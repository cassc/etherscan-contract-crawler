{"SourceCode": "/** \r\n *  SourceUnit: /Users/farhaan/repositories/maple/proxy-factory/contracts/Proxy.sol\r\n*/\r\n            \r\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: AGPL-3.0-only\r\npragma solidity ^0.8.7;\r\n\r\nabstract contract SlotManipulatable {\r\n\r\n    function _getReferenceTypeSlot(bytes32 slot_, bytes32 key_) internal pure returns (bytes32 value_) {\r\n        return keccak256(abi.encodePacked(key_, slot_));\r\n    }\r\n\r\n    function _getSlotValue(bytes32 slot_) internal view returns (bytes32 value_) {\r\n        assembly {\r\n            value_ := sload(slot_)\r\n        }\r\n    }\r\n\r\n    function _setSlotValue(bytes32 slot_, bytes32 value_) internal {\r\n        assembly {\r\n            sstore(slot_, value_)\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n/** \r\n *  SourceUnit: /Users/farhaan/repositories/maple/proxy-factory/contracts/Proxy.sol\r\n*/\r\n            \r\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: AGPL-3.0-only\r\npragma solidity ^0.8.7;\r\n\r\n/// @title An beacon that provides a default implementation for proxies, must implement IDefaultImplementationBeacon.\r\ninterface IDefaultImplementationBeacon {\r\n\r\n    /// @dev The address of an implementation for proxies.\r\n    function defaultImplementation() external view returns (address defaultImplementation_);\r\n\r\n}\r\n\r\n\r\n/** \r\n *  SourceUnit: /Users/farhaan/repositories/maple/proxy-factory/contracts/Proxy.sol\r\n*/\r\n\r\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: AGPL-3.0-only\r\npragma solidity ^0.8.7;\r\n\r\n////import { IDefaultImplementationBeacon } from \"./interfaces/IDefaultImplementationBeacon.sol\";\r\n\r\n////import { SlotManipulatable } from \"./SlotManipulatable.sol\";\r\n\r\n/// @title A completely transparent, and thus interface-less, proxy contract.\r\ncontract Proxy is SlotManipulatable {\r\n\r\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.factory') - 1`.\r\n    bytes32 private constant FACTORY_SLOT = bytes32(0x7a45a402e4cb6e08ebc196f20f66d5d30e67285a2a8aa80503fa409e727a4af1);\r\n\r\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\r\n    bytes32 private constant IMPLEMENTATION_SLOT = bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\r\n\r\n    /**\r\n     *  @dev   The constructor requires at least one of `factory_` or `implementation_`.\r\n     *         If an implementation is not provided, the factory is treated as an IDefaultImplementationBeacon\r\n     *         to fetch the default implementation.\r\n     *  @param factory_        The address of a proxy factory, if any.\r\n     *  @param implementation_ The address of the implementation contract being proxied, if any.\r\n     */\r\n    constructor(address factory_, address implementation_) {\r\n        _setSlotValue(FACTORY_SLOT, bytes32(uint256(uint160(factory_))));\r\n\r\n        // If the implementation is empty, fetch it from the factory, which can act as a beacon.\r\n        address implementation = implementation_ == address(0)\r\n            ? IDefaultImplementationBeacon(factory_).defaultImplementation()\r\n            : implementation_;\r\n\r\n        require(implementation != address(0));\r\n\r\n        _setSlotValue(IMPLEMENTATION_SLOT, bytes32(uint256(uint160(implementation))));\r\n    }\r\n\r\n    fallback() payable external virtual {\r\n        bytes32 implementation = _getSlotValue(IMPLEMENTATION_SLOT);\r\n\r\n        require(address(uint160(uint256(implementation))).code.length != uint256(0));\r\n\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize())\r\n\r\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\r\n\r\n            returndatacopy(0, 0, returndatasize())\r\n\r\n            switch result\r\n            case 0 {\r\n                revert(0, returndatasize())\r\n            }\r\n            default {\r\n                return(0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"}]", "ContractName": "Proxy", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000006fad515fc046dd17166453a79725f50b917b7cf60000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "1", "Implementation": "0x085176e2a201c90ce506be00bfc4f411bf9b3998", "SwarmSource": "ipfs://6a731915400432878d54bd0168588da912c447afb1999eac01f1b1977a676e80"}