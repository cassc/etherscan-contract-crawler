{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/gen1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n    MIT License\\n    Copyright (c) 2023 SomeGuy\\n*/\\npragma solidity ^0.8.19;\\n\\nerror WhenTheTimeIsRight();\\nerror YoureNotTheOwnerHomie();\\nerror GottaUnlockGen1Please();\\nerror ButTheseAintHiddenThough();\\nerror YooooThatTokenIdIsWayTooHigh();\\nerror SorryYouCantAbandonOwnershipToTheZeroAddress();\\n\\n\\n\\n/*\\n\\n     \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588       \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \\n    \u2588\u2588       \u2588\u2588    \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588  \u2588\u2588  \u2588\u2588      \\n    \u2588\u2588   \u2588\u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \\n    \u2588\u2588    \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588  \u2588\u2588       \u2588\u2588 \\n     \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \\n                                                                                        \\n                                                                                        \\n     \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588    \u2588\u2588        \u2588\u2588                                                \\n    \u2588\u2588       \u2588\u2588      \u2588\u2588\u2588\u2588   \u2588\u2588       \u2588\u2588\u2588                                                \\n    \u2588\u2588   \u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588\u2588\u2588\u2588  \u2588\u2588                                                \\n    \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588  \u2588\u2588 \u2588\u2588        \u2588\u2588                                                \\n     \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588\u2588\u2588        \u2588\u2588\\n\\n    \\n    circles and squares\\n    \ud83d\udfe1\ud83d\udfe5\\n\\n    by SomeGuy\\n\\n*/\\n\\ncontract goodblocksGen1\\n{\\n    // gen-1 description\\n    string private constant Gen1Description = unicode'who said circles and squares cant get along? welcome to gen-1 where these two shapes come together in unique harmony. you know the drill... enjoy the art, explore the code, and dont forget to click around for some extra fun! \ud83d\ude09 \ud83d\udfe8\ud83d\udfe5\ud83d\udfe6';\\n\\n\\n\\n    /*\\n\\n        \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588        \\n        \u2588\u2588         \u2588\u2588    \u2588\u2588    \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588             \\n        \u2588\u2588\u2588\u2588\u2588\u2588\u2588    \u2588\u2588    \u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588          \\n             \u2588\u2588    \u2588\u2588    \u2588\u2588    \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588             \\n        \u2588\u2588\u2588\u2588\u2588\u2588\u2588    \u2588\u2588     \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588        \\n                                                        \\n                                                        \\n        \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588                                   \\n        \u2588\u2588   \u2588\u2588 \u2588\u2588   \u2588\u2588                                  \\n        \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588                                  \\n        \u2588\u2588   \u2588\u2588 \u2588\u2588   \u2588\u2588                                  \\n        \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588   \u2588\u2588                 \\n               \\n                                                        \\n        \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588       \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \\n        \u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588  \u2588\u2588  \u2588\u2588      \\n        \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \\n        \u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588  \u2588\u2588       \u2588\u2588 \\n        \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n\\n    */\\n\\n    // contract owner \\n    address private ContractOwner;\\n    // original goodblocks contract\\n    IGBContract private GBTokenContract = IGBContract(address(0x29B4Ea6B1164C7cd8A3a0a1dc4ad88d1E0589124));\\n    /* \\n        optimization from gen-0 code:\\n        each bit is a flag for whether or not text should be white or black on the images\\n\\n        this number:\\n            00000001111111111100001000000110101000110111100010110000\\n        replaces these strings in the gen contract for optimization\\n            string private constant LabelFlags =\\n            \\\"00000001\\\"  // palette 0 Joy\\n            \\\"11111111\\\"  // palette 1 Night\\n            \\\"11000010\\\"  // palette 2 Cosmos\\n            \\\"00000110\\\"  // palette 3 Earth\\n            \\\"10100011\\\"  // palette 4 Arctic\\n            \\\"01111000\\\"  // palette 5 Serenity\\n            \\\"10110000\\\"; // palette 6 Twilight\\n    */\\n    uint256 private constant LabelFlags = 562683776825520;\\n    // reuse block symmetry weights\\n    uint256[] private BlockSymmetryWeights = [40,25,15,15,4,1];\\n    // reuse color group names\\n    string[7] private ColorGroupNames = [\\\"Joy\\\", \\\"Night\\\", \\\"Cosmos\\\", \\\"Earth\\\", \\\"Arctic\\\", \\\"Serenity\\\", \\\"Twilight\\\"];\\n    // reuse color group weights\\n    uint256[] private ColorGroupWeights = [30,10,20,10,25,30,15];\\n    /* \\n        optimization from gen-0 code:\\n        each uint256 represents a 4-color palette that is mapped to ascii characters\\n\\n        for example,\\n        Night 0\\n            uint256\\n                1183296175157854577031491632722463825992351302656747456068\\n            binary (padded to 192 length)\\n                001100000100001000110000010000100011000001000100001101000011011100110100010000010011010100110110001110010011001000111001010000010100000101000010010001000011001101000100001101010100011001000100\\n            ascii\\n                0B0B0D474A56929AABD3D5FD\\n            color palette\\n                #0B0B0D #474A56 #929AAB #D3D5FD\\n    */\\n    uint256[56] private ColorPalettes = \\n    [\\n        // 0 palette (Joy)        \\n        1722934404554201348729366417993644954268499892180661388600,\\n        // ['#FDFF8F','#A8ECE7','#F4BEEE','#D47AE8'],\\n        1722928418248847460524038327043022431014471111280592240963,\\n        // ['#FD6F96','#FFEBA1','#95DAC1','#6F69AC'],\\n        1723125218196464527198646930792784633471438866919854455108,\\n        // ['#FFDF6B','#FF79CD','#AA2EE6','#23049D'],\\n        1402738212716665681330154749417641799183811080661356593456,\\n        // ['#95E1D3','#EAFFD0','#FCE38A','#FF75A0'],\\n        1723124839644503782921222069990975963319678746178410133809,\\n        // ['#FFCC29','#F58634','#007965','#00AF91'],\\n        1403116499037504867228637477972569616281207095664540137028,\\n        // ['#998CEB','#77E4D4','#B4FE98','#FBF46D'],\\n        1698509881339924158818218547090721811442225106761431398197,\\n        // ['#EEEEEE','#77D970','#172774','#FF0075'],\\n        1181573994293619966810731042752478535937452576456742880307,\\n        // ['#005F99','#FF449F','#FFF5B7','#00EAD3'],\\n\\n        // 1 palette (Night)\\n        1183296175157854577031491632722463825992351302656747456068,\\n        // ['#0B0B0D','#474A56','#929AAB','#D3D5FD'],\\n        1182242562556626812122607221338801609399248306075785639732,\\n        // ['#07031A','#4F8A8B','#B1B493','#FFCB74'],\\n        1232624496385106213304636376314333012044247519742934988098,\\n        // ['#2E3A63','#665C84','#71A0A5','#FAB95B'],\\n        1181572091366904789282201902090920653963139822626228420920,\\n        // ['#000000','#226089','#4592AF','#E3C4A8'],\\n        1207816483819194660626624753928186438635106027164195632180,\\n        // ['#1B1F3A','#53354A','#A64942','#FF7844'],\\n        1210785733379461822760266649310303341232493204710845920305,\\n        // ['#1a1a1a','#153B44','#2D6E7E','#C6DE41'],\\n        1183679297598673735033245276169107883091480197076665910594,\\n        // ['#0F0A3C','#07456F','#009F9D','#CDFFEB'],\\n        1206379362946223673176236699366397918327115252264628204592,\\n        // ['#130026','#801336','#C72C41','#EE4540'],\\n        \\n        // 2 palette (Cosmos)\\n        1206188204395529784504373821286370393680112876317865816376,\\n        // ['#111D5E','#C70039','#F37121','#C0E218'],\\n        1181764787452334280973727296291940992808625784402829652801,\\n        // ['#02383C','#230338','#ED5107','#C70D3A'],\\n        1181866548967864296392515374823870372305589162777764968501,\\n        // ['#03C4A1','#C62A88','#590995','#150485'],\\n        1181578463622937915916884477042913908575131282466401431874,\\n        // ['#00A8CC','#005082','#000839','#FFA41B'],\\n        1697354125759019098874587460972843735496947121341899813445,\\n        // ['#E94560','#0F3460','#16213E','#1A1A2E'],\\n        1672170482535347701413567349811776693278328217919730758469,\\n        // ['#D2FAFB','#FE346E','#512B58','#2C003E'],\\n        1353213864613208291156955180757907990714862673150763807539,\\n        // ['#706C61','#E1F4F3','#FFFFFF','#333333'],\\n        1722647039797242987206907486689895518314237453093734396725,\\n        // ['#FAF7F2','#2BB3C0','#161C2E','#EF6C35'],\\n        \\n        // 3 palette (Earth)\\n        1723125960724730352591241524833495038198492338713211844403,\\n        // ['#FFFBE9','#E3CAA5','#CEAB93','#AD8B73'],\\n        1598414277963937531436118304205823216013870508573848846904,\\n        // ['#A09F57','#C56824','#CFB784','#EADEB8'],\\n        1696785419003103129465305528958529858836219135706396965187,\\n        // ['#E3D0B9','#E1BC91','#C19277','#62959C'],\\n        1697359742326961329795704250533301241360585844664883622452,\\n        // ['#E9C891','#8A8635','#AE431E','#D06224'],\\n        1378025605464422021827397574345536902253231127146057185586,\\n        // ['#83B582','#D6E4AA','#FFFFC5','#F0DD92'],\\n        1255133030464834789817026233978878414701123122015613568567,\\n        // ['#303E27','#B4BB72','#E7EAA8','#F6FAF7'],\\n        1599180132596406893561285739937078139222444185901121812786,\\n        // ['#A8896C','#F1E8A7','#AED09E','#61B292'],\\n        1721401160781475903301032372806804394112790122319723115573,\\n        // ['#F4DFBA','#EEC373','#CA965C','#876445'],\\n        \\n        // 4 palette (Arctic)\\n        1279850479717986101566374421011898284803750609483886642756,\\n        // ['#42C2FF','#85F4FF','#B8FFF9','#EFFFFD'],\\n        1697265072171141542916534444934787077291477130161358844978,\\n        // ['#E8F0F2','#A2DBFA','#39A2DB','#053742'],\\n        1257145528564464104373930541022632732747621545894209603142,\\n        // ['#3E64FF','#5EDFFF','#B2FCFF','#ECFCFF'],\\n        1672074708871527899905595150760089445681629758932940633666,\\n        // ['#D1FFFA','#4AA9AF','#3E31AE','#1C226B'],\\n        1721689224238219033220141417024881005610968517418405740857,\\n        // ['#F7F3F3','#C1EAF2','#5CC2F2','#191BA9'],\\n        1721306100353001166844721355424130832848268931432162083893,\\n        // ['#F3F3F3','#303841','#3A4750','#2185D5'],\\n        1353789677333435717167229733400735324241612031748483466819,\\n        // ['#769FCD','#B9D7EA','#D6E6F2','#F7FBFC'],\\n        1257049769492558230805482258810392444115501509870169966134,\\n        // ['#3D6CB9','#00D1FF','#00FFF0','#FAFAF6'],\\n        \\n        // 5 palette (Serenity)\\n        1403121739988174702800583195012373711618086044131908601414,\\n        // ['#99FEFF','#94DAFF','#94B3FD','#B983FF'],\\n        1696972117005731040492347755183146534302783978509605028674,\\n        // ['#E5707E','#E6B566','#E8E9A1','#A3DDCB'],\\n        1329461281397530506280402045629953962146120816058213549634,\\n        // ['#6892D5','#79D1C3','#C9FDD7','#F8FCFB'],\\n        1330513398814299447253626769393243188045317948896038697269,\\n        // ['#6C5B7B','#C06C84','#F67280','#F8B195'],\\n        1255133384165670211048503380421693678075219799238809633077,\\n        // ['#30475E','#BA6B57','#F1935C','#E7B2A5'],\\n        1723125586574466746505575984771607893125819988320632193347,\\n        // ['#FFEBD3','#264E70','#679186','#FFB4AC'],\\n        1330614793481988775794266785314624655591903298842748139825,\\n        // ['#6DDCCF','#94EBCD','#FFEFA1','#FFCB91'],\\n        1672744801525859670694077834043317089631871727545208619830,\\n        // ['#D8EFF0','#B0E0A8','#F0F69F','#F3C1C6'],\\n        \\n        // 6 palette (Twilight)\\n        1255612289033585437444993878451534470432700665266407880752,\\n        // ['#35477D','#6C5B7B','#C06C84','#F67280'],\\n        1721592316357852063982625679845008202349317682013842519366,\\n        // ['#F6C065','#55B3B1','#AF0069','#09015F'],\\n        1280322302022924147060513003728168238845485443276919292980,\\n        // ['#470D21','#9C0F48','#D67D3E','#F9E4D4'],\\n        1181572497692950828953760601853026334571312612200352531009,\\n        // ['#001F52','#A10054','#FF8D68','#FFECBA'],\\n        1723119975755435620157027839780780929332479594873347126342,\\n        // ['#FF6C00','#A0204C','#23103A','#282D4F'],\\n        1723125947553932544526123585201978692984733212900337332531,\\n        // ['#FFF9B2','#ECAC5D','#B24080','#3F0713'],\\n        1723125573352757813299695957060899475309511522981632947253,\\n        // ['#FFE98A','#C84771','#61105E','#280B45'],\\n        1698414081283041489814189444330070411452527498177335867715\\n        // ['#EDE862','#FA9856','#F27370','#22559C']\\n    ];\\n    // function to get color palette by index (0-55)\\n    function getColorPalette(uint256 index) public view returns(string[4] memory)\\n    {\\n        // initialize string array with # sign\\n        string[4] memory paletteArray = [\\\"#\\\", \\\"#\\\", \\\"#\\\", \\\"#\\\"];\\n        // get palette information\\n        uint256 palette = ColorPalettes[index];\\n        unchecked\\n        {\\n            // get 1st color\\n            for(uint256 i=0; i<6; ++i)\\n            {\\n                paletteArray[0] = string.concat(paletteArray[0], string(abi.encodePacked(bytes1(uint8((palette & (255 << ((24-1-i)*8))) >> ((24-1-i)*8))))));\\n            }\\n            // get 2nd color\\n            for(uint256 i=6; i<12; ++i)\\n            {   \\n                paletteArray[1] = string.concat(paletteArray[1], string(abi.encodePacked(bytes1(uint8((palette & (255 << ((24-1-i)*8))) >> ((24-1-i)*8))))));\\n            }\\n            // get 3rd color\\n            for(uint256 i=12; i<18; ++i)\\n            {   \\n                paletteArray[2] = string.concat(paletteArray[2], string(abi.encodePacked(bytes1(uint8((palette & (255 << ((24-1-i)*8))) >> ((24-1-i)*8))))));\\n            }\\n            // get 4th color\\n            for(uint256 i=18; i<24; ++i)\\n            {   \\n                paletteArray[3] = string.concat(paletteArray[3], string(abi.encodePacked(bytes1(uint8((palette & (255 << ((24-1-i)*8))) >> ((24-1-i)*8))))));\\n            }\\n            // return the palette array\\n            return paletteArray;\\n        }\\n    }\\n    /*\\n        weights for shape design\\n        index -> shape design\\n        0 - none\\n        1 - basic circle\\n        2 - basic square\\n        3 - repeated circle\\n        4 - repeated square\\n        5 - repeated, rotated square\\n        6 - repeated, rotated double square \\n    */\\n    uint256[] private ShapeDesignWeights = [40,50,50,20,20,50,50];\\n    // weights for repeated, rotated squares\\n    uint256[] private RotatedSquareWeights = [20,20,20,20,20];\\n\\n    /*\\n\\n        \u2588\u2588\u2588    \u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588  \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588               \\n        \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588  \u2588\u2588  \u2588\u2588                    \\n        \u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588                 \\n        \u2588\u2588  \u2588\u2588  \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588  \u2588\u2588  \u2588\u2588                    \\n        \u2588\u2588      \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588               \\n                                                        \\n                                                        \\n        \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588                                   \\n        \u2588\u2588   \u2588\u2588 \u2588\u2588   \u2588\u2588                                  \\n        \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588                                  \\n        \u2588\u2588   \u2588\u2588 \u2588\u2588   \u2588\u2588                                  \\n        \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588   \u2588\u2588                       \\n                                                        \\n                                                        \\n        \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588       \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \\n        \u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588  \u2588\u2588  \u2588\u2588      \\n        \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \\n        \u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588  \u2588\u2588       \u2588\u2588 \\n        \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \\n\\n    */\\n\\n    // struct for gen-1 block\\n    struct Gen1Block\\n    {\\n        uint256 index;\\n        uint256 numLevels;\\n        uint256 widthInterval;\\n        uint256 circleCount;\\n        uint256 squareCount;\\n        uint256 noneCount;\\n        uint256 complexityLevel;\\n        uint256 colorGroupIndex;\\n        uint256 paletteIndex;\\n        uint256 shapeDesign;\\n        bool isSpecial; \\n        bool glitchy;\\n        string svg;\\n        string name;\\n        string labelColor;\\n        string[4] palette;\\n    }\\n    // struct for gen-1 shape\\n    struct Gen1Shape\\n    {\\n        uint256 width;\\n        uint256 numIterations;\\n        uint256 numDegrees;\\n        uint256 rotationInterval;\\n        uint256 randSeed;\\n        uint256 fillColorIndex;\\n        uint256 strokeColorIndex;\\n        uint256 strokeWidth;\\n    }\\n    // get gen-1 block from token id\\n    function getBlockData(uint256 _tokenId) private view returns(Gen1Block memory)\\n    {\\n        unchecked\\n        {     \\n            // start up that block!\\n            Gen1Block memory blockData;\\n            // set token index\\n            blockData.index = _tokenId;\\n            // set num levels\\n            blockData.numLevels = (GBUtils.random(string.concat(GBUtils.toString(_tokenId), \\\"create x innovate x impact - do some good\\\"))%4) + 5;\\n            // set interval\\n            blockData.widthInterval = 3000/blockData.numLevels;\\n            // set color group\\n            blockData.colorGroupIndex = GBUtils.getWeightedItem(ColorGroupWeights, GBUtils.random(GBUtils.toString(_tokenId + 1)) % 140);\\n            // set palette index\\n            blockData.paletteIndex = uint8(GBUtils.random(string(abi.encodePacked(\\\"Wth?\\\", GBUtils.toString(_tokenId + 4)))) % 8);\\n            // set all palette index\\n            uint256 allPaletteIndex = blockData.colorGroupIndex*8+blockData.paletteIndex;\\n            // set color palette\\n            blockData.palette = getColorPalette(allPaletteIndex);\\n            // set glitchy\\n            blockData.glitchy = GBUtils.getWeightedItem(BlockSymmetryWeights, GBUtils.random(GBUtils.toString(_tokenId + 22)) % 100) == 5;\\n            // set special status\\n            if(_tokenId > 2132 && _tokenId < 6121)\\n            {\\n                // 68 > x > 22\\n                // 2093 < x < 6187\\n                // 2132 < x < 6121\\n                if(((1 << (256-((_tokenId-2093)-(256*((_tokenId-2093)/256))))-1) & dg[((_tokenId-2093)/256)]) >> (256-((_tokenId-2093)-(256*((_tokenId-2093)/256)))-1) == 0)\\n                {\\n                    blockData.isSpecial = false;\\n                } else\\n                {\\n                    blockData.isSpecial = true;\\n                }            \\n            } else \\n            {\\n                blockData.isSpecial = false;\\n            }\\n            // set label color\\n            blockData.labelColor = blockData.isSpecial ? '#fff' : GBUtils.readBitBool(LabelFlags, (55-allPaletteIndex)) ? '#fff' : '#000';\\n            // set block name\\n            blockData.name = string.concat(ColorGroupNames[blockData.colorGroupIndex], \\\" #\\\", GBUtils.toString(_tokenId));\\n            // return da block\\n            return blockData;\\n        }\\n    }\\n    // get shape data\\n    function getShapeData(uint256 _tokenId, uint256 _seed, bool _repeated, bool _rotated) private view returns(Gen1Shape memory)\\n    {\\n        unchecked\\n        {\\n            Gen1Shape memory shapeData;\\n            string memory tokenIdString = GBUtils.toString(_tokenId + _seed*213 + 104);\\n            \\n            // get fill color\\n            shapeData.fillColorIndex = GBUtils.random(tokenIdString) % 4;\\n            \\n            if(_repeated)\\n            {\\n                // set stroke color (ensure different)\\n                shapeData.strokeColorIndex = shapeData.fillColorIndex == 3 ? 0 : shapeData.fillColorIndex + 1;\\n                // check if rotated\\n                if(_rotated)\\n                {\\n                    shapeData.numDegrees = (GBUtils.random(string.concat(tokenIdString, \\\"how many degrees are we rotating?\\\"))%136)+45;\\n                    shapeData.numIterations = (GBUtils.random(string.concat(tokenIdString, \\\"how many times are we spinning?\\\"))%21)+40;\\n                    // get rand seed\\n                    shapeData.randSeed = GBUtils.getWeightedItem(RotatedSquareWeights, GBUtils.random(string.concat(unicode\\\"what will you get? \ud83e\udd14\\\", GBUtils.toString(_seed*7 + _tokenId)))%100);\\n                    // set stroke width\\n                    shapeData.strokeWidth = _seed == 0 ? 200 : 300/(_seed+1);\\n                    \\n                } else\\n                {\\n                    // set rotation\\n                    shapeData.numDegrees = 0;\\n                    // get number of iterations\\n                    shapeData.numIterations = (GBUtils.random(string.concat(tokenIdString, \\\"how many times are we spinning?\\\"))%10)+5;\\n                    // set stroke width\\n                    shapeData.strokeWidth = _seed == 0 ? 50 : 50/_seed;\\n                }            \\n            } else\\n            {\\n                // get stroke color (can be same)\\n                shapeData.strokeColorIndex = GBUtils.random(string.concat(GBUtils.toString(_tokenId +_seed), \\\"a little extra\\\")) % 4;\\n                // get stroke width\\n                shapeData.strokeWidth = 50;\\n            }\\n            return shapeData;\\n        }\\n    }\\n    // get shape design\\n    function getShapeDesign(uint256 _seed, uint256 _limit) private view returns(uint256)\\n    {\\n        return GBUtils.getWeightedItem(ShapeDesignWeights, GBUtils.random(string.concat(\\\"its a good day\\\", GBUtils.toString(_seed*13 << 27), \\\"to have a good day\\\"))%_limit);\\n    }\\n    // svg strings\\n    string[13] private SvgPieces;\\n    // update svg strings\\n    function updateSvgPiece(uint256 _index, string memory _text) external onlyOwner\\n    {\\n        // update svg string\\n        SvgPieces[_index] = _text;\\n    }\\n    // metadata strings\\n    string[23] private MetadataPieces = \\n    [\\n        'data:application/json,{\\\"name\\\":\\\"',                  // 0\\n        '\\\",\\\"description\\\":\\\"',                                // 1            \\n        '\\\",',                                               // 2\\n        ',\\\"attributes\\\":[',                                  // 3\\n        '],\\\"image\\\":\\\"data:image/svg+xml;base64,',            // 4                        \\n        '\\\"}',                                               // 5\\n        '{\\\"trait_type\\\": \\\"Generations Unlocked\\\", \\\"value\\\":',  // 6                                \\n        '},{\\\"trait_type\\\": \\\"Active Generation\\\", \\\"value\\\":\\\"',  // 7                                \\n        '\\\"},{\\\"trait_type\\\": \\\"Times Transferred\\\", \\\"value\\\":\\\"', // 8                                \\n        '\\\"},{\\\"trait_type\\\": \\\"Owned Since\\\", \\\"value\\\":\\\"',       // 9                            \\n        '\\\"},{\\\"trait_type\\\": \\\"Color Group\\\", \\\"value\\\":\\\"',       // 10                            \\n        '\\\"},{\\\"trait_type\\\": \\\"Palette Index\\\", \\\"value\\\":\\\"',     // 11                           \\n        '\\\"},{\\\"trait_type\\\": \\\"Shape Groups\\\", \\\"value\\\":\\\"',      // 12                           \\n        '\\\"},{\\\"trait_type\\\": \\\"Circles\\\", \\\"value\\\":\\\"',           // 13                       \\n        '\\\"},{\\\"trait_type\\\": \\\"Squares\\\", \\\"value\\\":\\\"',           // 14                       \\n        '\\\"},{\\\"trait_type\\\": \\\"Blanks\\\", \\\"value\\\":\\\"',            // 15                       \\n        '\\\"},{\\\"trait_type\\\": \\\"Complexity\\\", \\\"value\\\":\\\"',        // 16                           \\n        '\\\"},{\\\"trait_type\\\": \\\"Glitchy\\\", \\\"value\\\":\\\"',           // 17                   \\n        'True',                                             // 18                           \\n        'False',                                            // 19\\n        '\\\"},{\\\"trait_type\\\": \\\"Special Trait\\\", \\\"value\\\":\\\"',     // 20\\n        'Do Good\\\"}',                                        // 21\\n        'None\\\"}'                                            // 22\\n    ];\\n    // update metadata strings\\n    function updateMetadataPiece(uint256 _index, string memory _text) external onlyOwner\\n    {\\n        // update svg string\\n        MetadataPieces[_index] = _text;\\n    }\\n    // struct for circle data\\n    struct circleData\\n    {\\n        uint256 radius;\\n        string fill;\\n        string strokeFill;\\n        uint256 strokeWidth;\\n    }\\n    // circle strings\\n    string[5] private CirclePieces = \\n    [\\n        \\\"<circle  cx='2000' cy='2000' r='\\\", // 0\\n        \\\"' fill='\\\",                         // 1\\n        \\\"' stroke-width='\\\",                 // 2\\n        \\\"' stroke='\\\",                       // 3\\n        \\\"'>\\\"                                // 4\\n        \\\"</circle>\\\"\\n        \\\"\\\"\\n    ];\\n    // update circle strings\\n    function updateCirclePiece(uint256 _index, string memory _text) external onlyOwner\\n    {\\n        CirclePieces[_index] = _text;\\n    }\\n    // draw circle\\n    function drawCircle(circleData memory _circleData) private view returns(string memory)\\n    {\\n        // start svg\\n        string memory outputSVG = string.concat(\\n            CirclePieces[0],\\n            // add radius\\n            GBUtils.toString(_circleData.radius),\\n            // add fill\\n            CirclePieces[1],\\n            _circleData.fill,\\n            // add stroke width\\n            CirclePieces[2],\\n            GBUtils.toString(_circleData.strokeWidth),\\n            // add stroke fill\\n            CirclePieces[3],\\n            _circleData.strokeFill,\\n            // close\\n            CirclePieces[4]\\n        );\\n\\n        return outputSVG;\\n    }\\n    // struct for square data\\n    struct SquareData\\n    {\\n        uint256 width;\\n        uint256 height;\\n        string startX;\\n        string startY;\\n        string strokeWidth;\\n        string fill;\\n        string strokeFill;\\n        string strWidth;\\n        string strHeight;\\n        string rotation;\\n    }\\n    // square strings\\n    string[9] private SquarePieces = \\n    [\\n        \\\"<rect x='\\\",                // 0\\n        \\\"' y='\\\",                    // 1\\n        \\\"' width='\\\",                // 2\\n        \\\"' height='\\\",               // 3\\n        \\\"' fill='\\\",                 // 4\\n        \\\"' stroke-width='\\\",         // 5\\n        \\\"' stroke='\\\",               // 6\\n        \\\"' transform='rotate(\\\",     // 7\\n        \\\" 2000 2000)'>\\\"             // 8\\n        \\\"</rect>\\\"\\n        \\\"\\\"  \\n    ];\\n    // update square strings\\n    function updateSquarePiece(uint256 _index, string memory _text) external onlyOwner\\n    {\\n        SquarePieces[_index] = _text;\\n    }\\n    // draw square\\n    function drawSquare(SquareData memory _squareData) private view returns(string memory)\\n    {       \\n        // start svg\\n        string memory outputSVG = string.concat(\\n            // add x\\n            SquarePieces[0],\\n            _squareData.startX,\\n            // add y\\n            SquarePieces[1],\\n            _squareData.startY,\\n            // add width\\n            SquarePieces[2],\\n            _squareData.strWidth,\\n            // add height\\n            SquarePieces[3],\\n            _squareData.strHeight\\n        );\\n        // continue square...\\n        outputSVG = string.concat(\\n            outputSVG,\\n            // add fill\\n            SquarePieces[4],\\n            _squareData.fill,\\n            // add stroke width\\n            SquarePieces[5],\\n            _squareData.strokeWidth,\\n            // add stroke width\\n            SquarePieces[6],\\n            _squareData.strokeFill,\\n            // add rotation\\n            SquarePieces[7],\\n            _squareData.rotation,\\n            // close\\n            SquarePieces[8]\\n        );\\n\\n        return outputSVG;\\n    }\\n    // repeated center square\\n    function simpleRepeatedSquare(Gen1Shape memory _shapeData, SquareData memory _squareData, uint256 _width) private view returns(string memory)\\n    {\\n        unchecked\\n        {\\n            // get interval\\n            uint256 widthInterval = _width/_shapeData.numIterations;\\n            string memory svg;\\n            // loop through and add squares\\n            for(uint256 i = 0; i<_shapeData.numIterations; ++i)\\n            {\\n                // update dimensions\\n                _squareData.width = (widthInterval)*(_shapeData.numIterations-i);\\n                _squareData.height = _squareData.width;\\n                _squareData.strWidth = GBUtils.toString(_squareData.width);\\n                _squareData.strHeight = _squareData.strWidth;\\n                _squareData.startX = GBUtils.toString(2000 - _squareData.width/2);\\n                _squareData.startY = _squareData.startX;\\n                // add square to svg\\n                svg = string.concat(svg, drawSquare(_squareData));\\n            }\\n            return svg;    \\n        }\\n        \\n    }\\n    // repeated squares in alternating directions\\n    function doubleRepeatedSquare(Gen1Shape memory _shapeData, SquareData memory _squareData, uint256 _width) private view returns(string memory)\\n    {\\n        unchecked\\n        {\\n            // start svg\\n            string memory svg;\\n            // temporary square string\\n            string memory tempSquare;\\n            // interval for each rotation\\n            uint256 rotationInterval = _shapeData.numDegrees/_shapeData.numIterations;\\n            // interval for each square width\\n            uint256 widthInterval = _width/_shapeData.numIterations;\\n            // loop through and add squares\\n            for(uint256 i = 0; i<_shapeData.numIterations; ++i)\\n            {\\n                // update dimensions\\n                _squareData.width = (widthInterval)*(_shapeData.numIterations-i);\\n                _squareData.height = _squareData.width;\\n                _squareData.strWidth = GBUtils.toString(_squareData.width);\\n                _squareData.strHeight = _squareData.strWidth;\\n                _squareData.startX = GBUtils.toString(2000 - _squareData.width/2);\\n                _squareData.startY = _squareData.startX;\\n                // update rotation\\n                _squareData.rotation = GBUtils.toString((rotationInterval)*i);\\n                tempSquare = drawSquare(_squareData);\\n                _squareData.rotation = string.concat(\\\"-\\\", _squareData.rotation);\\n                // add to svg\\n                svg = string.concat(\\n                    svg, \\n                    tempSquare,\\n                    drawSquare(_squareData)\\n                ); \\n            }\\n            return svg;\\n        }   \\n    }\\n    // squares repeated in same direction but more fun\\n    function getRepeatedSquare(Gen1Shape memory _shapeData, SquareData memory _squareData, uint256 _width) private view returns(string memory)\\n    {\\n        unchecked \\n        {\\n            // start svg\\n            string memory svg;\\n            // interval for square rotation\\n            uint256 rotationInterval = (_shapeData.numDegrees*100)/_shapeData.numIterations;\\n            // interval for square width\\n            uint256 widthInterval = (_width - ((_width)/10))/_shapeData.numIterations;\\n            // temporary rotation\\n            uint256 tempRotation;\\n            // store square strings here to avoid multiple string.concat\\n            string[5] memory tempSquares;\\n\\n            // double square, same direction, 15\u00b0 apart\\n            if(_shapeData.randSeed == 0)\\n            {\\n                // loop through and add squares\\n                for(uint256 i = 0; i<_shapeData.numIterations; ++i)\\n                {\\n                    // temporary rotation\\n                    tempRotation = (rotationInterval)*i;\\n                    // update dimensions\\n                    _squareData.width = (widthInterval)*(_shapeData.numIterations-i);\\n                    _squareData.strWidth = GBUtils.toString(_squareData.width);\\n                    _squareData.height = _squareData.width;\\n                    _squareData.strHeight = _squareData.strWidth;\\n                    _squareData.startX = GBUtils.toString(2000 - _squareData.width/2);\\n                    _squareData.startY = _squareData.startX;\\n                    // update rotation\\n                    _squareData.rotation = addDecimalFromTheRight(tempRotation, 2);\\n                    // add first square\\n                    tempSquares[0] = drawSquare(_squareData);\\n                    // update rotation\\n                    _squareData.rotation = addDecimalFromTheRight(tempRotation+1500, 2);\\n                    // add to svg\\n                    svg = string.concat(\\n                        svg,\\n                        tempSquares[0],\\n                        drawSquare(_squareData)\\n                    );\\n                }\\n\\n            // double square, same direction, 45\u00b0 apart\\n            } else if(_shapeData.randSeed == 1)\\n            {\\n                // loop through and add squares\\n                for(uint256 i = 0; i<_shapeData.numIterations; ++i)\\n                {\\n                    // temporary rotation\\n                    tempRotation = (rotationInterval)*i;\\n                    // update dimensions\\n                    _squareData.width = (widthInterval)*(_shapeData.numIterations-i);\\n                    _squareData.strWidth = GBUtils.toString(_squareData.width);\\n                    _squareData.height = _squareData.width;\\n                    _squareData.strHeight = _squareData.strWidth;\\n                    _squareData.startX = GBUtils.toString(2000 - _squareData.width/2);\\n                    _squareData.startY = _squareData.startX;\\n                    // update rotation\\n                    _squareData.rotation = addDecimalFromTheRight(tempRotation, 2);\\n                    // add first square\\n                    tempSquares[0] = drawSquare(_squareData);\\n                    // update rotation\\n                    _squareData.rotation = addDecimalFromTheRight(tempRotation+4500, 2);\\n                    // add to svg\\n                    svg = string.concat(\\n                        svg,\\n                        tempSquares[0],\\n                        drawSquare(_squareData)\\n                    );\\n                }\\n            \\n            // 3 squares, same direction, 0\u00b0 30\u00b0 60\u00b0\\n            } else if(_shapeData.randSeed == 2)\\n            {\\n                // loop through and add squares\\n                for(uint256 i = 0; i<_shapeData.numIterations; ++i)\\n                {\\n                    // temporary rotation\\n                    tempRotation = (rotationInterval)*i;\\n                    // update dimensions\\n                    _squareData.width = (widthInterval)*(_shapeData.numIterations-i);\\n                    _squareData.strWidth = GBUtils.toString(_squareData.width);\\n                    _squareData.height = _squareData.width;\\n                    _squareData.strHeight = _squareData.strWidth;\\n                    _squareData.startX = GBUtils.toString(2000 - _squareData.width/2);\\n                    _squareData.startY = _squareData.startX;\\n                    // update rotation\\n                    _squareData.rotation = addDecimalFromTheRight(tempRotation, 2);\\n                    // add first square\\n                    tempSquares[0] = drawSquare(_squareData);\\n                    // update rotation\\n                    _squareData.rotation = addDecimalFromTheRight(tempRotation+3000, 2);\\n                    // add second square\\n                    tempSquares[1] = drawSquare(_squareData);\\n                    // update rotation\\n                    _squareData.rotation = addDecimalFromTheRight(tempRotation+6000, 2);\\n                    // add to svg\\n                    svg = string.concat(\\n                        svg,\\n                        tempSquares[0],\\n                        tempSquares[1],\\n                        drawSquare(_squareData)\\n                    );\\n                }\\n                \\n            // 4 squares, same direction, 0\u00b0 22\u00b0 45\u00b0 68\u00b0\\n            } else if(_shapeData.randSeed == 3)\\n            {\\n                // loop through and add squares\\n                for(uint256 i = 0; i<_shapeData.numIterations; ++i)\\n                {\\n                    // temporary rotation\\n                    tempRotation = (rotationInterval)*i;\\n                    // update dimensions\\n                    _squareData.width = (widthInterval)*(_shapeData.numIterations-i);\\n                    _squareData.strWidth = GBUtils.toString(_squareData.width);\\n                    _squareData.height = _squareData.width;\\n                    _squareData.strHeight = _squareData.strWidth;\\n                    _squareData.startX = GBUtils.toString(2000 - _squareData.width/2);\\n                    _squareData.startY = _squareData.startX;\\n                    // update rotation\\n                    _squareData.rotation = addDecimalFromTheRight(tempRotation, 2);\\n                    // add first square\\n                    tempSquares[0] = drawSquare(_squareData);\\n                    // update rotation                            \\n                    _squareData.rotation = addDecimalFromTheRight(tempRotation+2200, 2);\\n                    // add second square\\n                    tempSquares[1] = drawSquare(_squareData);\\n                    // update rotation        \\n                    _squareData.rotation = addDecimalFromTheRight(tempRotation+4500, 2);\\n                    // add third square\\n                    tempSquares[2] = drawSquare(_squareData);\\n                    // update rotation        \\n                    _squareData.rotation = addDecimalFromTheRight(tempRotation+6800, 2);\\n                    // add to svg\\n                    svg = string.concat(\\n                        svg,\\n                        tempSquares[0],\\n                        tempSquares[1],\\n                        tempSquares[2],\\n                        drawSquare(_squareData)\\n                    );\\n                }\\n\\n            // 6 squares, same direction, 0\u00b0 15\u00b0 30\u00b0 45\u00b0 60\u00b0 75\u00b0\\n            } else if(_shapeData.randSeed == 4)\\n            {\\n                // loop through and add squares\\n                for(uint256 i = 0; i<_shapeData.numIterations; ++i)\\n                {\\n                    // temporary rotation\\n                    tempRotation = (rotationInterval)*i;\\n                    // update dimensions\\n                    _squareData.width = (widthInterval)*(_shapeData.numIterations-i);\\n                    _squareData.strWidth = GBUtils.toString(_squareData.width);\\n                    _squareData.height = _squareData.width;\\n                    _squareData.strHeight = _squareData.strWidth;\\n                    _squareData.startX = GBUtils.toString(2000 - _squareData.width/2);\\n                    _squareData.startY = _squareData.startX;\\n                    // update rotation\\n                    _squareData.rotation = addDecimalFromTheRight(tempRotation, 2);\\n                    // add first square\\n                    tempSquares[0] = drawSquare(_squareData);\\n                    // update rotation    \\n                    _squareData.rotation = addDecimalFromTheRight(tempRotation+1500, 2);\\n                    // add second square\\n                    tempSquares[1] = drawSquare(_squareData);\\n                    // update rotation                        \\n                    _squareData.rotation = addDecimalFromTheRight(tempRotation+3000, 2);\\n                    // add third square\\n                    tempSquares[2] = drawSquare(_squareData);\\n                    // update rotation    \\n                    _squareData.rotation = addDecimalFromTheRight(tempRotation+4500, 2);\\n                    // add fourth square\\n                    tempSquares[3] = drawSquare(_squareData);\\n                    // update rotation    \\n                    _squareData.rotation = addDecimalFromTheRight(tempRotation+6000, 2);\\n                    // add fifth square\\n                    tempSquares[4] = drawSquare(_squareData);\\n                    // update rotation                        \\n                    _squareData.rotation = addDecimalFromTheRight(tempRotation+7500, 2);\\n                    // add to svg\\n                    svg = string.concat(\\n                        svg,\\n                        tempSquares[0],\\n                        tempSquares[1],\\n                        tempSquares[2],\\n                        tempSquares[3],\\n                        tempSquares[4],\\n                        drawSquare(_squareData)\\n                    );\\n                }\\n            }\\n            return svg;\\n        }   \\n    }\\n    // get repeated circles\\n    function getRepeatedCircle(Gen1Shape memory _shapeData, circleData memory _circleData, uint256 _width) private view returns(string memory)\\n    {\\n        // start svg\\n        string memory svg;\\n        // loop through and add circles\\n        for(uint256 i = 0; i<_shapeData.numIterations; ++i)\\n        {   \\n            // get radius                 \\n            _circleData.radius = ((_width/_shapeData.numIterations)*(_shapeData.numIterations-i))/2;\\n            // draw circle\\n            svg = string.concat(svg, drawCircle(_circleData));\\n        }\\n        return svg;\\n    }\\n    // create token data string for token js\\n    function getTokenDataString(IGBContract.TokenData memory _tokenData, Gen1Block memory _gen1Block) private view returns(string memory)\\n    {        \\n        // start token data string for token\\n        string memory tokenDataString = string.concat(\\n            GBUtils.toString(_gen1Block.index),\\n            '|',\\n            _gen1Block.name,\\n            '|',\\n            GBUtils.toHexString(_tokenData.tokenOwner),\\n            '|',\\n            GBUtils.toString(_tokenData.ownedSince),\\n            '|',\\n            GBUtils.toString(_tokenData.timesTransferred),\\n            '|',\\n            GBUtils.toString(_tokenData.highestGenLevel + 1),\\n            '|',\\n            GBUtils.toString(_tokenData.activeGen),\\n            '|',\\n            ColorGroupNames[_gen1Block.colorGroupIndex],\\n            '|',\\n            GBUtils.toString(_gen1Block.paletteIndex),\\n            '|'\\n        );\\n        // continue data string\\n        return string.concat(\\n            tokenDataString,\\n            GBUtils.toString(_gen1Block.numLevels),\\n            '|',\\n            GBUtils.toString(_gen1Block.circleCount),\\n            '|',\\n            GBUtils.toString(_gen1Block.squareCount),\\n            '|',\\n            GBUtils.toString(_gen1Block.noneCount),\\n            '|',\\n            GBUtils.toString(_gen1Block.complexityLevel),\\n            '|',\\n            _gen1Block.glitchy ? 'true' : 'false',\\n            '|',\\n            _gen1Block.isSpecial ? 'do good' : 'none',\\n            '|',\\n            _gen1Block.palette[0],\\n            '|',\\n            _gen1Block.palette[1],\\n            '|',\\n            _gen1Block.palette[2],\\n            '|',\\n            _gen1Block.palette[3]\\n        );\\n    }\\n    // get metadata for gen-1 block\\n    function blockToMetadata(IGBContract.TokenData memory _tokenData, Gen1Block memory _gen1Block, string memory _tokenAttributes) private view returns(string memory)\\n    {\\n        // get attribute substring\\n        string[2] memory ogAttributes = cleanAttributes(_tokenAttributes);\\n        // start metadata\\n        string memory metadata = string.concat(\\n            MetadataPieces[6],      // {\\\"trait_type\\\": \\\"Generations Unlocked\\\", \\\"value\\\":,\\n            GBUtils.toString(_tokenData.highestGenLevel+1),\\n            MetadataPieces[7],      // },{\\\"trait_type\\\": \\\"Active Generation\\\", \\\"value\\\":\\\",\\n            GBUtils.toString(_tokenData.activeGen),\\n            MetadataPieces[8],      // \\\"},{\\\"trait_type\\\": \\\"Times Transferred\\\", \\\"value\\\":\\\",\\n            ogAttributes[0],\\n            MetadataPieces[9],      // \\\"},{\\\"trait_type\\\": \\\"Owned Since\\\", \\\"value\\\":\\\",\\n            ogAttributes[1]\\n        );\\n        metadata = string.concat(\\n            metadata,\\n            MetadataPieces[10],      // \\\"},{\\\"trait_type\\\": \\\"Color Group\\\", \\\"value\\\":\\\",\\n            ColorGroupNames[_gen1Block.colorGroupIndex],\\n            MetadataPieces[11],      // \\\"},{\\\"trait_type\\\": \\\"Palette Index\\\", \\\"value\\\":\\\",\\n            GBUtils.toString(_gen1Block.paletteIndex),\\n            MetadataPieces[12],      // \\\"},{\\\"trait_type\\\": \\\"Shape Groups\\\", \\\"value\\\":\\\",\\n            GBUtils.toString(_gen1Block.numLevels),\\n            MetadataPieces[13],      // \\\"},{\\\"trait_type\\\": \\\"Circles\\\", \\\"value\\\":\\\",\\n            GBUtils.toString(_gen1Block.circleCount)\\n        );\\n        metadata = string.concat(\\n            metadata,\\n            MetadataPieces[14],      // \\\"},{\\\"trait_type\\\": \\\"Squares\\\", \\\"value\\\":\\\",\\n            GBUtils.toString(_gen1Block.squareCount),\\n            MetadataPieces[15],      // \\\"},{\\\"trait_type\\\": \\\"Blanks\\\", \\\"value\\\":\\\",\\n            GBUtils.toString(_gen1Block.noneCount),\\n            MetadataPieces[16],      // \\\"},{\\\"trait_type\\\": \\\"Complexity\\\", \\\"value\\\":\\\",\\n            GBUtils.toString(_gen1Block.complexityLevel),\\n            MetadataPieces[17],      // \\\"},{\\\"trait_type\\\": \\\"Glitchy\\\", \\\"value\\\":\\\",\\n            _gen1Block.glitchy ? MetadataPieces[18] : MetadataPieces[19], // true false\\n            MetadataPieces[20],      // \\\"},{\\\"trait_type\\\": \\\"Special Trait\\\", \\\"value\\\":\\\",\\n            _gen1Block.isSpecial ? MetadataPieces[21] : MetadataPieces[22] // Do Good\\\"} : None\\\"}\\n        );\\n        // return metadata string\\n        return metadata;\\n    }\\n    // function to add decimals to a number\\n    function addDecimalFromTheRight(uint256 _number, uint256 _sigFigs) private pure returns(string memory)\\n    {\\n        string memory numString = GBUtils.toString(_number);\\n        uint256 length = bytes(numString).length;\\n        bytes memory decimal = new bytes(_sigFigs);   \\n        // check if sig fig greater thant length (0 padded)\\n        if(_sigFigs > length)\\n        {\\n            for(uint256 i=_sigFigs-1; i>0; --i)\\n            {\\n                if(i < _sigFigs-length)\\n                {\\n                    decimal[i] = bytes('0')[0];\\n                } else\\n                {\\n                    decimal[i] = bytes(numString)[i-(_sigFigs-length)];\\n                }\\n            }\\n            decimal[0] = '0';\\n            return string.concat('0', '.', string(decimal));\\n        // sig figs is = length\\n        } else if(_sigFigs == length)\\n        {\\n            return string.concat('0', '.', numString);\\n        // sig figs < length\\n        } else\\n        {\\n            uint256 wholeIndex;\\n            uint256 decimalIndex;\\n            bytes memory whole = new bytes(length-_sigFigs);\\n            for(uint256 i=0; i<length; ++i)\\n            {\\n                if(i < length-_sigFigs)\\n                {\\n                    whole[wholeIndex] = bytes(numString)[i];\\n                    wholeIndex++;\\n                } else\\n                {\\n                    decimal[decimalIndex] = bytes(numString)[i];\\n                    decimalIndex++;\\n                }\\n            }\\n            return string.concat(string(whole), '.', string(decimal));\\n        }\\n    }\\n    // attribute data struct to help clean original contract metadata\\n    struct AttData\\n    {\\n        uint256 ownedStart;\\n        uint256 ownedEnd;\\n        uint256 ownedLength;\\n        uint256 transferStart;\\n        uint256 transferEnd;\\n        uint256 transferLength;\\n    }\\n    // function to clean original attributes\\n    function cleanAttributes(string memory _attributes) public pure returns(string[2] memory)\\n    {\\n        uint256 i;\\n        bytes memory attBytes = bytes(_attributes);\\n        AttData memory attData;\\n        // get time owned attribute\\n        attData.ownedEnd = attBytes.length-3;\\n        for(i=attData.ownedEnd; i>0; --i)\\n        {\\n            if(attBytes[i] == bytes1('\\\"'))\\n            {\\n                attData.ownedStart = i+1;\\n                attData.ownedLength = (attData.ownedEnd-attData.ownedStart+1);\\n                break;\\n            }\\n        }\\n        // get times transfrerred attribute\\n        attData.transferEnd = attData.ownedStart-43;\\n        for(i=attData.transferEnd; i>0; --i)\\n        {\\n            if(attBytes[i] == bytes1('\\\"'))\\n            {\\n                attData.transferStart = i+1;\\n                attData.transferLength = (attData.transferEnd-attData.transferStart+1);\\n                break;\\n            }            \\n        }\\n\\n        bytes memory timesTransferredBytes = new bytes(attData.transferLength);\\n        bytes memory ownedSinceBytes = new bytes(attData.ownedLength);\\n        \\n        for(i=0; i<attData.transferLength; ++i)\\n        {\\n            timesTransferredBytes[i] = attBytes[attData.transferStart + i];\\n        }\\n        \\n        for(i=0; i<attData.ownedLength; ++i)\\n        {\\n            ownedSinceBytes[i] = attBytes[attData.ownedStart + i];\\n        }\\n\\n        // return attributes\\n        return [string(timesTransferredBytes), string(ownedSinceBytes)];\\n    }\\n    \\n\\n\\n    /*\\n\\n        \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588  \u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588          \\n        \u2588\u2588      \u2588\u2588   \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588               \\n        \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588            \\n             \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588               \\n        \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588          \\n                                                        \\n                                                        \\n        \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588                                   \\n        \u2588\u2588   \u2588\u2588 \u2588\u2588   \u2588\u2588                                  \\n        \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588                                  \\n        \u2588\u2588   \u2588\u2588 \u2588\u2588   \u2588\u2588                                  \\n        \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588   \u2588\u2588                                  \\n                                                        \\n                                                        \\n        \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588       \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \\n        \u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588  \u2588\u2588  \u2588\u2588      \\n        \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \\n        \u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588  \u2588\u2588       \u2588\u2588 \\n        \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n\\n    */    \\n\\n\\n\\n\\n    // token uri for gen-1\\n    function tokenGenURI(uint256 _tokenId, string memory _tokenMetadata, string memory _tokenAttributes) public view returns(string memory)\\n    {\\n        // check if valid token ID\\n        if(_tokenId > 8280) revert YooooThatTokenIdIsWayTooHigh();\\n        // get token data from original contract\\n        IGBContract.TokenData memory tokenData = GBTokenContract.getTokenData(_tokenId);\\n        // check if gen-1 has been unlocked\\n        //if(tokenData.highestGenLevel < 1) revert GottaUnlockGen1Please();        \\n        // get gen 1 block\\n        Gen1Block memory blockData = getBlockData(_tokenId);\\n        string memory svg = getTokenSvg(_tokenId, tokenData, blockData);\\n        // return token uri\\n        return string.concat(\\n            // name\\n            MetadataPieces[0],\\n            blockData.name,\\n            // description\\n            MetadataPieces[1],\\n            Gen1Description,\\n            // metadata\\n            MetadataPieces[2],\\n            _tokenMetadata,\\n            // attributes\\n            MetadataPieces[3],\\n            blockToMetadata(tokenData, blockData, _tokenAttributes),\\n            // image\\n            MetadataPieces[4],\\n            GBUtils.encode(bytes(svg)),\\n            // close\\n            MetadataPieces[5]\\n        );\\n    }\\n    // get token svg\\n    function getTokenSvg(uint256 _tokenId, IGBContract.TokenData memory _tokenData, Gen1Block memory _blockData) private view returns(string memory)\\n    {\\n        /*\\n            same color group as gen0\\n            chaos gets a little funky\\n            specials are still special\\n            lets go....\\n        */\\n\\n        // declare temporary square and circle variables\\n        SquareData memory tempSquareData;\\n        circleData memory tempCircleData;\\n        // declare shape data for loop\\n        Gen1Shape memory shapeData;\\n        // use memory array to minimize data going into string.concat for each loop\\n        string[9] memory shapes;\\n\\n        // oooh.... risky\\n        unchecked\\n        {\\n            // loop through dem shapes\\n            for(uint256 i=0; i<_blockData.numLevels; ++i)\\n            {\\n                // get shape width\\n                shapeData.width = _blockData.widthInterval*(_blockData.numLevels-i);\\n                // get weighted shape design\\n                /*\\n                    0 - none\\n                    1 - basic circle\\n                    2 - basic square (possibly rotated to 45 degrees)\\n                    3 - repeated circle\\n                    4 - repeated square\\n                    5 - rotated square (same direction)\\n                    6 - double rotated square (opposite directions)\\n                */\\n                // check if complexity limit is reached or recently used or too small\\n                if(_blockData.complexityLevel < 3 && _blockData.shapeDesign < 3 && i<6)\\n                {\\n                    // get possible complex shape\\n                    _blockData.shapeDesign = getShapeDesign((_tokenId+i), 280);\\n                } else\\n                {\\n                    // get simple shapes\\n                    _blockData.shapeDesign = getShapeDesign((_tokenId+i), 140);\\n                }\\n\\n                // none\\n                if(_blockData.shapeDesign == 0)\\n                {\\n                    // nothing to see here folks!\\n                    ++_blockData.noneCount;\\n\\n                // basic circle\\n                } else if(_blockData.shapeDesign == 1)\\n                {\\n                    // update shape\\n                    shapeData = getShapeData(_tokenId, i, false, false);\\n                    // get radius\\n                    tempCircleData.radius = (_blockData.widthInterval*(_blockData.numLevels-i))/2;\\n                    // get fill\\n                    tempCircleData.fill = _blockData.palette[shapeData.fillColorIndex];\\n                    // get stroke color\\n                    tempCircleData.strokeFill = _blockData.palette[shapeData.strokeColorIndex];\\n                    // set stroke width\\n                    tempCircleData.strokeWidth = shapeData.strokeWidth;\\n                    // add to shapes\\n                    shapes[i] = string.concat(        \\n                        SvgPieces[0],\\n                        GBUtils.toString(i),\\n                        SvgPieces[1],\\n                        drawCircle(tempCircleData),\\n                        SvgPieces[2]\\n                    );\\n                    // update circle count\\n                    ++_blockData.circleCount;\\n\\n\\n                // basic square\\n                } else if(_blockData.shapeDesign == 2)\\n                {\\n                    // update shape\\n                    shapeData = getShapeData(_tokenId, i, false, false);\\n                    // get dimensions\\n                    tempSquareData.width = (_blockData.widthInterval*(_blockData.numLevels-i))-150;\\n                    tempSquareData.height = tempSquareData.width;\\n                    tempSquareData.strWidth = GBUtils.toString(tempSquareData.width);\\n                    tempSquareData.strHeight  = GBUtils.toString(tempSquareData.width);\\n                    tempSquareData.startX = GBUtils.toString(2000 - tempSquareData.width/2);\\n                    tempSquareData.startY = tempSquareData.startX;\\n                    // get fill\\n                    tempSquareData.fill = _blockData.palette[shapeData.fillColorIndex];\\n                    // get stroke color\\n                    tempSquareData.strokeFill = _blockData.palette[shapeData.strokeColorIndex];\\n                    // set stroke width\\n                    tempSquareData.strokeWidth = GBUtils.toString(shapeData.strokeWidth);\\n                    // set rotation\\n                    tempSquareData.rotation = (i*shapeData.strokeColorIndex*3)%2==0 ? \\\"0\\\" : \\\"45\\\";\\n                    // add to shapes\\n                    shapes[i] = string.concat(\\n                        SvgPieces[0],\\n                        GBUtils.toString(i),\\n                        SvgPieces[1],\\n                        drawSquare(tempSquareData),\\n                        SvgPieces[2]\\n                    );\\n                    // update square count\\n                    ++_blockData.squareCount;\\n\\n\\n                // repeated circle\\n                } else if(_blockData.shapeDesign == 3)\\n                {\\n                    // update shape\\n                    shapeData = getShapeData(_tokenId, i, true, false);\\n                    // get fill\\n                    tempCircleData.fill = _blockData.palette[shapeData.fillColorIndex];\\n                    // get stroke color\\n                    tempCircleData.strokeFill = _blockData.palette[shapeData.strokeColorIndex];\\n                    // set stroke width\\n                    tempCircleData.strokeWidth = shapeData.strokeWidth;\\n                    // add to shapes\\n                    shapes[i] = string.concat(\\n                        SvgPieces[0],\\n                        GBUtils.toString(i),\\n                        SvgPieces[1],\\n                        getRepeatedCircle(shapeData, tempCircleData, _blockData.widthInterval*(_blockData.numLevels-i)),\\n                        SvgPieces[2]\\n                    );\\n                    // update circle count\\n                    ++_blockData.circleCount;\\n                    // update complexity count\\n                    ++_blockData.complexityLevel;\\n\\n\\n                // repeated square\\n                } else if(_blockData.shapeDesign == 4)\\n                {\\n                    // update shape\\n                    shapeData = getShapeData(_tokenId, i, true, false);\\n                    // get fill\\n                    tempSquareData.fill = _blockData.palette[shapeData.fillColorIndex];\\n                    // get stroke color\\n                    tempSquareData.strokeFill = _blockData.palette[shapeData.strokeColorIndex];\\n                    // get stroke width\\n                    tempSquareData.strokeWidth = GBUtils.toString(i==0 ? 20 : 20/i);\\n                    // set rotation\\n                    tempSquareData.rotation = '0';\\n                    // add to shapes                    \\n                    shapes[i] = string.concat(\\n                        SvgPieces[0],\\n                        GBUtils.toString(i),\\n                        SvgPieces[1],\\n                        simpleRepeatedSquare(shapeData, tempSquareData, _blockData.widthInterval*(_blockData.numLevels-i)),\\n                        SvgPieces[2]\\n                    );\\n                    // update square count\\n                    ++_blockData.squareCount;\\n                    // update complexity count\\n                    ++_blockData.complexityLevel;\\n\\n\\n                // rotated square, same direction\\n                } else if(_blockData.shapeDesign == 5)\\n                {\\n                    // update shape\\n                    shapeData = getShapeData(_tokenId, i, true, true);\\n                    // get fill\\n                    tempSquareData.fill = _blockData.palette[shapeData.fillColorIndex];\\n                    // get stroke color\\n                    tempSquareData.strokeFill = _blockData.palette[shapeData.strokeColorIndex];\\n                    // get stroke width\\n                    tempSquareData.strokeWidth = GBUtils.toString(i==0 ? 20 : 20/i);\\n                    // add to shapes\\n                    shapes[i] = string.concat(\\n                        SvgPieces[0],\\n                        GBUtils.toString(i),\\n                        SvgPieces[1],\\n                        getRepeatedSquare(shapeData, tempSquareData, _blockData.widthInterval*(_blockData.numLevels-i)),\\n                        SvgPieces[2]\\n                    );\\n                    // update square count\\n                    ++_blockData.squareCount;\\n                    // update complexity count\\n                    ++_blockData.complexityLevel;\\n\\n\\n                // rotated square, 2 directions\\n                } else if(_blockData.shapeDesign == 6)\\n                {\\n                    // update shape\\n                    shapeData = getShapeData(_tokenId, i, true, true);\\n                    // get fill\\n                    tempSquareData.fill = _blockData.palette[shapeData.fillColorIndex];\\n                    // get stroke color\\n                    tempSquareData.strokeFill = _blockData.palette[shapeData.strokeColorIndex];\\n                    // get stroke width\\n                    tempSquareData.strokeWidth = '5';\\n                    // add to shapes\\n                    shapes[i] = string.concat(\\n                        SvgPieces[0],\\n                        GBUtils.toString(i),\\n                        SvgPieces[1],\\n                        doubleRepeatedSquare(shapeData, tempSquareData, _blockData.widthInterval*(_blockData.numLevels-i)),\\n                        SvgPieces[2]\\n                    );\\n                    // update square count\\n                    ++_blockData.squareCount;\\n                    // update complexity count\\n                    ++_blockData.complexityLevel;\\n                }\\n            }\\n\\n            // combine everything\\n            string memory svg = string.concat(\\n                // svg intro\\n                SvgPieces[3],\\n                // check for special and add background\\n                !_blockData.isSpecial ? _blockData.palette[0] : '#000',\\n                // check for glitchy friends\\n                !_blockData.glitchy ? SvgPieces[4] : SvgPieces[5],\\n                // shapes 0-5\\n                shapes[0],\\n                shapes[1],\\n                shapes[2],\\n                shapes[3],\\n                shapes[4],\\n                shapes[5],\\n                shapes[6],\\n                shapes[7],\\n                shapes[8]\\n            );\\n            // combine continued....\\n            return string.concat(\\n                svg,\\n                // add name text intro\\n                SvgPieces[6],\\n                // add name text color\\n                _blockData.labelColor,\\n                // close name text intro\\n                SvgPieces[7],\\n                // add name\\n                _blockData.name,\\n                // add special js\\n                _blockData.isSpecial ? SvgPieces[8] : SvgPieces[9],\\n                // add glitchy js\\n                _blockData.glitchy ? SvgPieces[10] : SvgPieces[11],\\n                // token data for js to run token specific thangs\\n                getTokenDataString(_tokenData, _blockData),\\n                // the rest of the js, token info, and background intro\\n                SvgPieces[12]\\n            );\\n        }\\n    }\\n\\n\\n\\n    /*\\n  \\n         \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588     \u2588\u2588 \u2588\u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588      \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \\n        \u2588\u2588    \u2588\u2588 \u2588\u2588     \u2588\u2588 \u2588\u2588\u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588     \u2588\u2588      \u2588\u2588   \u2588\u2588 \u2588\u2588    \u2588\u2588\u2588  \\n        \u2588\u2588    \u2588\u2588 \u2588\u2588  \u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588      \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588\u2588   \\n        \u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588  \u2588\u2588\u2588    \\n         \u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588 \u2588\u2588\u2588  \u2588\u2588   \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588     \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\\n  \\n    */\\n\\n    // transfer contract ownership\\n    function transferOwnership(address _newOwner) external onlyOwner()\\n    {\\n        if(_newOwner == address(0)) revert SorryYouCantAbandonOwnershipToTheZeroAddress();\\n        ContractOwner = _newOwner;\\n    }\\n    // only owner homes!\\n    modifier onlyOwner\\n    {\\n        checkOwner();\\n        _;\\n    }\\n    // check owner function\\n    function checkOwner() private view\\n    {\\n        if(msg.sender != ContractOwner) revert YoureNotTheOwnerHomie();\\n    }\\n    // da constructor of course\\n    constructor()\\n    {\\n        ContractOwner = msg.sender;\\n    }\\n\\n\\n\\n    /*\\n         \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588      \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \\n        \u2588\u2588    \u2588\u2588    \u2588\u2588    \u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588     \u2588\u2588      \u2588\u2588   \u2588\u2588 \u2588\u2588    \u2588\u2588\u2588  \\n        \u2588\u2588    \u2588\u2588    \u2588\u2588    \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588\u2588      \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588\u2588   \\n        \u2588\u2588    \u2588\u2588    \u2588\u2588    \u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588   \u2588\u2588          \u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588  \u2588\u2588\u2588    \\n         \u2588\u2588\u2588\u2588\u2588\u2588     \u2588\u2588    \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588     \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588   \u2588\u2588 \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \\n    */\\n\\n    // what is this? might get some eth if you find out what this is for...\\n    uint256[16] private dg = \\n    [\\n        // 68 > x > 22\\n        // 2093 < x < 6187\\n        // 2132 < x < 6121\\n        102021282553914774613608089359761799178262015729299970412947439616,\\n        778360615187948414715637888792127984453292966684722682785855,\\n        57896044618658097713354588343023422346919739148282798015233532827003470742527,\\n        113078184538831209931075937543155121694344228625149498392006825716502298099712,\\n        877218653273216194192172123140375024722217319512236697439018639782890700800,\\n        6807227843502851840086740716877481124486385200992461467676556649824256,\\n        13162529905113298226147989406167177160117143377373115831914856448,\\n        8935141660703064064,\\n        417879173340834916817338734017584329434161216427212678811432712667136,\\n        3188165079992327097213657786451849572789873861404668167890927616,\\n        28946476292872224935800687286985591109930951143206526035726254058726678798208,\\n        428329420568494648490658216432943684042380553829661223197682737300246431,\\n        3505424579788208648752016578713469198590704525103534625737963099627387355039,\\n        115707279715488546053996121108542739027840001942120880079093165837435296288641,\\n        113984590913297954738950134280881736553353928201922026541891808982545480024079,\\n        115565932813024562229384323676698964891999997982351658710285968647177438756864\\n    ];\\n}\\n\\n\\n\\n// interface with the token contract\\ninterface IGBContract\\n{\\n    struct TokenData\\n    {\\n        uint8 activeGen;\\n        uint8 highestGenLevel;\\n        uint64 timesTransferred;\\n        uint64 ownedSince;\\n        address tokenOwner;\\n    }\\n    function getTokenData(uint256 _tokenId) external view returns (TokenData memory);\\n}\\n\\n\\n\\n// extra shizzles that help enable all of this mess\\nlibrary GBUtils\\n{\\n    // get weighted item\\n    function getWeightedItem(uint256[] memory weightArray, uint256 i) internal pure returns (uint256)\\n    {\\n        uint256 index = 0;\\n        uint256 j = weightArray[0];\\n        while (j <= i)\\n        {\\n            index++;\\n            j += weightArray[index];\\n        }\\n        return index;\\n    }\\n    // get pseudo-random number\\n    function random(string memory _input) internal pure returns (uint256)\\n    {\\n        return uint256(keccak256(abi.encodePacked(_input)));\\n    }\\n    // read bit, return bool\\n    function readBitBool(uint256 _data, uint256 _bitIndex) internal pure returns(bool)\\n    {\\n        return ((1 << _bitIndex) & _data) != 0;\\n    }\\n    // trimmed down version of open zeppelin libraries Strings.sol, Math.sol, and Base64.sol\\n    function toString(uint256 value) internal pure returns (string memory)\\n    {\\n        unchecked {\\n            uint256 length = log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true)\\n            {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), \\\"0123456789abcdef\\\"))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n    function toHexString(address addr) internal pure returns (string memory)\\n    {\\n        uint256 value = uint256(uint160(addr));\\n        uint256 length = 20;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i)\\n        {\\n            buffer[i] = bytes16(\\\"0123456789abcdef\\\")[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n    function log10(uint256 value) internal pure returns (uint256)\\n    {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64)\\n            {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32)\\n            {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16)\\n            {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8)\\n            {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4)\\n            {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2)\\n            {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1)\\n            {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n    function log256(uint256 value) internal pure returns (uint256)\\n    {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0)\\n            {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0)\\n            {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0)\\n            {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0)\\n            {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0)\\n            {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n    function encode(bytes memory data) internal pure returns (string memory)\\n    {\\n        if (data.length == 0) return \\\"\\\";\\n        // Loads the table into memory\\n        string memory table = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\\n        // and split into 4 numbers of 6 bits.\\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\\n        // - `data.length + 2`  -> Round up\\n        // - `/ 3`              -> Number of 3-bytes chunks\\n        // - `4 *`              -> 4 characters for each chunk\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the lookup table (skip the first \\\"length\\\" byte)\\n            let tablePtr := add(table, 1)\\n\\n            // Prepare result pointer, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // Run over the input, 3 bytes at a time\\n            for {\\n                let dataPtr := data\\n                let endPtr := add(data, mload(data))\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                // Advance 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n                // To write each character, shift the 3 bytes (18 bits) chunk\\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\\n                // and apply logical AND with 0x3F which is the number of\\n                // the previous character in the ASCII table prior to the Base64 Table\\n                // The result is then added to the table to get the character to write,\\n                // and finally write it in the result pointer but with a left shift\\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n            }\\n            // When data `bytes` is not exactly 3 bytes long\\n            // it is padded with `=` characters at the end\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n                mstore8(sub(resultPtr, 2), 0x3d)\\n            }\\n            case 2 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n\\n////////////////////////////////////////////\\n// be the reason someone smiles today \ud83e\udec2 //\\n///////////////////////////////////////////\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"SorryYouCantAbandonOwnershipToTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"YooooThatTokenIdIsWayTooHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"YoureNotTheOwnerHomie\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_attributes\",\"type\":\"string\"}],\"name\":\"cleanAttributes\",\"outputs\":[{\"internalType\":\"string[2]\",\"name\":\"\",\"type\":\"string[2]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getColorPalette\",\"outputs\":[{\"internalType\":\"string[4]\",\"name\":\"\",\"type\":\"string[4]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_tokenMetadata\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_tokenAttributes\",\"type\":\"string\"}],\"name\":\"tokenGenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_text\",\"type\":\"string\"}],\"name\":\"updateCirclePiece\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_text\",\"type\":\"string\"}],\"name\":\"updateMetadataPiece\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_text\",\"type\":\"string\"}],\"name\":\"updateSquarePiece\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_text\",\"type\":\"string\"}],\"name\":\"updateSvgPiece\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "goodblocksGen1", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}