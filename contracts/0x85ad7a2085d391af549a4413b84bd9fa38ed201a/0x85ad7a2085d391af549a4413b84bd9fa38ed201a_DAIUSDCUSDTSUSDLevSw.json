{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/dependencies/openzeppelin/contracts/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n    // for accounts without code, i.e. `keccak256('')`\\n    bytes32 codehash;\\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      codehash := extcodehash(account)\\n    }\\n    return (codehash != accountHash && codehash != 0x0);\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, 'Address: insufficient balance');\\n\\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n    (bool success, ) = recipient.call{value: amount}('');\\n    require(success, 'Address: unable to send value, recipient may have reverted');\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/contracts/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/contracts/IERC20Detailed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from './IERC20.sol';\\n\\ninterface IERC20Detailed is IERC20 {\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/contracts/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n  enum Rounding {\\n    Down, // Toward negative infinity\\n    Up, // Toward infinity\\n    Zero // Toward zero\\n  }\\n\\n  /**\\n   * @dev Returns the largest of two numbers.\\n   */\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a >= b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the smallest of two numbers.\\n   */\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the average of two numbers. The result is rounded towards\\n   * zero.\\n   */\\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b) / 2 can overflow.\\n    return (a & b) + (a ^ b) / 2;\\n  }\\n\\n  /**\\n   * @dev Returns the ceiling of the division of two numbers.\\n   *\\n   * This differs from standard division with `/` in that it rounds up instead\\n   * of rounding down.\\n   */\\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b - 1) / b can overflow on addition, so we distribute.\\n    return a == 0 ? 0 : (a - 1) / b + 1;\\n  }\\n\\n  /**\\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n   * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n   * with further edits by Uniswap Labs also under MIT license.\\n   */\\n  function mulDiv(\\n    uint256 x,\\n    uint256 y,\\n    uint256 denominator\\n  ) internal pure returns (uint256 result) {\\n    unchecked {\\n      // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n      // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n      // variables such that product = prod1 * 2^256 + prod0.\\n      uint256 prod0; // Least significant 256 bits of the product\\n      uint256 prod1; // Most significant 256 bits of the product\\n      assembly {\\n        let mm := mulmod(x, y, not(0))\\n        prod0 := mul(x, y)\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n      }\\n\\n      // Handle non-overflow cases, 256 by 256 division.\\n      if (prod1 == 0) {\\n        // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n        // The surrounding unchecked block does not change this fact.\\n        // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n        return prod0 / denominator;\\n      }\\n\\n      // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n      require(denominator > prod1, 'Math: mulDiv overflow');\\n\\n      ///////////////////////////////////////////////\\n      // 512 by 256 division.\\n      ///////////////////////////////////////////////\\n\\n      // Make division exact by subtracting the remainder from [prod1 prod0].\\n      uint256 remainder;\\n      assembly {\\n        // Compute remainder using mulmod.\\n        remainder := mulmod(x, y, denominator)\\n\\n        // Subtract 256 bit number from 512 bit number.\\n        prod1 := sub(prod1, gt(remainder, prod0))\\n        prod0 := sub(prod0, remainder)\\n      }\\n\\n      // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n      // See https://cs.stackexchange.com/q/138556/92363.\\n\\n      // Does not overflow because the denominator cannot be zero at this stage in the function.\\n      uint256 twos = denominator & (~denominator + 1);\\n      assembly {\\n        // Divide denominator by twos.\\n        denominator := div(denominator, twos)\\n\\n        // Divide [prod1 prod0] by twos.\\n        prod0 := div(prod0, twos)\\n\\n        // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n        twos := add(div(sub(0, twos), twos), 1)\\n      }\\n\\n      // Shift in bits from prod1 into prod0.\\n      prod0 |= prod1 * twos;\\n\\n      // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n      // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n      // four bits. That is, denominator * inv = 1 mod 2^4.\\n      uint256 inverse = (3 * denominator) ^ 2;\\n\\n      // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n      // in modular arithmetic, doubling the correct bits in each step.\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n      inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n      // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n      // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n      // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n      // is no longer required.\\n      result = prod0 * inverse;\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n   */\\n  function mulDiv(\\n    uint256 x,\\n    uint256 y,\\n    uint256 denominator,\\n    Rounding rounding\\n  ) internal pure returns (uint256) {\\n    uint256 result = mulDiv(x, y, denominator);\\n    if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n      result += 1;\\n    }\\n    return result;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/contracts/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n  // Booleans are more expensive than uint256 or any type that takes up a full\\n  // word because each write operation emits an extra SLOAD to first read the\\n  // slot's contents, replace the bits taken up by the boolean, and then write\\n  // back. This is the compiler's defense against contract upgrades and\\n  // pointer aliasing, and it cannot be disabled.\\n\\n  // The values being non-zero value makes deployment a bit more expensive,\\n  // but in exchange the refund on every call to nonReentrant will be lower in\\n  // amount. Since refunds are capped to a percentage of the total\\n  // transaction's gas, it is best to keep them low in cases like this one, to\\n  // increase the likelihood of the full refund coming into effect.\\n  uint256 private constant _NOT_ENTERED = 1;\\n  uint256 private constant _ENTERED = 2;\\n\\n  uint256 private _status;\\n\\n  constructor() {\\n    _status = _NOT_ENTERED;\\n  }\\n\\n  /**\\n   * @dev Prevents a contract from calling itself, directly or indirectly.\\n   * Calling a `nonReentrant` function from another `nonReentrant`\\n   * function is not supported. It is possible to prevent this from happening\\n   * by making the `nonReentrant` function external, and make it call a\\n   * `private` function that does the actual work.\\n   */\\n  modifier nonReentrant() {\\n    // On the first call to nonReentrant, _notEntered will be true\\n    require(_status != _ENTERED, 'ReentrancyGuard: reentrant call');\\n\\n    // Any calls to nonReentrant after this point will fail\\n    _status = _ENTERED;\\n\\n    _;\\n\\n    // By storing the original value once again, a refund is triggered (see\\n    // https://eips.ethereum.org/EIPS/eip-2200)\\n    _status = _NOT_ENTERED;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/contracts/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from './IERC20.sol';\\nimport {Address} from './Address.sol';\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n  }\\n\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      'SafeERC20: approve from non-zero to non-zero allowance'\\n    );\\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n  }\\n\\n  function callOptionalReturn(IERC20 token, bytes memory data) private {\\n    require(address(token).isContract(), 'SafeERC20: call to non-contract');\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = address(token).call(data);\\n    require(success, 'SafeERC20: low-level call failed');\\n\\n    if (returndata.length != 0) {\\n      // Return data is optional\\n      // solhint-disable-next-line max-line-length\\n      require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed');\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/flashloan/interfaces/IFlashLoanReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IFlashLoanReceiver interface\\n * @notice Interface for the IFlashLoanReceiver.\\n * @author Sturdy\\n * @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract\\n **/\\ninterface IFlashLoanReceiver {\\n  function executeOperation(\\n    address[] calldata assets,\\n    uint256[] calldata amounts,\\n    uint256[] calldata premiums,\\n    address initiator,\\n    bytes calldata params\\n  ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/flashloan/interfaces/IFlashLoanRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\\n\\n/**\\n * @title IFlashLoanRecipient interface\\n * @notice Interface for the IFlashLoanRecipient.\\n * @author Sturdy\\n * @dev implement this interface to develop a flashloan-compatible IFlashLoanRecipient contract\\n **/\\ninterface IFlashLoanRecipient {\\n  /**\\n   * @dev When `flashLoan` is called on the Vault, it invokes the `receiveFlashLoan` hook on the recipient.\\n   *\\n   * At the time of the call, the Vault will have transferred `amounts` for `tokens` to the recipient. Before this\\n   * call returns, the recipient must have transferred `amounts` plus `feeAmounts` for each token back to the\\n   * Vault, or else the entire flash loan will revert.\\n   *\\n   * `userData` is the same value passed in the `IVault.flashLoan` call.\\n   */\\n  function receiveFlashLoan(\\n    IERC20[] memory tokens,\\n    uint256[] memory amounts,\\n    uint256[] memory feeAmounts,\\n    bytes memory userData\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAaveFlashLoan.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\ninterface IAaveFlashLoan {\\n  /**\\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\\n   * as long as the amount taken plus a fee is returned.\\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\\n   * For further details please visit https://developers.aave.com\\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\\n   * @param assets The addresses of the assets being flash-borrowed\\n   * @param amounts The amounts amounts being flash-borrowed\\n   * @param modes Types of the debt to open if the flash loan is not returned:\\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\\n   * @param params Variadic packed params to pass to the receiver as extra information\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   **/\\n  function flashLoan(\\n    address receiverAddress,\\n    address[] calldata assets,\\n    uint256[] calldata amounts,\\n    uint256[] calldata modes,\\n    address onBehalfOf,\\n    bytes calldata params,\\n    uint16 referralCode\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\\nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol';\\nimport {IInitializableAToken} from './IInitializableAToken.sol';\\nimport {ISturdyIncentivesController} from './ISturdyIncentivesController.sol';\\n\\ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {\\n  /**\\n   * @dev Emitted after the mint action\\n   * @param from The address performing the mint\\n   * @param value The amount being\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  event Mint(address indexed from, uint256 value, uint256 index);\\n\\n  /**\\n   * @dev Mints `amount` aTokens to `user`\\n   * @param user The address receiving the minted tokens\\n   * @param amount The amount of tokens getting minted\\n   * @param index The new liquidity index of the reserve\\n   * @return `true` if the the previous balance of the user was 0\\n   */\\n  function mint(address user, uint256 amount, uint256 index) external payable returns (bool);\\n\\n  /**\\n   * @dev Emitted after aTokens are burned\\n   * @param from The owner of the aTokens, getting them burned\\n   * @param target The address that will receive the underlying\\n   * @param value The amount being burned\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  event Burn(address indexed from, address indexed target, uint256 value, uint256 index);\\n\\n  /**\\n   * @dev Emitted during the transfer action\\n   * @param from The user whose tokens are being transferred\\n   * @param to The recipient\\n   * @param value The amount being transferred\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\\n\\n  /**\\n   * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\\n   * @param user The owner of the aTokens, getting them burned\\n   * @param receiverOfUnderlying The address that will receive the underlying\\n   * @param amount The amount being burned\\n   * @param index The new liquidity index of the reserve\\n   **/\\n  function burn(\\n    address user,\\n    address receiverOfUnderlying,\\n    uint256 amount,\\n    uint256 index\\n  ) external payable;\\n\\n  /**\\n   * @dev Mints aTokens to the reserve treasury\\n   * @param amount The amount of tokens getting minted\\n   * @param index The new liquidity index of the reserve\\n   */\\n  function mintToTreasury(uint256 amount, uint256 index) external payable;\\n\\n  /**\\n   * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\\n   * @param from The address getting liquidated, current owner of the aTokens\\n   * @param to The recipient\\n   * @param value The amount of tokens getting transferred\\n   **/\\n  function transferOnLiquidation(address from, address to, uint256 value) external payable;\\n\\n  /**\\n   * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\\n   * assets in borrow(), withdraw() and flashLoan()\\n   * @param user The recipient of the underlying\\n   * @param amount The amount getting transferred\\n   * @return The amount transferred\\n   **/\\n  function transferUnderlyingTo(address user, uint256 amount) external payable returns (uint256);\\n\\n  /**\\n   * @dev Invoked to execute actions on the aToken side after a repayment.\\n   * @param user The user executing the repayment\\n   * @param amount The amount getting repaid\\n   **/\\n  function handleRepayment(address user, uint256 amount) external;\\n\\n  /**\\n   * @dev Returns the address of the incentives controller contract\\n   **/\\n  function getIncentivesController() external view returns (ISturdyIncentivesController);\\n\\n  /**\\n   * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\\n   **/\\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBalancerVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol';\\n\\ninterface IBalancerVault {\\n  // Pools\\n  //\\n  // There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\\n  // functionality:\\n  //\\n  //  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\\n  // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\\n  // which increase with the number of registered tokens.\\n  //\\n  //  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\\n  // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\\n  // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\\n  // independent of the number of registered tokens.\\n  //\\n  //  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\\n  // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\\n\\n  enum PoolSpecialization {\\n    GENERAL,\\n    MINIMAL_SWAP_INFO,\\n    TWO_TOKEN\\n  }\\n\\n  /**\\n   * @dev Returns a Pool's contract address and specialization setting.\\n   */\\n  function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\\n\\n  // Swaps\\n  //\\n  // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\\n  // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\\n  // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\\n  //\\n  // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\\n  // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\\n  // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\\n  // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\\n  // individual swaps.\\n  //\\n  // There are two swap kinds:\\n  //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\\n  // `onSwap` hook) the amount of tokens out (to send to the recipient).\\n  //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\\n  // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\\n  //\\n  // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\\n  // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\\n  // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\\n  // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\\n  // the final intended token.\\n  //\\n  // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\\n  // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\\n  // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\\n  // much less gas than they would otherwise.\\n  //\\n  // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\\n  // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\\n  // updating the Pool's internal accounting).\\n  //\\n  // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\\n  // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\\n  // minimum amount of tokens to receive (by passing a negative value) is specified.\\n  //\\n  // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\\n  // this point in time (e.g. if the transaction failed to be included in a block promptly).\\n  //\\n  // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\\n  // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\\n  // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\\n  // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\\n  //\\n  // Finally, Internal Balance can be used when either sending or receiving tokens.\\n\\n  enum SwapKind {\\n    GIVEN_IN,\\n    GIVEN_OUT\\n  }\\n\\n  /**\\n   * @dev Performs a swap with a single Pool.\\n   *\\n   * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\\n   * taken from the Pool, which must be greater than or equal to `limit`.\\n   *\\n   * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\\n   * sent to the Pool, which must be less than or equal to `limit`.\\n   *\\n   * Internal Balance usage and the recipient are determined by the `funds` struct.\\n   *\\n   * Emits a `Swap` event.\\n   */\\n  function swap(\\n    SingleSwap memory singleSwap,\\n    FundManagement memory funds,\\n    uint256 limit,\\n    uint256 deadline\\n  ) external payable returns (uint256);\\n\\n  /**\\n   * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\\n   * the `kind` value.\\n   *\\n   * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\\n   * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\\n   *\\n   * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\\n   * used to extend swap behavior.\\n   */\\n  struct SingleSwap {\\n    bytes32 poolId;\\n    SwapKind kind;\\n    address assetIn;\\n    address assetOut;\\n    uint256 amount;\\n    bytes userData;\\n  }\\n\\n  /**\\n   * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\\n   * `recipient` account.\\n   *\\n   * If the caller is not `sender`, it must be an authorized relayer for them.\\n   *\\n   * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\\n   * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\\n   * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\\n   * `joinPool`.\\n   *\\n   * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\\n   * transferred. This matches the behavior of `exitPool`.\\n   *\\n   * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\\n   * revert.\\n   */\\n  struct FundManagement {\\n    address sender;\\n    bool fromInternalBalance;\\n    address payable recipient;\\n    bool toInternalBalance;\\n  }\\n\\n  /**\\n   * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\\n   * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\\n   * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\\n   * `getPoolTokenInfo`).\\n   *\\n   * If the caller is not `sender`, it must be an authorized relayer for them.\\n   *\\n   * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\\n   * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\\n   * it just enforces these minimums.\\n   *\\n   * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\\n   * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\\n   * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\\n   *\\n   * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\\n   * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\\n   * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\\n   * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\\n   *\\n   * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\\n   * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\\n   * do so will trigger a revert.\\n   *\\n   * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\\n   * `tokens` array. This array must match the Pool's registered tokens.\\n   *\\n   * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\\n   * their own custom logic. This typically requires additional information from the user (such as the expected number\\n   * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\\n   * passed directly to the Pool's contract.\\n   *\\n   * Emits a `PoolBalanceChanged` event.\\n   */\\n  function exitPool(\\n    bytes32 poolId,\\n    address sender,\\n    address payable recipient,\\n    ExitPoolRequest memory request\\n  ) external;\\n\\n  struct ExitPoolRequest {\\n    address[] assets;\\n    uint256[] minAmountsOut;\\n    bytes userData;\\n    bool toInternalBalance;\\n  }\\n\\n  enum ExitKind {\\n    EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\\n    EXACT_BPT_IN_FOR_TOKENS_OUT,\\n    BPT_IN_FOR_EXACT_TOKENS_OUT\\n  }\\n\\n  function joinPool(\\n    bytes32 poolId,\\n    address sender,\\n    address recipient,\\n    JoinPoolRequest memory request\\n  ) external payable;\\n\\n  struct JoinPoolRequest {\\n    address[] assets;\\n    uint256[] maxAmountsIn;\\n    bytes userData;\\n    bool fromInternalBalance;\\n  }\\n\\n  enum JoinKind {\\n    INIT,\\n    EXACT_TOKENS_IN_FOR_BPT_OUT,\\n    TOKEN_IN_FOR_EXACT_BPT_OUT\\n  }\\n\\n  function getPoolTokenInfo(\\n    bytes32 poolId,\\n    IERC20 token\\n  )\\n    external\\n    view\\n    returns (uint256 cash, uint256 managed, uint256 lastChangeBlock, address assetManager);\\n\\n  function getPoolTokens(\\n    bytes32 poolId\\n  )\\n    external\\n    view\\n    returns (address[] memory tokens, uint256[] memory balances, uint256 lastChangeBlock);\\n\\n  struct BatchSwapStep {\\n    bytes32 poolId;\\n    uint256 assetInIndex;\\n    uint256 assetOutIndex;\\n    uint256 amount;\\n    bytes userData;\\n  }\\n\\n  function batchSwap(\\n    SwapKind kind,\\n    BatchSwapStep[] memory swaps,\\n    address[] memory assets,\\n    FundManagement memory funds,\\n    int256[] memory limits,\\n    uint256 deadline\\n  ) external payable returns (int256[] memory);\\n\\n  function flashLoan(\\n    address recipient,\\n    IERC20[] memory tokens,\\n    uint256[] memory amounts,\\n    bytes memory userData\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICurveAddressProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ICurveAddressProvider interface\\n * @notice Interface for the Curve Address Provider.\\n **/\\n\\ninterface ICurveAddressProvider {\\n  function get_address(uint256 id) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICurveExchange.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\ninterface ICurveExchange {\\n  function exchange(\\n    address _pool,\\n    address _from,\\n    address _to,\\n    uint256 _amount,\\n    uint256 _expected,\\n    address _receiver\\n  ) external payable returns (uint256);\\n\\n  function exchange_multiple(\\n    address[9] memory _route,\\n    uint256[3][4] memory _swap_params,\\n    uint256 _amount,\\n    uint256 _expected,\\n    address[4] memory _pools,\\n    address _receiver\\n  ) external payable returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICurvePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\ninterface ICurvePool {\\n  function get_virtual_price() external view returns (uint256 price);\\n\\n  function coins(uint256) external view returns (address);\\n\\n  function coins(int128) external view returns (address);\\n\\n  function balances(int128 _id) external view returns (uint256);\\n\\n  function balances(uint256 _id) external view returns (uint256);\\n\\n  function calc_withdraw_one_coin(\\n    uint256 _burn_amount,\\n    int128 i,\\n    bool _previous\\n  ) external view returns (uint256);\\n\\n  function calc_withdraw_one_coin(uint256 _burn_amount, int128 i) external view returns (uint256);\\n\\n  function calc_token_amount(\\n    uint256[2] memory _amounts,\\n    bool _is_deposit\\n  ) external view returns (uint256);\\n\\n  function calc_token_amount(\\n    uint256[3] memory _amounts,\\n    bool _is_deposit\\n  ) external view returns (uint256);\\n\\n  function calc_token_amount(\\n    uint256[4] memory _amounts,\\n    bool _is_deposit\\n  ) external view returns (uint256);\\n\\n  function remove_liquidity_one_coin(\\n    uint256 _burn_amount,\\n    int128 i,\\n    uint256 _min_amount,\\n    address _receiver\\n  ) external returns (uint256);\\n\\n  function remove_liquidity_one_coin(\\n    uint256 _burn_amount,\\n    int128 i,\\n    uint256 _min_amount\\n  ) external returns (uint256);\\n\\n  function remove_liquidity_one_coin(\\n    uint256 _burn_amount,\\n    int128 i,\\n    uint256 _min_amount,\\n    bool _use_underlying\\n  ) external returns (uint256);\\n\\n  function remove_liquidity_imbalance(\\n    uint256[4] calldata amounts,\\n    uint256 max_burn_amount\\n  ) external;\\n\\n  /**\\n   * @dev Index values can be found via the `coins` public getter method\\n   * @param i Index value for the coin to send\\n   * @param j Index valie of the coin to recieve\\n   * @param dx Amount of `i` being exchanged\\n   * @param min_dy Minimum amount of `j` to receive\\n   * @return Actual amount of `j` received\\n   **/\\n  function exchange(\\n    int128 i,\\n    int128 j,\\n    uint256 dx,\\n    uint256 min_dy\\n  ) external payable returns (uint256);\\n\\n  function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256);\\n\\n  function get_dy_underlying(int128 i, int128 j, uint256 dx) external view returns (uint256);\\n\\n  function add_liquidity(uint256[4] memory amounts, uint256 _min_mint_amount) external;\\n\\n  function add_liquidity(uint256[2] memory amounts, uint256 _min_mint_amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGeneralLevSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {CurveswapAdapter} from '../protocol/libraries/swap/CurveswapAdapter.sol';\\n\\ninterface IGeneralLevSwap {\\n  enum FlashLoanType {\\n    AAVE,\\n    BALANCER\\n  }\\n\\n  enum SwapType {\\n    NONE,\\n    NO_SWAP,\\n    UNISWAP,\\n    BALANCER,\\n    CURVE\\n  }\\n\\n  struct MultipSwapPath {\\n    address[9] routes;\\n    uint256[3][4] routeParams;\\n    // uniswap/balancer/curve\\n    SwapType swapType;\\n    uint256 poolCount;\\n    address swapFrom;\\n    address swapTo;\\n    uint256 inAmount;\\n    uint256 outAmount;\\n  }\\n\\n  struct SwapInfo {\\n    MultipSwapPath[3] paths;\\n    MultipSwapPath[3] reversePaths;\\n    uint256 pathLength;\\n  }\\n\\n  struct FlashLoanParams {\\n    bool isEnterPosition;\\n    uint256 minCollateralAmount;\\n    address user;\\n    address sAsset;\\n    SwapInfo swapInfo;\\n  }\\n\\n  struct LeverageParams {\\n    address user;\\n    uint256 principal;\\n    uint256 leverage;\\n    address borrowAsset;\\n    FlashLoanType flashLoanType;\\n    SwapInfo swapInfo;\\n  }\\n\\n  function enterPositionWithFlashloan(\\n    uint256 _principal,\\n    uint256 _leverage,\\n    address _stableAsset,\\n    FlashLoanType _flashLoanType,\\n    SwapInfo calldata _swapInfo\\n  ) external;\\n\\n  function withdrawWithFlashloan(\\n    uint256 _repayAmount,\\n    uint256 _requiredAmount,\\n    address _stableAsset,\\n    address _sAsset,\\n    FlashLoanType _flashLoanType,\\n    SwapInfo calldata _swapInfo\\n  ) external;\\n\\n  function zapDeposit(\\n    address _zappingAsset,\\n    uint256 _principal,\\n    MultipSwapPath[3] calldata _zapPaths,\\n    uint256 _zapPathLength\\n  ) external;\\n\\n  function zapLeverageWithFlashloan(\\n    address _zappingAsset,\\n    uint256 _principal,\\n    uint256 _leverage,\\n    address _borrowAsset,\\n    FlashLoanType _flashLoanType,\\n    MultipSwapPath[3] calldata _zapPaths,\\n    uint256 _zapPathLength,\\n    SwapInfo calldata _swapInfo\\n  ) external;\\n\\n  function getAvailableBorrowAssets() external pure returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGeneralVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\ninterface IGeneralVault {\\n  function pricePerShare() external view returns (uint256);\\n\\n  function vaultYieldInPrice() external view returns (uint256);\\n\\n  function withdrawOnLiquidation(address _asset, uint256 _amount) external returns (uint256);\\n\\n  function convertOnLiquidation(address _assetOut, uint256 _amountIn) external;\\n\\n  function processYield() external;\\n\\n  function getYieldAmount() external view returns (uint256);\\n\\n  function setTreasuryInfo(address _treasury, uint256 _fee) external;\\n\\n  function depositCollateral(address _asset, uint256 _amount) external payable;\\n\\n  function depositCollateralFrom(address _asset, uint256 _amount, address _user) external payable;\\n\\n  function withdrawCollateral(\\n    address _asset,\\n    uint256 _amount,\\n    uint256 _slippage,\\n    address _to\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IInitializableAToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {ILendingPool} from './ILendingPool.sol';\\nimport {ISturdyIncentivesController} from './ISturdyIncentivesController.sol';\\n\\n/**\\n * @title IInitializableAToken\\n * @notice Interface for the initialize function on AToken\\n * @author Sturdy, inspiration from Aave\\n **/\\ninterface IInitializableAToken {\\n  /**\\n   * @dev Emitted when an aToken is initialized\\n   * @param underlyingAsset The address of the underlying asset\\n   * @param pool The address of the associated lending pool\\n   * @param treasury The address of the treasury\\n   * @param incentivesController The address of the incentives controller for this aToken\\n   * @param aTokenDecimals the decimals of the underlying\\n   * @param aTokenName the name of the aToken\\n   * @param aTokenSymbol the symbol of the aToken\\n   * @param params A set of encoded parameters for additional initialization\\n   **/\\n  event Initialized(\\n    address indexed underlyingAsset,\\n    address indexed pool,\\n    address treasury,\\n    address incentivesController,\\n    uint8 aTokenDecimals,\\n    string aTokenName,\\n    string aTokenSymbol,\\n    bytes params\\n  );\\n\\n  /**\\n   * @dev Initializes the aToken\\n   * @param pool The address of the lending pool where this aToken will be used\\n   * @param treasury The address of the Sturdy treasury, receiving the fees on this aToken\\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\\n   * @param incentivesController The smart contract managing potential incentives distribution\\n   * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\\n   * @param aTokenName The name of the aToken\\n   * @param aTokenSymbol The symbol of the aToken\\n   */\\n  function initialize(\\n    ILendingPool pool,\\n    address treasury,\\n    address underlyingAsset,\\n    ISturdyIncentivesController incentivesController,\\n    uint8 aTokenDecimals,\\n    string calldata aTokenName,\\n    string calldata aTokenSymbol,\\n    bytes calldata params\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\nimport {ILendingPoolAddressesProvider} from './ILendingPoolAddressesProvider.sol';\\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\\n\\ninterface ILendingPool {\\n  /**\\n   * @dev Emitted on deposit()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The address initiating the deposit\\n   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\\n   * @param amount The amount deposited\\n   * @param referral The referral code used\\n   **/\\n  event Deposit(\\n    address indexed reserve,\\n    address user,\\n    address indexed onBehalfOf,\\n    uint256 amount,\\n    uint16 indexed referral\\n  );\\n\\n  /**\\n   * @dev Emitted on withdraw()\\n   * @param reserve The address of the underlyng asset being withdrawn\\n   * @param user The address initiating the withdrawal, owner of aTokens\\n   * @param to Address that will receive the underlying\\n   * @param amount The amount to be withdrawn\\n   **/\\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\\n\\n  /**\\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\\n   * @param reserve The address of the underlying asset being borrowed\\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\\n   * initiator of the transaction on flashLoan()\\n   * @param onBehalfOf The address that will be getting the debt\\n   * @param amount The amount borrowed out\\n   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\\n   * @param borrowRate The numeric rate at which the user has borrowed\\n   * @param referral The referral code used\\n   **/\\n  event Borrow(\\n    address indexed reserve,\\n    address user,\\n    address indexed onBehalfOf,\\n    uint256 amount,\\n    uint256 borrowRateMode,\\n    uint256 borrowRate,\\n    uint16 indexed referral\\n  );\\n\\n  /**\\n   * @dev Emitted on repay()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The beneficiary of the repayment, getting his debt reduced\\n   * @param repayer The address of the user initiating the repay(), providing the funds\\n   * @param amount The amount repaid\\n   **/\\n  event Repay(\\n    address indexed reserve,\\n    address indexed user,\\n    address indexed repayer,\\n    uint256 amount\\n  );\\n\\n  /**\\n   * @dev Emitted on setUserUseReserveAsCollateral()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The address of the user enabling the usage as collateral\\n   **/\\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\\n\\n  /**\\n   * @dev Emitted on setUserUseReserveAsCollateral()\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param user The address of the user enabling the usage as collateral\\n   **/\\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\\n\\n  /**\\n   * @dev Emitted on flashLoan()\\n   * @param target The address of the flash loan receiver contract\\n   * @param initiator The address initiating the flash loan\\n   * @param asset The address of the asset being flash borrowed\\n   * @param amount The amount flash borrowed\\n   * @param premium The fee flash borrowed\\n   * @param referralCode The referral code used\\n   **/\\n  event FlashLoan(\\n    address indexed target,\\n    address indexed initiator,\\n    address indexed asset,\\n    uint256 amount,\\n    uint256 premium,\\n    uint16 referralCode\\n  );\\n\\n  /**\\n   * @dev Emitted when the pause is triggered.\\n   */\\n  event Paused();\\n\\n  /**\\n   * @dev Emitted when the pause is lifted.\\n   */\\n  event Unpaused();\\n\\n  /**\\n   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\\n   * LendingPoolCollateral manager using a DELEGATECALL\\n   * This allows to have the events in the generated ABI for LendingPool.\\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\n   * @param user The address of the borrower getting liquidated\\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\n   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\\n   * @param liquidator The address of the liquidator\\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\\n   * to receive the underlying collateral asset directly\\n   **/\\n  event LiquidationCall(\\n    address indexed collateralAsset,\\n    address indexed debtAsset,\\n    address indexed user,\\n    uint256 debtToCover,\\n    uint256 liquidatedCollateralAmount,\\n    address liquidator,\\n    bool receiveAToken\\n  );\\n\\n  /**\\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\\n   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\\n   * gets added to the LendingPool ABI\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param liquidityRate The new liquidity rate\\n   * @param stableBorrowRate The new stable borrow rate\\n   * @param variableBorrowRate The new variable borrow rate\\n   * @param liquidityIndex The new liquidity index\\n   * @param variableBorrowIndex The new variable borrow index\\n   **/\\n  event ReserveDataUpdated(\\n    address indexed reserve,\\n    uint256 liquidityRate,\\n    uint256 stableBorrowRate,\\n    uint256 variableBorrowRate,\\n    uint256 liquidityIndex,\\n    uint256 variableBorrowIndex\\n  );\\n\\n  /**\\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\\n   * - Caller is anyone.\\n   * @param asset The address of the underlying asset to deposit\\n   * @param amount The amount to be deposited\\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n   *   is a different wallet\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   **/\\n  function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\\n\\n  /**\\n   * @dev Deposits an `amount` of underlying asset into the reserve for supplier from vault\\n   * - Caller is only Vault which is registered in this contract\\n   * @param asset The address of the underlying asset to deposit\\n   * @param amount The amount to be deposited\\n   **/\\n  function depositYield(address asset, uint256 amount) external;\\n\\n  /**\\n   * @dev Grab an Yield `amount` of underlying asset into the vault\\n   * - Caller is only Vault which is registered in this contract\\n   * @param asset The address of the underlying asset to get yield\\n   * @param amount The yield amount\\n   **/\\n  function getYield(address asset, uint256 amount) external;\\n\\n  /**\\n   * @dev Get underlying asset and aToken's total balance\\n   * @param asset The address of the underlying asset\\n   **/\\n  function getTotalBalanceOfAssetPair(address asset) external view returns (uint256, uint256);\\n\\n  /**\\n   * @dev Get total underlying asset which is borrowable\\n   *  and also list of underlying asset\\n   **/\\n  function getBorrowingAssetAndVolumes()\\n    external\\n    view\\n    returns (uint256, uint256[] memory, address[] memory, uint256);\\n\\n  /**\\n   * @dev Register the vault address\\n   * - To check if the caller is vault for some functions\\n   * - Caller is only LendingPoolConfigurator\\n   * @param _vaultAddress The address of the Vault\\n   **/\\n  function registerVault(address _vaultAddress) external payable;\\n\\n  /**\\n   * @dev Unregister the vault address\\n   * - To check if the caller is vault for some functions\\n   * - Caller is only LendingPoolConfigurator\\n   * @param _vaultAddress The address of the Vault\\n   **/\\n  function unregisterVault(address _vaultAddress) external payable;\\n\\n  /**\\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\\n   * - E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\n   * - Caller is anyone\\n   * @param asset The address of the underlying asset to withdraw\\n   * @param amount The underlying amount to be withdrawn\\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\n   * @param to Address that will receive the underlying, same as msg.sender if the user\\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n   *   different wallet\\n   * @return The final amount withdrawn\\n   **/\\n  function withdraw(address asset, uint256 amount, address to) external returns (uint256);\\n\\n  /**\\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\\n   * - E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\n   * - Caller is anyone\\n   * @param asset The address of the underlying asset to withdraw\\n   * @param amount The underlying amount to be withdrawn\\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\n   * @param from The address of user who is depositor of underlying asset\\n   * @param to Address that will receive the underlying, same as msg.sender if the user\\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n   *   different wallet\\n   * @return The final amount withdrawn\\n   **/\\n  function withdrawFrom(\\n    address asset,\\n    uint256 amount,\\n    address from,\\n    address to\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\\n   * - Caller is anyone\\n   * @param asset The address of the underlying asset to borrow\\n   * @param amount The amount to be borrowed\\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\\n   * if he has been given credit delegation allowance\\n   **/\\n  function borrow(\\n    address asset,\\n    uint256 amount,\\n    uint256 interestRateMode,\\n    uint16 referralCode,\\n    address onBehalfOf\\n  ) external;\\n\\n  /**\\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\\n   * - Caller is anyone\\n   * @param asset The address of the borrowed underlying asset previously borrowed\\n   * @param amount The amount to repay\\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\\n   * other borrower whose debt should be removed\\n   * @return The final amount repaid\\n   **/\\n  function repay(\\n    address asset,\\n    uint256 amount,\\n    uint256 rateMode,\\n    address onBehalfOf\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\\n   * @param asset The address of the underlying asset deposited\\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\\n   **/\\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\\n\\n  /**\\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\\n   * - Caller is anyone\\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\n   * @param user The address of the borrower getting liquidated\\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\\n   * to receive the underlying collateral asset directly\\n   **/\\n  function liquidationCall(\\n    address collateralAsset,\\n    address debtAsset,\\n    address user,\\n    uint256 debtToCover,\\n    bool receiveAToken\\n  ) external;\\n\\n  /**\\n   * @dev Returns the user account data across all the reserves\\n   * @param user The address of the user\\n   * @return totalCollateralETH the total collateral in ETH of the user\\n   * @return totalDebtETH the total debt in ETH of the user\\n   * @return availableBorrowsETH the borrowing power left of the user\\n   * @return currentLiquidationThreshold the liquidation threshold of the user\\n   * @return ltv the loan to value of the user\\n   * @return healthFactor the current health factor of the user\\n   **/\\n  function getUserAccountData(\\n    address user\\n  )\\n    external\\n    view\\n    returns (\\n      uint256 totalCollateralETH,\\n      uint256 totalDebtETH,\\n      uint256 availableBorrowsETH,\\n      uint256 currentLiquidationThreshold,\\n      uint256 ltv,\\n      uint256 healthFactor\\n    );\\n\\n  /**\\n   * @dev Initializes a reserve, activating it, assigning an aToken and debt tokens and an\\n   * interest rate strategy\\n   * - Only callable by the LendingPoolConfigurator contract\\n   * - Caller is only LendingPoolConfigurator\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param yieldAddress The address of the underlying asset's yield contract of the reserve\\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\\n   **/\\n  function initReserve(\\n    address reserve,\\n    address yieldAddress,\\n    address aTokenAddress,\\n    address stableDebtAddress,\\n    address variableDebtAddress,\\n    address interestRateStrategyAddress\\n  ) external payable;\\n\\n  /**\\n   * @dev Updates the address of the interest rate strategy contract\\n   * - Caller is only LendingPoolConfigurator\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param rateStrategyAddress The address of the interest rate strategy contract\\n   **/\\n  function setReserveInterestRateStrategyAddress(\\n    address reserve,\\n    address rateStrategyAddress\\n  ) external payable;\\n\\n  /**\\n   * @dev Sets the configuration bitmap of the reserve as a whole\\n   * - Caller is only LendingPoolConfigurator\\n   * @param reserve The address of the underlying asset of the reserve\\n   * @param configuration The new configuration bitmap\\n   **/\\n  function setConfiguration(address reserve, uint256 configuration) external payable;\\n\\n  /**\\n   * @dev Returns the configuration of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The configuration of the reserve\\n   **/\\n  function getConfiguration(\\n    address asset\\n  ) external view returns (DataTypes.ReserveConfigurationMap memory);\\n\\n  /**\\n   * @dev Returns the configuration of the user across all the reserves\\n   * @param user The user address\\n   * @return The configuration of the user\\n   **/\\n  function getUserConfiguration(\\n    address user\\n  ) external view returns (DataTypes.UserConfigurationMap memory);\\n\\n  /**\\n   * @dev Returns the normalized income normalized income of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The reserve's normalized income\\n   */\\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the normalized variable debt per unit of asset\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The reserve normalized variable debt\\n   */\\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the state and configuration of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The state of the reserve\\n   **/\\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\\n\\n  /**\\n   * @dev Validates and finalizes an aToken transfer\\n   * - Only callable by the overlying aToken of the `asset`\\n   * - Caller is only aToken contract which is storing the underlying asset of depositors\\n   * @param asset The address of the underlying asset of the aToken\\n   * @param from The user from which the aTokens are transferred\\n   * @param to The user receiving the aTokens\\n   * @param amount The amount being transferred/withdrawn\\n   * @param balanceFromAfter The aToken balance of the `from` user before the transfer\\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\\n   */\\n  function finalizeTransfer(\\n    address asset,\\n    address from,\\n    address to,\\n    uint256 amount,\\n    uint256 balanceFromAfter,\\n    uint256 balanceToBefore\\n  ) external;\\n\\n  /**\\n   * @dev Returns the list of the initialized reserves\\n   **/\\n  function getReservesList() external view returns (address[] memory);\\n\\n  /**\\n   * @dev Returns the cached LendingPoolAddressesProvider connected to this contract\\n   **/\\n  function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\\n\\n  /**\\n   * @dev Set the _pause state of a reserve\\n   * - Caller is only LendingPoolConfigurator\\n   * @param val `true` to pause the reserve, `false` to un-pause it\\n   */\\n  function setPause(bool val) external payable;\\n\\n  /**\\n   * @dev Returns if the LendingPool is paused\\n   */\\n  function paused() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendingPoolAddressesProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title LendingPoolAddressesProvider contract\\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\\n * - Owned by the Sturdy Governance\\n * @author Sturdy, inspiration from Aave\\n **/\\ninterface ILendingPoolAddressesProvider {\\n  event MarketIdSet(string newMarketId);\\n  event LendingPoolUpdated(address indexed newAddress);\\n  event IncentiveControllerUpdated(address indexed newAddress);\\n  event IncentiveTokenUpdated(address indexed newAddress);\\n  event ConfigurationAdminUpdated(address indexed newAddress);\\n  event EmergencyAdminUpdated(address indexed newAddress);\\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\\n  event PriceOracleUpdated(address indexed newAddress);\\n  event LendingRateOracleUpdated(address indexed newAddress);\\n  event ProxyCreated(bytes32 id, address indexed newAddress);\\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\\n\\n  function getMarketId() external view returns (string memory);\\n\\n  function setMarketId(string calldata marketId) external payable;\\n\\n  function setAddress(bytes32 id, address newAddress) external payable;\\n\\n  function setAddressAsProxy(bytes32 id, address impl) external payable;\\n\\n  function getAddress(bytes32 id) external view returns (address);\\n\\n  function getLendingPool() external view returns (address);\\n\\n  function setLendingPoolImpl(address pool) external payable;\\n\\n  function getIncentiveController() external view returns (address);\\n\\n  function setIncentiveControllerImpl(address incentiveController) external payable;\\n\\n  function getIncentiveToken() external view returns (address);\\n\\n  function setIncentiveTokenImpl(address incentiveToken) external payable;\\n\\n  function getLendingPoolConfigurator() external view returns (address);\\n\\n  function setLendingPoolConfiguratorImpl(address configurator) external payable;\\n\\n  function getLendingPoolCollateralManager() external view returns (address);\\n\\n  function setLendingPoolCollateralManager(address manager) external payable;\\n\\n  function getPoolAdmin() external view returns (address);\\n\\n  function setPoolAdmin(address admin) external payable;\\n\\n  function getEmergencyAdmin() external view returns (address);\\n\\n  function setEmergencyAdmin(address admin) external payable;\\n\\n  function getPriceOracle() external view returns (address);\\n\\n  function setPriceOracle(address priceOracle) external payable;\\n\\n  function getLendingRateOracle() external view returns (address);\\n\\n  function setLendingRateOracle(address lendingRateOracle) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceOracleGetter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IPriceOracleGetter interface\\n * @notice Interface for the Sturdy price oracle.\\n **/\\n\\ninterface IPriceOracleGetter {\\n  /**\\n   * @dev returns the asset price in ETH\\n   * @param asset the address of the asset\\n   * @return the ETH price of the asset\\n   **/\\n  function getAssetPrice(address asset) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IScaledBalanceToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\ninterface IScaledBalanceToken {\\n  /**\\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\\n   * @param user The user whose balance is calculated\\n   * @return The scaled balance of the user\\n   **/\\n  function scaledBalanceOf(address user) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the scaled balance of the user and the scaled total supply.\\n   * @param user The address of the user\\n   * @return The scaled balance of the user\\n   * @return The scaled balance and the scaled total supply\\n   **/\\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\\n\\n  /**\\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\\n   * @return The scaled total supply\\n   **/\\n  function scaledTotalSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISturdyIncentivesController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\ninterface ISturdyIncentivesController {\\n  event RewardsAccrued(address indexed user, uint256 amount);\\n\\n  event RewardsClaimed(address indexed user, address indexed to, uint256 amount);\\n\\n  event RewardsClaimed(\\n    address indexed user,\\n    address indexed to,\\n    address indexed claimer,\\n    uint256 amount\\n  );\\n\\n  event ClaimerSet(address indexed user, address indexed claimer);\\n\\n  /*\\n   * @dev Returns the configuration of the distribution for a certain asset\\n   * @param asset The address of the reference asset of the distribution\\n   * @return The asset index, the emission per second and the last updated timestamp\\n   **/\\n  function getAssetData(address asset) external view returns (uint256, uint256, uint256);\\n\\n  /**\\n   * @dev Whitelists an address to claim the rewards on behalf of another address\\n   * @param user The address of the user\\n   * @param claimer The address of the claimer\\n   */\\n  function setClaimer(address user, address claimer) external payable;\\n\\n  /**\\n   * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\\n   * @param user The address of the user\\n   * @return The claimer address\\n   */\\n  function getClaimer(address user) external view returns (address);\\n\\n  /**\\n   * @dev Configure assets for a certain rewards emission\\n   * @param assets The assets to incentivize\\n   * @param emissionsPerSecond The emission for each asset\\n   */\\n  function configureAssets(\\n    address[] calldata assets,\\n    uint256[] calldata emissionsPerSecond\\n  ) external payable;\\n\\n  /**\\n   * @dev Called by the corresponding asset on any update that affects the rewards distribution\\n   * @param user The address of the user\\n   * @param userBalance The balance of the user of the asset in the lending pool\\n   * @param totalSupply The total supply of the asset in the lending pool\\n   **/\\n  function handleAction(address user, uint256 totalSupply, uint256 userBalance) external;\\n\\n  /**\\n   * @dev Returns the total of rewards of an user, already accrued + not yet accrued\\n   * @param user The address of the user\\n   * @return The rewards\\n   **/\\n  function getRewardsBalance(\\n    address[] calldata assets,\\n    address user\\n  ) external view returns (uint256);\\n\\n  /**\\n   * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\\n   * @param amount Amount of rewards to claim\\n   * @param to Address that will be receiving the rewards\\n   * @return Rewards claimed\\n   **/\\n  function claimRewards(\\n    address[] calldata assets,\\n    uint256 amount,\\n    address to\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\\n   * be whitelisted via \\\"allowClaimOnBehalf\\\" function by the RewardsAdmin role manager\\n   * @param amount Amount of rewards to claim\\n   * @param user Address to check and claim rewards\\n   * @param to Address that will be receiving the rewards\\n   * @return Rewards claimed\\n   **/\\n  function claimRewardsOnBehalf(\\n    address[] calldata assets,\\n    uint256 amount,\\n    address user,\\n    address to\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev returns the unclaimed rewards of the user\\n   * @param user the address of the user\\n   * @return the unclaimed user rewards\\n   */\\n  function getUserUnclaimedRewards(address user) external view returns (uint256);\\n\\n  /**\\n   * @dev returns the unclaimed rewards of the user\\n   * @param user the address of the user\\n   * @param asset The asset to incentivize\\n   * @return the user index for the asset\\n   */\\n  function getUserAssetData(address user, address asset) external view returns (uint256);\\n\\n  /**\\n   * @dev for backward compatibility with previous implementation of the Incentives controller\\n   */\\n  function REWARD_TOKEN() external view returns (address);\\n\\n  /**\\n   * @dev for backward compatibility with previous implementation of the Incentives controller\\n   */\\n  function PRECISION() external view returns (uint8);\\n\\n  /**\\n   * @dev Gets the distribution end timestamp of the emissions\\n   */\\n  function DISTRIBUTION_END() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\nimport './IUniswapV3SwapCallback.sol';\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter is IUniswapV3SwapCallback {\\n  struct ExactInputSingleParams {\\n    address tokenIn;\\n    address tokenOut;\\n    uint24 fee;\\n    address recipient;\\n    uint256 deadline;\\n    uint256 amountIn;\\n    uint256 amountOutMinimum;\\n    uint160 sqrtPriceLimitX96;\\n  }\\n\\n  /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n  /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n  /// @return amountOut The amount of the received token\\n  function exactInputSingle(ExactInputSingleParams calldata params)\\n    external\\n    payable\\n    returns (uint256 amountOut);\\n\\n  struct ExactInputParams {\\n    bytes path;\\n    address recipient;\\n    uint256 deadline;\\n    uint256 amountIn;\\n    uint256 amountOutMinimum;\\n  }\\n\\n  /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n  /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n  /// @return amountOut The amount of the received token\\n  function exactInput(ExactInputParams calldata params)\\n    external\\n    payable\\n    returns (uint256 amountOut);\\n\\n  struct ExactOutputSingleParams {\\n    address tokenIn;\\n    address tokenOut;\\n    uint24 fee;\\n    address recipient;\\n    uint256 deadline;\\n    uint256 amountOut;\\n    uint256 amountInMaximum;\\n    uint160 sqrtPriceLimitX96;\\n  }\\n\\n  /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n  /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n  /// @return amountIn The amount of the input token\\n  function exactOutputSingle(ExactOutputSingleParams calldata params)\\n    external\\n    payable\\n    returns (uint256 amountIn);\\n\\n  struct ExactOutputParams {\\n    bytes path;\\n    address recipient;\\n    uint256 deadline;\\n    uint256 amountOut;\\n    uint256 amountInMaximum;\\n  }\\n\\n  /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n  /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n  /// @return amountIn The amount of the input token\\n  function exactOutput(ExactOutputParams calldata params)\\n    external\\n    payable\\n    returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV3SwapCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n  function uniswapV3SwapCallback(\\n    int256 amount0Delta,\\n    int256 amount1Delta,\\n    bytes calldata data\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultWhitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\npragma experimental ABIEncoderV2;\\n\\ninterface IVaultWhitelist {\\n  function whitelistUser(address vault, address user) external view returns (bool);\\n\\n  function whitelistUserCount(address vault) external view returns (uint256);\\n\\n  function whitelistContract(address vault, address sender) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/leverage/ethereum/DAIUSDCUSDTSUSDLevSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\nimport {GeneralLevSwap} from '../GeneralLevSwap.sol';\\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\\nimport {IGeneralLevSwap} from '../../../interfaces/IGeneralLevSwap.sol';\\nimport {ICurvePool} from '../../../interfaces/ICurvePool.sol';\\nimport {SafeERC20} from '../../../dependencies/openzeppelin/contracts/SafeERC20.sol';\\nimport {Errors} from '../../libraries/helpers/Errors.sol';\\n\\ncontract DAIUSDCUSDTSUSDLevSwap is GeneralLevSwap {\\n  using SafeERC20 for IERC20;\\n\\n  address private constant POOL = 0xA5407eAE9Ba41422680e2e00537571bcC53efBfD;\\n  address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n  address private constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n  address private constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\\n\\n  constructor(\\n    address _asset,\\n    address _vault,\\n    address _provider\\n  ) GeneralLevSwap(_asset, _vault, _provider) {\\n    ENABLED_BORROW_ASSETS[DAI] = true;\\n    ENABLED_BORROW_ASSETS[USDC] = true;\\n    ENABLED_BORROW_ASSETS[USDT] = true;\\n  }\\n\\n  function getAvailableBorrowAssets() external pure override returns (address[] memory assets) {\\n    assets = new address[](3);\\n    assets[0] = DAI;\\n    assets[1] = USDC;\\n    assets[2] = USDT;\\n  }\\n\\n  function _getCoinIndex(address _stableAsset) internal pure returns (uint256) {\\n    if (_stableAsset == DAI) return 0;\\n    if (_stableAsset == USDC) return 1;\\n    require(_stableAsset == USDT, 'Invalid stable coin');\\n    return 2;\\n  }\\n\\n  // DAIUSDCUSDTSUSD <-> borrowing asset\\n  function _processSwap(\\n    uint256 _amount,\\n    IGeneralLevSwap.MultipSwapPath memory _path,\\n    bool _isFrom,\\n    bool _checkOutAmount\\n  ) internal override returns (uint256) {\\n    if (_path.swapType > IGeneralLevSwap.SwapType.NO_SWAP) {\\n      return _swapByPath(_amount, _path, _checkOutAmount);\\n    }\\n\\n    uint256 outAmount = _checkOutAmount ? _path.outAmount : 0;\\n    if (_isFrom) {\\n      // DAIUSDCUSDTSUSD -> borrowing asset\\n      require(_checkOutAmount == true, Errors.LS_INVALID_CONFIGURATION);\\n\\n      address to = _path.swapTo;\\n      uint256 coinIndex = _getCoinIndex(to);\\n      uint256[4] memory amounts;\\n\\n      // receivable stable asset amount\\n      amounts[coinIndex] = outAmount;\\n\\n      // Withdraw a single asset from the pool\\n      ICurvePool(POOL).remove_liquidity_imbalance(amounts, _path.inAmount);\\n\\n      return IERC20(to).balanceOf(address(this));\\n    }\\n\\n    // borrowing asset -> DAIUSDCUSDTSUSD\\n    require(_path.swapTo == COLLATERAL, Errors.LS_INVALID_CONFIGURATION);\\n\\n    address from = _path.swapFrom;\\n\\n    IERC20(from).safeApprove(POOL, 0);\\n    IERC20(from).safeApprove(POOL, _amount);\\n\\n    uint256 coinIndex = _getCoinIndex(from);\\n    uint256[4] memory amountsAdded;\\n    amountsAdded[coinIndex] = _amount;\\n\\n    ICurvePool(POOL).add_liquidity(amountsAdded, outAmount);\\n\\n    return IERC20(COLLATERAL).balanceOf(address(this));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/leverage/GeneralLevSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol';\\nimport {IERC20Detailed} from '../../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\\nimport {SafeERC20} from '../../dependencies/openzeppelin/contracts/SafeERC20.sol';\\nimport {ReentrancyGuard} from '../../dependencies/openzeppelin/contracts/ReentrancyGuard.sol';\\nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol';\\nimport {ILendingPool} from '../../interfaces/ILendingPool.sol';\\nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol';\\nimport {PercentageMath} from '../libraries/math/PercentageMath.sol';\\nimport {IGeneralVault} from '../../interfaces/IGeneralVault.sol';\\nimport {IGeneralLevSwap} from '../../interfaces/IGeneralLevSwap.sol';\\nimport {IAToken} from '../../interfaces/IAToken.sol';\\nimport {IFlashLoanReceiver} from '../../flashloan/interfaces/IFlashLoanReceiver.sol';\\nimport {IFlashLoanRecipient} from '../../flashloan/interfaces/IFlashLoanRecipient.sol';\\nimport {IVaultWhitelist} from '../../interfaces/IVaultWhitelist.sol';\\nimport {IAaveFlashLoan} from '../../interfaces/IAaveFlashLoan.sol';\\nimport {IBalancerVault} from '../../interfaces/IBalancerVault.sol';\\nimport {DataTypes} from '../libraries/types/DataTypes.sol';\\nimport {ReserveConfiguration} from '../libraries/configuration/ReserveConfiguration.sol';\\nimport {Math} from '../../dependencies/openzeppelin/contracts/Math.sol';\\nimport {WadRayMath} from '../libraries/math/WadRayMath.sol';\\nimport {Errors} from '../libraries/helpers/Errors.sol';\\nimport {BalancerswapAdapter2} from '../libraries/swap/BalancerswapAdapter2.sol';\\nimport {UniswapAdapter2} from '../libraries/swap/UniswapAdapter2.sol';\\nimport {CurveswapAdapter2} from '../libraries/swap/CurveswapAdapter2.sol';\\n\\nabstract contract GeneralLevSwap is IFlashLoanReceiver, IFlashLoanRecipient, ReentrancyGuard {\\n  using SafeERC20 for IERC20;\\n  using PercentageMath for uint256;\\n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\n  using WadRayMath for uint256;\\n\\n  uint256 private constant USE_VARIABLE_DEBT = 2;\\n\\n  address private constant AAVE_LENDING_POOL_ADDRESS = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;\\n\\n  address private constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;\\n\\n  IVaultWhitelist private constant VAULT_WHITELIST =\\n    IVaultWhitelist(0x88eE44794bAf865E3b0b192d1F9f0AC3Daf1EA0E);\\n\\n  address public immutable COLLATERAL; // The address of external asset\\n\\n  uint256 public immutable DECIMALS; // The collateral decimals\\n\\n  address public immutable VAULT; // The address of vault\\n\\n  ILendingPoolAddressesProvider internal immutable PROVIDER;\\n\\n  IPriceOracleGetter internal immutable ORACLE;\\n\\n  ILendingPool internal immutable LENDING_POOL;\\n\\n  mapping(address => bool) internal ENABLED_BORROW_ASSETS;\\n\\n  //1 == not inExec\\n  //2 == inExec;\\n  //setting default to 1 to save some gas.\\n  uint256 private _balancerFlashLoanLock = 1;\\n\\n  /**\\n   * @param _asset The external asset ex. wFTM\\n   * @param _vault The deployed vault address\\n   * @param _provider The deployed AddressProvider\\n   */\\n  constructor(address _asset, address _vault, address _provider) {\\n    require(\\n      _asset != address(0) && _provider != address(0) && _vault != address(0),\\n      Errors.LS_INVALID_CONFIGURATION\\n    );\\n\\n    COLLATERAL = _asset;\\n    DECIMALS = IERC20Detailed(_asset).decimals();\\n    VAULT = _vault;\\n    PROVIDER = ILendingPoolAddressesProvider(_provider);\\n    ORACLE = IPriceOracleGetter(PROVIDER.getPriceOracle());\\n    LENDING_POOL = ILendingPool(PROVIDER.getLendingPool());\\n    IERC20(COLLATERAL).approve(_vault, type(uint256).max);\\n  }\\n\\n  /**\\n   * Get borrow coins available to borrow\\n   */\\n  function getAvailableBorrowAssets() external pure virtual returns (address[] memory) {\\n    return new address[](0);\\n  }\\n\\n  /**\\n   * This function is called after your contract has received the flash loaned amount\\n   * overriding executeOperation() in IFlashLoanReceiver\\n   */\\n  function executeOperation(\\n    address[] calldata assets,\\n    uint256[] calldata amounts,\\n    uint256[] calldata premiums,\\n    address initiator,\\n    bytes calldata params\\n  ) external override returns (bool) {\\n    require(initiator == address(this), Errors.LS_INVALID_CONFIGURATION);\\n    require(msg.sender == AAVE_LENDING_POOL_ADDRESS, Errors.LS_INVALID_CONFIGURATION);\\n    require(assets.length == amounts.length, Errors.LS_INVALID_CONFIGURATION);\\n    require(assets.length == premiums.length, Errors.LS_INVALID_CONFIGURATION);\\n    require(amounts[0] != 0, Errors.LS_INVALID_CONFIGURATION);\\n    require(assets[0] != address(0), Errors.LS_INVALID_CONFIGURATION);\\n\\n    _executeOperation(assets[0], amounts[0], premiums[0], params);\\n\\n    // approve the Aave LendingPool contract allowance to *pull* the owed amount\\n    IERC20(assets[0]).safeApprove(AAVE_LENDING_POOL_ADDRESS, 0);\\n    IERC20(assets[0]).safeApprove(AAVE_LENDING_POOL_ADDRESS, amounts[0] + premiums[0]);\\n\\n    return true;\\n  }\\n\\n  /**\\n   * This function is called after your contract has received the flash loaned amount\\n   * overriding receiveFlashLoan() in IFlashLoanRecipient\\n   */\\n  function receiveFlashLoan(\\n    IERC20[] memory tokens,\\n    uint256[] memory amounts,\\n    uint256[] memory feeAmounts,\\n    bytes memory userData\\n  ) external override {\\n    require(msg.sender == BALANCER_VAULT, Errors.LS_INVALID_CONFIGURATION);\\n    require(_balancerFlashLoanLock == 2, Errors.LS_INVALID_CONFIGURATION);\\n    require(tokens.length == amounts.length, Errors.LS_INVALID_CONFIGURATION);\\n    require(tokens.length == feeAmounts.length, Errors.LS_INVALID_CONFIGURATION);\\n    require(amounts[0] != 0, Errors.LS_INVALID_CONFIGURATION);\\n    require(address(tokens[0]) != address(0), Errors.LS_INVALID_CONFIGURATION);\\n    _balancerFlashLoanLock = 1;\\n\\n    _executeOperation(address(tokens[0]), amounts[0], feeAmounts[0], userData);\\n\\n    // send tokens to Balancer vault contract\\n    IERC20(tokens[0]).safeTransfer(msg.sender, amounts[0] + feeAmounts[0]);\\n  }\\n\\n  function _executeOperation(\\n    address asset,\\n    uint256 borrowAmount,\\n    uint256 fee,\\n    bytes memory params\\n  ) internal {\\n    // parse params\\n    IGeneralLevSwap.FlashLoanParams memory opsParams = abi.decode(\\n      params,\\n      (IGeneralLevSwap.FlashLoanParams)\\n    );\\n    require(opsParams.minCollateralAmount != 0, Errors.LS_INVALID_CONFIGURATION);\\n    require(opsParams.user != address(0), Errors.LS_INVALID_CONFIGURATION);\\n\\n    if (opsParams.isEnterPosition) {\\n      _enterPositionWithFlashloan(asset, borrowAmount, fee, opsParams);\\n    } else {\\n      require(opsParams.sAsset != address(0), Errors.LS_INVALID_CONFIGURATION);\\n      _withdrawWithFlashloan(asset, borrowAmount, opsParams);\\n    }\\n  }\\n\\n  /**\\n   * @param _principal - The amount of collateral\\n   * @param _leverage - Extra leverage value and must be greater than 0, ex. 300% = 300_00\\n   *                    _principal + _principal * _leverage should be used as collateral\\n   * @param _borrowAsset - The borrowing asset address when leverage works\\n   * @param _flashLoanType - 0 is Aave, 1 is Balancer\\n   * @param _swapInfo - The uniswap/balancer swap paths between borrowAsset and collateral\\n   */\\n  function enterPositionWithFlashloan(\\n    uint256 _principal,\\n    uint256 _leverage,\\n    address _borrowAsset,\\n    IGeneralLevSwap.FlashLoanType _flashLoanType,\\n    IGeneralLevSwap.SwapInfo calldata _swapInfo\\n  ) external nonReentrant {\\n    require(_principal != 0, Errors.LS_SWAP_AMOUNT_NOT_GT_0);\\n    require(_leverage != 0, Errors.LS_SWAP_AMOUNT_NOT_GT_0);\\n    require(_leverage < 900_00, Errors.LS_INVALID_CONFIGURATION);\\n    require(_borrowAsset != address(0), Errors.LS_INVALID_CONFIGURATION);\\n    require(ENABLED_BORROW_ASSETS[_borrowAsset], Errors.LS_STABLE_COIN_NOT_SUPPORTED);\\n    require(IERC20(COLLATERAL).balanceOf(msg.sender) >= _principal, Errors.LS_SUPPLY_NOT_ALLOWED);\\n    IERC20(COLLATERAL).safeTransferFrom(msg.sender, address(this), _principal);\\n\\n    _leverageWithFlashloan(\\n      IGeneralLevSwap.LeverageParams(\\n        msg.sender,\\n        _principal,\\n        _leverage,\\n        _borrowAsset,\\n        _flashLoanType,\\n        _swapInfo\\n      )\\n    );\\n  }\\n\\n  /**\\n   * @param _repayAmount - The amount of repay\\n   * @param _requiredAmount - The amount of collateral\\n   * @param _borrowAsset - The borrowing asset address when leverage works\\n   * @param _sAsset - staked asset address of collateral internal asset\\n   * @param _flashLoanType - 0 is Aave, 1 is Balancer\\n   * @param _swapInfo - The uniswap/balancer/curve swap infos between borrowAsset and collateral\\n   */\\n  function withdrawWithFlashloan(\\n    uint256 _repayAmount,\\n    uint256 _requiredAmount,\\n    address _borrowAsset,\\n    address _sAsset,\\n    IGeneralLevSwap.FlashLoanType _flashLoanType,\\n    IGeneralLevSwap.SwapInfo calldata _swapInfo\\n  ) external nonReentrant {\\n    require(_repayAmount != 0, Errors.LS_SWAP_AMOUNT_NOT_GT_0);\\n    require(_requiredAmount != 0, Errors.LS_SWAP_AMOUNT_NOT_GT_0);\\n    require(_borrowAsset != address(0), Errors.LS_INVALID_CONFIGURATION);\\n    require(ENABLED_BORROW_ASSETS[_borrowAsset], Errors.LS_STABLE_COIN_NOT_SUPPORTED);\\n    require(_sAsset != address(0), Errors.LS_INVALID_CONFIGURATION);\\n    require(\\n      _sAsset ==\\n        LENDING_POOL.getReserveData(IAToken(_sAsset).UNDERLYING_ASSET_ADDRESS()).aTokenAddress,\\n      Errors.LS_INVALID_CONFIGURATION\\n    );\\n\\n    uint256[] memory amounts = new uint256[](1);\\n    amounts[0] = _repayAmount;\\n\\n    bytes memory params = abi.encode(\\n      false /*leavePosition*/,\\n      _requiredAmount,\\n      msg.sender,\\n      _sAsset,\\n      _swapInfo\\n    );\\n\\n    if (_flashLoanType == IGeneralLevSwap.FlashLoanType.AAVE) {\\n      // 0 means revert the transaction if not validated\\n      uint256[] memory modes = new uint256[](1);\\n      modes[0] = 0;\\n\\n      address[] memory assets = new address[](1);\\n      assets[0] = _borrowAsset;\\n      IAaveFlashLoan(AAVE_LENDING_POOL_ADDRESS).flashLoan(\\n        address(this),\\n        assets,\\n        amounts,\\n        modes,\\n        address(this),\\n        params,\\n        0\\n      );\\n    } else {\\n      require(_balancerFlashLoanLock == 1, Errors.LS_INVALID_CONFIGURATION);\\n      IERC20[] memory assets = new IERC20[](1);\\n      assets[0] = IERC20(_borrowAsset);\\n      _balancerFlashLoanLock = 2;\\n      IBalancerVault(BALANCER_VAULT).flashLoan(address(this), assets, amounts, params);\\n    }\\n\\n    // remained borrow asset -> collateral\\n    _swapTo(\\n      _borrowAsset,\\n      IERC20(_borrowAsset).balanceOf(address(this)),\\n      _swapInfo.paths,\\n      _swapInfo.pathLength,\\n      false\\n    );\\n\\n    uint256 collateralAmount = IERC20(COLLATERAL).balanceOf(address(this));\\n    if (collateralAmount > _requiredAmount) {\\n      _supply(collateralAmount - _requiredAmount, msg.sender);\\n      collateralAmount = _requiredAmount;\\n    }\\n\\n    // finally deliver the collateral to user\\n    IERC20(COLLATERAL).safeTransfer(msg.sender, collateralAmount);\\n  }\\n\\n  function _enterPositionWithFlashloan(\\n    address _borrowAsset,\\n    uint256 _borrowedAmount,\\n    uint256 _fee,\\n    IGeneralLevSwap.FlashLoanParams memory _params\\n  ) internal {\\n    //swap borrow asset to collateral\\n    _swapTo(\\n      _borrowAsset,\\n      _borrowedAmount,\\n      _params.swapInfo.paths,\\n      _params.swapInfo.pathLength,\\n      true\\n    );\\n\\n    uint256 collateralAmount = IERC20(COLLATERAL).balanceOf(address(this));\\n    require(collateralAmount >= _params.minCollateralAmount, Errors.LS_SUPPLY_FAILED);\\n\\n    //deposit collateral\\n    _supply(collateralAmount, _params.user);\\n\\n    //borrow\\n    _borrow(_borrowAsset, _borrowedAmount + _fee, _params.user);\\n  }\\n\\n  function _withdrawWithFlashloan(\\n    address _borrowAsset,\\n    uint256 _borrowedAmount,\\n    IGeneralLevSwap.FlashLoanParams memory _params\\n  ) internal {\\n    // repay\\n    _repay(_borrowAsset, _borrowedAmount, _params.user);\\n\\n    // withdraw collateral\\n    // get internal asset address\\n    address internalAsset = IAToken(_params.sAsset).UNDERLYING_ASSET_ADDRESS();\\n    // get reserve info of internal asset\\n    DataTypes.ReserveConfigurationMap memory configuration = LENDING_POOL.getConfiguration(\\n      internalAsset\\n    );\\n    (, uint256 assetLiquidationThreshold, , , ) = configuration.getParamsMemory();\\n    require(assetLiquidationThreshold != 0, Errors.LS_INVALID_CONFIGURATION);\\n    // get user info\\n    (\\n      uint256 totalCollateralETH,\\n      uint256 totalDebtETH,\\n      ,\\n      uint256 currentLiquidationThreshold,\\n      ,\\n\\n    ) = LENDING_POOL.getUserAccountData(_params.user);\\n\\n    uint256 withdrawalAmountETH = (((totalCollateralETH * currentLiquidationThreshold) /\\n      PercentageMath.PERCENTAGE_FACTOR -\\n      totalDebtETH) * PercentageMath.PERCENTAGE_FACTOR) / assetLiquidationThreshold;\\n\\n    uint256 withdrawalAmount = Math.min(\\n      IERC20(_params.sAsset).balanceOf(_params.user),\\n      (withdrawalAmountETH * (10 ** DECIMALS)) / ORACLE.getAssetPrice(COLLATERAL)\\n    );\\n\\n    require(withdrawalAmount >= _params.minCollateralAmount, Errors.LS_SUPPLY_NOT_ALLOWED);\\n\\n    IERC20(_params.sAsset).safeTransferFrom(_params.user, address(this), withdrawalAmount);\\n    _remove(withdrawalAmount, 0, _params.user);\\n\\n    // collateral -> borrow asset\\n    _swapFrom(_borrowAsset, _params.swapInfo.reversePaths, _params.swapInfo.pathLength);\\n  }\\n\\n  function _supply(uint256 _amount, address _user) internal {\\n    // whitelist checking\\n    if (VAULT_WHITELIST.whitelistUserCount(VAULT) != 0) {\\n      require(VAULT_WHITELIST.whitelistUser(VAULT, _user), Errors.CALLER_NOT_WHITELIST_USER);\\n    }\\n\\n    IERC20(COLLATERAL).safeApprove(VAULT, 0);\\n    IERC20(COLLATERAL).safeApprove(VAULT, _amount);\\n    IGeneralVault(VAULT).depositCollateralFrom(COLLATERAL, _amount, _user);\\n  }\\n\\n  function _remove(uint256 _amount, uint256 _slippage, address _user) internal {\\n    // whitelist checking\\n    if (VAULT_WHITELIST.whitelistUserCount(VAULT) != 0) {\\n      require(VAULT_WHITELIST.whitelistUser(VAULT, _user), Errors.CALLER_NOT_WHITELIST_USER);\\n    }\\n\\n    IGeneralVault(VAULT).withdrawCollateral(COLLATERAL, _amount, _slippage, address(this));\\n  }\\n\\n  function _borrow(address _borrowAsset, uint256 _amount, address borrower) internal {\\n    LENDING_POOL.borrow(_borrowAsset, _amount, USE_VARIABLE_DEBT, 0, borrower);\\n  }\\n\\n  function _repay(address _borrowAsset, uint256 _amount, address borrower) internal {\\n    IERC20(_borrowAsset).safeApprove(address(LENDING_POOL), 0);\\n    IERC20(_borrowAsset).safeApprove(address(LENDING_POOL), _amount);\\n\\n    uint256 paybackAmount = LENDING_POOL.repay(_borrowAsset, _amount, USE_VARIABLE_DEBT, borrower);\\n    require(paybackAmount != 0, Errors.LS_REPAY_FAILED);\\n  }\\n\\n  /**\\n   * @param _zappingAsset - The stable coin address which will zap into lp token\\n   * @param _principal - The amount of collateral\\n   * @param _zapPaths - The uniswap/balancer/curve swap paths between zappingAsset and collateral\\n   * @param _zapPathLength - The uniswap/balancer/curve swap path length between zappingAsset and collateral\\n   */\\n  function zapDeposit(\\n    address _zappingAsset,\\n    uint256 _principal,\\n    IGeneralLevSwap.MultipSwapPath[3] calldata _zapPaths,\\n    uint256 _zapPathLength\\n  ) external nonReentrant {\\n    require(_principal != 0, Errors.LS_SWAP_AMOUNT_NOT_GT_0);\\n    require(_zappingAsset != address(0), Errors.LS_INVALID_CONFIGURATION);\\n    require(ENABLED_BORROW_ASSETS[_zappingAsset], Errors.LS_STABLE_COIN_NOT_SUPPORTED);\\n    require(\\n      IERC20(_zappingAsset).balanceOf(msg.sender) >= _principal,\\n      Errors.LS_SUPPLY_NOT_ALLOWED\\n    );\\n\\n    IERC20(_zappingAsset).safeTransferFrom(msg.sender, address(this), _principal);\\n\\n    uint256 suppliedAmount = _swapTo(_zappingAsset, _principal, _zapPaths, _zapPathLength, true);\\n    // supply to LP\\n    _supply(suppliedAmount, msg.sender);\\n  }\\n\\n  /**\\n   * @param _zappingAsset - The stable coin address which will zap into lp token\\n   * @param _principal - The amount of the stable coin\\n   * @param _leverage - Extra leverage value and must be greater than 0, ex. 300% = 300_00\\n   *                    principal + principal * leverage should be used as collateral\\n   * @param _borrowAsset - The borrowing asset address when leverage works\\n   * @param _flashLoanType - 0 is Aave, 1 is Balancer\\n   * @param _zapPaths - The uniswap/balancer/curve swap paths between zappingAsset and collateral\\n   * @param _zapPathLength - The uniswap/balancer/curve swap path length between zappingAsset and collateral\\n   * @param _swapInfo - The uniswap/balancer/curve swap between borrowAsset and collateral\\n   */\\n  function zapLeverageWithFlashloan(\\n    address _zappingAsset,\\n    uint256 _principal,\\n    uint256 _leverage,\\n    address _borrowAsset,\\n    IGeneralLevSwap.FlashLoanType _flashLoanType,\\n    IGeneralLevSwap.MultipSwapPath[3] calldata _zapPaths,\\n    uint256 _zapPathLength,\\n    IGeneralLevSwap.SwapInfo calldata _swapInfo\\n  ) external nonReentrant {\\n    require(_principal != 0, Errors.LS_SWAP_AMOUNT_NOT_GT_0);\\n    require(_leverage != 0, Errors.LS_SWAP_AMOUNT_NOT_GT_0);\\n    require(_leverage < 900_00, Errors.LS_INVALID_CONFIGURATION);\\n    require(_borrowAsset != address(0), Errors.LS_INVALID_CONFIGURATION);\\n    require(_zappingAsset != address(0), Errors.LS_INVALID_CONFIGURATION);\\n    require(ENABLED_BORROW_ASSETS[_zappingAsset], Errors.LS_STABLE_COIN_NOT_SUPPORTED);\\n    require(ENABLED_BORROW_ASSETS[_borrowAsset], Errors.LS_STABLE_COIN_NOT_SUPPORTED);\\n    require(\\n      IERC20(_zappingAsset).balanceOf(msg.sender) >= _principal,\\n      Errors.LS_SUPPLY_NOT_ALLOWED\\n    );\\n\\n    IERC20(_zappingAsset).safeTransferFrom(msg.sender, address(this), _principal);\\n\\n    uint256 collateralAmount = _swapTo(_zappingAsset, _principal, _zapPaths, _zapPathLength, true);\\n\\n    _leverageWithFlashloan(\\n      IGeneralLevSwap.LeverageParams(\\n        msg.sender,\\n        collateralAmount,\\n        _leverage,\\n        _borrowAsset,\\n        _flashLoanType,\\n        _swapInfo\\n      )\\n    );\\n  }\\n\\n  function _leverageWithFlashloan(IGeneralLevSwap.LeverageParams memory _params) internal {\\n    uint256 minCollateralAmount = _params.principal.percentMul(\\n      PercentageMath.PERCENTAGE_FACTOR + _params.leverage\\n    );\\n\\n    bytes memory params = abi.encode(\\n      true /*enterPosition*/,\\n      minCollateralAmount,\\n      _params.user,\\n      address(0),\\n      _params.swapInfo\\n    );\\n\\n    uint256 borrowAssetDecimals = IERC20Detailed(_params.borrowAsset).decimals();\\n    uint256[] memory amounts = new uint256[](1);\\n    amounts[0] = _params.swapInfo.paths[0].inAmount;\\n    if (_params.flashLoanType == IGeneralLevSwap.FlashLoanType.AAVE) {\\n      // 0 means revert the transaction if not validated\\n      uint256[] memory modes = new uint256[](1);\\n      address[] memory assets = new address[](1);\\n      assets[0] = _params.borrowAsset;\\n      IAaveFlashLoan(AAVE_LENDING_POOL_ADDRESS).flashLoan(\\n        address(this),\\n        assets,\\n        amounts,\\n        modes,\\n        address(this),\\n        params,\\n        0\\n      );\\n    } else {\\n      require(_balancerFlashLoanLock == 1, Errors.LS_INVALID_CONFIGURATION);\\n\\n      IERC20[] memory assets = new IERC20[](1);\\n      assets[0] = IERC20(_params.borrowAsset);\\n      _balancerFlashLoanLock = 2;\\n      IBalancerVault(BALANCER_VAULT).flashLoan(address(this), assets, amounts, params);\\n      _balancerFlashLoanLock = 1;\\n    }\\n  }\\n\\n  function _swapTo(\\n    address _borrowingAsset,\\n    uint256 _amount,\\n    IGeneralLevSwap.MultipSwapPath[3] memory _paths,\\n    uint256 _pathLength,\\n    bool _checkOutAmount\\n  ) internal returns (uint256) {\\n    require(_pathLength > 0, Errors.LS_INVALID_CONFIGURATION);\\n    require(_paths[0].swapFrom == _borrowingAsset, Errors.LS_INVALID_CONFIGURATION);\\n    require(_paths[_pathLength - 1].swapTo == COLLATERAL, Errors.LS_INVALID_CONFIGURATION);\\n\\n    uint256 amount = _amount;\\n    if (amount == 0) return 0;\\n\\n    for (uint256 i; i < _pathLength; ++i) {\\n      if (_paths[i].swapType == IGeneralLevSwap.SwapType.NONE) continue;\\n      amount = _processSwap(amount, _paths[i], false, _checkOutAmount);\\n    }\\n\\n    return amount;\\n  }\\n\\n  function _swapFrom(\\n    address _borrowingAsset,\\n    IGeneralLevSwap.MultipSwapPath[3] memory _paths,\\n    uint256 _pathLength\\n  ) internal returns (uint256) {\\n    require(_pathLength > 0, Errors.LS_INVALID_CONFIGURATION);\\n    require(_paths[0].swapFrom == COLLATERAL, Errors.LS_INVALID_CONFIGURATION);\\n    require(_paths[_pathLength - 1].swapTo == _borrowingAsset, Errors.LS_INVALID_CONFIGURATION);\\n\\n    uint256 amount = IERC20(COLLATERAL).balanceOf(address(this));\\n    if (amount == 0) return 0;\\n\\n    for (uint256 i; i < _pathLength; ++i) {\\n      if (_paths[i].swapType == IGeneralLevSwap.SwapType.NONE) continue;\\n      amount = _processSwap(amount, _paths[i], true, true);\\n    }\\n\\n    return amount;\\n  }\\n\\n  function _swapByPath(\\n    uint256 _fromAmount,\\n    IGeneralLevSwap.MultipSwapPath memory _path,\\n    bool _checkOutAmount\\n  ) internal returns (uint256) {\\n    uint256 poolCount = _path.poolCount;\\n    uint256 outAmount = _checkOutAmount ? _path.outAmount : 0;\\n    require(poolCount > 0, Errors.LS_INVALID_CONFIGURATION);\\n\\n    if (_path.swapType == IGeneralLevSwap.SwapType.BALANCER) {\\n      // Balancer Swap\\n      BalancerswapAdapter2.Path memory path;\\n      path.tokens = new address[](poolCount + 1);\\n      path.poolIds = new bytes32[](poolCount);\\n\\n      for (uint256 i; i < poolCount; ++i) {\\n        path.tokens[i] = _path.routes[i * 2];\\n        path.poolIds[i] = bytes32(_path.routeParams[i][0]);\\n      }\\n      path.tokens[poolCount] = _path.routes[poolCount * 2];\\n\\n      return\\n        BalancerswapAdapter2.swapExactTokensForTokens(\\n          _path.swapFrom,\\n          _path.swapTo,\\n          _fromAmount,\\n          path,\\n          outAmount\\n        );\\n    }\\n\\n    if (_path.swapType == IGeneralLevSwap.SwapType.UNISWAP) {\\n      // UniSwap\\n      UniswapAdapter2.Path memory path;\\n      path.tokens = new address[](poolCount + 1);\\n      path.fees = new uint256[](poolCount);\\n\\n      for (uint256 i; i < poolCount; ++i) {\\n        path.tokens[i] = _path.routes[i * 2];\\n        path.fees[i] = _path.routeParams[i][0];\\n      }\\n      path.tokens[poolCount] = _path.routes[poolCount * 2];\\n\\n      return\\n        UniswapAdapter2.swapExactTokensForTokens(\\n          PROVIDER,\\n          _path.swapFrom,\\n          _path.swapTo,\\n          _fromAmount,\\n          path,\\n          outAmount\\n        );\\n    }\\n\\n    // Curve Swap\\n    return\\n      CurveswapAdapter2.swapExactTokensForTokens(\\n        PROVIDER,\\n        _path.swapFrom,\\n        _path.swapTo,\\n        _fromAmount,\\n        CurveswapAdapter2.Path(_path.routes, _path.routeParams),\\n        outAmount\\n      );\\n  }\\n\\n  function _processSwap(\\n    uint256,\\n    IGeneralLevSwap.MultipSwapPath memory,\\n    bool,\\n    bool\\n  ) internal virtual returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/libraries/configuration/ReserveConfiguration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {Errors} from '../helpers/Errors.sol';\\nimport {DataTypes} from '../types/DataTypes.sol';\\n\\n/**\\n * @title ReserveConfiguration library\\n * @author Sturdy, inspiration from Aave\\n * @notice Implements the bitmap logic to handle the reserve configuration\\n */\\nlibrary ReserveConfiguration {\\n  uint256 constant LTV_MASK =                   0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\\n  uint256 constant LIQUIDATION_THRESHOLD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\\n  uint256 constant LIQUIDATION_BONUS_MASK =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\\n  uint256 constant DECIMALS_MASK =              0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant ACTIVE_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant FROZEN_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant BORROWING_MASK =             0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant STABLE_BORROWING_MASK =      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant RESERVE_FACTOR_MASK =        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\\n  uint256 constant COLLATERAL_MASK =            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF; // prettier-ignore\\n\\n  /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\\n  uint256 constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\\n  uint256 constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\\n  uint256 constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\\n  uint256 constant IS_ACTIVE_START_BIT_POSITION = 56;\\n  uint256 constant IS_FROZEN_START_BIT_POSITION = 57;\\n  uint256 constant BORROWING_ENABLED_START_BIT_POSITION = 58;\\n  uint256 constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\\n  uint256 constant COLLATERAL_ENABLED_START_BIT_POSITION = 60;\\n  uint256 constant RESERVE_FACTOR_START_BIT_POSITION = 64;\\n\\n  uint256 constant MAX_VALID_LTV = 65535;\\n  uint256 constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\\n  uint256 constant MAX_VALID_LIQUIDATION_BONUS = 65535;\\n  uint256 constant MAX_VALID_DECIMALS = 255;\\n  uint256 constant MAX_VALID_RESERVE_FACTOR = 65535;\\n\\n  /**\\n   * @dev Sets the Loan to Value of the reserve\\n   * @param self The reserve configuration\\n   * @param ltv the new ltv\\n   **/\\n  function setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure {\\n    require(ltv <= MAX_VALID_LTV, Errors.RC_INVALID_LTV);\\n\\n    self.data = (self.data & LTV_MASK) | ltv;\\n  }\\n\\n  /**\\n   * @dev Gets the Loan to Value of the reserve\\n   * @param self The reserve configuration\\n   * @return The loan to value\\n   **/\\n  function getLtv(DataTypes.ReserveConfigurationMap storage self) internal view returns (uint256) {\\n    return self.data & ~LTV_MASK;\\n  }\\n\\n  /**\\n   * @dev Sets the liquidation threshold of the reserve\\n   * @param self The reserve configuration\\n   * @param threshold The new liquidation threshold\\n   **/\\n  function setLiquidationThreshold(\\n    DataTypes.ReserveConfigurationMap memory self,\\n    uint256 threshold\\n  ) internal pure {\\n    require(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.RC_INVALID_LIQ_THRESHOLD);\\n\\n    self.data =\\n      (self.data & LIQUIDATION_THRESHOLD_MASK) |\\n      (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the liquidation threshold of the reserve\\n   * @param self The reserve configuration\\n   * @return The liquidation threshold\\n   **/\\n  function getLiquidationThreshold(\\n    DataTypes.ReserveConfigurationMap storage self\\n  ) internal view returns (uint256) {\\n    return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Sets the liquidation bonus of the reserve\\n   * @param self The reserve configuration\\n   * @param bonus The new liquidation bonus\\n   **/\\n  function setLiquidationBonus(\\n    DataTypes.ReserveConfigurationMap memory self,\\n    uint256 bonus\\n  ) internal pure {\\n    require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.RC_INVALID_LIQ_BONUS);\\n\\n    self.data =\\n      (self.data & LIQUIDATION_BONUS_MASK) |\\n      (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the liquidation bonus of the reserve\\n   * @param self The reserve configuration\\n   * @return The liquidation bonus\\n   **/\\n  function getLiquidationBonus(\\n    DataTypes.ReserveConfigurationMap storage self\\n  ) internal view returns (uint256) {\\n    return (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Sets the decimals of the underlying asset of the reserve\\n   * @param self The reserve configuration\\n   * @param decimals The decimals\\n   **/\\n  function setDecimals(\\n    DataTypes.ReserveConfigurationMap memory self,\\n    uint256 decimals\\n  ) internal pure {\\n    require(decimals <= MAX_VALID_DECIMALS, Errors.RC_INVALID_DECIMALS);\\n\\n    self.data = (self.data & DECIMALS_MASK) | (decimals << RESERVE_DECIMALS_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the decimals of the underlying asset of the reserve\\n   * @param self The reserve configuration\\n   * @return The decimals of the asset\\n   **/\\n  function getDecimals(\\n    DataTypes.ReserveConfigurationMap storage self\\n  ) internal view returns (uint256) {\\n    return (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Sets the active state of the reserve\\n   * @param self The reserve configuration\\n   * @param active The active state\\n   **/\\n  function setActive(DataTypes.ReserveConfigurationMap memory self, bool active) internal pure {\\n    self.data =\\n      (self.data & ACTIVE_MASK) |\\n      (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the active state of the reserve\\n   * @param self The reserve configuration\\n   * @return The active state\\n   **/\\n  function getActive(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\\n    return (self.data & ~ACTIVE_MASK) != 0;\\n  }\\n\\n  /**\\n   * @dev Sets the frozen state of the reserve\\n   * @param self The reserve configuration\\n   * @param frozen The frozen state\\n   **/\\n  function setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen) internal pure {\\n    self.data =\\n      (self.data & FROZEN_MASK) |\\n      (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the frozen state of the reserve\\n   * @param self The reserve configuration\\n   * @return The frozen state\\n   **/\\n  function getFrozen(DataTypes.ReserveConfigurationMap storage self) internal view returns (bool) {\\n    return (self.data & ~FROZEN_MASK) != 0;\\n  }\\n\\n  /**\\n   * @dev Enables or disables borrowing on the reserve\\n   * @param self The reserve configuration\\n   * @param enabled True if the borrowing needs to be enabled, false otherwise\\n   **/\\n  function setBorrowingEnabled(\\n    DataTypes.ReserveConfigurationMap memory self,\\n    bool enabled\\n  ) internal pure {\\n    self.data =\\n      (self.data & BORROWING_MASK) |\\n      (uint256(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the borrowing state of the reserve\\n   * @param self The reserve configuration\\n   * @return The borrowing state\\n   **/\\n  function getBorrowingEnabled(\\n    DataTypes.ReserveConfigurationMap storage self\\n  ) internal view returns (bool) {\\n    return (self.data & ~BORROWING_MASK) != 0;\\n  }\\n\\n  /**\\n   * @dev Sets the collateral state of the reserve\\n   * @param self The reserve configuration\\n   * @param enabled The collateral state\\n   **/\\n  function setCollateralEnabled(\\n    DataTypes.ReserveConfigurationMap memory self,\\n    bool enabled\\n  ) internal pure {\\n    self.data =\\n      (self.data & COLLATERAL_MASK) |\\n      (uint256(enabled ? 1 : 0) << COLLATERAL_ENABLED_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the collateral state of the reserve\\n   * @param self The reserve configuration\\n   * @return The collateral state\\n   **/\\n  function getCollateralEnabled(\\n    DataTypes.ReserveConfigurationMap storage self\\n  ) internal view returns (bool) {\\n    return (self.data & ~COLLATERAL_MASK) != 0;\\n  }\\n\\n  /**\\n   * @dev Enables or disables stable rate borrowing on the reserve\\n   * @param self The reserve configuration\\n   * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise\\n   **/\\n  function setStableRateBorrowingEnabled(\\n    DataTypes.ReserveConfigurationMap memory self,\\n    bool enabled\\n  ) internal pure {\\n    self.data =\\n      (self.data & STABLE_BORROWING_MASK) |\\n      (uint256(enabled ? 1 : 0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the stable rate borrowing state of the reserve\\n   * @param self The reserve configuration\\n   * @return The stable rate borrowing state\\n   **/\\n  function getStableRateBorrowingEnabled(\\n    DataTypes.ReserveConfigurationMap storage self\\n  ) internal view returns (bool) {\\n    return (self.data & ~STABLE_BORROWING_MASK) != 0;\\n  }\\n\\n  /**\\n   * @dev Sets the reserve factor of the reserve\\n   * @param self The reserve configuration\\n   * @param reserveFactor The reserve factor\\n   **/\\n  function setReserveFactor(\\n    DataTypes.ReserveConfigurationMap memory self,\\n    uint256 reserveFactor\\n  ) internal pure {\\n    require(reserveFactor <= MAX_VALID_RESERVE_FACTOR, Errors.RC_INVALID_RESERVE_FACTOR);\\n\\n    self.data =\\n      (self.data & RESERVE_FACTOR_MASK) |\\n      (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION);\\n  }\\n\\n  /**\\n   * @dev Gets the reserve factor of the reserve\\n   * @param self The reserve configuration\\n   * @return The reserve factor\\n   **/\\n  function getReserveFactor(\\n    DataTypes.ReserveConfigurationMap storage self\\n  ) internal view returns (uint256) {\\n    return (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;\\n  }\\n\\n  /**\\n   * @dev Gets the configuration flags of the reserve\\n   * @param self The reserve configuration\\n   * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enabled, collateral enabled\\n   **/\\n  function getFlags(\\n    DataTypes.ReserveConfigurationMap storage self\\n  ) internal view returns (bool, bool, bool, bool, bool) {\\n    uint256 dataLocal = self.data;\\n\\n    return (\\n      (dataLocal & ~ACTIVE_MASK) != 0,\\n      (dataLocal & ~FROZEN_MASK) != 0,\\n      (dataLocal & ~BORROWING_MASK) != 0,\\n      (dataLocal & ~STABLE_BORROWING_MASK) != 0,\\n      (dataLocal & ~COLLATERAL_MASK) != 0\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the configuration paramters of the reserve\\n   * @param self The reserve configuration\\n   * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\\n   **/\\n  function getParams(\\n    DataTypes.ReserveConfigurationMap storage self\\n  ) internal view returns (uint256, uint256, uint256, uint256, uint256) {\\n    uint256 dataLocal = self.data;\\n\\n    return (\\n      dataLocal & ~LTV_MASK,\\n      (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\\n      (dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\\n      (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\\n      (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the configuration paramters of the reserve from a memory object\\n   * @param self The reserve configuration\\n   * @return The state params representing ltv, liquidation threshold, liquidation bonus, the reserve decimals\\n   **/\\n  function getParamsMemory(\\n    DataTypes.ReserveConfigurationMap memory self\\n  ) internal pure returns (uint256, uint256, uint256, uint256, uint256) {\\n    return (\\n      self.data & ~LTV_MASK,\\n      (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\\n      (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\\n      (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\\n      (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION\\n    );\\n  }\\n\\n  /**\\n   * @dev Gets the configuration flags of the reserve from a memory object\\n   * @param self The reserve configuration\\n   * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enabled, collateral enabled\\n   **/\\n  function getFlagsMemory(\\n    DataTypes.ReserveConfigurationMap memory self\\n  ) internal pure returns (bool, bool, bool, bool, bool) {\\n    return (\\n      (self.data & ~ACTIVE_MASK) != 0,\\n      (self.data & ~FROZEN_MASK) != 0,\\n      (self.data & ~BORROWING_MASK) != 0,\\n      (self.data & ~STABLE_BORROWING_MASK) != 0,\\n      (self.data & ~COLLATERAL_MASK) != 0\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/libraries/helpers/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Errors library\\n * @author Sturdy, inspiration from Aave\\n * @notice Defines the error messages emitted by the different contracts of the Sturdy protocol\\n * @dev Error messages prefix glossary:\\n *  - VL = ValidationLogic\\n *  - MATH = Math libraries\\n *  - CT = Common errors between tokens (AToken, VariableDebtToken and StableDebtToken)\\n *  - AT = AToken\\n *  - SAT = StaticAToken\\n *  - SDT = StableDebtToken\\n *  - VDT = VariableDebtToken\\n *  - LP = LendingPool\\n *  - LPAPR = LendingPoolAddressesProviderRegistry\\n *  - LPC = LendingPoolConfiguration\\n *  - RL = ReserveLogic\\n *  - LPCM = LendingPoolCollateralManager\\n *  - P = Pausable\\n */\\nlibrary Errors {\\n  //common errors\\n  string internal constant CALLER_NOT_POOL_ADMIN = '33'; // 'The caller must be the pool admin'\\n  string internal constant BORROW_ALLOWANCE_NOT_ENOUGH = '59'; // User borrows on behalf, but allowance are too small\\n\\n  //contract specific errors\\n  string internal constant VL_INVALID_AMOUNT = '1'; // 'Amount must be greater than 0'\\n  string internal constant VL_NO_ACTIVE_RESERVE = '2'; // 'Action requires an active reserve'\\n  string internal constant VL_RESERVE_FROZEN = '3'; // 'Action cannot be performed because the reserve is frozen'\\n  string internal constant VL_CURRENT_AVAILABLE_LIQUIDITY_NOT_ENOUGH = '4'; // 'The current liquidity is not enough'\\n  string internal constant VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE = '5'; // 'User cannot withdraw more than the available balance'\\n  string internal constant VL_TRANSFER_NOT_ALLOWED = '6'; // 'Transfer cannot be allowed.'\\n  string internal constant VL_BORROWING_NOT_ENABLED = '7'; // 'Borrowing is not enabled'\\n  string internal constant VL_INVALID_INTEREST_RATE_MODE_SELECTED = '8'; // 'Invalid interest rate mode selected'\\n  string internal constant VL_COLLATERAL_BALANCE_IS_0 = '9'; // 'The collateral balance is 0'\\n  string internal constant VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = '10'; // 'Health factor is lesser than the liquidation threshold'\\n  string internal constant VL_COLLATERAL_CANNOT_COVER_NEW_BORROW = '11'; // 'There is not enough collateral to cover a new borrow'\\n  string internal constant VL_STABLE_BORROWING_NOT_ENABLED = '12'; // stable borrowing not enabled\\n  string internal constant VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY = '13'; // collateral is (mostly) the same currency that is being borrowed\\n  string internal constant VL_AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = '14'; // 'The requested amount is greater than the max loan size in stable rate mode\\n  string internal constant VL_NO_DEBT_OF_SELECTED_TYPE = '15'; // 'for repayment of stable debt, the user needs to have stable debt, otherwise, he needs to have variable debt'\\n  string internal constant VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = '16'; // 'To repay on behalf of an user an explicit amount to repay is needed'\\n  string internal constant VL_NO_STABLE_RATE_LOAN_IN_RESERVE = '17'; // 'User does not have a stable rate loan in progress on this reserve'\\n  string internal constant VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE = '18'; // 'User does not have a variable rate loan in progress on this reserve'\\n  string internal constant VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0 = '19'; // 'The underlying balance needs to be greater than 0'\\n  string internal constant VL_DEPOSIT_ALREADY_IN_USE = '20'; // 'User deposit is already being used as collateral'\\n  string internal constant LP_NOT_ENOUGH_STABLE_BORROW_BALANCE = '21'; // 'User does not have any stable rate loan for this reserve'\\n  string internal constant LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = '22'; // 'Interest rate rebalance conditions were not met'\\n  string internal constant LP_LIQUIDATION_CALL_FAILED = '23'; // 'Liquidation call failed'\\n  string internal constant LP_NOT_ENOUGH_LIQUIDITY_TO_BORROW = '24'; // 'There is not enough liquidity available to borrow'\\n  string internal constant LP_REQUESTED_AMOUNT_TOO_SMALL = '25'; // 'The requested amount is too small for a FlashLoan.'\\n  string internal constant LP_INCONSISTENT_PROTOCOL_ACTUAL_BALANCE = '26'; // 'The actual balance of the protocol is inconsistent'\\n  string internal constant LP_CALLER_NOT_LENDING_POOL_CONFIGURATOR = '27'; // 'The caller of the function is not the lending pool configurator'\\n  string internal constant LP_INCONSISTENT_FLASHLOAN_PARAMS = '28';\\n  string internal constant CT_CALLER_MUST_BE_LENDING_POOL = '29'; // 'The caller of this function must be a lending pool'\\n  string internal constant CT_CANNOT_GIVE_ALLOWANCE_TO_HIMSELF = '30'; // 'User cannot give allowance to himself'\\n  string internal constant CT_TRANSFER_AMOUNT_NOT_GT_0 = '31'; // 'Transferred amount needs to be greater than zero'\\n  string internal constant RL_RESERVE_ALREADY_INITIALIZED = '32'; // 'Reserve has already been initialized'\\n  string internal constant LPC_RESERVE_LIQUIDITY_NOT_0 = '34'; // 'The liquidity of the reserve needs to be 0'\\n  string internal constant LPC_INVALID_ATOKEN_POOL_ADDRESS = '35'; // 'The liquidity of the reserve needs to be 0'\\n  string internal constant LPC_INVALID_STABLE_DEBT_TOKEN_POOL_ADDRESS = '36'; // 'The liquidity of the reserve needs to be 0'\\n  string internal constant LPC_INVALID_VARIABLE_DEBT_TOKEN_POOL_ADDRESS = '37'; // 'The liquidity of the reserve needs to be 0'\\n  string internal constant LPC_INVALID_STABLE_DEBT_TOKEN_UNDERLYING_ADDRESS = '38'; // 'The liquidity of the reserve needs to be 0'\\n  string internal constant LPC_INVALID_VARIABLE_DEBT_TOKEN_UNDERLYING_ADDRESS = '39'; // 'The liquidity of the reserve needs to be 0'\\n  string internal constant LPC_INVALID_ADDRESSES_PROVIDER_ID = '40'; // 'The liquidity of the reserve needs to be 0'\\n  string internal constant LPC_INVALID_CONFIGURATION = '75'; // 'Invalid risk parameters for the reserve'\\n  string internal constant LPC_CALLER_NOT_EMERGENCY_ADMIN = '76'; // 'The caller must be the emergency admin'\\n  string internal constant LPAPR_PROVIDER_NOT_REGISTERED = '41'; // 'Provider is not registered'\\n  string internal constant LPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD = '42'; // 'Health factor is not below the threshold'\\n  string internal constant LPCM_COLLATERAL_CANNOT_BE_LIQUIDATED = '43'; // 'The collateral chosen cannot be liquidated'\\n  string internal constant LPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = '44'; // 'User did not borrow the specified currency'\\n  string internal constant LPCM_NOT_ENOUGH_LIQUIDITY_TO_LIQUIDATE = '45'; // \\\"There isn't enough liquidity available to liquidate\\\"\\n  string internal constant LPCM_NO_ERRORS = '46'; // 'No errors'\\n  string internal constant LP_INVALID_FLASHLOAN_MODE = '47'; //Invalid flashloan mode selected\\n  string internal constant MATH_MULTIPLICATION_OVERFLOW = '48';\\n  string internal constant MATH_ADDITION_OVERFLOW = '49';\\n  string internal constant MATH_DIVISION_BY_ZERO = '50';\\n  string internal constant RL_LIQUIDITY_INDEX_OVERFLOW = '51'; //  Liquidity index overflows uint128\\n  string internal constant RL_VARIABLE_BORROW_INDEX_OVERFLOW = '52'; //  Variable borrow index overflows uint128\\n  string internal constant RL_LIQUIDITY_RATE_OVERFLOW = '53'; //  Liquidity rate overflows uint128\\n  string internal constant RL_VARIABLE_BORROW_RATE_OVERFLOW = '54'; //  Variable borrow rate overflows uint128\\n  string internal constant RL_STABLE_BORROW_RATE_OVERFLOW = '55'; //  Stable borrow rate overflows uint128\\n  string internal constant CT_INVALID_MINT_AMOUNT = '56'; //invalid amount to mint\\n  string internal constant LP_FAILED_REPAY_WITH_COLLATERAL = '57';\\n  string internal constant CT_INVALID_BURN_AMOUNT = '58'; //invalid amount to burn\\n  string internal constant LP_FAILED_COLLATERAL_SWAP = '60';\\n  string internal constant LP_INVALID_EQUAL_ASSETS_TO_SWAP = '61';\\n  string internal constant LP_REENTRANCY_NOT_ALLOWED = '62';\\n  string internal constant LP_CALLER_MUST_BE_AN_ATOKEN = '63';\\n  string internal constant LP_IS_PAUSED = '64'; // 'Pool is paused'\\n  string internal constant LP_NO_MORE_RESERVES_ALLOWED = '65';\\n  string internal constant LP_INVALID_FLASH_LOAN_EXECUTOR_RETURN = '66';\\n  string internal constant RC_INVALID_LTV = '67';\\n  string internal constant RC_INVALID_LIQ_THRESHOLD = '68';\\n  string internal constant RC_INVALID_LIQ_BONUS = '69';\\n  string internal constant RC_INVALID_DECIMALS = '70';\\n  string internal constant RC_INVALID_RESERVE_FACTOR = '71';\\n  string internal constant LPAPR_INVALID_ADDRESSES_PROVIDER_ID = '72';\\n  string internal constant VL_INCONSISTENT_FLASHLOAN_PARAMS = '73';\\n  string internal constant LP_INCONSISTENT_PARAMS_LENGTH = '74';\\n  string internal constant UL_INVALID_INDEX = '77';\\n  string internal constant LP_NOT_CONTRACT = '78';\\n  string internal constant SDT_STABLE_DEBT_OVERFLOW = '79';\\n  string internal constant SDT_BURN_EXCEEDS_BALANCE = '80';\\n  string internal constant VT_COLLATERAL_DEPOSIT_REQUIRE_ETH = '81'; //Only accept ETH for collateral deposit\\n  string internal constant VT_COLLATERAL_DEPOSIT_INVALID = '82'; //Collateral deposit failed\\n  string internal constant VT_LIQUIDITY_DEPOSIT_INVALID = '83'; //Only accept USDC, USDT, DAI for liquidity deposit\\n  string internal constant VT_COLLATERAL_WITHDRAW_INVALID = '84'; //Collateral withdraw failed\\n  string internal constant VT_COLLATERAL_WITHDRAW_INVALID_AMOUNT = '85'; //Collateral withdraw has not enough amount\\n  string internal constant VT_CONVERT_ASSET_BY_CURVE_INVALID = '86'; //Convert asset by curve invalid\\n  string internal constant VT_PROCESS_YIELD_INVALID = '87'; //Processing yield is invalid\\n  string internal constant VT_TREASURY_INVALID = '88'; //Treasury is invalid\\n  string internal constant LP_ATOKEN_INIT_INVALID = '89'; //aToken invalid init\\n  string internal constant VT_FEE_TOO_BIG = '90'; //Fee is too big\\n  string internal constant VT_COLLATERAL_DEPOSIT_VAULT_UNAVAILABLE = '91';\\n  string internal constant LP_LIQUIDATION_CONVERT_FAILED = '92';\\n  string internal constant VT_DEPLOY_FAILED = '93'; // Vault deploy failed\\n  string internal constant VT_INVALID_CONFIGURATION = '94'; // Invalid vault configuration\\n  string internal constant VL_OVERFLOW_MAX_RESERVE_CAPACITY = '95'; // overflow max capacity of reserve\\n  string internal constant VT_WITHDRAW_AMOUNT_MISMATCH = '96'; // not performed withdraw 100%\\n  string internal constant VT_SWAP_MISMATCH_RETURNED_AMOUNT = '97'; //Returned amount is not enough\\n  string internal constant CALLER_NOT_YIELD_PROCESSOR = '98'; // 'The caller must be the pool admin'\\n  string internal constant VT_EXTRA_REWARDS_INDEX_INVALID = '97'; // Invalid extraRewards index\\n  string internal constant VT_SWAP_PATH_LENGTH_INVALID = '100'; // Invalid token or fee length\\n  string internal constant VT_SWAP_PATH_TOKEN_INVALID = '101'; // Invalid token information\\n  string internal constant CLAIMER_UNAUTHORIZED = '102'; // 'The claimer is not authorized'\\n  string internal constant YD_INVALID_CONFIGURATION = '103'; // 'The yield distribution's invalid configuration'\\n  string internal constant CALLER_NOT_EMISSION_MANAGER = '104'; // 'The caller must be emission manager'\\n  string internal constant CALLER_NOT_INCENTIVE_CONTROLLER = '105'; // 'The caller must be incentive controller'\\n  string internal constant YD_VR_ASSET_ALREADY_IN_USE = '106'; // Vault is already registered\\n  string internal constant YD_VR_INVALID_VAULT = '107'; // Invalid vault is used for an asset\\n  string internal constant YD_VR_INVALID_REWARDS_AMOUNT = '108'; // Rewards amount should be bigger than before\\n  string internal constant YD_VR_REWARD_TOKEN_NOT_VALID = '109'; // The reward token must be same with configured address\\n  string internal constant YD_VR_ASSET_NOT_REGISTERED = '110';\\n  string internal constant YD_VR_CALLER_NOT_VAULT = '111'; // The caller must be same with configured vault address\\n  string internal constant LS_INVALID_CONFIGURATION = '112'; // Invalid Leverage Swapper configuration\\n  string internal constant LS_SWAP_AMOUNT_NOT_GT_0 = '113'; // Collateral amount needs to be greater than zero\\n  string internal constant LS_STABLE_COIN_NOT_SUPPORTED = '114'; // Doesn't support swap for the stable coin\\n  string internal constant LS_SUPPLY_NOT_ALLOWED = '115'; // no sufficient funds\\n  string internal constant LS_SUPPLY_FAILED = '116'; // Deposit fails when leverage works\\n  string internal constant LS_REMOVE_ITERATION_OVER = '117'; // Withdraw iteration limit over\\n  string internal constant CALLER_NOT_WHITELIST_USER = '118'; // 'The caller must be whitelist user'\\n  string internal constant SAT_INVALID_OWNER = '119';\\n  string internal constant SAT_INVALID_EXPIRATION = '120';\\n  string internal constant SAT_INVALID_SIGNATURE = '121';\\n  string internal constant SAT_INVALID_DEPOSITOR = '122';\\n  string internal constant SAT_INVALID_RECIPIENT = '123';\\n  string internal constant SAT_ONLY_ONE_AMOUNT_FORMAT_ALLOWED = '125';\\n  string internal constant LS_REPAY_FAILED = '126';\\n\\n  enum CollateralManagerErrors {\\n    NO_ERROR,\\n    NO_COLLATERAL_AVAILABLE,\\n    COLLATERAL_CANNOT_BE_LIQUIDATED,\\n    CURRRENCY_NOT_BORROWED,\\n    HEALTH_FACTOR_ABOVE_THRESHOLD,\\n    NOT_ENOUGH_LIQUIDITY,\\n    NO_ACTIVE_RESERVE,\\n    HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD,\\n    INVALID_EQUAL_ASSETS_TO_SWAP,\\n    FROZEN_RESERVE\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/libraries/math/PercentageMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {Errors} from '../helpers/Errors.sol';\\n\\n/**\\n * @title PercentageMath library\\n * @author Sturdy, inspiration from Aave\\n * @notice Provides functions to perform percentage calculations\\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\\n * @dev Operations are rounded half up\\n **/\\n\\nlibrary PercentageMath {\\n  uint256 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals\\n  uint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;\\n\\n  /**\\n   * @dev Executes a percentage multiplication\\n   * @param value The value of which the percentage needs to be calculated\\n   * @param percentage The percentage of the value to be calculated\\n   * @return The percentage of value\\n   **/\\n  function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256) {\\n    if (value == 0 || percentage == 0) {\\n      return 0;\\n    }\\n\\n    return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR;\\n  }\\n\\n  /**\\n   * @dev Executes a percentage division\\n   * @param value The value of which the percentage needs to be calculated\\n   * @param percentage The percentage of the value to be calculated\\n   * @return The value divided the percentage\\n   **/\\n  function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256) {\\n    uint256 halfPercentage = percentage / 2;\\n\\n    return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/libraries/math/WadRayMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {Errors} from '../helpers/Errors.sol';\\n\\n/**\\n * @title WadRayMath library\\n * @author Sturdy, inspiration from Aave\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\\n **/\\n\\nlibrary WadRayMath {\\n  uint256 internal constant WAD = 1e18;\\n  uint256 internal constant halfWAD = WAD / 2;\\n\\n  uint256 internal constant RAY = 1e27;\\n  uint256 internal constant halfRAY = RAY / 2;\\n\\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n  /**\\n   * @return One ray, 1e27\\n   **/\\n  function ray() internal pure returns (uint256) {\\n    return RAY;\\n  }\\n\\n  /**\\n   * @return One wad, 1e18\\n   **/\\n\\n  function wad() internal pure returns (uint256) {\\n    return WAD;\\n  }\\n\\n  /**\\n   * @return Half ray, 1e27/2\\n   **/\\n  function halfRay() internal pure returns (uint256) {\\n    return halfRAY;\\n  }\\n\\n  /**\\n   * @return Half ray, 1e18/2\\n   **/\\n  function halfWad() internal pure returns (uint256) {\\n    return halfWAD;\\n  }\\n\\n  /**\\n   * @dev Multiplies two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a*b, in wad\\n   **/\\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n\\n    return (a * b + halfWAD) / WAD;\\n  }\\n\\n  /**\\n   * @dev Divides two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a/b, in wad\\n   **/\\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 halfB = b / 2;\\n\\n    return (a * WAD + halfB) / b;\\n  }\\n\\n  /**\\n   * @dev Multiplies two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a*b, in ray\\n   **/\\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n\\n    return (a * b + halfRAY) / RAY;\\n  }\\n\\n  /**\\n   * @dev Divides two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a/b, in ray\\n   **/\\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 halfB = b / 2;\\n\\n    return (a * RAY + halfB) / b;\\n  }\\n\\n  /**\\n   * @dev Casts ray down to wad\\n   * @param a Ray\\n   * @return a casted to wad, rounded half up to the nearest wad\\n   **/\\n  function rayToWad(uint256 a) internal pure returns (uint256) {\\n    uint256 halfRatio = WAD_RAY_RATIO / 2;\\n    uint256 result = halfRatio + a;\\n\\n    return result / WAD_RAY_RATIO;\\n  }\\n\\n  /**\\n   * @dev Converts wad up to ray\\n   * @param a Wad\\n   * @return a converted in ray\\n   **/\\n  function wadToRay(uint256 a) internal pure returns (uint256) {\\n    uint256 result = a * WAD_RAY_RATIO;\\n\\n    return result;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/libraries/swap/BalancerswapAdapter2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\\nimport {IBalancerVault} from '../../../interfaces/IBalancerVault.sol';\\nimport {SafeERC20} from '../../../dependencies/openzeppelin/contracts/SafeERC20.sol';\\nimport {Errors} from '../../libraries/helpers/Errors.sol';\\n\\nlibrary BalancerswapAdapter2 {\\n  using SafeERC20 for IERC20;\\n\\n  struct Path {\\n    address[] tokens;\\n    bytes32[] poolIds;\\n  }\\n\\n  address constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;\\n\\n  function swapExactTokensForTokens(\\n    address assetToSwapFrom,\\n    address assetToSwapTo,\\n    uint256 amountToSwap,\\n    Path calldata path,\\n    uint256 minAmountOut\\n  ) external returns (uint256) {\\n    // Check path is valid\\n    uint256 length = path.tokens.length;\\n    require(length > 1 && length - 1 == path.poolIds.length, Errors.VT_SWAP_PATH_LENGTH_INVALID);\\n    require(\\n      path.tokens[0] == assetToSwapFrom && path.tokens[length - 1] == assetToSwapTo,\\n      Errors.VT_SWAP_PATH_TOKEN_INVALID\\n    );\\n\\n    // Approves the transfer for the swap. Approves for 0 first to comply with tokens that implement the anti frontrunning approval fix.\\n    IERC20(assetToSwapFrom).safeApprove(address(BALANCER_VAULT), 0);\\n    if (IERC20(assetToSwapFrom).allowance(address(this), address(BALANCER_VAULT)) == 0)\\n      IERC20(assetToSwapFrom).safeApprove(address(BALANCER_VAULT), amountToSwap);\\n\\n    IBalancerVault.BatchSwapStep[] memory swaps = new IBalancerVault.BatchSwapStep[](length - 1);\\n    int256[] memory limits = new int256[](length);\\n    for (uint256 i; i < length - 1; ++i) {\\n      swaps[i] = IBalancerVault.BatchSwapStep({\\n        poolId: path.poolIds[i],\\n        assetInIndex: i,\\n        assetOutIndex: i + 1,\\n        amount: 0,\\n        userData: '0'\\n      });\\n    }\\n    swaps[0].amount = amountToSwap;\\n    limits[0] = int256(amountToSwap);\\n    unchecked {\\n      limits[length - 1] = int256(0 - minAmountOut);\\n    }\\n\\n    IBalancerVault.FundManagement memory funds = IBalancerVault.FundManagement({\\n      sender: address(this),\\n      fromInternalBalance: false,\\n      recipient: payable(address(this)),\\n      toInternalBalance: false\\n    });\\n\\n    int256[] memory receivedAmount = IBalancerVault(BALANCER_VAULT).batchSwap(\\n      IBalancerVault.SwapKind.GIVEN_IN,\\n      swaps,\\n      path.tokens,\\n      funds,\\n      limits,\\n      block.timestamp\\n    );\\n\\n    uint256 receivedPositveAmount;\\n    unchecked {\\n      receivedPositveAmount = uint256(0 - receivedAmount[length - 1]);\\n    }\\n\\n    require(receivedPositveAmount != 0, Errors.VT_SWAP_MISMATCH_RETURNED_AMOUNT);\\n    require(\\n      IERC20(assetToSwapTo).balanceOf(address(this)) >= receivedPositveAmount,\\n      Errors.VT_SWAP_MISMATCH_RETURNED_AMOUNT\\n    );\\n\\n    return receivedPositveAmount;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/libraries/swap/CurveswapAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\nimport {IERC20Detailed} from '../../../dependencies/openzeppelin/contracts/IERC20Detailed.sol';\\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\\nimport {IPriceOracleGetter} from '../../../interfaces/IPriceOracleGetter.sol';\\nimport {ICurveAddressProvider} from '../../../interfaces/ICurveAddressProvider.sol';\\nimport {ICurveExchange} from '../../../interfaces/ICurveExchange.sol';\\nimport {ILendingPoolAddressesProvider} from '../../../interfaces/ILendingPoolAddressesProvider.sol';\\nimport {SafeERC20} from '../../../dependencies/openzeppelin/contracts/SafeERC20.sol';\\nimport {PercentageMath} from '../../libraries/math/PercentageMath.sol';\\nimport {Errors} from '../../libraries/helpers/Errors.sol';\\n\\nlibrary CurveswapAdapter {\\n  using PercentageMath for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  struct Path {\\n    address[9] routes;\\n    uint256[3][4] swapParams;\\n  }\\n\\n  address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n  function swapExactTokensForTokens(\\n    ILendingPoolAddressesProvider addressesProvider,\\n    address poolAddress,\\n    address assetToSwapFrom,\\n    address assetToSwapTo,\\n    uint256 amountToSwap,\\n    uint256 slippage // 2% = 200\\n  ) external returns (uint256) {\\n    uint256 minAmountOut = _getMinAmount(\\n      addressesProvider,\\n      assetToSwapFrom,\\n      assetToSwapTo,\\n      amountToSwap,\\n      slippage\\n    );\\n\\n    // Approves the transfer for the swap. Approves for 0 first to comply with tokens that implement the anti frontrunning approval fix.\\n    address curveAddressProvider = addressesProvider.getAddress('CURVE_ADDRESS_PROVIDER');\\n    address curveExchange = ICurveAddressProvider(curveAddressProvider).get_address(2);\\n\\n    IERC20(assetToSwapFrom).safeApprove(address(curveExchange), 0);\\n    IERC20(assetToSwapFrom).safeApprove(address(curveExchange), amountToSwap);\\n\\n    uint256 receivedAmount = ICurveExchange(curveExchange).exchange(\\n      poolAddress,\\n      assetToSwapFrom,\\n      assetToSwapTo,\\n      amountToSwap,\\n      minAmountOut,\\n      address(this)\\n    );\\n\\n    require(receivedAmount != 0, Errors.VT_SWAP_MISMATCH_RETURNED_AMOUNT);\\n    uint256 balanceOfAsset;\\n    if (assetToSwapTo == ETH) {\\n      balanceOfAsset = address(this).balance;\\n    } else {\\n      balanceOfAsset = IERC20(assetToSwapTo).balanceOf(address(this));\\n    }\\n    require(balanceOfAsset >= receivedAmount, Errors.VT_SWAP_MISMATCH_RETURNED_AMOUNT);\\n    return receivedAmount;\\n  }\\n\\n  function _getDecimals(address asset) internal view returns (uint256) {\\n    if (asset == ETH) {\\n      return 18;\\n    }\\n    return IERC20Detailed(asset).decimals();\\n  }\\n\\n  function _getPrice(\\n    ILendingPoolAddressesProvider addressesProvider,\\n    address asset\\n  ) internal view returns (uint256) {\\n    if (asset == ETH) {\\n      return 1e18;\\n    }\\n    return IPriceOracleGetter(addressesProvider.getPriceOracle()).getAssetPrice(asset);\\n  }\\n\\n  function _getMinAmount(\\n    ILendingPoolAddressesProvider addressesProvider,\\n    address assetToSwapFrom,\\n    address assetToSwapTo,\\n    uint256 amountToSwap,\\n    uint256 slippage\\n  ) internal view returns (uint256) {\\n    uint256 fromAssetDecimals = _getDecimals(assetToSwapFrom);\\n    uint256 toAssetDecimals = _getDecimals(assetToSwapTo);\\n\\n    uint256 fromAssetPrice = _getPrice(addressesProvider, assetToSwapFrom);\\n    uint256 toAssetPrice = _getPrice(addressesProvider, assetToSwapTo);\\n\\n    uint256 minAmountOut = ((amountToSwap * fromAssetPrice * 10 ** toAssetDecimals) /\\n      (toAssetPrice * 10 ** fromAssetDecimals)).percentMul(\\n        PercentageMath.PERCENTAGE_FACTOR - slippage\\n      );\\n\\n    return minAmountOut;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/libraries/swap/CurveswapAdapter2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\\nimport {ICurveAddressProvider} from '../../../interfaces/ICurveAddressProvider.sol';\\nimport {ICurveExchange} from '../../../interfaces/ICurveExchange.sol';\\nimport {ILendingPoolAddressesProvider} from '../../../interfaces/ILendingPoolAddressesProvider.sol';\\nimport {SafeERC20} from '../../../dependencies/openzeppelin/contracts/SafeERC20.sol';\\nimport {Errors} from '../../libraries/helpers/Errors.sol';\\n\\nlibrary CurveswapAdapter2 {\\n  using SafeERC20 for IERC20;\\n\\n  struct Path {\\n    address[9] routes;\\n    uint256[3][4] swapParams;\\n  }\\n\\n  address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n  function swapExactTokensForTokens(\\n    ILendingPoolAddressesProvider addressesProvider,\\n    address assetToSwapFrom,\\n    address assetToSwapTo,\\n    uint256 amountToSwap,\\n    Path calldata path,\\n    uint256 minAmountOut\\n  ) external returns (uint256) {\\n    // Approves the transfer for the swap. Approves for 0 first to comply with tokens that implement the anti frontrunning approval fix.\\n    address curveAddressProvider = addressesProvider.getAddress('CURVE_ADDRESS_PROVIDER');\\n    address curveExchange = ICurveAddressProvider(curveAddressProvider).get_address(2);\\n\\n    IERC20(assetToSwapFrom).safeApprove(address(curveExchange), 0);\\n    IERC20(assetToSwapFrom).safeApprove(address(curveExchange), amountToSwap);\\n\\n    address[4] memory pools;\\n    uint256 receivedAmount = ICurveExchange(curveExchange).exchange_multiple(\\n      path.routes,\\n      path.swapParams,\\n      amountToSwap,\\n      minAmountOut,\\n      pools,\\n      address(this)\\n    );\\n\\n    require(receivedAmount != 0, Errors.VT_SWAP_MISMATCH_RETURNED_AMOUNT);\\n    uint256 balanceOfAsset;\\n    if (assetToSwapTo == ETH) {\\n      balanceOfAsset = address(this).balance;\\n    } else {\\n      balanceOfAsset = IERC20(assetToSwapTo).balanceOf(address(this));\\n    }\\n    require(balanceOfAsset >= receivedAmount, Errors.VT_SWAP_MISMATCH_RETURNED_AMOUNT);\\n    return receivedAmount;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/libraries/swap/UniswapAdapter2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol';\\nimport {ISwapRouter} from '../../../interfaces/ISwapRouter.sol';\\nimport {ILendingPoolAddressesProvider} from '../../../interfaces/ILendingPoolAddressesProvider.sol';\\nimport {SafeERC20} from '../../../dependencies/openzeppelin/contracts/SafeERC20.sol';\\nimport {Errors} from '../../libraries/helpers/Errors.sol';\\n\\nlibrary UniswapAdapter2 {\\n  using SafeERC20 for IERC20;\\n\\n  struct Path {\\n    address[] tokens;\\n    uint256[] fees;\\n  }\\n\\n  function swapExactTokensForTokens(\\n    ILendingPoolAddressesProvider addressesProvider,\\n    address assetToSwapFrom,\\n    address assetToSwapTo,\\n    uint256 amountToSwap,\\n    Path calldata path,\\n    uint256 minAmountOut\\n  ) external returns (uint256) {\\n    // Check path is valid\\n    uint256 length = path.tokens.length;\\n    require(length > 1 && length - 1 == path.fees.length, Errors.VT_SWAP_PATH_LENGTH_INVALID);\\n    require(\\n      path.tokens[0] == assetToSwapFrom && path.tokens[length - 1] == assetToSwapTo,\\n      Errors.VT_SWAP_PATH_TOKEN_INVALID\\n    );\\n\\n    // Approves the transfer for the swap. Approves for 0 first to comply with tokens that implement the anti frontrunning approval fix.\\n    address UNISWAP_ROUTER = addressesProvider.getAddress('uniswapRouter');\\n    IERC20(assetToSwapFrom).safeApprove(address(UNISWAP_ROUTER), 0);\\n    IERC20(assetToSwapFrom).safeApprove(address(UNISWAP_ROUTER), amountToSwap);\\n\\n    uint256 receivedAmount;\\n    if (length > 2) {\\n      bytes memory _path;\\n\\n      for (uint256 i; i < length - 1; ++i) {\\n        _path = abi.encodePacked(_path, path.tokens[i], uint24(path.fees[i]));\\n      }\\n      _path = abi.encodePacked(_path, assetToSwapTo);\\n\\n      ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({\\n        path: _path,\\n        recipient: address(this),\\n        deadline: block.timestamp,\\n        amountIn: amountToSwap,\\n        amountOutMinimum: minAmountOut\\n      });\\n\\n      // Executes the swap.\\n      receivedAmount = ISwapRouter(UNISWAP_ROUTER).exactInput(params);\\n    } else {\\n      ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\\n        tokenIn: assetToSwapFrom,\\n        tokenOut: assetToSwapTo,\\n        fee: uint24(path.fees[0]),\\n        recipient: address(this),\\n        deadline: block.timestamp,\\n        amountIn: amountToSwap,\\n        amountOutMinimum: minAmountOut,\\n        sqrtPriceLimitX96: 0\\n      });\\n\\n      // Executes the swap.\\n      receivedAmount = ISwapRouter(UNISWAP_ROUTER).exactInputSingle(params);\\n    }\\n\\n    require(receivedAmount != 0, Errors.VT_SWAP_MISMATCH_RETURNED_AMOUNT);\\n    require(\\n      IERC20(assetToSwapTo).balanceOf(address(this)) >= receivedAmount,\\n      Errors.VT_SWAP_MISMATCH_RETURNED_AMOUNT\\n    );\\n\\n    return receivedAmount;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/libraries/types/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nlibrary DataTypes {\\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\\n  struct ReserveData {\\n    //stores the reserve configuration\\n    ReserveConfigurationMap configuration;\\n    //the liquidity index. Expressed in ray\\n    uint128 liquidityIndex;\\n    //variable borrow index. Expressed in ray\\n    uint128 variableBorrowIndex;\\n    //the current supply rate. Expressed in ray\\n    uint128 currentLiquidityRate;\\n    //the current variable borrow rate. Expressed in ray\\n    uint128 currentVariableBorrowRate;\\n    //the current stable borrow rate. Expressed in ray\\n    uint128 currentStableBorrowRate;\\n    uint40 lastUpdateTimestamp;\\n    //tokens addresses\\n    address aTokenAddress;\\n    address stableDebtTokenAddress;\\n    address variableDebtTokenAddress;\\n    //address of the interest rate strategy\\n    address interestRateStrategyAddress;\\n    //address of the yield contract\\n    address yieldAddress;\\n    //the id of the reserve. Represents the position in the list of the active reserves\\n    uint8 id;\\n  }\\n\\n  struct ReserveConfigurationMap {\\n    //bit 0-15: LTV\\n    //bit 16-31: Liq. threshold\\n    //bit 32-47: Liq. bonus\\n    //bit 48-55: Decimals\\n    //bit 56: Reserve is active\\n    //bit 57: reserve is frozen\\n    //bit 58: borrowing is enabled\\n    //bit 59: stable rate borrowing enabled\\n    //bit 60-63: reserved\\n    //bit 64-79: reserve factor\\n    uint256 data;\\n  }\\n\\n  struct UserConfigurationMap {\\n    uint256 data;\\n  }\\n\\n  enum InterestRateMode {\\n    NONE,\\n    STABLE,\\n    VARIABLE\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/protocol/libraries/swap/BalancerswapAdapter2.sol\": {\r\n        \"BalancerswapAdapter2\": \"0xc0ddd95419e2375b7cdc9c12a8db464584e158f3\"\r\n      },\r\n      \"contracts/protocol/libraries/swap/CurveswapAdapter2.sol\": {\r\n        \"CurveswapAdapter2\": \"0x31780cc26c7c66a7a72bde665147de4001b302ec\"\r\n      },\r\n      \"contracts/protocol/libraries/swap/UniswapAdapter2.sol\": {\r\n        \"UniswapAdapter2\": \"0x31d5b63b54259b37e74c767706f135ac1c9b8879\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"COLLATERAL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VAULT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_leverage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_borrowAsset\",\"type\":\"address\"},{\"internalType\":\"enum IGeneralLevSwap.FlashLoanType\",\"name\":\"_flashLoanType\",\"type\":\"uint8\"},{\"components\":[{\"components\":[{\"internalType\":\"address[9]\",\"name\":\"routes\",\"type\":\"address[9]\"},{\"internalType\":\"uint256[3][4]\",\"name\":\"routeParams\",\"type\":\"uint256[3][4]\"},{\"internalType\":\"enum IGeneralLevSwap.SwapType\",\"name\":\"swapType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"poolCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"swapFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IGeneralLevSwap.MultipSwapPath[3]\",\"name\":\"paths\",\"type\":\"tuple[3]\"},{\"components\":[{\"internalType\":\"address[9]\",\"name\":\"routes\",\"type\":\"address[9]\"},{\"internalType\":\"uint256[3][4]\",\"name\":\"routeParams\",\"type\":\"uint256[3][4]\"},{\"internalType\":\"enum IGeneralLevSwap.SwapType\",\"name\":\"swapType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"poolCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"swapFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IGeneralLevSwap.MultipSwapPath[3]\",\"name\":\"reversePaths\",\"type\":\"tuple[3]\"},{\"internalType\":\"uint256\",\"name\":\"pathLength\",\"type\":\"uint256\"}],\"internalType\":\"struct IGeneralLevSwap.SwapInfo\",\"name\":\"_swapInfo\",\"type\":\"tuple\"}],\"name\":\"enterPositionWithFlashloan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"premiums\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"executeOperation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAvailableBorrowAssets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"feeAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"name\":\"receiveFlashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_repayAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_requiredAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_borrowAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sAsset\",\"type\":\"address\"},{\"internalType\":\"enum IGeneralLevSwap.FlashLoanType\",\"name\":\"_flashLoanType\",\"type\":\"uint8\"},{\"components\":[{\"components\":[{\"internalType\":\"address[9]\",\"name\":\"routes\",\"type\":\"address[9]\"},{\"internalType\":\"uint256[3][4]\",\"name\":\"routeParams\",\"type\":\"uint256[3][4]\"},{\"internalType\":\"enum IGeneralLevSwap.SwapType\",\"name\":\"swapType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"poolCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"swapFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IGeneralLevSwap.MultipSwapPath[3]\",\"name\":\"paths\",\"type\":\"tuple[3]\"},{\"components\":[{\"internalType\":\"address[9]\",\"name\":\"routes\",\"type\":\"address[9]\"},{\"internalType\":\"uint256[3][4]\",\"name\":\"routeParams\",\"type\":\"uint256[3][4]\"},{\"internalType\":\"enum IGeneralLevSwap.SwapType\",\"name\":\"swapType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"poolCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"swapFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IGeneralLevSwap.MultipSwapPath[3]\",\"name\":\"reversePaths\",\"type\":\"tuple[3]\"},{\"internalType\":\"uint256\",\"name\":\"pathLength\",\"type\":\"uint256\"}],\"internalType\":\"struct IGeneralLevSwap.SwapInfo\",\"name\":\"_swapInfo\",\"type\":\"tuple\"}],\"name\":\"withdrawWithFlashloan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_zappingAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_principal\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address[9]\",\"name\":\"routes\",\"type\":\"address[9]\"},{\"internalType\":\"uint256[3][4]\",\"name\":\"routeParams\",\"type\":\"uint256[3][4]\"},{\"internalType\":\"enum IGeneralLevSwap.SwapType\",\"name\":\"swapType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"poolCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"swapFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IGeneralLevSwap.MultipSwapPath[3]\",\"name\":\"_zapPaths\",\"type\":\"tuple[3]\"},{\"internalType\":\"uint256\",\"name\":\"_zapPathLength\",\"type\":\"uint256\"}],\"name\":\"zapDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_zappingAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_leverage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_borrowAsset\",\"type\":\"address\"},{\"internalType\":\"enum IGeneralLevSwap.FlashLoanType\",\"name\":\"_flashLoanType\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"address[9]\",\"name\":\"routes\",\"type\":\"address[9]\"},{\"internalType\":\"uint256[3][4]\",\"name\":\"routeParams\",\"type\":\"uint256[3][4]\"},{\"internalType\":\"enum IGeneralLevSwap.SwapType\",\"name\":\"swapType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"poolCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"swapFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IGeneralLevSwap.MultipSwapPath[3]\",\"name\":\"_zapPaths\",\"type\":\"tuple[3]\"},{\"internalType\":\"uint256\",\"name\":\"_zapPathLength\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"address[9]\",\"name\":\"routes\",\"type\":\"address[9]\"},{\"internalType\":\"uint256[3][4]\",\"name\":\"routeParams\",\"type\":\"uint256[3][4]\"},{\"internalType\":\"enum IGeneralLevSwap.SwapType\",\"name\":\"swapType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"poolCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"swapFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IGeneralLevSwap.MultipSwapPath[3]\",\"name\":\"paths\",\"type\":\"tuple[3]\"},{\"components\":[{\"internalType\":\"address[9]\",\"name\":\"routes\",\"type\":\"address[9]\"},{\"internalType\":\"uint256[3][4]\",\"name\":\"routeParams\",\"type\":\"uint256[3][4]\"},{\"internalType\":\"enum IGeneralLevSwap.SwapType\",\"name\":\"swapType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"poolCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"swapFrom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IGeneralLevSwap.MultipSwapPath[3]\",\"name\":\"reversePaths\",\"type\":\"tuple[3]\"},{\"internalType\":\"uint256\",\"name\":\"pathLength\",\"type\":\"uint256\"}],\"internalType\":\"struct IGeneralLevSwap.SwapInfo\",\"name\":\"_swapInfo\",\"type\":\"tuple\"}],\"name\":\"zapLeverageWithFlashloan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DAIUSDCUSDTSUSDLevSwap", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c25a3a3b969415c80451098fa907ec722572917f0000000000000000000000009700e0b9d22fe10ff00170462c98abffa2505de2000000000000000000000000b7499a92fc36e9053a4324affae59d333635d9c3", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}