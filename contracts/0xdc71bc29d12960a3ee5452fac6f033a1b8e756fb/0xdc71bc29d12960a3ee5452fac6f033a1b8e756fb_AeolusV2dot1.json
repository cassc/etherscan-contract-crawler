{"SourceCode": "// File: contracts/math/SafeMath.sol\r\n\r\npragma solidity <0.6 >=0.4.21;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n\r\n  /*@CTK SafeMath_mul\r\n    @tag spec\r\n    @post __reverted == __has_assertion_failure\r\n    @post __has_assertion_failure == __has_overflow\r\n    @post __reverted == false -> c == a * b\r\n    @post msg == msg__post\r\n   */\r\n  /* CertiK Smart Labelling, for more details visit: https://certik.org */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  /*@CTK SafeMath_div\r\n    @tag spec\r\n    @pre b != 0\r\n    @post __reverted == __has_assertion_failure\r\n    @post __has_overflow == true -> __has_assertion_failure == true\r\n    @post __reverted == false -> __return == a / b\r\n    @post msg == msg__post\r\n   */\r\n  /* CertiK Smart Labelling, for more details visit: https://certik.org */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  /*@CTK SafeMath_sub\r\n    @tag spec\r\n    @post __reverted == __has_assertion_failure\r\n    @post __has_overflow == true -> __has_assertion_failure == true\r\n    @post __reverted == false -> __return == a - b\r\n    @post msg == msg__post\r\n   */\r\n  /* CertiK Smart Labelling, for more details visit: https://certik.org */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  /*@CTK SafeMath_add\r\n    @tag spec\r\n    @post __reverted == __has_assertion_failure\r\n    @post __has_assertion_failure == __has_overflow\r\n    @post __reverted == false -> c == a + b\r\n    @post msg == msg__post\r\n   */\r\n  /* CertiK Smart Labelling, for more details visit: https://certik.org */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/ownership/Ownable.sol\r\n\r\npragma solidity <6.0 >=0.4.0;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/token/IERC20Basic.sol\r\n\r\npragma solidity <0.6 >=0.4.21;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract IERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: contracts/token/IERC20.sol\r\n\r\npragma solidity <0.6 >=0.4.21;\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract IERC20 is IERC20Basic {\r\n  function name() external view returns (string memory);\r\n  function symbol() external view returns (string memory);\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/token/IMintableToken.sol\r\n\r\npragma solidity <0.6 >=0.4.24;\r\n\r\n\r\ncontract IMintableToken is IERC20 {\r\n    function mint(address, uint) external returns (bool);\r\n    function burn(uint) external returns (bool);\r\n\r\n    event Minted(address indexed to, uint256 amount);\r\n    event Burned(address indexed from, uint256 amount);\r\n    event MinterAdded(address indexed minter);\r\n    event MinterRemoved(address indexed minter);\r\n}\r\n\r\n// File: contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type,\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: contracts/token/SafeERC20.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/uniswapv2/IRouter.sol\r\n\r\npragma solidity >=0.5.0 <0.8.0;\r\n\r\ninterface IRouter {\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function swapETHForExactTokens(\r\n        uint amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\r\n}\r\n\r\n// File: contracts/AeolusV2dot1.sol\r\n\r\npragma solidity <0.6 >=0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Aeolus is the master of Cyclone tokens. He can distribute CYC and he is a fair guy.\r\n//\r\n// Note that it's ownable and the owner wields tremendous power. The ownership\r\n// will be transferred to a governance smart contract once CYC is sufficiently\r\n// distributed and the community can show to govern itself.\r\n//\r\n// Have fun reading it. Hopefully it's bug-free. God bless.\r\ncontract AeolusV2dot1 is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // Info of each user.\r\n    struct UserInfo {\r\n        uint256 amount;     // How many LP tokens the user has provided.\r\n        uint256 rewardDebt; // Reward debt. See explanation below.\r\n        //\r\n        // We do some fancy math here. Basically, any point in time, the amount of CYCs\r\n        // entitled to a user but is pending to be distributed is:\r\n        //\r\n        //   pending reward = (user.amount * accCYCPerShare) - user.rewardDebt\r\n        //\r\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\r\n        //   1. Update accCYCPerShare and lastRewardBlock\r\n        //   2. User receives the pending reward sent to his/her address.\r\n        //   3. User's `amount` gets updated.\r\n        //   4. User's `rewardDebt` gets updated.\r\n    }\r\n\r\n\r\n    // Address of LP token contract.\r\n    IERC20 public lpToken;\r\n    // Accumulated CYCs per share, times 1e12. See below.\r\n    uint256 public accCYCPerShare;\r\n    // Last block reward block height\r\n    uint256 public lastRewardBlock;\r\n    // Reward per block\r\n    uint256 public rewardPerBlock;\r\n    // Reward to distribute\r\n    uint256 public rewardToDistribute;\r\n    // Entrance Fee Rate\r\n    uint256 public entranceFeeRate;\r\n\r\n    IERC20 public wrappedCoin;\r\n    IRouter public router;\r\n    // The Cyclone TOKEN\r\n    IMintableToken public cycToken;\r\n\r\n    // Info of each user that stakes LP tokens.\r\n    mapping (address => UserInfo) public userInfo;\r\n\r\n    event RewardAdded(uint256 amount, bool isBlockReward);\r\n    event Deposit(address indexed user, uint256 amount, uint256 fee);\r\n    event Withdraw(address indexed user, uint256 amount);\r\n    event EmergencyWithdraw(address indexed user, uint256 amount);\r\n\r\n    constructor(IMintableToken _cycToken, IERC20 _lpToken, address _router, IERC20 _wrappedCoin) public {\r\n        cycToken = _cycToken;\r\n        lastRewardBlock = block.number;\r\n        lpToken = _lpToken;\r\n        router = IRouter(_router);\r\n        wrappedCoin = _wrappedCoin;\r\n        require(_lpToken.approve(_router, uint256(-1)), \"failed to approve router\");\r\n        require(_wrappedCoin.approve(_router, uint256(-1)), \"failed to approve router\");\r\n    }\r\n\r\n    function setEntranceFeeRate(uint256 _entranceFeeRate) public onlyOwner {\r\n        require(_entranceFeeRate < 10000, \"invalid entrance fee rate\");\r\n        entranceFeeRate = _entranceFeeRate;\r\n    }\r\n\r\n    function setRewardPerBlock(uint256 _rewardPerBlock) public onlyOwner {\r\n        updateBlockReward();\r\n        rewardPerBlock = _rewardPerBlock;\r\n    }\r\n\r\n    function rewardPending() internal view returns (uint256) {\r\n        uint256 reward = block.number.sub(lastRewardBlock).mul(rewardPerBlock);\r\n        uint256 cycBalance = cycToken.balanceOf(address(this)).sub(rewardToDistribute);\r\n        if (cycBalance < reward) {\r\n            return cycBalance;\r\n        }\r\n        return reward;\r\n    }\r\n\r\n    // View function to see pending reward on frontend.\r\n    function pendingReward(address _user) external view returns (uint256) {\r\n        UserInfo storage user = userInfo[_user];\r\n        uint256 acps = accCYCPerShare;\r\n        if (rewardPerBlock > 0) {\r\n            uint256 lpSupply = lpToken.balanceOf(address(this));\r\n            if (block.number > lastRewardBlock && lpSupply > 0) {\r\n                acps = acps.add(rewardPending().mul(1e12).div(lpSupply));\r\n            }\r\n        }\r\n\r\n        return user.amount.mul(acps).div(1e12).sub(user.rewardDebt);\r\n    }\r\n\r\n    // Update reward variables to be up-to-date.\r\n    function updateBlockReward() public {\r\n        if (block.number <= lastRewardBlock || rewardPerBlock == 0) {\r\n            return;\r\n        }\r\n        uint256 lpSupply = lpToken.balanceOf(address(this));\r\n        uint256 reward = rewardPending();\r\n        if (lpSupply == 0 || reward == 0) {\r\n            lastRewardBlock = block.number;\r\n            return;\r\n        }\r\n        rewardToDistribute = rewardToDistribute.add(reward);\r\n        emit RewardAdded(reward, true);\r\n        lastRewardBlock = block.number;\r\n        accCYCPerShare = accCYCPerShare.add(reward.mul(1e12).div(lpSupply));\r\n    }\r\n\r\n    // Deposit LP tokens to Aeolus for CYC allocation.\r\n    function deposit(uint256 _amount) public {\r\n        updateBlockReward();\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        uint256 originAmount = user.amount;\r\n        uint256 acps = accCYCPerShare;\r\n        if (originAmount > 0) {\r\n            uint256 pending = originAmount.mul(acps).div(1e12).sub(user.rewardDebt);\r\n            if (pending > 0) {\r\n                safeCYCTransfer(msg.sender, pending);\r\n            }\r\n        }\r\n        uint256 feeInCYC = 0;\r\n        if (_amount > 0) {\r\n            lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\r\n            uint256 entranceFee = _amount.mul(entranceFeeRate).div(10000);\r\n            if (entranceFee > 0) {\r\n                IERC20 wct = wrappedCoin;\r\n                (uint256 wcAmount, uint256 cycAmount) = router.removeLiquidity(address(wct), address(cycToken), entranceFee, 0, 0, address(this), block.timestamp.mul(2));\r\n                if (wcAmount > 0) {\r\n                    address[] memory path = new address[](2);\r\n                    path[0] = address(wct);\r\n                    path[1] = address(cycToken);\r\n                    uint256[] memory amounts = router.swapExactTokensForTokens(wcAmount, 0, path, address(this), block.timestamp.mul(2));\r\n                    feeInCYC = cycAmount.add(amounts[1]);\r\n                } else {\r\n                    feeInCYC = cycAmount;\r\n                }\r\n                if (feeInCYC > 0) {\r\n                    require(cycToken.burn(feeInCYC), \"failed to burn cyc token\");\r\n                }\r\n                _amount = _amount.sub(entranceFee);\r\n            }\r\n            user.amount = originAmount.add(_amount);\r\n        }\r\n        user.rewardDebt = user.amount.mul(acps).div(1e12);\r\n        emit Deposit(msg.sender, _amount, feeInCYC);\r\n    }\r\n\r\n    // Withdraw LP tokens from Aeolus.\r\n    function withdraw(uint256 _amount) public {\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        uint256 originAmount = user.amount;\r\n        require(originAmount >= _amount, \"withdraw: not good\");\r\n        updateBlockReward();\r\n        uint256 acps = accCYCPerShare;\r\n        uint256 pending = originAmount.mul(acps).div(1e12).sub(user.rewardDebt);\r\n        if (pending > 0) {\r\n            safeCYCTransfer(msg.sender, pending);\r\n        }\r\n        if (_amount > 0) {\r\n            user.amount = originAmount.sub(_amount);\r\n            lpToken.safeTransfer(address(msg.sender), _amount);\r\n        }\r\n        user.rewardDebt = user.amount.mul(acps).div(1e12);\r\n        emit Withdraw(msg.sender, _amount);\r\n    }\r\n\r\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\r\n    function emergencyWithdraw() public {\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        uint256 amount = user.amount;\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n        lpToken.safeTransfer(address(msg.sender), amount);\r\n        emit EmergencyWithdraw(msg.sender, amount);\r\n    }\r\n\r\n    // Safe CYC transfer function, just in case if rounding error causes pool to not have enough CYCs.\r\n    function safeCYCTransfer(address _to, uint256 _amount) internal {\r\n        IMintableToken token = cycToken;\r\n        uint256 cycBalance = token.balanceOf(address(this));\r\n        if (_amount > cycBalance) {\r\n            _amount = cycBalance;\r\n        }\r\n        rewardToDistribute = rewardToDistribute.sub(_amount);\r\n        require(token.transfer(_to, _amount), \"failed to transfer cyc token\");\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IMintableToken\",\"name\":\"_cycToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_wrappedCoin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBlockReward\",\"type\":\"bool\"}],\"name\":\"RewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"accCYCPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cycToken\",\"outputs\":[{\"internalType\":\"contract IMintableToken\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"entranceFeeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastRewardBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lpToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardToDistribute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_entranceFeeRate\",\"type\":\"uint256\"}],\"name\":\"setEntranceFeeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardPerBlock\",\"type\":\"uint256\"}],\"name\":\"setRewardPerBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateBlockReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wrappedCoin\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AeolusV2dot1", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008861cff2366c1128fd699b68304ad99a0764ef9a00000000000000000000000037d9c7f451e5c619a7d4ca01e06761eb7dae6f890000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU LGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://ab6c4638ed2de10be40f70dfa5ec3205ba6c6ad4b476b2aecbee6c40e4225798"}