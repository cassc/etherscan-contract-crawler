{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"openzeppelin-contracts/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\\n\\n    /**\\n     * @dev An int value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedIntToUint(int256 value);\\n\\n    /**\\n     * @dev Value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\\n\\n    /**\\n     * @dev An uint value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedUintToInt(uint256 value);\\n\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        if (value > type(uint248).max) {\\n            revert SafeCastOverflowedUintDowncast(248, value);\\n        }\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        if (value > type(uint240).max) {\\n            revert SafeCastOverflowedUintDowncast(240, value);\\n        }\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        if (value > type(uint232).max) {\\n            revert SafeCastOverflowedUintDowncast(232, value);\\n        }\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        if (value > type(uint224).max) {\\n            revert SafeCastOverflowedUintDowncast(224, value);\\n        }\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        if (value > type(uint216).max) {\\n            revert SafeCastOverflowedUintDowncast(216, value);\\n        }\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        if (value > type(uint208).max) {\\n            revert SafeCastOverflowedUintDowncast(208, value);\\n        }\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        if (value > type(uint200).max) {\\n            revert SafeCastOverflowedUintDowncast(200, value);\\n        }\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        if (value > type(uint192).max) {\\n            revert SafeCastOverflowedUintDowncast(192, value);\\n        }\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        if (value > type(uint184).max) {\\n            revert SafeCastOverflowedUintDowncast(184, value);\\n        }\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        if (value > type(uint176).max) {\\n            revert SafeCastOverflowedUintDowncast(176, value);\\n        }\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        if (value > type(uint168).max) {\\n            revert SafeCastOverflowedUintDowncast(168, value);\\n        }\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        if (value > type(uint160).max) {\\n            revert SafeCastOverflowedUintDowncast(160, value);\\n        }\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        if (value > type(uint152).max) {\\n            revert SafeCastOverflowedUintDowncast(152, value);\\n        }\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        if (value > type(uint144).max) {\\n            revert SafeCastOverflowedUintDowncast(144, value);\\n        }\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        if (value > type(uint136).max) {\\n            revert SafeCastOverflowedUintDowncast(136, value);\\n        }\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        if (value > type(uint128).max) {\\n            revert SafeCastOverflowedUintDowncast(128, value);\\n        }\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        if (value > type(uint120).max) {\\n            revert SafeCastOverflowedUintDowncast(120, value);\\n        }\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        if (value > type(uint112).max) {\\n            revert SafeCastOverflowedUintDowncast(112, value);\\n        }\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        if (value > type(uint104).max) {\\n            revert SafeCastOverflowedUintDowncast(104, value);\\n        }\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        if (value > type(uint96).max) {\\n            revert SafeCastOverflowedUintDowncast(96, value);\\n        }\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        if (value > type(uint88).max) {\\n            revert SafeCastOverflowedUintDowncast(88, value);\\n        }\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        if (value > type(uint80).max) {\\n            revert SafeCastOverflowedUintDowncast(80, value);\\n        }\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        if (value > type(uint72).max) {\\n            revert SafeCastOverflowedUintDowncast(72, value);\\n        }\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        if (value > type(uint64).max) {\\n            revert SafeCastOverflowedUintDowncast(64, value);\\n        }\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        if (value > type(uint56).max) {\\n            revert SafeCastOverflowedUintDowncast(56, value);\\n        }\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        if (value > type(uint48).max) {\\n            revert SafeCastOverflowedUintDowncast(48, value);\\n        }\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        if (value > type(uint40).max) {\\n            revert SafeCastOverflowedUintDowncast(40, value);\\n        }\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        if (value > type(uint32).max) {\\n            revert SafeCastOverflowedUintDowncast(32, value);\\n        }\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        if (value > type(uint24).max) {\\n            revert SafeCastOverflowedUintDowncast(24, value);\\n        }\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        if (value > type(uint16).max) {\\n            revert SafeCastOverflowedUintDowncast(16, value);\\n        }\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        if (value > type(uint8).max) {\\n            revert SafeCastOverflowedUintDowncast(8, value);\\n        }\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        if (value < 0) {\\n            revert SafeCastOverflowedIntToUint(value);\\n        }\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(248, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(240, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(232, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(224, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(216, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(208, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(200, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(192, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(184, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(176, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(168, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(160, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(152, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(144, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(136, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(128, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(120, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(112, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(104, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(96, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(88, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(80, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(72, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(64, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(56, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(48, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(40, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(32, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(24, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(16, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(8, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        if (value > uint256(type(int256).max)) {\\n            revert SafeCastOverflowedUintToInt(value);\\n        }\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nlibrary Constants {\\n    /// @notice Flooring protocol\\n    /// @dev floor token amount of 1 NFT (with 18 decimals)\\n    uint256 public constant FLOOR_TOKEN_AMOUNT = 1_000_000 ether;\\n    /// @dev The minimum vip level required to use `proxy collection`\\n    uint8 public constant PROXY_COLLECTION_VIP_THRESHOLD = 3;\\n\\n    /// @notice Rolling Bucket Constant Conf\\n    uint256 public constant BUCKET_SPAN_1 = 259199 seconds; // BUCKET_SPAN minus 1, used for rounding up\\n    uint256 public constant BUCKET_SPAN = 3 days;\\n    uint256 public constant MAX_LOCKING_BUCKET = 240;\\n    uint256 public constant MAX_LOCKING_PERIOD = 720 days; // MAX LOCKING BUCKET * BUCKET_SPAN\\n\\n    /// @notice Auction Config\\n    uint256 public constant FREE_AUCTION_PERIOD = 24 hours;\\n    uint256 public constant AUCTION_INITIAL_PERIODS = 24 hours;\\n    uint256 public constant AUCTION_COMPLETE_GRACE_PERIODS = 2 days;\\n    /// @dev minimum bid per NFT when someone starts aution on expired safebox\\n    uint256 public constant AUCTION_ON_EXPIRED_MINIMUM_BID = 1000 ether;\\n    /// @dev admin fee charged per NFT when someone starts aution on expired safebox\\n    uint256 public constant AUCTION_ON_EXPIRED_SAFEBOX_COST = 2000 ether;\\n    /// @dev admin fee charged per NFT when owner starts aution on himself safebox\\n    uint256 public constant AUCTION_COST = 2000 ether;\\n\\n    /// @notice Raffle Config\\n    uint256 public constant RAFFLE_COST = 5000 ether;\\n    uint256 public constant RAFFLE_COMPLETE_GRACE_PERIODS = 2 days;\\n\\n    /// @notice Private offer Config\\n    uint256 public constant PRIVATE_OFFER_DURATION = 24 hours;\\n    uint256 public constant PRIVATE_OFFER_COMPLETE_GRACE_DURATION = 2 days;\\n    uint256 public constant PRIVATE_OFFER_COST = 0;\\n\\n    uint256 public constant ADD_FREE_NFT_REWARD = 0;\\n\\n    /// @notice Lock/Unlock config\\n    uint256 public constant LOCKING_RAMP_UP_THRESHOLD = 20;\\n\\n    uint256 public constant LOCKING_PCT_TO_SAFEBOX_MAINT_MIN = 6000 ether;\\n    uint256 public constant LOCKING_PCT_TO_SAFEBOX_MAINT_MAX = 1728000 ether;\\n\\n    /// @notice Activities Fee Rate\\n\\n    /// @notice Fee rate used to distribute funds that collected from Auctions on expired safeboxes.\\n    /// these auction would be settled using credit token\\n    uint256 public constant FREE_AUCTION_FEE_RATE_BIPS = 2000; // 20%\\n    /// @notice Fee rate settled with credit token\\n    uint256 public constant CREDIT_FEE_RATE_BIPS = 150; // 2%\\n    /// @notice Fee rate settled with specified token\\n    uint256 public constant SPEC_FEE_RATE_BIPS = 300; // 3%\\n    /// @notice Fee rate settled with all other tokens\\n    uint256 public constant COMMON_FEE_RATE_BIPS = 500; // 5%\\n\\n    uint256 public constant VIP_LEVEL_COUNT = 8;\\n\\n    struct AuctionBidOption {\\n        uint256 extendDurationSecs;\\n        uint256 minimumRaisePct;\\n        uint256 vipLevel;\\n    }\\n\\n    function getVipLockingBuckets(uint256 vipLevel) internal pure returns (uint256 buckets) {\\n        require(vipLevel < VIP_LEVEL_COUNT);\\n        assembly {\\n            switch vipLevel\\n            case 1 { buckets := 1 }\\n            case 2 { buckets := 5 }\\n            case 3 { buckets := 20 }\\n            case 4 { buckets := 60 }\\n            case 5 { buckets := 120 }\\n            case 6 { buckets := 240 }\\n            case 7 { buckets := MAX_LOCKING_BUCKET }\\n        }\\n    }\\n\\n    function getVipLevel(uint256 totalCredit) internal pure returns (uint8) {\\n        if (totalCredit < 50_000 ether) {\\n            return 0;\\n        } else if (totalCredit < 200_000 ether) {\\n            return 1;\\n        } else if (totalCredit < 500_000 ether) {\\n            return 2;\\n        } else if (totalCredit < 2_000_000 ether) {\\n            return 3;\\n        } else if (totalCredit < 5_000_000 ether) {\\n            return 4;\\n        } else if (totalCredit < 20_000_000 ether) {\\n            return 5;\\n        } else if (totalCredit < 50_000_000 ether) {\\n            return 6;\\n        } else {\\n            return 7;\\n        }\\n    }\\n\\n    function getVipBalanceRequirements(uint256 vipLevel) internal pure returns (uint256 required) {\\n        require(vipLevel < VIP_LEVEL_COUNT);\\n\\n        assembly {\\n            switch vipLevel\\n            case 1 { required := 50000 }\\n            case 2 { required := 200000 }\\n            case 3 { required := 500000 }\\n            case 4 { required := 2000000 }\\n            case 5 { required := 5000000 }\\n            case 6 { required := 20000000 }\\n            case 7 { required := 50000000 }\\n        }\\n\\n        /// credit token should be scaled with 18 decimals(1 ether == 10**18)\\n        unchecked {\\n            return required * 1 ether;\\n        }\\n    }\\n\\n    function getBidOption(uint256 idx) internal pure returns (AuctionBidOption memory) {\\n        require(idx < 4);\\n        AuctionBidOption[4] memory bidOptions = [\\n            AuctionBidOption({extendDurationSecs: 5 minutes, minimumRaisePct: 1, vipLevel: 0}),\\n            AuctionBidOption({extendDurationSecs: 8 hours, minimumRaisePct: 10, vipLevel: 3}),\\n            AuctionBidOption({extendDurationSecs: 16 hours, minimumRaisePct: 20, vipLevel: 5}),\\n            AuctionBidOption({extendDurationSecs: 24 hours, minimumRaisePct: 40, vipLevel: 7})\\n        ];\\n        return bidOptions[idx];\\n    }\\n\\n    function raffleDurations(uint256 idx) internal pure returns (uint256 vipLevel, uint256 duration) {\\n        require(idx < 6);\\n\\n        vipLevel = idx;\\n        assembly {\\n            switch idx\\n            case 1 { duration := 1 }\\n            case 2 { duration := 2 }\\n            case 3 { duration := 3 }\\n            case 4 { duration := 5 }\\n            case 5 { duration := 7 }\\n        }\\n        unchecked {\\n            duration *= 1 days;\\n        }\\n    }\\n\\n    function getVipRequiredStakingWithDiscount(uint256 requiredStaking, uint8 vipLevel)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (vipLevel < 3) {\\n            return requiredStaking;\\n        }\\n        unchecked {\\n            /// the higher vip level, more discount for staking\\n            ///  discount range: 10% - 50%\\n            return requiredStaking * (100 - (vipLevel - 2) * 10) / 100;\\n        }\\n    }\\n\\n    function getRequiredStakingForLockRatio(uint256 locked, uint256 totalManaged) internal pure returns (uint256) {\\n        if (totalManaged < Constants.LOCKING_RAMP_UP_THRESHOLD) {\\n            return 6000 ether;\\n        }\\n\\n        unchecked {\\n            uint256 lockingRatioPct = locked * 100 / totalManaged;\\n            if (lockingRatioPct <= 40) {\\n                return 6000 ether;\\n            } else if (lockingRatioPct < 60) {\\n                return 6600 ether + ((lockingRatioPct - 40) >> 1) * 600 ether;\\n            } else if (lockingRatioPct < 70) {\\n                return 13200 ether + ((lockingRatioPct - 60) >> 1) * 1200 ether;\\n            } else if (lockingRatioPct < 80) {\\n                return 20400 ether + ((lockingRatioPct - 70) >> 1) * 2400 ether;\\n            } else if (lockingRatioPct < 90) {\\n                return 34800 ether + ((lockingRatioPct - 80) >> 1) * 4800 ether;\\n            } else if (lockingRatioPct < 100) {\\n                /// 108000 * 2^x\\n                return 108000 ether << ((lockingRatioPct - 90) >> 1);\\n            } else {\\n                return 1728000 ether;\\n            }\\n        }\\n    }\\n\\n    function getVipClaimCostWithDiscount(uint256 cost, uint8 vipLevel) internal pure returns (uint256) {\\n        if (vipLevel < 3) {\\n            return cost;\\n        }\\n\\n        unchecked {\\n            uint256 discount = 4000 ether << (vipLevel - 3);\\n            if (cost < discount) {\\n                return 0;\\n            } else {\\n                return cost - discount;\\n            }\\n        }\\n    }\\n\\n    function getClaimExpiredCost(uint256 locked, uint256 totalManaged, uint8 vipLevel)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 realCost = getClaimCost(locked, totalManaged);\\n        return getVipClaimCostWithDiscount(realCost, vipLevel);\\n    }\\n\\n    function getClaimRandomCost(uint256 locked, uint256 totalManaged, uint8 vipLevel) internal pure returns (uint256) {\\n        uint256 realCost = getClaimCost(locked, totalManaged);\\n        return getVipClaimCostWithDiscount(realCost, vipLevel);\\n    }\\n\\n    function getClaimCost(uint256 locked, uint256 totalManaged) private pure returns (uint256) {\\n        if (totalManaged < Constants.LOCKING_RAMP_UP_THRESHOLD) {\\n            return 0;\\n        }\\n\\n        unchecked {\\n            uint256 lockingRatioPct = locked * 100 / totalManaged;\\n\\n            if (lockingRatioPct <= 60) {\\n                return 0;\\n            } else if (lockingRatioPct < 100) {\\n                uint256 cost = 1 ether;\\n                assembly {\\n                    switch shr(1, sub(lockingRatioPct, 60))\\n                    case 0 { cost := mul(cost, 400) }\\n                    case 1 { cost := mul(cost, 600) }\\n                    case 2 { cost := mul(cost, 800) }\\n                    case 3 { cost := mul(cost, 1200) }\\n                    case 4 { cost := mul(cost, 1600) }\\n                    case 5 { cost := mul(cost, 2400) }\\n                    case 6 { cost := mul(cost, 3200) }\\n                    case 7 { cost := mul(cost, 4800) }\\n                    case 8 { cost := mul(cost, 6400) }\\n                    case 9 { cost := mul(cost, 9600) }\\n                    case 10 { cost := mul(cost, 12800) }\\n                    case 11 { cost := mul(cost, 19200) }\\n                    case 12 { cost := mul(cost, 25600) }\\n                    case 13 { cost := mul(cost, 38400) }\\n                    case 14 { cost := mul(cost, 51200) }\\n                    case 15 { cost := mul(cost, 76800) }\\n                    case 16 { cost := mul(cost, 102400) }\\n                    case 17 { cost := mul(cost, 153600) }\\n                    case 18 { cost := mul(cost, 204800) }\\n                    case 19 { cost := mul(cost, 307200) }\\n                }\\n                return cost;\\n            } else {\\n                return 307200 ether;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nlibrary Errors {\\n    /// @notice Safe Box error\\n    error SafeBoxHasExpire();\\n    error SafeBoxNotExist();\\n    error SafeBoxHasNotExpire();\\n    error SafeBoxAlreadyExist();\\n    error NoMatchingSafeBoxKey();\\n    error SafeBoxKeyAlreadyExist();\\n\\n    /// @notice Auction error\\n    error AuctionHasNotCompleted();\\n    error AuctionHasExpire();\\n    error AuctionBidIsNotHighEnough();\\n    error AuctionBidTokenMismatch();\\n    error AuctionSelfBid();\\n    error AuctionInvalidBidAmount();\\n    error AuctionNotExist();\\n    error SafeBoxAuctionWindowHasPassed();\\n\\n    /// @notice Activity common error\\n    error NftHasActiveActivities();\\n    error ActivityHasNotCompleted();\\n    error ActivityHasExpired();\\n    error ActivityNotExist();\\n\\n    /// @notice User account error\\n    error InsufficientCredit();\\n    error InsufficientBalanceForVipLevel();\\n    error NoPrivilege();\\n\\n    /// @notice Parameter error\\n    error InvalidParam();\\n    error NftCollectionNotSupported();\\n    error NftCollectionAlreadySupported();\\n    error ClaimableNftInsufficient();\\n    error TokenNotSupported();\\n}\\n\"\r\n    },\r\n    \"src/interface/IFragmentToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\ninterface IFragmentToken {\\n    error CallerIsNotTrustedContract();\\n\\n    function mint(address account, uint256 amount) external;\\n\\n    function burn(address account, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/logic/Structs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"../interface/IFragmentToken.sol\\\";\\n\\nstruct SafeBox {\\n    /// Either matching a key OR Constants.SAFEBOX_KEY_NOTATION meaning temporarily\\n    /// held by a bidder in auction.\\n    uint64 keyId;\\n    /// The timestamp that the safe box expires.\\n    uint32 expiryTs;\\n    /// The owner of the safebox. It maybe outdated due to expiry\\n    address owner;\\n}\\n\\nstruct PrivateOffer {\\n    /// private offer end time\\n    uint96 endTime;\\n    /// which token used to accpet the offer\\n    address token;\\n    /// price of the offer\\n    uint96 price;\\n    address owner;\\n    /// who should receive the offer\\n    address buyer;\\n    uint64 activityId;\\n}\\n\\nstruct AuctionInfo {\\n    /// The end time for the auction.\\n    uint96 endTime;\\n    /// Bid token address.\\n    address bidTokenAddress;\\n    /// Minimum Bid.\\n    uint96 minimumBid;\\n    /// The person who trigger the auction at the beginning.\\n    address triggerAddress;\\n    uint96 lastBidAmount;\\n    address lastBidder;\\n    /// Whether the auction is triggered by the NFT owner itself\uff1f\\n    bool isSelfTriggered;\\n    uint64 activityId;\\n    uint32 feeRateBips;\\n}\\n\\nstruct TicketRecord {\\n    /// who buy the tickets\\n    address buyer;\\n    /// Start index of tickets\\n    /// [startIdx, endIdx)\\n    uint48 startIdx;\\n    /// End index of tickets\\n    uint48 endIdx;\\n}\\n\\nstruct RaffleInfo {\\n    /// raffle end time\\n    uint48 endTime;\\n    /// max tickets amount the raffle can sell\\n    uint48 maxTickets;\\n    /// which token used to buy the raffle tickets\\n    address token;\\n    /// price per ticket\\n    uint96 ticketPrice;\\n    /// total funds collected by selling tickets\\n    uint96 collectedFund;\\n    uint64 activityId;\\n    address owner;\\n    /// total sold tickets amount\\n    uint48 ticketSold;\\n    uint32 feeRateBips;\\n    /// whether the raffle is being settling\\n    bool isSettling;\\n    /// tickets sold records\\n    TicketRecord[] tickets;\\n}\\n\\nstruct CollectionState {\\n    /// The address of the Floor Token cooresponding to the NFTs.\\n    IFragmentToken floorToken;\\n    /// Records the active safe box in each time bucket.\\n    mapping(uint256 => uint256) countingBuckets;\\n    /// Stores all of the NFTs that has been fragmented but *without* locked up limit.\\n    uint256[] freeTokenIds;\\n    /// Huge map for all the `SafeBox`es in one collection.\\n    mapping(uint256 => SafeBox) safeBoxes;\\n    /// Stores all the ongoing auctions: nftId => `AuctionInfo`.\\n    mapping(uint256 => AuctionInfo) activeAuctions;\\n    /// Stores all the ongoing raffles: nftId => `RaffleInfo`.\\n    mapping(uint256 => RaffleInfo) activeRaffles;\\n    /// Stores all the ongoing private offers: nftId => `PrivateOffer`.\\n    mapping(uint256 => PrivateOffer) activePrivateOffers;\\n    /// The last bucket time the `countingBuckets` is updated.\\n    uint64 lastUpdatedBucket;\\n    /// Next Key Id. This should start from 1, we treat key id `SafeboxLib.SAFEBOX_KEY_NOTATION` as temporarily\\n    /// being used for activities(auction/raffle).\\n    uint64 nextKeyId;\\n    /// Active Safe Box Count.\\n    uint64 activeSafeBoxCnt;\\n    /// The number of infinite lock count.\\n    uint64 infiniteCnt;\\n    /// Next Activity Id. This should start from 1\\n    uint64 nextActivityId;\\n}\\n\\nstruct UserFloorAccount {\\n    /// @notice it should be maximum of the `totalLockingCredit` across all collections\\n    uint96 minMaintCredit;\\n    /// @notice used to iterate collection accounts\\n    /// packed with `minMaintCredit` to reduce storage slot access\\n    address firstCollection;\\n    /// @notice user vip level related info\\n    /// 0 - 239 bits: store SafeBoxKey Count per vip level, per level using 24 bits\\n    /// 240 - 247 bits: store minMaintVipLevel\\n    /// 248 - 255 bits: remaining\\n    uint256 vipInfo;\\n    /// @notice Locked Credit amount which cannot be withdrawn and will be released as time goes.\\n    uint256 lockedCredit;\\n    mapping(address => CollectionAccount) accounts;\\n    mapping(address => uint256) tokenAmounts;\\n}\\n\\nstruct SafeBoxKey {\\n    /// locked credit amount of this safebox\\n    uint96 lockingCredit;\\n    /// corresponding key id of the safebox\\n    uint64 keyId;\\n    /// which vip level the safebox locked\\n    uint8 vipLevel;\\n}\\n\\nstruct CollectionAccount {\\n    mapping(uint256 => SafeBoxKey) keys;\\n    /// total locking credit of all `keys` in this collection\\n    uint96 totalLockingCredit;\\n    /// track next collection as linked list\\n    address next;\\n}\\n\\n/// Internal Structure\\nstruct LockParam {\\n    address proxyCollection;\\n    address collection;\\n    uint256[] nftIds;\\n    uint256 expiryTs;\\n    uint256 vipLevel;\\n    uint256 maxCreditCost;\\n    address creditToken;\\n}\\n\"\r\n    },\r\n    \"src/logic/User.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"openzeppelin-contracts/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport \\\"../Constants.sol\\\";\\nimport \\\"../Errors.sol\\\";\\nimport {UserFloorAccount, CollectionAccount, SafeBoxKey} from \\\"./Structs.sol\\\";\\n\\nlibrary UserLib {\\n    using SafeCast for uint256;\\n\\n    /// @notice update the account maintain credit on behalfOf `onBehalfOf`\\n    event UpdateMaintainCredit(address indexed onBehalfOf, uint256 minMaintCredit);\\n\\n    address internal constant LIST_GUARD = address(1);\\n\\n    function ensureVipCredit(UserFloorAccount storage account, uint8 requireVipLevel, address creditToken)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 totalCredit = tokenBalance(account, creditToken);\\n        if (Constants.getVipBalanceRequirements(requireVipLevel) > totalCredit) {\\n            revert Errors.InsufficientBalanceForVipLevel();\\n        }\\n        return totalCredit;\\n    }\\n\\n    function getMinMaintVipLevel(UserFloorAccount storage account) internal view returns (uint8) {\\n        unchecked {\\n            return uint8(account.vipInfo >> 240);\\n        }\\n    }\\n\\n    function getMinLevelAndVipKeyCounts(uint256 vipInfo)\\n        internal\\n        pure\\n        returns (uint8 minLevel, uint256[] memory counts)\\n    {\\n        unchecked {\\n            counts = new uint256[](Constants.VIP_LEVEL_COUNT);\\n            minLevel = uint8(vipInfo >> 240);\\n            for (uint256 i; i < Constants.VIP_LEVEL_COUNT; ++i) {\\n                counts[i] = (vipInfo >> (i * 24)) & 0xFFFFFF;\\n            }\\n        }\\n    }\\n\\n    function storeMinLevelAndVipKeyCounts(\\n        UserFloorAccount storage account,\\n        uint8 minMaintVipLevel,\\n        uint256[] memory keyCounts\\n    ) internal {\\n        unchecked {\\n            uint256 _data = (uint256(minMaintVipLevel) << 240);\\n            for (uint256 i; i < Constants.VIP_LEVEL_COUNT; ++i) {\\n                _data |= ((keyCounts[i] & 0xFFFFFF) << (i * 24));\\n            }\\n            account.vipInfo = _data;\\n        }\\n    }\\n\\n    function getOrAddCollection(UserFloorAccount storage user, address collection)\\n        internal\\n        returns (CollectionAccount storage)\\n    {\\n        CollectionAccount storage entry = user.accounts[collection];\\n        if (entry.next == address(0)) {\\n            if (user.firstCollection == address(0)) {\\n                user.firstCollection = collection;\\n                entry.next = LIST_GUARD;\\n            } else {\\n                entry.next = user.firstCollection;\\n                user.firstCollection = collection;\\n            }\\n        }\\n        return entry;\\n    }\\n\\n    function removeCollection(UserFloorAccount storage userAccount, address collection, address prev) internal {\\n        CollectionAccount storage cur = userAccount.accounts[collection];\\n        if (cur.next == address(0)) revert Errors.InvalidParam();\\n\\n        if (collection == userAccount.firstCollection) {\\n            if (cur.next == LIST_GUARD) {\\n                userAccount.firstCollection = address(0);\\n            } else {\\n                userAccount.firstCollection = cur.next;\\n            }\\n        } else {\\n            CollectionAccount storage prevAccount = userAccount.accounts[prev];\\n            if (prevAccount.next != collection) revert Errors.InvalidParam();\\n            prevAccount.next = cur.next;\\n        }\\n\\n        delete userAccount.accounts[collection];\\n    }\\n\\n    function getByKey(UserFloorAccount storage userAccount, address collection)\\n        internal\\n        view\\n        returns (CollectionAccount storage)\\n    {\\n        return userAccount.accounts[collection];\\n    }\\n\\n    function addSafeboxKey(CollectionAccount storage account, uint256 nftId, SafeBoxKey memory key) internal {\\n        if (account.keys[nftId].keyId > 0) {\\n            revert Errors.SafeBoxKeyAlreadyExist();\\n        }\\n\\n        account.keys[nftId] = key;\\n    }\\n\\n    function removeSafeboxKey(CollectionAccount storage account, uint256 nftId) internal {\\n        delete account.keys[nftId];\\n    }\\n\\n    function getByKey(CollectionAccount storage account, uint256 nftId) internal view returns (SafeBoxKey storage) {\\n        return account.keys[nftId];\\n    }\\n\\n    function tokenBalance(UserFloorAccount storage account, address token) internal view returns (uint256) {\\n        return account.tokenAmounts[token];\\n    }\\n\\n    function lockCredit(UserFloorAccount storage account, uint256 amount) internal {\\n        unchecked {\\n            account.lockedCredit += amount;\\n        }\\n    }\\n\\n    function unlockCredit(UserFloorAccount storage account, uint256 amount) internal {\\n        unchecked {\\n            account.lockedCredit -= amount;\\n        }\\n    }\\n\\n    function depositToken(UserFloorAccount storage account, address token, uint256 amount) internal {\\n        account.tokenAmounts[token] += amount;\\n    }\\n\\n    function withdrawToken(UserFloorAccount storage account, address token, uint256 amount, bool isCreditToken)\\n        internal\\n    {\\n        uint256 balance = account.tokenAmounts[token];\\n        if (balance < amount) {\\n            revert Errors.InsufficientCredit();\\n        }\\n\\n        if (isCreditToken) {\\n            uint256 avaiableBuf;\\n            unchecked {\\n                avaiableBuf = balance - amount;\\n            }\\n            if (\\n                avaiableBuf < Constants.getVipBalanceRequirements(getMinMaintVipLevel(account))\\n                    || avaiableBuf < account.minMaintCredit || avaiableBuf < account.lockedCredit\\n            ) {\\n                revert Errors.InsufficientCredit();\\n            }\\n\\n            account.tokenAmounts[token] = avaiableBuf;\\n        } else {\\n            unchecked {\\n                account.tokenAmounts[token] = balance - amount;\\n            }\\n        }\\n    }\\n\\n    function transferToken(\\n        UserFloorAccount storage from,\\n        UserFloorAccount storage to,\\n        address token,\\n        uint256 amount,\\n        bool isCreditToken\\n    ) internal {\\n        withdrawToken(from, token, amount, isCreditToken);\\n        depositToken(to, token, amount);\\n    }\\n\\n    function updateVipKeyCount(UserFloorAccount storage account, uint8 vipLevel, int256 diff) internal {\\n        if (vipLevel > 0 && diff != 0) {\\n            (uint8 minMaintVipLevel, uint256[] memory keyCounts) = getMinLevelAndVipKeyCounts(account.vipInfo);\\n\\n            if (diff < 0) {\\n                keyCounts[vipLevel] -= uint256(-diff);\\n                if (vipLevel == minMaintVipLevel && keyCounts[vipLevel] == 0) {\\n                    uint8 newVipLevel = vipLevel;\\n                    do {\\n                        unchecked {\\n                            --newVipLevel;\\n                        }\\n                    } while (newVipLevel > 0 && keyCounts[newVipLevel] == 0);\\n\\n                    minMaintVipLevel = newVipLevel;\\n                }\\n            } else {\\n                keyCounts[vipLevel] += uint256(diff);\\n                if (vipLevel > minMaintVipLevel) {\\n                    minMaintVipLevel = vipLevel;\\n                }\\n            }\\n            storeMinLevelAndVipKeyCounts(account, minMaintVipLevel, keyCounts);\\n        }\\n    }\\n\\n    function recalculateMinMaintCredit(UserFloorAccount storage account, address onBehalfOf)\\n        public\\n        returns (uint256 maxLocking)\\n    {\\n        address prev = account.firstCollection;\\n        for (address collection = account.firstCollection; collection != LIST_GUARD && collection != address(0);) {\\n            (uint256 locking, address next) =\\n                (getByKey(account, collection).totalLockingCredit, getByKey(account, collection).next);\\n            if (locking == 0) {\\n                removeCollection(account, collection, prev);\\n                collection = next;\\n            } else {\\n                if (locking > maxLocking) {\\n                    maxLocking = locking;\\n                }\\n                prev = collection;\\n                collection = next;\\n            }\\n        }\\n\\n        account.minMaintCredit = uint96(maxLocking);\\n\\n        emit UpdateMaintainCredit(onBehalfOf, maxLocking);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"InvalidParam\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minMaintCredit\",\"type\":\"uint256\"}],\"name\":\"UpdateMaintainCredit\",\"type\":\"event\"}]", "ContractName": "UserLib", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}