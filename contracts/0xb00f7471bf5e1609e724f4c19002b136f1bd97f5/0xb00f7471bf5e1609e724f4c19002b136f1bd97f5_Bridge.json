{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Bridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {Owned} from \\\"lib/solmate/src/auth/Owned.sol\\\";\\nimport {IERC20} from \\\"./vendor/IERC20.sol\\\";\\nimport {IRouterClient} from \\\"lib/chainlink-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\\\";\\nimport {Client} from \\\"lib/chainlink-ccip/src/v0.8/ccip/libraries/Client.sol\\\";\\nimport {AggregatorV2V3Interface} from \\\"lib/chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\\\";\\nimport {LinkTokenInterface} from \\\"lib/chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\\\";\\nimport {Denominations} from \\\"lib/chainlink/contracts/src/v0.8/Denominations.sol\\\";\\nimport {console2} from \\\"forge-std/Test.sol\\\";\\n\\nstruct BridgeEnvironment {\\n    address router;\\n    address linkFeed;\\n    address linkToken;\\n}\\n\\ncontract Bridge is Owned {\\n    IRouterClient router;\\n    AggregatorV2V3Interface internal linkFeed;\\n    LinkTokenInterface linkToken;\\n    address feeRecipient = address(0);\\n    address purseAddress = address(0);\\n    uint256 public feePercentage = 25;  // 0.25%\\n\\n    constructor(address owner) Owned(owner) {}\\n\\n    function setEnv(BridgeEnvironment memory _env) public onlyOwner {\\n        router = IRouterClient(_env.router);\\n        linkToken = LinkTokenInterface(_env.linkToken);\\n        linkFeed = AggregatorV2V3Interface(_env.linkFeed);\\n\\n        // Approve LINK as the fee token\\n        enableToken(address(linkToken));\\n    }\\n\\n    // Given as /10000.\\n    function setFee(uint256 _fee, address _feeRecipient) public onlyOwner {\\n        feeRecipient = _feeRecipient;\\n        feePercentage = _fee;\\n    }\\n\\n    function setPurse(address _purse) public onlyOwner {\\n        purseAddress = _purse;\\n    }\\n\\n    // Approve CCIP to take the tokens the users are bridging from us.\\n    // To safe gas during bridging, this just needs to be called once for every token.\\n    // NB: We allow anyone to whitelist this for any token, it just needs to be done \\n    // once. If not pre-authorized, the first swap will do it.\\n    function enableToken(address _token) public {\\n        IERC20 token = IERC20(_token);\\n        if (token.allowance(address(this), address(router)) == 0) {\\n            IERC20(token).approve(address(router), 2 ** 256 - 1);\\n        }        \\n    }\\n\\n    // https://docs.chain.link/ccip/supported-networks\\n    function ccipCall(\\n        uint64 _destinationChainSelector,\\n        address _receiver,\\n        address _token,\\n        uint256 _amount\\n    ) public payable returns (bytes32) {\\n        // Calculate fees to send over (minus our fee)\\n        uint256 fee = (_amount * feePercentage) / 10000;\\n        uint256 amountToSend = _amount - fee;\\n\\n        // Build message\\n        (Client.EVM2AnyMessage memory evm2AnyMessage, uint256 feesInLink) = prepareCcipCall(\\n            _destinationChainSelector,\\n            _receiver,\\n            _token,\\n            amountToSend\\n        );\\n        linkToken.transferFrom(purseAddress, address(this), feesInLink);\\n        require(feesInLink <= linkToken.balanceOf(address(this)), \\\"out of fee funds\\\");\\n\\n        // Convert fees to ETH, require they have been sent\\n        (, int linkPrice, , uint timeStamp, ) = linkFeed.latestRoundData();\\n        uint256 feesInEth = (feesInLink * uint256(linkPrice)) / 10 ** 18;\\n        require(msg.value >= feesInEth, \\\"not enough ether sent for fee\\\");\\n\\n        // Transfer the token fee\\n        IERC20(_token).transferFrom(msg.sender, feeRecipient, fee);\\n\\n        // Transfer tokens to us then send on. Ensure router is authorized\\n        // to take any tokens from us.\\n        enableToken(_token);\\n        IERC20(_token).transferFrom(msg.sender, address(this), amountToSend);\\n        return router.ccipSend(_destinationChainSelector, evm2AnyMessage);\\n    }\\n\\n    /**\\n     * Can be used as a helper to build the message off-chain.\\n     */\\n    function prepareCcipCall(\\n        uint64 _destinationChainSelector,\\n        address _receiver,\\n        address _token,\\n        uint256 _amount\\n    ) internal view returns (Client.EVM2AnyMessage memory, uint256) {\\n        // Set the token amounts\\n        Client.EVMTokenAmount[] memory tokenAmounts = new Client.EVMTokenAmount[](1);\\n        Client.EVMTokenAmount memory tokenAmount = Client.EVMTokenAmount({\\n            token: _token,\\n            amount: _amount\\n        });\\n        tokenAmounts[0] = tokenAmount;\\n\\n        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message\\n        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({\\n            receiver: abi.encode(_receiver),\\n            data: \\\"\\\",\\n            tokenAmounts: tokenAmounts,\\n            extraArgs: Client._argsToBytes(Client.EVMExtraArgsV1({gasLimit: 0, strict: false})),\\n            feeToken: address(linkToken)\\n        });\\n\\n        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);\\n\\n        return (evm2AnyMessage, fees);\\n    }\\n\\n    /**\\n     * Return a fee estimate for the given trade, in ETH.\\n     */\\n    function estimateFee(\\n        uint64 _destinationChainSelector,\\n        address _receiver,\\n        address _token,\\n        uint256 _amount\\n    ) public view returns (uint256) {\\n        (Client.EVM2AnyMessage memory evm2AnyMessage, uint256 feesInLink) = prepareCcipCall(\\n            _destinationChainSelector,\\n            _receiver,\\n            _token,\\n            _amount\\n        );\\n        (, int linkPrice, , uint timeStamp, ) = linkFeed.latestRoundData();\\n        uint256 feesInEth = (feesInLink * uint256(linkPrice)) / 10 ** 18;\\n        return feesInEth;\\n    }\\n\\n    receive() external payable {}\\n\\n    function withdraw(address _beneficiary) public onlyOwner {\\n        uint256 amount = address(this).balance;\\n        (bool sent, ) = _beneficiary.call{value: amount}(\\\"\\\");\\n        require(sent, \\\"failed to send\\\");\\n    }\\n\\n    function withdrawToken(address _beneficiary, address _token, uint256 _amount) public onlyOwner {\\n        uint256 amount = _amount;\\n        IERC20(_token).transfer(_beneficiary, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/vendor/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity 0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\"\r\n    },\r\n    \"lib/chainlink-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\n\\ninterface IRouterClient {\\n  error UnsupportedDestinationChain(uint64 destChainSelector);\\n  error InsufficientFeeTokenAmount();\\n  error InvalidMsgValue();\\n\\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\\n  /// @param chainSelector The chain to check.\\n  /// @return supported is true if it is supported, false if not.\\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\\n\\n  /// @notice Gets a list of all supported tokens which can be sent or received\\n  /// to/from a given chain id.\\n  /// @param chainSelector The chainSelector.\\n  /// @return tokens The addresses of all tokens that are supported.\\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\\n\\n  /// @param destinationChainSelector The destination chainSelector\\n  /// @param message The cross-chain CCIP message including data and/or tokens\\n  /// @return fee returns guaranteed execution fee for the specified message\\n  /// delivery to destination chain\\n  /// @dev returns 0 fee on invalid message.\\n  function getFee(\\n    uint64 destinationChainSelector,\\n    Client.EVM2AnyMessage memory message\\n  ) external view returns (uint256 fee);\\n\\n  /// @notice Request a message to be sent to the destination chain\\n  /// @param destinationChainSelector The destination chain ID\\n  /// @param message The cross-chain CCIP message including data and/or tokens\\n  /// @return messageId The message ID\\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\\n  /// the overpayment with no refund.\\n  function ccipSend(\\n    uint64 destinationChainSelector,\\n    Client.EVM2AnyMessage calldata message\\n  ) external payable returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/chainlink-ccip/src/v0.8/ccip/libraries/Client.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// End consumer library.\\nlibrary Client {\\n  struct EVMTokenAmount {\\n    address token; // token address on the local chain.\\n    uint256 amount; // Amount of tokens.\\n  }\\n\\n  struct Any2EVMMessage {\\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\\n    uint64 sourceChainSelector; // Source chain selector.\\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\\n    bytes data; // payload sent in original message.\\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\\n  }\\n\\n  // If extraArgs is empty bytes, the default is 200k gas limit and strict = false.\\n  struct EVM2AnyMessage {\\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\\n    bytes data; // Data payload\\n    EVMTokenAmount[] tokenAmounts; // Token transfers\\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\\n  }\\n\\n  // extraArgs will evolve to support new features\\n  // bytes4(keccak256(\\\"CCIP EVMExtraArgsV1\\\"));\\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\\n  struct EVMExtraArgsV1 {\\n    uint256 gasLimit; // ATTENTION!!! MAX GAS LIMIT 4M FOR BETA TESTING\\n    bool strict; // See strict sequencing details below.\\n  }\\n\\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\\n\"\r\n    },\r\n    \"lib/chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface LinkTokenInterface {\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n  function approve(address spender, uint256 value) external returns (bool success);\\n\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  function decimals() external view returns (uint8 decimalPlaces);\\n\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\n\\n  function name() external view returns (string memory tokenName);\\n\\n  function symbol() external view returns (string memory tokenSymbol);\\n\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\n\\n  function transfer(address to, uint256 value) external returns (bool success);\\n\\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\\n\\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"lib/chainlink/contracts/src/v0.8/Denominations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Denominations {\\n  address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n  address public constant BTC = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\\n\\n  // Fiat currencies follow https://en.wikipedia.org/wiki/ISO_4217\\n  address public constant USD = address(840);\\n  address public constant GBP = address(826);\\n  address public constant EUR = address(978);\\n  address public constant JPY = address(392);\\n  address public constant KRW = address(410);\\n  address public constant CNY = address(156);\\n  address public constant AUD = address(36);\\n  address public constant CAD = address(124);\\n  address public constant CHF = address(756);\\n  address public constant ARS = address(32);\\n  address public constant PHP = address(608);\\n  address public constant NZD = address(554);\\n  address public constant SGD = address(702);\\n  address public constant NGN = address(566);\\n  address public constant ZAR = address(710);\\n  address public constant RUB = address(643);\\n  address public constant INR = address(356);\\n  address public constant BRL = address(986);\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/Test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\n// \ud83d\udcac ABOUT\\n// Forge Std's default Test.\\n\\n// \ud83e\udde9 MODULES\\nimport {console} from \\\"./console.sol\\\";\\nimport {console2} from \\\"./console2.sol\\\";\\nimport {safeconsole} from \\\"./safeconsole.sol\\\";\\nimport {StdAssertions} from \\\"./StdAssertions.sol\\\";\\nimport {StdChains} from \\\"./StdChains.sol\\\";\\nimport {StdCheats} from \\\"./StdCheats.sol\\\";\\nimport {stdError} from \\\"./StdError.sol\\\";\\nimport {StdInvariant} from \\\"./StdInvariant.sol\\\";\\nimport {stdJson} from \\\"./StdJson.sol\\\";\\nimport {stdMath} from \\\"./StdMath.sol\\\";\\nimport {StdStorage, stdStorage} from \\\"./StdStorage.sol\\\";\\nimport {StdStyle} from \\\"./StdStyle.sol\\\";\\nimport {StdUtils} from \\\"./StdUtils.sol\\\";\\nimport {Vm} from \\\"./Vm.sol\\\";\\n\\n// \ud83d\udce6 BOILERPLATE\\nimport {TestBase} from \\\"./Base.sol\\\";\\nimport {DSTest} from \\\"ds-test/test.sol\\\";\\n\\n// \u2b50\ufe0f TEST\\n// Note: DSTest and any contracts that inherit it must be inherited first, https://github.com/foundry-rs/forge-std/pull/241\\nabstract contract Test is DSTest, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils, TestBase {\\n// Note: IS_TEST() must return true.\\n// Note: Must have failure system, https://github.com/dapphub/ds-test/blob/cd98eff28324bfac652e63a239a60632a761790b/src/test.sol#L39-L76.\\n}\\n\"\r\n    },\r\n    \"lib/chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer() external view returns (int256);\\n\\n  function latestTimestamp() external view returns (uint256);\\n\\n  function latestRound() external view returns (uint256);\\n\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\n\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\\n\"\r\n    },\r\n    \"lib/chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(\\n    uint80 _roundId\\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n    function _sendLogPayload(bytes memory payload) private view {\\n        uint256 payloadLength = payload.length;\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let payloadStart := add(payload, 32)\\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n        }\\n    }\\n\\n    function log() internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n    }\\n\\n    function logUint(uint p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal view {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\"\r\n    },\r\n    \"lib/forge-std/src/console2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\n/// @dev The original console.sol uses `int` and `uint` for computing function selectors, but it should\\n/// use `int256` and `uint256`. This modified version fixes that. This version is recommended\\n/// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\\n/// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\\n/// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\\nlibrary console2 {\\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n    function _castLogPayloadViewToPure(\\n        function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) internal pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);\\n    }\\n\\n    function _sendLogPayloadView(bytes memory payload) private view {\\n        uint256 payloadLength = payload.length;\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let payloadStart := add(payload, 32)\\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n        }\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, int256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,int256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\"\r\n    },\r\n    \"lib/forge-std/src/safeconsole.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\n/// @author philogy <https://github.com/philogy>\\n/// @dev Code generated automatically by script.\\nlibrary safeconsole {\\n    uint256 constant CONSOLE_ADDR = 0x000000000000000000000000000000000000000000636F6e736F6c652e6c6f67;\\n\\n    // Credit to [0age](https://twitter.com/z0age/status/1654922202930888704) and [0xdapper](https://github.com/foundry-rs/forge-std/pull/374)\\n    // for the view-to-pure log trick.\\n    function _sendLogPayload(uint256 offset, uint256 size) private pure {\\n        function(uint256, uint256) internal view fnIn = _sendLogPayloadView;\\n        function(uint256, uint256) internal pure pureSendLogPayload;\\n        assembly {\\n            pureSendLogPayload := fnIn\\n        }\\n        pureSendLogPayload(offset, size);\\n    }\\n\\n    function _sendLogPayloadView(uint256 offset, uint256 size) private view {\\n        assembly {\\n            pop(staticcall(gas(), CONSOLE_ADDR, offset, size, 0x0, 0x0))\\n        }\\n    }\\n\\n    function _memcopy(uint256 fromOffset, uint256 toOffset, uint256 length) private pure {\\n        function(uint256, uint256, uint256) internal view fnIn = _memcopyView;\\n        function(uint256, uint256, uint256) internal pure pureMemcopy;\\n        assembly {\\n            pureMemcopy := fnIn\\n        }\\n        pureMemcopy(fromOffset, toOffset, length);\\n    }\\n\\n    function _memcopyView(uint256 fromOffset, uint256 toOffset, uint256 length) private view {\\n        assembly {\\n            pop(staticcall(gas(), 0x4, fromOffset, length, toOffset, length))\\n        }\\n    }\\n\\n    function logMemory(uint256 offset, uint256 length) internal pure {\\n        if (offset >= 0x60) {\\n            // Sufficient memory before slice to prepare call header.\\n            bytes32 m0;\\n            bytes32 m1;\\n            bytes32 m2;\\n            assembly {\\n                m0 := mload(sub(offset, 0x60))\\n                m1 := mload(sub(offset, 0x40))\\n                m2 := mload(sub(offset, 0x20))\\n                // Selector of `logBytes(bytes)`.\\n                mstore(sub(offset, 0x60), 0xe17bf956)\\n                mstore(sub(offset, 0x40), 0x20)\\n                mstore(sub(offset, 0x20), length)\\n            }\\n            _sendLogPayload(offset - 0x44, length + 0x44);\\n            assembly {\\n                mstore(sub(offset, 0x60), m0)\\n                mstore(sub(offset, 0x40), m1)\\n                mstore(sub(offset, 0x20), m2)\\n            }\\n        } else {\\n            // Insufficient space, so copy slice forward, add header and reverse.\\n            bytes32 m0;\\n            bytes32 m1;\\n            bytes32 m2;\\n            uint256 endOffset = offset + length;\\n            assembly {\\n                m0 := mload(add(endOffset, 0x00))\\n                m1 := mload(add(endOffset, 0x20))\\n                m2 := mload(add(endOffset, 0x40))\\n            }\\n            _memcopy(offset, offset + 0x60, length);\\n            assembly {\\n                // Selector of `logBytes(bytes)`.\\n                mstore(add(offset, 0x00), 0xe17bf956)\\n                mstore(add(offset, 0x20), 0x20)\\n                mstore(add(offset, 0x40), length)\\n            }\\n            _sendLogPayload(offset + 0x1c, length + 0x44);\\n            _memcopy(offset + 0x60, offset, length);\\n            assembly {\\n                mstore(add(endOffset, 0x00), m0)\\n                mstore(add(endOffset, 0x20), m1)\\n                mstore(add(endOffset, 0x40), m2)\\n            }\\n        }\\n    }\\n\\n    function log(address p0) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            // Selector of `log(address)`.\\n            mstore(0x00, 0x2c2ecbc2)\\n            mstore(0x20, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x24);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n        }\\n    }\\n\\n    function log(bool p0) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            // Selector of `log(bool)`.\\n            mstore(0x00, 0x32458eed)\\n            mstore(0x20, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x24);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n        }\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            // Selector of `log(uint256)`.\\n            mstore(0x00, 0xf82c50f1)\\n            mstore(0x20, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x24);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n        }\\n    }\\n\\n    function log(bytes32 p0) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(string)`.\\n            mstore(0x00, 0x41304fac)\\n            mstore(0x20, 0x20)\\n            writeString(0x40, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(address,address)`.\\n            mstore(0x00, 0xdaf0d4aa)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(address,bool)`.\\n            mstore(0x00, 0x75b605d3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(address,uint256)`.\\n            mstore(0x00, 0x8309e8a8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,string)`.\\n            mstore(0x00, 0x759f86bb)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x40)\\n            writeString(0x60, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(bool,address)`.\\n            mstore(0x00, 0x853c4849)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(bool,bool)`.\\n            mstore(0x00, 0x2a110e83)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(bool,uint256)`.\\n            mstore(0x00, 0x399174d3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,string)`.\\n            mstore(0x00, 0x8feac525)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x40)\\n            writeString(0x60, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(uint256,address)`.\\n            mstore(0x00, 0x69276c86)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(uint256,bool)`.\\n            mstore(0x00, 0x1c9d7eb3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            // Selector of `log(uint256,uint256)`.\\n            mstore(0x00, 0xf666715a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x44);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,string)`.\\n            mstore(0x00, 0x643fd0df)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x40)\\n            writeString(0x60, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(string,address)`.\\n            mstore(0x00, 0x319af333)\\n            mstore(0x20, 0x40)\\n            mstore(0x40, p1)\\n            writeString(0x60, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(string,bool)`.\\n            mstore(0x00, 0xc3b55635)\\n            mstore(0x20, 0x40)\\n            mstore(0x40, p1)\\n            writeString(0x60, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(string,uint256)`.\\n            mstore(0x00, 0xb60e72cc)\\n            mstore(0x20, 0x40)\\n            mstore(0x40, p1)\\n            writeString(0x60, p0)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,string)`.\\n            mstore(0x00, 0x4b5c4277)\\n            mstore(0x20, 0x40)\\n            mstore(0x40, 0x80)\\n            writeString(0x60, p0)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,address,address)`.\\n            mstore(0x00, 0x018c84c2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,address,bool)`.\\n            mstore(0x00, 0xf2a66286)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,address,uint256)`.\\n            mstore(0x00, 0x17fe6185)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,address,string)`.\\n            mstore(0x00, 0x007150be)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,bool,address)`.\\n            mstore(0x00, 0xf11699ed)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,bool,bool)`.\\n            mstore(0x00, 0xeb830c92)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,bool,uint256)`.\\n            mstore(0x00, 0x9c4f99fb)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,bool,string)`.\\n            mstore(0x00, 0x212255cc)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,uint256,address)`.\\n            mstore(0x00, 0x7bc0d848)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,uint256,bool)`.\\n            mstore(0x00, 0x678209a8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(address,uint256,uint256)`.\\n            mstore(0x00, 0xb69bcaf6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,uint256,string)`.\\n            mstore(0x00, 0xa1f2e8aa)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,string,address)`.\\n            mstore(0x00, 0xf08744e8)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,string,bool)`.\\n            mstore(0x00, 0xcf020fb1)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(address,string,uint256)`.\\n            mstore(0x00, 0x67dd6ff1)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(address,string,string)`.\\n            mstore(0x00, 0xfb772265)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p1)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,address,address)`.\\n            mstore(0x00, 0xd2763667)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,address,bool)`.\\n            mstore(0x00, 0x18c9c746)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,address,uint256)`.\\n            mstore(0x00, 0x5f7b9afb)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,address,string)`.\\n            mstore(0x00, 0xde9a9270)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,bool,address)`.\\n            mstore(0x00, 0x1078f68d)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,bool,bool)`.\\n            mstore(0x00, 0x50709698)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,bool,uint256)`.\\n            mstore(0x00, 0x12f21602)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,bool,string)`.\\n            mstore(0x00, 0x2555fa46)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,uint256,address)`.\\n            mstore(0x00, 0x088ef9d2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,uint256,bool)`.\\n            mstore(0x00, 0xe8defba9)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(bool,uint256,uint256)`.\\n            mstore(0x00, 0x37103367)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,uint256,string)`.\\n            mstore(0x00, 0xc3fc3970)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,string,address)`.\\n            mstore(0x00, 0x9591b953)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,string,bool)`.\\n            mstore(0x00, 0xdbb4c247)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(bool,string,uint256)`.\\n            mstore(0x00, 0x1093ee11)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(bool,string,string)`.\\n            mstore(0x00, 0xb076847f)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p1)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,address,address)`.\\n            mstore(0x00, 0xbcfd9be0)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,address,bool)`.\\n            mstore(0x00, 0x9b6ec042)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,address,uint256)`.\\n            mstore(0x00, 0x5a9b5ed5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,address,string)`.\\n            mstore(0x00, 0x63cb41f9)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,bool,address)`.\\n            mstore(0x00, 0x35085f7b)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,bool,bool)`.\\n            mstore(0x00, 0x20718650)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,bool,uint256)`.\\n            mstore(0x00, 0x20098014)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,bool,string)`.\\n            mstore(0x00, 0x85775021)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,uint256,address)`.\\n            mstore(0x00, 0x5c96b331)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,uint256,bool)`.\\n            mstore(0x00, 0x4766da72)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            // Selector of `log(uint256,uint256,uint256)`.\\n            mstore(0x00, 0xd1ed7a3c)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x64);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,uint256,string)`.\\n            mstore(0x00, 0x71d04af2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x60)\\n            writeString(0x80, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,string,address)`.\\n            mstore(0x00, 0x7afac959)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,string,bool)`.\\n            mstore(0x00, 0x4ceda75a)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(uint256,string,uint256)`.\\n            mstore(0x00, 0x37aa7d4c)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, p2)\\n            writeString(0x80, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(uint256,string,string)`.\\n            mstore(0x00, 0xb115611f)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x60)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p1)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,address,address)`.\\n            mstore(0x00, 0xfcec75e0)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,address,bool)`.\\n            mstore(0x00, 0xc91d5ed4)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,address,uint256)`.\\n            mstore(0x00, 0x0d26b925)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,address,string)`.\\n            mstore(0x00, 0xe0e9ad4f)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,bool,address)`.\\n            mstore(0x00, 0x932bbb38)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,bool,bool)`.\\n            mstore(0x00, 0x850b7ad6)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,bool,uint256)`.\\n            mstore(0x00, 0xc95958d6)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,bool,string)`.\\n            mstore(0x00, 0xe298f47d)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,uint256,address)`.\\n            mstore(0x00, 0x1c7ec448)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,uint256,bool)`.\\n            mstore(0x00, 0xca7733b1)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            // Selector of `log(string,uint256,uint256)`.\\n            mstore(0x00, 0xca47c4eb)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xa4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,uint256,string)`.\\n            mstore(0x00, 0x5970e089)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xa0)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, address p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,string,address)`.\\n            mstore(0x00, 0x95ed0195)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, 0xa0)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bool p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,string,bool)`.\\n            mstore(0x00, 0xb0e0f9b5)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, 0xa0)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, uint256 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            // Selector of `log(string,string,uint256)`.\\n            mstore(0x00, 0x5821efa1)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, 0xa0)\\n            mstore(0x60, p2)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xe4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bytes32 p2) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            // Selector of `log(string,string,string)`.\\n            mstore(0x00, 0x2ced7cef)\\n            mstore(0x20, 0x60)\\n            mstore(0x40, 0xa0)\\n            mstore(0x60, 0xe0)\\n            writeString(0x80, p0)\\n            writeString(0xc0, p1)\\n            writeString(0x100, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x124);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n        }\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,address,address)`.\\n            mstore(0x00, 0x665bf134)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,address,bool)`.\\n            mstore(0x00, 0x0e378994)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,address,uint256)`.\\n            mstore(0x00, 0x94250d77)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,address,string)`.\\n            mstore(0x00, 0xf808da20)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,bool,address)`.\\n            mstore(0x00, 0x9f1bc36e)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,bool,bool)`.\\n            mstore(0x00, 0x2cd4134a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,bool,uint256)`.\\n            mstore(0x00, 0x3971e78c)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,bool,string)`.\\n            mstore(0x00, 0xaa6540c8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,uint256,address)`.\\n            mstore(0x00, 0x8da6def5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,uint256,bool)`.\\n            mstore(0x00, 0x9b4254e2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,address,uint256,uint256)`.\\n            mstore(0x00, 0xbe553481)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,uint256,string)`.\\n            mstore(0x00, 0xfdb4f990)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,string,address)`.\\n            mstore(0x00, 0x8f736d16)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,string,bool)`.\\n            mstore(0x00, 0x6f1a594e)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,address,string,uint256)`.\\n            mstore(0x00, 0xef1cefe7)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, address p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,address,string,string)`.\\n            mstore(0x00, 0x21bdaf25)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,address,address)`.\\n            mstore(0x00, 0x660375dd)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,address,bool)`.\\n            mstore(0x00, 0xa6f50b0f)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,address,uint256)`.\\n            mstore(0x00, 0xa75c59de)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,address,string)`.\\n            mstore(0x00, 0x2dd778e6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,bool,address)`.\\n            mstore(0x00, 0xcf394485)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,bool,bool)`.\\n            mstore(0x00, 0xcac43479)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,bool,uint256)`.\\n            mstore(0x00, 0x8c4e5de6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,bool,string)`.\\n            mstore(0x00, 0xdfc4a2e8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,uint256,address)`.\\n            mstore(0x00, 0xccf790a1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,uint256,bool)`.\\n            mstore(0x00, 0xc4643e20)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,bool,uint256,uint256)`.\\n            mstore(0x00, 0x386ff5f4)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,uint256,string)`.\\n            mstore(0x00, 0x0aa6cfad)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,string,address)`.\\n            mstore(0x00, 0x19fd4956)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,string,bool)`.\\n            mstore(0x00, 0x50ad461d)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,bool,string,uint256)`.\\n            mstore(0x00, 0x80e6a20b)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,bool,string,string)`.\\n            mstore(0x00, 0x475c5c33)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,address,address)`.\\n            mstore(0x00, 0x478d1c62)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,address,bool)`.\\n            mstore(0x00, 0xa1bcc9b3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,address,uint256)`.\\n            mstore(0x00, 0x100f650e)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,address,string)`.\\n            mstore(0x00, 0x1da986ea)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,bool,address)`.\\n            mstore(0x00, 0xa31bfdcc)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,bool,bool)`.\\n            mstore(0x00, 0x3bf5e537)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,bool,uint256)`.\\n            mstore(0x00, 0x22f6b999)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,bool,string)`.\\n            mstore(0x00, 0xc5ad85f9)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,uint256,address)`.\\n            mstore(0x00, 0x20e3984d)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,uint256,bool)`.\\n            mstore(0x00, 0x66f1bc67)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(address,uint256,uint256,uint256)`.\\n            mstore(0x00, 0x34f0e636)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,uint256,string)`.\\n            mstore(0x00, 0x4a28c017)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,string,address)`.\\n            mstore(0x00, 0x5c430d47)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,string,bool)`.\\n            mstore(0x00, 0xcf18105c)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,uint256,string,uint256)`.\\n            mstore(0x00, 0xbf01f891)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,uint256,string,string)`.\\n            mstore(0x00, 0x88a8c406)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,address,address)`.\\n            mstore(0x00, 0x0d36fa20)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,address,bool)`.\\n            mstore(0x00, 0x0df12b76)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,address,uint256)`.\\n            mstore(0x00, 0x457fe3cf)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,address,string)`.\\n            mstore(0x00, 0xf7e36245)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,bool,address)`.\\n            mstore(0x00, 0x205871c2)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,bool,bool)`.\\n            mstore(0x00, 0x5f1d5c9f)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,bool,uint256)`.\\n            mstore(0x00, 0x515e38b6)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,bool,string)`.\\n            mstore(0x00, 0xbc0b61fe)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,uint256,address)`.\\n            mstore(0x00, 0x63183678)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,uint256,bool)`.\\n            mstore(0x00, 0x0ef7e050)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(address,string,uint256,uint256)`.\\n            mstore(0x00, 0x1dc8e1b8)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,uint256,string)`.\\n            mstore(0x00, 0x448830a8)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,string,address)`.\\n            mstore(0x00, 0xa04e2f87)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,string,bool)`.\\n            mstore(0x00, 0x35a5071f)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(address,string,string,uint256)`.\\n            mstore(0x00, 0x159f8927)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(address p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(address,string,string,string)`.\\n            mstore(0x00, 0x5d02c50b)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,address,address)`.\\n            mstore(0x00, 0x1d14d001)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,address,bool)`.\\n            mstore(0x00, 0x46600be0)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,address,uint256)`.\\n            mstore(0x00, 0x0c66d1be)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,address,string)`.\\n            mstore(0x00, 0xd812a167)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,bool,address)`.\\n            mstore(0x00, 0x1c41a336)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,bool,bool)`.\\n            mstore(0x00, 0x6a9c478b)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,bool,uint256)`.\\n            mstore(0x00, 0x07831502)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,bool,string)`.\\n            mstore(0x00, 0x4a66cb34)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,uint256,address)`.\\n            mstore(0x00, 0x136b05dd)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,uint256,bool)`.\\n            mstore(0x00, 0xd6019f1c)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,address,uint256,uint256)`.\\n            mstore(0x00, 0x7bf181a1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,uint256,string)`.\\n            mstore(0x00, 0x51f09ff8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,string,address)`.\\n            mstore(0x00, 0x6f7c603e)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,string,bool)`.\\n            mstore(0x00, 0xe2bfd60b)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,address,string,uint256)`.\\n            mstore(0x00, 0xc21f64c7)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, address p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,address,string,string)`.\\n            mstore(0x00, 0xa73c1db6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,address,address)`.\\n            mstore(0x00, 0xf4880ea4)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,address,bool)`.\\n            mstore(0x00, 0xc0a302d8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,address,uint256)`.\\n            mstore(0x00, 0x4c123d57)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,address,string)`.\\n            mstore(0x00, 0xa0a47963)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,bool,address)`.\\n            mstore(0x00, 0x8c329b1a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,bool,bool)`.\\n            mstore(0x00, 0x3b2a5ce0)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,bool,uint256)`.\\n            mstore(0x00, 0x6d7045c1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,bool,string)`.\\n            mstore(0x00, 0x2ae408d4)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,uint256,address)`.\\n            mstore(0x00, 0x54a7a9a0)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,uint256,bool)`.\\n            mstore(0x00, 0x619e4d0e)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,bool,uint256,uint256)`.\\n            mstore(0x00, 0x0bb00eab)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,uint256,string)`.\\n            mstore(0x00, 0x7dd4d0e0)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,string,address)`.\\n            mstore(0x00, 0xf9ad2b89)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,string,bool)`.\\n            mstore(0x00, 0xb857163a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,bool,string,uint256)`.\\n            mstore(0x00, 0xe3a9ca2f)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,bool,string,string)`.\\n            mstore(0x00, 0x6d1e8751)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,address,address)`.\\n            mstore(0x00, 0x26f560a8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,address,bool)`.\\n            mstore(0x00, 0xb4c314ff)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,address,uint256)`.\\n            mstore(0x00, 0x1537dc87)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,address,string)`.\\n            mstore(0x00, 0x1bb3b09a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,bool,address)`.\\n            mstore(0x00, 0x9acd3616)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,bool,bool)`.\\n            mstore(0x00, 0xceb5f4d7)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,bool,uint256)`.\\n            mstore(0x00, 0x7f9bbca2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,bool,string)`.\\n            mstore(0x00, 0x9143dbb1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,uint256,address)`.\\n            mstore(0x00, 0x00dd87b9)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,uint256,bool)`.\\n            mstore(0x00, 0xbe984353)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(bool,uint256,uint256,uint256)`.\\n            mstore(0x00, 0x374bb4b2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,uint256,string)`.\\n            mstore(0x00, 0x8e69fb5d)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,string,address)`.\\n            mstore(0x00, 0xfedd1fff)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,string,bool)`.\\n            mstore(0x00, 0xe5e70b2b)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,uint256,string,uint256)`.\\n            mstore(0x00, 0x6a1199e2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,uint256,string,string)`.\\n            mstore(0x00, 0xf5bc2249)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,address,address)`.\\n            mstore(0x00, 0x2b2b18dc)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,address,bool)`.\\n            mstore(0x00, 0x6dd434ca)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,address,uint256)`.\\n            mstore(0x00, 0xa5cada94)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,address,string)`.\\n            mstore(0x00, 0x12d6c788)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,bool,address)`.\\n            mstore(0x00, 0x538e06ab)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,bool,bool)`.\\n            mstore(0x00, 0xdc5e935b)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,bool,uint256)`.\\n            mstore(0x00, 0x1606a393)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,bool,string)`.\\n            mstore(0x00, 0x483d0416)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,uint256,address)`.\\n            mstore(0x00, 0x1596a1ce)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,uint256,bool)`.\\n            mstore(0x00, 0x6b0e5d53)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(bool,string,uint256,uint256)`.\\n            mstore(0x00, 0x28863fcb)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,uint256,string)`.\\n            mstore(0x00, 0x1ad96de6)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,string,address)`.\\n            mstore(0x00, 0x97d394d8)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,string,bool)`.\\n            mstore(0x00, 0x1e4b87e5)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(bool,string,string,uint256)`.\\n            mstore(0x00, 0x7be0c3eb)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bool p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(bool,string,string,string)`.\\n            mstore(0x00, 0x1762e32a)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,address,address)`.\\n            mstore(0x00, 0x2488b414)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,address,bool)`.\\n            mstore(0x00, 0x091ffaf5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,address,uint256)`.\\n            mstore(0x00, 0x736efbb6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,address,string)`.\\n            mstore(0x00, 0x031c6f73)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,bool,address)`.\\n            mstore(0x00, 0xef72c513)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,bool,bool)`.\\n            mstore(0x00, 0xe351140f)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,bool,uint256)`.\\n            mstore(0x00, 0x5abd992a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,bool,string)`.\\n            mstore(0x00, 0x90fb06aa)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,uint256,address)`.\\n            mstore(0x00, 0x15c127b5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,uint256,bool)`.\\n            mstore(0x00, 0x5f743a7c)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,address,uint256,uint256)`.\\n            mstore(0x00, 0x0c9cd9c1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,uint256,string)`.\\n            mstore(0x00, 0xddb06521)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,string,address)`.\\n            mstore(0x00, 0x9cba8fff)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,string,bool)`.\\n            mstore(0x00, 0xcc32ab07)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,address,string,uint256)`.\\n            mstore(0x00, 0x46826b5d)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, address p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,address,string,string)`.\\n            mstore(0x00, 0x3e128ca3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,address,address)`.\\n            mstore(0x00, 0xa1ef4cbb)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,address,bool)`.\\n            mstore(0x00, 0x454d54a5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,address,uint256)`.\\n            mstore(0x00, 0x078287f5)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,address,string)`.\\n            mstore(0x00, 0xade052c7)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,bool,address)`.\\n            mstore(0x00, 0x69640b59)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,bool,bool)`.\\n            mstore(0x00, 0xb6f577a1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,bool,uint256)`.\\n            mstore(0x00, 0x7464ce23)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,bool,string)`.\\n            mstore(0x00, 0xdddb9561)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,uint256,address)`.\\n            mstore(0x00, 0x88cb6041)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,uint256,bool)`.\\n            mstore(0x00, 0x91a02e2a)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,bool,uint256,uint256)`.\\n            mstore(0x00, 0xc6acc7a8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,uint256,string)`.\\n            mstore(0x00, 0xde03e774)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,string,address)`.\\n            mstore(0x00, 0xef529018)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,string,bool)`.\\n            mstore(0x00, 0xeb928d7f)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,bool,string,uint256)`.\\n            mstore(0x00, 0x2c1d0746)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,bool,string,string)`.\\n            mstore(0x00, 0x68c8b8bd)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,address,address)`.\\n            mstore(0x00, 0x56a5d1b1)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,address,bool)`.\\n            mstore(0x00, 0x15cac476)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,address,uint256)`.\\n            mstore(0x00, 0x88f6e4b2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,address,string)`.\\n            mstore(0x00, 0x6cde40b8)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,bool,address)`.\\n            mstore(0x00, 0x9a816a83)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,bool,bool)`.\\n            mstore(0x00, 0xab085ae6)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,bool,uint256)`.\\n            mstore(0x00, 0xeb7f6fd2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,bool,string)`.\\n            mstore(0x00, 0xa5b4fc99)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,uint256,address)`.\\n            mstore(0x00, 0xfa8185af)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,uint256,bool)`.\\n            mstore(0x00, 0xc598d185)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        assembly {\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            // Selector of `log(uint256,uint256,uint256,uint256)`.\\n            mstore(0x00, 0x193fb800)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x84);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,uint256,string)`.\\n            mstore(0x00, 0x59cfcbe3)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x80)\\n            writeString(0xa0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,string,address)`.\\n            mstore(0x00, 0x42d21db7)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,string,bool)`.\\n            mstore(0x00, 0x7af6ab25)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,uint256,string,uint256)`.\\n            mstore(0x00, 0x5da297eb)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,uint256,string,string)`.\\n            mstore(0x00, 0x27d8afd2)\\n            mstore(0x20, p0)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0x80)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p2)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,address,address)`.\\n            mstore(0x00, 0x6168ed61)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,address,bool)`.\\n            mstore(0x00, 0x90c30a56)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,address,uint256)`.\\n            mstore(0x00, 0xe8d3018d)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,address,string)`.\\n            mstore(0x00, 0x9c3adfa1)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,bool,address)`.\\n            mstore(0x00, 0xae2ec581)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,bool,bool)`.\\n            mstore(0x00, 0xba535d9c)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,bool,uint256)`.\\n            mstore(0x00, 0xcf009880)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,bool,string)`.\\n            mstore(0x00, 0xd2d423cd)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,uint256,address)`.\\n            mstore(0x00, 0x3b2279b4)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,uint256,bool)`.\\n            mstore(0x00, 0x691a8f74)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(uint256,string,uint256,uint256)`.\\n            mstore(0x00, 0x82c25b74)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,uint256,string)`.\\n            mstore(0x00, 0xb7b914ca)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,string,address)`.\\n            mstore(0x00, 0xd583c602)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,string,bool)`.\\n            mstore(0x00, 0xb3a6b6bd)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(uint256,string,string,uint256)`.\\n            mstore(0x00, 0xb028c9bd)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(uint256 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(uint256,string,string,string)`.\\n            mstore(0x00, 0x21ad0683)\\n            mstore(0x20, p0)\\n            mstore(0x40, 0x80)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p1)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,address,address)`.\\n            mstore(0x00, 0xed8f28f6)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,address,bool)`.\\n            mstore(0x00, 0xb59dbd60)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,address,uint256)`.\\n            mstore(0x00, 0x8ef3f399)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,address,string)`.\\n            mstore(0x00, 0x800a1c67)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,bool,address)`.\\n            mstore(0x00, 0x223603bd)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,bool,bool)`.\\n            mstore(0x00, 0x79884c2b)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,bool,uint256)`.\\n            mstore(0x00, 0x3e9f866a)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,bool,string)`.\\n            mstore(0x00, 0x0454c079)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,uint256,address)`.\\n            mstore(0x00, 0x63fb8bc5)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,uint256,bool)`.\\n            mstore(0x00, 0xfc4845f0)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,address,uint256,uint256)`.\\n            mstore(0x00, 0xf8f51b1e)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,uint256,string)`.\\n            mstore(0x00, 0x5a477632)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,string,address)`.\\n            mstore(0x00, 0xaabc9a31)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,string,bool)`.\\n            mstore(0x00, 0x5f15d28c)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,address,string,uint256)`.\\n            mstore(0x00, 0x91d1112e)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, address p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,address,string,string)`.\\n            mstore(0x00, 0x245986f2)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,address,address)`.\\n            mstore(0x00, 0x33e9dd1d)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,address,bool)`.\\n            mstore(0x00, 0x958c28c6)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,address,uint256)`.\\n            mstore(0x00, 0x5d08bb05)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,address,string)`.\\n            mstore(0x00, 0x2d8e33a4)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,bool,address)`.\\n            mstore(0x00, 0x7190a529)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,bool,bool)`.\\n            mstore(0x00, 0x895af8c5)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,bool,uint256)`.\\n            mstore(0x00, 0x8e3f78a9)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,bool,string)`.\\n            mstore(0x00, 0x9d22d5dd)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,uint256,address)`.\\n            mstore(0x00, 0x935e09bf)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,uint256,bool)`.\\n            mstore(0x00, 0x8af7cf8a)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,bool,uint256,uint256)`.\\n            mstore(0x00, 0x64b5bb67)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,uint256,string)`.\\n            mstore(0x00, 0x742d6ee7)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,string,address)`.\\n            mstore(0x00, 0xe0625b29)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,string,bool)`.\\n            mstore(0x00, 0x3f8a701d)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,bool,string,uint256)`.\\n            mstore(0x00, 0x24f91465)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,bool,string,string)`.\\n            mstore(0x00, 0xa826caeb)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,address,address)`.\\n            mstore(0x00, 0x5ea2b7ae)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,address,bool)`.\\n            mstore(0x00, 0x82112a42)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,address,uint256)`.\\n            mstore(0x00, 0x4f04fdc6)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,address,string)`.\\n            mstore(0x00, 0x9ffb2f93)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,bool,address)`.\\n            mstore(0x00, 0xe0e95b98)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,bool,bool)`.\\n            mstore(0x00, 0x354c36d6)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,bool,uint256)`.\\n            mstore(0x00, 0xe41b6f6f)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,bool,string)`.\\n            mstore(0x00, 0xabf73a98)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,uint256,address)`.\\n            mstore(0x00, 0xe21de278)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,uint256,bool)`.\\n            mstore(0x00, 0x7626db92)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            // Selector of `log(string,uint256,uint256,uint256)`.\\n            mstore(0x00, 0xa7a87853)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n        }\\n        _sendLogPayload(0x1c, 0xc4);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,uint256,string)`.\\n            mstore(0x00, 0x854b3496)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0xc0)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,string,address)`.\\n            mstore(0x00, 0x7c4632a4)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,string,bool)`.\\n            mstore(0x00, 0x7d24491d)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,uint256,string,uint256)`.\\n            mstore(0x00, 0xc67ea9d1)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,uint256,string,string)`.\\n            mstore(0x00, 0x5ab84e1f)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, p1)\\n            mstore(0x60, 0xc0)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p2)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, address p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,address,address)`.\\n            mstore(0x00, 0x439c7bef)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, address p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,address,bool)`.\\n            mstore(0x00, 0x5ccd4e37)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, address p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,address,uint256)`.\\n            mstore(0x00, 0x7cc3c607)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, address p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,address,string)`.\\n            mstore(0x00, 0xeb1bff80)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bool p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,bool,address)`.\\n            mstore(0x00, 0xc371c7db)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bool p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,bool,bool)`.\\n            mstore(0x00, 0x40785869)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bool p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,bool,uint256)`.\\n            mstore(0x00, 0xd6aefad2)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,bool,string)`.\\n            mstore(0x00, 0x5e84b0ea)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, uint256 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,uint256,address)`.\\n            mstore(0x00, 0x1023f7b2)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, uint256 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,uint256,bool)`.\\n            mstore(0x00, 0xc3a8a654)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            // Selector of `log(string,string,uint256,uint256)`.\\n            mstore(0x00, 0xf45d7d2c)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n        }\\n        _sendLogPayload(0x1c, 0x104);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,uint256,string)`.\\n            mstore(0x00, 0x5d1a971a)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, p2)\\n            mstore(0x80, 0x100)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, address p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,string,address)`.\\n            mstore(0x00, 0x6d572f44)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, 0x100)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,string,bool)`.\\n            mstore(0x00, 0x2c1754ed)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, 0x100)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            // Selector of `log(string,string,string,uint256)`.\\n            mstore(0x00, 0x8eafb02b)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, 0x100)\\n            mstore(0x80, p3)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p2)\\n        }\\n        _sendLogPayload(0x1c, 0x144);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n        }\\n    }\\n\\n    function log(bytes32 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {\\n        bytes32 m0;\\n        bytes32 m1;\\n        bytes32 m2;\\n        bytes32 m3;\\n        bytes32 m4;\\n        bytes32 m5;\\n        bytes32 m6;\\n        bytes32 m7;\\n        bytes32 m8;\\n        bytes32 m9;\\n        bytes32 m10;\\n        bytes32 m11;\\n        bytes32 m12;\\n        assembly {\\n            function writeString(pos, w) {\\n                let length := 0\\n                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }\\n                mstore(pos, length)\\n                let shift := sub(256, shl(3, length))\\n                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))\\n            }\\n            m0 := mload(0x00)\\n            m1 := mload(0x20)\\n            m2 := mload(0x40)\\n            m3 := mload(0x60)\\n            m4 := mload(0x80)\\n            m5 := mload(0xa0)\\n            m6 := mload(0xc0)\\n            m7 := mload(0xe0)\\n            m8 := mload(0x100)\\n            m9 := mload(0x120)\\n            m10 := mload(0x140)\\n            m11 := mload(0x160)\\n            m12 := mload(0x180)\\n            // Selector of `log(string,string,string,string)`.\\n            mstore(0x00, 0xde68f20a)\\n            mstore(0x20, 0x80)\\n            mstore(0x40, 0xc0)\\n            mstore(0x60, 0x100)\\n            mstore(0x80, 0x140)\\n            writeString(0xa0, p0)\\n            writeString(0xe0, p1)\\n            writeString(0x120, p2)\\n            writeString(0x160, p3)\\n        }\\n        _sendLogPayload(0x1c, 0x184);\\n        assembly {\\n            mstore(0x00, m0)\\n            mstore(0x20, m1)\\n            mstore(0x40, m2)\\n            mstore(0x60, m3)\\n            mstore(0x80, m4)\\n            mstore(0xa0, m5)\\n            mstore(0xc0, m6)\\n            mstore(0xe0, m7)\\n            mstore(0x100, m8)\\n            mstore(0x120, m9)\\n            mstore(0x140, m10)\\n            mstore(0x160, m11)\\n            mstore(0x180, m12)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/StdAssertions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\nimport {DSTest} from \\\"ds-test/test.sol\\\";\\nimport {stdMath} from \\\"./StdMath.sol\\\";\\n\\nabstract contract StdAssertions is DSTest {\\n    event log_array(uint256[] val);\\n    event log_array(int256[] val);\\n    event log_array(address[] val);\\n    event log_named_array(string key, uint256[] val);\\n    event log_named_array(string key, int256[] val);\\n    event log_named_array(string key, address[] val);\\n\\n    function fail(string memory err) internal virtual {\\n        emit log_named_string(\\\"Error\\\", err);\\n        fail();\\n    }\\n\\n    function assertFalse(bool data) internal virtual {\\n        assertTrue(!data);\\n    }\\n\\n    function assertFalse(bool data, string memory err) internal virtual {\\n        assertTrue(!data, err);\\n    }\\n\\n    function assertEq(bool a, bool b) internal virtual {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [bool]\\\");\\n            emit log_named_string(\\\"      Left\\\", a ? \\\"true\\\" : \\\"false\\\");\\n            emit log_named_string(\\\"     Right\\\", b ? \\\"true\\\" : \\\"false\\\");\\n            fail();\\n        }\\n    }\\n\\n    function assertEq(bool a, bool b, string memory err) internal virtual {\\n        if (a != b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n\\n    function assertEq(bytes memory a, bytes memory b) internal virtual {\\n        assertEq0(a, b);\\n    }\\n\\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal virtual {\\n        assertEq0(a, b, err);\\n    }\\n\\n    function assertEq(uint256[] memory a, uint256[] memory b) internal virtual {\\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\\n            emit log(\\\"Error: a == b not satisfied [uint[]]\\\");\\n            emit log_named_array(\\\"      Left\\\", a);\\n            emit log_named_array(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n\\n    function assertEq(int256[] memory a, int256[] memory b) internal virtual {\\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\\n            emit log(\\\"Error: a == b not satisfied [int[]]\\\");\\n            emit log_named_array(\\\"      Left\\\", a);\\n            emit log_named_array(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n\\n    function assertEq(address[] memory a, address[] memory b) internal virtual {\\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\\n            emit log(\\\"Error: a == b not satisfied [address[]]\\\");\\n            emit log_named_array(\\\"      Left\\\", a);\\n            emit log_named_array(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n\\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal virtual {\\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n\\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal virtual {\\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n\\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal virtual {\\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n\\n    // Legacy helper\\n    function assertEqUint(uint256 a, uint256 b) internal virtual {\\n        assertEq(uint256(a), uint256(b));\\n    }\\n\\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta) internal virtual {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"      Left\\\", a);\\n            emit log_named_uint(\\\"     Right\\\", b);\\n            emit log_named_uint(\\\" Max Delta\\\", maxDelta);\\n            emit log_named_uint(\\\"     Delta\\\", delta);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqAbs(uint256 a, uint256 b, uint256 maxDelta, string memory err) internal virtual {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqAbs(a, b, maxDelta);\\n        }\\n    }\\n\\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals) internal virtual {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [uint]\\\");\\n            emit log_named_decimal_uint(\\\"      Left\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"     Right\\\", b, decimals);\\n            emit log_named_decimal_uint(\\\" Max Delta\\\", maxDelta, decimals);\\n            emit log_named_decimal_uint(\\\"     Delta\\\", delta, decimals);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqAbsDecimal(uint256 a, uint256 b, uint256 maxDelta, uint256 decimals, string memory err)\\n        internal\\n        virtual\\n    {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\\n        }\\n    }\\n\\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta) internal virtual {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [int]\\\");\\n            emit log_named_int(\\\"       Left\\\", a);\\n            emit log_named_int(\\\"      Right\\\", b);\\n            emit log_named_uint(\\\" Max Delta\\\", maxDelta);\\n            emit log_named_uint(\\\"     Delta\\\", delta);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqAbs(int256 a, int256 b, uint256 maxDelta, string memory err) internal virtual {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqAbs(a, b, maxDelta);\\n        }\\n    }\\n\\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals) internal virtual {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [int]\\\");\\n            emit log_named_decimal_int(\\\"      Left\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"     Right\\\", b, decimals);\\n            emit log_named_decimal_uint(\\\" Max Delta\\\", maxDelta, decimals);\\n            emit log_named_decimal_uint(\\\"     Delta\\\", delta, decimals);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqAbsDecimal(int256 a, int256 b, uint256 maxDelta, uint256 decimals, string memory err)\\n        internal\\n        virtual\\n    {\\n        uint256 delta = stdMath.delta(a, b);\\n\\n        if (delta > maxDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqAbsDecimal(a, b, maxDelta, decimals);\\n        }\\n    }\\n\\n    function assertApproxEqRel(\\n        uint256 a,\\n        uint256 b,\\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\\n    ) internal virtual {\\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"        Left\\\", a);\\n            emit log_named_uint(\\\"       Right\\\", b);\\n            emit log_named_decimal_uint(\\\" Max % Delta\\\", maxPercentDelta * 100, 18);\\n            emit log_named_decimal_uint(\\\"     % Delta\\\", percentDelta * 100, 18);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqRel(\\n        uint256 a,\\n        uint256 b,\\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\\n        string memory err\\n    ) internal virtual {\\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqRel(a, b, maxPercentDelta);\\n        }\\n    }\\n\\n    function assertApproxEqRelDecimal(\\n        uint256 a,\\n        uint256 b,\\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\\n        uint256 decimals\\n    ) internal virtual {\\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [uint]\\\");\\n            emit log_named_decimal_uint(\\\"        Left\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"       Right\\\", b, decimals);\\n            emit log_named_decimal_uint(\\\" Max % Delta\\\", maxPercentDelta * 100, 18);\\n            emit log_named_decimal_uint(\\\"     % Delta\\\", percentDelta * 100, 18);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqRelDecimal(\\n        uint256 a,\\n        uint256 b,\\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\\n        uint256 decimals,\\n        string memory err\\n    ) internal virtual {\\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\\n        }\\n    }\\n\\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta) internal virtual {\\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [int]\\\");\\n            emit log_named_int(\\\"        Left\\\", a);\\n            emit log_named_int(\\\"       Right\\\", b);\\n            emit log_named_decimal_uint(\\\" Max % Delta\\\", maxPercentDelta * 100, 18);\\n            emit log_named_decimal_uint(\\\"     % Delta\\\", percentDelta * 100, 18);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqRel(int256 a, int256 b, uint256 maxPercentDelta, string memory err) internal virtual {\\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqRel(a, b, maxPercentDelta);\\n        }\\n    }\\n\\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals) internal virtual {\\n        if (b == 0) return assertEq(a, b); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log(\\\"Error: a ~= b not satisfied [int]\\\");\\n            emit log_named_decimal_int(\\\"        Left\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"       Right\\\", b, decimals);\\n            emit log_named_decimal_uint(\\\" Max % Delta\\\", maxPercentDelta * 100, 18);\\n            emit log_named_decimal_uint(\\\"     % Delta\\\", percentDelta * 100, 18);\\n            fail();\\n        }\\n    }\\n\\n    function assertApproxEqRelDecimal(int256 a, int256 b, uint256 maxPercentDelta, uint256 decimals, string memory err)\\n        internal\\n        virtual\\n    {\\n        if (b == 0) return assertEq(a, b, err); // If the left is 0, right must be too.\\n\\n        uint256 percentDelta = stdMath.percentDelta(a, b);\\n\\n        if (percentDelta > maxPercentDelta) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertApproxEqRelDecimal(a, b, maxPercentDelta, decimals);\\n        }\\n    }\\n\\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {\\n        assertEqCall(target, callDataA, target, callDataB, true);\\n    }\\n\\n    function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)\\n        internal\\n        virtual\\n    {\\n        assertEqCall(targetA, callDataA, targetB, callDataB, true);\\n    }\\n\\n    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)\\n        internal\\n        virtual\\n    {\\n        assertEqCall(target, callDataA, target, callDataB, strictRevertData);\\n    }\\n\\n    function assertEqCall(\\n        address targetA,\\n        bytes memory callDataA,\\n        address targetB,\\n        bytes memory callDataB,\\n        bool strictRevertData\\n    ) internal virtual {\\n        (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);\\n        (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);\\n\\n        if (successA && successB) {\\n            assertEq(returnDataA, returnDataB, \\\"Call return data does not match\\\");\\n        }\\n\\n        if (!successA && !successB && strictRevertData) {\\n            assertEq(returnDataA, returnDataB, \\\"Call revert data does not match\\\");\\n        }\\n\\n        if (!successA && successB) {\\n            emit log(\\\"Error: Calls were not equal\\\");\\n            emit log_named_bytes(\\\"  Left call revert data\\\", returnDataA);\\n            emit log_named_bytes(\\\" Right call return data\\\", returnDataB);\\n            fail();\\n        }\\n\\n        if (successA && !successB) {\\n            emit log(\\\"Error: Calls were not equal\\\");\\n            emit log_named_bytes(\\\"  Left call return data\\\", returnDataA);\\n            emit log_named_bytes(\\\" Right call revert data\\\", returnDataB);\\n            fail();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/StdChains.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\nimport {VmSafe} from \\\"./Vm.sol\\\";\\n\\n/**\\n * StdChains provides information about EVM compatible chains that can be used in scripts/tests.\\n * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are\\n * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of\\n * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the\\n * alias used in this contract, which can be found as the first argument to the\\n * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.\\n *\\n * There are two main ways to use this contract:\\n *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or\\n *      `setChain(string memory chainAlias, Chain memory chain)`\\n *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.\\n *\\n * The first time either of those are used, chains are initialized with the default set of RPC URLs.\\n * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in\\n * `defaultRpcUrls`.\\n *\\n * The `setChain` function is straightforward, and it simply saves off the given chain data.\\n *\\n * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say\\n * we want to retrieve the RPC URL for `mainnet`:\\n *   - If you have specified data with `setChain`, it will return that.\\n *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it\\n *     is valid (e.g. a URL is specified, or an environment variable is given and exists).\\n *   - If neither of the above conditions is met, the default data is returned.\\n *\\n * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.\\n */\\nabstract contract StdChains {\\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    bool private stdChainsInitialized;\\n\\n    struct ChainData {\\n        string name;\\n        uint256 chainId;\\n        string rpcUrl;\\n    }\\n\\n    struct Chain {\\n        // The chain name.\\n        string name;\\n        // The chain's Chain ID.\\n        uint256 chainId;\\n        // The chain's alias. (i.e. what gets specified in `foundry.toml`).\\n        string chainAlias;\\n        // A default RPC endpoint for this chain.\\n        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and\\n        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy\\n        // usage as you will be throttled and this is a disservice to others who need this endpoint.\\n        string rpcUrl;\\n    }\\n\\n    // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.\\n    mapping(string => Chain) private chains;\\n    // Maps from the chain's alias to it's default RPC URL.\\n    mapping(string => string) private defaultRpcUrls;\\n    // Maps from a chain ID to it's alias.\\n    mapping(uint256 => string) private idToAlias;\\n\\n    bool private fallbackToDefaultRpcUrls = true;\\n\\n    // The RPC URL will be fetched from config or defaultRpcUrls if possible.\\n    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {\\n        require(bytes(chainAlias).length != 0, \\\"StdChains getChain(string): Chain alias cannot be the empty string.\\\");\\n\\n        initializeStdChains();\\n        chain = chains[chainAlias];\\n        require(\\n            chain.chainId != 0,\\n            string(abi.encodePacked(\\\"StdChains getChain(string): Chain with alias \\\\\\\"\\\", chainAlias, \\\"\\\\\\\" not found.\\\"))\\n        );\\n\\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\\n    }\\n\\n    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {\\n        require(chainId != 0, \\\"StdChains getChain(uint256): Chain ID cannot be 0.\\\");\\n        initializeStdChains();\\n        string memory chainAlias = idToAlias[chainId];\\n\\n        chain = chains[chainAlias];\\n\\n        require(\\n            chain.chainId != 0,\\n            string(abi.encodePacked(\\\"StdChains getChain(uint256): Chain with ID \\\", vm.toString(chainId), \\\" not found.\\\"))\\n        );\\n\\n        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);\\n    }\\n\\n    // set chain info, with priority to argument's rpcUrl field.\\n    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {\\n        require(\\n            bytes(chainAlias).length != 0,\\n            \\\"StdChains setChain(string,ChainData): Chain alias cannot be the empty string.\\\"\\n        );\\n\\n        require(chain.chainId != 0, \\\"StdChains setChain(string,ChainData): Chain ID cannot be 0.\\\");\\n\\n        initializeStdChains();\\n        string memory foundAlias = idToAlias[chain.chainId];\\n\\n        require(\\n            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),\\n            string(\\n                abi.encodePacked(\\n                    \\\"StdChains setChain(string,ChainData): Chain ID \\\",\\n                    vm.toString(chain.chainId),\\n                    \\\" already used by \\\\\\\"\\\",\\n                    foundAlias,\\n                    \\\"\\\\\\\".\\\"\\n                )\\n            )\\n        );\\n\\n        uint256 oldChainId = chains[chainAlias].chainId;\\n        delete idToAlias[oldChainId];\\n\\n        chains[chainAlias] =\\n            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});\\n        idToAlias[chain.chainId] = chainAlias;\\n    }\\n\\n    // set chain info, with priority to argument's rpcUrl field.\\n    function setChain(string memory chainAlias, Chain memory chain) internal virtual {\\n        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));\\n    }\\n\\n    function _toUpper(string memory str) private pure returns (string memory) {\\n        bytes memory strb = bytes(str);\\n        bytes memory copy = new bytes(strb.length);\\n        for (uint256 i = 0; i < strb.length; i++) {\\n            bytes1 b = strb[i];\\n            if (b >= 0x61 && b <= 0x7A) {\\n                copy[i] = bytes1(uint8(b) - 32);\\n            } else {\\n                copy[i] = b;\\n            }\\n        }\\n        return string(copy);\\n    }\\n\\n    // lookup rpcUrl, in descending order of priority:\\n    // current -> config (foundry.toml) -> environment variable -> default\\n    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain) private returns (Chain memory) {\\n        if (bytes(chain.rpcUrl).length == 0) {\\n            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {\\n                chain.rpcUrl = configRpcUrl;\\n            } catch (bytes memory err) {\\n                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), \\\"_RPC_URL\\\"));\\n                if (fallbackToDefaultRpcUrls) {\\n                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);\\n                } else {\\n                    chain.rpcUrl = vm.envString(envName);\\n                }\\n                // distinguish 'not found' from 'cannot read'\\n                bytes memory notFoundError =\\n                    abi.encodeWithSignature(\\\"CheatCodeError\\\", string(abi.encodePacked(\\\"invalid rpc url \\\", chainAlias)));\\n                if (keccak256(notFoundError) != keccak256(err) || bytes(chain.rpcUrl).length == 0) {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, err), mload(err))\\n                    }\\n                }\\n            }\\n        }\\n        return chain;\\n    }\\n\\n    function setFallbackToDefaultRpcUrls(bool useDefault) internal {\\n        fallbackToDefaultRpcUrls = useDefault;\\n    }\\n\\n    function initializeStdChains() private {\\n        if (stdChainsInitialized) return;\\n\\n        stdChainsInitialized = true;\\n\\n        // If adding an RPC here, make sure to test the default RPC URL in `testRpcs`\\n        setChainWithDefaultRpcUrl(\\\"anvil\\\", ChainData(\\\"Anvil\\\", 31337, \\\"http://127.0.0.1:8545\\\"));\\n        setChainWithDefaultRpcUrl(\\n            \\\"mainnet\\\", ChainData(\\\"Mainnet\\\", 1, \\\"https://mainnet.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\n            \\\"goerli\\\", ChainData(\\\"Goerli\\\", 5, \\\"https://goerli.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\n            \\\"sepolia\\\", ChainData(\\\"Sepolia\\\", 11155111, \\\"https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\\"optimism\\\", ChainData(\\\"Optimism\\\", 10, \\\"https://mainnet.optimism.io\\\"));\\n        setChainWithDefaultRpcUrl(\\\"optimism_goerli\\\", ChainData(\\\"Optimism Goerli\\\", 420, \\\"https://goerli.optimism.io\\\"));\\n        setChainWithDefaultRpcUrl(\\\"arbitrum_one\\\", ChainData(\\\"Arbitrum One\\\", 42161, \\\"https://arb1.arbitrum.io/rpc\\\"));\\n        setChainWithDefaultRpcUrl(\\n            \\\"arbitrum_one_goerli\\\", ChainData(\\\"Arbitrum One Goerli\\\", 421613, \\\"https://goerli-rollup.arbitrum.io/rpc\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\\"arbitrum_nova\\\", ChainData(\\\"Arbitrum Nova\\\", 42170, \\\"https://nova.arbitrum.io/rpc\\\"));\\n        setChainWithDefaultRpcUrl(\\\"polygon\\\", ChainData(\\\"Polygon\\\", 137, \\\"https://polygon-rpc.com\\\"));\\n        setChainWithDefaultRpcUrl(\\n            \\\"polygon_mumbai\\\", ChainData(\\\"Polygon Mumbai\\\", 80001, \\\"https://rpc-mumbai.maticvigil.com\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\\"avalanche\\\", ChainData(\\\"Avalanche\\\", 43114, \\\"https://api.avax.network/ext/bc/C/rpc\\\"));\\n        setChainWithDefaultRpcUrl(\\n            \\\"avalanche_fuji\\\", ChainData(\\\"Avalanche Fuji\\\", 43113, \\\"https://api.avax-test.network/ext/bc/C/rpc\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\n            \\\"bnb_smart_chain\\\", ChainData(\\\"BNB Smart Chain\\\", 56, \\\"https://bsc-dataseed1.binance.org\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\n            \\\"bnb_smart_chain_testnet\\\",\\n            ChainData(\\\"BNB Smart Chain Testnet\\\", 97, \\\"https://rpc.ankr.com/bsc_testnet_chapel\\\")\\n        );\\n        setChainWithDefaultRpcUrl(\\\"gnosis_chain\\\", ChainData(\\\"Gnosis Chain\\\", 100, \\\"https://rpc.gnosischain.com\\\"));\\n    }\\n\\n    // set chain info, with priority to chainAlias' rpc url in foundry.toml\\n    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {\\n        string memory rpcUrl = chain.rpcUrl;\\n        defaultRpcUrls[chainAlias] = rpcUrl;\\n        chain.rpcUrl = \\\"\\\";\\n        setChain(chainAlias, chain);\\n        chain.rpcUrl = rpcUrl; // restore argument\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/StdCheats.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport {StdStorage, stdStorage} from \\\"./StdStorage.sol\\\";\\nimport {Vm} from \\\"./Vm.sol\\\";\\n\\nabstract contract StdCheatsSafe {\\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    uint256 private constant UINT256_MAX =\\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\\n\\n    bool private gasMeteringOff;\\n\\n    // Data structures to parse Transaction objects from the broadcast artifact\\n    // that conform to EIP1559. The Raw structs is what is parsed from the JSON\\n    // and then converted to the one that is used by the user for better UX.\\n\\n    struct RawTx1559 {\\n        string[] arguments;\\n        address contractAddress;\\n        string contractName;\\n        // json value name = function\\n        string functionSig;\\n        bytes32 hash;\\n        // json value name = tx\\n        RawTx1559Detail txDetail;\\n        // json value name = type\\n        string opcode;\\n    }\\n\\n    struct RawTx1559Detail {\\n        AccessList[] accessList;\\n        bytes data;\\n        address from;\\n        bytes gas;\\n        bytes nonce;\\n        address to;\\n        bytes txType;\\n        bytes value;\\n    }\\n\\n    struct Tx1559 {\\n        string[] arguments;\\n        address contractAddress;\\n        string contractName;\\n        string functionSig;\\n        bytes32 hash;\\n        Tx1559Detail txDetail;\\n        string opcode;\\n    }\\n\\n    struct Tx1559Detail {\\n        AccessList[] accessList;\\n        bytes data;\\n        address from;\\n        uint256 gas;\\n        uint256 nonce;\\n        address to;\\n        uint256 txType;\\n        uint256 value;\\n    }\\n\\n    // Data structures to parse Transaction objects from the broadcast artifact\\n    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON\\n    // and then converted to the one that is used by the user for better UX.\\n\\n    struct TxLegacy {\\n        string[] arguments;\\n        address contractAddress;\\n        string contractName;\\n        string functionSig;\\n        string hash;\\n        string opcode;\\n        TxDetailLegacy transaction;\\n    }\\n\\n    struct TxDetailLegacy {\\n        AccessList[] accessList;\\n        uint256 chainId;\\n        bytes data;\\n        address from;\\n        uint256 gas;\\n        uint256 gasPrice;\\n        bytes32 hash;\\n        uint256 nonce;\\n        bytes1 opcode;\\n        bytes32 r;\\n        bytes32 s;\\n        uint256 txType;\\n        address to;\\n        uint8 v;\\n        uint256 value;\\n    }\\n\\n    struct AccessList {\\n        address accessAddress;\\n        bytes32[] storageKeys;\\n    }\\n\\n    // Data structures to parse Receipt objects from the broadcast artifact.\\n    // The Raw structs is what is parsed from the JSON\\n    // and then converted to the one that is used by the user for better UX.\\n\\n    struct RawReceipt {\\n        bytes32 blockHash;\\n        bytes blockNumber;\\n        address contractAddress;\\n        bytes cumulativeGasUsed;\\n        bytes effectiveGasPrice;\\n        address from;\\n        bytes gasUsed;\\n        RawReceiptLog[] logs;\\n        bytes logsBloom;\\n        bytes status;\\n        address to;\\n        bytes32 transactionHash;\\n        bytes transactionIndex;\\n    }\\n\\n    struct Receipt {\\n        bytes32 blockHash;\\n        uint256 blockNumber;\\n        address contractAddress;\\n        uint256 cumulativeGasUsed;\\n        uint256 effectiveGasPrice;\\n        address from;\\n        uint256 gasUsed;\\n        ReceiptLog[] logs;\\n        bytes logsBloom;\\n        uint256 status;\\n        address to;\\n        bytes32 transactionHash;\\n        uint256 transactionIndex;\\n    }\\n\\n    // Data structures to parse the entire broadcast artifact, assuming the\\n    // transactions conform to EIP1559.\\n\\n    struct EIP1559ScriptArtifact {\\n        string[] libraries;\\n        string path;\\n        string[] pending;\\n        Receipt[] receipts;\\n        uint256 timestamp;\\n        Tx1559[] transactions;\\n        TxReturn[] txReturns;\\n    }\\n\\n    struct RawEIP1559ScriptArtifact {\\n        string[] libraries;\\n        string path;\\n        string[] pending;\\n        RawReceipt[] receipts;\\n        TxReturn[] txReturns;\\n        uint256 timestamp;\\n        RawTx1559[] transactions;\\n    }\\n\\n    struct RawReceiptLog {\\n        // json value = address\\n        address logAddress;\\n        bytes32 blockHash;\\n        bytes blockNumber;\\n        bytes data;\\n        bytes logIndex;\\n        bool removed;\\n        bytes32[] topics;\\n        bytes32 transactionHash;\\n        bytes transactionIndex;\\n        bytes transactionLogIndex;\\n    }\\n\\n    struct ReceiptLog {\\n        // json value = address\\n        address logAddress;\\n        bytes32 blockHash;\\n        uint256 blockNumber;\\n        bytes data;\\n        uint256 logIndex;\\n        bytes32[] topics;\\n        uint256 transactionIndex;\\n        uint256 transactionLogIndex;\\n        bool removed;\\n    }\\n\\n    struct TxReturn {\\n        string internalType;\\n        string value;\\n    }\\n\\n    struct Account {\\n        address addr;\\n        uint256 key;\\n    }\\n\\n    enum AddressType {\\n        Payable,\\n        NonPayable,\\n        ZeroAddress,\\n        Precompile,\\n        ForgeAddress\\n    }\\n\\n    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.\\n    function assumeNotBlacklisted(address token, address addr) internal view virtual {\\n        // Nothing to check if `token` is not a contract.\\n        uint256 tokenCodeSize;\\n        assembly {\\n            tokenCodeSize := extcodesize(token)\\n        }\\n        require(tokenCodeSize > 0, \\\"StdCheats assumeNotBlacklisted(address,address): Token address is not a contract.\\\");\\n\\n        bool success;\\n        bytes memory returnData;\\n\\n        // 4-byte selector for `isBlacklisted(address)`, used by USDC.\\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xfe575a87, addr));\\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\\n\\n        // 4-byte selector for `isBlackListed(address)`, used by USDT.\\n        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xe47d6060, addr));\\n        vm.assume(!success || abi.decode(returnData, (bool)) == false);\\n    }\\n\\n    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.\\n    // This is identical to `assumeNotBlacklisted(address,address)` but with a different name, for\\n    // backwards compatibility, since this name was used in the original PR which has already has\\n    // a release. This function can be removed in a future release once we want a breaking change.\\n    function assumeNoBlacklisted(address token, address addr) internal view virtual {\\n        assumeNotBlacklisted(token, addr);\\n    }\\n\\n    function assumeAddressIsNot(address addr, AddressType addressType) internal virtual {\\n        if (addressType == AddressType.Payable) {\\n            assumeNotPayable(addr);\\n        } else if (addressType == AddressType.NonPayable) {\\n            assumePayable(addr);\\n        } else if (addressType == AddressType.ZeroAddress) {\\n            assumeNotZeroAddress(addr);\\n        } else if (addressType == AddressType.Precompile) {\\n            assumeNotPrecompile(addr);\\n        } else if (addressType == AddressType.ForgeAddress) {\\n            assumeNotForgeAddress(addr);\\n        }\\n    }\\n\\n    function assumeAddressIsNot(address addr, AddressType addressType1, AddressType addressType2) internal virtual {\\n        assumeAddressIsNot(addr, addressType1);\\n        assumeAddressIsNot(addr, addressType2);\\n    }\\n\\n    function assumeAddressIsNot(\\n        address addr,\\n        AddressType addressType1,\\n        AddressType addressType2,\\n        AddressType addressType3\\n    ) internal virtual {\\n        assumeAddressIsNot(addr, addressType1);\\n        assumeAddressIsNot(addr, addressType2);\\n        assumeAddressIsNot(addr, addressType3);\\n    }\\n\\n    function assumeAddressIsNot(\\n        address addr,\\n        AddressType addressType1,\\n        AddressType addressType2,\\n        AddressType addressType3,\\n        AddressType addressType4\\n    ) internal virtual {\\n        assumeAddressIsNot(addr, addressType1);\\n        assumeAddressIsNot(addr, addressType2);\\n        assumeAddressIsNot(addr, addressType3);\\n        assumeAddressIsNot(addr, addressType4);\\n    }\\n\\n    // This function checks whether an address, `addr`, is payable. It works by sending 1 wei to\\n    // `addr` and checking the `success` return value.\\n    // NOTE: This function may result in state changes depending on the fallback/receive logic\\n    // implemented by `addr`, which should be taken into account when this function is used.\\n    function _isPayable(address addr) private returns (bool) {\\n        require(\\n            addr.balance < UINT256_MAX,\\n            \\\"StdCheats _isPayable(address): Balance equals max uint256, so it cannot receive any more funds\\\"\\n        );\\n        uint256 origBalanceTest = address(this).balance;\\n        uint256 origBalanceAddr = address(addr).balance;\\n\\n        vm.deal(address(this), 1);\\n        (bool success,) = payable(addr).call{value: 1}(\\\"\\\");\\n\\n        // reset balances\\n        vm.deal(address(this), origBalanceTest);\\n        vm.deal(addr, origBalanceAddr);\\n\\n        return success;\\n    }\\n\\n    // NOTE: This function may result in state changes depending on the fallback/receive logic\\n    // implemented by `addr`, which should be taken into account when this function is used. See the\\n    // `_isPayable` method for more information.\\n    function assumePayable(address addr) internal virtual {\\n        vm.assume(_isPayable(addr));\\n    }\\n\\n    function assumeNotPayable(address addr) internal virtual {\\n        vm.assume(!_isPayable(addr));\\n    }\\n\\n    function assumeNotZeroAddress(address addr) internal pure virtual {\\n        vm.assume(addr != address(0));\\n    }\\n\\n    function assumeNotPrecompile(address addr) internal pure virtual {\\n        assumeNotPrecompile(addr, _pureChainId());\\n    }\\n\\n    function assumeNotPrecompile(address addr, uint256 chainId) internal pure virtual {\\n        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific\\n        // address), but the same rationale for excluding them applies so we include those too.\\n\\n        // These should be present on all EVM-compatible chains.\\n        vm.assume(addr < address(0x1) || addr > address(0x9));\\n\\n        // forgefmt: disable-start\\n        if (chainId == 10 || chainId == 420) {\\n            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21\\n            vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));\\n        } else if (chainId == 42161 || chainId == 421613) {\\n            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains\\n            vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));\\n        } else if (chainId == 43114 || chainId == 43113) {\\n            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59\\n            vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));\\n            vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));\\n            vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));\\n        }\\n        // forgefmt: disable-end\\n    }\\n\\n    function assumeNotForgeAddress(address addr) internal pure virtual {\\n        // vm and console addresses\\n        vm.assume(addr != address(vm) || addr != 0x000000000000000000636F6e736F6c652e6c6f67);\\n    }\\n\\n    function readEIP1559ScriptArtifact(string memory path)\\n        internal\\n        view\\n        virtual\\n        returns (EIP1559ScriptArtifact memory)\\n    {\\n        string memory data = vm.readFile(path);\\n        bytes memory parsedData = vm.parseJson(data);\\n        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));\\n        EIP1559ScriptArtifact memory artifact;\\n        artifact.libraries = rawArtifact.libraries;\\n        artifact.path = rawArtifact.path;\\n        artifact.timestamp = rawArtifact.timestamp;\\n        artifact.pending = rawArtifact.pending;\\n        artifact.txReturns = rawArtifact.txReturns;\\n        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);\\n        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);\\n        return artifact;\\n    }\\n\\n    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {\\n        Tx1559[] memory txs = new Tx1559[](rawTxs.length);\\n        for (uint256 i; i < rawTxs.length; i++) {\\n            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);\\n        }\\n        return txs;\\n    }\\n\\n    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {\\n        Tx1559 memory transaction;\\n        transaction.arguments = rawTx.arguments;\\n        transaction.contractName = rawTx.contractName;\\n        transaction.functionSig = rawTx.functionSig;\\n        transaction.hash = rawTx.hash;\\n        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);\\n        transaction.opcode = rawTx.opcode;\\n        return transaction;\\n    }\\n\\n    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)\\n        internal\\n        pure\\n        virtual\\n        returns (Tx1559Detail memory)\\n    {\\n        Tx1559Detail memory txDetail;\\n        txDetail.data = rawDetail.data;\\n        txDetail.from = rawDetail.from;\\n        txDetail.to = rawDetail.to;\\n        txDetail.nonce = _bytesToUint(rawDetail.nonce);\\n        txDetail.txType = _bytesToUint(rawDetail.txType);\\n        txDetail.value = _bytesToUint(rawDetail.value);\\n        txDetail.gas = _bytesToUint(rawDetail.gas);\\n        txDetail.accessList = rawDetail.accessList;\\n        return txDetail;\\n    }\\n\\n    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {\\n        string memory deployData = vm.readFile(path);\\n        bytes memory parsedDeployData = vm.parseJson(deployData, \\\".transactions\\\");\\n        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));\\n        return rawToConvertedEIPTx1559s(rawTxs);\\n    }\\n\\n    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {\\n        string memory deployData = vm.readFile(path);\\n        string memory key = string(abi.encodePacked(\\\".transactions[\\\", vm.toString(index), \\\"]\\\"));\\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\\n        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));\\n        return rawToConvertedEIPTx1559(rawTx);\\n    }\\n\\n    // Analogous to readTransactions, but for receipts.\\n    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {\\n        string memory deployData = vm.readFile(path);\\n        bytes memory parsedDeployData = vm.parseJson(deployData, \\\".receipts\\\");\\n        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));\\n        return rawToConvertedReceipts(rawReceipts);\\n    }\\n\\n    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {\\n        string memory deployData = vm.readFile(path);\\n        string memory key = string(abi.encodePacked(\\\".receipts[\\\", vm.toString(index), \\\"]\\\"));\\n        bytes memory parsedDeployData = vm.parseJson(deployData, key);\\n        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));\\n        return rawToConvertedReceipt(rawReceipt);\\n    }\\n\\n    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {\\n        Receipt[] memory receipts = new Receipt[](rawReceipts.length);\\n        for (uint256 i; i < rawReceipts.length; i++) {\\n            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);\\n        }\\n        return receipts;\\n    }\\n\\n    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {\\n        Receipt memory receipt;\\n        receipt.blockHash = rawReceipt.blockHash;\\n        receipt.to = rawReceipt.to;\\n        receipt.from = rawReceipt.from;\\n        receipt.contractAddress = rawReceipt.contractAddress;\\n        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);\\n        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);\\n        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);\\n        receipt.status = _bytesToUint(rawReceipt.status);\\n        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);\\n        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);\\n        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);\\n        receipt.logsBloom = rawReceipt.logsBloom;\\n        receipt.transactionHash = rawReceipt.transactionHash;\\n        return receipt;\\n    }\\n\\n    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)\\n        internal\\n        pure\\n        virtual\\n        returns (ReceiptLog[] memory)\\n    {\\n        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);\\n        for (uint256 i; i < rawLogs.length; i++) {\\n            logs[i].logAddress = rawLogs[i].logAddress;\\n            logs[i].blockHash = rawLogs[i].blockHash;\\n            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);\\n            logs[i].data = rawLogs[i].data;\\n            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);\\n            logs[i].topics = rawLogs[i].topics;\\n            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);\\n            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);\\n            logs[i].removed = rawLogs[i].removed;\\n        }\\n        return logs;\\n    }\\n\\n    // Deploy a contract by fetching the contract bytecode from\\n    // the artifacts directory\\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\\n    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {\\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\\n        }\\n\\n        require(addr != address(0), \\\"StdCheats deployCode(string,bytes): Deployment failed.\\\");\\n    }\\n\\n    function deployCode(string memory what) internal virtual returns (address addr) {\\n        bytes memory bytecode = vm.getCode(what);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\\n        }\\n\\n        require(addr != address(0), \\\"StdCheats deployCode(string): Deployment failed.\\\");\\n    }\\n\\n    /// @dev deploy contract with value on construction\\n    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {\\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\\n        }\\n\\n        require(addr != address(0), \\\"StdCheats deployCode(string,bytes,uint256): Deployment failed.\\\");\\n    }\\n\\n    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {\\n        bytes memory bytecode = vm.getCode(what);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create(val, add(bytecode, 0x20), mload(bytecode))\\n        }\\n\\n        require(addr != address(0), \\\"StdCheats deployCode(string,uint256): Deployment failed.\\\");\\n    }\\n\\n    // creates a labeled address and the corresponding private key\\n    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {\\n        privateKey = uint256(keccak256(abi.encodePacked(name)));\\n        addr = vm.addr(privateKey);\\n        vm.label(addr, name);\\n    }\\n\\n    // creates a labeled address\\n    function makeAddr(string memory name) internal virtual returns (address addr) {\\n        (addr,) = makeAddrAndKey(name);\\n    }\\n\\n    // Destroys an account immediately, sending the balance to beneficiary.\\n    // Destroying means: balance will be zero, code will be empty, and nonce will be 0\\n    // This is similar to selfdestruct but not identical: selfdestruct destroys code and nonce\\n    // only after tx ends, this will run immediately.\\n    function destroyAccount(address who, address beneficiary) internal virtual {\\n        uint256 currBalance = who.balance;\\n        vm.etch(who, abi.encode());\\n        vm.deal(who, 0);\\n        vm.resetNonce(who);\\n\\n        uint256 beneficiaryBalance = beneficiary.balance;\\n        vm.deal(beneficiary, currBalance + beneficiaryBalance);\\n    }\\n\\n    // creates a struct containing both a labeled address and the corresponding private key\\n    function makeAccount(string memory name) internal virtual returns (Account memory account) {\\n        (account.addr, account.key) = makeAddrAndKey(name);\\n    }\\n\\n    function deriveRememberKey(string memory mnemonic, uint32 index)\\n        internal\\n        virtual\\n        returns (address who, uint256 privateKey)\\n    {\\n        privateKey = vm.deriveKey(mnemonic, index);\\n        who = vm.rememberKey(privateKey);\\n    }\\n\\n    function _bytesToUint(bytes memory b) private pure returns (uint256) {\\n        require(b.length <= 32, \\\"StdCheats _bytesToUint(bytes): Bytes length exceeds 32.\\\");\\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\\n    }\\n\\n    function isFork() internal view virtual returns (bool status) {\\n        try vm.activeFork() {\\n            status = true;\\n        } catch (bytes memory) {}\\n    }\\n\\n    modifier skipWhenForking() {\\n        if (!isFork()) {\\n            _;\\n        }\\n    }\\n\\n    modifier skipWhenNotForking() {\\n        if (isFork()) {\\n            _;\\n        }\\n    }\\n\\n    modifier noGasMetering() {\\n        vm.pauseGasMetering();\\n        // To prevent turning gas monitoring back on with nested functions that use this modifier,\\n        // we check if gasMetering started in the off position. If it did, we don't want to turn\\n        // it back on until we exit the top level function that used the modifier\\n        //\\n        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.\\n        // funcA will have `gasStartedOff` as false, funcB will have it as true,\\n        // so we only turn metering back on at the end of the funcA\\n        bool gasStartedOff = gasMeteringOff;\\n        gasMeteringOff = true;\\n\\n        _;\\n\\n        // if gas metering was on when this modifier was called, turn it back on at the end\\n        if (!gasStartedOff) {\\n            gasMeteringOff = false;\\n            vm.resumeGasMetering();\\n        }\\n    }\\n\\n    // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no\\n    // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We\\n    // can't simply access the chain ID in a normal view or pure function because the solc View Pure\\n    // Checker changed `chainid` from pure to view in 0.8.0.\\n    function _viewChainId() private view returns (uint256 chainId) {\\n        // Assembly required since `block.chainid` was introduced in 0.8.0.\\n        assembly {\\n            chainId := chainid()\\n        }\\n\\n        address(this); // Silence warnings in older Solc versions.\\n    }\\n\\n    function _pureChainId() private pure returns (uint256 chainId) {\\n        function() internal view returns (uint256) fnIn = _viewChainId;\\n        function() internal pure returns (uint256) pureChainId;\\n        assembly {\\n            pureChainId := fnIn\\n        }\\n        chainId = pureChainId();\\n    }\\n}\\n\\n// Wrappers around cheatcodes to avoid footguns\\nabstract contract StdCheats is StdCheatsSafe {\\n    using stdStorage for StdStorage;\\n\\n    StdStorage private stdstore;\\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    // Skip forward or rewind time by the specified number of seconds\\n    function skip(uint256 time) internal virtual {\\n        vm.warp(block.timestamp + time);\\n    }\\n\\n    function rewind(uint256 time) internal virtual {\\n        vm.warp(block.timestamp - time);\\n    }\\n\\n    // Setup a prank from an address that has some ether\\n    function hoax(address msgSender) internal virtual {\\n        vm.deal(msgSender, 1 << 128);\\n        vm.prank(msgSender);\\n    }\\n\\n    function hoax(address msgSender, uint256 give) internal virtual {\\n        vm.deal(msgSender, give);\\n        vm.prank(msgSender);\\n    }\\n\\n    function hoax(address msgSender, address origin) internal virtual {\\n        vm.deal(msgSender, 1 << 128);\\n        vm.prank(msgSender, origin);\\n    }\\n\\n    function hoax(address msgSender, address origin, uint256 give) internal virtual {\\n        vm.deal(msgSender, give);\\n        vm.prank(msgSender, origin);\\n    }\\n\\n    // Start perpetual prank from an address that has some ether\\n    function startHoax(address msgSender) internal virtual {\\n        vm.deal(msgSender, 1 << 128);\\n        vm.startPrank(msgSender);\\n    }\\n\\n    function startHoax(address msgSender, uint256 give) internal virtual {\\n        vm.deal(msgSender, give);\\n        vm.startPrank(msgSender);\\n    }\\n\\n    // Start perpetual prank from an address that has some ether\\n    // tx.origin is set to the origin parameter\\n    function startHoax(address msgSender, address origin) internal virtual {\\n        vm.deal(msgSender, 1 << 128);\\n        vm.startPrank(msgSender, origin);\\n    }\\n\\n    function startHoax(address msgSender, address origin, uint256 give) internal virtual {\\n        vm.deal(msgSender, give);\\n        vm.startPrank(msgSender, origin);\\n    }\\n\\n    function changePrank(address msgSender) internal virtual {\\n        vm.stopPrank();\\n        vm.startPrank(msgSender);\\n    }\\n\\n    function changePrank(address msgSender, address txOrigin) internal virtual {\\n        vm.stopPrank();\\n        vm.startPrank(msgSender, txOrigin);\\n    }\\n\\n    // The same as Vm's `deal`\\n    // Use the alternative signature for ERC20 tokens\\n    function deal(address to, uint256 give) internal virtual {\\n        vm.deal(to, give);\\n    }\\n\\n    // Set the balance of an account for any ERC20 token\\n    // Use the alternative signature to update `totalSupply`\\n    function deal(address token, address to, uint256 give) internal virtual {\\n        deal(token, to, give, false);\\n    }\\n\\n    // Set the balance of an account for any ERC1155 token\\n    // Use the alternative signature to update `totalSupply`\\n    function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {\\n        dealERC1155(token, to, id, give, false);\\n    }\\n\\n    function deal(address token, address to, uint256 give, bool adjust) internal virtual {\\n        // get current balance\\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\\n        uint256 prevBal = abi.decode(balData, (uint256));\\n\\n        // update balance\\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);\\n\\n        // update total supply\\n        if (adjust) {\\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0x18160ddd));\\n            uint256 totSup = abi.decode(totSupData, (uint256));\\n            if (give < prevBal) {\\n                totSup -= (prevBal - give);\\n            } else {\\n                totSup += (give - prevBal);\\n            }\\n            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);\\n        }\\n    }\\n\\n    function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {\\n        // get current balance\\n        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x00fdd58e, to, id));\\n        uint256 prevBal = abi.decode(balData, (uint256));\\n\\n        // update balance\\n        stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);\\n\\n        // update total supply\\n        if (adjust) {\\n            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0xbd85b039, id));\\n            require(\\n                totSupData.length != 0,\\n                \\\"StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply.\\\"\\n            );\\n            uint256 totSup = abi.decode(totSupData, (uint256));\\n            if (give < prevBal) {\\n                totSup -= (prevBal - give);\\n            } else {\\n                totSup += (give - prevBal);\\n            }\\n            stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);\\n        }\\n    }\\n\\n    function dealERC721(address token, address to, uint256 id) internal virtual {\\n        // check if token id is already minted and the actual owner.\\n        (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));\\n        require(successMinted, \\\"StdCheats deal(address,address,uint,bool): id not minted.\\\");\\n\\n        // get owner current balance\\n        (, bytes memory fromBalData) =\\n            token.staticcall(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));\\n        uint256 fromPrevBal = abi.decode(fromBalData, (uint256));\\n\\n        // get new user current balance\\n        (, bytes memory toBalData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));\\n        uint256 toPrevBal = abi.decode(toBalData, (uint256));\\n\\n        // update balances\\n        stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);\\n        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);\\n\\n        // update owner\\n        stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);\\n    }\\n\\n    function deployCodeTo(string memory what, address where) internal virtual {\\n        deployCodeTo(what, \\\"\\\", 0, where);\\n    }\\n\\n    function deployCodeTo(string memory what, bytes memory args, address where) internal virtual {\\n        deployCodeTo(what, args, 0, where);\\n    }\\n\\n    function deployCodeTo(string memory what, bytes memory args, uint256 value, address where) internal virtual {\\n        bytes memory creationCode = vm.getCode(what);\\n        vm.etch(where, abi.encodePacked(creationCode, args));\\n        (bool success, bytes memory runtimeBytecode) = where.call{value: value}(\\\"\\\");\\n        require(success, \\\"StdCheats deployCodeTo(string,bytes,uint256,address): Failed to create runtime bytecode.\\\");\\n        vm.etch(where, runtimeBytecode);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/StdError.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test\\npragma solidity >=0.6.2 <0.9.0;\\n\\nlibrary stdError {\\n    bytes public constant assertionError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x01);\\n    bytes public constant arithmeticError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x11);\\n    bytes public constant divisionError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x12);\\n    bytes public constant enumConversionError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x21);\\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x22);\\n    bytes public constant popError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x31);\\n    bytes public constant indexOOBError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x32);\\n    bytes public constant memOverflowError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x41);\\n    bytes public constant zeroVarError = abi.encodeWithSignature(\\\"Panic(uint256)\\\", 0x51);\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/StdInvariant.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nabstract contract StdInvariant {\\n    struct FuzzSelector {\\n        address addr;\\n        bytes4[] selectors;\\n    }\\n\\n    address[] private _excludedContracts;\\n    address[] private _excludedSenders;\\n    address[] private _targetedContracts;\\n    address[] private _targetedSenders;\\n\\n    string[] private _excludedArtifacts;\\n    string[] private _targetedArtifacts;\\n\\n    FuzzSelector[] private _targetedArtifactSelectors;\\n    FuzzSelector[] private _targetedSelectors;\\n\\n    // Functions for users:\\n    // These are intended to be called in tests.\\n\\n    function excludeContract(address newExcludedContract_) internal {\\n        _excludedContracts.push(newExcludedContract_);\\n    }\\n\\n    function excludeSender(address newExcludedSender_) internal {\\n        _excludedSenders.push(newExcludedSender_);\\n    }\\n\\n    function excludeArtifact(string memory newExcludedArtifact_) internal {\\n        _excludedArtifacts.push(newExcludedArtifact_);\\n    }\\n\\n    function targetArtifact(string memory newTargetedArtifact_) internal {\\n        _targetedArtifacts.push(newTargetedArtifact_);\\n    }\\n\\n    function targetArtifactSelector(FuzzSelector memory newTargetedArtifactSelector_) internal {\\n        _targetedArtifactSelectors.push(newTargetedArtifactSelector_);\\n    }\\n\\n    function targetContract(address newTargetedContract_) internal {\\n        _targetedContracts.push(newTargetedContract_);\\n    }\\n\\n    function targetSelector(FuzzSelector memory newTargetedSelector_) internal {\\n        _targetedSelectors.push(newTargetedSelector_);\\n    }\\n\\n    function targetSender(address newTargetedSender_) internal {\\n        _targetedSenders.push(newTargetedSender_);\\n    }\\n\\n    // Functions for forge:\\n    // These are called by forge to run invariant tests and don't need to be called in tests.\\n\\n    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {\\n        excludedArtifacts_ = _excludedArtifacts;\\n    }\\n\\n    function excludeContracts() public view returns (address[] memory excludedContracts_) {\\n        excludedContracts_ = _excludedContracts;\\n    }\\n\\n    function excludeSenders() public view returns (address[] memory excludedSenders_) {\\n        excludedSenders_ = _excludedSenders;\\n    }\\n\\n    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {\\n        targetedArtifacts_ = _targetedArtifacts;\\n    }\\n\\n    function targetArtifactSelectors() public view returns (FuzzSelector[] memory targetedArtifactSelectors_) {\\n        targetedArtifactSelectors_ = _targetedArtifactSelectors;\\n    }\\n\\n    function targetContracts() public view returns (address[] memory targetedContracts_) {\\n        targetedContracts_ = _targetedContracts;\\n    }\\n\\n    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {\\n        targetedSelectors_ = _targetedSelectors;\\n    }\\n\\n    function targetSenders() public view returns (address[] memory targetedSenders_) {\\n        targetedSenders_ = _targetedSenders;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/StdJson.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport {VmSafe} from \\\"./Vm.sol\\\";\\n\\n// Helpers for parsing and writing JSON files\\n// To parse:\\n// ```\\n// using stdJson for string;\\n// string memory json = vm.readFile(\\\"some_peth\\\");\\n// json.parseUint(\\\"<json_path>\\\");\\n// ```\\n// To write:\\n// ```\\n// using stdJson for string;\\n// string memory json = \\\"deploymentArtifact\\\";\\n// Contract contract = new Contract();\\n// json.serialize(\\\"contractAddress\\\", address(contract));\\n// json = json.serialize(\\\"deploymentTimes\\\", uint(1));\\n// // store the stringified JSON to the 'json' variable we have been using as a key\\n// // as we won't need it any longer\\n// string memory json2 = \\\"finalArtifact\\\";\\n// string memory final = json2.serialize(\\\"depArtifact\\\", json);\\n// final.write(\\\"<some_path>\\\");\\n// ```\\n\\nlibrary stdJson {\\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {\\n        return vm.parseJson(json, key);\\n    }\\n\\n    function readUint(string memory json, string memory key) internal returns (uint256) {\\n        return vm.parseJsonUint(json, key);\\n    }\\n\\n    function readUintArray(string memory json, string memory key) internal returns (uint256[] memory) {\\n        return vm.parseJsonUintArray(json, key);\\n    }\\n\\n    function readInt(string memory json, string memory key) internal returns (int256) {\\n        return vm.parseJsonInt(json, key);\\n    }\\n\\n    function readIntArray(string memory json, string memory key) internal returns (int256[] memory) {\\n        return vm.parseJsonIntArray(json, key);\\n    }\\n\\n    function readBytes32(string memory json, string memory key) internal returns (bytes32) {\\n        return vm.parseJsonBytes32(json, key);\\n    }\\n\\n    function readBytes32Array(string memory json, string memory key) internal returns (bytes32[] memory) {\\n        return vm.parseJsonBytes32Array(json, key);\\n    }\\n\\n    function readString(string memory json, string memory key) internal returns (string memory) {\\n        return vm.parseJsonString(json, key);\\n    }\\n\\n    function readStringArray(string memory json, string memory key) internal returns (string[] memory) {\\n        return vm.parseJsonStringArray(json, key);\\n    }\\n\\n    function readAddress(string memory json, string memory key) internal returns (address) {\\n        return vm.parseJsonAddress(json, key);\\n    }\\n\\n    function readAddressArray(string memory json, string memory key) internal returns (address[] memory) {\\n        return vm.parseJsonAddressArray(json, key);\\n    }\\n\\n    function readBool(string memory json, string memory key) internal returns (bool) {\\n        return vm.parseJsonBool(json, key);\\n    }\\n\\n    function readBoolArray(string memory json, string memory key) internal returns (bool[] memory) {\\n        return vm.parseJsonBoolArray(json, key);\\n    }\\n\\n    function readBytes(string memory json, string memory key) internal returns (bytes memory) {\\n        return vm.parseJsonBytes(json, key);\\n    }\\n\\n    function readBytesArray(string memory json, string memory key) internal returns (bytes[] memory) {\\n        return vm.parseJsonBytesArray(json, key);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {\\n        return vm.serializeBool(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bool[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeBool(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {\\n        return vm.serializeUint(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, uint256[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeUint(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {\\n        return vm.serializeInt(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, int256[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeInt(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {\\n        return vm.serializeAddress(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, address[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeAddress(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {\\n        return vm.serializeBytes32(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeBytes32(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {\\n        return vm.serializeBytes(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, bytes[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeBytes(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, string memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeString(jsonKey, key, value);\\n    }\\n\\n    function serialize(string memory jsonKey, string memory key, string[] memory value)\\n        internal\\n        returns (string memory)\\n    {\\n        return vm.serializeString(jsonKey, key, value);\\n    }\\n\\n    function write(string memory jsonKey, string memory path) internal {\\n        vm.writeJson(jsonKey, path);\\n    }\\n\\n    function write(string memory jsonKey, string memory path, string memory valueKey) internal {\\n        vm.writeJson(jsonKey, path, valueKey);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/StdMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\nlibrary stdMath {\\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\\n\\n    function abs(int256 a) internal pure returns (uint256) {\\n        // Required or it will fail when `a = type(int256).min`\\n        if (a == INT256_MIN) {\\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\\n        }\\n\\n        return uint256(a > 0 ? a : -a);\\n    }\\n\\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a - b : b - a;\\n    }\\n\\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\\n        // a and b are of the same sign\\n        // this works thanks to two's complement, the left-most bit is the sign bit\\n        if ((a ^ b) > -1) {\\n            return delta(abs(a), abs(b));\\n        }\\n\\n        // a and b are of opposite signs\\n        return abs(a) + abs(b);\\n    }\\n\\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 absDelta = delta(a, b);\\n\\n        return absDelta * 1e18 / b;\\n    }\\n\\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\\n        uint256 absDelta = delta(a, b);\\n        uint256 absB = abs(b);\\n\\n        return absDelta * 1e18 / absB;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/StdStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\nimport {Vm} from \\\"./Vm.sol\\\";\\n\\nstruct StdStorage {\\n    mapping(address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\\n    mapping(address => mapping(bytes4 => mapping(bytes32 => bool))) finds;\\n    bytes32[] _keys;\\n    bytes4 _sig;\\n    uint256 _depth;\\n    address _target;\\n    bytes32 _set;\\n}\\n\\nlibrary stdStorageSafe {\\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);\\n    event WARNING_UninitedSlot(address who, uint256 slot);\\n\\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\\n        return bytes4(keccak256(bytes(sigStr)));\\n    }\\n\\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\\n    // slot complexity:\\n    //  if flat, will be bytes32(uint256(uint));\\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\\n    function find(StdStorage storage self) internal returns (uint256) {\\n        address who = self._target;\\n        bytes4 fsig = self._sig;\\n        uint256 field_depth = self._depth;\\n        bytes32[] memory ins = self._keys;\\n\\n        // calldata to test against\\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\\n        }\\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\\n        vm.record();\\n        bytes32 fdat;\\n        {\\n            (, bytes memory rdat) = who.staticcall(cald);\\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\\n        }\\n\\n        (bytes32[] memory reads,) = vm.accesses(address(who));\\n        if (reads.length == 1) {\\n            bytes32 curr = vm.load(who, reads[0]);\\n            if (curr == bytes32(0)) {\\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\\n            }\\n            if (fdat != curr) {\\n                require(\\n                    false,\\n                    \\\"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\\\"\\n                );\\n            }\\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\\n        } else if (reads.length > 1) {\\n            for (uint256 i = 0; i < reads.length; i++) {\\n                bytes32 prev = vm.load(who, reads[i]);\\n                if (prev == bytes32(0)) {\\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\\n                }\\n                // store\\n                vm.store(who, reads[i], bytes32(hex\\\"1337\\\"));\\n                bool success;\\n                bytes memory rdat;\\n                {\\n                    (success, rdat) = who.staticcall(cald);\\n                    fdat = bytesToBytes32(rdat, 32 * field_depth);\\n                }\\n\\n                if (success && fdat == bytes32(hex\\\"1337\\\")) {\\n                    // we found which of the slots is the actual one\\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\\n                    vm.store(who, reads[i], prev);\\n                    break;\\n                }\\n                vm.store(who, reads[i], prev);\\n            }\\n        } else {\\n            revert(\\\"stdStorage find(StdStorage): No storage use detected for target.\\\");\\n        }\\n\\n        require(\\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))],\\n            \\\"stdStorage find(StdStorage): Slot(s) not found.\\\"\\n        );\\n\\n        delete self._target;\\n        delete self._sig;\\n        delete self._keys;\\n        delete self._depth;\\n\\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\\n    }\\n\\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\\n        self._target = _target;\\n        return self;\\n    }\\n\\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\\n        self._sig = _sig;\\n        return self;\\n    }\\n\\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\\n        self._sig = sigs(_sig);\\n        return self;\\n    }\\n\\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\\n        self._keys.push(bytes32(uint256(uint160(who))));\\n        return self;\\n    }\\n\\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\\n        self._keys.push(bytes32(amt));\\n        return self;\\n    }\\n\\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\\n        self._keys.push(key);\\n        return self;\\n    }\\n\\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\\n        self._depth = _depth;\\n        return self;\\n    }\\n\\n    function read(StdStorage storage self) private returns (bytes memory) {\\n        address t = self._target;\\n        uint256 s = find(self);\\n        return abi.encode(vm.load(t, bytes32(s)));\\n    }\\n\\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\\n        return abi.decode(read(self), (bytes32));\\n    }\\n\\n    function read_bool(StdStorage storage self) internal returns (bool) {\\n        int256 v = read_int(self);\\n        if (v == 0) return false;\\n        if (v == 1) return true;\\n        revert(\\\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\\\");\\n    }\\n\\n    function read_address(StdStorage storage self) internal returns (address) {\\n        return abi.decode(read(self), (address));\\n    }\\n\\n    function read_uint(StdStorage storage self) internal returns (uint256) {\\n        return abi.decode(read(self), (uint256));\\n    }\\n\\n    function read_int(StdStorage storage self) internal returns (int256) {\\n        return abi.decode(read(self), (int256));\\n    }\\n\\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\\n        bytes32 out;\\n\\n        uint256 max = b.length > 32 ? 32 : b.length;\\n        for (uint256 i = 0; i < max; i++) {\\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\\n        }\\n        return out;\\n    }\\n\\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\\n        bytes memory result = new bytes(b.length * 32);\\n        for (uint256 i = 0; i < b.length; i++) {\\n            bytes32 k = b[i];\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore(add(result, add(32, mul(32, i))), k)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\nlibrary stdStorage {\\n    Vm private constant vm = Vm(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    function sigs(string memory sigStr) internal pure returns (bytes4) {\\n        return stdStorageSafe.sigs(sigStr);\\n    }\\n\\n    function find(StdStorage storage self) internal returns (uint256) {\\n        return stdStorageSafe.find(self);\\n    }\\n\\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\\n        return stdStorageSafe.target(self, _target);\\n    }\\n\\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\\n        return stdStorageSafe.sig(self, _sig);\\n    }\\n\\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\\n        return stdStorageSafe.sig(self, _sig);\\n    }\\n\\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\\n        return stdStorageSafe.with_key(self, who);\\n    }\\n\\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\\n        return stdStorageSafe.with_key(self, amt);\\n    }\\n\\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\\n        return stdStorageSafe.with_key(self, key);\\n    }\\n\\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\\n        return stdStorageSafe.depth(self, _depth);\\n    }\\n\\n    function checked_write(StdStorage storage self, address who) internal {\\n        checked_write(self, bytes32(uint256(uint160(who))));\\n    }\\n\\n    function checked_write(StdStorage storage self, uint256 amt) internal {\\n        checked_write(self, bytes32(amt));\\n    }\\n\\n    function checked_write_int(StdStorage storage self, int256 val) internal {\\n        checked_write(self, bytes32(uint256(val)));\\n    }\\n\\n    function checked_write(StdStorage storage self, bool write) internal {\\n        bytes32 t;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            t := write\\n        }\\n        checked_write(self, t);\\n    }\\n\\n    function checked_write(StdStorage storage self, bytes32 set) internal {\\n        address who = self._target;\\n        bytes4 fsig = self._sig;\\n        uint256 field_depth = self._depth;\\n        bytes32[] memory ins = self._keys;\\n\\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\\n            find(self);\\n        }\\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\\n\\n        bytes32 fdat;\\n        {\\n            (, bytes memory rdat) = who.staticcall(cald);\\n            fdat = bytesToBytes32(rdat, 32 * field_depth);\\n        }\\n        bytes32 curr = vm.load(who, slot);\\n\\n        if (fdat != curr) {\\n            require(\\n                false,\\n                \\\"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\\\"\\n            );\\n        }\\n        vm.store(who, slot, set);\\n        delete self._target;\\n        delete self._sig;\\n        delete self._keys;\\n        delete self._depth;\\n    }\\n\\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\\n        return stdStorageSafe.read_bytes32(self);\\n    }\\n\\n    function read_bool(StdStorage storage self) internal returns (bool) {\\n        return stdStorageSafe.read_bool(self);\\n    }\\n\\n    function read_address(StdStorage storage self) internal returns (address) {\\n        return stdStorageSafe.read_address(self);\\n    }\\n\\n    function read_uint(StdStorage storage self) internal returns (uint256) {\\n        return stdStorageSafe.read_uint(self);\\n    }\\n\\n    function read_int(StdStorage storage self) internal returns (int256) {\\n        return stdStorageSafe.read_int(self);\\n    }\\n\\n    // Private function so needs to be copied over\\n    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {\\n        bytes32 out;\\n\\n        uint256 max = b.length > 32 ? 32 : b.length;\\n        for (uint256 i = 0; i < max; i++) {\\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\\n        }\\n        return out;\\n    }\\n\\n    // Private function so needs to be copied over\\n    function flatten(bytes32[] memory b) private pure returns (bytes memory) {\\n        bytes memory result = new bytes(b.length * 32);\\n        for (uint256 i = 0; i < b.length; i++) {\\n            bytes32 k = b[i];\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore(add(result, add(32, mul(32, i))), k)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/StdStyle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nimport {VmSafe} from \\\"./Vm.sol\\\";\\n\\nlibrary StdStyle {\\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n\\n    string constant RED = \\\"\\\\u001b[91m\\\";\\n    string constant GREEN = \\\"\\\\u001b[92m\\\";\\n    string constant YELLOW = \\\"\\\\u001b[93m\\\";\\n    string constant BLUE = \\\"\\\\u001b[94m\\\";\\n    string constant MAGENTA = \\\"\\\\u001b[95m\\\";\\n    string constant CYAN = \\\"\\\\u001b[96m\\\";\\n    string constant BOLD = \\\"\\\\u001b[1m\\\";\\n    string constant DIM = \\\"\\\\u001b[2m\\\";\\n    string constant ITALIC = \\\"\\\\u001b[3m\\\";\\n    string constant UNDERLINE = \\\"\\\\u001b[4m\\\";\\n    string constant INVERSE = \\\"\\\\u001b[7m\\\";\\n    string constant RESET = \\\"\\\\u001b[0m\\\";\\n\\n    function styleConcat(string memory style, string memory self) private pure returns (string memory) {\\n        return string(abi.encodePacked(style, self, RESET));\\n    }\\n\\n    function red(string memory self) internal pure returns (string memory) {\\n        return styleConcat(RED, self);\\n    }\\n\\n    function red(uint256 self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function red(int256 self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function red(address self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function red(bool self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function redBytes(bytes memory self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function redBytes32(bytes32 self) internal pure returns (string memory) {\\n        return red(vm.toString(self));\\n    }\\n\\n    function green(string memory self) internal pure returns (string memory) {\\n        return styleConcat(GREEN, self);\\n    }\\n\\n    function green(uint256 self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function green(int256 self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function green(address self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function green(bool self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function greenBytes(bytes memory self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function greenBytes32(bytes32 self) internal pure returns (string memory) {\\n        return green(vm.toString(self));\\n    }\\n\\n    function yellow(string memory self) internal pure returns (string memory) {\\n        return styleConcat(YELLOW, self);\\n    }\\n\\n    function yellow(uint256 self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function yellow(int256 self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function yellow(address self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function yellow(bool self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function yellowBytes(bytes memory self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function yellowBytes32(bytes32 self) internal pure returns (string memory) {\\n        return yellow(vm.toString(self));\\n    }\\n\\n    function blue(string memory self) internal pure returns (string memory) {\\n        return styleConcat(BLUE, self);\\n    }\\n\\n    function blue(uint256 self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function blue(int256 self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function blue(address self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function blue(bool self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function blueBytes(bytes memory self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function blueBytes32(bytes32 self) internal pure returns (string memory) {\\n        return blue(vm.toString(self));\\n    }\\n\\n    function magenta(string memory self) internal pure returns (string memory) {\\n        return styleConcat(MAGENTA, self);\\n    }\\n\\n    function magenta(uint256 self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function magenta(int256 self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function magenta(address self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function magenta(bool self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function magentaBytes(bytes memory self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function magentaBytes32(bytes32 self) internal pure returns (string memory) {\\n        return magenta(vm.toString(self));\\n    }\\n\\n    function cyan(string memory self) internal pure returns (string memory) {\\n        return styleConcat(CYAN, self);\\n    }\\n\\n    function cyan(uint256 self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function cyan(int256 self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function cyan(address self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function cyan(bool self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function cyanBytes(bytes memory self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function cyanBytes32(bytes32 self) internal pure returns (string memory) {\\n        return cyan(vm.toString(self));\\n    }\\n\\n    function bold(string memory self) internal pure returns (string memory) {\\n        return styleConcat(BOLD, self);\\n    }\\n\\n    function bold(uint256 self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function bold(int256 self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function bold(address self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function bold(bool self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function boldBytes(bytes memory self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function boldBytes32(bytes32 self) internal pure returns (string memory) {\\n        return bold(vm.toString(self));\\n    }\\n\\n    function dim(string memory self) internal pure returns (string memory) {\\n        return styleConcat(DIM, self);\\n    }\\n\\n    function dim(uint256 self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function dim(int256 self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function dim(address self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function dim(bool self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function dimBytes(bytes memory self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function dimBytes32(bytes32 self) internal pure returns (string memory) {\\n        return dim(vm.toString(self));\\n    }\\n\\n    function italic(string memory self) internal pure returns (string memory) {\\n        return styleConcat(ITALIC, self);\\n    }\\n\\n    function italic(uint256 self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function italic(int256 self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function italic(address self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function italic(bool self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function italicBytes(bytes memory self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function italicBytes32(bytes32 self) internal pure returns (string memory) {\\n        return italic(vm.toString(self));\\n    }\\n\\n    function underline(string memory self) internal pure returns (string memory) {\\n        return styleConcat(UNDERLINE, self);\\n    }\\n\\n    function underline(uint256 self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function underline(int256 self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function underline(address self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function underline(bool self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function underlineBytes(bytes memory self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function underlineBytes32(bytes32 self) internal pure returns (string memory) {\\n        return underline(vm.toString(self));\\n    }\\n\\n    function inverse(string memory self) internal pure returns (string memory) {\\n        return styleConcat(INVERSE, self);\\n    }\\n\\n    function inverse(uint256 self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n\\n    function inverse(int256 self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n\\n    function inverse(address self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n\\n    function inverse(bool self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n\\n    function inverseBytes(bytes memory self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n\\n    function inverseBytes32(bytes32 self) internal pure returns (string memory) {\\n        return inverse(vm.toString(self));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/StdUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport {IMulticall3} from \\\"./interfaces/IMulticall3.sol\\\";\\nimport {VmSafe} from \\\"./Vm.sol\\\";\\n\\nabstract contract StdUtils {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                     CONSTANTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);\\n    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\\\"hevm cheat code\\\")))));\\n    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;\\n    uint256 private constant INT256_MIN_ABS =\\n        57896044618658097711785492504343953926634992332820282019728792003956564819968;\\n    uint256 private constant SECP256K1_ORDER =\\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\\n    uint256 private constant UINT256_MAX =\\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\\n\\n    // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\\n    address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                 INTERNAL FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {\\n        require(min <= max, \\\"StdUtils bound(uint256,uint256,uint256): Max is less than min.\\\");\\n        // If x is between min and max, return x directly. This is to ensure that dictionary values\\n        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188\\n        if (x >= min && x <= max) return x;\\n\\n        uint256 size = max - min + 1;\\n\\n        // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.\\n        // This helps ensure coverage of the min/max values.\\n        if (x <= 3 && size > x) return min + x;\\n        if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);\\n\\n        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.\\n        if (x > max) {\\n            uint256 diff = x - max;\\n            uint256 rem = diff % size;\\n            if (rem == 0) return max;\\n            result = min + rem - 1;\\n        } else if (x < min) {\\n            uint256 diff = min - x;\\n            uint256 rem = diff % size;\\n            if (rem == 0) return min;\\n            result = max - rem + 1;\\n        }\\n    }\\n\\n    function bound(uint256 x, uint256 min, uint256 max) internal view virtual returns (uint256 result) {\\n        result = _bound(x, min, max);\\n        console2_log(\\\"Bound Result\\\", result);\\n    }\\n\\n    function _bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {\\n        require(min <= max, \\\"StdUtils bound(int256,int256,int256): Max is less than min.\\\");\\n\\n        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:\\n        // int256 : -(2**255) ~ (2**255 - 1)\\n        // uint256:     0     ~ (2**256 - 1)\\n        // So, add 2**255, INT256_MIN_ABS to the integer values.\\n        //\\n        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.\\n        // So, use `~uint256(x) + 1` instead.\\n        uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);\\n        uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);\\n        uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);\\n\\n        uint256 y = _bound(_x, _min, _max);\\n\\n        // To move it back to int256 value, subtract INT256_MIN_ABS at here.\\n        result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);\\n    }\\n\\n    function bound(int256 x, int256 min, int256 max) internal view virtual returns (int256 result) {\\n        result = _bound(x, min, max);\\n        console2_log(\\\"Bound result\\\", vm.toString(result));\\n    }\\n\\n    function boundPrivateKey(uint256 privateKey) internal pure virtual returns (uint256 result) {\\n        result = _bound(privateKey, 1, SECP256K1_ORDER - 1);\\n    }\\n\\n    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {\\n        require(b.length <= 32, \\\"StdUtils bytesToUint(bytes): Bytes length exceeds 32.\\\");\\n        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));\\n    }\\n\\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\\n    /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)\\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {\\n        // forgefmt: disable-start\\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\\n        // A one byte integer uses its own value as its length prefix, there is no additional \\\"0x80 + length\\\" prefix that comes before it.\\n        if (nonce == 0x00)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));\\n        if (nonce <= 0x7f)      return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));\\n\\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\\n        if (nonce <= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));\\n        if (nonce <= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));\\n        if (nonce <= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));\\n        // forgefmt: disable-end\\n\\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\\n        return addressFromLast20Bytes(\\n            keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce)))\\n        );\\n    }\\n\\n    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)\\n        internal\\n        pure\\n        virtual\\n        returns (address)\\n    {\\n        return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, initcodeHash)));\\n    }\\n\\n    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer\\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {\\n        return computeCreate2Address(salt, initCodeHash, CREATE2_FACTORY);\\n    }\\n\\n    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments\\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\\n    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {\\n        return hashInitCode(creationCode, \\\"\\\");\\n    }\\n\\n    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2\\n    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode\\n    /// @param args the ABI-encoded arguments to the constructor of C\\n    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(creationCode, args));\\n    }\\n\\n    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.\\n    function getTokenBalances(address token, address[] memory addresses)\\n        internal\\n        virtual\\n        returns (uint256[] memory balances)\\n    {\\n        uint256 tokenCodeSize;\\n        assembly {\\n            tokenCodeSize := extcodesize(token)\\n        }\\n        require(tokenCodeSize > 0, \\\"StdUtils getTokenBalances(address,address[]): Token address is not a contract.\\\");\\n\\n        // ABI encode the aggregate call to Multicall3.\\n        uint256 length = addresses.length;\\n        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);\\n        for (uint256 i = 0; i < length; ++i) {\\n            // 0x70a08231 = bytes4(\\\"balanceOf(address)\\\"))\\n            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});\\n        }\\n\\n        // Make the aggregate call.\\n        (, bytes[] memory returnData) = multicall.aggregate(calls);\\n\\n        // ABI decode the return data and return the balances.\\n        balances = new uint256[](length);\\n        for (uint256 i = 0; i < length; ++i) {\\n            balances[i] = abi.decode(returnData[i], (uint256));\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                 PRIVATE FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {\\n        return address(uint160(uint256(bytesValue)));\\n    }\\n\\n    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.\\n\\n    function console2_log(string memory p0, uint256 p1) private view {\\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n        status;\\n    }\\n\\n    function console2_log(string memory p0, string memory p1) private view {\\n        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n        status;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/Vm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\n// Cheatcodes are marked as view/pure/none using the following rules:\\n// 0. A call's observable behaviour includes its return value, logs, reverts and state writes,\\n// 1. If you can influence a later call's observable behaviour, you're neither `view` nor `pure (you are modifying some state be it the EVM, interpreter, filesystem, etc),\\n// 2. Otherwise if you can be influenced by an earlier call, or if reading some state, you're `view`,\\n// 3. Otherwise you're `pure`.\\n\\ninterface VmSafe {\\n    enum CallerMode {\\n        None,\\n        Broadcast,\\n        RecurrentBroadcast,\\n        Prank,\\n        RecurrentPrank\\n    }\\n\\n    struct Log {\\n        bytes32[] topics;\\n        bytes data;\\n        address emitter;\\n    }\\n\\n    struct Rpc {\\n        string key;\\n        string url;\\n    }\\n\\n    struct DirEntry {\\n        string errorMessage;\\n        string path;\\n        uint64 depth;\\n        bool isDir;\\n        bool isSymlink;\\n    }\\n\\n    struct FsMetadata {\\n        bool isDir;\\n        bool isSymlink;\\n        uint256 length;\\n        bool readOnly;\\n        uint256 modified;\\n        uint256 accessed;\\n        uint256 created;\\n    }\\n\\n    // Loads a storage slot from an address\\n    function load(address target, bytes32 slot) external view returns (bytes32 data);\\n    // Signs data\\n    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);\\n    // Gets the address for a given private key\\n    function addr(uint256 privateKey) external pure returns (address keyAddr);\\n    // Gets the nonce of an account\\n    function getNonce(address account) external view returns (uint64 nonce);\\n    // Performs a foreign function call via the terminal\\n    function ffi(string[] calldata commandInput) external returns (bytes memory result);\\n    // Sets environment variables\\n    function setEnv(string calldata name, string calldata value) external;\\n    // Reads environment variables, (name) => (value)\\n    function envBool(string calldata name) external view returns (bool value);\\n    function envUint(string calldata name) external view returns (uint256 value);\\n    function envInt(string calldata name) external view returns (int256 value);\\n    function envAddress(string calldata name) external view returns (address value);\\n    function envBytes32(string calldata name) external view returns (bytes32 value);\\n    function envString(string calldata name) external view returns (string memory value);\\n    function envBytes(string calldata name) external view returns (bytes memory value);\\n    // Reads environment variables as arrays\\n    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);\\n    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);\\n    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);\\n    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);\\n    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);\\n    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);\\n    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);\\n    // Read environment variables with default value\\n    function envOr(string calldata name, bool defaultValue) external returns (bool value);\\n    function envOr(string calldata name, uint256 defaultValue) external returns (uint256 value);\\n    function envOr(string calldata name, int256 defaultValue) external returns (int256 value);\\n    function envOr(string calldata name, address defaultValue) external returns (address value);\\n    function envOr(string calldata name, bytes32 defaultValue) external returns (bytes32 value);\\n    function envOr(string calldata name, string calldata defaultValue) external returns (string memory value);\\n    function envOr(string calldata name, bytes calldata defaultValue) external returns (bytes memory value);\\n    // Read environment variables as arrays with default value\\n    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)\\n        external\\n        returns (bool[] memory value);\\n    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)\\n        external\\n        returns (uint256[] memory value);\\n    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)\\n        external\\n        returns (int256[] memory value);\\n    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)\\n        external\\n        returns (address[] memory value);\\n    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)\\n        external\\n        returns (bytes32[] memory value);\\n    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)\\n        external\\n        returns (string[] memory value);\\n    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)\\n        external\\n        returns (bytes[] memory value);\\n    // Records all storage reads and writes\\n    function record() external;\\n    // Gets all accessed reads and write slot from a recording session, for a given address\\n    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);\\n    // Gets the _creation_ bytecode from an artifact file. Takes in the relative path to the json file\\n    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);\\n    // Gets the _deployed_ bytecode from an artifact file. Takes in the relative path to the json file\\n    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);\\n    // Labels an address in call traces\\n    function label(address account, string calldata newLabel) external;\\n    // Gets the label for the specified address\\n    function getLabel(address account) external returns (string memory currentLabel);\\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\\n    function broadcast() external;\\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\\n    function broadcast(address signer) external;\\n    // Has the next call (at this call depth only) create a transaction with the private key provided as the sender that can later be signed and sent onchain\\n    function broadcast(uint256 privateKey) external;\\n    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\\n    function startBroadcast() external;\\n    // Has all subsequent calls (at this call depth only) create transactions with the address provided that can later be signed and sent onchain\\n    function startBroadcast(address signer) external;\\n    // Has all subsequent calls (at this call depth only) create transactions with the private key provided that can later be signed and sent onchain\\n    function startBroadcast(uint256 privateKey) external;\\n    // Stops collecting onchain transactions\\n    function stopBroadcast() external;\\n\\n    // Get the path of the current project root.\\n    function projectRoot() external view returns (string memory path);\\n    // Reads the entire content of file to string. `path` is relative to the project root.\\n    function readFile(string calldata path) external view returns (string memory data);\\n    // Reads the entire content of file as binary. `path` is relative to the project root.\\n    function readFileBinary(string calldata path) external view returns (bytes memory data);\\n    // Reads next line of file to string.\\n    function readLine(string calldata path) external view returns (string memory line);\\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\\n    // `path` is relative to the project root.\\n    function writeFile(string calldata path, string calldata data) external;\\n    // Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.\\n    // `path` is relative to the project root.\\n    function writeFileBinary(string calldata path, bytes calldata data) external;\\n    // Writes line to file, creating a file if it does not exist.\\n    // `path` is relative to the project root.\\n    function writeLine(string calldata path, string calldata data) external;\\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\\n    // `path` is relative to the project root.\\n    function closeFile(string calldata path) external;\\n    // Removes a file from the filesystem.\\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\\n    // - `path` points to a directory.\\n    // - The file doesn't exist.\\n    // - The user lacks permissions to remove the file.\\n    // `path` is relative to the project root.\\n    function removeFile(string calldata path) external;\\n    // Creates a new, empty directory at the provided path.\\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\\n    // - User lacks permissions to modify `path`.\\n    // - A parent of the given path doesn't exist and `recursive` is false.\\n    // - `path` already exists and `recursive` is false.\\n    // `path` is relative to the project root.\\n    function createDir(string calldata path, bool recursive) external;\\n    // Removes a directory at the provided path.\\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\\n    // - `path` doesn't exist.\\n    // - `path` isn't a directory.\\n    // - User lacks permissions to modify `path`.\\n    // - The directory is not empty and `recursive` is false.\\n    // `path` is relative to the project root.\\n    function removeDir(string calldata path, bool recursive) external;\\n    // Reads the directory at the given path recursively, up to `max_depth`.\\n    // `max_depth` defaults to 1, meaning only the direct children of the given directory will be returned.\\n    // Follows symbolic links if `follow_links` is true.\\n    function readDir(string calldata path) external view returns (DirEntry[] memory entries);\\n    function readDir(string calldata path, uint64 maxDepth) external view returns (DirEntry[] memory entries);\\n    function readDir(string calldata path, uint64 maxDepth, bool followLinks)\\n        external\\n        view\\n        returns (DirEntry[] memory entries);\\n    // Reads a symbolic link, returning the path that the link points to.\\n    // This cheatcode will revert in the following situations, but is not limited to just these cases:\\n    // - `path` is not a symbolic link.\\n    // - `path` does not exist.\\n    function readLink(string calldata linkPath) external view returns (string memory targetPath);\\n    // Given a path, query the file system to get information about a file, directory, etc.\\n    function fsMetadata(string calldata path) external view returns (FsMetadata memory metadata);\\n\\n    // Convert values to a string\\n    function toString(address value) external pure returns (string memory stringifiedValue);\\n    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);\\n    function toString(bytes32 value) external pure returns (string memory stringifiedValue);\\n    function toString(bool value) external pure returns (string memory stringifiedValue);\\n    function toString(uint256 value) external pure returns (string memory stringifiedValue);\\n    function toString(int256 value) external pure returns (string memory stringifiedValue);\\n    // Convert values from a string\\n    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);\\n    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);\\n    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);\\n    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);\\n    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);\\n    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);\\n    // Record all the transaction logs\\n    function recordLogs() external;\\n    // Gets all the recorded logs\\n    function getRecordedLogs() external returns (Log[] memory logs);\\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\\n    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);\\n    // Derive a private key from a provided mnenomic string (or mnenomic file path) at {derivationPath}{index}\\n    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)\\n        external\\n        pure\\n        returns (uint256 privateKey);\\n    // Adds a private key to the local forge wallet and returns the address\\n    function rememberKey(uint256 privateKey) external returns (address keyAddr);\\n    //\\n    // parseJson\\n    //\\n    // ----\\n    // In case the returned value is a JSON object, it's encoded as a ABI-encoded tuple. As JSON objects\\n    // don't have the notion of ordered, but tuples do, they JSON object is encoded with it's fields ordered in\\n    // ALPHABETICAL order. That means that in order to successfully decode the tuple, we need to define a tuple that\\n    // encodes the fields in the same order, which is alphabetical. In the case of Solidity structs, they are encoded\\n    // as tuples, with the attributes in the order in which they are defined.\\n    // For example: json = { 'a': 1, 'b': 0xa4tb......3xs}\\n    // a: uint256\\n    // b: address\\n    // To decode that json, we need to define a struct or a tuple as follows:\\n    // struct json = { uint256 a; address b; }\\n    // If we defined a json struct with the opposite order, meaning placing the address b first, it would try to\\n    // decode the tuple in that order, and thus fail.\\n    // ----\\n    // Given a string of JSON, return it as ABI-encoded\\n    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);\\n    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);\\n\\n    // The following parseJson cheatcodes will do type coercion, for the type that they indicate.\\n    // For example, parseJsonUint will coerce all values to a uint256. That includes stringified numbers '12'\\n    // and hex numbers '0xEF'.\\n    // Type coercion works ONLY for discrete values or arrays. That means that the key must return a value or array, not\\n    // a JSON object.\\n    function parseJsonUint(string calldata, string calldata) external returns (uint256);\\n    function parseJsonUintArray(string calldata, string calldata) external returns (uint256[] memory);\\n    function parseJsonInt(string calldata, string calldata) external returns (int256);\\n    function parseJsonIntArray(string calldata, string calldata) external returns (int256[] memory);\\n    function parseJsonBool(string calldata, string calldata) external returns (bool);\\n    function parseJsonBoolArray(string calldata, string calldata) external returns (bool[] memory);\\n    function parseJsonAddress(string calldata, string calldata) external returns (address);\\n    function parseJsonAddressArray(string calldata, string calldata) external returns (address[] memory);\\n    function parseJsonString(string calldata, string calldata) external returns (string memory);\\n    function parseJsonStringArray(string calldata, string calldata) external returns (string[] memory);\\n    function parseJsonBytes(string calldata, string calldata) external returns (bytes memory);\\n    function parseJsonBytesArray(string calldata, string calldata) external returns (bytes[] memory);\\n    function parseJsonBytes32(string calldata, string calldata) external returns (bytes32);\\n    function parseJsonBytes32Array(string calldata, string calldata) external returns (bytes32[] memory);\\n\\n    // Serialize a key and value to a JSON object stored in-memory that can be later written to a file\\n    // It returns the stringified version of the specific JSON file up to that moment.\\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)\\n        external\\n        returns (string memory json);\\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)\\n        external\\n        returns (string memory json);\\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)\\n        external\\n        returns (string memory json);\\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)\\n        external\\n        returns (string memory json);\\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)\\n        external\\n        returns (string memory json);\\n    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)\\n        external\\n        returns (string memory json);\\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)\\n        external\\n        returns (string memory json);\\n\\n    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)\\n        external\\n        returns (string memory json);\\n    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)\\n        external\\n        returns (string memory json);\\n    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)\\n        external\\n        returns (string memory json);\\n    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)\\n        external\\n        returns (string memory json);\\n    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)\\n        external\\n        returns (string memory json);\\n    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)\\n        external\\n        returns (string memory json);\\n    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)\\n        external\\n        returns (string memory json);\\n\\n    //\\n    // writeJson\\n    //\\n    // ----\\n    // Write a serialized JSON object to a file. If the file exists, it will be overwritten.\\n    // Let's assume we want to write the following JSON to a file:\\n    //\\n    // { \\\"boolean\\\": true, \\\"number\\\": 342, \\\"object\\\": { \\\"title\\\": \\\"finally json serialization\\\" } }\\n    //\\n    // ```\\n    //  string memory json1 = \\\"some key\\\";\\n    //  vm.serializeBool(json1, \\\"boolean\\\", true);\\n    //  vm.serializeBool(json1, \\\"number\\\", uint256(342));\\n    //  json2 = \\\"some other key\\\";\\n    //  string memory output = vm.serializeString(json2, \\\"title\\\", \\\"finally json serialization\\\");\\n    //  string memory finalJson = vm.serialize(json1, \\\"object\\\", output);\\n    //  vm.writeJson(finalJson, \\\"./output/example.json\\\");\\n    // ```\\n    // The critical insight is that every invocation of serialization will return the stringified version of the JSON\\n    // up to that point. That means we can construct arbitrary JSON objects and then use the return stringified version\\n    // to serialize them as values to another JSON object.\\n    //\\n    // json1 and json2 are simply keys used by the backend to keep track of the objects. So vm.serializeJson(json1,..)\\n    // will find the object in-memory that is keyed by \\\"some key\\\".\\n    function writeJson(string calldata json, string calldata path) external;\\n    // Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key>\\n    // This is useful to replace a specific value of a JSON file, without having to parse the entire thing\\n    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;\\n    // Returns the RPC url for the given alias\\n    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);\\n    // Returns all rpc urls and their aliases `[alias, url][]`\\n    function rpcUrls() external view returns (string[2][] memory urls);\\n    // Returns all rpc urls and their aliases as structs.\\n    function rpcUrlStructs() external view returns (Rpc[] memory urls);\\n    // If the condition is false, discard this run's fuzz inputs and generate new ones.\\n    function assume(bool condition) external pure;\\n    // Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.\\n    function pauseGasMetering() external;\\n    // Resumes gas metering (i.e. gas usage is counted again). Noop if already on.\\n    function resumeGasMetering() external;\\n    // Writes a breakpoint to jump to in the debugger\\n    function breakpoint(string calldata char) external;\\n    // Writes a conditional breakpoint to jump to in the debugger\\n    function breakpoint(string calldata char, bool value) external;\\n}\\n\\ninterface Vm is VmSafe {\\n    // Sets block.timestamp\\n    function warp(uint256 newTimestamp) external;\\n    // Sets block.height\\n    function roll(uint256 newHeight) external;\\n    // Sets block.basefee\\n    function fee(uint256 newBasefee) external;\\n    // Sets block.difficulty\\n    // Not available on EVM versions from Paris onwards. Use `prevrandao` instead.\\n    // If used on unsupported EVM versions it will revert.\\n    function difficulty(uint256 newDifficulty) external;\\n    // Sets block.prevrandao\\n    // Not available on EVM versions before Paris. Use `difficulty` instead.\\n    // If used on unsupported EVM versions it will revert.\\n    function prevrandao(bytes32 newPrevrandao) external;\\n    // Sets block.chainid\\n    function chainId(uint256 newChainId) external;\\n    // Sets tx.gasprice\\n    function txGasPrice(uint256 newGasPrice) external;\\n    // Stores a value to an address' storage slot.\\n    function store(address target, bytes32 slot, bytes32 value) external;\\n    // Sets the nonce of an account; must be higher than the current nonce of the account\\n    function setNonce(address account, uint64 newNonce) external;\\n    // Sets the nonce of an account to an arbitrary value\\n    function setNonceUnsafe(address account, uint64 newNonce) external;\\n    // Resets the nonce of an account to 0 for EOAs and 1 for contract accounts\\n    function resetNonce(address account) external;\\n    // Sets the *next* call's msg.sender to be the input address\\n    function prank(address msgSender) external;\\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\\n    function startPrank(address msgSender) external;\\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\\n    function prank(address msgSender, address txOrigin) external;\\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\\n    function startPrank(address msgSender, address txOrigin) external;\\n    // Resets subsequent calls' msg.sender to be `address(this)`\\n    function stopPrank() external;\\n    // Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification\\n    function readCallers() external returns (CallerMode callerMode, address msgSender, address txOrigin);\\n    // Sets an address' balance\\n    function deal(address account, uint256 newBalance) external;\\n    // Sets an address' code\\n    function etch(address target, bytes calldata newRuntimeBytecode) external;\\n    // Marks a test as skipped. Must be called at the top of the test.\\n    function skip(bool skipTest) external;\\n    // Expects an error on next call\\n    function expectRevert(bytes calldata revertData) external;\\n    function expectRevert(bytes4 revertData) external;\\n    function expectRevert() external;\\n\\n    // Prepare an expected log with all four checks enabled.\\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\\n    // logs were emitted in the expected order with the expected topics and data.\\n    // Second form also checks supplied address against emitting contract.\\n    function expectEmit() external;\\n    function expectEmit(address emitter) external;\\n\\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\\n    // Second form also checks supplied address against emitting contract.\\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;\\n    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)\\n        external;\\n\\n    // Mocks a call to an address, returning specified data.\\n    // Calldata can either be strict or a partial match, e.g. if you only\\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\\n    // function will be mocked.\\n    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;\\n    // Mocks a call to an address with a specific msg.value, returning specified data.\\n    // Calldata match takes precedence over msg.value in case of ambiguity.\\n    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;\\n    // Reverts a call to an address with specified revert data.\\n    function mockCallRevert(address callee, bytes calldata data, bytes calldata revertData) external;\\n    // Reverts a call to an address with a specific msg.value, with specified revert data.\\n    function mockCallRevert(address callee, uint256 msgValue, bytes calldata data, bytes calldata revertData)\\n        external;\\n    // Clears all mocked calls\\n    function clearMockedCalls() external;\\n    // Expects a call to an address with the specified calldata.\\n    // Calldata can either be a strict or a partial match\\n    function expectCall(address callee, bytes calldata data) external;\\n    // Expects given number of calls to an address with the specified calldata.\\n    function expectCall(address callee, bytes calldata data, uint64 count) external;\\n    // Expects a call to an address with the specified msg.value and calldata\\n    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;\\n    // Expects given number of calls to an address with the specified msg.value and calldata\\n    function expectCall(address callee, uint256 msgValue, bytes calldata data, uint64 count) external;\\n    // Expect a call to an address with the specified msg.value, gas, and calldata.\\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;\\n    // Expects given number of calls to an address with the specified msg.value, gas, and calldata.\\n    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data, uint64 count) external;\\n    // Expect a call to an address with the specified msg.value and calldata, and a *minimum* amount of gas.\\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;\\n    // Expect given number of calls to an address with the specified msg.value and calldata, and a *minimum* amount of gas.\\n    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data, uint64 count)\\n        external;\\n    // Only allows memory writes to offsets [0x00, 0x60) \u222a [min, max) in the current subcontext. If any other\\n    // memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.\\n    function expectSafeMemory(uint64 min, uint64 max) external;\\n    // Only allows memory writes to offsets [0x00, 0x60) \u222a [min, max) in the next created subcontext.\\n    // If any other memory is written to, the test will fail. Can be called multiple times to add more ranges\\n    // to the set.\\n    function expectSafeMemoryCall(uint64 min, uint64 max) external;\\n    // Sets block.coinbase\\n    function coinbase(address newCoinbase) external;\\n    // Snapshot the current state of the evm.\\n    // Returns the id of the snapshot that was created.\\n    // To revert a snapshot use `revertTo`\\n    function snapshot() external returns (uint256 snapshotId);\\n    // Revert the state of the EVM to a previous snapshot\\n    // Takes the snapshot id to revert to.\\n    // This deletes the snapshot and all snapshots taken after the given snapshot id.\\n    function revertTo(uint256 snapshotId) external returns (bool success);\\n    // Creates a new fork with the given endpoint and block and returns the identifier of the fork\\n    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\\n    // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\\n    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);\\n    // Creates a new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before the transaction,\\n    // and returns the identifier of the fork\\n    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\\n    // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\\n    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);\\n    // Creates _and_ also selects new fork with the given endpoint and at the block the given transaction was mined in, replays all transaction mined in the block before\\n    // the transaction, returns the identifier of the fork\\n    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);\\n    // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\\n    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);\\n    // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\\n    function selectFork(uint256 forkId) external;\\n    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.\\n    function activeFork() external view returns (uint256 forkId);\\n    // Updates the currently active fork to given block number\\n    // This is similar to `roll` but for the currently active fork\\n    function rollFork(uint256 blockNumber) external;\\n    // Updates the currently active fork to given transaction\\n    // this will `rollFork` with the number of the block the transaction was mined in and replays all transaction mined before it in the block\\n    function rollFork(bytes32 txHash) external;\\n    // Updates the given fork to given block number\\n    function rollFork(uint256 forkId, uint256 blockNumber) external;\\n    // Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block\\n    function rollFork(uint256 forkId, bytes32 txHash) external;\\n    // Marks that the account(s) should use persistent storage across fork swaps in a multifork setup\\n    // Meaning, changes made to the state of this account will be kept when switching forks\\n    function makePersistent(address account) external;\\n    function makePersistent(address account0, address account1) external;\\n    function makePersistent(address account0, address account1, address account2) external;\\n    function makePersistent(address[] calldata accounts) external;\\n    // Revokes persistent status from the address, previously added via `makePersistent`\\n    function revokePersistent(address account) external;\\n    function revokePersistent(address[] calldata accounts) external;\\n    // Returns true if the account is marked as persistent\\n    function isPersistent(address account) external view returns (bool persistent);\\n    // In forking mode, explicitly grant the given address cheatcode access\\n    function allowCheatcodes(address account) external;\\n    // Fetches the given transaction from the active fork and executes it on the current state\\n    function transact(bytes32 txHash) external;\\n    // Fetches the given transaction from the given fork and executes it on the current state\\n    function transact(uint256 forkId, bytes32 txHash) external;\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\nimport {StdStorage} from \\\"./StdStorage.sol\\\";\\nimport {Vm, VmSafe} from \\\"./Vm.sol\\\";\\n\\nabstract contract CommonBase {\\n    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.\\n    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(\\\"hevm cheat code\\\"))));\\n    // console.sol and console2.sol work by executing a staticcall to this address.\\n    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;\\n    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.\\n    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;\\n    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.\\n    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(\\\"foundry default caller\\\"))));\\n    // Address of the test contract, deployed by the DEFAULT_SENDER.\\n    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;\\n    // Deterministic deployment address of the Multicall3 contract.\\n    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;\\n    // The order of the secp256k1 curve.\\n    uint256 internal constant SECP256K1_ORDER =\\n        115792089237316195423570985008687907852837564279074904382605163141518161494337;\\n\\n    uint256 internal constant UINT256_MAX =\\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\\n\\n    Vm internal constant vm = Vm(VM_ADDRESS);\\n    StdStorage internal stdstore;\\n}\\n\\nabstract contract TestBase is CommonBase {}\\n\\nabstract contract ScriptBase is CommonBase {\\n    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/lib/ds-test/src/test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.5.0;\\n\\ncontract DSTest {\\n    event log                    (string);\\n    event logs                   (bytes);\\n\\n    event log_address            (address);\\n    event log_bytes32            (bytes32);\\n    event log_int                (int);\\n    event log_uint               (uint);\\n    event log_bytes              (bytes);\\n    event log_string             (string);\\n\\n    event log_named_address      (string key, address val);\\n    event log_named_bytes32      (string key, bytes32 val);\\n    event log_named_decimal_int  (string key, int val, uint decimals);\\n    event log_named_decimal_uint (string key, uint val, uint decimals);\\n    event log_named_int          (string key, int val);\\n    event log_named_uint         (string key, uint val);\\n    event log_named_bytes        (string key, bytes val);\\n    event log_named_string       (string key, string val);\\n\\n    bool public IS_TEST = true;\\n    bool private _failed;\\n\\n    address constant HEVM_ADDRESS =\\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\\n\\n    modifier mayRevert() { _; }\\n    modifier testopts(string memory) { _; }\\n\\n    function failed() public returns (bool) {\\n        if (_failed) {\\n            return _failed;\\n        } else {\\n            bool globalFailed = false;\\n            if (hasHEVMContext()) {\\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\\n                    abi.encodePacked(\\n                        bytes4(keccak256(\\\"load(address,bytes32)\\\")),\\n                        abi.encode(HEVM_ADDRESS, bytes32(\\\"failed\\\"))\\n                    )\\n                );\\n                globalFailed = abi.decode(retdata, (bool));\\n            }\\n            return globalFailed;\\n        }\\n    }\\n\\n    function fail() internal virtual {\\n        if (hasHEVMContext()) {\\n            (bool status, ) = HEVM_ADDRESS.call(\\n                abi.encodePacked(\\n                    bytes4(keccak256(\\\"store(address,bytes32,bytes32)\\\")),\\n                    abi.encode(HEVM_ADDRESS, bytes32(\\\"failed\\\"), bytes32(uint256(0x01)))\\n                )\\n            );\\n            status; // Silence compiler warnings\\n        }\\n        _failed = true;\\n    }\\n\\n    function hasHEVMContext() internal view returns (bool) {\\n        uint256 hevmCodeSize = 0;\\n        assembly {\\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\\n        }\\n        return hevmCodeSize > 0;\\n    }\\n\\n    modifier logs_gas() {\\n        uint startGas = gasleft();\\n        _;\\n        uint endGas = gasleft();\\n        emit log_named_uint(\\\"gas\\\", startGas - endGas);\\n    }\\n\\n    function assertTrue(bool condition) internal {\\n        if (!condition) {\\n            emit log(\\\"Error: Assertion Failed\\\");\\n            fail();\\n        }\\n    }\\n\\n    function assertTrue(bool condition, string memory err) internal {\\n        if (!condition) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertTrue(condition);\\n        }\\n    }\\n\\n    function assertEq(address a, address b) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [address]\\\");\\n            emit log_named_address(\\\"      Left\\\", a);\\n            emit log_named_address(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertEq(address a, address b, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string (\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n\\n    function assertEq(bytes32 a, bytes32 b) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [bytes32]\\\");\\n            emit log_named_bytes32(\\\"      Left\\\", a);\\n            emit log_named_bytes32(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string (\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n    function assertEq32(bytes32 a, bytes32 b) internal {\\n        assertEq(a, b);\\n    }\\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\\n        assertEq(a, b, err);\\n    }\\n\\n    function assertEq(int a, int b) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [int]\\\");\\n            emit log_named_int(\\\"      Left\\\", a);\\n            emit log_named_int(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertEq(int a, int b, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n    function assertEq(uint a, uint b) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"      Left\\\", a);\\n            emit log_named_uint(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertEq(uint a, uint b, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n    function assertEqDecimal(int a, int b, uint decimals) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [decimal int]\\\");\\n            emit log_named_decimal_int(\\\"      Left\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"     Right\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEqDecimal(a, b, decimals);\\n        }\\n    }\\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\\n        if (a != b) {\\n            emit log(\\\"Error: a == b not satisfied [decimal uint]\\\");\\n            emit log_named_decimal_uint(\\\"      Left\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"     Right\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\\n        if (a != b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEqDecimal(a, b, decimals);\\n        }\\n    }\\n\\n    function assertNotEq(address a, address b) internal {\\n        if (a == b) {\\n            emit log(\\\"Error: a != b not satisfied [address]\\\");\\n            emit log_named_address(\\\"      Left\\\", a);\\n            emit log_named_address(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertNotEq(address a, address b, string memory err) internal {\\n        if (a == b) {\\n            emit log_named_string (\\\"Error\\\", err);\\n            assertNotEq(a, b);\\n        }\\n    }\\n\\n    function assertNotEq(bytes32 a, bytes32 b) internal {\\n        if (a == b) {\\n            emit log(\\\"Error: a != b not satisfied [bytes32]\\\");\\n            emit log_named_bytes32(\\\"      Left\\\", a);\\n            emit log_named_bytes32(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertNotEq(bytes32 a, bytes32 b, string memory err) internal {\\n        if (a == b) {\\n            emit log_named_string (\\\"Error\\\", err);\\n            assertNotEq(a, b);\\n        }\\n    }\\n    function assertNotEq32(bytes32 a, bytes32 b) internal {\\n        assertNotEq(a, b);\\n    }\\n    function assertNotEq32(bytes32 a, bytes32 b, string memory err) internal {\\n        assertNotEq(a, b, err);\\n    }\\n\\n    function assertNotEq(int a, int b) internal {\\n        if (a == b) {\\n            emit log(\\\"Error: a != b not satisfied [int]\\\");\\n            emit log_named_int(\\\"      Left\\\", a);\\n            emit log_named_int(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertNotEq(int a, int b, string memory err) internal {\\n        if (a == b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertNotEq(a, b);\\n        }\\n    }\\n    function assertNotEq(uint a, uint b) internal {\\n        if (a == b) {\\n            emit log(\\\"Error: a != b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"      Left\\\", a);\\n            emit log_named_uint(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertNotEq(uint a, uint b, string memory err) internal {\\n        if (a == b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertNotEq(a, b);\\n        }\\n    }\\n    function assertNotEqDecimal(int a, int b, uint decimals) internal {\\n        if (a == b) {\\n            emit log(\\\"Error: a != b not satisfied [decimal int]\\\");\\n            emit log_named_decimal_int(\\\"      Left\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"     Right\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertNotEqDecimal(int a, int b, uint decimals, string memory err) internal {\\n        if (a == b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertNotEqDecimal(a, b, decimals);\\n        }\\n    }\\n    function assertNotEqDecimal(uint a, uint b, uint decimals) internal {\\n        if (a == b) {\\n            emit log(\\\"Error: a != b not satisfied [decimal uint]\\\");\\n            emit log_named_decimal_uint(\\\"      Left\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"     Right\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertNotEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\\n        if (a == b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertNotEqDecimal(a, b, decimals);\\n        }\\n    }\\n\\n    function assertGt(uint a, uint b) internal {\\n        if (a <= b) {\\n            emit log(\\\"Error: a > b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"  Value a\\\", a);\\n            emit log_named_uint(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertGt(uint a, uint b, string memory err) internal {\\n        if (a <= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGt(a, b);\\n        }\\n    }\\n    function assertGt(int a, int b) internal {\\n        if (a <= b) {\\n            emit log(\\\"Error: a > b not satisfied [int]\\\");\\n            emit log_named_int(\\\"  Value a\\\", a);\\n            emit log_named_int(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertGt(int a, int b, string memory err) internal {\\n        if (a <= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGt(a, b);\\n        }\\n    }\\n    function assertGtDecimal(int a, int b, uint decimals) internal {\\n        if (a <= b) {\\n            emit log(\\\"Error: a > b not satisfied [decimal int]\\\");\\n            emit log_named_decimal_int(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\\n        if (a <= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGtDecimal(a, b, decimals);\\n        }\\n    }\\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\\n        if (a <= b) {\\n            emit log(\\\"Error: a > b not satisfied [decimal uint]\\\");\\n            emit log_named_decimal_uint(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\\n        if (a <= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGtDecimal(a, b, decimals);\\n        }\\n    }\\n\\n    function assertGe(uint a, uint b) internal {\\n        if (a < b) {\\n            emit log(\\\"Error: a >= b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"  Value a\\\", a);\\n            emit log_named_uint(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertGe(uint a, uint b, string memory err) internal {\\n        if (a < b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGe(a, b);\\n        }\\n    }\\n    function assertGe(int a, int b) internal {\\n        if (a < b) {\\n            emit log(\\\"Error: a >= b not satisfied [int]\\\");\\n            emit log_named_int(\\\"  Value a\\\", a);\\n            emit log_named_int(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertGe(int a, int b, string memory err) internal {\\n        if (a < b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGe(a, b);\\n        }\\n    }\\n    function assertGeDecimal(int a, int b, uint decimals) internal {\\n        if (a < b) {\\n            emit log(\\\"Error: a >= b not satisfied [decimal int]\\\");\\n            emit log_named_decimal_int(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\\n        if (a < b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGeDecimal(a, b, decimals);\\n        }\\n    }\\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\\n        if (a < b) {\\n            emit log(\\\"Error: a >= b not satisfied [decimal uint]\\\");\\n            emit log_named_decimal_uint(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\\n        if (a < b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertGeDecimal(a, b, decimals);\\n        }\\n    }\\n\\n    function assertLt(uint a, uint b) internal {\\n        if (a >= b) {\\n            emit log(\\\"Error: a < b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"  Value a\\\", a);\\n            emit log_named_uint(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertLt(uint a, uint b, string memory err) internal {\\n        if (a >= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLt(a, b);\\n        }\\n    }\\n    function assertLt(int a, int b) internal {\\n        if (a >= b) {\\n            emit log(\\\"Error: a < b not satisfied [int]\\\");\\n            emit log_named_int(\\\"  Value a\\\", a);\\n            emit log_named_int(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertLt(int a, int b, string memory err) internal {\\n        if (a >= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLt(a, b);\\n        }\\n    }\\n    function assertLtDecimal(int a, int b, uint decimals) internal {\\n        if (a >= b) {\\n            emit log(\\\"Error: a < b not satisfied [decimal int]\\\");\\n            emit log_named_decimal_int(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\\n        if (a >= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLtDecimal(a, b, decimals);\\n        }\\n    }\\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\\n        if (a >= b) {\\n            emit log(\\\"Error: a < b not satisfied [decimal uint]\\\");\\n            emit log_named_decimal_uint(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\\n        if (a >= b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLtDecimal(a, b, decimals);\\n        }\\n    }\\n\\n    function assertLe(uint a, uint b) internal {\\n        if (a > b) {\\n            emit log(\\\"Error: a <= b not satisfied [uint]\\\");\\n            emit log_named_uint(\\\"  Value a\\\", a);\\n            emit log_named_uint(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertLe(uint a, uint b, string memory err) internal {\\n        if (a > b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLe(a, b);\\n        }\\n    }\\n    function assertLe(int a, int b) internal {\\n        if (a > b) {\\n            emit log(\\\"Error: a <= b not satisfied [int]\\\");\\n            emit log_named_int(\\\"  Value a\\\", a);\\n            emit log_named_int(\\\"  Value b\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertLe(int a, int b, string memory err) internal {\\n        if (a > b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLe(a, b);\\n        }\\n    }\\n    function assertLeDecimal(int a, int b, uint decimals) internal {\\n        if (a > b) {\\n            emit log(\\\"Error: a <= b not satisfied [decimal int]\\\");\\n            emit log_named_decimal_int(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_int(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\\n        if (a > b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLeDecimal(a, b, decimals);\\n        }\\n    }\\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\\n        if (a > b) {\\n            emit log(\\\"Error: a <= b not satisfied [decimal uint]\\\");\\n            emit log_named_decimal_uint(\\\"  Value a\\\", a, decimals);\\n            emit log_named_decimal_uint(\\\"  Value b\\\", b, decimals);\\n            fail();\\n        }\\n    }\\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\\n        if (a > b) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertLeDecimal(a, b, decimals);\\n        }\\n    }\\n\\n    function assertEq(string memory a, string memory b) internal {\\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\\n            emit log(\\\"Error: a == b not satisfied [string]\\\");\\n            emit log_named_string(\\\"      Left\\\", a);\\n            emit log_named_string(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertEq(string memory a, string memory b, string memory err) internal {\\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq(a, b);\\n        }\\n    }\\n\\n    function assertNotEq(string memory a, string memory b) internal {\\n        if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {\\n            emit log(\\\"Error: a != b not satisfied [string]\\\");\\n            emit log_named_string(\\\"      Left\\\", a);\\n            emit log_named_string(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertNotEq(string memory a, string memory b, string memory err) internal {\\n        if (keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b))) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertNotEq(a, b);\\n        }\\n    }\\n\\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\\n        ok = true;\\n        if (a.length == b.length) {\\n            for (uint i = 0; i < a.length; i++) {\\n                if (a[i] != b[i]) {\\n                    ok = false;\\n                }\\n            }\\n        } else {\\n            ok = false;\\n        }\\n    }\\n    function assertEq0(bytes memory a, bytes memory b) internal {\\n        if (!checkEq0(a, b)) {\\n            emit log(\\\"Error: a == b not satisfied [bytes]\\\");\\n            emit log_named_bytes(\\\"      Left\\\", a);\\n            emit log_named_bytes(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\\n        if (!checkEq0(a, b)) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertEq0(a, b);\\n        }\\n    }\\n\\n    function assertNotEq0(bytes memory a, bytes memory b) internal {\\n        if (checkEq0(a, b)) {\\n            emit log(\\\"Error: a != b not satisfied [bytes]\\\");\\n            emit log_named_bytes(\\\"      Left\\\", a);\\n            emit log_named_bytes(\\\"     Right\\\", b);\\n            fail();\\n        }\\n    }\\n    function assertNotEq0(bytes memory a, bytes memory b, string memory err) internal {\\n        if (checkEq0(a, b)) {\\n            emit log_named_string(\\\"Error\\\", err);\\n            assertNotEq0(a, b);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/interfaces/IMulticall3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2 <0.9.0;\\n\\npragma experimental ABIEncoderV2;\\n\\ninterface IMulticall3 {\\n    struct Call {\\n        address target;\\n        bytes callData;\\n    }\\n\\n    struct Call3 {\\n        address target;\\n        bool allowFailure;\\n        bytes callData;\\n    }\\n\\n    struct Call3Value {\\n        address target;\\n        bool allowFailure;\\n        uint256 value;\\n        bytes callData;\\n    }\\n\\n    struct Result {\\n        bool success;\\n        bytes returnData;\\n    }\\n\\n    function aggregate(Call[] calldata calls)\\n        external\\n        payable\\n        returns (uint256 blockNumber, bytes[] memory returnData);\\n\\n    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);\\n\\n    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);\\n\\n    function blockAndAggregate(Call[] calldata calls)\\n        external\\n        payable\\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\\n\\n    function getBasefee() external view returns (uint256 basefee);\\n\\n    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);\\n\\n    function getBlockNumber() external view returns (uint256 blockNumber);\\n\\n    function getChainId() external view returns (uint256 chainid);\\n\\n    function getCurrentBlockCoinbase() external view returns (address coinbase);\\n\\n    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);\\n\\n    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);\\n\\n    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);\\n\\n    function getEthBalance(address addr) external view returns (uint256 balance);\\n\\n    function getLastBlockHash() external view returns (bytes32 blockHash);\\n\\n    function tryAggregate(bool requireSuccess, Call[] calldata calls)\\n        external\\n        payable\\n        returns (Result[] memory returnData);\\n\\n    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)\\n        external\\n        payable\\n        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"chainlink-ccip/=lib/chainlink-ccip/src/\",\r\n      \"chainlink/=lib/chainlink/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"scripty.sol/=lib/scripty.sol/contracts/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_destinationChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ccipCall\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"enableToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_destinationChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"estimateFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"linkFeed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"linkToken\",\"type\":\"address\"}],\"internalType\":\"struct BridgeEnvironment\",\"name\":\"_env\",\"type\":\"tuple\"}],\"name\":\"setEnv\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_purse\",\"type\":\"address\"}],\"name\":\"setPurse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Bridge", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b17bd918fb932fb24e3a31d5a3a046e5190a0c6f", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}