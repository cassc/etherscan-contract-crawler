{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/settled-cash/CrossMarginCashLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport {IGrappa} from \\\"grappa/interfaces/IGrappa.sol\\\";\\nimport {IERC20} from \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\nimport {UintArrayLib} from \\\"array-lib/UintArrayLib.sol\\\";\\n\\nimport \\\"grappa/libraries/TokenIdUtil.sol\\\";\\nimport \\\"grappa/libraries/BalanceUtil.sol\\\";\\n\\nimport \\\"../libraries/AccountUtil.sol\\\";\\n\\n// Cross Margin libraries and configs\\nimport {CrossMarginAccount} from \\\"./types.sol\\\";\\nimport \\\"../config/errors.sol\\\";\\n\\n/**\\n * @title CrossMarginCashLib\\n * @dev   This library is in charge of updating the simple account struct and do validations\\n */\\nlibrary CrossMarginCashLib {\\n    using BalanceUtil for Balance[];\\n    using AccountUtil for Position[];\\n    using UintArrayLib for uint256[];\\n    using TokenIdUtil for uint256;\\n\\n    /**\\n     * @dev return true if the account has no short,long positions nor collateral\\n     */\\n    function isEmpty(CrossMarginAccount storage account) external view returns (bool) {\\n        return account.shorts.isEmpty() && account.longs.isEmpty() && account.collaterals.isEmpty();\\n    }\\n\\n    ///@dev Increase the collateral in the account\\n    ///@param account CrossMarginAccount storage that will be updated\\n    function addCollateral(CrossMarginAccount storage account, uint8 collateralId, uint80 amount) public {\\n        if (amount == 0) return;\\n\\n        (bool found, uint256 index) = account.collaterals.indexOf(collateralId);\\n\\n        if (!found) {\\n            account.collaterals.push(Balance(collateralId, amount));\\n        } else {\\n            account.collaterals[index].amount += amount;\\n        }\\n    }\\n\\n    ///@dev Reduce the collateral in the account\\n    ///@param account CrossMarginAccount storage that will be updated\\n    function removeCollateral(CrossMarginAccount storage account, uint8 collateralId, uint80 amount) public {\\n        Balance[] memory collaterals = account.collaterals;\\n\\n        (bool found, uint256 index) = collaterals.indexOf(collateralId);\\n\\n        if (!found) revert CM_WrongCollateralId();\\n\\n        uint80 newAmount = collaterals[index].amount - amount;\\n\\n        if (newAmount == 0) {\\n            account.collaterals.remove(index);\\n        } else {\\n            account.collaterals[index].amount = newAmount;\\n        }\\n    }\\n\\n    ///@dev Increase the amount of short call or put (debt) of the account\\n    ///@param account CrossMarginAccount storage that will be updated\\n    function mintOption(CrossMarginAccount storage account, uint256 tokenId, uint64 amount) external {\\n        if (amount == 0) return;\\n\\n        TokenType optionType = tokenId.parseTokenType();\\n\\n        // engine only supports calls and puts\\n        if (optionType != TokenType.CALL && optionType != TokenType.PUT) revert CM_UnsupportedTokenType();\\n\\n        (bool found, uint256 index) = account.shorts.indexOf(tokenId);\\n        if (!found) {\\n            account.shorts.push(Position(tokenId, amount));\\n        } else {\\n            account.shorts[index].amount += amount;\\n        }\\n    }\\n\\n    ///@dev Remove the amount of short call or put (debt) of the account\\n    ///@param account CrossMarginAccount storage that will be updated in-place\\n    function burnOption(CrossMarginAccount storage account, uint256 tokenId, uint64 amount) external {\\n        (bool found, Position memory position, uint256 index) = account.shorts.find(tokenId);\\n\\n        if (!found) revert CM_InvalidToken();\\n\\n        uint64 newShortAmount = position.amount - amount;\\n        if (newShortAmount == 0) {\\n            account.shorts.removeAt(index);\\n        } else {\\n            account.shorts[index].amount = newShortAmount;\\n        }\\n    }\\n\\n    ///@dev Increase the amount of long call or put (debt) of the account\\n    ///@param account CrossMarginAccount storage that will be updated\\n    function addOption(CrossMarginAccount storage account, uint256 tokenId, uint64 amount) external {\\n        if (amount == 0) return;\\n\\n        (bool found, uint256 index) = account.longs.indexOf(tokenId);\\n\\n        if (!found) {\\n            account.longs.push(Position(tokenId, amount));\\n        } else {\\n            account.longs[index].amount += amount;\\n        }\\n    }\\n\\n    ///@dev Remove the amount of long call or put held by the account\\n    ///@param account CrossMarginAccount storage that will be updated in-place\\n    function removeOption(CrossMarginAccount storage account, uint256 tokenId, uint64 amount) external {\\n        (bool found, Position memory position, uint256 index) = account.longs.find(tokenId);\\n\\n        if (!found) revert CM_InvalidToken();\\n\\n        uint64 newLongAmount = position.amount - amount;\\n        if (newLongAmount == 0) {\\n            account.longs.removeAt(index);\\n        } else {\\n            account.longs[index].amount = newLongAmount;\\n        }\\n    }\\n\\n    ///@dev Settles the accounts longs and shorts\\n    ///@param account CrossMarginAccount storage that will be updated in-place\\n    function settleAtExpiry(CrossMarginAccount storage account, IGrappa grappa)\\n        external\\n        returns (Balance[] memory longPayouts, Balance[] memory shortPayouts)\\n    {\\n        // settling longs first as they can only increase collateral\\n        longPayouts = _settleLongs(grappa, account);\\n        // settling shorts last as they can only reduce collateral\\n        shortPayouts = _settleShorts(grappa, account);\\n    }\\n\\n    ///@dev Settles the accounts longs, adding collateral to balances\\n    ///@param grappa interface to settle long options in a batch call\\n    ///@param account CrossMarginAccount memory that will be updated in-place\\n    function _settleLongs(IGrappa grappa, CrossMarginAccount storage account) public returns (Balance[] memory payouts) {\\n        uint256 i;\\n        uint256[] memory tokenIds;\\n        uint256[] memory amounts;\\n\\n        while (i < account.longs.length) {\\n            uint256 tokenId = account.longs[i].tokenId;\\n\\n            if (tokenId.isExpired()) {\\n                tokenIds = tokenIds.append(tokenId);\\n                amounts = amounts.append(account.longs[i].amount);\\n\\n                account.longs.removeAt(i);\\n            } else {\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n\\n        if (tokenIds.length > 0) {\\n            payouts = grappa.batchSettleOptions(address(this), tokenIds, amounts);\\n\\n            for (i = 0; i < payouts.length;) {\\n                // add the collateral in the account storage.\\n                addCollateral(account, payouts[i].collateralId, payouts[i].amount);\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n    }\\n\\n    ///@dev Settles the accounts shorts, reserving collateral for ITM options\\n    ///@param grappa interface to get short option payouts in a batch call\\n    ///@param account CrossMarginAccount memory that will be updated in-place\\n    function _settleShorts(IGrappa grappa, CrossMarginAccount storage account) public returns (Balance[] memory payouts) {\\n        uint256 i;\\n        uint256[] memory tokenIds;\\n        uint256[] memory amounts;\\n\\n        while (i < account.shorts.length) {\\n            uint256 tokenId = account.shorts[i].tokenId;\\n\\n            if (tokenId.isExpired()) {\\n                tokenIds = tokenIds.append(tokenId);\\n                amounts = amounts.append(account.shorts[i].amount);\\n\\n                account.shorts.removeAt(i);\\n            } else {\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n\\n        if (tokenIds.length > 0) {\\n            payouts = grappa.batchGetPayouts(tokenIds, amounts);\\n\\n            for (i = 0; i < payouts.length;) {\\n                // remove the collateral in the account storage.\\n                removeCollateral(account, payouts[i].collateralId, payouts[i].amount);\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/core-cash/src/interfaces/IGrappa.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../config/types.sol\\\";\\n\\ninterface IGrappa {\\n    function getDetailFromProductId(uint40 _productId)\\n        external\\n        view\\n        returns (\\n            address oracle,\\n            address engine,\\n            address underlying,\\n            uint8 underlyingDecimals,\\n            address strike,\\n            uint8 strikeDecimals,\\n            address collateral,\\n            uint8 collateralDecimals\\n        );\\n\\n    function checkEngineAccess(uint256 _tokenId, address _engine) external view;\\n\\n    function checkEngineAccessAndTokenId(uint256 _tokenId, address _engine) external view;\\n\\n    function engineIds(address _engine) external view returns (uint8 id);\\n\\n    function assetIds(address _asset) external view returns (uint8 id);\\n\\n    function assets(uint8 _id) external view returns (address addr, uint8 decimals);\\n\\n    function engines(uint8 _id) external view returns (address engine);\\n\\n    function oracles(uint8 _id) external view returns (address oracle);\\n\\n    function getPayout(uint256 tokenId, uint64 amount)\\n        external\\n        view\\n        returns (address engine, address collateral, uint256 payout);\\n\\n    function getProductId(address oracle, address engine, address underlying, address strike, address collateral)\\n        external\\n        view\\n        returns (uint40 id);\\n\\n    function getTokenId(TokenType tokenType, uint40 productId, uint256 expiry, uint256 longStrike, uint256 shortStrike)\\n        external\\n        view\\n        returns (uint256 id);\\n\\n    /**\\n     * @notice burn option token and get out cash value at expiry\\n     * @param _account who to settle for\\n     * @param _tokenId  tokenId of option token to burn\\n     * @param _amount   amount to settle\\n     * @return payout amount paid out\\n     */\\n    function settleOption(address _account, uint256 _tokenId, uint256 _amount) external returns (uint256 payout);\\n\\n    /**\\n     * @notice burn array of option tokens and get out cash value at expiry\\n     * @param _account who to settle for\\n     * @param _tokenIds array of tokenIds to burn\\n     * @param _amounts   array of amounts to burn\\n     */\\n    function batchSettleOptions(address _account, uint256[] memory _tokenIds, uint256[] memory _amounts)\\n        external\\n        returns (Balance[] memory payouts);\\n\\n    function batchGetPayouts(uint256[] memory _tokenIds, uint256[] memory _amounts) external returns (Balance[] memory payouts);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/array-lib/src/UintArrayLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {SafeCast} from \\\"openzeppelin/utils/math/SafeCast.sol\\\";\\n\\nlibrary UintArrayLib {\\n    using SafeCast for uint256;\\n\\n    error IntegerOverflow();\\n\\n    /**\\n     * @dev Returns maximal element in array\\n     */\\n    function max(uint256[] memory x) internal pure returns (uint256 m) {\\n        m = x[0];\\n        for (uint256 i; i < x.length;) {\\n            if (x[i] > m) {\\n                m = x[i];\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns minimum element in array\\n     */\\n    function min(uint256[] memory x) internal pure returns (uint256 m) {\\n        m = x[0];\\n        for (uint256 i = 1; i < x.length;) {\\n            if (x[i] < m) {\\n                m = x[i];\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev return the min and max for an array.\\n     */\\n    function minMax(uint256[] memory x) internal pure returns (uint256 min_, uint256 max_) {\\n        if (x.length == 1) return (x[0], x[0]);\\n        (min_, max_) = (x[0], x[0]);\\n\\n        for (uint256 i = 1; i < x.length;) {\\n            if (x[i] < min_) {\\n                min_ = x[i];\\n            } else if (x[i] > max_) {\\n                max_ = x[i];\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev return a new array that append element v at the end of array x\\n     */\\n    function append(uint256[] memory x, uint256 v) internal pure returns (uint256[] memory y) {\\n        y = new uint256[](x.length + 1);\\n        uint256 i;\\n        for (i; i < x.length;) {\\n            y[i] = x[i];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        y[i] = v;\\n    }\\n\\n    /**\\n     * @dev Return a new array that removes element at index z.\\n     * @return y new array\\n     */\\n    function remove(uint256[] memory x, uint256 z) internal pure returns (uint256[] memory y) {\\n        if (z >= x.length) return x;\\n        y = new uint256[](x.length - 1);\\n        for (uint256 i; i < x.length;) {\\n            unchecked {\\n                if (i < z) y[i] = x[i];\\n                else if (i > z) y[i - 1] = x[i];\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Return index of the first element in array x with value v\\n     * @return found set to true if found\\n     * @return i index in the array\\n     */\\n    function indexOf(uint256[] memory x, uint256 v) internal pure returns (bool, uint256) {\\n        for (uint256 i; i < x.length;) {\\n            if (x[i] == v) {\\n                return (true, i);\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return (false, 0);\\n    }\\n\\n    /**\\n     * @dev Compute sum of all elements\\n     * @return s sum\\n     */\\n    function sum(uint256[] memory x) internal pure returns (uint256 s) {\\n        require(x.length != 0);\\n        // Variable to implement the overflow logic\\n        uint256 j;\\n        assembly {\\n            // The Memory layout of input array looks like this\\n            // It has Consequent slots of 32 bytes each\\n            // {length of array}{x[0]}{x[1]}{x[2]}....\\n\\n            //Cache the pointer to end of the array to be used in for loop\\n            //First param to add() is a memory pointer to start of the first element slot\\n            //Second param to add() is a memory pointer to end of the last element slot\\n            let end := add(add(x, 0x20), shl(5, mload(x)))\\n\\n            // iszero(eq()) is cheaper than lt(i,n)\\n            // We increment i by 32 bytes\\n            for { let i := add(x, 0x20) } iszero(eq(i, end)) { i := add(i, 0x20) } {\\n                j := s\\n                s := add(s, mload(i))\\n                if lt(s, j) {\\n                    // Storing the 4byte selector of error IntegerOverflow()\\n                    // mstore()\\n                    mstore(0x00, 0xa5bd5d7f)\\n                    // revert(memory offset,size of return data)\\n                    // revert(28,4)\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev return a new array that's the result of concatting a and b\\n     */\\n    function concat(uint256[] memory a, uint256[] memory b) internal pure returns (uint256[] memory y) {\\n        y = new uint256[](a.length + b.length);\\n        uint256 v;\\n        uint256 i;\\n        for (i; i < a.length;) {\\n            y[v] = a[i];\\n\\n            unchecked {\\n                ++i;\\n                ++v;\\n            }\\n        }\\n        for (i = 0; i < b.length;) {\\n            y[v] = b[i];\\n\\n            unchecked {\\n                ++i;\\n                ++v;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Populates array a with values from b\\n     * @dev modifies array a in place.\\n     */\\n    function populate(uint256[] memory a, uint256[] memory b) internal pure {\\n        for (uint256 i; i < a.length;) {\\n            a[i] = b[i];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev return the element at index i\\n     *      if i is positive, it's the same as requesting x[i]\\n     *      if i is negative, return the value positioned at -i from the end\\n     * @param i can be positive or negative\\n     */\\n    function at(uint256[] memory x, int256 i) internal pure returns (uint256) {\\n        if (i >= 0) {\\n            // will revert with out of bound error if i is too large\\n            return x[uint256(i)];\\n        } else {\\n            // will revert with underflow error if i is too small\\n            return x[x.length - uint256(-i)];\\n        }\\n    }\\n\\n    /**\\n     * @dev return a new array y with y[i] = z - x[i]\\n     */\\n    function subEachFrom(uint256[] memory x, uint256 z) internal pure returns (int256[] memory y) {\\n        y = new int256[](x.length);\\n        int256 intZ = z.toInt256();\\n        for (uint256 i; i < x.length;) {\\n            y[i] = intZ - x[i].toInt256();\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev return a new array y with y[i] = x[i] - z\\n     */\\n    function subEachBy(uint256[] memory x, uint256 z) internal pure returns (int256[] memory y) {\\n        y = new int256[](x.length);\\n        int256 intZ = z.toInt256();\\n        for (uint256 i; i < x.length;) {\\n            y[i] = x[i].toInt256() - intZ;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev return dot of 2 vectors\\n     *      will revert if 2 vectors has different length\\n     * @param a uint256 array\\n     * @param b uint256 array\\n     */\\n    function dot(uint256[] memory a, uint256[] memory b) internal pure returns (uint256 s) {\\n        for (uint256 i; i < a.length;) {\\n            s += a[i] * b[i];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev return dot of 2 vectors\\n     *      will revert if 2 vectors has different length\\n     * @param a uint256 array\\n     * @param b int256 array\\n     */\\n    function dot(uint256[] memory a, int256[] memory b) internal pure returns (int256 s) {\\n        for (uint256 i; i < a.length;) {\\n            s += int256(a[i]) * b[i];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/core-cash/src/libraries/TokenIdUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// solhint-disable max-line-length\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../config/enums.sol\\\";\\nimport \\\"../config/errors.sol\\\";\\n\\n/**\\n * Token ID =\\n *\\n *  * ------------------- | ------------------- | ---------------- | -------------------- | --------------------- *\\n *  | tokenType (24 bits) | productId (40 bits) | expiry (64 bits) | longStrike (64 bits) | reserved    (64 bits) |\\n *  * ------------------- | ------------------- | ---------------- | -------------------- | --------------------- *\\n */\\n\\nlibrary TokenIdUtil {\\n    /**\\n     * @notice calculate ERC1155 token id for given option parameters. See table above for tokenId\\n     * @param tokenType TokenType enum\\n     * @param productId if of the product\\n     * @param expiry timestamp of option expiry\\n     * @param longStrike strike price of the long option, with 6 decimals\\n     * @param reserved strike price of the short (upper bond for call and lower bond for put) if this is a spread. 6 decimals\\n     * @return tokenId token id\\n     */\\n    function getTokenId(TokenType tokenType, uint40 productId, uint64 expiry, uint64 longStrike, uint64 reserved)\\n        internal\\n        pure\\n        returns (uint256 tokenId)\\n    {\\n        unchecked {\\n            tokenId = (uint256(tokenType) << 232) + (uint256(productId) << 192) + (uint256(expiry) << 128)\\n                + (uint256(longStrike) << 64) + uint256(reserved);\\n        }\\n    }\\n\\n    /**\\n     * @notice derive option, product, expiry and strike price from ERC1155 token id\\n     * @dev    See table above for tokenId composition\\n     * @param tokenId token id\\n     * @return tokenType TokenType enum\\n     * @return productId 32 bits product id\\n     * @return expiry timestamp of option expiry\\n     * @return longStrike strike price of the long option, with 6 decimals\\n     * @return reserved strike price of the short (upper bond for call and lower bond for put) if this is a spread. 6 decimals\\n     */\\n    function parseTokenId(uint256 tokenId)\\n        internal\\n        pure\\n        returns (TokenType tokenType, uint40 productId, uint64 expiry, uint64 longStrike, uint64 reserved)\\n    {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            tokenType := shr(232, tokenId)\\n            productId := shr(192, tokenId)\\n            expiry := shr(128, tokenId)\\n            longStrike := shr(64, tokenId)\\n            reserved := tokenId\\n        }\\n    }\\n\\n    /**\\n     * @notice parse collateral id from tokenId\\n     * @dev more efficient than parsing tokenId and than parse productId\\n     * @param tokenId token id\\n     * @return collateralId\\n     */\\n    function parseCollateralId(uint256 tokenId) internal pure returns (uint8 collateralId) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // collateralId is the last bits of productId\\n            collateralId := shr(192, tokenId)\\n        }\\n    }\\n\\n    /**\\n     * @notice parse engine id from tokenId\\n     * @dev more efficient than parsing tokenId and than parse productId\\n     * @param tokenId token id\\n     * @return engineId\\n     */\\n    function parseEngineId(uint256 tokenId) internal pure returns (uint8 engineId) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // collateralId is the last bits of productId\\n            engineId := shr(216, tokenId) // 192 to get product id, another 24 to get engineId\\n        }\\n    }\\n\\n    /**\\n     * @notice derive option type from ERC1155 token id\\n     * @param tokenId token id\\n     * @return tokenType TokenType enum\\n     */\\n    function parseTokenType(uint256 tokenId) internal pure returns (TokenType tokenType) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            tokenType := shr(232, tokenId)\\n        }\\n    }\\n\\n    /**\\n     * @notice derive if option is expired from ERC1155 token id\\n     * @param tokenId token id\\n     * @return expired bool\\n     */\\n    function isExpired(uint256 tokenId) internal view returns (bool expired) {\\n        uint64 expiry;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            expiry := shr(128, tokenId)\\n        }\\n\\n        expired = block.timestamp >= expiry;\\n    }\\n\\n    /**\\n     * @notice convert an spread tokenId back to put or call.\\n     *                  * ------------------- | ------------------- | ---------------- | -------------------- | --------------------- *\\n     * @dev   oldId =   | spread type (24 b)  | productId (40 bits) | expiry (64 bits) | longStrike (64 bits) | shortStrike (64 bits) |\\n     *                  * ------------------- | ------------------- | ---------------- | -------------------- | --------------------- *\\n     *                  * ------------------- | ------------------- | ---------------- | -------------------- | --------------------- *\\n     * @dev   newId =   | call or put type    | productId (40 bits) | expiry (64 bits) | longStrike (64 bits) | 0           (64 bits) |\\n     *                  * ------------------- | ------------------- | ---------------- | -------------------- | --------------------- *\\n     * @dev   this function will: override tokenType, remove shortStrike.\\n     * @param _tokenId token id to change\\n     */\\n    function convertToVanillaId(uint256 _tokenId) internal pure returns (uint256 newId) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            newId := shr(64, _tokenId) // step 1: >> 64 to wipe out shortStrike\\n            newId := shl(64, newId) // step 2: << 64 go back\\n\\n            newId := sub(newId, shl(232, 1)) // step 3: new tokenType = spread type - 1\\n        }\\n    }\\n\\n    /**\\n     * @notice convert an spread tokenId back to put or call.\\n     *                  * ------------------- | ------------------- | ---------------- | -------------------- | --------------------- *\\n     * @dev   oldId =   | call or put type    | productId (40 bits) | expiry (64 bits) | longStrike (64 bits) | 0           (64 bits) |\\n     *                  * ------------------- | ------------------- | ---------------- | -------------------- | --------------------- *\\n     *                  * ------------------- | ------------------- | ---------------- | -------------------- | --------------------- *\\n     * @dev   newId =   | spread type         | productId (40 bits) | expiry (64 bits) | longStrike (64 bits) | shortStrike (64 bits) |\\n     *                  * ------------------- | ------------------- | ---------------- | -------------------- | --------------------- *\\n     *\\n     * this function convert put or call type to spread type, add shortStrike.\\n     * @param _tokenId token id to change\\n     * @param _shortStrike strike to add\\n     */\\n    function convertToSpreadId(uint256 _tokenId, uint256 _shortStrike) internal pure returns (uint256 newId) {\\n        // solhint-disable-next-line no-inline-assembly\\n        unchecked {\\n            newId = _tokenId + _shortStrike;\\n            return newId + (1 << 232); // new type (spread type) = old type + 1\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/core-cash/src/libraries/BalanceUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Balance} from \\\"../config/types.sol\\\";\\n\\n/**\\n * Operations on Balance struct\\n */\\nlibrary BalanceUtil {\\n    /**\\n     * @dev create a new Balance array with 1 more element\\n     * @param x balance array\\n     * @param v new value to add\\n     * @return y new balance array\\n     */\\n    function append(Balance[] memory x, Balance memory v) internal pure returns (Balance[] memory y) {\\n        y = new Balance[](x.length + 1);\\n        uint256 i;\\n        for (i; i < x.length;) {\\n            y[i] = x[i];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        y[i] = v;\\n    }\\n\\n    /**\\n     * @dev check if a balance object for collateral id already exists\\n     * @param x balance array\\n     * @param v collateral id to search\\n     * @return f true if found\\n     * @return b Balance object\\n     * @return i index of the found entry\\n     */\\n    function find(Balance[] memory x, uint8 v) internal pure returns (bool f, Balance memory b, uint256 i) {\\n        for (i; i < x.length;) {\\n            if (x[i].collateralId == v) {\\n                b = x[i];\\n                f = true;\\n                break;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev return the index of an element balance array\\n     * @param x balance array\\n     * @param v collateral id to search\\n     * @return f true if found\\n     * @return i index of the found entry\\n     */\\n    function indexOf(Balance[] memory x, uint8 v) internal pure returns (bool f, uint256 i) {\\n        for (i; i < x.length;) {\\n            if (x[i].collateralId == v) {\\n                f = true;\\n                break;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev remove index y from balance array\\n     * @param x balance array\\n     * @param i index to remove\\n     */\\n    function remove(Balance[] storage x, uint256 i) internal {\\n        if (i >= x.length) return;\\n        x[i] = x[x.length - 1];\\n        x.pop();\\n    }\\n\\n    /**\\n     * @dev checks if balances are empty\\n     */\\n    function isEmpty(Balance[] memory x) internal pure returns (bool e) {\\n        e = true;\\n        for (uint256 i; i < x.length;) {\\n            if (x[i].amount > 0) {\\n                e = false;\\n                break;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/AccountUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// cross margin types\\nimport {CrossMarginDetail, Position} from \\\"../config/types.sol\\\";\\n\\nlibrary AccountUtil {\\n    function append(CrossMarginDetail[] memory x, CrossMarginDetail memory v)\\n        internal\\n        pure\\n        returns (CrossMarginDetail[] memory y)\\n    {\\n        y = new CrossMarginDetail[](x.length + 1);\\n        uint256 i;\\n        for (i; i < x.length;) {\\n            y[i] = x[i];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        y[i] = v;\\n    }\\n\\n    function append(Position[] memory x, Position memory v) internal pure returns (Position[] memory y) {\\n        y = new Position[](x.length + 1);\\n        uint256 i;\\n        for (i; i < x.length;) {\\n            y[i] = x[i];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        y[i] = v;\\n    }\\n\\n    function concat(Position[] memory a, Position[] memory b) internal pure returns (Position[] memory y) {\\n        y = new Position[](a.length + b.length);\\n        uint256 v;\\n        uint256 i;\\n        for (i; i < a.length;) {\\n            y[v] = a[i];\\n            unchecked {\\n                ++i;\\n                ++v;\\n            }\\n        }\\n        for (i = 0; i < b.length;) {\\n            y[v] = b[i];\\n            unchecked {\\n                ++i;\\n                ++v;\\n            }\\n        }\\n    }\\n\\n    function find(Position[] memory x, uint256 v) internal pure returns (bool f, Position memory p, uint256 i) {\\n        for (i; i < x.length;) {\\n            if (x[i].tokenId == v) {\\n                p = x[i];\\n                f = true;\\n                break;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function indexOf(Position[] memory x, uint256 v) internal pure returns (bool f, uint256 i) {\\n        for (i; i < x.length;) {\\n            if (x[i].tokenId == v) {\\n                f = true;\\n                break;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function isEmpty(Position[] memory x) internal pure returns (bool e) {\\n        e = true;\\n        for (uint256 i; i < x.length;) {\\n            if (x[i].amount > 0) {\\n                e = false;\\n                break;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function removeAt(Position[] storage x, uint256 y) internal {\\n        if (y >= x.length) return;\\n        x[y] = x[x.length - 1];\\n        x.pop();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/settled-cash/types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../config/types.sol\\\";\\nimport {Balance} from \\\"grappa/config/types.sol\\\";\\n\\n/**\\n * @dev base unit of cross margin account. This is the data stored in the state\\n *      storage packing is utilized to save gas.\\n * @param shorts an array of short positions\\n * @param longs an array of long positions\\n * @param collaterals an array of collateral balances\\n */\\nstruct CrossMarginAccount {\\n    Position[] shorts;\\n    Position[] longs;\\n    Balance[] collaterals;\\n}\\n\"\r\n    },\r\n    \"src/config/errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/* --------------------- *\\n *  Cross Margin Errors\\n * --------------------- */\\n\\n/// @dev cross margin doesn't support this action\\nerror CM_UnsupportedAction();\\n\\n/// @dev cannot override a non-empty subaccount id\\nerror CM_AccountIsNotEmpty();\\n\\n/// @dev unsupported token type\\nerror CM_UnsupportedTokenType();\\n\\n/// @dev can only add long tokens that are not expired\\nerror CM_Token_Expired();\\n\\n/// @dev can only add long tokens from authorized engines\\nerror CM_Not_Authorized_Engine();\\n\\n/// @dev collateral id is wrong: the id doesn't match the existing collateral\\nerror CM_WrongCollateralId();\\n\\n/// @dev invalid collateral:\\nerror CM_CannotMintOptionWithThisCollateral();\\n\\n/// @dev invalid tokenId specify to mint / burn actions\\nerror CM_InvalidToken();\\n\\n//// @dev invalid signed message\\nerror CM_InvalidSignature();\\n\\n/* -------------------------- *\\n *  Cross Margin Math Errors\\n * -------------------------- */\\n\\n/// @dev invalid put length given strikes\\nerror CMM_InvalidPutLengths();\\n\\n/// @dev invalid call length given strikes\\nerror CMM_InvalidCallLengths();\\n\\n/// @dev invalid put length of zero\\nerror CMM_InvalidPutWeight();\\n\\n/// @dev invalid call length of zero\\nerror CMM_InvalidCallWeight();\\n\\n/* ------------------------ *\\n *  Cross Margin Lib Errors\\n * ------------------------ */\\n\\n/// @dev token not yet expired\\nerror CML_NotExpired();\\n\\nerror CML_ExceedsAmount();\\n\"\r\n    },\r\n    \"lib/core-cash/src/config/types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./enums.sol\\\";\\n\\n/**\\n * @dev struct representing the current balance for a given collateral\\n * @param collateralId grappa asset id\\n * @param amount amount the asset\\n */\\nstruct Balance {\\n    uint8 collateralId;\\n    uint80 amount;\\n}\\n\\n/**\\n * @dev struct containing assets detail for an product\\n * @param underlying    underlying address\\n * @param strike        strike address\\n * @param collateral    collateral address\\n * @param collateralDecimals collateral asset decimals\\n */\\nstruct ProductDetails {\\n    address oracle;\\n    uint8 oracleId;\\n    address engine;\\n    uint8 engineId;\\n    address underlying;\\n    uint8 underlyingId;\\n    uint8 underlyingDecimals;\\n    address strike;\\n    uint8 strikeId;\\n    uint8 strikeDecimals;\\n    address collateral;\\n    uint8 collateralId;\\n    uint8 collateralDecimals;\\n}\\n\\n// todo: update doc\\nstruct ActionArgs {\\n    ActionType action;\\n    bytes data;\\n}\\n\\nstruct BatchExecute {\\n    address subAccount;\\n    ActionArgs[] actions;\\n}\\n\\n/**\\n * @dev asset detail stored per asset id\\n * @param addr address of the asset\\n * @param decimals token decimals\\n */\\nstruct AssetDetail {\\n    address addr;\\n    uint8 decimals;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/core-cash/src/config/enums.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nenum TokenType {\\n    PUT,\\n    PUT_SPREAD,\\n    CALL,\\n    CALL_SPREAD\\n}\\n\\n/**\\n * @dev common action types on margin engines\\n */\\nenum ActionType {\\n    AddCollateral,\\n    RemoveCollateral,\\n    MintShort,\\n    BurnShort,\\n    MergeOptionToken, // These actions are defined in \\\"DebitSpread\\\"\\n    SplitOptionToken, // These actions are defined in \\\"DebitSpread\\\"\\n    AddLong,\\n    RemoveLong,\\n    SettleAccount,\\n    // actions that influence more than one subAccounts:\\n    // These actions are defined in \\\"OptionTransferable\\\"\\n    MintShortIntoAccount, // increase short (debt) position in one subAccount, increase long token directly to another subAccount\\n    TransferCollateral, // transfer collateral directly to another subAccount\\n    TransferLong, // transfer long directly to another subAccount\\n    TransferShort, // transfer short directly to another subAccount\\n    BurnShortInAccount // decreases short position in one subAccount, decreases long position in another\\n}\\n\"\r\n    },\r\n    \"lib/core-cash/src/config/errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// for easier import\\nimport \\\"../core/oracles/errors.sol\\\";\\n\\n/* ------------------------ *\\n *      Shared Errors       *\\n * -----------------------  */\\n\\nerror NoAccess();\\n\\n/* ------------------------ *\\n *      Grappa Errors       *\\n * -----------------------  */\\n\\n/// @dev asset already registered\\nerror GP_AssetAlreadyRegistered();\\n\\n/// @dev margin engine already registered\\nerror GP_EngineAlreadyRegistered();\\n\\n/// @dev oracle already registered\\nerror GP_OracleAlreadyRegistered();\\n\\n/// @dev registring oracle doesn't comply with the max dispute period constraint.\\nerror GP_BadOracle();\\n\\n/// @dev amounts length speicified to batch settle doesn't match with tokenIds\\nerror GP_WrongArgumentLength();\\n\\n/// @dev cannot settle an unexpired option\\nerror GP_NotExpired();\\n\\n/// @dev settlement price is not finalized yet\\nerror GP_PriceNotFinalized();\\n\\n/// @dev cannot mint token after expiry\\nerror GP_InvalidExpiry();\\n\\n/// @dev put and call should not contain \\\"short stirkes\\\"\\nerror GP_BadStrikes();\\n\\n/// @dev burn or mint can only be called by corresponding engine.\\nerror GP_Not_Authorized_Engine();\\n\\n/* ---------------------------- *\\n *   Common BaseEngine Errors   *\\n * ---------------------------  */\\n\\n/// @dev can only merge subaccount with put or call.\\nerror BM_CannotMergeSpread();\\n\\n/// @dev only spread position can be split\\nerror BM_CanOnlySplitSpread();\\n\\n/// @dev type of existing short token doesn't match the incoming token\\nerror BM_MergeTypeMismatch();\\n\\n/// @dev product type of existing short token doesn't match the incoming token\\nerror BM_MergeProductMismatch();\\n\\n/// @dev expiry of existing short token doesn't match the incoming token\\nerror BM_MergeExpiryMismatch();\\n\\n/// @dev cannot merge type with the same strike. (should use burn instead)\\nerror BM_MergeWithSameStrike();\\n\\n/// @dev account is not healthy / account is underwater\\nerror BM_AccountUnderwater();\\n\\n/// @dev msg.sender is not authorized to ask margin account to pull token from {from} address\\nerror BM_InvalidFromAddress();\\n\"\r\n    },\r\n    \"src/config/types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev struct used in memory to represent a cross margin account's option set\\n *      this is a grouping of like underlying, collateral, strike (asset), and expiry\\n *      used to calculate margin requirements\\n * @param putWeights            amount of put options held in account (shorts and longs)\\n * @param putStrikes            strikes of put options held in account (shorts and longs)\\n * @param callWeights           amount of call options held in account (shorts and longs)\\n * @param callStrikes           strikes of call options held in account (shorts and longs)\\n * @param underlyingId          pomace id for underlying asset\\n * @param underlyingDecimals    decimal points of underlying asset\\n * @param numeraireId           pomace id for numeraire (aka strike) asset\\n * @param numeraireDecimals     decimal points of numeraire (aka strike) asset\\n * @param expiry                expiry of the option\\n */\\nstruct CrossMarginDetail {\\n    int256[] putWeights;\\n    uint256[] putStrikes;\\n    int256[] callWeights;\\n    uint256[] callStrikes;\\n    uint8 underlyingId;\\n    uint8 underlyingDecimals;\\n    uint8 numeraireId;\\n    uint8 numeraireDecimals;\\n    uint256 expiry;\\n}\\n\\n/**\\n * @dev an uncompressed Position struct, expanding tokenId to uint256\\n * @param tokenId pomace option token id\\n * @param amount number option tokens\\n */\\nstruct Position {\\n    uint256 tokenId;\\n    uint64 amount;\\n}\\n\\nstruct SettlementTracker {\\n    uint64 issued;\\n    uint80 totalDebt;\\n    uint80 totalPaid;\\n}\\n\"\r\n    },\r\n    \"lib/core-cash/src/core/oracles/errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nerror OC_CannotReportForFuture();\\n\\nerror OC_PriceNotReported();\\n\\nerror OC_PriceReported();\\n\\n///@dev cannot dispute the settlement price after dispute period is over\\nerror OC_DisputePeriodOver();\\n\\n///@dev cannot force-set an settlement price until grace period is passed and no one has set the price.\\nerror OC_GracePeriodNotOver();\\n\\n///@dev already disputed\\nerror OC_PriceDisputed();\\n\\n///@dev owner trying to set a dispute period that is invalid\\nerror OC_InvalidDisputePeriod();\\n\\n// Chainlink oracle\\n\\nerror CL_AggregatorNotSet();\\n\\nerror CL_StaleAnswer();\\n\\nerror CL_RoundIdTooSmall();\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"array-lib/=lib/array-lib/src/\",\r\n      \"core-cash/=lib/core-cash/\",\r\n      \"core-physical/=lib/core-physical/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"grappa-test/=lib/core-cash/test/\",\r\n      \"grappa/=lib/core-cash/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"pomace-test/=lib/core-physical/test/\",\r\n      \"pomace/=lib/core-physical/src/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {\r\n      \"src/settled-cash/CrossMarginCashLib.sol\": {\r\n        \"CrossMarginCashLib\": \"0xe3db03a6a579b259061830746a6f2ac16f37f9c4\"\r\n      },\r\n      \"src/settled-cash/CrossMarginCashMath.sol\": {\r\n        \"CrossMarginCashMath\": \"0xeff65967227f0b84ea115bdb8be1d166c3f371d0\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"CM_InvalidToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CM_UnsupportedTokenType\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CM_WrongCollateralId\",\"type\":\"error\"}]", "ContractName": "CrossMarginCashLib", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}