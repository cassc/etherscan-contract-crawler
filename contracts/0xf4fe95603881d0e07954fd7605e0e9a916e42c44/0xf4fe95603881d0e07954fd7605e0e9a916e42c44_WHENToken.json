{"SourceCode": "pragma solidity ^0.4.18;\r\n\r\n/************************************************** */\r\n/* WhenHub Token Smart Contract                     */\r\n/* Author: Nik Kalyani  nik@whenhub.com             */\r\n/* Copyright (c) 2018 CalendarTree, Inc.            */\r\n/* https://interface.whenhub.com                    */\r\n/************************************************** */\r\ncontract WHENToken {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) balances;                               // Token balance for each address\r\n    mapping (address => mapping (address => uint256)) internal allowed; // Approval granted to transfer tokens by one address to another address\r\n\r\n    /* ERC20 fields */\r\n    string public name;\r\n    string public symbol;\r\n    uint public decimals = 18;\r\n    string public sign = \"\uffe6\";\r\n    string public logoPng = \"https://github.com/WhenHub/WHEN/raw/master/assets/when-token-icon.png\";\r\n\r\n\r\n    /* Each registered user on WhenHub Interface Network has a record in this contract */\r\n    struct User {\r\n        bool isRegistered;                                              // Flag to indicate user was registered \r\n        uint256 seedJiffys;                                             // Tracks free tokens granted to user       \r\n        uint256 interfaceEscrowJiffys;                                  // Tracks escrow tokens used in Interfaces      \r\n        address referrer;                                               // Tracks who referred this user\r\n    }\r\n \r\n    // IcoBurnAuthorized is used to determine when remaining ICO tokens should be burned\r\n    struct IcoBurnAuthorized {\r\n        bool contractOwner;                                              // Flag to indicate ContractOwner has authorized\r\n        bool platformManager;                                            // Flag to indicate PlatformManager has authorized\r\n        bool icoOwner;                                                   // Flag to indicate SupportManager has authorized\r\n    }\r\n\r\n    // PurchaseCredit is used to track purchases made by USD when user isn't already registered\r\n    struct PurchaseCredit {\r\n        uint256 jiffys;                                                  // Number of jiffys purchased\r\n        uint256 purchaseTimestamp;                                       // Date/time of original purchase\r\n    }\r\n\r\n    mapping(address => PurchaseCredit) purchaseCredits;                  // Temporary store for USD-purchased tokens\r\n\r\n    uint private constant ONE_WEEK = 604800;\r\n    uint private constant SECONDS_IN_MONTH = 2629743;\r\n    uint256 private constant ICO_START_TIMESTAMP = 1521471600; // 3/19/2018 08:00:00 PDT\r\n\r\n    uint private constant BASIS_POINTS_TO_PERCENTAGE = 10000;                         // All fees are expressed in basis points. This makes conversion easier\r\n\r\n    /* Token allocations per published WhenHub token economics */\r\n    uint private constant ICO_TOKENS = 350000000;                              // Tokens available for public purchase\r\n    uint private constant PLATFORM_TOKENS = 227500000;                         // Tokens available for network seeding\r\n    uint private constant COMPANY_TOKENS = 262500000;                          // Tokens available to WhenHub for employees and future expansion\r\n    uint private constant PARTNER_TOKENS = 17500000;                           // Tokens available for WhenHub partner inventives\r\n    uint private constant FOUNDATION_TOKENS = 17500000;                        // Tokens available for WhenHub Foundationn charity\r\n\r\n    /* Network seeding tokens */\r\n    uint constant INCENTIVE_TOKENS = 150000000;                         // Total pool of seed tokens for incentives\r\n    uint constant REFERRAL_TOKENS = 77500000;                           // Total pool of seed tokens for referral\r\n    uint256 private userSignupJiffys = 0;                                // Number of Jiffys per user who signs up\r\n    uint256 private referralSignupJiffys = 0;                            // Number of Jiffys per user(x2) referrer + referree\r\n   \r\n    uint256 private jiffysMultiplier;                                   // 10 ** decimals\r\n    uint256 private incentiveJiffysBalance;                             // Available balance of Jiffys for incentives\r\n    uint256 private referralJiffysBalance;                              // Available balance of Jiffys for referrals\r\n\r\n    /* ICO variables */\r\n    uint256 private bonus20EndTimestamp = 0;                             // End of 20% ICO token bonus timestamp\r\n    uint256 private bonus10EndTimestamp = 0;                             // End of 10% ICO token bonus timestamp\r\n    uint256 private bonus5EndTimestamp = 0;                              // End of 5% ICO token bonus timestamp\r\n    uint private constant BUYER_REFERRER_BOUNTY = 3;                     // Referral bounty percentage\r\n\r\n    IcoBurnAuthorized icoBurnAuthorized = IcoBurnAuthorized(false, false, false);\r\n\r\n    /* Interface transaction settings */\r\n    bool private operational = true;                                    // Blocks all state changes throughout the contract if false\r\n                                                                        // Change using setOperatingStatus()\r\n\r\n    uint256 public winNetworkFeeBasisPoints = 0;                       // Per transaction fee deducted from payment to Expert\r\n                                                                        // Change using setWinNetworkFeeBasisPoints()\r\n\r\n    uint256 public weiExchangeRate = 500000000000000;                  // Exchange rate for 1 WHEN Token in Wei ($0.25/\uffe6)\r\n                                                                        // Change using setWeiExchangeRate()\r\n\r\n    uint256 public centsExchangeRate = 25;                             // Exchange rate for 1 WHEN Token in cents\r\n                                                                        // Change using setCentsExchangeRate()\r\n\r\n    /* State variables */\r\n    address private contractOwner;                                      // Account used to deploy contract\r\n    address private platformManager;                                    // Account used by API for Interface app\r\n    address private icoOwner;                                           // Account from which ICO funds are disbursed\r\n    address private supportManager;                                     // Account used by support team to reimburse users\r\n    address private icoWallet;                                          // Account to which ICO ETH is sent\r\n\r\n    mapping(address => User) private users;                             // All registered users   \r\n    mapping(address => uint256) private vestingEscrows;                 // Unvested tokens held in escrow\r\n\r\n    mapping(address => uint256) private authorizedContracts;            // Contracts authorized to call this one           \r\n\r\n    address[] private registeredUserLookup;                             // Lookup table of registered users     \r\n\r\n    /* ERC-20 Contract Events */\r\n    event Approval          // Fired when an account authorizes another account to spend tokens on its behalf\r\n                            (\r\n                                address indexed owner, \r\n                                address indexed spender, \r\n                                uint256 value\r\n                            );\r\n\r\n    event Transfer          // Fired when tokens are transferred from one account to another\r\n                            (\r\n                                address indexed from, \r\n                                address indexed to, \r\n                                uint256 value\r\n                            );\r\n\r\n\r\n    /* Interface app-specific Events */\r\n    event UserRegister      // Fired when a new user account (wallet) is registered\r\n                            (\r\n                                address indexed user, \r\n                                uint256 value,\r\n                                uint256 seedJiffys\r\n                            );                                 \r\n\r\n    event UserRefer         // Fired when tokens are granted to a user for referring a new user\r\n                            (\r\n                                address indexed user, \r\n                                address indexed referrer, \r\n                                uint256 value\r\n                            );                             \r\n\r\n    event UserLink          // Fired when a previously existing user is linked to an account in the Interface DB\r\n                            (\r\n                                address indexed user\r\n                            );\r\n\r\n\r\n    /**\r\n    * @dev Modifier that requires the \"operational\" boolean variable to be \"true\"\r\n    *      This is used on all state changing functions to pause the contract in \r\n    *      the event there is an issue that needs to be fixed\r\n    */\r\n    modifier requireIsOperational() \r\n    {\r\n        require(operational);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier that requires the \"ContractOwner\" account to be the function caller\r\n    */\r\n    modifier requireContractOwner()\r\n    {\r\n        require(msg.sender == contractOwner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier that requires the \"PlatformManager\" account to be the function caller\r\n    */\r\n    modifier requirePlatformManager()\r\n    {\r\n        require(isPlatformManager(msg.sender));\r\n        _;\r\n    }\r\n\r\n\r\n    /********************************************************************************************/\r\n    /*                                       CONSTRUCTOR                                        */\r\n    /********************************************************************************************/\r\n\r\n    /**\r\n    * @dev Contract constructor\r\n    *\r\n    * @param tokenName ERC-20 token name\r\n    * @param tokenSymbol ERC-20 token symbol\r\n    * @param platformAccount Account for making calls from Interface API (i.e. PlatformManager)\r\n    * @param icoAccount Account that holds ICO tokens (i.e. IcoOwner)\r\n    * @param supportAccount Account with limited access to manage Interface user support (i.e. SupportManager)\r\n    *\r\n    */\r\n    function WHENToken\r\n                            ( \r\n                                string tokenName, \r\n                                string tokenSymbol, \r\n                                address platformAccount, \r\n                                address icoAccount,\r\n                                address supportAccount\r\n                            ) \r\n                            public \r\n    {\r\n\r\n        name = tokenName;\r\n        symbol = tokenSymbol;\r\n\r\n        jiffysMultiplier = 10 ** uint256(decimals);                             // Multiplier used throughout contract\r\n        incentiveJiffysBalance = INCENTIVE_TOKENS.mul(jiffysMultiplier);        // Network seeding tokens\r\n        referralJiffysBalance = REFERRAL_TOKENS.mul(jiffysMultiplier);          // User referral tokens\r\n\r\n\r\n        contractOwner = msg.sender;                                     // Owner of the contract\r\n        platformManager = platformAccount;                              // API account for Interface\r\n        icoOwner = icoAccount;                                          // Account with ICO tokens for settling Interface transactions\r\n        icoWallet = icoOwner;                                           // Account to which ICO ETH is sent\r\n        supportManager = supportAccount;                                // Support account with limited permissions\r\n\r\n                \r\n        // Create user records for accounts\r\n        users[contractOwner] = User(true, 0, 0, address(0));       \r\n        registeredUserLookup.push(contractOwner);\r\n\r\n        users[platformManager] = User(true, 0, 0, address(0));   \r\n        registeredUserLookup.push(platformManager);\r\n\r\n        users[icoOwner] = User(true, 0, 0, address(0));   \r\n        registeredUserLookup.push(icoOwner);\r\n\r\n        users[supportManager] = User(true, 0, 0, address(0));   \r\n        registeredUserLookup.push(supportManager);\r\n\r\n    }    \r\n\r\n    /**\r\n    * @dev Contract constructor\r\n    *\r\n    * Initialize is to be called immediately after the supporting contracts are deployed.\r\n    *\r\n    * @param dataContract Address of the deployed InterfaceData contract\r\n    * @param appContract Address of the deployed InterfaceApp contract\r\n    * @param vestingContract Address of the deployed TokenVesting contract\r\n    *\r\n    */\r\n    function initialize\r\n                            (\r\n                                address dataContract,\r\n                                address appContract,\r\n                                address vestingContract\r\n                            )\r\n                            external\r\n                            requireContractOwner\r\n    {        \r\n        require(bonus20EndTimestamp == 0);      // Ensures function cannot be called twice\r\n        authorizeContract(dataContract);        // Authorizes InterfaceData contract to make calls to this contract\r\n        authorizeContract(appContract);         // Authorizes InterfaceApp contract to make calls to this contract\r\n        authorizeContract(vestingContract);     // Authorizes TokenVesting contract to make calls to this contract\r\n        \r\n        bonus20EndTimestamp = ICO_START_TIMESTAMP.add(ONE_WEEK);\r\n        bonus10EndTimestamp = bonus20EndTimestamp.add(ONE_WEEK);\r\n        bonus5EndTimestamp = bonus10EndTimestamp.add(ONE_WEEK);\r\n\r\n        // ICO tokens are allocated without vesting to ICO account for distribution during sale\r\n        balances[icoOwner] = ICO_TOKENS.mul(jiffysMultiplier);        \r\n\r\n        // Platform tokens (a.k.a. network seeding tokens) are allocated without vesting\r\n        balances[platformManager] = balances[platformManager].add(PLATFORM_TOKENS.mul(jiffysMultiplier));        \r\n\r\n        // Allocate all other tokens to contract owner without vesting\r\n        // These will be disbursed in initialize()\r\n        balances[contractOwner] = balances[contractOwner].add((COMPANY_TOKENS + PARTNER_TOKENS + FOUNDATION_TOKENS).mul(jiffysMultiplier));\r\n\r\n        userSignupJiffys = jiffysMultiplier.mul(500);       // Initial signup incentive\r\n        referralSignupJiffys = jiffysMultiplier.mul(100);   // Initial referral incentive\r\n       \r\n    }\r\n\r\n    /**\r\n    * @dev Token allocations for various accounts\r\n    *\r\n    * Called from TokenVesting to grant tokens to each account\r\n    *\r\n    */\r\n    function getTokenAllocations()\r\n                                external\r\n                                view\r\n                                returns(uint256, uint256, uint256)\r\n    {\r\n        return (COMPANY_TOKENS.mul(jiffysMultiplier), PARTNER_TOKENS.mul(jiffysMultiplier), FOUNDATION_TOKENS.mul(jiffysMultiplier));\r\n    }\r\n\r\n    /********************************************************************************************/\r\n    /*                                       ERC20 TOKEN                                        */\r\n    /********************************************************************************************/\r\n\r\n    /**\r\n    * @dev Total supply of tokens\r\n    */\r\n    function totalSupply() \r\n                            external \r\n                            view \r\n                            returns (uint) \r\n    {\r\n        uint256 total = ICO_TOKENS.add(PLATFORM_TOKENS).add(COMPANY_TOKENS).add(PARTNER_TOKENS).add(FOUNDATION_TOKENS);\r\n        return total.mul(jiffysMultiplier);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the calling address.\r\n    *\r\n    * @return An uint256 representing the amount owned by the calling address\r\n    */\r\n    function balance()\r\n                            public \r\n                            view \r\n                            returns (uint256) \r\n    {\r\n        return balanceOf(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    *\r\n    * @param owner The address to query the balance of\r\n    * @return An uint256 representing the amount owned by the passed address\r\n    */\r\n    function balanceOf\r\n                            (\r\n                                address owner\r\n                            ) \r\n                            public \r\n                            view \r\n                            returns (uint256) \r\n    {\r\n        return balances[owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers token for a specified address\r\n    *\r\n    * Constraints are added to ensure that tokens granted for network\r\n    * seeding and tokens in escrow are not transferable\r\n    *\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    * @return A bool indicating if the transfer was successful.\r\n    */\r\n    function transfer\r\n                            (\r\n                                address to, \r\n                                uint256 value\r\n                            ) \r\n                            public \r\n                            requireIsOperational \r\n                            returns (bool) \r\n    {\r\n        require(to != address(0));\r\n        require(to != msg.sender);\r\n        require(value <= transferableBalanceOf(msg.sender));                                         \r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(value);\r\n        balances[to] = balances[to].add(value);\r\n        Transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers tokens from one address to another\r\n    *\r\n    * Constraints are added to ensure that tokens granted for network\r\n    * seeding and tokens in escrow are not transferable\r\n    *\r\n    * @param from address The address which you want to send tokens from\r\n    * @param to address The address which you want to transfer to\r\n    * @param value uint256 the amount of tokens to be transferred\r\n    * @return A bool indicating if the transfer was successful.\r\n    */\r\n    function transferFrom\r\n                            (\r\n                                address from, \r\n                                address to, \r\n                                uint256 value\r\n                            ) \r\n                            public \r\n                            requireIsOperational \r\n                            returns (bool) \r\n    {\r\n        require(from != address(0));\r\n        require(value <= allowed[from][msg.sender]);\r\n        require(value <= transferableBalanceOf(from));                                         \r\n        require(to != address(0));\r\n        require(from != to);\r\n\r\n        balances[from] = balances[from].sub(value);\r\n        balances[to] = balances[to].add(value);\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\r\n        Transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Checks the amount of tokens that an owner allowed to a spender.\r\n    *\r\n    * @param owner address The address which owns the funds.\r\n    * @param spender address The address which will spend the funds.\r\n    * @return A uint256 specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance\r\n                            (\r\n                                address owner, \r\n                                address spender\r\n                            ) \r\n                            public \r\n                            view \r\n                            returns (uint256) \r\n    {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Approves the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    *\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param spender The address which will spend the funds.\r\n    * @param value The amount of tokens to be spent.\r\n    * @return A bool indicating success (always returns true)\r\n    */\r\n    function approve\r\n                            (\r\n                                address spender, \r\n                                uint256 value\r\n                            ) \r\n                            public \r\n                            requireIsOperational \r\n                            returns (bool) \r\n    {\r\n        allowed[msg.sender][spender] = value;\r\n        Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address less greater of escrow tokens and free signup tokens.\r\n    *\r\n    * @param account The address to query the the balance of.\r\n    * @return An uint256 representing the transferable amount owned by the passed address.\r\n    */\r\n    function transferableBalanceOf\r\n                            (\r\n                                address account\r\n                            ) \r\n                            public \r\n                            view \r\n                            returns (uint256) \r\n    {\r\n        require(account != address(0));\r\n\r\n        if (users[account].isRegistered) {\r\n            uint256 restrictedJiffys = users[account].interfaceEscrowJiffys >= users[account].seedJiffys ? users[account].interfaceEscrowJiffys : users[account].seedJiffys;\r\n            return balances[account].sub(restrictedJiffys);\r\n        }\r\n        return balances[account];\r\n    }\r\n\r\n   /**\r\n    * @dev Gets the balance of the specified address less escrow tokens\r\n    *\r\n    * Since seed tokens can be used to pay for Interface transactions\r\n    * this balance indicates what the user can afford to spend for such\r\n    * \"internal\" transactions ignoring distinction between paid and signup tokens\r\n    *\r\n    * @param account The address to query the balance of.\r\n    * @return An uint256 representing the spendable amount owned by the passed address.\r\n    */ \r\n    function spendableBalanceOf\r\n                            (\r\n                                address account\r\n                            ) \r\n                            public \r\n                            view \r\n                            returns(uint256) \r\n    {\r\n\r\n        require(account != address(0));\r\n\r\n        if (users[account].isRegistered) {\r\n            return balances[account].sub(users[account].interfaceEscrowJiffys);\r\n        }\r\n        return balances[account];\r\n    }\r\n\r\n    /********************************************************************************************/\r\n    /*                                  WHENHUB INTERFACE                                       */\r\n    /********************************************************************************************/\r\n\r\n\r\n   /**\r\n    * @dev Get operating status of contract\r\n    *\r\n    * @return A bool that is the current operating status\r\n    */      \r\n    function isOperational() \r\n                            public \r\n                            view \r\n                            returns(bool) \r\n    {\r\n        return operational;\r\n    }\r\n\r\n   /**\r\n    * @dev Sets contract operations on/off\r\n    *\r\n    * When operational mode is disabled, all write transactions except for this\r\n    * one will fail\r\n    * @return A bool that is the new operational mode\r\n    */    \r\n    function setOperatingStatus\r\n                            (\r\n                                bool mode\r\n                            ) \r\n                            external\r\n                            requireContractOwner \r\n    {\r\n        operational = mode;\r\n    }\r\n\r\n   /**\r\n    * @dev Authorizes ICO end and burn of remaining tokens\r\n    *\r\n    * ContractOwner, PlatformManager and IcoOwner must each call this function\r\n    * in any order. The third entity calling the function will cause the\r\n    * icoOwner account balance to be reset to 0.\r\n    */ \r\n    function authorizeIcoBurn() \r\n                            external\r\n    {\r\n        require(balances[icoOwner] > 0);\r\n        require((msg.sender == contractOwner) || (msg.sender == platformManager) || (msg.sender == icoOwner));\r\n\r\n        if (msg.sender == contractOwner) {\r\n            icoBurnAuthorized.contractOwner = true;\r\n        } else if (msg.sender == platformManager) {\r\n            icoBurnAuthorized.platformManager = true;\r\n        } else if (msg.sender == icoOwner) {\r\n            icoBurnAuthorized.icoOwner = true;\r\n        }\r\n\r\n        if (icoBurnAuthorized.contractOwner && icoBurnAuthorized.platformManager && icoBurnAuthorized.icoOwner) {\r\n            balances[icoOwner] = 0;\r\n        }\r\n    }\r\n\r\n   /**\r\n    * @dev Sets fee used in Interface transactions\r\n    *\r\n    * A network fee is charged for each transaction represented\r\n    * as a percentage of the total fee payable to Experts. This fee\r\n    * is deducted from the amount paid by Callers to Experts.\r\n    * @param basisPoints The fee percentage expressed as basis points\r\n    */    \r\n    function setWinNetworkFee\r\n                            (\r\n                                uint256 basisPoints\r\n                            ) \r\n                            external \r\n                            requireIsOperational \r\n                            requireContractOwner\r\n    {\r\n        require(basisPoints >= 0);\r\n\r\n        winNetworkFeeBasisPoints = basisPoints;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets signup tokens allocated for each user (based on availability)\r\n    *\r\n    * @param tokens The number of tokens each user gets\r\n    */    \r\n    function setUserSignupTokens\r\n                            (\r\n                                uint256 tokens\r\n                            ) \r\n                            external \r\n                            requireIsOperational \r\n                            requireContractOwner\r\n    {\r\n        require(tokens <= 10000);\r\n\r\n        userSignupJiffys = jiffysMultiplier.mul(tokens);\r\n    }\r\n\r\n    /**\r\n    * @dev Sets signup tokens allocated for each user (based on availability)\r\n    *\r\n    * @param tokens The number of tokens each referrer and referree get\r\n    */    \r\n    function setReferralSignupTokens\r\n                            (\r\n                                uint256 tokens\r\n                            ) \r\n                            external \r\n                            requireIsOperational \r\n                            requireContractOwner\r\n    {\r\n        require(tokens <= 10000);\r\n\r\n        referralSignupJiffys = jiffysMultiplier.mul(tokens);\r\n    }\r\n\r\n    /**\r\n    * @dev Sets wallet to which ICO ETH funds are sent\r\n    *\r\n    * @param account The address to which ETH funds are sent\r\n    */    \r\n    function setIcoWallet\r\n                            (\r\n                                address account\r\n                            ) \r\n                            external \r\n                            requireIsOperational \r\n                            requireContractOwner\r\n    {\r\n        require(account != address(0));\r\n\r\n        icoWallet = account;\r\n    }\r\n\r\n    /**\r\n    * @dev Authorizes a smart contract to call this contract\r\n    *\r\n    * @param account Address of the calling smart contract\r\n    */\r\n    function authorizeContract\r\n                            (\r\n                                address account\r\n                            ) \r\n                            public \r\n                            requireIsOperational \r\n                            requireContractOwner\r\n    {\r\n        require(account != address(0));\r\n\r\n        authorizedContracts[account] = 1;\r\n    }\r\n\r\n    /**\r\n    * @dev Deauthorizes a previously authorized smart contract from calling this contract\r\n    *\r\n    * @param account Address of the calling smart contract\r\n    */\r\n    function deauthorizeContract\r\n                            (\r\n                                address account\r\n                            ) \r\n                            external \r\n                            requireIsOperational\r\n                            requireContractOwner \r\n    {\r\n        require(account != address(0));\r\n\r\n        delete authorizedContracts[account];\r\n    }\r\n\r\n    /**\r\n    * @dev Checks if a contract is authorized to call this contract\r\n    *\r\n    * @param account Address of the calling smart contract\r\n    */\r\n    function isContractAuthorized\r\n                            (\r\n                                address account\r\n                            ) \r\n                            public \r\n                            view\r\n                            returns(bool) \r\n    {\r\n        return authorizedContracts[account] == 1;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the Wei to WHEN exchange rate \r\n    *\r\n    * @param rate Number of Wei for one WHEN token\r\n    */\r\n    function setWeiExchangeRate\r\n                            (\r\n                                uint256 rate\r\n                            ) \r\n                            external \r\n                            requireIsOperational\r\n                            requireContractOwner\r\n    {\r\n        require(rate >= 0); // Cannot set to less than 0.0001 ETH/\uffe6\r\n\r\n        weiExchangeRate = rate;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the U.S. cents to WHEN exchange rate \r\n    *\r\n    * @param rate Number of cents for one WHEN token\r\n    */\r\n    function setCentsExchangeRate\r\n                            (\r\n                                uint256 rate\r\n                            ) \r\n                            external \r\n                            requireIsOperational\r\n                            requireContractOwner\r\n    {\r\n        require(rate >= 1);\r\n\r\n        centsExchangeRate = rate;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the account that will be used for Platform Manager functions \r\n    *\r\n    * @param account Account to replace existing Platform Manager\r\n    */\r\n    function setPlatformManager\r\n                            (\r\n                                address account\r\n                            ) \r\n                            external \r\n                            requireIsOperational\r\n                            requireContractOwner\r\n    {\r\n        require(account != address(0));\r\n        require(account != platformManager);\r\n\r\n        balances[account] = balances[account].add(balances[platformManager]);\r\n        balances[platformManager] = 0;\r\n\r\n        if (!users[account].isRegistered) {\r\n            users[account] = User(true, 0, 0, address(0)); \r\n            registeredUserLookup.push(account);\r\n        }\r\n\r\n        platformManager = account; \r\n    }\r\n\r\n    /**\r\n    * @dev Checks if an account is the PlatformManager \r\n    *\r\n    * @param account Account to check\r\n    */\r\n    function isPlatformManager\r\n                            (\r\n                                address account\r\n                            ) \r\n                            public\r\n                            view \r\n                            returns(bool) \r\n    {\r\n        return account == platformManager;\r\n    }\r\n\r\n    /**\r\n    * @dev Checks if an account is the PlatformManager or SupportManager\r\n    *\r\n    * @param account Account to check\r\n    */\r\n    function isPlatformOrSupportManager\r\n                            (\r\n                                address account\r\n                            ) \r\n                            public\r\n                            view \r\n                            returns(bool) \r\n    {\r\n        return (account == platformManager) || (account == supportManager);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets address of SupportManager\r\n    *\r\n    */\r\n    function getSupportManager()\r\n                            public\r\n                            view \r\n                            returns(address) \r\n    {\r\n        return supportManager;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Checks if referral tokens are available\r\n    *\r\n    * referralSignupTokens is doubled because both referrer\r\n    * and recipient get referral tokens\r\n    *\r\n    * @return A bool indicating if referral tokens are available\r\n    */    \r\n    function isReferralSupported() \r\n                            public \r\n                            view \r\n                            returns(bool) \r\n    {\r\n        uint256 requiredJiffys = referralSignupJiffys.mul(2);\r\n        return (referralJiffysBalance >= requiredJiffys) && (balances[platformManager] >= requiredJiffys);\r\n    }\r\n\r\n    /**\r\n    * @dev Checks if user is a registered user\r\n    *\r\n    * @param account The address which owns the funds.\r\n    * @return A bool indicating if user is a registered user.\r\n    */\r\n    function isUserRegistered\r\n                            (\r\n                                address account\r\n                            ) \r\n                            public \r\n                            view \r\n                            returns(bool) \r\n    {\r\n        return (account != address(0)) && users[account].isRegistered;\r\n    }\r\n\r\n    /**\r\n    * @dev Checks pre-reqs and handles user registration\r\n    *\r\n    * @param account The address which is to be registered\r\n    * @param creditAccount The address which contains token credits from CC purchase\r\n    * @param referrer The address referred the account\r\n    */\r\n    function processRegisterUser\r\n                            (\r\n                                address account, \r\n                                address creditAccount,\r\n                                address referrer\r\n                            ) \r\n                            private\r\n    {\r\n        require(account != address(0));                                             // No invalid account\r\n        require(!users[account].isRegistered);                                      // No double registration\r\n        require(referrer == address(0) ? true : users[referrer].isRegistered);      // Referrer, if present, must be a registered user\r\n        require(referrer != account);                                               // User can't refer her/himself\r\n\r\n        // Initialize user with restricted jiffys\r\n        users[account] = User(true, 0, 0, referrer);\r\n        registeredUserLookup.push(account);\r\n\r\n\r\n        if (purchaseCredits[creditAccount].jiffys > 0) {\r\n            processPurchase(creditAccount, account, purchaseCredits[creditAccount].jiffys, purchaseCredits[creditAccount].purchaseTimestamp);\r\n            purchaseCredits[creditAccount].jiffys = 0;\r\n            delete purchaseCredits[creditAccount];\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev Registers a user wallet with a referrer and deposits any applicable signup tokens\r\n    *\r\n    * @param account The wallet address\r\n    * @param creditAccount The address containing any tokens purchased with USD\r\n    * @param referrer The referring user address\r\n    * @return A uint256 with the user's token balance\r\n    */ \r\n    function registerUser\r\n                            (\r\n                                address account, \r\n                                address creditAccount,\r\n                                address referrer\r\n                            ) \r\n                            public \r\n                            requireIsOperational \r\n                            requirePlatformManager \r\n                            returns(uint256) \r\n    {\r\n                                    \r\n        processRegisterUser(account, creditAccount, referrer);\r\n        UserRegister(account, balanceOf(account), 0);          // Fire event\r\n\r\n        return balanceOf(account);\r\n    }\r\n\r\n    /**\r\n    * @dev Registers a user wallet with a referrer and deposits any applicable bonus tokens\r\n    *\r\n    * @param account The wallet address\r\n    * @param creditAccount The address containing any tokens purchased with USD\r\n    * @param referrer The referring user address\r\n    * @return A uint256 with the user's token balance\r\n    */\r\n    function registerUserBonus\r\n                            (\r\n                                address account, \r\n                                address creditAccount,\r\n                                address referrer\r\n                            ) \r\n                            external \r\n                            requireIsOperational \r\n                            requirePlatformManager \r\n                            returns(uint256) \r\n    {\r\n        \r\n        processRegisterUser(account, creditAccount, referrer);\r\n\r\n        \r\n        // Allocate if there are any remaining signup tokens\r\n        uint256 jiffys = 0;\r\n        if ((incentiveJiffysBalance >= userSignupJiffys) && (balances[platformManager] >= userSignupJiffys)) {\r\n            incentiveJiffysBalance = incentiveJiffysBalance.sub(userSignupJiffys);\r\n            users[account].seedJiffys = users[account].seedJiffys.add(userSignupJiffys);\r\n            transfer(account, userSignupJiffys);\r\n            jiffys = userSignupJiffys;\r\n        }\r\n\r\n        UserRegister(account, balanceOf(account), jiffys);          // Fire event\r\n\r\n       // Allocate referral tokens for both user and referrer if available       \r\n       if ((referrer != address(0)) && isReferralSupported()) {\r\n            referralJiffysBalance = referralJiffysBalance.sub(referralSignupJiffys.mul(2));\r\n\r\n            // Referal tokens are restricted so it is necessary to update user's account\r\n            transfer(referrer, referralSignupJiffys);\r\n            users[referrer].seedJiffys = users[referrer].seedJiffys.add(referralSignupJiffys);\r\n\r\n            transfer(account, referralSignupJiffys);\r\n            users[account].seedJiffys = users[account].seedJiffys.add(referralSignupJiffys);\r\n\r\n            UserRefer(account, referrer, referralSignupJiffys);     // Fire event\r\n        }\r\n\r\n        return balanceOf(account);\r\n    }\r\n\r\n    /**\r\n    * @dev Adds Jiffys to escrow for a user\r\n    *\r\n    * Escrows track the number of Jiffys that the user may owe another user.\r\n    * This function is called by the InterfaceData contract when a caller\r\n    * subscribes to a call.\r\n    *\r\n    * @param account The wallet address\r\n    * @param jiffys The number of Jiffys to put into escrow\r\n    */ \r\n    function depositEscrow\r\n                            (\r\n                                address account, \r\n                                uint256 jiffys\r\n                            ) \r\n                            external \r\n                            requireIsOperational \r\n    {\r\n        if (jiffys > 0) {\r\n            require(isContractAuthorized(msg.sender) || isPlatformManager(msg.sender));   \r\n            require(isUserRegistered(account));                                                     \r\n            require(spendableBalanceOf(account) >= jiffys);\r\n\r\n            users[account].interfaceEscrowJiffys = users[account].interfaceEscrowJiffys.add(jiffys);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Refunds Jiffys from escrow for a user\r\n    *\r\n    * This function is called by the InterfaceData contract when a caller\r\n    * unsubscribes from a call.\r\n    *\r\n    * @param account The wallet address\r\n    * @param jiffys The number of Jiffys to remove from escrow\r\n    */ \r\n    function refundEscrow\r\n                            (\r\n                                address account, \r\n                                uint256 jiffys\r\n                            ) \r\n                            external \r\n                            requireIsOperational \r\n    {\r\n        if (jiffys > 0) {\r\n            require(isContractAuthorized(msg.sender) || isPlatformManager(msg.sender));   \r\n            require(isUserRegistered(account));                                                     \r\n            require(users[account].interfaceEscrowJiffys >= jiffys);\r\n\r\n            users[account].interfaceEscrowJiffys = users[account].interfaceEscrowJiffys.sub(jiffys);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Handles payment for an Interface transaction\r\n    *\r\n    * This function is called by the InterfaceData contract when the front-end\r\n    * application makes a settle() call indicating that the transaction is\r\n    * complete and it's time to pay the Expert. To prevent unauthorized use\r\n    * the function is only callable by a previously authorized contract and\r\n    * is limited to paying out funds previously escrowed.\r\n    *\r\n    * @param payer The account paying (i.e. a caller)\r\n    * @param payee The account being paid (i.e. the Expert)\r\n    * @param referrer The account that referred payer to payee\r\n    * @param referralFeeBasisPoints The referral fee payable to referrer\r\n    * @param billableJiffys The number of Jiffys for payment\r\n    * @param escrowJiffys The number of Jiffys held in escrow for Interface being paid\r\n    */ \r\n    function pay\r\n                            (\r\n                                address payer, \r\n                                address payee, \r\n                                address referrer, \r\n                                uint256 referralFeeBasisPoints, \r\n                                uint256 billableJiffys,\r\n                                uint256 escrowJiffys\r\n                            ) \r\n                            external \r\n                            requireIsOperational \r\n                            returns(uint256, uint256)\r\n    {\r\n        require(isContractAuthorized(msg.sender));   \r\n        require(billableJiffys >= 0);\r\n        require(users[payer].interfaceEscrowJiffys >= billableJiffys);  // Only payment of Interface escrowed funds is allowed\r\n        require(users[payee].isRegistered);\r\n\r\n        // This function may be called if the Expert's surety is\r\n        // being forfeited. In that case, the payment is made to the \r\n        // Support and then funds will be distributed as appropriate\r\n        // to parties following a grievance process. Since the rules \r\n        // for forfeiture can get very complex, they are best handled \r\n        // off-contract. payee == supportManager indicates a forfeiture.\r\n\r\n\r\n        // First, release Payer escrow\r\n        users[payer].interfaceEscrowJiffys = users[payer].interfaceEscrowJiffys.sub(escrowJiffys);\r\n        uint256 referralFeeJiffys = 0;\r\n        uint256 winNetworkFeeJiffys = 0;\r\n\r\n        if (billableJiffys > 0) {\r\n\r\n            // Second, pay the payee\r\n            processPayment(payer, payee, billableJiffys);\r\n\r\n            // Payee is SupportManager if Expert surety is being forfeited, so skip referral and network fees\r\n            if (payee != supportManager) {\r\n\r\n                // Third, Payee pays Referrer and referral fees due\r\n                if ((referralFeeBasisPoints > 0) && (referrer != address(0)) && (users[referrer].isRegistered)) {\r\n                    referralFeeJiffys = billableJiffys.mul(referralFeeBasisPoints).div(BASIS_POINTS_TO_PERCENTAGE); // Basis points to percentage conversion\r\n                    processPayment(payee, referrer, referralFeeJiffys);\r\n                }\r\n\r\n                // Finally, Payee pays contract owner WIN network fee\r\n                if (winNetworkFeeBasisPoints > 0) {\r\n                    winNetworkFeeJiffys = billableJiffys.mul(winNetworkFeeBasisPoints).div(BASIS_POINTS_TO_PERCENTAGE); // Basis points to percentage conversion\r\n                    processPayment(payee, contractOwner, winNetworkFeeJiffys);\r\n                }                    \r\n            }\r\n        }\r\n\r\n        return(referralFeeJiffys, winNetworkFeeJiffys);\r\n    }\r\n    \r\n    /**\r\n    * @dev Handles actual token transfer for payment\r\n    *\r\n    * @param payer The account paying\r\n    * @param payee The account being paid\r\n    * @param jiffys The number of Jiffys for payment\r\n    */     \r\n    function processPayment\r\n                               (\r\n                                   address payer,\r\n                                   address payee,\r\n                                   uint256 jiffys\r\n                               )\r\n                               private\r\n    {\r\n        require(isUserRegistered(payer));\r\n        require(isUserRegistered(payee));\r\n        require(spendableBalanceOf(payer) >= jiffys);\r\n\r\n        balances[payer] = balances[payer].sub(jiffys); \r\n        balances[payee] = balances[payee].add(jiffys);\r\n        Transfer(payer, payee, jiffys);\r\n\r\n        // In the event the payer had received any signup tokens, their value\r\n        // would be stored in the seedJiffys property. When any contract payment\r\n        // is made, we reduce the seedJiffys number. seedJiffys tracks how many\r\n        // tokens are not allowed to be transferred out of an account. As a user\r\n        // makes payments to other users, those tokens have served their purpose\r\n        // of encouraging use of the network and are no longer are restricted.\r\n        if (users[payer].seedJiffys >= jiffys) {\r\n            users[payer].seedJiffys = users[payer].seedJiffys.sub(jiffys);\r\n        } else {\r\n            users[payer].seedJiffys = 0;\r\n        }\r\n           \r\n    }\r\n\r\n    /**\r\n    * @dev Handles transfer of tokens for vesting grants\r\n    *\r\n    * This function is called by the TokenVesting contract. To prevent unauthorized \r\n    * use the function is only callable by a previously authorized contract.\r\n    *\r\n    * @param issuer The account granting tokens\r\n    * @param beneficiary The account being granted tokens\r\n    * @param vestedJiffys The number of vested Jiffys for immediate payment\r\n    * @param unvestedJiffys The number of unvested Jiffys to be placed in escrow\r\n    */     \r\n    function vestingGrant\r\n                            (\r\n                                address issuer, \r\n                                address beneficiary, \r\n                                uint256 vestedJiffys,\r\n                                uint256 unvestedJiffys\r\n                            ) \r\n                            external \r\n                            requireIsOperational \r\n    {\r\n        require(isContractAuthorized(msg.sender));   \r\n        require(spendableBalanceOf(issuer) >= unvestedJiffys.add(vestedJiffys));\r\n\r\n\r\n        // Any vestedJiffys are transferred immediately to the beneficiary\r\n        if (vestedJiffys > 0) {\r\n            balances[issuer] = balances[issuer].sub(vestedJiffys);\r\n            balances[beneficiary] = balances[beneficiary].add(vestedJiffys);\r\n            Transfer(issuer, beneficiary, vestedJiffys);\r\n        }\r\n\r\n        // Any unvestedJiffys are removed from the granting account balance\r\n        // A corresponding number of Jiffys is added to the granting account's\r\n        // vesting escrow balance.\r\n        balances[issuer] = balances[issuer].sub(unvestedJiffys);\r\n        vestingEscrows[issuer] = vestingEscrows[issuer].add(unvestedJiffys);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Handles transfer of tokens for vesting revokes and releases\r\n    *\r\n    * This function is called by the TokenVesting contract. To prevent unauthorized \r\n    * use the function is only callable by a previously authorized contract.\r\n    *\r\n    * @param issuer The account granting tokens\r\n    * @param beneficiary The account being granted tokens\r\n    * @param jiffys The number of Jiffys for release or revoke\r\n    */     \r\n    function vestingTransfer\r\n                            (\r\n                                address issuer, \r\n                                address beneficiary, \r\n                                uint256 jiffys\r\n                            ) \r\n                            external \r\n                            requireIsOperational \r\n    {\r\n        require(isContractAuthorized(msg.sender));   \r\n        require(vestingEscrows[issuer] >= jiffys);\r\n\r\n        vestingEscrows[issuer] = vestingEscrows[issuer].sub(jiffys);\r\n        balances[beneficiary] = balances[beneficiary].add(jiffys);\r\n        Transfer(issuer, beneficiary, jiffys);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Gets an array of addresses registered with contract\r\n    *\r\n    * This can be used by API to enumerate all users\r\n    */   \r\n    function getRegisteredUsers() \r\n                                external \r\n                                view \r\n                                requirePlatformManager \r\n                                returns(address[]) \r\n    {\r\n        return registeredUserLookup;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Gets an array of addresses registered with contract\r\n    *\r\n    * This can be used by API to enumerate all users\r\n    */   \r\n    function getRegisteredUser\r\n                                (\r\n                                    address account\r\n                                ) \r\n                                external \r\n                                view \r\n                                requirePlatformManager                                \r\n                                returns(uint256, uint256, uint256, address) \r\n    {\r\n        require(users[account].isRegistered);\r\n\r\n        return (balances[account], users[account].seedJiffys, users[account].interfaceEscrowJiffys, users[account].referrer);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Returns ICO-related state information for use by API\r\n    */ \r\n    function getIcoInfo()\r\n                                  public\r\n                                  view\r\n                                  returns(bool, uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n        return (\r\n                    balances[icoOwner] > 0, \r\n                    weiExchangeRate, \r\n                    centsExchangeRate, \r\n                    bonus20EndTimestamp, \r\n                    bonus10EndTimestamp, \r\n                    bonus5EndTimestamp\r\n                );\r\n    }\r\n\r\n    /********************************************************************************************/\r\n    /*                                       TOKEN SALE                                         */\r\n    /********************************************************************************************/\r\n\r\n    /**\r\n    * @dev Fallback function for buying ICO tokens. This is not expected to be called with\r\n    *      default gas as it will most certainly fail.\r\n    *\r\n    */\r\n    function() \r\n                            external \r\n                            payable \r\n    {\r\n        buy(msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Buy ICO tokens\r\n    *\r\n    * @param account Account that is buying tokens\r\n    *\r\n    */\r\n    function buy\r\n                            (\r\n                                address account\r\n                            ) \r\n                            public \r\n                            payable \r\n                            requireIsOperational \r\n    {\r\n        require(balances[icoOwner] > 0);\r\n        require(account != address(0));        \r\n        require(msg.value >= weiExchangeRate);    // Minimum 1 token\r\n\r\n        uint256 weiReceived = msg.value;\r\n\r\n        // Convert Wei to Jiffys based on the exchange rate\r\n        uint256 buyJiffys = weiReceived.mul(jiffysMultiplier).div(weiExchangeRate);\r\n        processPurchase(icoOwner, account, buyJiffys, now);\r\n        icoWallet.transfer(msg.value);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Buy ICO tokens with USD\r\n    *\r\n    * @param account Account that is buying tokens\r\n    * @param cents Purchase amount in cents\r\n    *\r\n    */    \r\n    function buyUSD\r\n                            (\r\n                                address account,\r\n                                uint256 cents\r\n                            ) \r\n                            public \r\n                            requireIsOperational \r\n                            requirePlatformManager\r\n    {\r\n        require(balances[icoOwner] > 0);\r\n        require(account != address(0));        \r\n        require(cents >= centsExchangeRate);    // Minimum 1 token\r\n\r\n\r\n\r\n        // Convert Cents to Jiffys based on the exchange rate\r\n        uint256 buyJiffys = cents.mul(jiffysMultiplier).div(centsExchangeRate);\r\n\r\n        if (users[account].isRegistered) {\r\n            processPurchase(icoOwner, account, buyJiffys, now);\r\n        } else {\r\n            // Purchased credits will be transferred to account when user registers\r\n            // They are kept in a holding area until then. We deduct buy+bonus from \r\n            // icoOwner because that is the amount that will eventually be credited.\r\n            // However, we store the credit as buyJiffys so that the referral calculation\r\n            // will be against the buy amount and not the buy+bonus amount\r\n            uint256 totalJiffys = buyJiffys.add(calculatePurchaseBonus(buyJiffys, now));\r\n            balances[icoOwner] = balances[icoOwner].sub(totalJiffys);\r\n            balances[account] = balances[account].add(totalJiffys);\r\n            purchaseCredits[account] = PurchaseCredit(buyJiffys, now);\r\n            Transfer(icoOwner, account, buyJiffys);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev Process token purchase\r\n    *\r\n    * @param account Account that is buying tokens\r\n    * @param buyJiffys Number of Jiffys purchased\r\n    *\r\n    */    \r\n    function processPurchase\r\n                            (\r\n                                address source,\r\n                                address account,\r\n                                uint256 buyJiffys,\r\n                                uint256 purchaseTimestamp\r\n                            ) \r\n                            private \r\n    {\r\n\r\n        uint256 totalJiffys = buyJiffys.add(calculatePurchaseBonus(buyJiffys, purchaseTimestamp));\r\n\r\n\r\n        // Transfer purchased Jiffys to buyer\r\n        require(transferableBalanceOf(source) >= totalJiffys);        \r\n        balances[source] = balances[source].sub(totalJiffys);\r\n        balances[account] = balances[account].add(totalJiffys);            \r\n        Transfer(source, account, totalJiffys);\r\n\r\n        // If the buyer has a referrer attached to their profile, then\r\n        // transfer 3% of the purchased Jiffys to the referrer's account\r\n        if (users[account].isRegistered && (users[account].referrer != address(0))) {\r\n            address referrer = users[account].referrer;\r\n            uint256 referralJiffys = (buyJiffys.mul(BUYER_REFERRER_BOUNTY)).div(100);\r\n            if ((referralJiffys > 0) && (transferableBalanceOf(icoOwner) >= referralJiffys)) {\r\n                balances[icoOwner] = balances[icoOwner].sub(referralJiffys);\r\n                balances[referrer] = balances[referrer].add(referralJiffys);  \r\n                Transfer(icoOwner, referrer, referralJiffys);\r\n            }            \r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates ICO bonus tokens\r\n    *\r\n    * @param buyJiffys Number of Jiffys purchased\r\n    *\r\n    */    \r\n    function calculatePurchaseBonus\r\n                            (\r\n                                uint256 buyJiffys,\r\n                                uint256 purchaseTimestamp\r\n                            ) \r\n                            private \r\n                            view\r\n                            returns(uint256)\r\n    {\r\n        uint256 bonusPercentage = 0;\r\n\r\n        // Time-based bonus\r\n        if (purchaseTimestamp <= bonus5EndTimestamp) {\r\n            if (purchaseTimestamp <= bonus10EndTimestamp) {\r\n                if (purchaseTimestamp <= bonus20EndTimestamp) {\r\n                    bonusPercentage = 20;\r\n                } else {\r\n                    bonusPercentage = 10;\r\n                }\r\n            } else {\r\n                bonusPercentage = 5;\r\n            }\r\n        }\r\n\r\n        return (buyJiffys.mul(bonusPercentage)).div(100);\r\n    }\r\n    \r\n\r\n}   \r\n\r\n/*\r\nLICENSE FOR SafeMath and TokenVesting\r\n\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2016 Smart Contract Solutions, Inc.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included\r\nin all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n\r\n\r\nlibrary SafeMath {\r\n/* Copyright (c) 2016 Smart Contract Solutions, Inc. */\r\n/* See License at end of file                        */\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n        return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"setReferralSignupTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"cents\",\"type\":\"uint256\"}],\"name\":\"buyUSD\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"spendableBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isContractAuthorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"mode\",\"type\":\"bool\"}],\"name\":\"setOperatingStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winNetworkFeeBasisPoints\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isUserRegistered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"payer\",\"type\":\"address\"},{\"name\":\"payee\",\"type\":\"address\"},{\"name\":\"referrer\",\"type\":\"address\"},{\"name\":\"referralFeeBasisPoints\",\"type\":\"uint256\"},{\"name\":\"billableJiffys\",\"type\":\"uint256\"},{\"name\":\"escrowJiffys\",\"type\":\"uint256\"}],\"name\":\"pay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"centsExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sign\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setIcoWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isReferralSupported\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenAllocations\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"logoPng\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"setUserSignupTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"issuer\",\"type\":\"address\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"vestedJiffys\",\"type\":\"uint256\"},{\"name\":\"unvestedJiffys\",\"type\":\"uint256\"}],\"name\":\"vestingGrant\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"jiffys\",\"type\":\"uint256\"}],\"name\":\"refundEscrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"authorizeContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setPlatformManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSupportManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"deauthorizeContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRegisteredUsers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPlatformOrSupportManager\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getIcoInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"issuer\",\"type\":\"address\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"jiffys\",\"type\":\"uint256\"}],\"name\":\"vestingTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"basisPoints\",\"type\":\"uint256\"}],\"name\":\"setWinNetworkFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"jiffys\",\"type\":\"uint256\"}],\"name\":\"depositEscrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dataContract\",\"type\":\"address\"},{\"name\":\"appContract\",\"type\":\"address\"},{\"name\":\"vestingContract\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"creditAccount\",\"type\":\"address\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"registerUserBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"transferableBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"authorizeIcoBurn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOperational\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setWeiExchangeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getRegisteredUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"creditAccount\",\"type\":\"address\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"registerUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPlatformManager\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setCentsExchangeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenName\",\"type\":\"string\"},{\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"name\":\"platformAccount\",\"type\":\"address\"},{\"name\":\"icoAccount\",\"type\":\"address\"},{\"name\":\"supportAccount\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"seedJiffys\",\"type\":\"uint256\"}],\"name\":\"UserRegister\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"UserRefer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"}],\"name\":\"UserLink\",\"type\":\"event\"}]", "ContractName": "WHENToken", "CompilerVersion": "v0.4.18+commit.9cf6e910", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000b029e80c48e14af4b1f722823431432cb4921ea2000000000000000000000000294fee55fccabdf970e1889fb79675e0937afd23000000000000000000000000dd60feb57cfaf713fd5c19e8d662953e1f5cef40000000000000000000000000000000000000000000000000000000000000000a5748454e20546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000045748454e00000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://aa1b921e962e4184c65de3b1c612bc3ca0f496fe397cc7fa755b003f2f3cb64a"}