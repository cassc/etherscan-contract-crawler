{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@nftculture/nftc-contracts-private/contracts/access/v2/OwnableDeferral.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n/**\\n * @title OwnableDeferral\\n * @author @NiftyMike | @NFTCulture\\n * @dev Implements checks for contract admin operations. Will be Backed by\\n * OZ Ownable.\\n *\\n * This contract is helpful when a contract tree gets complicated,\\n * and multiple contracts need to leverage Ownable.\\n *\\n * Sample Implementation:\\n *\\n * modifier isOwner() override(...) {\\n *     _isOwner();\\n *     _;\\n * }\\n *\\n * function _isOwner() internal view override(...) {\\n *     _checkOwner();\\n * }\\n */\\nabstract contract OwnableDeferral {\\n    modifier isOwner() virtual;\\n\\n    function _isOwner() internal view virtual;\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts-private/contracts/access/v2/OwnableDeferralResolution.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n// OZ Libraries\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\n\\n// Local References\\nimport './OwnableDeferral.sol';\\n\\n// Error Codes\\nerror CallerIsNotOwner();\\n\\n/**\\n * @title OwnableDeferralResolution\\n * @author @NiftyMike | @NFTCulture\\n * @dev Implements checks for contract admin (Owner) operations. Backed by OZ Ownable.\\n *\\n * Ownership is assigned to contract deployer wallet by default.\\n *\\n * NOTE: IMPORTANT - This resolution will work great in a simple inheritance situation,\\n * however, if multiple inheritance is involved, it might not adequately satisfy\\n * override (...) conditions. In those scenarios, this code should be used as a\\n * starting point and then adjusted appropriately.\\n */\\ncontract OwnableDeferralResolution is Ownable, OwnableDeferral {\\n    modifier isOwner() override {\\n        _isOwner();\\n        _;\\n    }\\n\\n    function _isOwner() internal view override {\\n        // Same as _checkOwner() but using error code instead of a require statement.\\n        if (owner() != _msgSender()) revert CallerIsNotOwner();\\n    }\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts-private/contracts/metadata/v1/ArtDatastoreManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n// Local References\\nimport '../../access/v2/OwnableDeferral.sol';\\nimport './interfaces/IDynamicArt.sol';\\n\\n// Error Codes\\nerror ArtPieceCountExceeded();\\nerror ArtPieceDoesNotExist();\\nerror ArtPieceAlreadyCreated();\\nerror NullTokenType();\\n\\n/**\\n * @title ArtDatastoreManager\\n * @author @NiftyMike | @NFTCulture\\n * @dev A class for managing the datastore that holds Art pieces as either strings or bytes.\\n */\\nabstract contract ArtDatastoreManager is IDynamicArtV1, OwnableDeferral {\\n    // Storage for Token Attribute Definitions\\n    mapping(uint256 => DynamicArtV1) private _artObjects;\\n    uint64[] private _artPieceTokenTypes;\\n\\n    uint256 private immutable _maxNumberOfArtPieces;\\n\\n    constructor(uint256 __maxNumberOfArtPieces) {\\n        _maxNumberOfArtPieces = __maxNumberOfArtPieces;\\n    }\\n\\n    function createArtPieces(\\n        uint256[] calldata tokenTypes,\\n        string[] calldata stringAssets,\\n        string[] calldata backgrounds,\\n        bytes[] calldata bytesAssets\\n    ) external isOwner {\\n        require(\\n            tokenTypes.length == stringAssets.length &&\\n                tokenTypes.length == backgrounds.length &&\\n                tokenTypes.length == bytesAssets.length,\\n            'Invalid number of assets'\\n        );\\n\\n        uint256 idx;\\n        for (idx = 0; idx < tokenTypes.length; idx++) {\\n            _createArtPiece(tokenTypes[idx], stringAssets[idx], backgrounds[idx], bytesAssets[idx]);\\n        }\\n    }\\n\\n    function createArtPiece(\\n        uint256 tokenType,\\n        string calldata stringAsset,\\n        string calldata backgroundColor,\\n        bytes calldata bytesAsset\\n    ) external isOwner {\\n        _createArtPiece(tokenType, stringAsset, backgroundColor, bytesAsset);\\n    }\\n\\n    function updateArtPiece(\\n        uint256 tokenType,\\n        string calldata stringAsset,\\n        string calldata backgroundColor,\\n        bytes calldata bytesAsset\\n    ) external isOwner {\\n        if (tokenType == 0) revert NullTokenType();\\n        DynamicArtV1 memory current = _artObjects[tokenType];\\n        if (current.tokenType == 0) revert ArtPieceDoesNotExist();\\n\\n        current.tokenType = tokenType;\\n\\n        if (bytes(stringAsset).length > 0) {\\n            current.encodedArt = stringAsset;\\n        }\\n\\n        if (bytes(backgroundColor).length > 0) {\\n            current.backgroundColor = backgroundColor;\\n        }\\n\\n        if (bytesAsset.length > 0) {\\n            current.encodedArtBytes = bytesAsset;\\n        }\\n\\n        _artObjects[tokenType] = current;\\n    }\\n\\n    function _createArtPiece(\\n        uint256 tokenType,\\n        string calldata stringAsset,\\n        string calldata backgroundColor,\\n        bytes calldata bytesAsset\\n    ) internal {\\n        if (tokenType == 0) revert NullTokenType();\\n        if (_maxNumberOfArtPieces > 0 && _artPieceTokenTypes.length + 1 > _maxNumberOfArtPieces)\\n            revert ArtPieceCountExceeded();\\n        if (_artObjects[tokenType].tokenType > 0) revert ArtPieceAlreadyCreated();\\n\\n        DynamicArtV1 memory current;\\n        current.tokenType = tokenType;\\n        current.encodedArt = stringAsset;\\n        current.backgroundColor = backgroundColor;\\n        current.encodedArtBytes = bytesAsset;\\n\\n        _artObjects[tokenType] = current;\\n        _artPieceTokenTypes.push(uint64(tokenType));\\n    }\\n\\n    function getArtObject(uint256 tokenType) external view returns (DynamicArtV1 memory) {\\n        return _getArtObject(tokenType);\\n    }\\n\\n    function _getArtObject(uint256 tokenType) internal view returns (DynamicArtV1 memory) {\\n        return _artObjects[tokenType];\\n    }\\n\\n    function getArtPieceTokenTypes() external view returns (uint64[] memory) {\\n        return _getArtPieceTokenTypes();\\n    }\\n\\n    function _getArtPieceTokenTypes() internal view returns (uint64[] memory) {\\n        return _artPieceTokenTypes;\\n    }\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts-private/contracts/metadata/v1/interfaces/IChainNativeArtProducer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n/**\\n * @title IChainNativeArtProducer\\n * @author @NiftyMike | @NFTCulture\\n * @dev Super thin interface definition for a contract that\\n * produces art in a chain native way.\\n */\\ninterface IChainNativeArtProducer {\\n    /**\\n     * Given a token type, return a string that can be directly inserted into an\\n     * NFT metadata attribute such as image.\\n     *\\n     * @param tokenType type of the art piece\\n     */\\n    function getArtAsString(uint256 tokenType) external view returns (string memory);\\n\\n    /**\\n     * Given a token type, return a string that can be directly inserted into an\\n     * NFT metadata attribute such as animation_url.\\n     *\\n     * @param tokenType type of the art piece\\n     */\\n    function getAnimationAsString(uint256 tokenType) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts-private/contracts/metadata/v1/interfaces/IDynamicArt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n/**\\n * @title IDynamicArtV1\\n * @author @NFTMike | @NFTCulture\\n * @dev Interface that defines the datastructure of on-chain artwork.\\n */\\ninterface IDynamicArtV1 {\\n    struct DynamicArtV1 {\\n        uint256 tokenType;\\n        string encodedArt;\\n        string backgroundColor;\\n        bytes encodedArtBytes;\\n    }\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts-private/contracts/metadata/v1/interfaces/IScriptyStorageProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n///////////////////////////////////////////////////////////\\n// \u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2557 //\\n// \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2588\u2588\u2557\u2591\u2588\u2588\u2554\u255d //\\n// \u255a\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2551\u2591\u2591\u255a\u2550\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u255a\u2588\u2588\u2588\u2588\u2554\u255d\u2591 //\\n// \u2591\u255a\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u255a\u2588\u2588\u2554\u255d\u2591\u2591 //\\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591 //\\n// \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u2550\u2550\u255d\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591 //\\n///////////////////////////////////////////////////////////\\n\\n/**\\n * @title IScriptyStorageProvider\\n * @author @NiftyMike | @NFTCulture\\n * @dev An interface wrapper for a ScriptStorage contract, when we only need to read data from it.\\n * @dev Special thanks to @0xthedude and @xtremetom for providing this library.\\n * See: https://github.com/intartnft/scripty.sol\\n */\\ninterface IScriptyStorageProvider {\\n    /**\\n     * @notice Get the full script\\n     * @param name - Name given to the script. Eg: threejs.min.js_r148\\n     * @param data - Arbitrary data. Not used by this contract.\\n     * @return script - Full script from merged chunks\\n     */\\n    function getScript(string memory name, bytes memory data) external view returns (bytes memory script);\\n\\n    /**\\n     * @notice Get script's chunk pointer list\\n     * @param name - Name given to the script. Eg: threejs.min.js_r148\\n     * @return pointers - List of pointers\\n     */\\n    function getScriptChunkPointers(string memory name) external view returns (address[] memory pointers);\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts-private/contracts/metadata/v1/interfaces/ISVGConstructor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n/**\\n * @title ISVGConstructor\\n * @author @NiftyMike | @NFTCulture\\n * @dev A simple interface for rendering an SVG.\\n */\\ninterface ISVGConstructor {\\n    function constructFromPNG(\\n        bool hasBackground,\\n        string memory backgroundColor,\\n        string memory pngDataURI\\n    ) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@nftculture/nftc-contracts-private/contracts/metadata/v1/PNGBackedSVGArt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n// OZ Libraries\\nimport '@openzeppelin/contracts/utils/Base64.sol';\\n\\n// Local References\\nimport './ArtDatastoreManager.sol';\\nimport './interfaces/ISVGConstructor.sol';\\n\\n/**\\n * @title PNGBackedSVGArt\\n * @author @NiftyMike | @NFTCulture\\n * @dev An on-chain contract that constructs a PNG backed SVG object.\\n */\\nabstract contract PNGBackedSVGArt is ArtDatastoreManager {\\n    function _getSvgConstructor(uint256 tokenType) internal view virtual returns (ISVGConstructor svgConstructor);\\n\\n    function _getSvgDataURI(uint256 tokenType) internal view returns (string memory) {\\n        DynamicArtV1 memory artObject = _getArtObject(tokenType);\\n        bool hasBackground = bytes(artObject.backgroundColor).length > 0;\\n        string memory onChainEncodedArt = _getArtObject(tokenType).encodedArt;\\n        string memory svg = _constructSvg(\\n            tokenType,\\n            hasBackground,\\n            artObject.backgroundColor,\\n            _convertBase64PngToDataURI(onChainEncodedArt)\\n        );\\n\\n        return _convertSvgToDataURI(svg);\\n    }\\n\\n    function _getPngDataUri(uint256 tokenType) internal view returns (string memory) {\\n        string memory onChainEncodedArt = _getArtObject(tokenType).encodedArt;\\n        return _convertBase64PngToDataURI(onChainEncodedArt);\\n    }\\n\\n    function _convertBase64PngToDataURI(string memory base64Png) internal pure returns (string memory) {\\n        return string.concat('data:image/png;base64,', base64Png);\\n    }\\n\\n    function _convertSvgToDataURI(string memory svg) internal pure returns (string memory) {\\n        return string.concat('data:image/svg+xml;base64,', Base64.encode(bytes(svg)));\\n    }\\n\\n    function _convertBytesToDataURI(\\n        bytes memory artBytes,\\n        string memory mimeType\\n    ) internal pure returns (string memory) {\\n        return string.concat('data:', mimeType, ';base64,', Base64.encode(artBytes));\\n    }\\n\\n    function _constructSvg(\\n        uint256 tokenType,\\n        bool hasBackground,\\n        string memory backgroundColor,\\n        string memory pngDataURI\\n    ) internal view virtual returns (string memory) {\\n        return _getSvgConstructor(tokenType).constructFromPNG(hasBackground, backgroundColor, pngDataURI);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides a set of functions to operate with Base64 strings.\\n *\\n * _Available since v4.5._\\n */\\nlibrary Base64 {\\n    /**\\n     * @dev Base64 Encoding/Decoding Table\\n     */\\n    string internal constant _TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /**\\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\\n     */\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        /**\\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\\n         */\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // Loads the table into memory\\n        string memory table = _TABLE;\\n\\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\\n        // and split into 4 numbers of 6 bits.\\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\\n        // - `data.length + 2`  -> Round up\\n        // - `/ 3`              -> Number of 3-bytes chunks\\n        // - `4 *`              -> 4 characters for each chunk\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the lookup table (skip the first \\\"length\\\" byte)\\n            let tablePtr := add(table, 1)\\n\\n            // Prepare result pointer, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // Run over the input, 3 bytes at a time\\n            for {\\n                let dataPtr := data\\n                let endPtr := add(data, mload(data))\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                // Advance 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // To write each character, shift the 3 bytes (18 bits) chunk\\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\\n                // and apply logical AND with 0x3F which is the number of\\n                // the previous character in the ASCII table prior to the Base64 Table\\n                // The result is then added to the table to get the character to write,\\n                // and finally write it in the result pointer but with a left shift\\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n            }\\n\\n            // When data `bytes` is not exactly 3 bytes long\\n            // it is padded with `=` characters at the end\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n                mstore8(sub(resultPtr, 2), 0x3d)\\n            }\\n            case 2 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/KH87A/PixelPioneerArtwork.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n// Local References\\nimport './PixelPioneerArtworkBase.sol';\\n\\n/**\\n * @title PixelPioneerArtwork .\\n *                            .+.\\n *             -:       .:    :+.\\n *    --      :=.       :+    -=                                         .     ..                     .:-:\\n *    .+.    --         :+    =-   .:.                                 :++-.  .++=: ..              :==:-++==:\\n *     =-  .=:          :=    +.  -=::.:.               -.        .==..+=-+=  =+:+-.=====:         -+:  =+:.-+.\\n *     =-:=-       :.   ==----+  :+   =+:.-+-   ..                 ++..++++:  =++=-+:   -+:      .++=--=++=-++.\\n *     -=--==-.    :.   +-::.=-  +- .=-+:=::+. -+=     .:-.        =+.  .+=   :+=.=+:   -+:       +=:::=+..-+:\\n *     --    .--       .+.  .+:  ==-=: -+:  ===:.======-::+-       =+.  :+:   =+:-+-   :+=       .+=  .+--+-.\\n *     .-              .+.  :+.   :.                      :+.      .-    .    .-=-.    =+.        :==-=+=:.\\n *                      +:  .+                            :-                           ..            ..\\n *\\n *                                                On-Chain Artwork\\n */\\ncontract PixelPioneerArtwork is PixelPioneerArtworkBase {\\n    uint256 private constant maxNumberOfArtPieces = 5; // Capped at 5 total pieces.\\n\\n    constructor() ArtDatastoreManager(maxNumberOfArtPieces) {\\n        // Implementation version: v1.0.0\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/KH87A/PixelPioneerArtworkBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n// NFTC Prerelease Contracts\\nimport '@nftculture/nftc-contracts-private/contracts/access/v2/OwnableDeferralResolution.sol';\\nimport '@nftculture/nftc-contracts-private/contracts/metadata/v1/interfaces/IChainNativeArtProducer.sol';\\nimport '@nftculture/nftc-contracts-private/contracts/metadata/v1/interfaces/IScriptyStorageProvider.sol';\\nimport '@nftculture/nftc-contracts-private/contracts/metadata/v1/PNGBackedSVGArt.sol';\\n\\n// Error Codes\\nerror UnrecognizedExtension();\\n\\n/**\\n * @title PixelPioneerArtworkBase\\n * @author @NiftyMike | @NFTCulture\\n * @dev This contract implements the NFTC IChainNativeArtProducer API, which means\\n * it contains logic to return the contents of an NFT image / animation_url field\\n * for a given NFT token type.\\n *\\n * In this particular implementation, the image approach is fully on-chain. The returned\\n * value represents a SVG that is base64 encoded. The string representation can be copy\\n * and pasted into a new browser tab to display the image.\\n *\\n * The SVGs constructed by this contract are backed by bitmaps stored as base64 encoded\\n * PNG files. The PNG files are via transactions that are sent after the contract is\\n * deployed. The maximum base64 string size is about 34KB, and is limited by the max block\\n * size of the block chain, which is around 30M gas.\\n *\\n * In theory, this same exact approach could be used with larger backing PNGs (ignoring\\n * cost implications), if the base64 string was chunked across multiple transactions, but\\n * we have no need to do that with this project.\\n */\\nabstract contract PixelPioneerArtworkBase is PNGBackedSVGArt, IChainNativeArtProducer, OwnableDeferralResolution {\\n    string private constant extension_iff = 'iff';\\n    string private constant extension_pict = 'pct';\\n\\n    address private _svgRenderer;\\n\\n    struct ArchivalMetadata {\\n        address scriptyStorageProvider;\\n        uint256 tokenType;\\n        string scriptName;\\n        string extension;\\n    }\\n\\n    // File extension -> tokenType (but zero indexed)\\n    mapping(string => ArchivalMetadata[]) private _metadata;\\n\\n    function getArtAsString(uint256 tokenType) external view returns (string memory) {\\n        // This project returns the SVG data as the art string.\\n        return _getSvgDataURI(tokenType);\\n    }\\n\\n    function getAnimationAsString(uint256) external pure returns (string memory) {\\n        // This art is not animated.\\n        return '';\\n    }\\n\\n    /**\\n     * @notice Get the Art Asset for a TokenType as an SVG encoded into a data URI.\\n     *\\n     * @param tokenType the token type of the art piece.\\n     */\\n    function getSvgArt(uint256 tokenType) external view returns (string memory) {\\n        return _getSvgDataURI(tokenType);\\n    }\\n\\n    /**\\n     * @notice Get the Art Asset for a TokenType as a PNG encoded into a data URI.\\n     *\\n     * @param tokenType the token type of the art piece.\\n     */\\n    function getPngArt(uint256 tokenType) external view returns (string memory) {\\n        return _getPngDataUri(tokenType);\\n    }\\n\\n    /**\\n     * @notice Get the Art Asset for a TokenType as a PICT data URI.\\n     *\\n     * Important: This will only function if the PICT files have been recovered.\\n     *\\n     * @param tokenType the token type of the art piece.\\n     */\\n    function getPICTArt(uint256 tokenType) external view returns (string memory) {\\n        return _getPICTDataUri(tokenType);\\n    }\\n\\n    /**\\n     * @notice Get the Art Asset for a TokenType as an IFF data URI.\\n     *\\n     * Important: This will only function if the IFF files have been recovered.\\n     *\\n     * @param tokenType the token type of the art piece.\\n     */\\n    function getIFFArt(uint256 tokenType) external view returns (string memory) {\\n        return _getIFFDataUri(tokenType);\\n    }\\n\\n    /**\\n     * @notice Get the closest source archival asset for a token.\\n     *\\n     * @param extension the file extension of the archival asset.\\n     * @param tokenType the token type of the art piece.\\n     */\\n    function getRawArchivalArt(string calldata extension, uint256 tokenType) external view returns (bytes memory) {\\n        if (keccak256(abi.encodePacked(extension)) == keccak256(abi.encodePacked(extension_iff))) {\\n            return _getIFFBytes(tokenType);\\n        }\\n\\n        if (keccak256(abi.encodePacked(extension)) == keccak256(abi.encodePacked(extension_pict))) {\\n            return _getPICTBytes(tokenType);\\n        }\\n\\n        revert UnrecognizedExtension();\\n    }\\n\\n    /**\\n     * @notice Get the metadata of the source archival asset for a token.\\n     *\\n     * @param extension the file extension of the archival asset.\\n     * @param tokenType the token type of the art piece.\\n     */\\n    function getArchivalMetadata(\\n        string calldata extension,\\n        uint256 tokenType\\n    ) external view returns (ArchivalMetadata memory) {\\n        return _metadata[extension][tokenType - 1];\\n    }\\n\\n    /**\\n     * @notice Admin function to configure the archival metadata for all tokens for a particular file extension.\\n     *\\n     * @param provider address of the archival data store.\\n     * @param scriptNames the filenames that will be saved in the data store.\\n     * @param extension the native os extension of the files that will be saved.\\n     */\\n    function setArchivalMetadata(\\n        address provider,\\n        string[] calldata scriptNames,\\n        string calldata extension\\n    ) external isOwner {\\n        uint256 idx; // note, zero indexed.\\n        for (idx; idx < scriptNames.length; idx++) {\\n            // this is implicitly assuming tokenTypes are 1-5.\\n            ArchivalMetadata memory metadata = ArchivalMetadata(provider, idx + 1, scriptNames[idx], extension);\\n            _metadata[extension].push(metadata);\\n        }\\n    }\\n\\n    /**\\n     * @notice Admin function to update the archival metadata details for a single file.\\n     *\\n     * @param provider address of the archival data store.\\n     * @param tokenType the tokenType of the file.\\n     * @param scriptName the filename that will be saved in the data store.\\n     * @param extension the native os extension of the files that will be saved.\\n     */\\n    function updateArchivalMetadata(\\n        address provider,\\n        uint256 tokenType,\\n        string calldata scriptName,\\n        string calldata extension\\n    ) external isOwner {\\n        uint256 idx = tokenType - 1;\\n        ArchivalMetadata memory metadata = _metadata[extension][idx];\\n        require(metadata.tokenType == tokenType, 'invalid addressing');\\n\\n        _metadata[extension][idx].scriptyStorageProvider = provider;\\n        _metadata[extension][idx].scriptName = scriptName;\\n        _metadata[extension][idx].extension = extension;\\n    }\\n\\n    /**\\n     * @notice Admin function to clear out the entire Metadata Archive for a file extension.\\n     *\\n     * Important: This has no impact on the underlying datastore.\\n     *\\n     * @param extension the native os extension of the files that will be saved.\\n     */\\n    function clearArchivalMetadata(string calldata extension) external isOwner {\\n        ArchivalMetadata[] memory allMetadataForExtension = _metadata[extension];\\n        require(allMetadataForExtension.length > 0, 'array is empty');\\n        delete _metadata[extension];\\n    }\\n\\n    function setSvgRenderer(address svgRenderer) external isOwner {\\n        _svgRenderer = svgRenderer;\\n    }\\n\\n    function getSvgRenderer() external view returns (address) {\\n        return _svgRenderer;\\n    }\\n\\n    function _getSvgConstructor(uint256) internal view override returns (ISVGConstructor svgConstructor) {\\n        return ISVGConstructor(_svgRenderer);\\n    }\\n\\n    function _getIFFDataUri(uint256 tokenType) internal view returns (string memory) {\\n        bytes memory artBytes = _getIFFBytes(tokenType);\\n\\n        return _convertBytesToDataURI(artBytes, 'image/x-iff');\\n    }\\n\\n    function _getIFFBytes(uint256 tokenType) internal view returns (bytes memory) {\\n        uint256 idx = tokenType - 1;\\n        ArchivalMetadata memory metadata = _metadata[extension_iff][idx];\\n        require(metadata.tokenType == tokenType, 'IFF not configured');\\n\\n        IScriptyStorageProvider provider = IScriptyStorageProvider(metadata.scriptyStorageProvider);\\n        return provider.getScript(metadata.scriptName, '');\\n    }\\n\\n    function _getPICTDataUri(uint256 tokenType) internal view returns (string memory) {\\n        bytes memory artBytes = _getPICTBytes(tokenType);\\n\\n        return _convertBytesToDataURI(artBytes, 'image/x-pict');\\n    }\\n\\n    function _getPICTBytes(uint256 tokenType) internal view returns (bytes memory) {\\n        uint256 idx = tokenType - 1;\\n        ArchivalMetadata memory metadata = _metadata[extension_pict][idx];\\n        require(metadata.tokenType == tokenType, 'PICT not configured');\\n\\n        IScriptyStorageProvider provider = IScriptyStorageProvider(metadata.scriptyStorageProvider);\\n        return provider.getScript(metadata.scriptName, '');\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ArtPieceAlreadyCreated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ArtPieceCountExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ArtPieceDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NullTokenType\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnrecognizedExtension\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"extension\",\"type\":\"string\"}],\"name\":\"clearArchivalMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"stringAsset\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"backgroundColor\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"bytesAsset\",\"type\":\"bytes\"}],\"name\":\"createArtPiece\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenTypes\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"stringAssets\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"backgrounds\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"bytesAssets\",\"type\":\"bytes[]\"}],\"name\":\"createArtPieces\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getAnimationAsString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"extension\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"}],\"name\":\"getArchivalMetadata\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"scriptyStorageProvider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"scriptName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"extension\",\"type\":\"string\"}],\"internalType\":\"struct PixelPioneerArtworkBase.ArchivalMetadata\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"}],\"name\":\"getArtAsString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"}],\"name\":\"getArtObject\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"encodedArt\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"backgroundColor\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"encodedArtBytes\",\"type\":\"bytes\"}],\"internalType\":\"struct IDynamicArtV1.DynamicArtV1\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getArtPieceTokenTypes\",\"outputs\":[{\"internalType\":\"uint64[]\",\"name\":\"\",\"type\":\"uint64[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"}],\"name\":\"getIFFArt\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"}],\"name\":\"getPICTArt\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"}],\"name\":\"getPngArt\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"extension\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"}],\"name\":\"getRawArchivalArt\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"}],\"name\":\"getSvgArt\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSvgRenderer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"scriptNames\",\"type\":\"string[]\"},{\"internalType\":\"string\",\"name\":\"extension\",\"type\":\"string\"}],\"name\":\"setArchivalMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"svgRenderer\",\"type\":\"address\"}],\"name\":\"setSvgRenderer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"scriptName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"extension\",\"type\":\"string\"}],\"name\":\"updateArchivalMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"stringAsset\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"backgroundColor\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"bytesAsset\",\"type\":\"bytes\"}],\"name\":\"updateArtPiece\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PixelPioneerArtwork", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}