{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper::safeApprove: approve failed'\r\n        );\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper::safeTransfer: transfer failed'\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper::transferFrom: transferFrom failed'\r\n        );\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\r\n    }\r\n}\r\n\r\n/**\r\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\r\n * deploying minimal proxy contracts, also known as \"clones\".\r\n *\r\n */\r\ncontract Cloneable {\r\n\r\n    /**\r\n        @dev Deploys and returns the address of a clone of address(this\r\n        Created by DeFi Mark To Allow Clone Contract To Easily Create Clones Of Itself\r\n        Without redundancy\r\n     */\r\n    function clone() external returns(address) {\r\n        return _clone(address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create opcode, which should never revert.\r\n     */\r\n    function _clone(address implementation) internal returns (address instance) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            instance := create(0, ptr, 0x37)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create failed\");\r\n    }\r\n}\r\n\r\n/**\r\n * @title Owner\r\n * @dev Set & change owner\r\n */\r\ncontract Ownable {\r\n\r\n    address private owner;\r\n    \r\n    // event for EVM logging\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    \r\n    // modifier to check if caller is owner\r\n    modifier onlyOwner() {\r\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\r\n        // changes to the state and to Ether balances are reverted.\r\n        // This used to consume all gas in old EVM versions, but not anymore.\r\n        // It is often a good idea to use 'require' to check if functions are called correctly.\r\n        // As a second argument, you can also provide an explanation about what went wrong.\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set contract deployer as owner\r\n     */\r\n    constructor() {\r\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\r\n        emit OwnerSet(address(0), owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Change owner\r\n     * @param newOwner address of new owner\r\n     */\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        emit OwnerSet(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Return owner address \r\n     * @return address of owner\r\n     */\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    \r\n    function symbol() external view returns(string memory);\r\n    \r\n    function name() external view returns(string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    /**\r\n     * @dev Returns the number of decimal places\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 {\r\n    /**\r\n     * @dev Emitted when `bagId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed bagId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `bagId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed bagId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `bagId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `bagId` must exist.\r\n     */\r\n    function ownerOf(uint256 bagId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `bagId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `bagId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 bagId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `bagId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `bagId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 bagId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `bagId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `bagId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 bagId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `bagId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `bagId` must exist.\r\n     */\r\n    function getApproved(uint256 bagId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `bagId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `bagId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 bagId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ninterface IERC721Metadata {\r\n    function tokenURI(uint256 bagId) external view returns (string memory);\r\n}\r\n\r\ncontract BaggageClaimData {\r\n\r\n    uint256 internal constant PRECISION = 10**18;\r\n\r\n    // BAG Info\r\n    address public BAG;\r\n    string public name;\r\n    string public symbol;\r\n    uint256 public lockTime;\r\n\r\n    // reward info\r\n    address public rewardToken;\r\n    uint256 public rewardsPerSecond;\r\n    uint256 public lastRewardTime;\r\n\r\n    // Governance\r\n    address public lockTimeSetter;\r\n\r\n    // Reward Data\r\n    uint256 public dividendsPerBAG;\r\n    uint256 public totalDividends;\r\n    uint256 public numBagsChecked;\r\n\r\n    struct UserInfo {\r\n        uint256[] bagIds;\r\n        uint256 balance;\r\n        uint256 totalExcluded;\r\n        uint256 totalRewardsClaimed;\r\n    }\r\n\r\n    struct CheckedBagId {\r\n        uint256 index;      // index in user token id array\r\n        uint256 timeLocked; // time the id was locked\r\n        address owner;\r\n    }\r\n\r\n    mapping ( address => UserInfo ) public userInfo;\r\n    mapping ( uint256 => CheckedBagId ) public bagInfo;\r\n\r\n    uint256 internal constant _NOT_ENTERED = 1;\r\n    uint256 internal constant _ENTERED = 2;\r\n    uint256 internal _status;\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract BaggageClaim is BaggageClaimData, Cloneable, IERC721, IERC721Metadata {\r\n\r\n    function __init__(\r\n        address BAG_,\r\n        address rewardToken_,\r\n        uint256 lockTime_,\r\n        uint256 rewardsPerSecond_,\r\n        string calldata name_,\r\n        string calldata symbol_,\r\n        address lockTimeSetter_\r\n    ) external {\r\n\r\n        // ensure data is correct and this function is only called once\r\n        require(\r\n            BAG_ != address(0) &&\r\n            BAG == address(0),\r\n            'Invalid Init'\r\n        );\r\n        require(\r\n            lockTime_ <= 365 days,\r\n            'Lock Time Too Long'\r\n        );\r\n\r\n        // set data\r\n        BAG = BAG_;\r\n        rewardToken = rewardToken_;\r\n        lockTime = lockTime_;\r\n        rewardsPerSecond = rewardsPerSecond_;\r\n        name = name_;\r\n        symbol = symbol_;\r\n        lockTimeSetter = lockTimeSetter_;\r\n\r\n        // reset reentrancy\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    function setLockTime(uint256 newLockTime) external nonReentrant {\r\n        require(\r\n            msg.sender == lockTimeSetter,\r\n            'Only Setter Can Call'\r\n        );\r\n        require(\r\n            newLockTime <= 365 days,\r\n            'Lock Time Too Long'\r\n        );\r\n        lockTime = newLockTime;\r\n    }\r\n\r\n    function setRewardsPerDay(uint256 rewardsPerDay) external nonReentrant {\r\n        require(\r\n            msg.sender == lockTimeSetter,\r\n            'Only Setter Can Call'\r\n        );\r\n        rewardsPerSecond = rewardsPerDay / 1 days;\r\n    }\r\n\r\n    function setLockTimeSetter(address newSetter) external nonReentrant {\r\n        require(\r\n            msg.sender == lockTimeSetter,\r\n            'Only Setter Can Call'\r\n        );\r\n        lockTimeSetter = newSetter;\r\n    }\r\n\r\n    function checkBag(uint256 bagId) external nonReentrant {\r\n        _checkBag(bagId);\r\n    }\r\n\r\n    function checkMultipleBags(uint256[] calldata bagIds) external nonReentrant {\r\n        _checkMultipleBags(bagIds);\r\n    }\r\n\r\n    function pickUpBag(uint256 bagId) external nonReentrant {\r\n        _pickUpBag(bagId);\r\n    }\r\n\r\n    function pickUpMultipleBags(uint256[] calldata bagIds) external nonReentrant {\r\n        _pickUpMultipleBags(bagIds);\r\n    }\r\n\r\n    function claimRewards() external nonReentrant {\r\n        _updateRewards();\r\n        _claimRewards(msg.sender);\r\n    }\r\n\r\n    function updateRewards() external nonReentrant {\r\n        _updateRewards();\r\n    }\r\n\r\n    function _initRewards() internal {\r\n        lastRewardTime = block.timestamp;\r\n    }\r\n\r\n    function _updateRewards() internal {\r\n\r\n        // calculate the time since the last reward was claimed\r\n        uint256 timeSince = timeSinceLastReward();\r\n        if (timeSince == 0) {\r\n            return;\r\n        }\r\n\r\n        // calculate the amount of rewards to add\r\n        uint256 toReward = rewardsPerSecond * timeSince;\r\n\r\n        // reset the last reward time\r\n        lastRewardTime = block.timestamp;\r\n\r\n        // increase rewards\r\n        unchecked {\r\n            totalDividends += toReward;\r\n            dividendsPerBAG += ( toReward * PRECISION ) / numBagsChecked;\r\n        }\r\n    }\r\n\r\n    function _checkBag(uint256 bagId) internal {\r\n\r\n        // ensure message sender is owner of BAG\r\n        require(\r\n            isOwner(bagId, msg.sender),\r\n            'Sender Not BAG Owner'\r\n        );\r\n        require(\r\n            bagInfo[bagId].owner == address(0),\r\n            'Already Checked'\r\n        );\r\n\r\n        // if first bag check, reset reward timer\r\n        if (numBagsChecked == 0) {\r\n            _initRewards();\r\n        } else {\r\n            _updateRewards();\r\n        }\r\n\r\n        // claim rewards if applicable\r\n        _claimRewards(msg.sender);    \r\n\r\n        // send BAG to self\r\n        IERC721(BAG).transferFrom(msg.sender, address(this), bagId);\r\n\r\n        // ensure BAG is now owned by `this`\r\n        require(\r\n            isOwner(bagId, address(this)),\r\n            'BAG Ownership Not Transferred'\r\n        );\r\n\r\n        // increment total bags checked and user balance\r\n        unchecked {\r\n            numBagsChecked++;\r\n            userInfo[msg.sender].balance++;\r\n        }\r\n\r\n        // reset total rewards\r\n        userInfo[msg.sender].totalExcluded = getCumulativeDividends(userInfo[msg.sender].balance);\r\n        \r\n        // set current bagId index to length of user id array\r\n        bagInfo[bagId].index = userInfo[msg.sender].bagIds.length;\r\n        bagInfo[bagId].timeLocked = block.timestamp;\r\n        bagInfo[bagId].owner = msg.sender;\r\n\r\n        // push new token id to user id array\r\n        userInfo[msg.sender].bagIds.push(bagId);\r\n\r\n        emit Transfer(address(0), msg.sender, bagId);\r\n    }\r\n\r\n    function _checkMultipleBags(uint256[] calldata bagIds) internal {\r\n\r\n        // if first bag checked, reset reward timer\r\n        if (numBagsChecked == 0) {\r\n            _initRewards();\r\n        } else {\r\n            _updateRewards();\r\n        }\r\n\r\n        // claim rewards if applicable\r\n        _claimRewards(msg.sender);   \r\n\r\n        // length of array\r\n        uint256 len = bagIds.length; \r\n\r\n        for (uint i = 0; i < len;) {\r\n            // ensure message sender is owner of BAG\r\n            require(\r\n                isOwner(bagIds[i], msg.sender),\r\n                'Sender Not BAG Owner'\r\n            );\r\n            require(\r\n                bagInfo[bagIds[i]].owner == address(0),\r\n                'Already Checked'\r\n            );\r\n\r\n            // send BAG to self\r\n            IERC721(BAG).transferFrom(msg.sender, address(this), bagIds[i]);\r\n\r\n            // ensure BAG is now owned by `this`\r\n            require(\r\n                isOwner(bagIds[i], address(this)),\r\n                'BAG Ownership Not Transferred'\r\n            );\r\n\r\n            // set current bagId index to length of user id array\r\n            bagInfo[bagIds[i]].index = userInfo[msg.sender].bagIds.length;\r\n            bagInfo[bagIds[i]].timeLocked = block.timestamp;\r\n            bagInfo[bagIds[i]].owner = msg.sender;\r\n\r\n            // push new token id to user id array\r\n            userInfo[msg.sender].bagIds.push(bagIds[i]);\r\n\r\n            emit Transfer(address(0), msg.sender, bagIds[i]);\r\n            unchecked { ++i; }\r\n        }\r\n\r\n        // increment total bags checked and user balance\r\n        numBagsChecked += len;\r\n        userInfo[msg.sender].balance += len;\r\n\r\n        // reset total rewards\r\n        userInfo[msg.sender].totalExcluded = getCumulativeDividends(userInfo[msg.sender].balance);\r\n    }\r\n\r\n    function _pickUpBag(uint256 bagId) internal {\r\n        require(\r\n            isOwner(bagId, address(this)),\r\n            'BAG Is Not Checked'\r\n        );\r\n        require(\r\n            bagInfo[bagId].owner == msg.sender,\r\n            'Only Owner Can Pick Up Bag'\r\n        );\r\n        require(\r\n            hasCheckedBag(msg.sender, bagId),\r\n            'User Has Not Checked bagId'\r\n        );\r\n        require(\r\n            timeUntilUnlock(bagId) == 0,\r\n            'Token Still Locked'\r\n        );\r\n\r\n        // update rewards\r\n        _updateRewards();\r\n\r\n        // claim pending rewards if any\r\n        _claimRewards(msg.sender);\r\n        \r\n        // decrement balance\r\n        userInfo[msg.sender].balance -= 1;\r\n        numBagsChecked -= 1;\r\n\r\n        // reset total rewards\r\n        userInfo[msg.sender].totalExcluded = getCumulativeDividends(userInfo[msg.sender].balance);\r\n\r\n        // remove BAG from user array\r\n        _removeBAG(msg.sender, bagId);\r\n        \r\n        // send BAG to caller\r\n        IERC721(BAG).transferFrom(address(this), msg.sender, bagId);\r\n\r\n        emit Transfer(msg.sender, address(0), bagId);\r\n    }\r\n\r\n    function _pickUpMultipleBags(uint256[] calldata bagIds) internal {\r\n\r\n        // update rewards\r\n        _updateRewards();\r\n\r\n        // claim pending rewards if any\r\n        _claimRewards(msg.sender);\r\n\r\n        // length of array\r\n        uint256 len = bagIds.length;\r\n\r\n        // decrement balance\r\n        userInfo[msg.sender].balance -= len;\r\n        numBagsChecked -= len;\r\n\r\n        // reset total rewards\r\n        userInfo[msg.sender].totalExcluded = getCumulativeDividends(userInfo[msg.sender].balance);\r\n\r\n        for (uint i = 0; i < len;) {\r\n            \r\n            require(\r\n                isOwner(bagIds[i], address(this)),\r\n                'BAG Is Not Checked'\r\n            );\r\n            require(\r\n                bagInfo[bagIds[i]].owner == msg.sender,\r\n                'Only Owner Can Pick Up Bag'\r\n            );\r\n            require(\r\n                hasCheckedBag(msg.sender, bagIds[i]),\r\n                'User Has Not Checked bagId'\r\n            );\r\n            require(\r\n                timeUntilUnlock(bagIds[i]) == 0,\r\n                'Token Still Locked'\r\n            );\r\n\r\n            // remove BAG from user array\r\n            _removeBAG(msg.sender, bagIds[i]);\r\n\r\n            // send BAG to caller\r\n            IERC721(BAG).transferFrom(address(this), msg.sender, bagIds[i]);\r\n\r\n            // emit event\r\n            emit Transfer(msg.sender, address(0), bagIds[i]);\r\n\r\n            unchecked { ++i; }\r\n        }\r\n    }\r\n\r\n    /**\r\n        Claims Reward For User\r\n     */\r\n    function _claimRewards(address user) internal {\r\n\r\n        // return if zero balance\r\n        if (userInfo[user].balance == 0) {\r\n            return;\r\n        }\r\n\r\n        // fetch pending rewards\r\n        uint pending = pendingRewards(user);\r\n        uint max = rewardBalanceOf();\r\n        if (pending > max) {\r\n            pending = max;\r\n        }\r\n        \r\n        // reset total rewards\r\n        userInfo[user].totalExcluded = getCumulativeDividends(userInfo[user].balance);\r\n\r\n        // return if no rewards\r\n        if (pending == 0) {\r\n            return;\r\n        }\r\n\r\n        // incremenet total rewards claimed\r\n        unchecked {\r\n            userInfo[user].totalRewardsClaimed += pending;\r\n        }\r\n\r\n        // transfer reward to user\r\n        if (rewardToken == address(0)) {\r\n            TransferHelper.safeTransferETH(user, pending);\r\n        } else {\r\n            TransferHelper.safeTransfer(rewardToken, user, pending);\r\n        }\r\n    }\r\n\r\n    function _removeBAG(address user, uint256 bagId) internal {\r\n        \r\n        uint lastElement = userInfo[user].bagIds[userInfo[user].bagIds.length - 1];\r\n        uint removeIndex = bagInfo[bagId].index;\r\n\r\n        userInfo[user].bagIds[removeIndex] = lastElement;\r\n        bagInfo[lastElement].index = removeIndex;\r\n        userInfo[user].bagIds.pop();\r\n\r\n        delete bagInfo[bagId];\r\n    }\r\n\r\n    /**\r\n        Pending Token Rewards For `account` based on the last time _updateRewards() was called\r\n     */\r\n    function pendingRewards(address account) public view returns (uint256) {\r\n        if(userInfo[account].balance == 0){ return 0; }\r\n\r\n        uint256 accountTotalDividends = getCumulativeDividends(userInfo[account].balance);\r\n        uint256 accountTotalExcluded = userInfo[account].totalExcluded;\r\n\r\n        return accountTotalDividends <= accountTotalExcluded ? 0 : accountTotalDividends - accountTotalExcluded;\r\n    }\r\n\r\n    /**\r\n        Pending rewards including the current state of _updateRewards()\r\n        This result will match the actual payout of claimRewards() assuming the same timestamp, unless:\r\n            - `rewardToken` is a tax on transfer token\r\n            - insufficient `rewardToken`s are supplied by contract owner\r\n     */\r\n    function currentPendingRewards(address account) external view returns (uint256) {\r\n        if(userInfo[account].balance == 0){ return 0; }\r\n\r\n        // calculate the time since the last reward was claimed\r\n        uint256 timeSince = timeSinceLastReward();\r\n        if (timeSince == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // calculate the amount of rewards to add\r\n        uint256 toReward = rewardsPerSecond * timeSince;\r\n\r\n        // simulate the new dividends per BAG value\r\n        uint256 dividendsPerBAGCurrent = dividendsPerBAG + ( ( toReward * PRECISION ) / numBagsChecked );\r\n\r\n        // return the expected amount to receive\r\n        uint256 accountTotalDividends = ( userInfo[account].balance * dividendsPerBAGCurrent ) / PRECISION;\r\n        uint256 accountTotalExcluded = userInfo[account].totalExcluded;\r\n        return accountTotalDividends <= accountTotalExcluded ? 0 : accountTotalDividends - accountTotalExcluded;\r\n    }\r\n\r\n    function timeSinceLastReward() public view returns (uint256) {\r\n        if (lastRewardTime == 0 || numBagsChecked == 0) {\r\n            return 0;\r\n        }\r\n        return block.timestamp > lastRewardTime ? block.timestamp - lastRewardTime : 0;\r\n    }\r\n\r\n    /**\r\n        Cumulative Dividends For A Number Of Tokens\r\n     */\r\n    function getCumulativeDividends(uint256 share) internal view returns (uint256) {\r\n        return (share * dividendsPerBAG) / PRECISION;\r\n    }\r\n\r\n    function timeUntilUnlock(uint256 bagId) public view returns (uint256) {\r\n        uint unlockTime = bagInfo[bagId].timeLocked + lockTime;\r\n        return unlockTime <= block.timestamp ? 0 : unlockTime - block.timestamp;\r\n    }\r\n\r\n    function isOwner(uint256 bagId, address user) public view returns (bool) {\r\n        return IERC721(BAG).ownerOf(bagId) == user;\r\n    }\r\n\r\n    function listUserCheckedBAGs(address user) public view returns (uint256[] memory) {\r\n        return userInfo[user].bagIds;\r\n    }\r\n\r\n    function fetchBalancePendingAndTotalRewards(address user) public view returns (uint256, uint256, uint256) {\r\n        return (userInfo[user].balance, pendingRewards(user), userInfo[user].totalRewardsClaimed);\r\n    }\r\n    \r\n    function listUserCheckedBAGsAndURIs(address user) public view returns (uint256[] memory, string[] memory) {\r\n        \r\n        uint len = userInfo[user].bagIds.length;\r\n        string[] memory uris = new string[](len);\r\n        for (uint i = 0; i < len;) {\r\n            uris[i] = IERC721Metadata(BAG).tokenURI(userInfo[user].bagIds[i]);\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        return (userInfo[user].bagIds, uris);\r\n    }\r\n\r\n    function listUserCheckedBAGsURIsAndRemainingLockTimes(address user) public view returns (\r\n        uint256[] memory, \r\n        string[] memory,\r\n        uint256[] memory\r\n    ) {\r\n        \r\n        uint len = userInfo[user].bagIds.length;\r\n        string[] memory uris = new string[](len);\r\n        uint256[] memory remainingLocks = new uint256[](len);\r\n        for (uint i = 0; i < len;) {\r\n            uris[i] = IERC721Metadata(BAG).tokenURI(userInfo[user].bagIds[i]);\r\n            remainingLocks[i] = timeUntilUnlock(userInfo[user].bagIds[i]);\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        return (userInfo[user].bagIds, uris, remainingLocks);\r\n    }\r\n\r\n    function listUserTotalBAGs(address user, uint min, uint max) public view returns (uint256[] memory) {\r\n        \r\n        IERC721 BAG_ = IERC721(BAG);\r\n        uint len = BAG_.balanceOf(user);\r\n\r\n        uint256[] memory ids = new uint256[](len);\r\n        uint count = 0;\r\n\r\n        for (uint i = min; i < max;) {\r\n\r\n            if (BAG_.ownerOf(i) == user) {\r\n                ids[count] = i;\r\n                count++;\r\n            }\r\n            \r\n            unchecked {++i;}\r\n        }\r\n        return (ids);\r\n    }\r\n\r\n    function listUserTotalBAGsAndUris(address user, uint min, uint max) public view returns (uint256[] memory, string[] memory) {\r\n        \r\n        IERC721 BAG_ = IERC721(BAG);\r\n        uint len = BAG_.balanceOf(user);\r\n\r\n        uint256[] memory ids = new uint256[](len);\r\n        string[] memory uris = new string[](len);\r\n        uint count = 0;\r\n\r\n        for (uint i = min; i < max;) {\r\n\r\n            if (BAG_.ownerOf(i) == user) {\r\n                ids[count] = i;\r\n                uris[count] = IERC721Metadata(BAG).tokenURI(i);\r\n                count++;\r\n            }\r\n            \r\n            unchecked {++i;}\r\n        }\r\n        return (ids, uris);\r\n    }\r\n\r\n    function hasCheckedBag(address user, uint256 bagId) public view returns (bool) {\r\n        if (userInfo[user].bagIds.length <= bagInfo[bagId].index || bagInfo[bagId].owner != user) {\r\n            return false;\r\n        }\r\n        return userInfo[user].bagIds[bagInfo[bagId].index] == bagId;\r\n    }\r\n\r\n    function hasCheckedBags(address user, uint256[] calldata bagId) public view returns (bool[] memory) {\r\n        uint len = bagId.length;\r\n        bool[] memory hasChecked = new bool[](len);\r\n        for (uint i = 0; i < len;) {\r\n            hasChecked[i] = userInfo[user].bagIds[bagInfo[bagId[i]].index] == bagId[i];\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        return hasChecked;\r\n    }\r\n\r\n    function rewardBalanceOf() public view returns (uint256) {\r\n        return rewardToken == address(0) ? address(this).balance : IERC20(rewardToken).balanceOf(address(this));\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return IERC721(BAG).balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view override returns (uint256 balance) {\r\n        return userInfo[owner].balance;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the owner of the `bagId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `bagId` must exist.\r\n     */\r\n    function ownerOf(uint256 bagId) external view override returns (address owner) {\r\n        return bagInfo[bagId].owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `bagId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `bagId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external override {\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `bagId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `bagId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external override {\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `bagId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `bagId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address, uint256) external override {\r\n        emit Approval(address(0), address(0), 0);\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the account approved for `bagId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `bagId` must exist.\r\n     */\r\n    function getApproved(uint256 a) external view override returns (address operator) {\r\n        return a == uint(uint160(msg.sender)) ? address(0) : msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address, bool) external override {\r\n        emit Approval(address(0), address(0), 0);\r\n        return;\r\n    }\r\n\r\n    function isApprovedForAll(address, address) external pure override returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `bagId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `bagId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes calldata\r\n    ) external override {}\r\n\r\n    function tokenURI(uint256 bagId) external view override returns (string memory) {\r\n        return IERC721Metadata(BAG).tokenURI(bagId);\r\n    }\r\n\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"bagId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"bagId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BAG\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"BAG_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockTime_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsPerSecond_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"lockTimeSetter_\",\"type\":\"address\"}],\"name\":\"__init__\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bagInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeLocked\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bagId\",\"type\":\"uint256\"}],\"name\":\"checkBag\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"bagIds\",\"type\":\"uint256[]\"}],\"name\":\"checkMultipleBags\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clone\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"currentPendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendsPerBAG\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"fetchBalancePendingAndTotalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bagId\",\"type\":\"uint256\"}],\"name\":\"hasCheckedBag\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"bagId\",\"type\":\"uint256[]\"}],\"name\":\"hasCheckedBags\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bagId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRewardTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"listUserCheckedBAGs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"listUserCheckedBAGsAndURIs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"listUserCheckedBAGsURIsAndRemainingLockTimes\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"listUserTotalBAGs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"listUserTotalBAGsAndUris\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockTimeSetter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numBagsChecked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bagId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"pendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bagId\",\"type\":\"uint256\"}],\"name\":\"pickUpBag\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"bagIds\",\"type\":\"uint256[]\"}],\"name\":\"pickUpMultipleBags\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLockTime\",\"type\":\"uint256\"}],\"name\":\"setLockTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSetter\",\"type\":\"address\"}],\"name\":\"setLockTimeSetter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardsPerDay\",\"type\":\"uint256\"}],\"name\":\"setRewardsPerDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeSinceLastReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bagId\",\"type\":\"uint256\"}],\"name\":\"timeUntilUnlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bagId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalExcluded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewardsClaimed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BaggageClaim", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "10", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7abb45712818d7ee4c9a7657882a6deee235d117cddc0852a363aa61f670b0fc"}