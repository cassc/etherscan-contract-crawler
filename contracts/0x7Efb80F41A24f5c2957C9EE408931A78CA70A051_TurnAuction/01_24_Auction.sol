// SPDX-License-Identifier: MIT
pragma solidity ^0.8.12;

/**
 * @title Turn NFT auctions' smart-contract
 * @author Julien Kuntz (on behalf of Diligence and ConsenSys)
 * @notice Automatized auctionning smart-contracts, designed to sell TURN NFTs
 * (Tokenized binding contracts between service providers and their clients)
 * @dev The auction mechanism is based on on 'lazy minting'; service providers generate a signed voucher 
 * containing all the conditions that a client must meet to mint an NFT. (price, time constraints, etc.)
 */
import "./Turn.sol";
import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract TurnAuction is AccessControlEnumerable, EIP712, ReentrancyGuard {

  // /-----------------------\
  // | Variable declarations |
  // \-----------------------/

  /** 
   * @notice This data structure ('voucher') contains all the informations necessary to reconstruct the current state of an auction
   * @dev The last parameter ('signature') is generated by token providers following the EIP-712 (Typed Structured data hashing and signing)
   */
  struct NFTVoucher {
    uint256 tokenMintLimit;
    uint256 minPrice;
    uint256 startingPrice;
    uint256 priceFunc;
    uint256 dates;
    address currency;
    address withdrawalAddress;
    string uri;
    bytes signature;
  }

  bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
  bytes32 public constant PROVIDER_ROLE = keccak256("PROVIDER_ROLE");
  string private constant SIGNING_DOMAIN = "TurnAuction";
  string private constant SIGNATURE_VERSION = "4";
  uint256 private fees;
  address private adminWithdrawalAddress;

  mapping(address => mapping(address => uint256)) private pendingWithdrawals; // [WithdrawalAddress] => [ERC20Address] ==> [Balance]
  mapping(address => bool) private allowedERC20;
  address[] private allowedERC20List;
  mapping(bytes => uint256) private tokensMinted;
  Turn public turnContract;

  event Purchase(address purchaser, NFTVoucher voucher, uint256 tokenId);
  event Provider(address target, bool isProvider);
  event ERC20Token(address erc20, bool isAuthorised);


  // /------------------------------\
  // | Public functions declaration |
  // \------------------------------/

  constructor(
    address _nftAddress,
    address _admin
  ) EIP712(SIGNING_DOMAIN, SIGNATURE_VERSION) {
    turnContract = Turn(_nftAddress);
    _setupRole(ADMIN_ROLE, _admin);
    _setRoleAdmin(PROVIDER_ROLE, ADMIN_ROLE);
    _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);
    fees = 0; 
    adminWithdrawalAddress = _admin;
  }

  /** 
   * @notice fallback function; always reverts (prevents funds from being sent here inadvertently)
   * @dev doesn't prevents an external smart-contract to send funds through a self-destruct mechanism
   */
  fallback() external {
    revert("fallback: reverts");
  }

  /** 
   * @notice Returns the chain id of the current blockchain.
   * @dev This is used to workaround an issue with ganache returning different values from the on-chain chainid() function and
   * the eth_chainId RPC method. See https://github.com/protocol/nft-website/issues/121 for context.
   */
  function getChainID() public view returns (uint256) {
    uint256 id;
    assembly {
      id := chainid()
    }
    return id;
  }

  /** 
   * @notice Transfers all pending native Ether withdrawal balance to the caller. Reverts if the caller is not an authorized seller.
   * @dev only works for raw Eth withdrawals; another method needs to be created to handle ERC20 withdrawals
   */
  function withdraw() external nonReentrant() {
    address payable receiver = payable(_msgSender());
    uint256 amount = pendingWithdrawals[address(0)][receiver];
    pendingWithdrawals[address(0)][receiver] = 0;
    receiver.transfer(amount);
  }

  /** 
   * @notice Transfers all pending ERC20 withdrawal balance to the caller. Reverts if the caller is not an authorized seller.
   * @dev the target ERC20 token must comply with the standard ERC20 interface. This is the platform owners' responsibility to
   * prevent payments being made with buggy tokens.
   * @param erc20 the address of the ERC20's smartcontract
   */
  function withdrawERC20(address erc20) external nonReentrant() {
    address payable receiver = payable(_msgSender());
    uint256 amount = pendingWithdrawals[erc20][receiver];
    pendingWithdrawals[erc20][receiver] = 0;
    require(IERC20(erc20).transfer(receiver, amount),"ERC20 transfer failed");
  }

  /** 
   * @notice Transfers all pending native Ether withdrawal balance to the admin withdrawal address. Reverts if not an admin.
   * It will also transfer the funds generated by the platform fees.
   * @dev only works for raw Eth withdrawals; another method needs to be created to handle ERC20 withdrawals
   */
  function withdrawAdmin() external onlyRole(ADMIN_ROLE) nonReentrant() {
    address payable receiver = payable(adminWithdrawalAddress);
    uint256 amount = pendingWithdrawals[address(0)][address(this)];
    pendingWithdrawals[address(0)][address(this)] = 0;
    receiver.transfer(amount);
  }

  /** 
   * @notice Transfers all pending ERC20 withdrawal balance to the caller. Reverts if not an admin.
   * It will also transfer the funds generated by the platform fees.
   * @dev the target ERC20 token must comply with the standard ERC20 interface. This is the platform owners' responsibility to
   * prevent payments being made with buggy tokens.
   * @param erc20 the address of the ERC20's smartcontract
   */
  function withdrawERC20Admin(address erc20) external onlyRole(ADMIN_ROLE) nonReentrant() {
    address payable receiver = payable(adminWithdrawalAddress);
    uint256 amount = pendingWithdrawals[erc20][address(this)];
    pendingWithdrawals[erc20][address(this)] = 0;
    require(IERC20(erc20).transfer(receiver, amount),"ERC20 transfer failed");
  }

  /** 
   * @notice Retuns the amount of native Ether available to the user to withdraw.
   * @param user the address of the targeted user
   * @return balance the amount of tokens available to withdraw
   */
  function availableToWithdraw(address user) external view returns (uint256 balance) {
    return pendingWithdrawals[address(0)][user];
  }

  /** 
   * @notice Retuns the amount of ERC20 tokens available to the targeted user to withdraw.
   * @param user the address of the targeted user
   * @param erc20 the address of the targeted ERC20 token
   * @return balance the amount of tokens available to withdraw
   */
  function availableToWithdrawERC20(address user, address erc20) external view returns (uint256 balance) {
    return pendingWithdrawals[erc20][user];
  }

  /**
   * @notice Retuns the amount of native Ether available to the admin to withdraw.
   * @return balance the amount of tokens available to withdraw (also contains the funds generated by the platforms' fees)
   */
  function availableToWithdrawAdmin() external view returns (uint256 balance) {
    return pendingWithdrawals[address(0)][address(this)];
  }

  /**
   * @notice Retuns the amount of ERC20 tokens available to the admin to withdraw.
   * @param erc20 the address of the targeted ERC20 token
   * @return balance the amount of tokens available to withdraw (also contains the funds generated by the platforms' fees)
   */
  function availableToWithdrawERC20Admin(address erc20) external view returns (uint256 balance) {
    return pendingWithdrawals[erc20][address(this)];
  }


  /** 
   * @notice When a token is purchased, platform fees are substracted from the paid amount,
   * and credited to the smart-contract's address.
   * @return fees Returns the current platform fees (uint256(100) = 1%)
   */
  function auctionFees() public view returns (uint256) {
    return fees;
  }

  /** 
   * @notice Sets a new platform fee (cannot be more than 10%); can only be called by an admin.
   * @param newFees the new fee percentage (100 = 1%)
   */
  function changeAuctionFees(uint256 newFees) external onlyRole(ADMIN_ROLE) {
    require(newFees <= 1000, "Cannot set fees over 10%");
    fees = newFees;
  }

  /**
   * @notice Changes the admin's withdrawal address.
   * @param newAddress the new withdrawal address.
   */
  function changeAdminWithdrawalAddress(address newAddress) external onlyRole(ADMIN_ROLE) {
    require(newAddress != address(0), "Cannot set to zero address");
    adminWithdrawalAddress = newAddress;
  }


  /** 
   * @notice adds an ERC20 token to the list of tokens approved for NFT payments; can only be called by an admin.
   * @param erc20 the address of the ERC20's smartcontract you wish to add.
   */
  function addERC20Token(address erc20) external onlyRole(ADMIN_ROLE) {
    allowedERC20[erc20] = true;
    allowedERC20List.push(erc20);

    emit ERC20Token(erc20, true);
  }

  /** 
   * @notice removes an ERC20 token to the list of tokens approved for NFT payments; can only be called by an admin.
   * @param erc20 the address of the ERC20's smartcontract you wish to remove.
   */
  function removeERC20Token(address erc20) external onlyRole(ADMIN_ROLE) {
    require(allowedERC20[erc20], "That token is already forbidden");
    require(allowedERC20List.length > 1, "Can't remove last payment option");
    
    allowedERC20[erc20] = false;

    uint256 indexToRemove = allowedERC20List.length;

    for(uint i=0; i<indexToRemove ; i++) {
      if(allowedERC20List[i] == erc20) indexToRemove = i;
    }

    if(indexToRemove != allowedERC20List.length) {
      allowedERC20List[indexToRemove] = allowedERC20List[allowedERC20List.length - 1]; 
      allowedERC20List.pop();
    }
    emit ERC20Token(erc20, false);
  }

  /**
   * @notice retrieves the list of allowed ERC20 tokens for payments.
   * @dev necessary to prevent users from calling unsafe smart-contracts; admin platform must ensure added ERC20s are safe to use.
   * @return allowedERC20List an array of allowed smart-contract addresses.
   */
  function allowedTokenList() 
    external
    view
    returns(address[] memory)
  {
    return allowedERC20List;
  }

  /**
   * @notice checks if an ERC20 token is allowed or not for payments.
   * @param erc20 the address of the targeted smart-contract.
   * @return bool true/false statement.
   */
  function isTokenAllowed(address erc20) 
    public
    view 
    returns (bool)
  {
    return allowedERC20[erc20];
  }

  /** 
   * @notice Retuns the current price of an auction.
   * @dev Price is dependant on one of the parameters inside the NFTVoucher structure;
   * if the 'priceFunc' parameteris set to 1, you'll have a linear price degression [(StartingPrice) ==> (minPrice)] over the auction duration time
   * if the 'priceFunc' is set to 0 you'll have a constant price equal to minPrice.
   * @param voucher an NFTVoucher structure (doesn't need to be signed by a valid service provider to return a price).
   * @return price the current price of the NFT auction.
   */
  function getCurrentPrice(NFTVoucher calldata voucher)
    public
    view
    returns (uint256) 
  {
    require(block.timestamp <= turnContract.auctionStopsAt(voucher.dates), "Auction has ended");
    require(block.timestamp >= turnContract.auctionStartsAt(voucher.dates), "Auction has not started");
    if(voucher.priceFunc == 1) return _linearPricing(voucher);
    else return voucher.minPrice;
  }

  /**
   * @notice mints a fixed amount of tokens from a single voucher
   * @dev when about to send a transaction with this function, if the voucher can't mint 'quantity' amount of tokens,
   * Metamask (or the other wallet manager used) *should* show that the transaction is about to revert.
   * In the event that multiple transactions are inside the mempool, some transactions *might* revert.
   * @param receiver the address on which the newly minted NFTs will be deposited.
   * @param voucher the NFTVoucher representing the current auction you wish to participate in.
   * @param quantity the amount of NFT you wish to purchase.
   * @return tokenIds the tokenIDs of the NFTs you just minted.
   */
  function purchase(address receiver, NFTVoucher calldata voucher, uint256 quantity)
    external
    payable
    nonReentrant()
    returns (uint256[] memory tokenIds)
  {
    uint256 currentPrice = getCurrentPrice(voucher) * quantity;

    require(hasRole(PROVIDER_ROLE, getVoucherSigner(voucher)), "Invalid signer");
    require(allowedERC20[voucher.currency], "Currency not authorized");
    require((tokensMinted[voucher.signature] + quantity - 1) < voucher.tokenMintLimit, "Voucher limit exceeded");

    if(voucher.currency == address(0)){
      require(msg.value >= currentPrice, "Insufficient funds to purchase");
    }
    else {
      require(IERC20(voucher.currency).allowance(_msgSender(), address(this)) >= currentPrice, "Insufficient ERC20 allowance");
      require(msg.value == 0, "Ether sent during ERC20 purchase");
    }

    uint256 platformFees = (currentPrice / 10000) * fees;
    uint256 sellerProceeds = currentPrice - platformFees;

    if(voucher.currency == address(0)) {
      pendingWithdrawals[address(0)][voucher.withdrawalAddress] += sellerProceeds;
      pendingWithdrawals[address(0)][address(this)] += platformFees;
      pendingWithdrawals[address(0)][_msgSender()] += msg.value - currentPrice;
    }
    else {
      pendingWithdrawals[voucher.currency][voucher.withdrawalAddress] += sellerProceeds;
      pendingWithdrawals[voucher.currency][address(this)] += platformFees;
      require(IERC20(voucher.currency).transferFrom(_msgSender(), address(this), currentPrice), "ERC20 transfer failed");
    }

    tokenIds = new uint256[](quantity);

    uint256 i = 0;
    for(i = 0; i < quantity; i++) {
      tokenIds[i] = _purchase(receiver, voucher);
    }

    return tokenIds;
  }

  /** 
   * @notice Disables a voucher's ability to mint more NFTs (doesn't invalidate NFTs that has already been minted with it).
   * @dev Because auctions' state are reconstructed on-the-fly during purchase, it is not able to know  if a voucher has been disabled in advance.
   * This function 'disables' a voucher by setting internal variables in such a way that, during future purchases, an overflow will be triggered, thus reverting the whole transaction.
   * @param voucher the NFTVoucher to disable.
   */

   function cancelVoucher(NFTVoucher calldata voucher)
    external
  {
    address signer = getVoucherSigner(voucher);
    require(hasRole(PROVIDER_ROLE, signer), "Invalid signer");
    require((_msgSender() == signer) || (_msgSender() == voucher.withdrawalAddress), "msgSender can't cancel voucher");

    tokensMinted[voucher.signature] = type(uint256).max;
  }

  /**
   * @notice Gets the next tokenId for a given voucher if you were to mint with it (will revert if voucher has been disabled with 'cancelVoucher()')
   * @dev Because this function doesn't account for pending purchases in the mempool, you shouldn't rely on this function's output to predict tokenIds.
   * Instead, you should rely/listen on purchase()'s output/events. This function comes handy to know how many NFTs are still mintable with a given voucher.
   * @param voucher the NFTVoucher representing the auction you're curious about.
   * @return tokenId the tokenId of the NFT you'd get if you were to purchase one immediately with the voucher you gave in input.
   */
  function getTokenId(NFTVoucher calldata voucher) 
    public
    view
    returns (uint256)
  {
    uint256 tokenId = uint256(turnContract.tokenGroup(_toUint256(voucher.signature)));
    tokenId = tokenId << 128;
    tokenId += tokensMinted[voucher.signature];

    return tokenId;
  }

  /**
   * @notice Gets the amount of tokens that can be purchased from a given voucher.
   * @dev Unlike 'getTokenId()', this function takes into account the voucher's validity and if it's signed by a vetted service provider. Won't revert.
   * @param voucher the NFTVoucher representing the auction you're curious about.
   * @return buyableTokens the amount of NFTs you can mint with that voucher.
   */
  function getBuyableTokens(NFTVoucher calldata voucher)
    external
    view
    returns (uint256 buyableTokens)
  {
    uint256 mintCount = tokensMinted[voucher.signature];

    if(mintCount == type(uint256).max) buyableTokens = 0;
    else if(hasRole(PROVIDER_ROLE, getVoucherSigner(voucher))) {
      buyableTokens = voucher.tokenMintLimit - mintCount;
    }
    else buyableTokens = 0;
  }

  /**
   * @notice returns the voucher's signer address. Signature is based on the EIP712 standard.
   * @dev similar to 'verify()', which is also a public function doing exactly the same thing.
   * Will revert if the signature is invalid. Does not verify that the signer is authorized to mint NFTs.
   * @param voucher An NFTVoucher describing the auction you're curious about.
   * @return signer the address of the guy who signed that NFT.
   */
  function getVoucherSigner(NFTVoucher calldata voucher)
    public
    view
    returns (address signer)
  {
    signer = verify(voucher);
  }

  /**
   * @notice grants Service Provider's rights to an user.
   * @dev this function can only be called by a platform admin.
   * @param user the targeted user you wish to grant PROVIDER_ROLE.
   */
  function becomeServiceProvider(address user) 
    external
    onlyRole(ADMIN_ROLE)
  {
    grantRole(PROVIDER_ROLE, user);
    emit Provider(user, true);
  }

  /**
   * @notice revokes Service Provider role of an user.
   * @dev this function can only be called by a platform admin.
   * @param user the targeted user you wish to revoke PROVIDER_ROLE.
   */
  function revokeServiceProvider(address user) 
    external
    onlyRole(ADMIN_ROLE)
  {
    revokeRole(PROVIDER_ROLE, user);
    emit Provider(user, false);
  }

  // /--------------------------------\
  // | Internal functions declaration |
  // \--------------------------------/

  /** 
   * @notice Returns a hash of the given NFTVoucher, prepared using EIP712 typed data hashing rules.
   * @dev This function is used by 'verify()' in order to retrieve the address of the voucher's signer.
   * @param voucher An NFTVoucher to hash.
   * @return hash the hash of the NFTVoucher in bytes32 format.
   */
  function _hash(NFTVoucher calldata voucher) internal view returns (bytes32) {
    return
      _hashTypedDataV4(
        keccak256(
          abi.encode(
            keccak256(
              "NFTVoucher(uint256 tokenMintLimit,string uri,uint256 minPrice,uint256 startingPrice,uint256 priceFunc,uint256 dates,address currency,address withdrawalAddress)"
            ),
            voucher.tokenMintLimit,
            keccak256(bytes(voucher.uri)),
            voucher.minPrice,
            voucher.startingPrice,
            voucher.priceFunc,
            voucher.dates,
            voucher.currency,
            voucher.withdrawalAddress
          )
        )
      );
  }

  /**
   * @notice Verifies the signature for a given NFTVoucher, returning the address of the signer. Signature is based on the EIP712 standard.
   * @dev Will revert if the signature is invalid. Does not verify that the signer is authorized to mint NFTs.
   * @param voucher An NFTVoucher describing the auction you're curious about.
   * @return signer the address of the guy who signed that NFT.
   */
  function verify(NFTVoucher calldata voucher)
    public
    view
    returns (address)
  {
    bytes32 digest = _hash(voucher);
    return ECDSA.recover(digest, voucher.signature);
  }

  /**
   * @notice bytes to uint converter. 
   * @dev Because implicit casting is not allowed anymore, and because we want an easy way to translate an NFTVoucher signature into a tokenId,
   * this function is there to help us do just that. Bear in mind that, if the input is bigger than 256 bits, the extra bits will be lost in the convertion.
   * @param _bytes the bytes parameter you want to cast into uint256.
   * @return value the 256 first bits of the _bytes given in input, in uint256 format.
   */
  function _toUint256(bytes memory _bytes)   
    internal
    pure
    returns (uint256 value)
  {
    assembly {
      value := mload(add(_bytes, 0x20))
    }
  }

   /**
   * @notice returns a price for a given voucher following a linear function between the points
   * (auctionStart,startPrice) and (auctionEnd,minPrice)
   * @dev this function is called if the 'priceFunc' variable inside the voucher is equal to 1. Other functions such as this one, describing other price functions,
   * can be created. You will need to sligthly modify the 'purchase' function to take into account new pricing functions, as the logic behind this mechanism is currently 
   * using hard-coded values (priceFunc = 1 ==> _linearPricing ; priceFunc = 0 ==> _constantPrice)
   * @param _voucher the NFTVoucher you're curious about.
   * @return price the current price of the auction as described by the _voucher.
   */
  function _linearPricing(NFTVoucher calldata _voucher)  
    internal 
    view
    returns (uint256) 
  {
    return  _voucher.minPrice 
            + (_voucher.startingPrice - _voucher.minPrice)
            * (turnContract.auctionStopsAt(_voucher.dates) - block.timestamp) 
            / (turnContract.auctionStopsAt(_voucher.dates) - turnContract.auctionStartsAt(_voucher.dates));
  }

  /** 
   * @dev internal purchase method; used only post-checks
   * @param receiver the address that will receive the minted NFT.
   * @param voucher the voucher describing the auction you're participating in.
   * @return tokenId the tokenId of the NFT you just purchased.
   */
   function _purchase(address receiver, NFTVoucher calldata voucher)
    internal
    returns (uint256 tokenId)
  {
    tokenId = getTokenId(voucher);

    tokensMinted[voucher.signature] += 1;

    require(turnContract.safeMint(receiver, tokenId, voucher.dates, voucher.uri), "Token doesn't exist");

    emit Purchase(receiver, voucher, tokenId);

    return tokenId;
  }
}