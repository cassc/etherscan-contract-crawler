{"SourceCode": "/**\r\n * verified by 3esmit\r\n*/\r\n\r\n/**\r\n * Allows to create contracts which would be able to receive ETH and tokens.\r\n * Contract will help to detect ETH deposits faster.\r\n * Contract idea was borrowed from Bittrex.\r\n * Version: 2\r\n * */\r\n\r\npragma solidity 0.4.25;\r\n\r\n\r\ncontract Owned {\r\n    address public owner1;\r\n    address public owner2;\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender != address(0));\r\n        require(msg.sender == owner1 || msg.sender == owner2, \"Only owner.\");\r\n        _;\r\n    }\r\n\r\n    constructor() internal {\r\n        owner1 = msg.sender;\r\n    }\r\n\r\n    function setOwner1(address _address) public onlyOwner {\r\n        require(_address != address(0));\r\n        owner1 = _address;\r\n    }\r\n\r\n    function setOwner2(address _address) public onlyOwner {\r\n        require(_address != address(0));\r\n        owner2 = _address;\r\n    }\r\n}\r\n\r\n\r\ncontract RequiringAuthorization is Owned {\r\n    Casino public casino;\r\n    bool public casinoAuthorized;\r\n    mapping(address => bool) public authorized;\r\n\r\n    modifier onlyAuthorized {\r\n        require(authorized[msg.sender] || casinoAuthorized && casino.authorized(msg.sender), \"Caller is not authorized.\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _casino) internal {\r\n        authorized[msg.sender] = true;\r\n        casino = Casino(_casino);\r\n        casinoAuthorized = true;\r\n    }\r\n\r\n    function authorize(address _address) public onlyOwner {\r\n        authorized[_address] = true;\r\n    }\r\n\r\n    function deauthorize(address _address) public onlyOwner {\r\n        authorized[_address] = false;\r\n    }\r\n\r\n    function authorizeCasino() public onlyOwner {\r\n        casinoAuthorized = true;\r\n    }\r\n\r\n    function deauthorizeCasino() public onlyOwner {\r\n        casinoAuthorized = false;\r\n    }\r\n\r\n    function setCasino(address _casino) public onlyOwner {\r\n        casino = Casino(_casino);\r\n    }\r\n}\r\n\r\n\r\ncontract WalletController is RequiringAuthorization {\r\n    address public destination;\r\n    address public defaultSweeper = address(new DefaultSweeper(address(this)));\r\n    bool public halted = false;\r\n\r\n    mapping(address => address) public sweepers;\r\n    mapping(address => bool) public wallets;\r\n\r\n    event EthDeposit(address _from, address _to, uint _amount);\r\n    event WalletCreated(address _address);\r\n    event Sweeped(address _from, address _to, address _token, uint _amount);\r\n\r\n    modifier onlyWallet {\r\n        require(wallets[msg.sender], \"Caller must be user wallet.\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _casino) public RequiringAuthorization(_casino) {\r\n        destination = msg.sender;\r\n    }\r\n\r\n    function setDestination(address _destination) public onlyOwner {\r\n        destination = _destination;\r\n    }\r\n\r\n    function createWallet() public {\r\n        address wallet = address(new UserWallet(this));\r\n        wallets[wallet] = true;\r\n        emit WalletCreated(wallet);\r\n    }\r\n\r\n    function createWallets(uint count) public {\r\n        for (uint i = 0; i < count; i++) {\r\n            createWallet();\r\n        }\r\n    }\r\n\r\n    function addSweeper(address _token, address _sweeper) public onlyOwner {\r\n        sweepers[_token] = _sweeper;\r\n    }\r\n\r\n    function halt() public onlyAuthorized {\r\n        halted = true;\r\n    }\r\n\r\n    function start() public onlyOwner {\r\n        halted = false;\r\n    }\r\n\r\n    function sweeperOf(address _token) public view returns (address) {\r\n        address sweeper = sweepers[_token];\r\n        if (sweeper == 0) sweeper = defaultSweeper;\r\n        return sweeper;\r\n    }\r\n\r\n    function logEthDeposit(address _from, address _to, uint _amount) public onlyWallet {\r\n        emit EthDeposit(_from, _to, _amount);\r\n    }\r\n\r\n    function logSweep(address _from, address _to, address _token, uint _amount) public {\r\n        emit Sweeped(_from, _to, _token, _amount);\r\n    }\r\n}\r\n\r\n\r\ncontract UserWallet {\r\n    WalletController private controller;\r\n\r\n    constructor (address _controller) public {\r\n        controller = WalletController(_controller);\r\n    }\r\n\r\n    function () public payable {\r\n        controller.logEthDeposit(msg.sender, address(this), msg.value);\r\n    }\r\n\r\n    function tokenFallback(address _from, uint _value, bytes _data) public pure {\r\n        (_from);\r\n        (_value);\r\n        (_data);\r\n    }\r\n\r\n    function sweep(address _token, uint _amount) public returns (bool) {\r\n        (_amount);\r\n        return controller.sweeperOf(_token).delegatecall(msg.data);\r\n    }\r\n}\r\n\r\n\r\ncontract AbstractSweeper {\r\n    WalletController public controller;\r\n\r\n    constructor (address _controller) public {\r\n        controller = WalletController(_controller);\r\n    }\r\n\r\n    function () public { revert(\"Contract does not accept ETH.\"); }\r\n\r\n    function sweep(address token, uint amount) public returns (bool);\r\n\r\n    modifier canSweep() {\r\n        if (!(controller.authorized(msg.sender) || controller.casinoAuthorized() && controller.casino().authorized(msg.sender))) revert(\"Caller is not authorized to sweep.\");\r\n        if (controller.halted()) revert(\"Contract is halted.\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\ncontract DefaultSweeper is AbstractSweeper {\r\n\r\n    constructor (address controller) public AbstractSweeper(controller) {}\r\n\r\n    function sweep(address _token, uint _amount) public canSweep returns (bool) {\r\n        bool success = false;\r\n        address destination = controller.destination();\r\n\r\n        if (_token != address(0)) {\r\n            Token token = Token(_token);\r\n            uint amount = _amount;\r\n            if (amount > token.balanceOf(this)) {\r\n                return false;\r\n            }\r\n\r\n            success = token.transfer(destination, amount);\r\n        } else {\r\n            uint amountInWei = _amount;\r\n            if (amountInWei > address(this).balance) {\r\n                return false;\r\n            }\r\n            success = destination.send(amountInWei);\r\n        }\r\n\r\n        if (success) {\r\n            controller.logSweep(this, destination, _token, _amount);\r\n        }\r\n        return success;\r\n    }\r\n}\r\n\r\n\r\ncontract Token {\r\n    function balanceOf(address a) public pure returns (uint) {\r\n        (a);\r\n        return 0;\r\n    }\r\n\r\n    function transfer(address a, uint val) public pure returns (bool) {\r\n        (a);\r\n        (val);\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\ncontract Casino {\r\n    mapping(address => bool) public authorized;\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sweep\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_controller\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]", "ContractName": "UserWallet", "CompilerVersion": "v0.4.25+commit.59dbf8f1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004202b62990c763860ffaf5e4ee935b1459890e25", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://670b3401d94aec68ef3bdcca24e917d0bcb5bf05491f1d1c1d0f59cf6c11fae6"}