{"SourceCode": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\n\nlibrary AddressUpgradeable {\n    \n    function isContract(address account) internal view returns (bool) {\n        \n        \n        \n\n        return account.code.length > 0;\n    }\n\n    \n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    \n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    \n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    \n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    \n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    \n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            \n            if (returndata.length > 0) {\n                \n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\nabstract contract Initializable {\n    \n    bool private _initialized;\n\n    \n    bool private _initializing;\n\n    \n    modifier initializer() {\n        \n        \n        \n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    \n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n\nlibrary MerkleProofUpgradeable {\n    \n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    \n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                \n                computedHash = _efficientHash(computedHash, proofElement);\n            } else {\n                \n                computedHash = _efficientHash(proofElement, computedHash);\n            }\n        }\n        return computedHash;\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    \n    function toString(uint256 value) internal pure returns (string memory) {\n        \n        \n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    \n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    \n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\ninterface IERC20Upgradeable {\n    \n    function totalSupply() external view returns (uint256);\n\n    \n    function balanceOf(address account) external view returns (uint256);\n\n    \n    function transfer(address to, uint256 amount) external returns (bool);\n\n    \n    function allowance(address owner, address spender) external view returns (uint256);\n\n    \n    function approve(address spender, uint256 amount) external returns (bool);\n\n    \n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    \n    \n    \n    \n    \n\n    \n    \n    \n    \n    \n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    \n    modifier nonReentrant() {\n        \n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        \n        _status = _ENTERED;\n\n        _;\n\n        \n        \n        _status = _NOT_ENTERED;\n    }\n\n    \n    uint256[49] private __gap;\n}\n\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    \n    uint256[50] private __gap;\n}\n\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    \n    event Paused(address account);\n\n    \n    event Unpaused(address account);\n\n    bool private _paused;\n\n    \n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    \n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    \n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    \n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    \n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    \n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    \n    uint256[49] private __gap;\n}\n\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    \n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    \n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    \n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    \n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    \n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    \n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    \n    uint256[49] private __gap;\n}\n\ninterface IAccessControlUpgradeable {\n    \n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    \n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    \n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    \n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    \n    function grantRole(bytes32 role, address account) external;\n\n    \n    function revokeRole(bytes32 role, address account) external;\n\n    \n    function renounceRole(bytes32 role, address account) external;\n}\n\ninterface IERC165Upgradeable {\n    \n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    \n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    \n    uint256[50] private __gap;\n}\n\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    \n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    \n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    \n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    \n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    \n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    \n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    \n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    \n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    \n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    \n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    \n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    \n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    \n    uint256[49] private __gap;\n}\n\nlibrary EnumerableSetUpgradeable {\n    \n    \n    \n    \n    \n    \n    \n    \n\n    struct Set {\n        \n        bytes32[] _values;\n        \n        \n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    \n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            \n            \n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        \n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            \n            \n            \n            \n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                \n                set._values[toDeleteIndex] = lastvalue;\n                \n                set._indexes[lastvalue] = valueIndex; \n            }\n\n            \n            set._values.pop();\n\n            \n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    \n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    \n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    \n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    \n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    \n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    \n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    \n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    \n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    \n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    \n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    \n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    \n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    \n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    \n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    \n\n    struct UintSet {\n        Set _inner;\n    }\n\n    \n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    \n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    \n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    \n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    \n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    \n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\ncontract Claiming is Initializable, ContextUpgradeable, OwnableUpgradeable, AccessControlUpgradeable, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    using StringsUpgradeable for uint16;\n    using StringsUpgradeable for uint256;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    bytes32 public constant LOCKER_ROLE = keccak256(\"LOCKER_ROLE\");\n    uint256 public constant denominator = 100000000;\n    bool public isAllowedWithdraw;\n\n    struct DistributorSettings {\n        bytes32 claimingWalletsMerkleRoot; \n        uint256 unlocksNumber; \n        uint256 lastRootUpdate;\n        bool paused;\n    }\n\n    struct UnlockPeriod {\n        uint256 startDate; \n        uint256 totalPercentage; \n        uint256 endDate; \n        uint256 periodUnit;\n        bool isUnlockedBeforeStart;\n    }\n\n    struct Claim {\n        uint256 totalClaimed;\n    }\n\n    struct Wallet {\n        bool isGraylisted;\n        uint256 lastWalletUpdate;\n    }\n\n    address distributorAddress;\n    DistributorSettings distributorSetting; \n    mapping(uint256 => UnlockPeriod) unlocks;\n    mapping(address => Claim) claims; \n    mapping(address => Wallet) wallets; \n    mapping(address => address) walletInfo; \n    uint256 public stoppedTime;\n    uint256 public totalAmount;\n    uint256 public totalClaimedAmount;\n\n    uint256 public refundDate;\n    EnumerableSetUpgradeable.AddressSet private refundRequested;\n    EnumerableSetUpgradeable.AddressSet private refunded;\n\n    event UnlockPeriodChanged(uint256 indexed _periodIndex, uint256 _vestingStartDate, uint256 _totalPercentage, uint256 _cliffEndDate, uint256 _periodUnit, bool _isUnlocked);\n    event Claimed(address indexed sender, uint256 _amount);\n    event TokensWithdrawn(uint256 _amount);\n    event MerkleRootUpdated(bytes32 _merkleRoot);\n    event DistributionPaused(bool _paused);\n    event WalletUpdated(address indexed _existingWallet, address indexed _newWallet);\n    event CancelVesting(uint256 _stoppedTime, uint256 _withdrawnAmount);\n\n    function initialize() public initializer {\n        __Ownable_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n        __AccessControl_init();\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n        _setupRole(LOCKER_ROLE, _msgSender());\n        isAllowedWithdraw = true;\n    }\n\n    function setRoot(address _distributorAddress, bytes32 _merkleRoot) public onlyRole(LOCKER_ROLE) {\n        _setRoot(_distributorAddress, _merkleRoot);\n    }\n\n    function setPause(bool _paused) public onlyRole(LOCKER_ROLE) {\n        distributorSetting.paused = _paused;\n        emit DistributionPaused(_paused);\n    }\n\n    function setRefundDate(uint256 _refundDate) public onlyRole(LOCKER_ROLE) {\n        refundDate = _refundDate;\n    }\n\n    function withdrawEmergency(address _to, uint256 _amount) public onlyRole(LOCKER_ROLE) {\n        require(isAllowedWithdraw, \"emgergeny withdraw stopped\");\n        IERC20Upgradeable _token = IERC20Upgradeable(distributorAddress);\n        require(_token.balanceOf(address(this)) >= _amount, \"insufficient balance\");\n        _token.transfer(_to, _amount);\n        emit TokensWithdrawn(_amount);\n    }\n\n    function lock(\n        address _distributorAddress,\n        bytes32 _merkleRoot,\n        uint256 _totalAmount,\n        UnlockPeriod[] calldata _periods,\n        uint256 _refundDate\n    ) public onlyRole(LOCKER_ROLE) {\n        require(_totalAmount > 0, \"total amount can't be 0\");\n        _setRoot(_distributorAddress, _merkleRoot);\n        setUnlockPeriods(_periods);\n        totalAmount = _totalAmount;\n        refundDate = _refundDate;\n    }\n\n    function stopEmergencyWithdraw() public onlyRole(LOCKER_ROLE) {\n        isAllowedWithdraw = false;\n    }\n\n    function updateWallet(\n        uint256 _totalAllocation,\n        address _newWallet,\n        bytes32[] calldata _merkleProof\n    ) public nonReentrant {\n        require(!distributorSetting.paused, \"distribution paused\");\n\n        _validateProof(_totalAllocation, _msgSender(), distributorSetting.claimingWalletsMerkleRoot, _merkleProof);\n\n        wallets[_msgSender()].isGraylisted = true;\n        wallets[_msgSender()].lastWalletUpdate = block.timestamp;\n        wallets[_newWallet].isGraylisted = false;\n        wallets[_newWallet].lastWalletUpdate = block.timestamp;\n        if (walletInfo[_msgSender()] == address(0))\n            walletInfo[_newWallet] = _msgSender();\n        else\n            walletInfo[_newWallet] = walletInfo[_msgSender()];\n        walletInfo[_msgSender()] = address(0);\n\n        claims[_newWallet].totalClaimed = claims[_msgSender()].totalClaimed;\n\n        if (refundRequested.contains(_msgSender())) {\n            refundRequested.remove(_msgSender());\n            refundRequested.add(_newWallet);\n        }\n\n        if (refunded.contains(_msgSender())) {\n            refunded.remove(_msgSender());\n            refunded.add(_newWallet);\n        }\n\n        emit WalletUpdated(_msgSender(), _newWallet);\n    }\n\n    function claim(\n        uint256 _totalAllocation,\n        bytes32[] calldata _merkleProof\n    ) public nonReentrant {\n\n        require(!distributorSetting.paused, \"distribution paused\");\n\n        require(!wallets[_msgSender()].isGraylisted, \"wallet greylisted\");\n\n        if (refundDate > 0) {\n            require(!refunded.contains(_msgSender()), \"wallet refunded\");\n\n            if (block.timestamp > refundDate) {\n                require(!refundRequested.contains(_msgSender()), \"refund requested\");\n            }\n            else {\n                refundRequested.remove(_msgSender());\n            }\n        }\n        \n        _validateProof(_totalAllocation, _msgSender(), distributorSetting.claimingWalletsMerkleRoot, _merkleProof);\n\n        uint256 totalToClaim = getAvailableTokens(_totalAllocation, _msgSender(), _merkleProof);\n\n        require(totalToClaim > 0, \"nothing to claim\");\n\n        _transfer(totalToClaim);\n\n        claims[_msgSender()].totalClaimed += totalToClaim;\n        totalClaimedAmount += totalToClaim;\n\n        emit Claimed(_msgSender(), totalToClaim);\n    }\n\n    function requestRefund() external refundEnabled {\n        require(claims[_msgSender()].totalClaimed == 0, \"already claimed\");\n        refundRequested.add(_msgSender());\n    }\n\n    function revokeRefund() external refundEnabled {\n        refundRequested.remove(_msgSender());\n    }\n\n    function isRefundRequested() external view returns (bool) {\n        return refundRequested.contains(_msgSender());\n    }\n\n    function isRefunded() external view returns (bool) {\n        return refunded.contains(_msgSender());\n    }\n\n    function getRefundRequested() public view onlyRole(LOCKER_ROLE) returns (address[] memory) {\n        return _addressSetToArray(refundRequested);\n    }\n\n    function getRefunded() public view onlyRole(LOCKER_ROLE) returns (address[] memory) {\n        return _addressSetToArray(refunded);\n    }\n\n    function addRefunded(address[] memory users) public onlyRole(LOCKER_ROLE) {\n        for (uint256 i = 0; i < users.length; i++) {\n            refunded.add(users[i]);\n        }\n    }\n\n    function removeRefunded(address[] memory users) public onlyRole(LOCKER_ROLE) {\n        for (uint256 i = 0; i < users.length; i++) {\n            refunded.remove(users[i]);\n        }\n    }\n\n    function stopVesting() public nonReentrant onlyRole(LOCKER_ROLE) {\n        require(stoppedTime == 0, \"Vesting was already stopped\");\n        stoppedTime = block.timestamp;\n\n        uint256 percentageBeforeStopped = 0;\n        for (uint256 _periodIndex = 0; _periodIndex < distributorSetting.unlocksNumber; _periodIndex++) {\n            UnlockPeriod memory _unlockPeriod = unlocks[_periodIndex];\n            if (_unlockPeriod.startDate >= stoppedTime) {\n                break;\n            }\n            if (_unlockPeriod.isUnlockedBeforeStart) {\n                continue;\n            }\n            percentageBeforeStopped += _unlockPeriod.totalPercentage;\n        }\n        uint256 leftAmount = totalAmount * percentageBeforeStopped / (denominator * 100) - totalClaimedAmount;\n\n        IERC20Upgradeable _token = IERC20Upgradeable(distributorAddress);\n        uint256 currentLockedAmount = _token.balanceOf(address(this));\n\n        uint256 withdrawnAmount = 0;\n        if (currentLockedAmount > leftAmount) {\n            withdrawnAmount = currentLockedAmount - leftAmount;\n            _transfer(withdrawnAmount);\n        }\n        emit CancelVesting(stoppedTime, withdrawnAmount);\n\n    }\n\n    function getAvailableTokens(uint256 _totalAllocation, address _wallet, bytes32[] calldata _merkleProof) public view returns (uint256) {\n        require(!wallets[_wallet].isGraylisted, \"wallet greylisted\");\n        \n        _validateProof(_totalAllocation, _wallet, distributorSetting.claimingWalletsMerkleRoot, _merkleProof);\n\n        uint256 availableAmount = 0;\n        uint256 unlocksNumber = distributorSetting.unlocksNumber;\n        uint256 totalClaimed = claims[_wallet].totalClaimed;\n        uint256 unlockedBefore = 0;\n\n        for (uint256 _periodIndex = 0; _periodIndex < unlocksNumber; _periodIndex++) {\n            UnlockPeriod memory _unlockPeriod = unlocks[_periodIndex];\n            if (block.timestamp >= _unlockPeriod.startDate) {\n                if (_unlockPeriod.startDate >= stoppedTime && stoppedTime > 0) {\n                    break;\n                }\n                if (_unlockPeriod.totalPercentage == 0) {\n                    continue;\n                }\n                if (_unlockPeriod.isUnlockedBeforeStart) {\n                    \n                    unlockedBefore += _unlockPeriod.totalPercentage;\n                    continue;\n                }\n                if (_unlockPeriod.periodUnit == 0) {\n                    availableAmount += _unlockPeriod.totalPercentage;\n                } else {\n                    if (block.timestamp >= _unlockPeriod.endDate) {\n                        if (stoppedTime == 0 || stoppedTime >= _unlockPeriod.endDate)\n                            availableAmount += _unlockPeriod.totalPercentage;\n                        else {\n                            availableAmount += (_unlockPeriod.totalPercentage / ((_unlockPeriod.endDate - _unlockPeriod.startDate) / _unlockPeriod.periodUnit + 1)) * ((stoppedTime - _unlockPeriod.startDate) / _unlockPeriod.periodUnit + 1);\n                        }\n                    } else {\n                        uint256 _end = block.timestamp;\n                        if (_end > stoppedTime && stoppedTime > _unlockPeriod.startDate) _end = stoppedTime;\n                        availableAmount += (_unlockPeriod.totalPercentage / ((_unlockPeriod.endDate - _unlockPeriod.startDate) / _unlockPeriod.periodUnit + 1)) * ((_end - _unlockPeriod.startDate) / _unlockPeriod.periodUnit + 1);\n                    }\n                }\n            } else {\n                break;\n            }\n        }\n        if ((availableAmount + unlockedBefore) > (100 * denominator)) availableAmount = 100 * denominator - unlockedBefore;\n        uint256 _avail = _calculatePercentage(_totalAllocation, availableAmount);\n        if (_avail >= totalClaimed)\n            return _avail - totalClaimed;\n        else\n            return 0;\n    }\n\n    function verifyTotalPercentageUnlockPeriod(UnlockPeriod[] calldata _periods) public pure returns (bool) {\n        uint256 _totalAmount = 0;\n        for(uint256 _periodIndex = 0; _periodIndex < _periods.length; _periodIndex++) {\n            _totalAmount += _periods[_periodIndex].totalPercentage;\n        }\n        return ((_totalAmount <= 100 * denominator) && (_totalAmount >= 99 * denominator));\n    }\n\n    function setUnlockPeriods(UnlockPeriod[] calldata _periods) public onlyRole(LOCKER_ROLE) {\n        require(verifyTotalPercentageUnlockPeriod(_periods), \"invalid unlock percentage\");\n        distributorSetting.unlocksNumber = _periods.length;\n\n        for(uint256 _periodIndex = 0; _periodIndex < _periods.length; _periodIndex++) {\n\n            unlocks[_periodIndex].startDate = _periods[_periodIndex].startDate;\n            unlocks[_periodIndex].totalPercentage = _periods[_periodIndex].totalPercentage;\n            unlocks[_periodIndex].endDate = _periods[_periodIndex].endDate;\n            unlocks[_periodIndex].periodUnit = _periods[_periodIndex].periodUnit;\n            unlocks[_periodIndex].isUnlockedBeforeStart = _periods[_periodIndex].isUnlockedBeforeStart;\n            \n\n            emit UnlockPeriodChanged(\n                _periodIndex, \n                _periods[_periodIndex].startDate, \n                _periods[_periodIndex].totalPercentage, \n                _periods[_periodIndex].endDate,\n                _periods[_periodIndex].periodUnit,\n                _periods[_periodIndex].isUnlockedBeforeStart);\n        }\n    }\n\n    function getTotalClaimedPerWallet(address _wallet, uint256 _totalAllocation, bytes32[] calldata _merkleProof) public view returns (uint256) {\n        require(!wallets[_wallet].isGraylisted, \"wallet greylisted\");\n        \n        _validateProof(_totalAllocation, _wallet, distributorSetting.claimingWalletsMerkleRoot, _merkleProof);\n        \n        uint256 unlockedBefore = 0;\n        uint256 unlocksNumber = distributorSetting.unlocksNumber;\n        for (uint256 _periodIndex = 0; _periodIndex < unlocksNumber; _periodIndex++) {\n            UnlockPeriod memory _unlockPeriod = unlocks[_periodIndex];\n            if (_unlockPeriod.isUnlockedBeforeStart) {\n                unlockedBefore += _unlockPeriod.totalPercentage;\n                continue;\n            } else {\n                break;\n            }\n        }\n        return claims[_wallet].totalClaimed + _calculatePercentage(_totalAllocation, unlockedBefore);\n    }\n\n    function isVestingStopped() public view returns (bool) {\n        return stoppedTime > 0;\n    }\n\n    \n    \n    \n\n    function _setRoot(address _distributorAddress, bytes32 _merkleRoot) internal {\n        distributorAddress = _distributorAddress;\n        distributorSetting.claimingWalletsMerkleRoot = _merkleRoot;\n        distributorSetting.lastRootUpdate = block.timestamp;\n        emit MerkleRootUpdated(_merkleRoot);\n    }\n\n    function _calculatePercentage(\n        uint256 _amount,\n        uint256 _percentage\n    ) internal pure returns (uint256) {\n        return (_amount * _percentage / (100 * denominator));\n    }\n\n    function _validateProof(\n        uint256 _totalAllocation,\n        address _wallet,\n        bytes32 _merkleRoot,\n        bytes32[] calldata _merkleProof\n    ) internal view {\n        address _origin = walletInfo[_wallet];\n        if (_origin == address(0)) _origin = _wallet;\n        bytes32 leaf = keccak256(abi.encode(_origin, _totalAllocation));\n        require(MerkleProofUpgradeable.verify(_merkleProof, _merkleRoot, leaf), \"invalid proof\");\n    }\n\n    function _transfer(uint256 _amount) internal {\n        IERC20Upgradeable _token = IERC20Upgradeable(distributorAddress);\n        require(_token.balanceOf(address(this)) >= _amount, \"insufficient balance\");\n        _token.transfer(_msgSender(), _amount);\n    }\n\n    function _addressSetToArray(EnumerableSetUpgradeable.AddressSet storage input) internal view returns (address[] memory) {\n        address[] memory result = new address[](input.length());\n\n        for (uint256 i = 0; i < result.length; i++) {\n            result[i] = input.at(i);\n        }\n\n        return result;\n    }\n\n    modifier refundEnabled {\n        require(block.timestamp <= refundDate, \"Refund not enabled or expired\");\n        _;\n    }\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stoppedTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_withdrawnAmount\",\"type\":\"uint256\"}],\"name\":\"CancelVesting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"DistributionPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"MerkleRootUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokensWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_periodIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_vestingStartDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalPercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_cliffEndDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_periodUnit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_isUnlocked\",\"type\":\"bool\"}],\"name\":\"UnlockPeriodChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_existingWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"WalletUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LOCKER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"addRefunded\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalAllocation\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"denominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalAllocation\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"getAvailableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRefundRequested\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRefunded\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_totalAllocation\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"getTotalClaimedPerWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAllowedWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRefundRequested\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRefunded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isVestingStopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_distributorAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_totalAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"periodUnit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnlockedBeforeStart\",\"type\":\"bool\"}],\"internalType\":\"struct Claiming.UnlockPeriod[]\",\"name\":\"_periods\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_refundDate\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"removeRefunded\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revokeRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_refundDate\",\"type\":\"uint256\"}],\"name\":\"setRefundDate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_distributorAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"setRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"periodUnit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnlockedBeforeStart\",\"type\":\"bool\"}],\"internalType\":\"struct Claiming.UnlockPeriod[]\",\"name\":\"_periods\",\"type\":\"tuple[]\"}],\"name\":\"setUnlockPeriods\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopEmergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stoppedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClaimedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalAllocation\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_newWallet\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"updateWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"periodUnit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnlockedBeforeStart\",\"type\":\"bool\"}],\"internalType\":\"struct Claiming.UnlockPeriod[]\",\"name\":\"_periods\",\"type\":\"tuple[]\"}],\"name\":\"verifyTotalPercentageUnlockPeriod\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Claiming", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}