{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/T2BApproval.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\nimport \\\"./utils/Ownable.sol\\\";\\nimport \\\"./interfaces/IT2BRouter.sol\\\";\\nimport {SafeTransferLib} from \\\"lib/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {ERC20} from \\\"lib/solmate/src/tokens/ERC20.sol\\\";\\n\\ncontract T2BApproval {\\n    using SafeTransferLib for ERC20;\\n\\n    error ZeroAddress();\\n    error InvalidTokenAddress();\\n\\n\\n    // Constructor\\n    constructor(address _t2bRouter) {\\n        // Set T2b Router.\\n        IT2BRouter t2bRouter = IT2BRouter(_t2bRouter);\\n\\n        // Set Max Approvals for supported tokens.\\n        uint256 tokenIndex = 0;\\n        while (t2bRouter.supportedTokens(tokenIndex) != address(0)) {\\n            ERC20(t2bRouter.supportedTokens(tokenIndex)).approve(\\n                address(t2bRouter),\\n                type(uint256).max\\n            );\\n            unchecked {\\n                ++tokenIndex;\\n            }\\n        }\\n\\n        selfdestruct(payable(msg.sender));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.4;\\n\\nabstract contract Ownable {\\n    address private _owner;\\n    address private _nominee;\\n\\n    event OwnerNominated(address indexed nominee);\\n    event OwnerClaimed(address indexed claimer);\\n\\n    error OnlyOwner();\\n    error OnlyNominee();\\n\\n    constructor(address owner_) {\\n        _claimOwner(owner_);\\n    }\\n\\n    modifier onlyOwner() {\\n        if (msg.sender != _owner) {\\n            revert OnlyOwner();\\n        }\\n        _;\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    function nominee() public view returns (address) {\\n        return _nominee;\\n    }\\n\\n    function nominateOwner(address nominee_) external {\\n        if (msg.sender != _owner) {\\n            revert OnlyOwner();\\n        }\\n        _nominee = nominee_;\\n        emit OwnerNominated(_nominee);\\n    }\\n\\n    function claimOwner() external {\\n        if (msg.sender != _nominee) {\\n            revert OnlyNominee();\\n        }\\n        _claimOwner(msg.sender);\\n    }\\n\\n    function _claimOwner(address claimer_) internal {\\n        _owner = claimer_;\\n        _nominee = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IT2BRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title IT2BRouter\\n * @notice Interface for T2B Router.\\n * @dev functions can be added here for invocation from external contracts or off-chain\\n * @author Socket dot tech.\\n */\\nabstract contract IT2BRouter {\\n    // tokenlist in IT2BRouter\\n    address[] public supportedTokens;\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/T2BRouter.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\nimport \\\"./utils/Ownable.sol\\\";\\nimport \\\"./T2BApproval.sol\\\";\\nimport \\\"./interfaces/IT2BRequest.sol\\\";\\nimport {SafeTransferLib} from \\\"lib/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {ERC20} from \\\"lib/solmate/src/tokens/ERC20.sol\\\";\\nimport \\\"lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\ncontract T2BRouter is Ownable {\\n    using SafeTransferLib for ERC20;\\n\\n    // Errors\\n    error VerificationCallFailed();\\n    error InvalidTokenAddress();\\n    error BalanceMismatch();\\n    error BridgingFailed();\\n    error UnsupportedBridge();\\n    error ZeroAddress();\\n    error SignerMismatch();\\n    error InvalidNonce();\\n\\n    /**\\n     * @dev The address used to identify ETH.\\n     */\\n    address public constant ETH_ADDRESS =\\n        address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\n\\n    // Socket Gateway.\\n    address public immutable socketGateway;\\n\\n    address public feeTakerAddress;\\n\\n    address[] public supportedTokens;\\n\\n    address public signerAddress;\\n\\n    // mapping of routeids against verifier contracts\\n    mapping(uint32 => address) public bridgeVerifiers;\\n\\n    // nonce used in fee update signatures\\n    mapping(address => uint256) public nextNonce;\\n\\n    // Constructor\\n    constructor(\\n        address _owner,\\n        address _socketGateway,\\n        address _feeTakerAddress\\n    ) Ownable(_owner) {\\n        socketGateway = _socketGateway;\\n        feeTakerAddress = _feeTakerAddress;\\n    }\\n\\n    // Set the t2b factory address\\n    function setFeeTakerAddress(address _feeTakerAddress) external onlyOwner {\\n        feeTakerAddress = _feeTakerAddress;\\n    }\\n\\n    // Set the signer address\\n    function setSignerAddress(address _signerAddress) external onlyOwner {\\n        signerAddress = _signerAddress;\\n    }\\n\\n    // Set bridge verifier contract address against routeId\\n    function setBridgeVerifier(\\n        uint32 routeId,\\n        address bridgeVerifier\\n    ) external onlyOwner {\\n        bridgeVerifiers[routeId] = bridgeVerifier;\\n    }\\n\\n    // function to add tokens to supportedTokens\\n    function setSupportedTokens(address[] memory _tokens) external onlyOwner {\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            supportedTokens.push(_tokens[i]);\\n        }\\n        supportedTokens.push(address(0));\\n    }\\n\\n    // function to empty supported tokens array\\n    function emptyTokenList() external onlyOwner {\\n        address[] memory emptyList;\\n        supportedTokens = emptyList;\\n    }\\n\\n    // Function that bridges taking amount from the t2bAddress where the user funds are parked.\\n    function bridgeERC20(\\n        uint256 fees,\\n        uint256 nonce,\\n        bytes calldata bridgeData,\\n        bytes calldata signature\\n    ) external {\\n        // recovering signer.\\n        address recoveredSigner = ECDSA.recover(\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                    keccak256(\\n                        abi.encode(\\n                            address(this),\\n                            nonce,\\n                            block.chainid, // uint256\\n                            fees,\\n                            bridgeData\\n                        )\\n                    )\\n                )\\n            ),\\n            signature\\n        );\\n\\n        if (signerAddress != recoveredSigner) revert SignerMismatch();\\n        // nonce is used by gated roles and we don't expect nonce to reach the max value of uint256\\n        unchecked {\\n            if (nonce != nextNonce[signerAddress]++) revert InvalidNonce();\\n        }\\n\\n        if (bridgeVerifiers[uint32(bytes4(bridgeData[0:4]))] == address(0))\\n            revert UnsupportedBridge();\\n        (bool parseSuccess, bytes memory parsedData) = bridgeVerifiers[\\n            uint32(bytes4(bridgeData[0:4]))\\n        ].call(bridgeData[4:bridgeData.length - 1]);\\n\\n        if (!parseSuccess) revert VerificationCallFailed();\\n\\n        IT2BRequest.T2BRequest memory t2bRequest = abi.decode(\\n            parsedData,\\n            (IT2BRequest.T2BRequest)\\n        );\\n        address t2bAddress = getAddressFor(\\n            t2bRequest.recipient,\\n            t2bRequest.toChainId\\n        );\\n        if (\\n            ERC20(t2bRequest.token).allowance(t2bAddress, address(this)) <\\n            t2bRequest.amount\\n        ) {\\n            bytes32 uniqueSalt = keccak256(\\n                abi.encode(t2bRequest.recipient, t2bRequest.toChainId)\\n            );\\n            new T2BApproval{salt: uniqueSalt}(address(this));\\n        }\\n\\n        ERC20(t2bRequest.token).safeTransferFrom(\\n            t2bAddress,\\n            address(this),\\n            t2bRequest.amount + fees\\n        );\\n\\n        if (fees > 0)\\n            ERC20(t2bRequest.token).safeTransfer(feeTakerAddress, fees);\\n\\n        if (\\n            t2bRequest.amount >\\n            ERC20(t2bRequest.token).allowance(address(this), socketGateway)\\n        ) {\\n            ERC20(t2bRequest.token).safeApprove(\\n                address(socketGateway),\\n                type(uint256).max\\n            );\\n        }\\n\\n        (bool bridgeSuccess, ) = socketGateway.call(bridgeData);\\n\\n        if (!bridgeSuccess) revert BridgingFailed();\\n    }\\n\\n    function deployApprovalContract(\\n        address receiver,\\n        uint256 toChainId\\n    ) public returns (address approvalAddress) {\\n        bytes32 uniqueSalt = keccak256(abi.encode(receiver, toChainId));\\n        approvalAddress = address(new T2BApproval{salt: uniqueSalt}(address(this)));\\n    }\\n\\n    function getAddressFor(\\n        address receiver,\\n        uint256 toChainId\\n    ) public view returns (address) {\\n        bytes32 salt = keccak256(abi.encode(receiver, toChainId));\\n        return\\n            address(\\n                uint160(\\n                    uint256(\\n                        keccak256(\\n                            abi.encodePacked(\\n                                bytes1(0xff),\\n                                address(this),\\n                                salt,\\n                                keccak256(\\n                                    abi.encodePacked(\\n                                        type(T2BApproval).creationCode,\\n                                        abi.encode(address(this))\\n                                    )\\n                                )\\n                            )\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n\\n    /*******************************************\\n     *          RESTRICTED RESCUE FUNCTION    *\\n     *******************************************/\\n\\n    /**\\n     * @dev Rescues funds from a contract.\\n     * @param token_ The address of the token contract.\\n     * @param userAddress_ The address of the user.\\n     * @param amount_ The amount of tokens to be rescued.\\n     */\\n    function rescueFunds(\\n        address token_,\\n        address userAddress_,\\n        uint256 amount_\\n    ) external onlyOwner {\\n        if (userAddress_ == address(0)) revert ZeroAddress();\\n\\n        if (token_ == ETH_ADDRESS) {\\n            SafeTransferLib.safeTransferETH(userAddress_, amount_);\\n        } else {\\n            if (token_.code.length == 0) revert InvalidTokenAddress();\\n            SafeTransferLib.safeTransfer(ERC20(token_), userAddress_, amount_);\\n        }\\n    }\\n\\n    function rescueFromT2BReceiver(\\n        address t2bReceiver_,\\n        address token_,\\n        address userAddress_,\\n        uint256 amount_\\n    ) external onlyOwner {\\n        if (userAddress_ == address(0)) revert ZeroAddress();\\n        if (token_.code.length == 0) revert InvalidTokenAddress();\\n        SafeTransferLib.safeTransferFrom(\\n            ERC20(token_),\\n            t2bReceiver_,\\n            userAddress_,\\n            amount_\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IT2BRequest.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\ninterface IT2BRequest {\\n    struct T2BRequest {\\n        uint256 amount;\\n        address recipient;\\n        uint256 toChainId;\\n        address token;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/bridgeVerifiers/SynapseVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\nimport \\\"../interfaces/ISynapseImpl.sol\\\";\\n\\ncontract SynapseVerifier {\\n    address NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    function bridgeERC20To(\\n        uint256 amount,\\n        bytes32 metadata,\\n        address receiverAddress,\\n        address token,\\n        uint256 toChainId,\\n        ISynapseImpl.SwapQuery calldata originQuery,\\n        ISynapseImpl.SwapQuery calldata destinationQuery\\n    ) external payable returns (ISynapseImpl.T2BRequest memory) {\\n        return\\n            ISynapseImpl.T2BRequest(amount, receiverAddress, toChainId, token);\\n    }\\n\\n    function bridgeNativeTo(\\n        uint256 amount,\\n        bytes32 metadata,\\n        address receiverAddress,\\n        uint256 toChainId,\\n        ISynapseImpl.SwapQuery calldata originQuery,\\n        ISynapseImpl.SwapQuery calldata destinationQuery\\n    ) external view returns (ISynapseImpl.T2BRequest memory) {\\n        return\\n            ISynapseImpl.T2BRequest(\\n                amount,\\n                receiverAddress,\\n                toChainId,\\n                NATIVE_TOKEN_ADDRESS\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISynapseImpl.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\ninterface ISynapseImpl {\\n    struct SwapQuery {\\n        address swapAdapter;\\n        address tokenOut;\\n        uint256 minAmountOut;\\n        uint256 deadline;\\n        bytes rawParams;\\n    }\\n\\n    struct T2BRequest {\\n        uint256 amount;\\n        address recipient;\\n        uint256 toChainId;\\n        address token;\\n    }\\n\\n    function bridgeERC20To(\\n        uint256 amount,\\n        bytes32 metadata,\\n        address receiverAddress,\\n        address token,\\n        uint256 toChainId,\\n        SwapQuery calldata originQuery,\\n        SwapQuery calldata destinationQuery\\n    ) external view returns (T2BRequest memory);\\n\\n    function bridgeNativeTo(\\n        uint256 amount,\\n        bytes32 metadata,\\n        address receiverAddress,\\n        uint256 toChainId,\\n        SwapQuery calldata originQuery,\\n        SwapQuery calldata destinationQuery\\n    ) external view returns (T2BRequest memory);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"metadata\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"toChainId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"swapAdapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"internalType\":\"struct ISynapseImpl.SwapQuery\",\"name\":\"originQuery\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"swapAdapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"internalType\":\"struct ISynapseImpl.SwapQuery\",\"name\":\"destinationQuery\",\"type\":\"tuple\"}],\"name\":\"bridgeERC20To\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"toChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct ISynapseImpl.T2BRequest\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"metadata\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"toChainId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"swapAdapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"internalType\":\"struct ISynapseImpl.SwapQuery\",\"name\":\"originQuery\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"swapAdapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"internalType\":\"struct ISynapseImpl.SwapQuery\",\"name\":\"destinationQuery\",\"type\":\"tuple\"}],\"name\":\"bridgeNativeTo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"toChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct ISynapseImpl.T2BRequest\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SynapseVerifier", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}