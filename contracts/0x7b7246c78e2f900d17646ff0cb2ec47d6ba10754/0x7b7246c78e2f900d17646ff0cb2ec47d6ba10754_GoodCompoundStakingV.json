{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/staking/compound/GoodCompoundStakingV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\nimport \\\"../SimpleStakingV2.sol\\\";\\nimport \\\"../../Interfaces.sol\\\";\\nimport \\\"../UniswapV2SwapHelper.sol\\\";\\n\\n/**\\n * @title Staking contract that donates earned interest to the DAO\\n * allowing stakers to deposit Token\\n * or withdraw their stake in Token\\n * the contracts buy cToken and can transfer the daily interest to the  DAO\\n */\\ncontract GoodCompoundStakingV2 is SimpleStakingV2 {\\n\\tusing UniswapV2SwapHelper for IHasRouter;\\n\\n\\t// Address of the TOKEN/USD oracle from chainlink\\n\\taddress tokenUsdOracle;\\n\\t//Address of the COMP/USD oracle from chianlink\\n\\taddress compUsdOracle;\\n\\n\\t// Gas cost to collect interest from this staking contract\\n\\tuint32 collectInterestGasCost;\\n\\t// Gas cost to collect COMP rewards\\n\\tuint32 compCollectGasCost;\\n\\n\\taddress[] tokenToDaiSwapPath;\\n\\n\\tERC20 comp;\\n\\n\\tUniswap uniswapContract;\\n\\n\\tfunction getSettings()\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint32 _collectInterestGasCost, uint32 _compCollectGasCost)\\n\\t{\\n\\t\\treturn (collectInterestGasCost, compCollectGasCost);\\n\\t}\\n\\n\\t/**\\n\\t * @param _token Token to swap DEFI token\\n\\t * @param _iToken DEFI token address\\n\\t * @param _ns Address of the NameService\\n\\t * @param _tokenName Name of the staking token which will be provided to staker for their staking share\\n\\t * @param _tokenSymbol Symbol of the staking token which will be provided to staker for their staking share\\n\\t * @param _maxRewardThreshold Determines blocks to pass for 1x Multiplier\\n\\t * @param _tokenUsdOracle address of the TOKEN/USD oracle\\n\\t * @param _compUsdOracle address of the COMP/USD oracle\\n\\t * @param _tokenToDaiSwapPath the uniswap path to swap token to DAI, should be empty if token is DAI\\n\\t */\\n\\tfunction init(\\n\\t\\taddress _token,\\n\\t\\taddress _iToken,\\n\\t\\tINameService _ns,\\n\\t\\tstring memory _tokenName,\\n\\t\\tstring memory _tokenSymbol,\\n\\t\\tuint64 _maxRewardThreshold,\\n\\t\\taddress _tokenUsdOracle,\\n\\t\\taddress _compUsdOracle,\\n\\t\\taddress[] memory _tokenToDaiSwapPath\\n\\t) public {\\n\\t\\tinitialize(\\n\\t\\t\\t_token,\\n\\t\\t\\t_iToken,\\n\\t\\t\\t_ns,\\n\\t\\t\\t_tokenName,\\n\\t\\t\\t_tokenSymbol,\\n\\t\\t\\t_maxRewardThreshold\\n\\t\\t);\\n\\n\\t\\taddress dai = nameService.getAddress(\\\"DAI\\\");\\n\\t\\trequire(\\n\\t\\t\\t_token == dai ||\\n\\t\\t\\t\\t(_tokenToDaiSwapPath[0] == _token &&\\n\\t\\t\\t\\t\\t_tokenToDaiSwapPath[_tokenToDaiSwapPath.length - 1] == dai),\\n\\t\\t\\t\\\"path\\\"\\n\\t\\t);\\n\\n\\t\\t//above  initialize going  to revert on second call, so this is safe\\n\\t\\tcompUsdOracle = _compUsdOracle;\\n\\t\\ttokenUsdOracle = _tokenUsdOracle;\\n\\t\\ttokenToDaiSwapPath = _tokenToDaiSwapPath;\\n\\t\\tcomp = ERC20(nameService.getAddress(\\\"COMP\\\"));\\n\\t\\tuniswapContract = Uniswap(nameService.getAddress(\\\"UNISWAP_ROUTER\\\"));\\n\\t\\tcollectInterestGasCost = 250000;\\n\\t\\tcompCollectGasCost = 150000;\\n\\t\\tcomp.approve(address(uniswapContract), type(uint256).max);\\n\\t\\ttoken.approve(address(uniswapContract), type(uint256).max);\\n\\t\\ttoken.approve(address(iToken), type(uint256).max); // approve the transfers to defi protocol as much as possible in order to save gas\\n\\t}\\n\\n\\t/**\\n\\t * @dev stake some Token\\n\\t * @param _amount of Token to stake\\n\\t */\\n\\tfunction mintInterestToken(uint256 _amount) internal override {\\n\\t\\trequire(cERC20(address(iToken)).mint(_amount) == 0, \\\"minting\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev redeem Token from compound\\n\\t * @param _amount of token to redeem in Token\\n\\t */\\n\\tfunction redeem(uint256 _amount) internal override {\\n\\t\\trequire(cERC20(address(iToken)).redeemUnderlying(_amount) == 0, \\\"redeem\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev Function to redeem cToken + reward COMP for DAI, so reserve knows how to handle it. (reserve can handle dai or cdai)\\n\\t * @dev _amount of token in iToken\\n\\t * @dev _recipient recipient of the DAI\\n\\t * @return actualTokenGains amount of token redeemed for dai,\\n\\t\\t\\tactualRewardTokenGains amount of reward token redeemed for dai,\\n\\t\\t\\tdaiAmount total dai received\\n\\t */\\n\\tfunction redeemUnderlyingToDAI(uint256 _amount, address _recipient)\\n\\t\\tinternal\\n\\t\\toverride\\n\\t\\treturns (\\n\\t\\t\\tuint256 actualTokenGains,\\n\\t\\t\\tuint256 actualRewardTokenGains,\\n\\t\\t\\tuint256 daiAmount\\n\\t\\t)\\n\\t{\\n\\t\\tuint256 compBalance = comp.balanceOf(address(this));\\n\\n\\t\\tuint256 redeemedDAI;\\n\\n\\t\\tif (compBalance > 0) {\\n\\t\\t\\taddress[] memory compToDaiSwapPath = new address[](3);\\n\\t\\t\\tcompToDaiSwapPath[0] = address(comp);\\n\\t\\t\\tcompToDaiSwapPath[1] = uniswapContract.WETH();\\n\\t\\t\\tcompToDaiSwapPath[2] = nameService.getAddress(\\\"DAI\\\");\\n\\t\\t\\tactualRewardTokenGains = IHasRouter(this).maxSafeTokenAmount(\\n\\t\\t\\t\\taddress(comp),\\n\\t\\t\\t\\tuniswapContract.WETH(),\\n\\t\\t\\t\\tcompBalance,\\n\\t\\t\\t\\tmaxLiquidityPercentageSwap\\n\\t\\t\\t);\\n\\n\\t\\t\\tredeemedDAI = IHasRouter(this).swap(\\n\\t\\t\\t\\tcompToDaiSwapPath,\\n\\t\\t\\t\\tactualRewardTokenGains,\\n\\t\\t\\t\\t0,\\n\\t\\t\\t\\t_recipient\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\t//in case of cdai there's no need to swap to DAI, we send cdai to reserve directly\\n\\t\\tactualTokenGains = iTokenWorthInToken(_amount);\\n\\t\\tif (address(iToken) == nameService.getAddress(\\\"CDAI\\\")) {\\n\\t\\t\\trequire(iToken.transfer(_recipient, _amount), \\\"collect\\\");\\n\\t\\t\\treturn (\\n\\t\\t\\t\\tactualTokenGains,\\n\\t\\t\\t\\tactualRewardTokenGains,\\n\\t\\t\\t\\tactualTokenGains + redeemedDAI\\n\\t\\t\\t); // If iToken is cDAI then just return cDAI\\n\\t\\t}\\n\\n\\t\\t//out of requested interests to withdraw how much is it safe to swap\\n\\t\\tuint256 safeAmount = IHasRouter(this).maxSafeTokenAmount(\\n\\t\\t\\taddress(token),\\n\\t\\t\\ttokenToDaiSwapPath[1],\\n\\t\\t\\tactualTokenGains,\\n\\t\\t\\tmaxLiquidityPercentageSwap\\n\\t\\t);\\n\\n\\t\\tif (actualTokenGains > safeAmount) {\\n\\t\\t\\tactualTokenGains = safeAmount;\\n\\t\\t\\t//recalculate how much iToken to redeem\\n\\t\\t\\t_amount = tokenWorthIniToken(actualTokenGains);\\n\\t\\t}\\n\\n\\t\\trequire(cERC20(address(iToken)).redeem(_amount) == 0, \\\"iredeem\\\");\\n\\n\\t\\tactualTokenGains = token.balanceOf(address(this));\\n\\n\\t\\tif (actualTokenGains > 0) {\\n\\t\\t\\tredeemedDAI += IHasRouter(this).swap(\\n\\t\\t\\t\\ttokenToDaiSwapPath,\\n\\t\\t\\t\\tactualTokenGains,\\n\\t\\t\\t\\t0,\\n\\t\\t\\t\\t_recipient\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\treturn (actualTokenGains, actualRewardTokenGains, redeemedDAI);\\n\\t}\\n\\n\\t/**\\n\\t * @dev returns decimals of token.\\n\\t */\\n\\tfunction tokenDecimal() internal view override returns (uint256) {\\n\\t\\treturn uint256(ERC20(address(token)).decimals());\\n\\t}\\n\\n\\t/**\\n\\t * @dev returns decimals of interest token.\\n\\t */\\n\\tfunction iTokenDecimal() internal view override returns (uint256) {\\n\\t\\treturn uint256(ERC20(address(iToken)).decimals());\\n\\t}\\n\\n\\t/**\\n\\t * @dev Function that calculates current interest gains of this staking contract\\n\\t * @param _returnTokenBalanceInUSD determine return token balance of staking contract in USD\\n\\t * @param _returnTokenGainsInUSD determine return token gains of staking contract in USD\\n\\t * @return  iTokenGains gains in itoken, tokenGains gains in token, tokenBalance total locked Tokens, balanceInUsd locked tokens worth in USD, tokenGainsInUSD token Gains in USD\\n\\t */\\n\\tfunction currentGains(\\n\\t\\tbool _returnTokenBalanceInUSD,\\n\\t\\tbool _returnTokenGainsInUSD\\n\\t)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\toverride\\n\\t\\treturns (\\n\\t\\t\\tuint256 iTokenGains,\\n\\t\\t\\tuint256 tokenGains,\\n\\t\\t\\tuint256 tokenBalance,\\n\\t\\t\\tuint256 balanceInUSD,\\n\\t\\t\\tuint256 tokenGainsInUSD\\n\\t\\t)\\n\\t{\\n\\t\\ttokenBalance = iTokenWorthInToken(iToken.balanceOf(address(this)));\\n\\t\\tbalanceInUSD = _returnTokenBalanceInUSD\\n\\t\\t\\t? getTokenValueInUSD(tokenUsdOracle, tokenBalance, token.decimals())\\n\\t\\t\\t: 0;\\n\\t\\tuint256 compValueInUSD = _returnTokenGainsInUSD\\n\\t\\t\\t? getTokenValueInUSD(\\n\\t\\t\\t\\tcompUsdOracle,\\n\\t\\t\\t\\tcomp.balanceOf(address(this)),\\n\\t\\t\\t\\t18 // COMP is in 18 decimal\\n\\t\\t\\t)\\n\\t\\t\\t: 0;\\n\\t\\tif (tokenBalance <= totalProductivity) {\\n\\t\\t\\treturn (0, 0, tokenBalance, balanceInUSD, compValueInUSD);\\n\\t\\t}\\n\\n\\t\\ttokenGains = tokenBalance - totalProductivity;\\n\\t\\ttokenGainsInUSD = _returnTokenGainsInUSD\\n\\t\\t\\t? getTokenValueInUSD(tokenUsdOracle, tokenGains, token.decimals()) +\\n\\t\\t\\t\\tcompValueInUSD\\n\\t\\t\\t: 0;\\n\\n\\t\\tiTokenGains = tokenWorthIniToken(tokenGains);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Function to get interest transfer cost for this particular staking contract\\n\\t */\\n\\tfunction getGasCostForInterestTransfer()\\n\\t\\texternal\\n\\t\\tview\\n\\t\\toverride\\n\\t\\treturns (uint32)\\n\\t{\\n\\t\\tuint256 compBalance = comp.balanceOf(address(this));\\n\\t\\tif (compBalance > 0) return collectInterestGasCost + 200000; // need to make more check for this value\\n\\n\\t\\treturn collectInterestGasCost;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Calculates worth of given amount of iToken in Token\\n\\t * @param _amount Amount of token to calculate worth in Token\\n\\t * @return Worth of given amount of token in Token\\n\\t */\\n\\tfunction iTokenWorthInToken(uint256 _amount)\\n\\t\\tinternal\\n\\t\\tview\\n\\t\\toverride\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\tuint256 er = cERC20(address(iToken)).exchangeRateStored();\\n\\t\\t(uint256 decimalDifference, bool caseType) = tokenDecimalPrecision();\\n\\t\\tuint256 mantissa = 18 + tokenDecimal() - iTokenDecimal();\\n\\t\\tuint256 tokenWorth = caseType == true\\n\\t\\t\\t? (_amount * (10**decimalDifference) * er) / 10**mantissa\\n\\t\\t\\t: ((_amount / (10**decimalDifference)) * er) / 10**mantissa; // calculation based on https://compound.finance/docs#protocol-math\\n\\t\\treturn tokenWorth;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Calculates worth of given amount of token in iToken\\n\\t * @param _amount Amount of iToken to calculate worth in token\\n\\t * @return tokenWorth Worth of given amount of token in iToken\\n\\t */\\n\\tfunction tokenWorthIniToken(uint256 _amount)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\treturns (uint256 tokenWorth)\\n\\t{\\n\\t\\tuint256 er = cERC20(address(iToken)).exchangeRateStored();\\n\\t\\t(uint256 decimalDifference, bool caseType) = tokenDecimalPrecision();\\n\\t\\tuint256 mantissa = 18 + tokenDecimal() - iTokenDecimal();\\n\\t\\ttokenWorth = caseType == true\\n\\t\\t\\t? ((_amount / (10**decimalDifference)) * 10**mantissa) / er\\n\\t\\t\\t: ((_amount * (10**decimalDifference)) * 10**mantissa) / er; // calculation based on https://compound.finance/docs#protocol-math\\n\\t}\\n\\n\\t/**\\n\\t * @dev Set Gas cost to interest collection for this contract\\n\\t * @param _collectInterestGasCost Gas cost to collect interest\\n\\t * @param _rewardTokenCollectCost gas cost to collect reward tokens\\n\\t */\\n\\tfunction setcollectInterestGasCostParams(\\n\\t\\tuint32 _collectInterestGasCost,\\n\\t\\tuint32 _rewardTokenCollectCost\\n\\t) external {\\n\\t\\t_onlyAvatar();\\n\\t\\tcollectInterestGasCost = _collectInterestGasCost;\\n\\t\\tcompCollectGasCost = _rewardTokenCollectCost;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/staking/SimpleStakingV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport \\\"../Interfaces.sol\\\";\\nimport \\\"../DAOStackInterfaces.sol\\\";\\nimport \\\"../utils/NameService.sol\\\";\\nimport \\\"../utils/DAOContract.sol\\\";\\nimport \\\"./GoodFundManager.sol\\\";\\nimport \\\"./BaseShareFieldV2.sol\\\";\\nimport \\\"../governance/StakersDistribution.sol\\\";\\nimport \\\"./UniswapV2SwapHelper.sol\\\";\\n\\n/**\\n * @title Staking contract that donates earned interest to the DAO\\n * allowing stakers to deposit Tokens\\n * or withdraw their stake in Tokens\\n * the FundManager can request to receive the interest\\n */\\nabstract contract SimpleStakingV2 is\\n\\tERC20Upgradeable,\\n\\tDAOContract,\\n\\tBaseShareFieldV2,\\n\\tReentrancyGuardUpgradeable,\\n\\tIHasRouter\\n{\\n\\t// Token address\\n\\tERC20 public token;\\n\\t// Interest Token address\\n\\tERC20 public iToken;\\n\\n\\t// emergency pause\\n\\tbool public isPaused;\\n\\n\\t//max percentage of token/dai pool liquidity to swap to DAI when collecting interest out of 100000\\n\\tuint24 public maxLiquidityPercentageSwap = 300; //0.3%\\n\\n\\tuint256 public lockedUSDValue;\\n\\n\\t/**\\n\\t * @dev Emitted when `staker` stake `value` tokens of `token`\\n\\t */\\n\\tevent Staked(address indexed staker, address token, uint256 value);\\n\\n\\t/**\\n\\t * @dev Emitted when `staker` withdraws their stake `value` tokens and contracts balance will\\n\\t * be reduced to`remainingBalance`.\\n\\t */\\n\\tevent StakeWithdraw(address indexed staker, address token, uint256 value);\\n\\n\\t/**\\n\\t * @dev Emitted when fundmanager transfers intrest collected from defi protrocol.\\n\\t * `recipient` will receive `intrestTokenValue` as intrest.\\n\\t */\\n\\tevent InterestCollected(\\n\\t\\taddress recipient,\\n\\t\\tuint256 iTokenGains, // interest accrued\\n\\t\\tuint256 tokenGains, // interest worth in underlying token value\\n\\t\\tuint256 actualTokenRedeemed, //actual token redeemed in uniswap (max 0.3% of liquidity) to DAI\\n\\t\\tuint256 actualRewardTokenEarned, //actual reward token earned\\n\\t\\tuint256 interestCollectedInDAI //actual dai sent to the reserve as interest from converting token and optionally reward token in uniswap\\n\\t);\\n\\n\\t/**\\n\\t * @dev Constructor\\n\\t * @param _token The address of Token\\n\\t * @param _iToken The address of Interest Token\\n\\t * @param _ns The address of the INameService contract\\n\\t * @param _tokenName The name of the staking token\\n\\t * @param _tokenSymbol The symbol of the staking token\\n\\t * @param _maxRewardThreshold the blocks that should pass to get 1x reward multiplier\\n\\n\\t */\\n\\tfunction initialize(\\n\\t\\taddress _token,\\n\\t\\taddress _iToken,\\n\\t\\tINameService _ns,\\n\\t\\tstring memory _tokenName,\\n\\t\\tstring memory _tokenSymbol,\\n\\t\\tuint64 _maxRewardThreshold\\n\\t) public virtual initializer {\\n\\t\\tsetDAO(_ns);\\n\\t\\ttoken = ERC20(_token);\\n\\t\\tiToken = ERC20(_iToken);\\n\\t\\t__ERC20_init(_tokenName, _tokenSymbol);\\n\\t\\trequire(token.decimals() <= 18, \\\"decimals\\\");\\n\\t\\ttokenDecimalDifference = 18 - token.decimals();\\n\\t\\tmaxMultiplierThreshold = _maxRewardThreshold;\\n\\t}\\n\\n\\tfunction setMaxLiquidityPercentageSwap(uint24 _maxPercentage) public virtual {\\n\\t\\t_onlyAvatar();\\n\\t\\tmaxLiquidityPercentageSwap = _maxPercentage;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Calculates worth of given amount of iToken in Token\\n\\t * @param _amount Amount of iToken to calculate worth in Token\\n\\t * @return Worth of given amount of iToken in Token\\n\\t */\\n\\tfunction iTokenWorthInToken(uint256 _amount)\\n\\t\\tinternal\\n\\t\\tview\\n\\t\\tvirtual\\n\\t\\treturns (uint256);\\n\\n\\t/**\\n\\t * @dev Get gas cost for interest transfer so can be used in the calculation of collectable interest for particular gas amount\\n\\t * @return returns hardcoded gas cost\\n\\t */\\n\\tfunction getGasCostForInterestTransfer()\\n\\t\\texternal\\n\\t\\tview\\n\\t\\tvirtual\\n\\t\\treturns (uint32);\\n\\n\\t/**\\n\\t * @dev Returns decimal value for token.\\n\\t */\\n\\tfunction tokenDecimal() internal view virtual returns (uint256);\\n\\n\\t/**\\n\\t * @dev Returns decimal value for intrest token.\\n\\t */\\n\\tfunction iTokenDecimal() internal view virtual returns (uint256);\\n\\n\\t/**\\n\\t * @dev Redeem invested tokens from defi protocol.\\n\\t * @param _amount tokens to be redeemed.\\n\\t */\\n\\tfunction redeem(uint256 _amount) internal virtual;\\n\\n\\t/**\\n\\t * @dev Redeem invested underlying tokens from defi protocol and exchange into DAI\\n\\t * @param _amount tokens to be redeemed\\n\\t * @return amount of token swapped to dai, amount of reward token swapped to dai, total dai\\n\\t */\\n\\tfunction redeemUnderlyingToDAI(uint256 _amount, address _recipient)\\n\\t\\tinternal\\n\\t\\tvirtual\\n\\t\\treturns (\\n\\t\\t\\tuint256,\\n\\t\\t\\tuint256,\\n\\t\\t\\tuint256\\n\\t\\t);\\n\\n\\t/**\\n\\t * @dev Invests staked tokens to defi protocol.\\n\\t * @param _amount tokens staked.\\n\\t */\\n\\tfunction mintInterestToken(uint256 _amount) internal virtual;\\n\\n\\t/**\\n\\t * @dev Function that calculates current interest gains of this staking contract\\n\\t * @param _returnTokenBalanceInUSD determine return token balance of staking contract in USD\\n\\t * @param _returnTokenGainsInUSD determine return token gains of staking contract in USD\\n\\t * @return return gains in itoken,Token and worth of total locked Tokens,token balance in USD (8 decimals),token Gains in USD (8 decimals)\\n\\t */\\n\\tfunction currentGains(\\n\\t\\tbool _returnTokenBalanceInUSD,\\n\\t\\tbool _returnTokenGainsInUSD\\n\\t)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\tvirtual\\n\\t\\treturns (\\n\\t\\t\\tuint256,\\n\\t\\t\\tuint256,\\n\\t\\t\\tuint256,\\n\\t\\t\\tuint256,\\n\\t\\t\\tuint256\\n\\t\\t);\\n\\n\\t/**\\n\\t * @dev Allows a staker to deposit Tokens. Notice that `approve` is\\n\\t * needed to be executed before the execution of this method.\\n\\t * Can be executed only when the contract is not paused.\\n\\t * @param _amount The amount of Token or iToken to stake (it depends on _inInterestToken parameter)\\n\\t * @param _donationPer The % of interest staker want to donate.\\n\\t * @param _inInterestToken specificy if stake in iToken or Token\\n\\t */\\n\\tfunction stake(\\n\\t\\tuint256 _amount,\\n\\t\\tuint256 _donationPer,\\n\\t\\tbool _inInterestToken\\n\\t) external virtual nonReentrant {\\n\\t\\trequire(isPaused == false, \\\"Staking is paused\\\");\\n\\t\\trequire(_donationPer == 0 || _donationPer == 100, \\\"donationPer\\\");\\n\\t\\trequire(_amount > 0, \\\"amount\\\");\\n\\t\\trequire(\\n\\t\\t\\t(_inInterestToken ? iToken : token).transferFrom(\\n\\t\\t\\t\\t_msgSender(),\\n\\t\\t\\t\\taddress(this),\\n\\t\\t\\t\\t_amount\\n\\t\\t\\t),\\n\\t\\t\\t\\\"approve\\\"\\n\\t\\t);\\n\\t\\t_amount = _inInterestToken ? iTokenWorthInToken(_amount) : _amount;\\n\\t\\tif (_inInterestToken == false) {\\n\\t\\t\\tmintInterestToken(_amount); //mint iToken\\n\\t\\t}\\n\\t\\t_mint(_msgSender(), _amount); // mint Staking token for staker\\n\\t\\t(\\n\\t\\t\\tuint32 rewardsPerBlock,\\n\\t\\t\\tuint64 blockStart,\\n\\t\\t\\tuint64 blockEnd,\\n\\n\\t\\t) = GoodFundManager(nameService.getAddress(\\\"FUND_MANAGER\\\"))\\n\\t\\t\\t\\t.rewardsForStakingContract(address(this));\\n\\t\\t_increaseProductivity(\\n\\t\\t\\t_msgSender(),\\n\\t\\t\\t_amount,\\n\\t\\t\\trewardsPerBlock,\\n\\t\\t\\tblockStart,\\n\\t\\t\\tblockEnd,\\n\\t\\t\\t_donationPer\\n\\t\\t);\\n\\n\\t\\t(, , , uint256 lockedValueInUSD, ) = currentGains(true, false);\\n\\t\\tlockedUSDValue = lockedValueInUSD;\\n\\n\\t\\t//notify GDAO distrbution for stakers\\n\\t\\tStakersDistribution sd = StakersDistribution(\\n\\t\\t\\tnameService.getAddress(\\\"GDAO_STAKERS\\\")\\n\\t\\t);\\n\\t\\tif (address(sd) != address(0)) {\\n\\t\\t\\tsd.userStaked(_msgSender(), _convertValueTo18Decimals(_amount));\\n\\t\\t}\\n\\n\\t\\temit Staked(_msgSender(), address(token), _amount);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Withdraws the sender staked Token.\\n\\t * @param _amount Amount to withdraw in Token or iToken\\n\\t * @param _inInterestToken if true _amount is in iToken and also returned in iToken other wise use Token\\n\\t */\\n\\tfunction withdrawStake(uint256 _amount, bool _inInterestToken)\\n\\t\\texternal\\n\\t\\tvirtual\\n\\t\\tnonReentrant\\n\\t{\\n\\t\\tuint256 tokenWithdraw;\\n\\n\\t\\tif (_inInterestToken) {\\n\\t\\t\\tuint256 tokenWorth = iTokenWorthInToken(_amount);\\n\\t\\t\\trequire(iToken.transfer(_msgSender(), _amount), \\\"iWithdraw\\\");\\n\\t\\t\\ttokenWithdraw = _amount = tokenWorth;\\n\\t\\t} else {\\n\\t\\t\\ttokenWithdraw = _amount;\\n\\t\\t\\tredeem(tokenWithdraw);\\n\\n\\t\\t\\t//this is required for redeem precision loss\\n\\t\\t\\tuint256 tokenActual = token.balanceOf(address(this));\\n\\t\\t\\tif (tokenActual < tokenWithdraw) {\\n\\t\\t\\t\\ttokenWithdraw = tokenActual;\\n\\t\\t\\t}\\n\\t\\t\\trequire(token.transfer(_msgSender(), tokenWithdraw), \\\"withdraw\\\");\\n\\t\\t}\\n\\n\\t\\tGoodFundManager fm = GoodFundManager(\\n\\t\\t\\tnameService.getAddress(\\\"FUND_MANAGER\\\")\\n\\t\\t);\\n\\n\\t\\t(, , , uint256 lockedValueInUSD, ) = currentGains(true, false);\\n\\t\\tlockedUSDValue = lockedValueInUSD;\\n\\n\\t\\t//this will revert in case user doesnt have enough productivity to withdraw _amount, as productivity=staking tokens amount\\n\\t\\t_burn(msg.sender, _amount); // burn their staking tokens\\n\\n\\t\\t(uint32 rewardsPerBlock, uint64 blockStart, uint64 blockEnd, ) = fm\\n\\t\\t\\t.rewardsForStakingContract(address(this));\\n\\n\\t\\t_decreaseProductivity(\\n\\t\\t\\t_msgSender(),\\n\\t\\t\\t_amount,\\n\\t\\t\\trewardsPerBlock,\\n\\t\\t\\tblockStart,\\n\\t\\t\\tblockEnd\\n\\t\\t);\\n\\t\\tfm.mintReward(nameService.getAddress(\\\"CDAI\\\"), _msgSender()); // send rewards to user and use cDAI address since reserve in cDAI\\n\\n\\t\\t//notify GDAO distrbution for stakers\\n\\t\\tStakersDistribution sd = StakersDistribution(\\n\\t\\t\\tnameService.getAddress(\\\"GDAO_STAKERS\\\")\\n\\t\\t);\\n\\t\\tif (address(sd) != address(0)) {\\n\\t\\t\\tsd.userWithdraw(_msgSender(), _convertValueTo18Decimals(_amount));\\n\\t\\t}\\n\\n\\t\\temit StakeWithdraw(msg.sender, address(token), tokenWithdraw);\\n\\t}\\n\\n\\t/**\\n\\t * @dev withdraw staker G$ rewards + GDAO rewards\\n\\t * withdrawing rewards resets the multiplier! so if user just want GDAO he should use claimReputation()\\n\\t */\\n\\tfunction withdrawRewards() external nonReentrant {\\n\\t\\tGoodFundManager(nameService.getAddress(\\\"FUND_MANAGER\\\")).mintReward(\\n\\t\\t\\tnameService.getAddress(\\\"CDAI\\\"),\\n\\t\\t\\t_msgSender()\\n\\t\\t); // send rewards to user and use cDAI address since reserve in cDAI\\n\\t\\tclaimReputation();\\n\\t}\\n\\n\\t/**\\n\\t * @dev withdraw staker GDAO rewards\\n\\t */\\n\\tfunction claimReputation() public {\\n\\t\\t//claim reputation rewards\\n\\t\\tStakersDistribution sd = StakersDistribution(\\n\\t\\t\\tnameService.getAddress(\\\"GDAO_STAKERS\\\")\\n\\t\\t);\\n\\t\\tif (address(sd) != address(0)) {\\n\\t\\t\\taddress[] memory contracts = new address[](1);\\n\\t\\t\\tcontracts[0] = (address(this));\\n\\t\\t\\tsd.claimReputation(_msgSender(), contracts);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev notify stakersdistribution when user performs transfer operation\\n\\t */\\n\\tfunction _transfer(\\n\\t\\taddress _from,\\n\\t\\taddress _to,\\n\\t\\tuint256 _value\\n\\t) internal override {\\n\\t\\tsuper._transfer(_from, _to, _value);\\n\\t\\tStakersDistribution sd = StakersDistribution(\\n\\t\\t\\tnameService.getAddress(\\\"GDAO_STAKERS\\\")\\n\\t\\t);\\n\\t\\t(\\n\\t\\t\\tuint32 rewardsPerBlock,\\n\\t\\t\\tuint64 blockStart,\\n\\t\\t\\tuint64 blockEnd,\\n\\n\\t\\t) = GoodFundManager(nameService.getAddress(\\\"FUND_MANAGER\\\"))\\n\\t\\t\\t\\t.rewardsForStakingContract(address(this));\\n\\n\\t\\t_decreaseProductivity(_from, _value, rewardsPerBlock, blockStart, blockEnd);\\n\\n\\t\\t_increaseProductivity(\\n\\t\\t\\t_to,\\n\\t\\t\\t_value,\\n\\t\\t\\trewardsPerBlock,\\n\\t\\t\\tblockStart,\\n\\t\\t\\tblockEnd,\\n\\t\\t\\t0\\n\\t\\t);\\n\\n\\t\\tif (address(sd) != address(0)) {\\n\\t\\t\\tuint256 _convertedValue = _convertValueTo18Decimals(_value);\\n\\t\\t\\tsd.userWithdraw(_from, _convertedValue);\\n\\t\\t\\tsd.userStaked(_to, _convertedValue);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _convertValueTo18Decimals(uint256 _amount)\\n\\t\\tinternal\\n\\t\\tview\\n\\t\\treturns (uint256 amountInEighteenDecimals)\\n\\t{\\n\\t\\tamountInEighteenDecimals = token.decimals() == 18\\n\\t\\t\\t? _amount\\n\\t\\t\\t: _amount * 10**(18 - token.decimals());\\n\\t}\\n\\n\\t// @dev To find difference in token's decimal and iToken's decimal\\n\\t// @return difference in decimals.\\n\\t// @return true if token's decimal is more than iToken's\\n\\tfunction tokenDecimalPrecision() internal view returns (uint256, bool) {\\n\\t\\tuint256 _tokenDecimal = tokenDecimal();\\n\\t\\tuint256 _iTokenDecimal = iTokenDecimal();\\n\\t\\tuint256 decimalDifference = _tokenDecimal > _iTokenDecimal\\n\\t\\t\\t? _tokenDecimal - _iTokenDecimal\\n\\t\\t\\t: _iTokenDecimal - _tokenDecimal;\\n\\t\\treturn (decimalDifference, _tokenDecimal > _iTokenDecimal);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Collects gained interest by fundmanager.\\n\\t * @param _recipient The recipient of cDAI gains\\n\\t * @return actualTokenRedeemed  actualRewardTokenRedeemed actualDai collected interest from token,\\n\\t * collected interest from reward token, total DAI received from swapping token+reward token\\n\\t */\\n\\tfunction collectUBIInterest(address _recipient)\\n\\t\\tpublic\\n\\t\\tvirtual\\n\\t\\treturns (\\n\\t\\t\\tuint256 actualTokenRedeemed,\\n\\t\\t\\tuint256 actualRewardTokenRedeemed,\\n\\t\\t\\tuint256 actualDai\\n\\t\\t)\\n\\t{\\n\\t\\t_canMintRewards();\\n\\n\\t\\t(uint256 iTokenGains, uint256 tokenGains, , , ) = currentGains(\\n\\t\\t\\tfalse,\\n\\t\\t\\tfalse\\n\\t\\t);\\n\\n\\t\\t(\\n\\t\\t\\tactualTokenRedeemed,\\n\\t\\t\\tactualRewardTokenRedeemed,\\n\\t\\t\\tactualDai\\n\\t\\t) = redeemUnderlyingToDAI(iTokenGains, _recipient);\\n\\n\\t\\temit InterestCollected(\\n\\t\\t\\t_recipient,\\n\\t\\t\\tiTokenGains,\\n\\t\\t\\ttokenGains,\\n\\t\\t\\tactualTokenRedeemed,\\n\\t\\t\\tactualRewardTokenRedeemed,\\n\\t\\t\\tactualDai\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev making the contract inactive\\n\\t * NOTICE: this could theoretically result in future interest earned in cdai to remain locked\\n\\t */\\n\\tfunction pause(bool _isPaused) public {\\n\\t\\t_onlyAvatar();\\n\\t\\tisPaused = _isPaused;\\n\\t}\\n\\n\\t/**\\n\\t * @dev method to recover any stuck ERC20 tokens (ie  compound COMP)\\n\\t * @param _token the ERC20 token to recover\\n\\t */\\n\\tfunction recover(ERC20 _token) public {\\n\\t\\t_onlyAvatar();\\n\\t\\tuint256 toWithdraw = _token.balanceOf(address(this));\\n\\n\\t\\t// recover left iToken(stakers token) only when all stakes have been withdrawn\\n\\t\\tif (address(_token) == address(iToken)) {\\n\\t\\t\\trequire(totalProductivity == 0 && isPaused, \\\"recover\\\");\\n\\t\\t}\\n\\t\\trequire(_token.transfer(address(avatar), toWithdraw), \\\"transfer\\\");\\n\\t}\\n\\n\\t/**\\n\\t @dev function calculate Token price in USD\\n \\t @param _oracle chainlink oracle usd/token oralce\\n\\t @param _amount Amount of Token to calculate worth of it\\n\\t @param _decimals decimals of Token\\n\\t @return Returns worth of Tokens in USD\\n\\t */\\n\\tfunction getTokenValueInUSD(\\n\\t\\taddress _oracle,\\n\\t\\tuint256 _amount,\\n\\t\\tuint256 _decimals\\n\\t) public view returns (uint256) {\\n\\t\\tAggregatorV3Interface tokenPriceOracle = AggregatorV3Interface(_oracle);\\n\\t\\tint256 tokenPriceinUSD = tokenPriceOracle.latestAnswer();\\n\\t\\treturn (uint256(tokenPriceinUSD) * _amount) / (10**_decimals); // tokenPriceinUSD in 8 decimals and _amount is in Token's decimals so we divide it to Token's decimal at the end to reduce 8 decimals back\\n\\t}\\n\\n\\tfunction _canMintRewards() internal view override {\\n\\t\\trequire(_msgSender() == nameService.getAddress(\\\"FUND_MANAGER\\\"), \\\"fund\\\");\\n\\t}\\n\\n\\tfunction decimals() public view virtual override returns (uint8) {\\n\\t\\treturn token.decimals();\\n\\t}\\n\\n\\t/**\\n\\t * @param _staker account to get rewards status for\\n\\t * @return (minted, pending) in G$ 2 decimals\\n\\t */\\n\\tfunction getUserMintedAndPending(address _staker)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256, uint256)\\n\\t{\\n\\t\\t(\\n\\t\\t\\tuint32 rewardsPerBlock,\\n\\t\\t\\tuint64 blockStart,\\n\\t\\t\\tuint64 blockEnd,\\n\\n\\t\\t) = GoodFundManager(nameService.getAddress(\\\"FUND_MANAGER\\\"))\\n\\t\\t\\t\\t.rewardsForStakingContract(address(this));\\n\\n\\t\\tuint256 pending = getUserPendingReward(\\n\\t\\t\\t_staker,\\n\\t\\t\\trewardsPerBlock,\\n\\t\\t\\tblockStart,\\n\\t\\t\\tblockEnd\\n\\t\\t);\\n\\n\\t\\t//divide by 1e16 to return in 2 decimals\\n\\t\\treturn (users[_staker].rewardMinted / 1e16, pending / 1e16);\\n\\t}\\n\\n\\tfunction getRouter() public view override returns (Uniswap) {\\n\\t\\treturn Uniswap(nameService.getAddress(\\\"UNISWAP_ROUTER\\\"));\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\nimport { DataTypes } from \\\"./utils/DataTypes.sol\\\";\\npragma solidity >=0.8.0;\\n\\npragma experimental ABIEncoderV2;\\n\\ninterface ERC20 {\\n\\tfunction balanceOf(address addr) external view returns (uint256);\\n\\n\\tfunction transfer(address to, uint256 amount) external returns (bool);\\n\\n\\tfunction approve(address spender, uint256 amount) external returns (bool);\\n\\n\\tfunction decimals() external view returns (uint8);\\n\\n\\tfunction mint(address to, uint256 mintAmount) external returns (uint256);\\n\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\tfunction allowance(address owner, address spender)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256);\\n\\n\\tfunction transferFrom(\\n\\t\\taddress sender,\\n\\t\\taddress recipient,\\n\\t\\tuint256 amount\\n\\t) external returns (bool);\\n\\n\\tfunction name() external view returns (string memory);\\n\\n\\tfunction symbol() external view returns (string memory);\\n\\n\\tevent Transfer(address indexed from, address indexed to, uint256 amount);\\n\\tevent Transfer(\\n\\t\\taddress indexed from,\\n\\t\\taddress indexed to,\\n\\t\\tuint256 amount,\\n\\t\\tbytes data\\n\\t);\\n}\\n\\ninterface cERC20 is ERC20 {\\n\\tfunction mint(uint256 mintAmount) external returns (uint256);\\n\\n\\tfunction redeemUnderlying(uint256 mintAmount) external returns (uint256);\\n\\n\\tfunction redeem(uint256 mintAmount) external returns (uint256);\\n\\n\\tfunction exchangeRateCurrent() external returns (uint256);\\n\\n\\tfunction exchangeRateStored() external view returns (uint256);\\n\\n\\tfunction underlying() external returns (address);\\n}\\n\\ninterface IGoodDollar is ERC20 {\\n\\tfunction getFees(uint256 value) external view returns (uint256, bool);\\n\\n\\tfunction burn(uint256 amount) external;\\n\\n\\tfunction burnFrom(address account, uint256 amount) external;\\n\\n\\tfunction renounceMinter() external;\\n\\n\\tfunction addMinter(address minter) external;\\n\\n\\tfunction isMinter(address minter) external view returns (bool);\\n\\n\\tfunction transferAndCall(\\n\\t\\taddress to,\\n\\t\\tuint256 value,\\n\\t\\tbytes calldata data\\n\\t) external returns (bool);\\n\\n\\tfunction formula() external view returns (address);\\n}\\n\\ninterface IERC2917 is ERC20 {\\n\\t/// @dev This emit when interests amount per block is changed by the owner of the contract.\\n\\t/// It emits with the old interests amount and the new interests amount.\\n\\tevent InterestRatePerBlockChanged(uint256 oldValue, uint256 newValue);\\n\\n\\t/// @dev This emit when a users' productivity has changed\\n\\t/// It emits with the user's address and the the value after the change.\\n\\tevent ProductivityIncreased(address indexed user, uint256 value);\\n\\n\\t/// @dev This emit when a users' productivity has changed\\n\\t/// It emits with the user's address and the the value after the change.\\n\\tevent ProductivityDecreased(address indexed user, uint256 value);\\n\\n\\t/// @dev Return the current contract's interests rate per block.\\n\\t/// @return The amount of interests currently producing per each block.\\n\\tfunction interestsPerBlock() external view returns (uint256);\\n\\n\\t/// @notice Change the current contract's interests rate.\\n\\t/// @dev Note the best practice will be restrict the gross product provider's contract address to call this.\\n\\t/// @return The true/fase to notice that the value has successfully changed or not, when it succeed, it will emite the InterestRatePerBlockChanged event.\\n\\tfunction changeInterestRatePerBlock(uint256 value) external returns (bool);\\n\\n\\t/// @notice It will get the productivity of given user.\\n\\t/// @dev it will return 0 if user has no productivity proved in the contract.\\n\\t/// @return user's productivity and overall productivity.\\n\\tfunction getProductivity(address user)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256, uint256);\\n\\n\\t/// @notice increase a user's productivity.\\n\\t/// @dev Note the best practice will be restrict the callee to prove of productivity's contract address.\\n\\t/// @return true to confirm that the productivity added success.\\n\\tfunction increaseProductivity(address user, uint256 value)\\n\\t\\texternal\\n\\t\\treturns (bool);\\n\\n\\t/// @notice decrease a user's productivity.\\n\\t/// @dev Note the best practice will be restrict the callee to prove of productivity's contract address.\\n\\t/// @return true to confirm that the productivity removed success.\\n\\tfunction decreaseProductivity(address user, uint256 value)\\n\\t\\texternal\\n\\t\\treturns (bool);\\n\\n\\t/// @notice take() will return the interests that callee will get at current block height.\\n\\t/// @dev it will always calculated by block.number, so it will change when block height changes.\\n\\t/// @return amount of the interests that user are able to mint() at current block height.\\n\\tfunction take() external view returns (uint256);\\n\\n\\t/// @notice similar to take(), but with the block height joined to calculate return.\\n\\t/// @dev for instance, it returns (_amount, _block), which means at block height _block, the callee has accumulated _amount of interests.\\n\\t/// @return amount of interests and the block height.\\n\\tfunction takeWithBlock() external view returns (uint256, uint256);\\n\\n\\t/// @notice mint the avaiable interests to callee.\\n\\t/// @dev once it mint, the amount of interests will transfer to callee's address.\\n\\t/// @return the amount of interests minted.\\n\\tfunction mint() external returns (uint256);\\n}\\n\\ninterface Staking {\\n\\tstruct Staker {\\n\\t\\t// The staked DAI amount\\n\\t\\tuint256 stakedDAI;\\n\\t\\t// The latest block number which the\\n\\t\\t// staker has staked tokens\\n\\t\\tuint256 lastStake;\\n\\t}\\n\\n\\tfunction stakeDAI(uint256 amount) external;\\n\\n\\tfunction withdrawStake() external;\\n\\n\\tfunction stakers(address staker) external view returns (Staker memory);\\n}\\n\\ninterface Uniswap {\\n\\tfunction swapExactETHForTokens(\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external payable returns (uint256[] memory amounts);\\n\\n\\tfunction swapExactTokensForETH(\\n\\t\\tuint256 amountIn,\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external returns (uint256[] memory amounts);\\n\\n\\tfunction swapExactTokensForTokens(\\n\\t\\tuint256 amountIn,\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external returns (uint256[] memory amounts);\\n\\n\\tfunction WETH() external pure returns (address);\\n\\n\\tfunction factory() external pure returns (address);\\n\\n\\tfunction quote(\\n\\t\\tuint256 amountA,\\n\\t\\tuint256 reserveA,\\n\\t\\tuint256 reserveB\\n\\t) external pure returns (uint256 amountB);\\n\\n\\tfunction getAmountIn(\\n\\t\\tuint256 amountOut,\\n\\t\\tuint256 reserveIn,\\n\\t\\tuint256 reserveOut\\n\\t) external pure returns (uint256 amountIn);\\n\\n\\tfunction getAmountOut(\\n\\t\\tuint256 amountI,\\n\\t\\tuint256 reserveIn,\\n\\t\\tuint256 reserveOut\\n\\t) external pure returns (uint256 amountOut);\\n\\n\\tfunction getAmountsOut(uint256 amountIn, address[] memory path)\\n\\t\\texternal\\n\\t\\tpure\\n\\t\\treturns (uint256[] memory amounts);\\n}\\n\\ninterface UniswapFactory {\\n\\tfunction getPair(address tokenA, address tokenB)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (address);\\n}\\n\\ninterface UniswapPair {\\n\\tfunction getReserves()\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (\\n\\t\\t\\tuint112 reserve0,\\n\\t\\t\\tuint112 reserve1,\\n\\t\\t\\tuint32 blockTimestampLast\\n\\t\\t);\\n\\n\\tfunction kLast() external view returns (uint256);\\n\\n\\tfunction token0() external view returns (address);\\n\\n\\tfunction token1() external view returns (address);\\n\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\tfunction balanceOf(address owner) external view returns (uint256);\\n}\\n\\ninterface Reserve {\\n\\tfunction buy(\\n\\t\\taddress _buyWith,\\n\\t\\tuint256 _tokenAmount,\\n\\t\\tuint256 _minReturn\\n\\t) external returns (uint256);\\n}\\n\\ninterface IIdentity {\\n\\tfunction isWhitelisted(address user) external view returns (bool);\\n\\n\\tfunction addWhitelistedWithDID(address account, string memory did) external;\\n\\n\\tfunction removeWhitelisted(address account) external;\\n\\n\\tfunction addIdentityAdmin(address account) external returns (bool);\\n\\n\\tfunction setAvatar(address _avatar) external;\\n\\n\\tfunction isIdentityAdmin(address account) external view returns (bool);\\n\\n\\tfunction owner() external view returns (address);\\n\\n\\tevent WhitelistedAdded(address user);\\n}\\n\\ninterface IUBIScheme {\\n\\tfunction currentDay() external view returns (uint256);\\n\\n\\tfunction periodStart() external view returns (uint256);\\n\\n\\tfunction hasClaimed(address claimer) external view returns (bool);\\n}\\n\\ninterface IFirstClaimPool {\\n\\tfunction awardUser(address user) external returns (uint256);\\n\\n\\tfunction claimAmount() external view returns (uint256);\\n}\\n\\ninterface ProxyAdmin {\\n\\tfunction getProxyImplementation(address proxy)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (address);\\n\\n\\tfunction getProxyAdmin(address proxy) external view returns (address);\\n\\n\\tfunction upgrade(address proxy, address implementation) external;\\n\\n\\tfunction owner() external view returns (address);\\n\\n\\tfunction transferOwnership(address newOwner) external;\\n}\\n\\n/**\\n * @dev Interface for chainlink oracles to obtain price datas\\n */\\ninterface AggregatorV3Interface {\\n\\tfunction decimals() external view returns (uint8);\\n\\n\\tfunction description() external view returns (string memory);\\n\\n\\tfunction version() external view returns (uint256);\\n\\n\\t// getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n\\t// if they do not have data to report, instead of returning unset values\\n\\t// which could be misinterpreted as actual reported values.\\n\\tfunction getRoundData(uint80 _roundId)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (\\n\\t\\t\\tuint80 roundId,\\n\\t\\t\\tint256 answer,\\n\\t\\t\\tuint256 startedAt,\\n\\t\\t\\tuint256 updatedAt,\\n\\t\\t\\tuint80 answeredInRound\\n\\t\\t);\\n\\n\\tfunction latestAnswer() external view returns (int256);\\n}\\n\\n/**\\n\\t@dev interface for AAVE lending Pool\\n */\\ninterface ILendingPool {\\n\\t/**\\n\\t * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\n\\t * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\\n\\t * @param asset The address of the underlying asset to deposit\\n\\t * @param amount The amount to be deposited\\n\\t * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n\\t *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n\\t *   is a different wallet\\n\\t * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n\\t *   0 if the action is executed directly by the user, without any middle-man\\n\\t **/\\n\\tfunction deposit(\\n\\t\\taddress asset,\\n\\t\\tuint256 amount,\\n\\t\\taddress onBehalfOf,\\n\\t\\tuint16 referralCode\\n\\t) external;\\n\\n\\t/**\\n\\t * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\\n\\t * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\n\\t * @param asset The address of the underlying asset to withdraw\\n\\t * @param amount The underlying amount to be withdrawn\\n\\t *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\n\\t * @param to Address that will receive the underlying, same as msg.sender if the user\\n\\t *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n\\t *   different wallet\\n\\t * @return The final amount withdrawn\\n\\t **/\\n\\tfunction withdraw(\\n\\t\\taddress asset,\\n\\t\\tuint256 amount,\\n\\t\\taddress to\\n\\t) external returns (uint256);\\n\\n\\t/**\\n\\t * @dev Returns the state and configuration of the reserve\\n\\t * @param asset The address of the underlying asset of the reserve\\n\\t * @return The state of the reserve\\n\\t **/\\n\\tfunction getReserveData(address asset)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (DataTypes.ReserveData memory);\\n}\\n\\ninterface IDonationStaking {\\n\\tfunction stakeDonations() external payable;\\n}\\n\\ninterface INameService {\\n\\tfunction getAddress(string memory _name) external view returns (address);\\n}\\n\\ninterface IAaveIncentivesController {\\n\\t/**\\n\\t * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\\n\\t * @param amount Amount of rewards to claim\\n\\t * @param to Address that will be receiving the rewards\\n\\t * @return Rewards claimed\\n\\t **/\\n\\tfunction claimRewards(\\n\\t\\taddress[] calldata assets,\\n\\t\\tuint256 amount,\\n\\t\\taddress to\\n\\t) external returns (uint256);\\n\\n\\t/**\\n\\t * @dev Returns the total of rewards of an user, already accrued + not yet accrued\\n\\t * @param user The address of the user\\n\\t * @return The rewards\\n\\t **/\\n\\tfunction getRewardsBalance(address[] calldata assets, address user)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256);\\n}\\n\\ninterface IGoodStaking {\\n\\tfunction collectUBIInterest(address recipient)\\n\\t\\texternal\\n\\t\\treturns (\\n\\t\\t\\tuint256,\\n\\t\\t\\tuint256,\\n\\t\\t\\tuint256\\n\\t\\t);\\n\\n\\tfunction iToken() external view returns (address);\\n\\n\\tfunction currentGains(\\n\\t\\tbool _returnTokenBalanceInUSD,\\n\\t\\tbool _returnTokenGainsInUSD\\n\\t)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (\\n\\t\\t\\tuint256,\\n\\t\\t\\tuint256,\\n\\t\\t\\tuint256,\\n\\t\\t\\tuint256,\\n\\t\\t\\tuint256\\n\\t\\t);\\n\\n\\tfunction getRewardEarned(address user) external view returns (uint256);\\n\\n\\tfunction getGasCostForInterestTransfer() external view returns (uint256);\\n\\n\\tfunction rewardsMinted(\\n\\t\\taddress user,\\n\\t\\tuint256 rewardsPerBlock,\\n\\t\\tuint256 blockStart,\\n\\t\\tuint256 blockEnd\\n\\t) external returns (uint256);\\n}\\n\\ninterface IHasRouter {\\n\\tfunction getRouter() external view returns (Uniswap);\\n}\\n\\ninterface IAdminWallet {\\n\\tfunction addAdmins(address payable[] memory _admins) external;\\n\\n\\tfunction removeAdmins(address[] memory _admins) external;\\n\\n\\tfunction owner() external view returns (address);\\n\\n\\tfunction transferOwnership(address _owner) external;\\n}\\n\"\r\n    },\r\n    \"contracts/staking/UniswapV2SwapHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\nimport \\\"../utils/DAOContract.sol\\\";\\nimport \\\"../Interfaces.sol\\\";\\n\\nlibrary UniswapV2SwapHelper {\\n\\t/**\\n\\t *@dev Helper to calculate percentage out of token liquidity in pool that is safe to exchange against sandwich attack.\\n\\t * also checks if token->eth has better safe limit, so perhaps doing tokenA->eth->tokenB is better than tokenA->tokenB\\n\\t * in that case it could be that eth->tokenB can be attacked because we dont know if eth received for tokenA->eth is less than _maxPercentage of the liquidity in\\n\\t * eth->tokenB. In our use case it is always eth->dai so either it will be safe or very minimal\\n\\t *@param _inToken address of token we are swapping\\n\\t *@param _outToken address of swap result token\\n\\t *@param _inTokenAmount amount of in token required to swap\\n\\t *@param _maxLiquidityPercentageSwap max percentage of liquidity to swap to token\\n\\t * when swapping tokens and this value is out of 100000 so for example if you want to set it to 0.3 you need set it to 300\\n\\t */\\n\\tfunction maxSafeTokenAmount(\\n\\t\\tIHasRouter _iHasRouter,\\n\\t\\taddress _inToken,\\n\\t\\taddress _outToken,\\n\\t\\tuint256 _inTokenAmount,\\n\\t\\tuint256 _maxLiquidityPercentageSwap\\n\\t) public view returns (uint256 safeAmount) {\\n\\t\\tUniswap uniswap = _iHasRouter.getRouter();\\n\\t\\taddress wETH = uniswap.WETH();\\n\\t\\t_inToken = _inToken == address(0x0) ? wETH : _inToken;\\n\\t\\t_outToken = _outToken == address(0x0) ? wETH : _outToken;\\n\\t\\tUniswapPair pair = UniswapPair(\\n\\t\\t\\tUniswapFactory(uniswap.factory()).getPair(_inToken, _outToken)\\n\\t\\t);\\n\\t\\t(uint112 reserve0, uint112 reserve1, ) = pair.getReserves();\\n\\t\\tuint112 reserve = reserve0;\\n\\t\\tif (_inToken == pair.token1()) {\\n\\t\\t\\treserve = reserve1;\\n\\t\\t}\\n\\n\\t\\tsafeAmount = (reserve * _maxLiquidityPercentageSwap) / 100000;\\n\\n\\t\\treturn safeAmount < _inTokenAmount ? safeAmount : _inTokenAmount;\\n\\t}\\n\\n\\t/**\\n\\t@dev Helper to swap tokens in the Uniswap\\n\\t*@param _path the buy path\\n\\t*@param _tokenAmount token amount to swap\\n\\t*@param _minTokenReturn minimum token amount to get in swap transaction\\n\\t*@param _receiver receiver of tokens after swap transaction\\n    *\\n\\t */\\n\\tfunction swap(\\n\\t\\tIHasRouter _iHasRouter,\\n\\t\\taddress[] memory _path,\\n\\t\\tuint256 _tokenAmount,\\n\\t\\tuint256 _minTokenReturn,\\n\\t\\taddress _receiver\\n\\t) internal returns (uint256 swapResult) {\\n\\t\\tUniswap uniswapContract = _iHasRouter.getRouter();\\n\\t\\tuint256[] memory result;\\n\\n\\t\\tif (_path[0] == address(0x0)) {\\n\\t\\t\\t_path[0] = uniswapContract.WETH();\\n\\t\\t\\tresult = uniswapContract.swapExactETHForTokens{ value: _tokenAmount }(\\n\\t\\t\\t\\t_minTokenReturn,\\n\\t\\t\\t\\t_path,\\n\\t\\t\\t\\t_receiver,\\n\\t\\t\\t\\tblock.timestamp\\n\\t\\t\\t);\\n\\t\\t} else if (_path[_path.length - 1] == address(0x0)) {\\n\\t\\t\\t_path[_path.length - 1] = uniswapContract.WETH();\\n\\t\\t\\tresult = uniswapContract.swapExactTokensForETH(\\n\\t\\t\\t\\t_tokenAmount,\\n\\t\\t\\t\\t_minTokenReturn,\\n\\t\\t\\t\\t_path,\\n\\t\\t\\t\\t_receiver,\\n\\t\\t\\t\\tblock.timestamp\\n\\t\\t\\t);\\n\\t\\t} else {\\n\\t\\t\\tresult = uniswapContract.swapExactTokensForTokens(\\n\\t\\t\\t\\t_tokenAmount,\\n\\t\\t\\t\\t_minTokenReturn,\\n\\t\\t\\t\\t_path,\\n\\t\\t\\t\\t_receiver,\\n\\t\\t\\t\\tblock.timestamp\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\treturn result[result.length - 1];\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\\n        __Context_init_unchained();\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n    uint256[45] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal initializer {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal initializer {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/DAOStackInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\ninterface Avatar {\\n\\tfunction nativeToken() external view returns (address);\\n\\n\\tfunction nativeReputation() external view returns (address);\\n\\n\\tfunction owner() external view returns (address);\\n}\\n\\ninterface Controller {\\n\\tevent RegisterScheme(address indexed _sender, address indexed _scheme);\\n\\tevent UnregisterScheme(address indexed _sender, address indexed _scheme);\\n\\n\\tfunction genericCall(\\n\\t\\taddress _contract,\\n\\t\\tbytes calldata _data,\\n\\t\\taddress _avatar,\\n\\t\\tuint256 _value\\n\\t) external returns (bool, bytes memory);\\n\\n\\tfunction avatar() external view returns (address);\\n\\n\\tfunction unregisterScheme(address _scheme, address _avatar)\\n\\t\\texternal\\n\\t\\treturns (bool);\\n\\n\\tfunction unregisterSelf(address _avatar) external returns (bool);\\n\\n\\tfunction registerScheme(\\n\\t\\taddress _scheme,\\n\\t\\tbytes32 _paramsHash,\\n\\t\\tbytes4 _permissions,\\n\\t\\taddress _avatar\\n\\t) external returns (bool);\\n\\n\\tfunction isSchemeRegistered(address _scheme, address _avatar)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (bool);\\n\\n\\tfunction getSchemePermissions(address _scheme, address _avatar)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (bytes4);\\n\\n\\tfunction addGlobalConstraint(\\n\\t\\taddress _constraint,\\n\\t\\tbytes32 _paramHash,\\n\\t\\taddress _avatar\\n\\t) external returns (bool);\\n\\n\\tfunction mintTokens(\\n\\t\\tuint256 _amount,\\n\\t\\taddress _beneficiary,\\n\\t\\taddress _avatar\\n\\t) external returns (bool);\\n\\n\\tfunction externalTokenTransfer(\\n\\t\\taddress _token,\\n\\t\\taddress _recipient,\\n\\t\\tuint256 _amount,\\n\\t\\taddress _avatar\\n\\t) external returns (bool);\\n\\n\\tfunction sendEther(\\n\\t\\tuint256 _amountInWei,\\n\\t\\taddress payable _to,\\n\\t\\taddress _avatar\\n\\t) external returns (bool);\\n}\\n\\ninterface GlobalConstraintInterface {\\n\\tenum CallPhase {\\n\\t\\tPre,\\n\\t\\tPost,\\n\\t\\tPreAndPost\\n\\t}\\n\\n\\tfunction pre(\\n\\t\\taddress _scheme,\\n\\t\\tbytes32 _params,\\n\\t\\tbytes32 _method\\n\\t) external returns (bool);\\n\\n\\t/**\\n\\t * @dev when return if this globalConstraints is pre, post or both.\\n\\t * @return CallPhase enum indication  Pre, Post or PreAndPost.\\n\\t */\\n\\tfunction when() external returns (CallPhase);\\n}\\n\\ninterface ReputationInterface {\\n\\tfunction balanceOf(address _user) external view returns (uint256);\\n\\n\\tfunction balanceOfAt(address _user, uint256 _blockNumber)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256);\\n\\n\\tfunction getVotes(address _user) external view returns (uint256);\\n\\n\\tfunction getVotesAt(\\n\\t\\taddress _user,\\n\\t\\tbool _global,\\n\\t\\tuint256 _blockNumber\\n\\t) external view returns (uint256);\\n\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\tfunction totalSupplyAt(uint256 _blockNumber)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256);\\n\\n\\tfunction delegateOf(address _user) external returns (address);\\n}\\n\\ninterface SchemeRegistrar {\\n\\tfunction proposeScheme(\\n\\t\\tAvatar _avatar,\\n\\t\\taddress _scheme,\\n\\t\\tbytes32 _parametersHash,\\n\\t\\tbytes4 _permissions,\\n\\t\\tstring memory _descriptionHash\\n\\t) external returns (bytes32);\\n\\n\\tevent NewSchemeProposal(\\n\\t\\taddress indexed _avatar,\\n\\t\\tbytes32 indexed _proposalId,\\n\\t\\taddress indexed _intVoteInterface,\\n\\t\\taddress _scheme,\\n\\t\\tbytes32 _parametersHash,\\n\\t\\tbytes4 _permissions,\\n\\t\\tstring _descriptionHash\\n\\t);\\n}\\n\\ninterface IntVoteInterface {\\n\\tevent NewProposal(\\n\\t\\tbytes32 indexed _proposalId,\\n\\t\\taddress indexed _organization,\\n\\t\\tuint256 _numOfChoices,\\n\\t\\taddress _proposer,\\n\\t\\tbytes32 _paramsHash\\n\\t);\\n\\n\\tevent ExecuteProposal(\\n\\t\\tbytes32 indexed _proposalId,\\n\\t\\taddress indexed _organization,\\n\\t\\tuint256 _decision,\\n\\t\\tuint256 _totalReputation\\n\\t);\\n\\n\\tevent VoteProposal(\\n\\t\\tbytes32 indexed _proposalId,\\n\\t\\taddress indexed _organization,\\n\\t\\taddress indexed _voter,\\n\\t\\tuint256 _vote,\\n\\t\\tuint256 _reputation\\n\\t);\\n\\n\\tevent CancelProposal(\\n\\t\\tbytes32 indexed _proposalId,\\n\\t\\taddress indexed _organization\\n\\t);\\n\\tevent CancelVoting(\\n\\t\\tbytes32 indexed _proposalId,\\n\\t\\taddress indexed _organization,\\n\\t\\taddress indexed _voter\\n\\t);\\n\\n\\t/**\\n\\t * @dev register a new proposal with the given parameters. Every proposal has a unique ID which is being\\n\\t * generated by calculating keccak256 of a incremented counter.\\n\\t * @param _numOfChoices number of voting choices\\n\\t * @param _proposalParameters defines the parameters of the voting machine used for this proposal\\n\\t * @param _proposer address\\n\\t * @param _organization address - if this address is zero the msg.sender will be used as the organization address.\\n\\t * @return proposal's id.\\n\\t */\\n\\tfunction propose(\\n\\t\\tuint256 _numOfChoices,\\n\\t\\tbytes32 _proposalParameters,\\n\\t\\taddress _proposer,\\n\\t\\taddress _organization\\n\\t) external returns (bytes32);\\n\\n\\tfunction vote(\\n\\t\\tbytes32 _proposalId,\\n\\t\\tuint256 _vote,\\n\\t\\tuint256 _rep,\\n\\t\\taddress _voter\\n\\t) external returns (bool);\\n\\n\\tfunction cancelVote(bytes32 _proposalId) external;\\n\\n\\tfunction getNumberOfChoices(bytes32 _proposalId)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256);\\n\\n\\tfunction isVotable(bytes32 _proposalId) external view returns (bool);\\n\\n\\t/**\\n\\t * @dev voteStatus returns the reputation voted for a proposal for a specific voting choice.\\n\\t * @param _proposalId the ID of the proposal\\n\\t * @param _choice the index in the\\n\\t * @return voted reputation for the given choice\\n\\t */\\n\\tfunction voteStatus(bytes32 _proposalId, uint256 _choice)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256);\\n\\n\\t/**\\n\\t * @dev isAbstainAllow returns if the voting machine allow abstain (0)\\n\\t * @return bool true or false\\n\\t */\\n\\tfunction isAbstainAllow() external pure returns (bool);\\n\\n\\t/**\\n     * @dev getAllowedRangeOfChoices returns the allowed range of choices for a voting machine.\\n     * @return min - minimum number of choices\\n               max - maximum number of choices\\n     */\\n\\tfunction getAllowedRangeOfChoices()\\n\\t\\texternal\\n\\t\\tpure\\n\\t\\treturns (uint256 min, uint256 max);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/NameService.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\n\\nimport \\\"../DAOStackInterfaces.sol\\\";\\n\\n/**\\n@title Simple name to address resolver\\n*/\\n\\ncontract NameService is Initializable, UUPSUpgradeable {\\n\\tmapping(bytes32 => address) public addresses;\\n\\n\\tController public dao;\\n\\tevent AddressChanged(string name ,address addr);\\n\\tfunction initialize(\\n\\t\\tController _dao,\\n\\t\\tbytes32[] memory _nameHashes,\\n\\t\\taddress[] memory _addresses\\n\\t) public virtual initializer {\\n\\t\\tdao = _dao;\\n\\t\\tfor (uint256 i = 0; i < _nameHashes.length; i++) {\\n\\t\\t\\taddresses[_nameHashes[i]] = _addresses[i];\\n\\t\\t}\\n\\t\\taddresses[keccak256(bytes(\\\"CONTROLLER\\\"))] = address(_dao);\\n\\t\\taddresses[keccak256(bytes(\\\"AVATAR\\\"))] = address(_dao.avatar());\\n\\t}\\n\\n\\tfunction _authorizeUpgrade(address) internal override {\\n\\t\\t_onlyAvatar();\\n\\t}\\n\\n\\tfunction _onlyAvatar() internal view {\\n\\t\\trequire(\\n\\t\\t\\taddress(dao.avatar()) == msg.sender,\\n\\t\\t\\t\\\"only avatar can call this method\\\"\\n\\t\\t);\\n\\t}\\n\\n\\tfunction setAddress(string memory name, address addr) external {\\n\\t\\t_onlyAvatar();\\n\\t\\taddresses[keccak256(bytes(name))] = addr;\\n\\t\\temit AddressChanged(name, addr);\\n\\t}\\n\\n\\tfunction setAddresses(bytes32[] calldata hash, address[] calldata addrs)\\n\\t\\texternal\\n\\t{\\n\\t\\t_onlyAvatar();\\n\\t\\tfor (uint256 i = 0; i < hash.length; i++) {\\n\\t\\t\\taddresses[hash[i]] = addrs[i];\\n\\t\\t}\\n\\t}\\n\\n\\tfunction getAddress(string memory name) external view returns (address) {\\n\\t\\treturn addresses[keccak256(bytes(name))];\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/utils/DAOContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"../DAOStackInterfaces.sol\\\";\\nimport \\\"../Interfaces.sol\\\";\\n\\n/**\\n@title Simple contract that keeps DAO contracts registery\\n*/\\n\\ncontract DAOContract {\\n\\tController public dao;\\n\\n\\taddress public avatar;\\n\\n\\tINameService public nameService;\\n\\n\\tfunction _onlyAvatar() internal view {\\n\\t\\trequire(\\n\\t\\t\\taddress(dao.avatar()) == msg.sender,\\n\\t\\t\\t\\\"only avatar can call this method\\\"\\n\\t\\t);\\n\\t}\\n\\n\\tfunction setDAO(INameService _ns) internal {\\n\\t\\tnameService = _ns;\\n\\t\\tupdateAvatar();\\n\\t}\\n\\n\\tfunction updateAvatar() public {\\n\\t\\tdao = Controller(nameService.getAddress(\\\"CONTROLLER\\\"));\\n\\t\\tavatar = dao.avatar();\\n\\t}\\n\\n\\tfunction nativeToken() public view returns (IGoodDollar) {\\n\\t\\treturn IGoodDollar(nameService.getAddress(\\\"GOODDOLLAR\\\"));\\n\\t}\\n\\n\\tuint256[50] private gap;\\n}\\n\"\r\n    },\r\n    \"contracts/staking/GoodFundManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"../reserve/GoodReserveCDai.sol\\\";\\nimport \\\"../Interfaces.sol\\\";\\nimport \\\"../utils/DSMath.sol\\\";\\nimport \\\"../utils/DAOUpgradeableContract.sol\\\";\\n\\n/**\\n * @title GoodFundManager contract that transfer interest from the staking contract\\n * to the reserve contract and transfer the return mintable tokens to the staking\\n * contract\\n * cDAI support only\\n */\\ncontract GoodFundManager is DAOUpgradeableContract, DSMath {\\n\\t// timestamp that indicates last time that interests collected\\n\\tuint256 public lastCollectedInterest;\\n\\t//just for UI to easily find last event\\n\\tuint256 public lastCollectedInterestBlock;\\n\\n\\t// Gas cost for mint ubi+bridge ubi+mint rewards\\n\\tuint256 public gasCostExceptInterestCollect;\\n\\t// Gas cost for minting GD for keeper\\n\\tuint256 public gdMintGasCost;\\n\\t// how much time since last collectInterest should pass in order to cancel gas cost multiplier requirement for next collectInterest\\n\\tuint256 public collectInterestTimeThreshold;\\n\\t// to allow keeper to collect interest, total interest collected should be interestMultiplier*gas costs\\n\\tuint8 public interestMultiplier;\\n\\t//min amount of days between interest collection\\n\\tuint8 public minCollectInterestIntervalDays;\\n\\t//address of the active staking contracts\\n\\taddress[] public activeContracts;\\n\\n\\tevent GasCostSet(uint256 newGasCost);\\n\\tevent CollectInterestTimeThresholdSet(\\n\\t\\tuint256 newCollectInterestTimeThreshold\\n\\t);\\n\\tevent InterestMultiplierSet(uint8 newInterestMultiplier);\\n\\tevent GasCostExceptInterestCollectSet(\\n\\t\\tuint256 newGasCostExceptInterestCollect\\n\\t);\\n\\tevent StakingRewardSet(\\n\\t\\tuint32 _rewardsPerBlock,\\n\\t\\taddress _stakingAddress,\\n\\t\\tuint32 _blockStart,\\n\\t\\tuint32 _blockEnd,\\n\\t\\tbool _isBlackListed\\n\\t);\\n\\t//Structure that hold reward information and if its blacklicksted or not for particular staking Contract\\n\\tstruct Reward {\\n\\t\\tuint32 blockReward; //in G$\\n\\t\\tuint64 blockStart; // # of the start block to distribute rewards\\n\\t\\tuint64 blockEnd; // # of the end block to distribute rewards\\n\\t\\tbool isBlackListed; // If staking contract is blacklisted or not\\n\\t}\\n\\tstruct InterestInfo {\\n\\t\\taddress contractAddress; // staking contract address which interest will be collected\\n\\t\\tuint256 interestBalance; // Interest amount that staking contract has\\n\\t\\tuint256 collectedInterestSoFar; // Collected interest amount so far including this contract\\n\\t\\tuint256 gasCostSoFar; // Spent gas amount so far including this contract\\n\\t\\tuint256 maxGasAmountSoFar; //  Max gas amount that can spend to collect this interest according to interest amount\\n\\t\\tbool maxGasLargerOrEqualRequired; // Bool that indicates if max gas amount larger or equal to actual gas needed\\n\\t}\\n\\t// Rewards per block for particular Staking contract\\n\\tmapping(address => Reward) public rewardsForStakingContract;\\n\\t// Emits when `transferInterest` transfers\\n\\t// funds to the staking contract and to\\n\\t// the bridge\\n\\tevent FundsTransferred(\\n\\t\\t// The caller address\\n\\t\\taddress indexed caller,\\n\\t\\t// The staking contract address\\n\\t\\t//address indexed staking,\\n\\t\\t// The reserve contract address\\n\\t\\taddress reserve,\\n\\t\\t//addresses of the staking contracts\\n\\t\\taddress[] stakings,\\n\\t\\t// Amount of cDai that was transferred\\n\\t\\t// from the staking contract to the\\n\\t\\t// reserve contract\\n\\t\\tuint256 cDAIinterestEarned,\\n\\t\\t// The number of tokens that have been minted\\n\\t\\t// by the reserve to the staking contract\\n\\t\\t//uint256 gdInterest,\\n\\t\\t// The number of tokens that have been minted\\n\\t\\t// by the reserve to the bridge which in his\\n\\t\\t// turn should transfer those funds to the\\n\\t\\t// sidechain\\n\\t\\tuint256 gdUBI,\\n\\t\\t// Amount of GD to be minted as reward\\n\\t\\t//to the keeper which collect interests\\n\\t\\tuint256 gdReward\\n\\t);\\n\\n\\tevent StakingRewardMinted(\\n\\t\\taddress stakingContract,\\n\\t\\taddress staker,\\n\\t\\tuint256 gdReward\\n\\t);\\n\\n\\t/**\\n\\t * @dev Constructor\\n\\t * @param _ns The address of the name Service\\n\\t */\\n\\tfunction initialize(INameService _ns) public virtual initializer {\\n\\t\\tsetDAO(_ns);\\n\\t\\tgdMintGasCost = 250000; // While testing highest amount was 240k so put 250k to be safe\\n\\t\\tcollectInterestTimeThreshold = 60 days;\\n\\t\\tinterestMultiplier = 4;\\n\\t\\tgasCostExceptInterestCollect = 850000; //while testing highest amount was 800k so put 850k to be safe\\n\\t\\tminCollectInterestIntervalDays = 7;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Set gas cost to mint GD rewards for keeper\\n\\t * @param _gasAmount amount of gas it costs for minting gd reward\\n\\t */\\n\\tfunction setGasCost(uint256 _gasAmount) public {\\n\\t\\t_onlyAvatar();\\n\\t\\tgdMintGasCost = _gasAmount;\\n\\t\\temit GasCostSet(_gasAmount);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Set collectInterestTimeThreshold to determine how much time should pass after collectInterest called\\n\\t * after which we ignore the interest>=multiplier*gas costs limit\\n\\t * @param _timeThreshold new threshold in seconds\\n\\t */\\n\\tfunction setCollectInterestTimeThreshold(uint256 _timeThreshold) public {\\n\\t\\t_onlyAvatar();\\n\\t\\tcollectInterestTimeThreshold = _timeThreshold;\\n\\t\\temit CollectInterestTimeThresholdSet(_timeThreshold);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Set multiplier to determine how much times larger should be collected interest than spent gas when collectInterestTimeThreshold did not pass\\n\\t */\\n\\tfunction setInterestMultiplier(uint8 _newMultiplier) public {\\n\\t\\t_onlyAvatar();\\n\\t\\tinterestMultiplier = _newMultiplier;\\n\\t\\temit InterestMultiplierSet(_newMultiplier);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Set Gas cost for required transactions after collecting interest in collectInterest function\\n\\t * we need this to know if caller has enough gas left to keep collecting interest\\n\\t * @dev _gasAmount The gas amount that needed for transactions\\n\\t */\\n\\tfunction setGasCostExceptInterestCollect(uint256 _gasAmount) public {\\n\\t\\t_onlyAvatar();\\n\\t\\tgasCostExceptInterestCollect = _gasAmount;\\n\\t\\temit GasCostExceptInterestCollectSet(_gasAmount);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Sets the Reward for particular Staking contract\\n\\t * @param _rewardsPerBlock reward for per block\\n\\t * @param _stakingAddress address of the staking contract\\n\\t * @param _blockStart block number for start reward distrubution\\n\\t * @param _blockEnd block number for end reward distrubition\\n\\t * @param _isBlackListed set staking contract blacklisted or not to prevent minting\\n\\t */\\n\\tfunction setStakingReward(\\n\\t\\tuint32 _rewardsPerBlock,\\n\\t\\taddress _stakingAddress,\\n\\t\\tuint32 _blockStart,\\n\\t\\tuint32 _blockEnd,\\n\\t\\tbool _isBlackListed\\n\\t) public {\\n\\t\\t_onlyAvatar();\\n\\n\\t\\t//we dont allow to undo blacklisting as it will mess up rewards accounting.\\n\\t\\t//staking contracts are assumed immutable and thus non fixable\\n\\t\\trequire(\\n\\t\\t\\t(_isBlackListed ||\\n\\t\\t\\t\\t!rewardsForStakingContract[_stakingAddress].isBlackListed),\\n\\t\\t\\t\\\"can't undo blacklisting\\\"\\n\\t\\t);\\n\\t\\tReward memory reward = Reward(\\n\\t\\t\\t_rewardsPerBlock,\\n\\t\\t\\t_blockStart > 0 ? _blockStart : uint32(block.number),\\n\\t\\t\\t_blockEnd > 0 ? _blockEnd : 0xFFFFFFFF,\\n\\t\\t\\t_isBlackListed\\n\\t\\t);\\n\\t\\trewardsForStakingContract[_stakingAddress] = reward;\\n\\n\\t\\tbool exist;\\n\\t\\tuint8 i;\\n\\t\\tfor (i = 0; i < activeContracts.length; i++) {\\n\\t\\t\\tif (activeContracts[i] == _stakingAddress) {\\n\\t\\t\\t\\texist = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (exist && (_isBlackListed || _rewardsPerBlock == 0)) {\\n\\t\\t\\tactiveContracts[i] = activeContracts[activeContracts.length - 1];\\n\\t\\t\\tactiveContracts.pop();\\n\\t\\t} else if (!exist && !(_isBlackListed || _rewardsPerBlock == 0)) {\\n\\t\\t\\tactiveContracts.push(_stakingAddress);\\n\\t\\t}\\n\\t\\temit StakingRewardSet(\\n\\t\\t\\t_rewardsPerBlock,\\n\\t\\t\\t_stakingAddress,\\n\\t\\t\\t_blockStart,\\n\\t\\t\\t_blockEnd,\\n\\t\\t\\t_isBlackListed\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Collects UBI interest in iToken from a given staking contract and transfers\\n\\t * that interest to the reserve contract. Then transfers the given gd which\\n\\t * received from the reserve contract back to the staking contract and to the\\n\\t * bridge, which locks the funds and then the GD tokens are been minted to the\\n\\t * given address on the sidechain\\n\\t * @param _stakingContracts from which contracts to collect interest\\n\\t * @param _forceAndWaiverRewards if set to true, it will collect interest even if not passed thershold, but will not reward caller with gas refund + reward\\n\\t */\\n\\tfunction collectInterest(\\n\\t\\taddress[] calldata _stakingContracts,\\n\\t\\tbool _forceAndWaiverRewards\\n\\t) external {\\n\\t\\tuint256 initialGas = gasleft();\\n\\t\\tuint256 gdUBI;\\n\\t\\tuint256 interestInCdai;\\n\\t\\taddress reserveAddress;\\n\\t\\t{\\n\\t\\t\\t// require(\\n\\t\\t\\t// \\tblock.timestamp >= lastCollectedInterest + minCollectedInterestIntervalDays * days,\\n\\t\\t\\t// \\t\\\"collectInterest: collect interval not passed\\\"\\n\\t\\t\\t// );\\n\\t\\t\\t//prevent stack too deep\\n\\t\\t\\tcERC20 iToken = cERC20(nameService.getAddress(\\\"CDAI\\\"));\\n\\t\\t\\tERC20 daiToken = ERC20(nameService.getAddress(\\\"DAI\\\"));\\n\\t\\t\\treserveAddress = nameService.getAddress(\\\"RESERVE\\\");\\n\\t\\t\\t// DAI balance of the reserve contract\\n\\t\\t\\tuint256 currentBalance = daiToken.balanceOf(reserveAddress);\\n\\t\\t\\tuint256 startingCDAIBalance = iToken.balanceOf(reserveAddress);\\n\\t\\t\\tfor (uint256 i = _stakingContracts.length - 1; i >= 0; i--) {\\n\\t\\t\\t\\t// elements are sorted by balances from lowest to highest\\n\\n\\t\\t\\t\\tif (_stakingContracts[i] != address(0x0)) {\\n\\t\\t\\t\\t\\tIGoodStaking(_stakingContracts[i]).collectUBIInterest(reserveAddress);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (i == 0) break; // when active contracts length is 1 then gives error\\n\\t\\t\\t}\\n\\t\\t\\t// Finds the actual transferred DAI\\n\\t\\t\\tuint256 daiToConvert = daiToken.balanceOf(reserveAddress) -\\n\\t\\t\\t\\tcurrentBalance;\\n\\n\\t\\t\\t// Mints gd while the interest amount is equal to the transferred amount\\n\\t\\t\\t(gdUBI, interestInCdai) = GoodReserveCDai(reserveAddress).mintUBI(\\n\\t\\t\\t\\tdaiToConvert,\\n\\t\\t\\t\\tstartingCDAIBalance,\\n\\t\\t\\t\\tiToken\\n\\t\\t\\t);\\n\\n\\t\\t\\tIGoodDollar token = IGoodDollar(nameService.getAddress(\\\"GOODDOLLAR\\\"));\\n\\t\\t\\tif (gdUBI > 0) {\\n\\t\\t\\t\\t//transfer ubi to avatar on sidechain via bridge\\n\\t\\t\\t\\trequire(\\n\\t\\t\\t\\t\\ttoken.transferAndCall(\\n\\t\\t\\t\\t\\t\\tnameService.getAddress(\\\"BRIDGE_CONTRACT\\\"),\\n\\t\\t\\t\\t\\t\\tgdUBI,\\n\\t\\t\\t\\t\\t\\tabi.encodePacked(nameService.getAddress(\\\"UBI_RECIPIENT\\\"))\\n\\t\\t\\t\\t\\t),\\n\\t\\t\\t\\t\\t\\\"ubi bridge transfer failed\\\"\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tuint256 gdRewardToMint;\\n\\n\\t\\tif (_forceAndWaiverRewards == false) {\\n\\t\\t\\tuint256 totalUsedGas = ((initialGas - gasleft() + gdMintGasCost) * 110) /\\n\\t\\t\\t\\t100; // We will return as reward 1.1x of used gas in GD\\n\\t\\t\\tgdRewardToMint = getGasPriceInGD(totalUsedGas);\\n\\n\\t\\t\\tGoodReserveCDai(reserveAddress).mintRewardFromRR(\\n\\t\\t\\t\\tnameService.getAddress(\\\"CDAI\\\"),\\n\\t\\t\\t\\tmsg.sender,\\n\\t\\t\\t\\tgdRewardToMint\\n\\t\\t\\t);\\n\\n\\t\\t\\tuint256 gasPriceIncDAI = getGasPriceIncDAIorDAI(\\n\\t\\t\\t\\tinitialGas - gasleft(),\\n\\t\\t\\t\\tfalse\\n\\t\\t\\t);\\n\\n\\t\\t\\tif (\\n\\t\\t\\t\\tblock.timestamp >= lastCollectedInterest + collectInterestTimeThreshold\\n\\t\\t\\t) {\\n\\t\\t\\t\\trequire(\\n\\t\\t\\t\\t\\tinterestInCdai >= gasPriceIncDAI,\\n\\t\\t\\t\\t\\t\\\"Collected interest value should be larger than spent gas costs\\\"\\n\\t\\t\\t\\t); // This require is necessary to keeper can not abuse this function\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trequire(\\n\\t\\t\\t\\t\\tinterestInCdai >= interestMultiplier * gasPriceIncDAI,\\n\\t\\t\\t\\t\\t\\\"Collected interest value should be interestMultiplier x gas costs\\\"\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\temit FundsTransferred(\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\treserveAddress,\\n\\t\\t\\t_stakingContracts,\\n\\t\\t\\tinterestInCdai,\\n\\t\\t\\tgdUBI,\\n\\t\\t\\tgdRewardToMint\\n\\t\\t);\\n\\n\\t\\tlastCollectedInterest = block.timestamp;\\n\\t\\tlastCollectedInterestBlock = block.number;\\n\\t}\\n\\n\\t/**\\n\\t * @dev  Function that get interest informations of staking contracts in the sorted array by highest interest to lowest interest amount\\n\\t * @return array of interestInfo struct\\n\\t */\\n\\tfunction calcSortedContracts() public view returns (InterestInfo[] memory) {\\n\\t\\taddress[] memory addresses = new address[](activeContracts.length);\\n\\t\\tuint256[] memory balances = new uint256[](activeContracts.length);\\n\\t\\tInterestInfo[] memory interestInfos = new InterestInfo[](\\n\\t\\t\\tactiveContracts.length\\n\\t\\t);\\n\\t\\tuint256 tempInterest;\\n\\t\\tint256 i;\\n\\t\\tfor (i = 0; i < int256(activeContracts.length); i++) {\\n\\t\\t\\t(, , , , tempInterest) = IGoodStaking(activeContracts[uint256(i)])\\n\\t\\t\\t\\t.currentGains(false, true);\\n\\t\\t\\tif (tempInterest != 0) {\\n\\t\\t\\t\\taddresses[uint256(i)] = activeContracts[uint256(i)];\\n\\t\\t\\t\\tbalances[uint256(i)] = tempInterest;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tuint256 usedGasAmount = gasCostExceptInterestCollect;\\n\\t\\tquick(balances, addresses); // sort the values according to interest balance\\n\\t\\tuint256 gasCost;\\n\\t\\tuint256 possibleCollected;\\n\\t\\tuint256 maxGasAmount;\\n\\t\\tfor (i = int256(activeContracts.length) - 1; i >= 0; i--) {\\n\\t\\t\\t// elements are sorted by balances from lowest to highest\\n\\n\\t\\t\\tif (addresses[uint256(i)] != address(0x0)) {\\n\\t\\t\\t\\tgasCost = IGoodStaking(addresses[uint256(i)])\\n\\t\\t\\t\\t\\t.getGasCostForInterestTransfer();\\n\\n\\t\\t\\t\\t// collects the interest from the staking contract and transfer it directly to the reserve contract\\n\\t\\t\\t\\t//`collectUBIInterest` returns (iTokengains, tokengains, precission loss, donation ratio)\\n\\t\\t\\t\\tpossibleCollected += balances[uint256(i)];\\n\\t\\t\\t\\tusedGasAmount += gasCost;\\n\\t\\t\\t\\tmaxGasAmount = block.timestamp >=\\n\\t\\t\\t\\t\\tlastCollectedInterest + collectInterestTimeThreshold\\n\\t\\t\\t\\t\\t? (possibleCollected * 1e10) / getGasPriceIncDAIorDAI(1, true)\\n\\t\\t\\t\\t\\t: (possibleCollected * 1e10) /\\n\\t\\t\\t\\t\\t\\t(interestMultiplier * getGasPriceIncDAIorDAI(1, true));\\n\\t\\t\\t\\tinterestInfos[uint256(i)] = InterestInfo({\\n\\t\\t\\t\\t\\tcontractAddress: addresses[uint256(i)],\\n\\t\\t\\t\\t\\tinterestBalance: balances[uint256(i)],\\n\\t\\t\\t\\t\\tcollectedInterestSoFar: possibleCollected,\\n\\t\\t\\t\\t\\tgasCostSoFar: usedGasAmount,\\n\\t\\t\\t\\t\\tmaxGasAmountSoFar: maxGasAmount,\\n\\t\\t\\t\\t\\tmaxGasLargerOrEqualRequired: maxGasAmount >= usedGasAmount\\n\\t\\t\\t\\t});\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak; // if addresses are null after this element then break because we initialize array in size activecontracts but if their interest balance is zero then we dont put it in this array\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn interestInfos;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Mint to users reward tokens which they earned by staking contract\\n\\t * @param _token reserve token (currently can be just cDAI)\\n\\t * @param _user user to get rewards\\n\\t */\\n\\tfunction mintReward(address _token, address _user) public {\\n\\t\\tReward memory staking = rewardsForStakingContract[address(msg.sender)];\\n\\t\\trequire(staking.blockStart > 0, \\\"Staking contract not registered\\\");\\n\\t\\tuint256 amount = IGoodStaking(address(msg.sender)).rewardsMinted(\\n\\t\\t\\t_user,\\n\\t\\t\\tstaking.blockReward,\\n\\t\\t\\tstaking.blockStart,\\n\\t\\t\\tstaking.blockEnd\\n\\t\\t);\\n\\t\\tif (amount > 0 && staking.isBlackListed == false) {\\n\\t\\t\\tGoodReserveCDai(nameService.getAddress(\\\"RESERVE\\\")).mintRewardFromRR(\\n\\t\\t\\t\\t_token,\\n\\t\\t\\t\\t_user,\\n\\t\\t\\t\\tamount\\n\\t\\t\\t);\\n\\n\\t\\t\\temit StakingRewardMinted(msg.sender, _user, amount);\\n\\t\\t}\\n\\t}\\n\\n\\t/// quick sort\\n\\tfunction quick(uint256[] memory data, address[] memory addresses)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t{\\n\\t\\tif (data.length > 1) {\\n\\t\\t\\tquickPart(data, addresses, 0, data.length - 1);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n     @dev quicksort algorithm to sort array\\n     */\\n\\tfunction quickPart(\\n\\t\\tuint256[] memory data,\\n\\t\\taddress[] memory addresses,\\n\\t\\tuint256 low,\\n\\t\\tuint256 high\\n\\t) internal pure {\\n\\t\\tif (low < high) {\\n\\t\\t\\tuint256 pivotVal = data[(low + high) / 2];\\n\\n\\t\\t\\tuint256 low1 = low;\\n\\t\\t\\tuint256 high1 = high;\\n\\t\\t\\tfor (;;) {\\n\\t\\t\\t\\twhile (data[low1] < pivotVal) low1++;\\n\\t\\t\\t\\twhile (data[high1] > pivotVal) high1--;\\n\\t\\t\\t\\tif (low1 >= high1) break;\\n\\t\\t\\t\\t(data[low1], data[high1]) = (data[high1], data[low1]);\\n\\t\\t\\t\\t(addresses[low1], addresses[high1]) = (\\n\\t\\t\\t\\t\\taddresses[high1],\\n\\t\\t\\t\\t\\taddresses[low1]\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\tlow1++;\\n\\t\\t\\t\\thigh1--;\\n\\t\\t\\t}\\n\\t\\t\\tif (low < high1) quickPart(data, addresses, low, high1);\\n\\t\\t\\thigh1++;\\n\\t\\t\\tif (high1 < high) quickPart(data, addresses, high1, high);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n     @dev Helper function to get gasPrice in GWEI then change it to cDAI/DAI\\n     @param _gasAmount gas amount to get its value\\n\\t @param _inDAI indicates if result should return in DAI\\n     @return Price of the gas in DAI/cDAI\\n     */\\n\\tfunction getGasPriceIncDAIorDAI(uint256 _gasAmount, bool _inDAI)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\tAggregatorV3Interface gasPriceOracle = AggregatorV3Interface(\\n\\t\\t\\tnameService.getAddress(\\\"GAS_PRICE_ORACLE\\\")\\n\\t\\t);\\n\\t\\tint256 gasPrice = gasPriceOracle.latestAnswer(); // returns gas price in 0 decimal as GWEI so 1eth / 1e9 eth\\n\\n\\t\\tAggregatorV3Interface daiETHOracle = AggregatorV3Interface(\\n\\t\\t\\tnameService.getAddress(\\\"DAI_ETH_ORACLE\\\")\\n\\t\\t);\\n\\t\\tint256 daiInETH = daiETHOracle.latestAnswer(); // returns DAI price in ETH\\n\\n\\t\\tuint256 result = ((uint256(gasPrice) * 1e18) / uint256(daiInETH)); // Gasprice in GWEI and daiInETH is 18 decimals so we multiply gasprice with 1e18 in order to get result in 18 decimals\\n\\t\\tif (_inDAI) return result * _gasAmount;\\n\\t\\tresult =\\n\\t\\t\\t(((result / 1e10) * 1e28) /\\n\\t\\t\\t\\tcERC20(nameService.getAddress(\\\"CDAI\\\")).exchangeRateStored()) *\\n\\t\\t\\t_gasAmount; // based on https://compound.finance/docs#protocol-math\\n\\t\\treturn result;\\n\\t}\\n\\n\\t/**\\n     @dev Helper function to get gasPrice in G$, used to calculate the rewards for collectInterest KEEPER\\n     @param _gasAmount gas amount to get its value\\n     @return Price of the gas in G$\\n     */\\n\\tfunction getGasPriceInGD(uint256 _gasAmount) public view returns (uint256) {\\n\\t\\tuint256 priceInCdai = getGasPriceIncDAIorDAI(_gasAmount, false);\\n\\t\\tuint256 gdPriceIncDAI = GoodReserveCDai(nameService.getAddress(\\\"RESERVE\\\"))\\n\\t\\t\\t.currentPrice();\\n\\t\\treturn ((priceInCdai * 1e27) / gdPriceIncDAI) / 1e25; // rdiv returns result in 27 decimals since GD$ in 2 decimals then divide 1e25\\n\\t}\\n\\n\\tfunction getActiveContractsCount() public view returns (uint256) {\\n\\t\\treturn activeContracts.length;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/staking/BaseShareFieldV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\nimport \\\"../Interfaces.sol\\\";\\n\\ncontract BaseShareFieldV2 {\\n\\t// rewards claimed by users\\n\\tuint128 mintedRewards;\\n\\t// total staked for shares calculation\\n\\tuint128 totalProductivity;\\n\\t// total staked that earns rewards (some stakers can donate their rewards)\\n\\tuint128 totalEffectiveStakes;\\n\\t// rewards accumulated for distribution\\n\\tuint128 accumulatedRewards;\\n\\t// block of last rewards accumulation\\n\\tuint128 lastRewardBlock;\\n\\t// number of blocks before reaching the max rewards multiplier (starting at 0.5 reaching 1 after maxMultiplierThreshold)\\n\\tuint64 maxMultiplierThreshold;\\n\\t// Staking contracts accepts Tokens with max 18 decimals so this variable holds decimal difference between 18 and Token's decimal in order to make calculations\\n\\tuint8 tokenDecimalDifference;\\n\\n\\t// accumulated rewards per share in 27 decimals precision\\n\\tuint256 accAmountPerShare;\\n\\n\\t//status of user rewards. everything is in 18 decimals\\n\\tstruct UserInfo {\\n\\t\\tuint128 amount; // How many tokens the user has provided.\\n\\t\\tuint128 effectiveStakes; // stakes not including stakes that donate their rewards\\n\\t\\tuint128 rewardDebt; // Reward debt.\\n\\t\\tuint128 rewardEarn; // Reward earn and not minted\\n\\t\\tuint128 rewardMinted; //Rewards minted to user so far\\n\\t\\tuint64 lastRewardTime; // Last time that user got rewards\\n\\t\\tuint64 multiplierResetTime; // Reset time of multiplier\\n\\t}\\n\\tmapping(address => UserInfo) public users;\\n\\n\\tfunction getStats()\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (\\n\\t\\t\\tuint256 _accAmountPerShare,\\n\\t\\t\\tuint128 _mintedRewards,\\n\\t\\t\\tuint128 _totalProductivity,\\n\\t\\t\\tuint128 _totalEffectiveStakes,\\n\\t\\t\\tuint128 _accumulatedRewards,\\n\\t\\t\\tuint128 _lastRewardBlock,\\n\\t\\t\\tuint64 _maxMultiplierThreshold,\\n\\t\\t\\tuint8 _tokenDecimalDifference\\n\\t\\t)\\n\\t{\\n\\t\\treturn (\\n\\t\\t\\taccAmountPerShare,\\n\\t\\t\\tmintedRewards,\\n\\t\\t\\ttotalProductivity,\\n\\t\\t\\ttotalEffectiveStakes,\\n\\t\\t\\taccumulatedRewards,\\n\\t\\t\\tlastRewardBlock,\\n\\t\\t\\tmaxMultiplierThreshold,\\n\\t\\t\\ttokenDecimalDifference\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Helper function to check if caller is fund manager\\n\\t */\\n\\tfunction _canMintRewards() internal view virtual {}\\n\\n\\t/**\\n\\t * @dev Update reward variables of the given pool to be up-to-date.\\n\\t * Calculates passed blocks and adding to the reward pool\\n\\t * @param rewardsPerBlock how much rewards does this contract earns per block\\n\\t * @param blockStart block from which contract starts earning rewards\\n\\t * @param blockEnd block from which contract stops earning rewards\\n\\t */\\n\\tfunction _update(\\n\\t\\tuint256 rewardsPerBlock,\\n\\t\\tuint256 blockStart,\\n\\t\\tuint256 blockEnd\\n\\t) internal virtual {\\n\\t\\tif (totalEffectiveStakes == 0) {\\n\\t\\t\\tlastRewardBlock = uint128(block.number);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif (block.number >= blockStart && lastRewardBlock < blockStart) {\\n\\t\\t\\tlastRewardBlock = uint128(blockStart);\\n\\t\\t}\\n\\n\\t\\tuint256 _lastRewardBlock = lastRewardBlock < blockStart &&\\n\\t\\t\\tblock.number >= blockStart\\n\\t\\t\\t? blockStart\\n\\t\\t\\t: lastRewardBlock;\\n\\t\\tuint256 curRewardBlock = block.number > blockEnd ? blockEnd : block.number;\\n\\n\\t\\tif (curRewardBlock < blockStart || _lastRewardBlock >= blockEnd) return;\\n\\n\\t\\tuint256 multiplier = curRewardBlock - _lastRewardBlock; // Blocks passed since last reward block\\n\\t\\tuint256 reward = multiplier * (rewardsPerBlock * 1e16); // rewardsPerBlock is in G$ which is only 2 decimals, we turn it into 18 decimals by multiplying 1e16\\n\\n\\t\\taccAmountPerShare =\\n\\t\\t\\taccAmountPerShare +\\n\\t\\t\\t(reward * 1e27) /\\n\\t\\t\\t(totalEffectiveStakes * (10**tokenDecimalDifference));\\n\\t\\t// Increase totalEffectiveStakes decimals if it is less than 18 decimals then accAmountPerShare in 27 decimals\\n\\n\\t\\tlastRewardBlock = uint128(curRewardBlock);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Audit user's rewards and calculate their earned rewards\\n\\t * For the first month rewards calculated with 0.5x\\n\\t * multiplier therefore they just gets half of the rewards which they earned in the first month\\n\\t * after first month they get full amount of rewards for the part that they earned after one month\\n\\t * @param user the user to audit\\n\\t * @param updatedAmount the new stake of the user after deposit/withdraw\\n\\t * @param donationPer percentage user is donating from his rewards. (currently just 0 or 100 in SimpleStaking)\\n\\t */\\n\\tfunction _audit(\\n\\t\\taddress user,\\n\\t\\tuint256 updatedAmount,\\n\\t\\tuint256 donationPer\\n\\t) internal virtual {\\n\\t\\tUserInfo storage userInfo = users[user];\\n\\t\\tuint256 _amount = userInfo.amount;\\n\\t\\tuint256 userEffectiveStake = userInfo.effectiveStakes;\\n\\t\\tif (userEffectiveStake > 0) {\\n\\t\\t\\t(\\n\\t\\t\\t\\tuint256 blocksToPay,\\n\\t\\t\\t\\tuint256 firstMonthBlocksToPay,\\n\\t\\t\\t\\tuint256 fullBlocksToPay\\n\\t\\t\\t) = _auditCalcs(userInfo);\\n\\n\\t\\t\\tif (blocksToPay != 0) {\\n\\t\\t\\t\\tuint256 pending = (userEffectiveStake *\\n\\t\\t\\t\\t\\t(10**tokenDecimalDifference) *\\n\\t\\t\\t\\t\\taccAmountPerShare) /\\n\\t\\t\\t\\t\\t1e27 -\\n\\t\\t\\t\\t\\tuserInfo.rewardDebt;\\n\\t\\t\\t\\t// Turn userInfo.amount to 18 decimals by multiplying tokenDecimalDifference if it's not and multiply with accAmountPerShare which is 27 decimals then divide it 1e27 bring it down to 18 decimals\\n\\t\\t\\t\\tuint256 rewardPerBlock = (pending * 1e9) / blocksToPay; // bring pending to 1e27\\n\\t\\t\\t\\tpending =\\n\\t\\t\\t\\t\\t((((firstMonthBlocksToPay * 1e2 * 5) / 10) + fullBlocksToPay * 1e2) * // multiply first month by 0.5x (5/10) since rewards in first month with multiplier 0.5 and multiply it with 1e2 to get it 2decimals so we could get more precision\\n\\t\\t\\t\\t\\t\\trewardPerBlock) / // Multiply fullBlocksToPay with 1e2 to bring it to 2 decimals // rewardPerBlock is in 27decimals\\n\\t\\t\\t\\t\\t1e11; // Pending in 18 decimals so we divide 1e11 to bring it down to 18 decimals\\n\\t\\t\\t\\tuserInfo.rewardEarn = uint128(userInfo.rewardEarn + pending); // Add user's earned rewards to user's account so it can be minted later\\n\\t\\t\\t\\taccumulatedRewards = uint128(accumulatedRewards + pending);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tuserInfo.multiplierResetTime = uint64(block.number); // Should set user's multiplierResetTime when they stake for the first time\\n\\t\\t}\\n\\n\\t\\t//if withdrawing rewards/stake we reset multiplier, only in case of increasinig productivity we dont reset multiplier\\n\\t\\tif (updatedAmount <= _amount) {\\n\\t\\t\\tuserInfo.multiplierResetTime = uint64(block.number);\\n\\t\\t\\tif (_amount > 0) {\\n\\t\\t\\t\\t//calculate relative part of user effective stakes\\n\\t\\t\\t\\tuint256 withdrawFromEffectiveStake = ((_amount - updatedAmount) *\\n\\t\\t\\t\\t\\tuserInfo.effectiveStakes) / _amount;\\n\\t\\t\\t\\tuserInfo.effectiveStakes -= uint128(withdrawFromEffectiveStake);\\n\\t\\t\\t\\ttotalEffectiveStakes -= uint128(withdrawFromEffectiveStake);\\n\\t\\t\\t}\\n\\t\\t} else if (donationPer == 0) {\\n\\t\\t\\tuserInfo.effectiveStakes += uint128(updatedAmount - _amount);\\n\\t\\t\\ttotalEffectiveStakes += uint128(updatedAmount - _amount);\\n\\t\\t}\\n\\t\\tuserInfo.lastRewardTime = uint64(block.number);\\n\\t\\tuserInfo.amount = uint128(updatedAmount);\\n\\t\\tuserInfo.rewardDebt = uint128(\\n\\t\\t\\t(userInfo.effectiveStakes *\\n\\t\\t\\t\\t(10**tokenDecimalDifference) *\\n\\t\\t\\t\\taccAmountPerShare) / 1e27\\n\\t\\t); // Divide to 1e27 to keep rewardDebt in 18 decimals since accAmountPerShare is 27 decimals\\n\\t}\\n\\n\\t/**\\n\\t * @dev Helper function to make calculations in audit and getUserPendingReward methods\\n\\t */\\n\\tfunction _auditCalcs(UserInfo memory _userInfo)\\n\\t\\tinternal\\n\\t\\tview\\n\\t\\treturns (\\n\\t\\t\\tuint256,\\n\\t\\t\\tuint256,\\n\\t\\t\\tuint256\\n\\t\\t)\\n\\t{\\n\\t\\tuint256 blocksPaid = _userInfo.lastRewardTime -\\n\\t\\t\\t_userInfo.multiplierResetTime; // lastRewardTime is always >= multiplierResetTime\\n\\t\\tuint256 blocksPassedFirstMonth = maxMultiplierThreshold <\\n\\t\\t\\tblock.number - _userInfo.multiplierResetTime\\n\\t\\t\\t? maxMultiplierThreshold\\n\\t\\t\\t: block.number - _userInfo.multiplierResetTime;\\n\\t\\t// blocks which is after first month\\n\\t\\tuint256 blocksToPay = block.number - _userInfo.lastRewardTime; // blocks passed since last payment\\n\\t\\tuint256 firstMonthBlocksToPay = blocksPaid >= maxMultiplierThreshold\\n\\t\\t\\t? 0\\n\\t\\t\\t: blocksPassedFirstMonth - blocksPaid; // block which is in the first month so pays with 0.5x multiplier\\n\\t\\tuint256 fullBlocksToPay = blocksToPay - firstMonthBlocksToPay; // blocks to pay in full amount which means with 1x multiplier\\n\\t\\treturn (blocksToPay, firstMonthBlocksToPay, fullBlocksToPay);\\n\\t}\\n\\n\\t/**\\n\\t * @dev This function increase user's productivity and updates the global productivity.\\n\\t * This function increase user's productivity and updates the global productivity.\\n\\t * the users' actual share percentage will calculated by:\\n\\t * Formula:     user_productivity / global_productivity\\n\\t * @param user the user to update\\n\\t * @param value the increase in user stake\\n\\t * @param rewardsPerBlock how much rewards does this contract earns per block\\n\\t * @param blockStart block from which contract starts earning rewards\\n\\t * @param blockEnd block from which contract stops earning rewards\\n\\t * @param donationPer percentage user is donating from his rewards. (currently just 0 or 100 in SimpleStaking)\\n\\t */\\n\\tfunction _increaseProductivity(\\n\\t\\taddress user,\\n\\t\\tuint256 value,\\n\\t\\tuint256 rewardsPerBlock,\\n\\t\\tuint256 blockStart,\\n\\t\\tuint256 blockEnd,\\n\\t\\tuint256 donationPer\\n\\t) internal virtual returns (bool) {\\n\\t\\t_update(rewardsPerBlock, blockStart, blockEnd);\\n\\t\\t_audit(user, users[user].amount + value, donationPer);\\n\\n\\t\\ttotalProductivity = uint128(totalProductivity + value);\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n\\t * @dev This function will decreases user's productivity by value, and updates the global productivity\\n\\t * it will record which block this is happenning and accumulates the area of (productivity * time)\\n\\t * @param user the user to update\\n\\t * @param value the increase in user stake\\n\\t * @param rewardsPerBlock how much rewards does this contract earns per block\\n\\t * @param blockStart block from which contract starts earning rewards\\n\\t * @param blockEnd block from which contract stops earning rewards\\n\\t */\\n\\n\\tfunction _decreaseProductivity(\\n\\t\\taddress user,\\n\\t\\tuint256 value,\\n\\t\\tuint256 rewardsPerBlock,\\n\\t\\tuint256 blockStart,\\n\\t\\tuint256 blockEnd\\n\\t) internal virtual returns (bool) {\\n\\t\\t_update(rewardsPerBlock, blockStart, blockEnd);\\n\\t\\t_audit(user, users[user].amount - value, 1); // donationPer variable should be something different than zero so called with 1\\n\\t\\ttotalProductivity = uint128(totalProductivity - value);\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Query user's pending reward with updated variables\\n\\t * @param user the user to update\\n\\t * @param rewardsPerBlock how much rewards does this contract earns per block\\n\\t * @param blockStart block from which contract starts earning rewards\\n\\t * @param blockEnd block from which contract stops earning rewards\\n\\t * @return returns  amount of user's earned but not minted rewards\\n\\t */\\n\\tfunction getUserPendingReward(\\n\\t\\taddress user,\\n\\t\\tuint256 rewardsPerBlock,\\n\\t\\tuint256 blockStart,\\n\\t\\tuint256 blockEnd\\n\\t) public view returns (uint256) {\\n\\t\\tUserInfo memory userInfo = users[user];\\n\\t\\tuint256 _accAmountPerShare = accAmountPerShare;\\n\\n\\t\\tuint256 pending = 0;\\n\\t\\tif (\\n\\t\\t\\ttotalEffectiveStakes != 0 &&\\n\\t\\t\\tblock.number >= blockStart &&\\n\\t\\t\\tblockEnd >= block.number\\n\\t\\t) {\\n\\t\\t\\tuint256 multiplier = block.number - lastRewardBlock;\\n\\t\\t\\tuint256 reward = multiplier * (rewardsPerBlock * 1e16); // turn it to 18 decimals since rewardsPerBlock in 2 decimals\\n\\t\\t\\t(\\n\\t\\t\\t\\tuint256 blocksToPay,\\n\\t\\t\\t\\tuint256 firstMonthBlocksToPay,\\n\\t\\t\\t\\tuint256 fullBlocksToPay\\n\\t\\t\\t) = _auditCalcs(userInfo);\\n\\n\\t\\t\\t_accAmountPerShare =\\n\\t\\t\\t\\t_accAmountPerShare +\\n\\t\\t\\t\\t(reward * 1e27) /\\n\\t\\t\\t\\t(totalEffectiveStakes * 10**tokenDecimalDifference); // Increase totalEffectiveStakes decimals if it is less than 18 decimals then accAmountPerShare in 27 decimals\\n\\t\\t\\tUserInfo memory tempUserInfo = userInfo; // to prevent stack too deep error any other recommendation?\\n\\t\\t\\tif (blocksToPay != 0) {\\n\\t\\t\\t\\tpending =\\n\\t\\t\\t\\t\\t(tempUserInfo.effectiveStakes *\\n\\t\\t\\t\\t\\t\\t(10**tokenDecimalDifference) *\\n\\t\\t\\t\\t\\t\\t_accAmountPerShare) /\\n\\t\\t\\t\\t\\t1e27 -\\n\\t\\t\\t\\t\\ttempUserInfo.rewardDebt; // Turn userInfo.amount to 18 decimals by multiplying tokenDecimalDifference if it's not and multiply with accAmountPerShare which is 27 decimals then divide it 1e27 bring it down to 18 decimals\\n\\t\\t\\t\\tuint256 rewardPerBlock = (pending * 1e27) / (blocksToPay * 1e18); // bring both variable to 18 decimals and multiply pending by 1e27 so when we divide them to each other result would be in 1e27\\n\\t\\t\\t\\tpending =\\n\\t\\t\\t\\t\\t((((firstMonthBlocksToPay * 1e2 * 5) / 10) + fullBlocksToPay * 1e2) * // multiply first month by 0.5x (5/10) since rewards in first month with multiplier 0.5 and multiply it with 1e2 to get it 2decimals so we could get more precision\\n\\t\\t\\t\\t\\t\\trewardPerBlock) / // Multiply fullBlocksToPay with 1e2 to bring it to 2decimals // rewardPerBlock is in 27decimals\\n\\t\\t\\t\\t\\t1e11; // Pending in 18 decimals so we divide 1e11 to bring it down to 18 decimals\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn userInfo.rewardEarn + pending; // rewardEarn is in 18 decimals\\n\\t}\\n\\n\\t/**\\n\\t * @dev When the fundmanager calls this function it will updates the user records\\n\\t * get the user rewards which they earned but not minted and mark it as minted\\n\\t * @param user the user to update\\n\\t * @param rewardsPerBlock how much rewards does this contract earns per block\\n\\t * @param blockStart block from which contract starts earning rewards\\n\\t * @param blockEnd block from which contract stops earning rewards\\n\\t * @return returns amount to mint as reward to the user\\n\\t */\\n\\n\\tfunction rewardsMinted(\\n\\t\\taddress user,\\n\\t\\tuint256 rewardsPerBlock,\\n\\t\\tuint256 blockStart,\\n\\t\\tuint256 blockEnd\\n\\t) public returns (uint256) {\\n\\t\\t_canMintRewards();\\n\\t\\t_update(rewardsPerBlock, blockStart, blockEnd);\\n\\t\\t_audit(user, users[user].amount, 1); // donationPer variable should be something different than zero so called with 1\\n\\t\\tuint128 amount = users[user].rewardEarn;\\n\\t\\tusers[user].rewardEarn = 0;\\n\\t\\tusers[user].rewardMinted += amount;\\n\\t\\tmintedRewards = mintedRewards + amount;\\n\\t\\tamount = amount / 1e16; // change decimal of mint amount to GD decimals\\n\\t\\treturn amount;\\n\\t}\\n\\n\\t/**\\n\\t * @return Returns how many productivity a user has and global has.\\n\\t */\\n\\n\\tfunction getProductivity(address user)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\tvirtual\\n\\t\\treturns (uint256, uint256)\\n\\t{\\n\\t\\treturn (users[user].amount, totalProductivity);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/governance/StakersDistribution.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport \\\"../utils/DAOContract.sol\\\";\\nimport \\\"../utils/NameService.sol\\\";\\nimport \\\"../Interfaces.sol\\\";\\nimport \\\"../governance/GReputation.sol\\\";\\nimport \\\"../governance/MultiBaseGovernanceShareField.sol\\\";\\nimport \\\"../staking/GoodFundManager.sol\\\";\\nimport \\\"../staking/SimpleStakingV2.sol\\\";\\n\\n/**\\n * Staking contracts will update this contract with staker token stake amount\\n * This contract will be able to mint GDAO. 2M GDAO that will be allocated between staking contracts each month pro-rate based on $ value staked.\\n * Each staker will receive his share pro rata per staking contract he participates in\\n * NOTICE: a contract will start earning GDAO rewards only after first month\\n */\\ncontract StakersDistribution is\\n\\tDAOUpgradeableContract,\\n\\tMultiBaseGovernanceShareField\\n{\\n\\t///@notice reputation to distribute each month, will effect next month when set\\n\\tuint256 public monthlyReputationDistribution;\\n\\n\\t///@notice month number since epoch\\n\\tuint256 public currentMonth;\\n\\n\\tevent ReputationEarned(\\n\\t\\taddress staker,\\n\\t\\taddress[] stakingContracts,\\n\\t\\tuint256 reputation\\n\\t);\\n\\n\\tfunction initialize(INameService _ns) public initializer {\\n\\t\\tmonthlyReputationDistribution = 2000000 ether; //2M as specified in specs\\n\\t\\tsetDAO(_ns);\\n\\t}\\n\\n\\t/**\\n\\t * @dev this contract runs on ethereum\\n\\t */\\n\\tfunction getChainBlocksPerMonth() public pure override returns (uint256) {\\n\\t\\treturn 172800; //4 * 60 * 24 * 30\\n\\t}\\n\\n\\t/**\\n\\t * @dev update the monthly reputation distribution. only avatar can do that.\\n\\t * @param newMonthlyReputationDistribution the new reputation amount to distribute\\n\\t */\\n\\tfunction setMonthlyReputationDistribution(\\n\\t\\tuint256 newMonthlyReputationDistribution\\n\\t) external {\\n\\t\\t_onlyAvatar();\\n\\t\\tmonthlyReputationDistribution = newMonthlyReputationDistribution;\\n\\t}\\n\\n\\t/**\\n\\t * @dev internal function to switch to new month. records for new month the current monthlyReputationDistribution\\n\\t */\\n\\tfunction _updateRewards() internal {\\n\\t\\tif (nameService.getAddress(\\\"FUND_MANAGER\\\") != address(0)) {\\n\\t\\t\\t//read active staking contracts set pro rate monthly share\\n\\t\\t\\tGoodFundManager gfm = GoodFundManager(\\n\\t\\t\\t\\tnameService.getAddress(\\\"FUND_MANAGER\\\")\\n\\t\\t\\t);\\n\\n\\t\\t\\tuint256 activeContractsCount = gfm.getActiveContractsCount();\\n\\t\\t\\taddress payable[] memory activeStakingList = new address payable[](\\n\\t\\t\\t\\tactiveContractsCount\\n\\t\\t\\t);\\n\\t\\t\\tuint256[] memory contractLockedValue = new uint256[](\\n\\t\\t\\t\\tactiveContractsCount\\n\\t\\t\\t);\\n\\n\\t\\t\\tuint256 totalLockedValue;\\n\\t\\t\\tfor (uint256 i = 0; i < activeContractsCount; i++) {\\n\\t\\t\\t\\tactiveStakingList[i] = payable(gfm.activeContracts(i));\\n\\t\\t\\t\\t(, uint64 blockStart, uint64 blockEnd, ) = gfm\\n\\t\\t\\t\\t\\t.rewardsForStakingContract(activeStakingList[i]);\\n\\t\\t\\t\\tif (blockStart <= block.number && blockEnd > block.number) {\\n\\t\\t\\t\\t\\tuint256 lockedValueInUSD = SimpleStakingV2(activeStakingList[i])\\n\\t\\t\\t\\t\\t\\t.lockedUSDValue();\\n\\t\\t\\t\\t\\tcontractLockedValue[i] = lockedValueInUSD;\\n\\t\\t\\t\\t\\ttotalLockedValue += contractLockedValue[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t//set each contract relative monthly rewards\\n\\t\\t\\tfor (uint256 i = 0; i < activeContractsCount; i++) {\\n\\t\\t\\t\\tuint256 contractShare = totalLockedValue > 0\\n\\t\\t\\t\\t\\t? (monthlyReputationDistribution * contractLockedValue[i]) /\\n\\t\\t\\t\\t\\t\\ttotalLockedValue\\n\\t\\t\\t\\t\\t: monthlyReputationDistribution / activeContractsCount;\\n\\t\\t\\t\\tif (contractLockedValue[i] > 0) {\\n\\t\\t\\t\\t\\t_setMonthlyRewards(activeStakingList[i], contractShare);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev staking contract can call this to increase user current contribution\\n\\t * @param _staker the user to update\\n\\t * @param _value the value to increase by\\n\\t */\\n\\tfunction userStaked(address _staker, uint256 _value) external {\\n\\t\\taddress stakingContract = msg.sender;\\n\\t\\t(\\n\\t\\t\\t,\\n\\t\\t\\tuint64 blockStart,\\n\\t\\t\\tuint64 blockEnd,\\n\\t\\t\\tbool isBlackListed\\n\\t\\t) = GoodFundManager(nameService.getAddress(\\\"FUND_MANAGER\\\"))\\n\\t\\t\\t\\t.rewardsForStakingContract(stakingContract);\\n\\n\\t\\tif (isBlackListed) return; //dont do anything if staking contract has been blacklisted;\\n\\n\\t\\t_increaseProductivity(\\n\\t\\t\\tstakingContract,\\n\\t\\t\\t_staker,\\n\\t\\t\\t_value,\\n\\t\\t\\tblockStart,\\n\\t\\t\\tblockEnd\\n\\t\\t);\\n\\n\\t\\taddress[] memory contracts = new address[](1);\\n\\t\\tcontracts[0] = stakingContract;\\n\\n\\t\\t_claimReputation(_staker, contracts);\\n\\n\\t\\t_updateRewards();\\n\\t}\\n\\n\\t/**\\n\\t * @dev staking contract can call this to decrease user current contribution\\n\\t * @param _staker the user to update\\n\\t * @param _value the value to decrease by\\n\\t */\\n\\tfunction userWithdraw(address _staker, uint256 _value) external {\\n\\t\\taddress stakingContract = msg.sender;\\n\\t\\t(\\n\\t\\t\\t,\\n\\t\\t\\tuint64 blockStart,\\n\\t\\t\\tuint64 blockEnd,\\n\\t\\t\\tbool isBlackListed\\n\\t\\t) = GoodFundManager(nameService.getAddress(\\\"FUND_MANAGER\\\"))\\n\\t\\t\\t\\t.rewardsForStakingContract(stakingContract);\\n\\n\\t\\tif (isBlackListed) return; //dont do anything if staking contract has been blacklisted;\\n\\n\\t\\t_decreaseProductivity(\\n\\t\\t\\tstakingContract,\\n\\t\\t\\t_staker,\\n\\t\\t\\t_value,\\n\\t\\t\\tblockStart,\\n\\t\\t\\tblockEnd\\n\\t\\t);\\n\\n\\t\\taddress[] memory contracts = new address[](1);\\n\\t\\tcontracts[0] = stakingContract;\\n\\t\\t_claimReputation(_staker, contracts);\\n\\t\\t_updateRewards();\\n\\t}\\n\\n\\t/**\\n\\t * @dev mints reputation to user according to his share in the different staking contracts\\n\\t * @param _staker the user to distribute reputation to\\n\\t * @param _stakingContracts the user to distribute reputation to\\n\\t */\\n\\tfunction claimReputation(\\n\\t\\taddress _staker,\\n\\t\\taddress[] calldata _stakingContracts\\n\\t) external {\\n\\t\\t_claimReputation(_staker, _stakingContracts);\\n\\t}\\n\\n\\tfunction _claimReputation(address _staker, address[] memory _stakingContracts)\\n\\t\\tinternal\\n\\t{\\n\\t\\tuint256 totalRep;\\n\\t\\tGoodFundManager gfm = GoodFundManager(\\n\\t\\t\\tnameService.getAddress(\\\"FUND_MANAGER\\\")\\n\\t\\t);\\n\\n\\t\\tfor (uint256 i = 0; i < _stakingContracts.length; i++) {\\n\\t\\t\\t(, uint64 blockStart, uint64 blockEnd, bool isBlackListed) = gfm\\n\\t\\t\\t\\t.rewardsForStakingContract(_stakingContracts[i]);\\n\\n\\t\\t\\tif (isBlackListed == false)\\n\\t\\t\\t\\ttotalRep += _issueEarnedRewards(\\n\\t\\t\\t\\t\\t_stakingContracts[i],\\n\\t\\t\\t\\t\\t_staker,\\n\\t\\t\\t\\t\\tblockStart,\\n\\t\\t\\t\\t\\tblockEnd\\n\\t\\t\\t\\t);\\n\\t\\t}\\n\\t\\tif (totalRep > 0) {\\n\\t\\t\\tGReputation(nameService.getAddress(\\\"REPUTATION\\\")).mint(_staker, totalRep);\\n\\t\\t\\temit ReputationEarned(_staker, _stakingContracts, totalRep);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev get user reputation rewards accrued in goodstaking contracts\\n\\t * @param _contracts list of contracts to check for rewards\\n\\t * @param _user the user to check rewards for\\n\\t * @return reputation rewards pending for user\\n\\t */\\n\\tfunction getUserPendingRewards(address[] memory _contracts, address _user)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\tuint256 pending;\\n\\t\\tfor (uint256 i = 0; i < _contracts.length; i++) {\\n\\t\\t\\t(\\n\\t\\t\\t\\t,\\n\\t\\t\\t\\tuint64 blockStart,\\n\\t\\t\\t\\tuint64 blockEnd,\\n\\t\\t\\t\\tbool isBlackListed\\n\\t\\t\\t) = GoodFundManager(nameService.getAddress(\\\"FUND_MANAGER\\\"))\\n\\t\\t\\t\\t\\t.rewardsForStakingContract(_contracts[i]);\\n\\n\\t\\t\\tif (isBlackListed == false) {\\n\\t\\t\\t\\tpending += getUserPendingReward(\\n\\t\\t\\t\\t\\t_contracts[i],\\n\\t\\t\\t\\t\\tblockStart,\\n\\t\\t\\t\\t\\tblockEnd,\\n\\t\\t\\t\\t\\t_user\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn pending;\\n\\t}\\n\\n\\t/**\\n\\t * @param _contracts staking contracts to sum _user minted and pending\\n\\t * @param _user account to get rewards status for\\n\\t * @return (minted, pending) in GDAO 18 decimals\\n\\t */\\n\\tfunction getUserMintedAndPending(address[] memory _contracts, address _user)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\treturns (uint256, uint256)\\n\\t{\\n\\t\\tuint256 pending = getUserPendingRewards(_contracts, _user);\\n\\t\\tuint256 minted;\\n\\t\\tfor (uint256 i = 0; i < _contracts.length; i++) {\\n\\t\\t\\tminted += contractToUsers[_contracts[i]][_user].rewardMinted;\\n\\t\\t}\\n\\t\\treturn (minted, pending);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nlibrary DataTypes {\\n\\t// refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\\n\\tstruct ReserveData {\\n\\t\\t//stores the reserve configuration\\n\\t\\tReserveConfigurationMap configuration;\\n\\t\\t//the liquidity index. Expressed in ray\\n\\t\\tuint128 liquidityIndex;\\n\\t\\t//variable borrow index. Expressed in ray\\n\\t\\tuint128 variableBorrowIndex;\\n\\t\\t//the current supply rate. Expressed in ray\\n\\t\\tuint128 currentLiquidityRate;\\n\\t\\t//the current variable borrow rate. Expressed in ray\\n\\t\\tuint128 currentVariableBorrowRate;\\n\\t\\t//the current stable borrow rate. Expressed in ray\\n\\t\\tuint128 currentStableBorrowRate;\\n\\t\\tuint40 lastUpdateTimestamp;\\n\\t\\t//tokens addresses\\n\\t\\taddress aTokenAddress;\\n\\t\\taddress stableDebtTokenAddress;\\n\\t\\taddress variableDebtTokenAddress;\\n\\t\\t//address of the interest rate strategy\\n\\t\\taddress interestRateStrategyAddress;\\n\\t\\t//the id of the reserve. Represents the position in the list of the active reserves\\n\\t\\tuint8 id;\\n\\t}\\n\\n\\tstruct ReserveConfigurationMap {\\n\\t\\t//bit 0-15: LTV\\n\\t\\t//bit 16-31: Liq. threshold\\n\\t\\t//bit 32-47: Liq. bonus\\n\\t\\t//bit 48-55: Decimals\\n\\t\\t//bit 56: Reserve is active\\n\\t\\t//bit 57: reserve is frozen\\n\\t\\t//bit 58: borrowing is enabled\\n\\t\\t//bit 59: stable rate borrowing enabled\\n\\t\\t//bit 60-63: reserved\\n\\t\\t//bit 64-79: reserve factor\\n\\t\\tuint256 data;\\n\\t}\\n\\tenum InterestRateMode { NONE, STABLE, VARIABLE }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is Initializable, ERC1967UpgradeUpgradeable {\\n    function __UUPSUpgradeable_init() internal initializer {\\n        __ERC1967Upgrade_init_unchained();\\n        __UUPSUpgradeable_init_unchained();\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal initializer {\\n    }\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallSecure(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallSecure(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeaconUpgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/StorageSlotUpgradeable.sol\\\";\\nimport \\\"../utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\\n    function __ERC1967Upgrade_init() internal initializer {\\n        __ERC1967Upgrade_init_unchained();\\n    }\\n\\n    function __ERC1967Upgrade_init_unchained() internal initializer {\\n    }\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(AddressUpgradeable.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallSecure(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        address oldImplementation = _getImplementation();\\n\\n        // Initial upgrade and setup call\\n        _setImplementation(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(newImplementation, data);\\n        }\\n\\n        // Perform rollback test if not already in progress\\n        StorageSlotUpgradeable.BooleanSlot storage rollbackTesting = StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT);\\n        if (!rollbackTesting.value) {\\n            // Trigger rollback using upgradeTo from the new implementation\\n            rollbackTesting.value = true;\\n            _functionDelegateCall(\\n                newImplementation,\\n                abi.encodeWithSignature(\\\"upgradeTo(address)\\\", oldImplementation)\\n            );\\n            rollbackTesting.value = false;\\n            // Check rollback was effective\\n            require(oldImplementation == _getImplementation(), \\\"ERC1967Upgrade: upgrade breaks further upgrades\\\");\\n            // Finally reset to the new implementation and log the upgrade\\n            _upgradeTo(newImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(AddressUpgradeable.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\\n        require(AddressUpgradeable.isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return AddressUpgradeable.verifyCallResult(success, returndata, \\\"Address: low-level delegate call failed\\\");\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/reserve/GoodReserveCDai.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\nimport \\\"../utils/DAOUpgradeableContract.sol\\\";\\nimport \\\"../utils/NameService.sol\\\";\\nimport \\\"../DAOStackInterfaces.sol\\\";\\nimport \\\"../Interfaces.sol\\\";\\nimport \\\"./GoodMarketMaker.sol\\\";\\n\\ninterface ContributionCalc {\\n\\tfunction calculateContribution(\\n\\t\\tGoodMarketMaker _marketMaker,\\n\\t\\tGoodReserveCDai _reserve,\\n\\t\\taddress _contributer,\\n\\t\\tERC20 _token,\\n\\t\\tuint256 _gdAmount\\n\\t) external view returns (uint256);\\n\\n\\tfunction setContributionRatio(uint256 _nom, uint256 _denom) external;\\n}\\n\\n/**\\n@title Reserve based on cDAI and dynamic reserve ratio market maker\\n*/\\ncontract GoodReserveCDai is\\n\\tDAOUpgradeableContract,\\n\\tERC20PresetMinterPauserUpgradeable,\\n\\tGlobalConstraintInterface\\n{\\n\\tbytes32 public constant RESERVE_MINTER_ROLE =\\n\\t\\tkeccak256(\\\"RESERVE_MINTER_ROLE\\\");\\n\\n\\t/// @dev G$ minting cap;\\n\\tuint256 public cap;\\n\\n\\t// The last block number which\\n\\t// `mintUBI` has been executed in\\n\\tuint256 public lastMinted;\\n\\n\\taddress public daiAddress;\\n\\taddress public cDaiAddress;\\n\\n\\t/// @dev merkleroot for GDX airdrop\\n\\tbytes32 public gdxAirdrop;\\n\\n\\t/// @dev mark if user claimed his GDX\\n\\tmapping(address => bool) public isClaimedGDX;\\n\\n\\t// Emits when new GD tokens minted\\n\\tevent UBIMinted(\\n\\t\\t//epoch of UBI\\n\\t\\tuint256 indexed day,\\n\\t\\t//the token paid as interest\\n\\t\\taddress indexed interestToken,\\n\\t\\t//wei amount of interest paid in interestToken\\n\\t\\tuint256 interestReceived,\\n\\t\\t// Amount of GD tokens that was\\n\\t\\t// added to the supply as a result\\n\\t\\t// of `mintInterest`\\n\\t\\tuint256 gdInterestMinted,\\n\\t\\t// Amount of GD tokens that was\\n\\t\\t// added to the supply as a result\\n\\t\\t// of `mintExpansion`\\n\\t\\tuint256 gdExpansionMinted,\\n\\t\\t// Amount of GD tokens that was\\n\\t\\t// minted to the `ubiCollector`\\n\\t\\tuint256 gdUbiTransferred\\n\\t);\\n\\n\\t// Emits when GD tokens are purchased\\n\\tevent TokenPurchased(\\n\\t\\t// The initiate of the action\\n\\t\\taddress indexed caller,\\n\\t\\t// The convertible token address\\n\\t\\t// which the GD tokens were\\n\\t\\t// purchased with\\n\\t\\taddress indexed inputToken,\\n\\t\\t// Reserve tokens amount\\n\\t\\tuint256 inputAmount,\\n\\t\\t// Actual return after the\\n\\t\\t// conversion\\n\\t\\tuint256 actualReturn,\\n\\t\\t// Address of the receiver of tokens\\n\\t\\taddress indexed receiverAddress\\n\\t);\\n\\t// Emits when GD tokens are sold\\n\\tevent TokenSold(\\n\\t\\t// The initiate of the action\\n\\t\\taddress indexed caller,\\n\\t\\t// The convertible token address\\n\\t\\t// which the GD tokens were\\n\\t\\t// sold to\\n\\t\\taddress indexed outputToken,\\n\\t\\t// GD tokens amount\\n\\t\\tuint256 gdAmount,\\n\\t\\t// The amount of GD tokens that\\n\\t\\t// was contributed during the\\n\\t\\t// conversion\\n\\t\\tuint256 contributionAmount,\\n\\t\\t// Actual return after the\\n\\t\\t// conversion\\n\\t\\tuint256 actualReturn,\\n\\t\\t// Address of the receiver of tokens\\n\\t\\taddress indexed receiverAddress\\n\\t);\\n\\n\\tfunction initialize(INameService _ns, bytes32 _gdxAirdrop)\\n\\t\\tpublic\\n\\t\\tvirtual\\n\\t\\tinitializer\\n\\t{\\n\\t\\t__ERC20PresetMinterPauser_init(\\\"GDX\\\", \\\"G$X\\\");\\n\\t\\tsetDAO(_ns);\\n\\n\\t\\t//fixed cdai/dai\\n\\t\\tsetAddresses();\\n\\n\\t\\t//gdx roles\\n\\t\\trenounceRole(MINTER_ROLE, _msgSender());\\n\\t\\trenounceRole(PAUSER_ROLE, _msgSender());\\n\\t\\trenounceRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n\\t\\t_setupRole(DEFAULT_ADMIN_ROLE, address(avatar));\\n\\n\\t\\t//mint access through reserve\\n\\t\\t_setupRole(RESERVE_MINTER_ROLE, address(avatar)); //only Avatar can manage minters\\n\\n\\t\\tcap = 22 * 1e14; //22 trillion G$ cents\\n\\n\\t\\tgdxAirdrop = _gdxAirdrop;\\n\\t}\\n\\n\\tfunction setGDXAirdrop(bytes32 _airdrop) external {\\n\\t\\t_onlyAvatar();\\n\\t\\tgdxAirdrop = _airdrop;\\n\\t}\\n\\n\\t/// @dev GDX decimals\\n\\tfunction decimals() public pure override returns (uint8) {\\n\\t\\treturn 2;\\n\\t}\\n\\n\\tfunction setAddresses() public {\\n\\t\\tdaiAddress = nameService.getAddress(\\\"DAI\\\");\\n\\t\\tcDaiAddress = nameService.getAddress(\\\"CDAI\\\");\\n\\t\\t// Approve transfer to cDAI contract\\n\\t\\tERC20(daiAddress).approve(cDaiAddress, type(uint256).max);\\n\\t}\\n\\n\\t/**\\n\\t * @dev get current MarketMaker from name service\\n\\t * The address of the market maker contract\\n\\t * which makes the calculations and holds\\n\\t * the token and accounts info (should be owned by the reserve)\\n\\t */\\n\\tfunction getMarketMaker() public view returns (GoodMarketMaker) {\\n\\t\\treturn GoodMarketMaker(nameService.getAddress(\\\"MARKET_MAKER\\\"));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Converts cDai tokens to GD tokens and updates the bonding curve params.\\n\\t * `buy` occurs only if the GD return is above the given minimum. It is possible\\n\\t * to buy only with cDAI and when the contract is set to active. MUST call to\\n\\t * cDAI `approve` prior this action to allow this contract to accomplish the\\n\\t * conversion.\\n\\t * @param _tokenAmount The amount of cDAI tokens that should be converted to GD tokens\\n\\t * @param _minReturn The minimum allowed return in GD tokens\\n\\t * @param _targetAddress address of g$ and gdx recipient if different than msg.sender\\n\\t * @return (gdReturn) How much GD tokens were transferred\\n\\t */\\n\\tfunction buy(\\n\\t\\tuint256 _tokenAmount,\\n\\t\\tuint256 _minReturn,\\n\\t\\taddress _targetAddress\\n\\t) external returns (uint256) {\\n\\t\\tERC20 buyWith = ERC20(cDaiAddress);\\n\\t\\tuint256 gdReturn = getMarketMaker().buy(buyWith, _tokenAmount);\\n\\t\\t_targetAddress = _targetAddress == address(0x0)\\n\\t\\t\\t? msg.sender\\n\\t\\t\\t: _targetAddress;\\n\\t\\taddress exchangeHelper = nameService.getAddress(\\\"EXCHANGE_HELPER\\\");\\n\\t\\tif (msg.sender != exchangeHelper)\\n\\t\\t\\trequire(\\n\\t\\t\\t\\tbuyWith.transferFrom(msg.sender, address(this), _tokenAmount) == true,\\n\\t\\t\\t\\t\\\"transferFrom failed, make sure you approved input token transfer\\\"\\n\\t\\t\\t);\\n\\t\\trequire(gdReturn >= _minReturn, \\\"GD return must be above the minReturn\\\");\\n\\t\\t_mintGoodDollars(_targetAddress, gdReturn, true);\\n\\t\\t//mint GDX\\n\\t\\t_mintGDX(_targetAddress, gdReturn);\\n\\n\\t\\temit TokenPurchased(\\n\\t\\t\\tmsg.sender != exchangeHelper ? msg.sender : tx.origin,\\n\\t\\t\\tcDaiAddress,\\n\\t\\t\\t_tokenAmount,\\n\\t\\t\\tgdReturn,\\n\\t\\t\\t_targetAddress\\n\\t\\t);\\n\\t\\treturn gdReturn;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Mint rewards for staking contracts in G$ and update RR\\n\\t * requires minting permissions which is enforced by _mintGoodDollars\\n\\t * @param _to Receipent address for rewards\\n\\t * @param _amount G$ amount to mint for rewards\\n\\t */\\n\\tfunction mintRewardFromRR(\\n\\t\\taddress _token,\\n\\t\\taddress _to,\\n\\t\\tuint256 _amount\\n\\t) public {\\n\\t\\tgetMarketMaker().mintFromReserveRatio(ERC20(_token), _amount);\\n\\t\\t_mintGoodDollars(_to, _amount, false);\\n\\t\\t//mint GDX\\n\\t\\t_mintGDX(_to, _amount);\\n\\t}\\n\\n\\t/**\\n\\t * @dev sell helper function burns GD tokens and update the bonding curve params.\\n\\t * `sell` occurs only if the token return is above the given minimum. Notice that\\n\\t * there is a contribution amount from the given GD that remains in the reserve.\\n\\t * @param _gdAmount The amount of GD tokens that should be converted to cDAI tokens\\n\\t * @param _minReturn The minimum allowed `sellTo` tokens return\\n\\t * @param _target address of the receiver of cDAI when sell G$\\n\\t * @param _seller address of the seller when using helper contract\\n\\t * @return (tokenReturn, contribution) (cDAI received, G$ exit contribution)\\n\\t */\\n\\tfunction sell(\\n\\t\\tuint256 _gdAmount,\\n\\t\\tuint256 _minReturn,\\n\\t\\taddress _target,\\n\\t\\taddress _seller\\n\\t) external returns (uint256, uint256) {\\n\\t\\tGoodMarketMaker mm = getMarketMaker();\\n\\t\\tif (msg.sender != nameService.getAddress(\\\"EXCHANGE_HELPER\\\")) {\\n\\t\\t\\tIGoodDollar(nameService.getAddress(\\\"GOODDOLLAR\\\")).burnFrom(\\n\\t\\t\\t\\tmsg.sender,\\n\\t\\t\\t\\t_gdAmount\\n\\t\\t\\t);\\n\\t\\t\\t_seller = msg.sender;\\n\\t\\t}\\n\\t\\t_target = _target == address(0x0) ? msg.sender : _target;\\n\\t\\t//discount on exit contribution based on gdx\\n\\t\\tuint256 gdx = balanceOf(_seller);\\n\\t\\tuint256 discount = gdx <= _gdAmount ? gdx : _gdAmount;\\n\\n\\t\\t//burn gdx used for discount\\n\\t\\tif (discount > 0) _burn(_seller, discount);\\n\\n\\t\\tuint256 contributionAmount = 0;\\n\\t\\tuint256 gdAmountTemp = _gdAmount; // to prevent stack too deep errors\\n\\t\\tif (discount < gdAmountTemp)\\n\\t\\t\\tcontributionAmount = ContributionCalc(\\n\\t\\t\\t\\tnameService.getAddress(\\\"CONTRIBUTION_CALCULATION\\\")\\n\\t\\t\\t).calculateContribution(\\n\\t\\t\\t\\t\\tmm,\\n\\t\\t\\t\\t\\tthis,\\n\\t\\t\\t\\t\\t_seller,\\n\\t\\t\\t\\t\\tERC20(cDaiAddress),\\n\\t\\t\\t\\t\\tgdAmountTemp - discount\\n\\t\\t\\t\\t);\\n\\n\\t\\tuint256 tokenReturn = mm.sellWithContribution(\\n\\t\\t\\tERC20(cDaiAddress),\\n\\t\\t\\tgdAmountTemp,\\n\\t\\t\\tcontributionAmount\\n\\t\\t);\\n\\t\\trequire(\\n\\t\\t\\ttokenReturn >= _minReturn,\\n\\t\\t\\t\\\"Token return must be above the minReturn\\\"\\n\\t\\t);\\n\\t\\tcERC20(cDaiAddress).transfer(_target, tokenReturn);\\n\\n\\t\\temit TokenSold(\\n\\t\\t\\t_seller,\\n\\t\\t\\tcDaiAddress,\\n\\t\\t\\t_gdAmount,\\n\\t\\t\\tcontributionAmount,\\n\\t\\t\\ttokenReturn,\\n\\t\\t\\t_target\\n\\t\\t);\\n\\n\\t\\treturn (tokenReturn, contributionAmount);\\n\\t}\\n\\n\\tfunction currentPrice() public view returns (uint256) {\\n\\t\\treturn getMarketMaker().currentPrice(ERC20(cDaiAddress));\\n\\t}\\n\\n\\tfunction currentPriceDAI() public view returns (uint256) {\\n\\t\\tcERC20 cDai = cERC20(cDaiAddress);\\n\\n\\t\\treturn (((currentPrice() * 1e10) * cDai.exchangeRateStored()) / 1e28); // based on https://compound.finance/docs#protocol-math\\n\\t}\\n\\n\\t/**\\n\\t * @dev helper to mint G$s\\n\\t * @param _to the recipient of newly minted G$s\\n\\t * @param _gdToMint how much G$ to mint\\n\\t * @param _internalCall skip minting role validation for internal calls, used when \\\"buying G$\\\" to \\\"allow\\\" buyer to mint G$ in exchange for his cDAI\\n\\t */\\n\\tfunction _mintGoodDollars(\\n\\t\\taddress _to,\\n\\t\\tuint256 _gdToMint,\\n\\t\\tbool _internalCall\\n\\t) internal {\\n\\t\\t//enforce minting rules\\n\\t\\trequire(\\n\\t\\t\\t_internalCall ||\\n\\t\\t\\t\\t_msgSender() == nameService.getAddress(\\\"FUND_MANAGER\\\") ||\\n\\t\\t\\t\\thasRole(RESERVE_MINTER_ROLE, _msgSender()),\\n\\t\\t\\t\\\"GoodReserve: not a minter\\\"\\n\\t\\t);\\n\\n\\t\\trequire(\\n\\t\\t\\tIGoodDollar(nameService.getAddress(\\\"GOODDOLLAR\\\")).totalSupply() +\\n\\t\\t\\t\\t_gdToMint <=\\n\\t\\t\\t\\tcap,\\n\\t\\t\\t\\\"GoodReserve: cap enforced\\\"\\n\\t\\t);\\n\\n\\t\\tIGoodDollar(nameService.getAddress(\\\"GOODDOLLAR\\\")).mint(_to, _gdToMint);\\n\\t}\\n\\n\\t/// @dev helper to mint GDX to make _mint more verbose\\n\\tfunction _mintGDX(address _to, uint256 _gdx) internal {\\n\\t\\t_mint(_to, _gdx);\\n\\t}\\n\\n\\t/**\\n\\t * @dev only FundManager or other with mint G$ permission can call this to trigger minting.\\n\\t * Reserve sends UBI + interest to FundManager.\\n\\t * @param _daiToConvert DAI amount to convert cDAI\\n\\t * @param _startingCDAIBalance Initial cDAI balance before staking collect process start\\n\\t * @param _interestToken The token that was transfered to the reserve\\n\\t * @return gdUBI,interestInCdai how much GD UBI was minted and how much cDAI collected from staking contracts\\n\\t */\\n\\tfunction mintUBI(\\n\\t\\tuint256 _daiToConvert,\\n\\t\\tuint256 _startingCDAIBalance,\\n\\t\\tERC20 _interestToken\\n\\t) public returns (uint256, uint256) {\\n\\t\\tcERC20(cDaiAddress).mint(_daiToConvert);\\n\\t\\tuint256 interestInCdai = _interestToken.balanceOf(address(this)) -\\n\\t\\t\\t_startingCDAIBalance;\\n\\t\\tuint256 gdInterestToMint = getMarketMaker().mintInterest(\\n\\t\\t\\t_interestToken,\\n\\t\\t\\tinterestInCdai\\n\\t\\t);\\n\\t\\tuint256 gdExpansionToMint = getMarketMaker().mintExpansion(_interestToken);\\n\\t\\tuint256 gdUBI = gdInterestToMint + gdExpansionToMint;\\n\\t\\t//this enforces who can call the public mintUBI method. only an address with permissions at reserve of  RESERVE_MINTER_ROLE\\n\\t\\t_mintGoodDollars(nameService.getAddress(\\\"FUND_MANAGER\\\"), gdUBI, false);\\n\\t\\tlastMinted = block.number;\\n\\t\\temit UBIMinted(\\n\\t\\t\\tlastMinted,\\n\\t\\t\\taddress(_interestToken),\\n\\t\\t\\tinterestInCdai,\\n\\t\\t\\tgdInterestToMint,\\n\\t\\t\\tgdExpansionToMint,\\n\\t\\t\\tgdUBI\\n\\t\\t);\\n\\t\\treturn (gdUBI, interestInCdai);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Allows the DAO to change the daily expansion rate\\n\\t * it is calculated by _nom/_denom with e27 precision. Emits\\n\\t * `ReserveRatioUpdated` event after the ratio has changed.\\n\\t * Only Avatar can call this method.\\n\\t * @param _nom The numerator to calculate the global `reserveRatioDailyExpansion` from\\n\\t * @param _denom The denominator to calculate the global `reserveRatioDailyExpansion` from\\n\\t */\\n\\tfunction setReserveRatioDailyExpansion(uint256 _nom, uint256 _denom) public {\\n\\t\\t_onlyAvatar();\\n\\t\\tgetMarketMaker().setReserveRatioDailyExpansion(_nom, _denom);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Remove minting rights after it has transferred the cDAI funds to `_avatar`\\n\\t * Only the Avatar can execute this method\\n\\t */\\n\\tfunction end() public {\\n\\t\\t_onlyAvatar();\\n\\t\\t// remaining cDAI tokens in the current reserve contract\\n\\t\\tif (ERC20(cDaiAddress).balanceOf(address(this)) > 0) {\\n\\t\\t\\trequire(\\n\\t\\t\\t\\tERC20(cDaiAddress).transfer(\\n\\t\\t\\t\\t\\taddress(avatar),\\n\\t\\t\\t\\t\\tERC20(cDaiAddress).balanceOf(address(this))\\n\\t\\t\\t\\t),\\n\\t\\t\\t\\t\\\"recover transfer failed\\\"\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\t//restore minting to avatar, so he can re-delegate it\\n\\t\\tIGoodDollar gd = IGoodDollar(nameService.getAddress(\\\"GOODDOLLAR\\\"));\\n\\t\\tif (gd.isMinter(address(avatar)) == false) gd.addMinter(address(avatar));\\n\\n\\t\\tIGoodDollar(nameService.getAddress(\\\"GOODDOLLAR\\\")).renounceMinter();\\n\\t}\\n\\n\\t/**\\n\\t * @dev method to recover any stuck erc20 tokens (ie compound COMP)\\n\\t * @param _token the ERC20 token to recover\\n\\t */\\n\\tfunction recover(ERC20 _token) public {\\n\\t\\t_onlyAvatar();\\n\\t\\trequire(\\n\\t\\t\\t_token.transfer(address(avatar), _token.balanceOf(address(this))),\\n\\t\\t\\t\\\"recover transfer failed\\\"\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @notice prove user balance in a specific blockchain state hash\\n\\t * @dev \\\"rootState\\\" is a special state that can be supplied once, and actually mints reputation on the current blockchain\\n\\t * @param _user the user to prove his balance\\n\\t * @param _gdx the balance we are prooving\\n\\t * @param _proof array of byte32 with proof data (currently merkle tree path)\\n\\t * @return true if proof is valid\\n\\t */\\n\\tfunction claimGDX(\\n\\t\\taddress _user,\\n\\t\\tuint256 _gdx,\\n\\t\\tbytes32[] memory _proof\\n\\t) public returns (bool) {\\n\\t\\trequire(isClaimedGDX[_user] == false, \\\"already claimed gdx\\\");\\n\\t\\tbytes32 leafHash = keccak256(abi.encode(_user, _gdx));\\n\\t\\tbool isProofValid = MerkleProofUpgradeable.verify(\\n\\t\\t\\t_proof,\\n\\t\\t\\tgdxAirdrop,\\n\\t\\t\\tleafHash\\n\\t\\t);\\n\\n\\t\\trequire(isProofValid, \\\"invalid merkle proof\\\");\\n\\n\\t\\t_mintGDX(_user, _gdx);\\n\\n\\t\\tisClaimedGDX[_user] = true;\\n\\t\\treturn true;\\n\\t}\\n\\n\\t// implement minting constraints through the GlobalConstraintInterface interface. prevent any minting not through reserve\\n\\tfunction pre(\\n\\t\\taddress _scheme,\\n\\t\\tbytes32 _hash,\\n\\t\\tbytes32 _method\\n\\t) public pure override returns (bool) {\\n\\t\\t_scheme;\\n\\t\\t_hash;\\n\\t\\t_method;\\n\\t\\tif (_method == \\\"mintTokens\\\") return false;\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction when() public pure override returns (CallPhase) {\\n\\t\\treturn CallPhase.Pre;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/utils/DSMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/// math.sol -- mixin for inline numerical wizardry\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.0;\\n\\ncontract DSMath {\\n\\tfunction rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n\\t\\tz = (x * y) / 10**27;\\n\\t}\\n\\n\\tfunction rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n\\t\\tz = (x * (10**27)) / y;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/utils/DAOUpgradeableContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\nimport \\\"./DAOContract.sol\\\";\\n\\n/**\\n@title Simple contract that adds upgradability to DAOContract\\n*/\\n\\ncontract DAOUpgradeableContract is Initializable, UUPSUpgradeable, DAOContract {\\n\\tfunction _authorizeUpgrade(address) internal virtual override {\\n\\t\\t_onlyAvatar();\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/ERC20BurnableUpgradeable.sol\\\";\\nimport \\\"../extensions/ERC20PausableUpgradeable.sol\\\";\\nimport \\\"../../../access/AccessControlEnumerableUpgradeable.sol\\\";\\nimport \\\"../../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev {ERC20} token, including:\\n *\\n *  - ability for holders to burn (destroy) their tokens\\n *  - a minter role that allows for token minting (creation)\\n *  - a pauser role that allows to stop all token transfers\\n *\\n * This contract uses {AccessControl} to lock permissioned functions using the\\n * different roles - head to its documentation for details.\\n *\\n * The account that deploys the contract will be granted the minter and pauser\\n * roles, as well as the default admin role, which will let it grant both minter\\n * and pauser roles to other accounts.\\n */\\ncontract ERC20PresetMinterPauserUpgradeable is Initializable, ContextUpgradeable, AccessControlEnumerableUpgradeable, ERC20BurnableUpgradeable, ERC20PausableUpgradeable {\\n    function initialize(string memory name, string memory symbol) public virtual initializer {\\n        __ERC20PresetMinterPauser_init(name, symbol);\\n    }\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n    bytes32 public constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\n\\n    /**\\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\\n     * account that deploys the contract.\\n     *\\n     * See {ERC20-constructor}.\\n     */\\n    function __ERC20PresetMinterPauser_init(string memory name, string memory symbol) internal initializer {\\n        __Context_init_unchained();\\n        __ERC165_init_unchained();\\n        __AccessControl_init_unchained();\\n        __AccessControlEnumerable_init_unchained();\\n        __ERC20_init_unchained(name, symbol);\\n        __ERC20Burnable_init_unchained();\\n        __Pausable_init_unchained();\\n        __ERC20Pausable_init_unchained();\\n        __ERC20PresetMinterPauser_init_unchained(name, symbol);\\n    }\\n\\n    function __ERC20PresetMinterPauser_init_unchained(string memory name, string memory symbol) internal initializer {\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n\\n        _setupRole(MINTER_ROLE, _msgSender());\\n        _setupRole(PAUSER_ROLE, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Creates `amount` new tokens for `to`.\\n     *\\n     * See {ERC20-_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `MINTER_ROLE`.\\n     */\\n    function mint(address to, uint256 amount) public virtual {\\n        require(hasRole(MINTER_ROLE, _msgSender()), \\\"ERC20PresetMinterPauser: must have minter role to mint\\\");\\n        _mint(to, amount);\\n    }\\n\\n    /**\\n     * @dev Pauses all token transfers.\\n     *\\n     * See {ERC20Pausable} and {Pausable-_pause}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `PAUSER_ROLE`.\\n     */\\n    function pause() public virtual {\\n        require(hasRole(PAUSER_ROLE, _msgSender()), \\\"ERC20PresetMinterPauser: must have pauser role to pause\\\");\\n        _pause();\\n    }\\n\\n    /**\\n     * @dev Unpauses all token transfers.\\n     *\\n     * See {ERC20Pausable} and {Pausable-_unpause}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `PAUSER_ROLE`.\\n     */\\n    function unpause() public virtual {\\n        require(hasRole(PAUSER_ROLE, _msgSender()), \\\"ERC20PresetMinterPauser: must have pauser role to unpause\\\");\\n        _unpause();\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual override(ERC20Upgradeable, ERC20PausableUpgradeable) {\\n        super._beforeTokenTransfer(from, to, amount);\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProofUpgradeable {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/reserve/GoodMarketMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"../utils/DSMath.sol\\\";\\nimport \\\"../utils/BancorFormula.sol\\\";\\nimport \\\"../DAOStackInterfaces.sol\\\";\\nimport \\\"../Interfaces.sol\\\";\\nimport \\\"../utils/DAOUpgradeableContract.sol\\\";\\n\\n/**\\n@title Dynamic reserve ratio market maker\\n*/\\ncontract GoodMarketMaker is DAOUpgradeableContract, DSMath {\\n\\t// Entity that holds a reserve token\\n\\tstruct ReserveToken {\\n\\t\\t// Determines the reserve token balance\\n\\t\\t// that the reserve contract holds\\n\\t\\tuint256 reserveSupply;\\n\\t\\t// Determines the current ratio between\\n\\t\\t// the reserve token and the GD token\\n\\t\\tuint32 reserveRatio;\\n\\t\\t// How many GD tokens have been minted\\n\\t\\t// against that reserve token\\n\\t\\tuint256 gdSupply;\\n\\t\\t// Last time reserve ratio was expanded\\n\\t\\tuint256 lastExpansion;\\n\\t}\\n\\n\\t// The map which holds the reserve token entities\\n\\tmapping(address => ReserveToken) public reserveTokens;\\n\\n\\t// Emits when a change has occurred in a\\n\\t// reserve balance, i.e. buy / sell will\\n\\t// change the balance\\n\\tevent BalancesUpdated(\\n\\t\\t// The account who initiated the action\\n\\t\\taddress indexed caller,\\n\\t\\t// The address of the reserve token\\n\\t\\taddress indexed reserveToken,\\n\\t\\t// The incoming amount\\n\\t\\tuint256 amount,\\n\\t\\t// The return value\\n\\t\\tuint256 returnAmount,\\n\\t\\t// The updated total supply\\n\\t\\tuint256 totalSupply,\\n\\t\\t// The updated reserve balance\\n\\t\\tuint256 reserveBalance\\n\\t);\\n\\n\\t// Emits when the ratio changed. The caller should be the Avatar by definition\\n\\tevent ReserveRatioUpdated(address indexed caller, uint256 nom, uint256 denom);\\n\\n\\t// Defines the daily change in the reserve ratio in RAY precision.\\n\\t// In the current release, only global ratio expansion is supported.\\n\\t// That will be a part of each reserve token entity in the future.\\n\\tuint256 public reserveRatioDailyExpansion;\\n\\n\\t//goodDollar token decimals\\n\\tuint256 decimals;\\n\\n\\t/**\\n\\t * @dev Constructor\\n\\t * @param _nom The numerator to calculate the global `reserveRatioDailyExpansion` from\\n\\t * @param _denom The denominator to calculate the global `reserveRatioDailyExpansion` from\\n\\t */\\n\\tfunction initialize(\\n\\t\\tINameService _ns,\\n\\t\\tuint256 _nom,\\n\\t\\tuint256 _denom\\n\\t) public virtual initializer {\\n\\t\\treserveRatioDailyExpansion = (_nom * 1e27) / _denom;\\n\\t\\tdecimals = 2;\\n\\t\\tsetDAO(_ns);\\n\\t}\\n\\n\\tfunction _onlyActiveToken(ERC20 _token) internal view {\\n\\t\\tReserveToken storage rtoken = reserveTokens[address(_token)];\\n\\t\\trequire(rtoken.gdSupply > 0, \\\"Reserve token not initialized\\\");\\n\\t}\\n\\n\\tfunction _onlyReserveOrAvatar() internal view {\\n\\t\\trequire(\\n\\t\\t\\tnameService.getAddress(\\\"RESERVE\\\") == msg.sender ||\\n\\t\\t\\t\\tnameService.getAddress(\\\"AVATAR\\\") == msg.sender,\\n\\t\\t\\t\\\"GoodMarketMaker: not Reserve or Avatar\\\"\\n\\t\\t);\\n\\t}\\n\\n\\tfunction getBancor() public view returns (BancorFormula) {\\n\\t\\treturn BancorFormula(nameService.getAddress(\\\"BANCOR_FORMULA\\\"));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Allows the DAO to change the daily expansion rate\\n\\t * it is calculated by _nom/_denom with e27 precision. Emits\\n\\t * `ReserveRatioUpdated` event after the ratio has changed.\\n\\t * Only Avatar can call this method.\\n\\t * @param _nom The numerator to calculate the global `reserveRatioDailyExpansion` from\\n\\t * @param _denom The denominator to calculate the global `reserveRatioDailyExpansion` from\\n\\t */\\n\\tfunction setReserveRatioDailyExpansion(uint256 _nom, uint256 _denom) public {\\n\\t\\t_onlyReserveOrAvatar();\\n\\t\\trequire(_denom > 0, \\\"denominator must be above 0\\\");\\n\\t\\treserveRatioDailyExpansion = (_nom * 1e27) / _denom;\\n\\t\\trequire(reserveRatioDailyExpansion < 1e27, \\\"Invalid nom or denom value\\\");\\n\\t\\temit ReserveRatioUpdated(msg.sender, _nom, _denom);\\n\\t}\\n\\n\\t// NOTICE: In the current release, if there is a wish to add another reserve token,\\n\\t//  `end` method in the reserve contract should be called first. Then, the DAO have\\n\\t//  to deploy a new reserve contract that will own the market maker. A scheme for\\n\\t// updating the new reserve must be deployed too.\\n\\n\\t/**\\n\\t * @dev Initialize a reserve token entity with the given parameters\\n\\t * @param _token The reserve token\\n\\t * @param _gdSupply Initial supply of GD to set the price\\n\\t * @param _tokenSupply Initial supply of reserve token to set the price\\n\\t * @param _reserveRatio The starting reserve ratio\\n\\t * @param _lastExpansion Last time reserve ratio was expanded\\n\\t */\\n\\tfunction initializeToken(\\n\\t\\tERC20 _token,\\n\\t\\tuint256 _gdSupply,\\n\\t\\tuint256 _tokenSupply,\\n\\t\\tuint32 _reserveRatio,\\n\\t\\tuint256 _lastExpansion\\n\\t) public {\\n\\t\\t_onlyReserveOrAvatar();\\n\\t\\treserveTokens[address(_token)] = ReserveToken({\\n\\t\\t\\tgdSupply: _gdSupply,\\n\\t\\t\\treserveSupply: _tokenSupply,\\n\\t\\t\\treserveRatio: _reserveRatio,\\n\\t\\t\\tlastExpansion: _lastExpansion == 0 ? block.timestamp : _lastExpansion\\n\\t\\t});\\n\\t}\\n\\n\\t/**\\n\\t * @dev Calculates how much to decrease the reserve ratio for _token by\\n\\t * the `reserveRatioDailyExpansion`\\n\\t * @param _token The reserve token to calculate the reserve ratio for\\n\\t * @return The new reserve ratio\\n\\t */\\n\\tfunction calculateNewReserveRatio(ERC20 _token) public view returns (uint32) {\\n\\t\\tReserveToken memory reserveToken = reserveTokens[address(_token)];\\n\\t\\tuint256 ratio = uint256(reserveToken.reserveRatio);\\n\\t\\tif (ratio == 0) {\\n\\t\\t\\tratio = 1e6;\\n\\t\\t}\\n\\t\\tratio *= 1e21; //expand to e27 precision\\n\\n\\t\\tuint256 daysPassed = (block.timestamp - reserveToken.lastExpansion) /\\n\\t\\t\\t1 days;\\n\\t\\tfor (uint256 i = 0; i < daysPassed; i++) {\\n\\t\\t\\tratio = (ratio * reserveRatioDailyExpansion) / 1e27;\\n\\t\\t}\\n\\n\\t\\treturn uint32(ratio / 1e21); // return to e6 precision\\n\\t}\\n\\n\\t/**\\n\\t * @dev Decreases the reserve ratio for _token by the `reserveRatioDailyExpansion`\\n\\t * @param _token The token to change the reserve ratio for\\n\\t * @return The new reserve ratio\\n\\t */\\n\\tfunction expandReserveRatio(ERC20 _token) public returns (uint32) {\\n\\t\\t_onlyReserveOrAvatar();\\n\\t\\t_onlyActiveToken(_token);\\n\\t\\tReserveToken storage reserveToken = reserveTokens[address(_token)];\\n\\t\\tuint32 ratio = reserveToken.reserveRatio;\\n\\t\\tif (ratio == 0) {\\n\\t\\t\\tratio = 1e6;\\n\\t\\t}\\n\\t\\treserveToken.reserveRatio = calculateNewReserveRatio(_token);\\n\\n\\t\\t//set last expansion to begining of expansion day\\n\\t\\treserveToken.lastExpansion =\\n\\t\\t\\tblock.timestamp -\\n\\t\\t\\t((block.timestamp - reserveToken.lastExpansion) % 1 days);\\n\\t\\treturn reserveToken.reserveRatio;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Calculates the buy return in GD according to the given _tokenAmount\\n\\t * @param _token The reserve token buying with\\n\\t * @param _tokenAmount The amount of reserve token buying with\\n\\t * @return Number of GD that should be given in exchange as calculated by the bonding curve\\n\\t */\\n\\tfunction buyReturn(ERC20 _token, uint256 _tokenAmount)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\tReserveToken memory rtoken = reserveTokens[address(_token)];\\n\\t\\treturn\\n\\t\\t\\tgetBancor().calculatePurchaseReturn(\\n\\t\\t\\t\\trtoken.gdSupply,\\n\\t\\t\\t\\trtoken.reserveSupply,\\n\\t\\t\\t\\trtoken.reserveRatio,\\n\\t\\t\\t\\t_tokenAmount\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Calculates the sell return in _token according to the given _gdAmount\\n\\t * @param _token The desired reserve token to have\\n\\t * @param _gdAmount The amount of GD that are sold\\n\\t * @return Number of tokens that should be given in exchange as calculated by the bonding curve\\n\\t */\\n\\tfunction sellReturn(ERC20 _token, uint256 _gdAmount)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\tReserveToken memory rtoken = reserveTokens[address(_token)];\\n\\t\\treturn\\n\\t\\t\\tgetBancor().calculateSaleReturn(\\n\\t\\t\\t\\trtoken.gdSupply,\\n\\t\\t\\t\\trtoken.reserveSupply,\\n\\t\\t\\t\\trtoken.reserveRatio,\\n\\t\\t\\t\\t_gdAmount\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Updates the _token bonding curve params. Emits `BalancesUpdated` with the\\n\\t * new reserve token information.\\n\\t * @param _token The reserve token buying with\\n\\t * @param _tokenAmount The amount of reserve token buying with\\n\\t * @return (gdReturn) Number of GD that will be given in exchange as calculated by the bonding curve\\n\\t */\\n\\tfunction buy(ERC20 _token, uint256 _tokenAmount) public returns (uint256) {\\n\\t\\t_onlyReserveOrAvatar();\\n\\t\\t_onlyActiveToken(_token);\\n\\n\\t\\tuint256 gdReturn = buyReturn(_token, _tokenAmount);\\n\\t\\tReserveToken storage rtoken = reserveTokens[address(_token)];\\n\\t\\trtoken.gdSupply += gdReturn;\\n\\t\\trtoken.reserveSupply += _tokenAmount;\\n\\t\\temit BalancesUpdated(\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\taddress(_token),\\n\\t\\t\\t_tokenAmount,\\n\\t\\t\\tgdReturn,\\n\\t\\t\\trtoken.gdSupply,\\n\\t\\t\\trtoken.reserveSupply\\n\\t\\t);\\n\\t\\treturn gdReturn;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Updates the bonding curve params. Decrease RR to in order to mint gd in the amount of provided\\n\\t * new RR = Reserve supply / ((gd supply + gd mint amount) * price)\\n\\t * @param _gdAmount Amount of gd to add reserveParams\\n\\t * @param _token The reserve token which is currently active\\n\\t */\\n\\tfunction mintFromReserveRatio(ERC20 _token, uint256 _gdAmount) public {\\n\\t\\t_onlyReserveOrAvatar();\\n\\t\\t_onlyActiveToken(_token);\\n\\t\\tuint256 reserveDecimalsDiff = uint256(27) - _token.decimals(); // //result is in RAY precision\\n\\t\\tReserveToken storage rtoken = reserveTokens[address(_token)];\\n\\t\\tuint256 priceBeforeGdSupplyChange = currentPrice(_token);\\n\\t\\trtoken.gdSupply += _gdAmount;\\n\\t\\trtoken.reserveRatio = uint32(\\n\\t\\t\\t((rtoken.reserveSupply * 1e27) /\\n\\t\\t\\t\\t(rtoken.gdSupply * priceBeforeGdSupplyChange)) / 10**reserveDecimalsDiff\\n\\t\\t); // Divide it decimal diff to bring it proper decimal\\n\\t}\\n\\n\\t/**\\n\\t * @dev Calculates the sell return with contribution in _token and update the bonding curve params.\\n\\t * Emits `BalancesUpdated` with the new reserve token information.\\n\\t * @param _token The desired reserve token to have\\n\\t * @param _gdAmount The amount of GD that are sold\\n\\t * @param _contributionGdAmount The number of GD tokens that will not be traded for the reserve token\\n\\t * @return Number of tokens that will be given in exchange as calculated by the bonding curve\\n\\t */\\n\\tfunction sellWithContribution(\\n\\t\\tERC20 _token,\\n\\t\\tuint256 _gdAmount,\\n\\t\\tuint256 _contributionGdAmount\\n\\t) public returns (uint256) {\\n\\t\\t_onlyReserveOrAvatar();\\n\\t\\t_onlyActiveToken(_token);\\n\\n\\t\\trequire(\\n\\t\\t\\t_gdAmount >= _contributionGdAmount,\\n\\t\\t\\t\\\"GD amount is lower than the contribution amount\\\"\\n\\t\\t);\\n\\t\\tReserveToken storage rtoken = reserveTokens[address(_token)];\\n\\t\\trequire(\\n\\t\\t\\trtoken.gdSupply >= _gdAmount,\\n\\t\\t\\t\\\"GD amount is higher than the total supply\\\"\\n\\t\\t);\\n\\n\\t\\t// Deduces the convertible amount of GD tokens by the given contribution amount\\n\\t\\tuint256 amountAfterContribution = _gdAmount - _contributionGdAmount;\\n\\n\\t\\t// The return value after the deduction\\n\\t\\tuint256 tokenReturn = sellReturn(_token, amountAfterContribution);\\n\\t\\trtoken.gdSupply -= _gdAmount;\\n\\t\\trtoken.reserveSupply -= tokenReturn;\\n\\t\\temit BalancesUpdated(\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\taddress(_token),\\n\\t\\t\\t_contributionGdAmount,\\n\\t\\t\\ttokenReturn,\\n\\t\\t\\trtoken.gdSupply,\\n\\t\\t\\trtoken.reserveSupply\\n\\t\\t);\\n\\t\\treturn tokenReturn;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Current price of GD in `token`. currently only cDAI is supported.\\n\\t * @param _token The desired reserve token to have\\n\\t * @return price of GD\\n\\t */\\n\\tfunction currentPrice(ERC20 _token) public view returns (uint256) {\\n\\t\\tReserveToken memory rtoken = reserveTokens[address(_token)];\\n\\t\\treturn\\n\\t\\t\\tgetBancor().calculateSaleReturn(\\n\\t\\t\\t\\trtoken.gdSupply,\\n\\t\\t\\t\\trtoken.reserveSupply,\\n\\t\\t\\t\\trtoken.reserveRatio,\\n\\t\\t\\t\\t(10**decimals)\\n\\t\\t\\t);\\n\\t}\\n\\n\\t//TODO: need real calculation and tests\\n\\t/**\\n\\t * @dev Calculates how much G$ to mint based on added token supply (from interest)\\n\\t * and on current reserve ratio, in order to keep G$ price the same at the bonding curve\\n\\t * formula to calculate the gd to mint: gd to mint =\\n\\t * addreservebalance * (gdsupply / (reservebalance * reserveratio))\\n\\t * @param _token the reserve token\\n\\t * @param _addTokenSupply amount of token added to supply\\n\\t * @return how much to mint in order to keep price in bonding curve the same\\n\\t */\\n\\tfunction calculateMintInterest(ERC20 _token, uint256 _addTokenSupply)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\tuint256 decimalsDiff = uint256(27) - decimals;\\n\\t\\t//resulting amount is in RAY precision\\n\\t\\t//we divide by decimalsdiff to get precision in GD (2 decimals)\\n\\t\\treturn\\n\\t\\t\\t((_addTokenSupply * 1e27) / currentPrice(_token)) / (10**decimalsDiff);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Updates bonding curve based on _addTokenSupply and new minted amount\\n\\t * @param _token The reserve token\\n\\t * @param _addTokenSupply Amount of token added to supply\\n\\t * @return How much to mint in order to keep price in bonding curve the same\\n\\t */\\n\\tfunction mintInterest(ERC20 _token, uint256 _addTokenSupply)\\n\\t\\tpublic\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\t_onlyReserveOrAvatar();\\n\\t\\t_onlyActiveToken(_token);\\n\\t\\tif (_addTokenSupply == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tuint256 toMint = calculateMintInterest(_token, _addTokenSupply);\\n\\t\\tReserveToken storage reserveToken = reserveTokens[address(_token)];\\n\\t\\treserveToken.gdSupply += toMint;\\n\\t\\treserveToken.reserveSupply += _addTokenSupply;\\n\\n\\t\\treturn toMint;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Calculate how much G$ to mint based on expansion change (new reserve\\n\\t * ratio), in order to keep G$ price the same at the bonding curve. the\\n\\t * formula to calculate the gd to mint: gd to mint =\\n\\t * (reservebalance / (newreserveratio * currentprice)) - gdsupply\\n\\t * @param _token The reserve token\\n\\t * @return How much to mint in order to keep price in bonding curve the same\\n\\t */\\n\\tfunction calculateMintExpansion(ERC20 _token) public view returns (uint256) {\\n\\t\\tReserveToken memory reserveToken = reserveTokens[address(_token)];\\n\\t\\tuint32 newReserveRatio = calculateNewReserveRatio(_token); // new reserve ratio\\n\\t\\tuint256 reserveDecimalsDiff = uint256(27) - _token.decimals(); // //result is in RAY precision\\n\\t\\tuint256 denom = (uint256(newReserveRatio) *\\n\\t\\t\\t1e21 *\\n\\t\\t\\tcurrentPrice(_token) *\\n\\t\\t\\t(10**reserveDecimalsDiff)) / 1e27; // (newreserveratio * currentprice) in RAY precision\\n\\t\\tuint256 gdDecimalsDiff = uint256(27) - decimals;\\n\\t\\tuint256 toMint = ((reserveToken.reserveSupply *\\n\\t\\t\\t(10**reserveDecimalsDiff) *\\n\\t\\t\\t1e27) / denom) / (10**gdDecimalsDiff); // reservebalance in RAY precision // return to gd precision\\n\\t\\treturn toMint - reserveToken.gdSupply;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Updates bonding curve based on expansion change and new minted amount\\n\\t * @param _token The reserve token\\n\\t * @return How much to mint in order to keep price in bonding curve the same\\n\\t */\\n\\tfunction mintExpansion(ERC20 _token) public returns (uint256) {\\n\\t\\t_onlyReserveOrAvatar();\\n\\t\\t_onlyActiveToken(_token);\\n\\t\\tuint256 toMint = calculateMintExpansion(_token);\\n\\t\\treserveTokens[address(_token)].gdSupply += toMint;\\n\\t\\texpandReserveRatio(_token);\\n\\n\\t\\treturn toMint;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20Upgradeable.sol\\\";\\nimport \\\"../../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\\n    function __ERC20Burnable_init() internal initializer {\\n        __Context_init_unchained();\\n        __ERC20Burnable_init_unchained();\\n    }\\n\\n    function __ERC20Burnable_init_unchained() internal initializer {\\n    }\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        uint256 currentAllowance = allowance(account, _msgSender());\\n        require(currentAllowance >= amount, \\\"ERC20: burn amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(account, _msgSender(), currentAllowance - amount);\\n        }\\n        _burn(account, amount);\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20Upgradeable.sol\\\";\\nimport \\\"../../../security/PausableUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev ERC20 token with pausable token transfers, minting and burning.\\n *\\n * Useful for scenarios such as preventing trades until the end of an evaluation\\n * period, or having an emergency switch for freezing all token transfers in the\\n * event of a large bug.\\n */\\nabstract contract ERC20PausableUpgradeable is Initializable, ERC20Upgradeable, PausableUpgradeable {\\n    function __ERC20Pausable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Pausable_init_unchained();\\n        __ERC20Pausable_init_unchained();\\n    }\\n\\n    function __ERC20Pausable_init_unchained() internal initializer {\\n    }\\n    /**\\n     * @dev See {ERC20-_beforeTokenTransfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - the contract must not be paused.\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, amount);\\n\\n        require(!paused(), \\\"ERC20Pausable: token transfer while paused\\\");\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlEnumerableUpgradeable.sol\\\";\\nimport \\\"./AccessControlUpgradeable.sol\\\";\\nimport \\\"../utils/structs/EnumerableSetUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\\n */\\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\\n    function __AccessControlEnumerable_init() internal initializer {\\n        __Context_init_unchained();\\n        __ERC165_init_unchained();\\n        __AccessControl_init_unchained();\\n        __AccessControlEnumerable_init_unchained();\\n    }\\n\\n    function __AccessControlEnumerable_init_unchained() internal initializer {\\n    }\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\n\\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\\n        return _roleMembers[role].at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\\n        return _roleMembers[role].length();\\n    }\\n\\n    /**\\n     * @dev Overload {grantRole} to track enumerable memberships\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControlUpgradeable) {\\n        super.grantRole(role, account);\\n        _roleMembers[role].add(account);\\n    }\\n\\n    /**\\n     * @dev Overload {revokeRole} to track enumerable memberships\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControlUpgradeable) {\\n        super.revokeRole(role, account);\\n        _roleMembers[role].remove(account);\\n    }\\n\\n    /**\\n     * @dev Overload {renounceRole} to track enumerable memberships\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControlUpgradeable) {\\n        super.renounceRole(role, account);\\n        _roleMembers[role].remove(account);\\n    }\\n\\n    /**\\n     * @dev Overload {_setupRole} to track enumerable memberships\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual override {\\n        super._setupRole(role, account);\\n        _roleMembers[role].add(account);\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal initializer {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlUpgradeable.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\\n */\\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlUpgradeable.sol\\\";\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../utils/StringsUpgradeable.sol\\\";\\nimport \\\"../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\\n    function __AccessControl_init() internal initializer {\\n        __Context_init_unchained();\\n        __ERC165_init_unchained();\\n        __AccessControl_init_unchained();\\n    }\\n\\n    function __AccessControl_init_unchained() internal initializer {\\n    }\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        StringsUpgradeable.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        StringsUpgradeable.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSetUpgradeable {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastvalue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastvalue;\\n                // Update the index for the moved value\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControlUpgradeable {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal initializer {\\n        __ERC165_init_unchained();\\n    }\\n\\n    function __ERC165_init_unchained() internal initializer {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/BancorFormula.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.8.0;\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\\\";\\n\\ncontract BancorFormula {\\n\\tusing SafeMathUpgradeable for uint256;\\n\\n\\tuint256 private constant ONE = 1;\\n\\tuint32 private constant MAX_WEIGHT = 1000000;\\n\\tuint8 private constant MIN_PRECISION = 32;\\n\\tuint8 private constant MAX_PRECISION = 127;\\n\\n\\t// Auto-generated via 'PrintIntScalingFactors.py'\\n\\tuint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\\n\\tuint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\\n\\tuint256 private constant MAX_NUM = 0x200000000000000000000000000000000;\\n\\n\\t// Auto-generated via 'PrintLn2ScalingFactors.py'\\n\\tuint256 private constant LN2_NUMERATOR = 0x3f80fe03f80fe03f80fe03f80fe03f8;\\n\\tuint256 private constant LN2_DENOMINATOR =\\n\\t\\t0x5b9de1d10bf4103d647b0955897ba80;\\n\\n\\t// Auto-generated via 'PrintFunctionOptimalLog.py' and 'PrintFunctionOptimalExp.py'\\n\\tuint256 private constant OPT_LOG_MAX_VAL =\\n\\t\\t0x15bf0a8b1457695355fb8ac404e7a79e3;\\n\\tuint256 private constant OPT_EXP_MAX_VAL =\\n\\t\\t0x800000000000000000000000000000000;\\n\\n\\t// Auto-generated via 'PrintLambertFactors.py'\\n\\tuint256 private constant LAMBERT_CONV_RADIUS =\\n\\t\\t0x002f16ac6c59de6f8d5d6f63c1482a7c86;\\n\\tuint256 private constant LAMBERT_POS2_SAMPLE =\\n\\t\\t0x0003060c183060c183060c183060c18306;\\n\\tuint256 private constant LAMBERT_POS2_MAXVAL =\\n\\t\\t0x01af16ac6c59de6f8d5d6f63c1482a7c80;\\n\\tuint256 private constant LAMBERT_POS3_MAXVAL =\\n\\t\\t0x6b22d43e72c326539cceeef8bb48f255ff;\\n\\n\\t// Auto-generated via 'PrintWeightFactors.py'\\n\\tuint256 private constant MAX_UNF_WEIGHT =\\n\\t\\t0x10c6f7a0b5ed8d36b4c7f34938583621fafc8b0079a2834d26fa3fcc9ea9;\\n\\n\\t// Auto-generated via 'PrintMaxExpArray.py'\\n\\tuint256[128] private maxExpArray;\\n\\n\\tfunction initMaxExpArray() private {\\n\\t\\t//  maxExpArray[  0] = 0x6bffffffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[  1] = 0x67ffffffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[  2] = 0x637fffffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[  3] = 0x5f6fffffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[  4] = 0x5b77ffffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[  5] = 0x57b3ffffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[  6] = 0x5419ffffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[  7] = 0x50a2ffffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[  8] = 0x4d517fffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[  9] = 0x4a233fffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 10] = 0x47165fffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 11] = 0x4429afffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 12] = 0x415bc7ffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 13] = 0x3eab73ffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 14] = 0x3c1771ffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 15] = 0x399e96ffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 16] = 0x373fc47fffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 17] = 0x34f9e8ffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 18] = 0x32cbfd5fffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 19] = 0x30b5057fffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 20] = 0x2eb40f9fffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 21] = 0x2cc8340fffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 22] = 0x2af09481ffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 23] = 0x292c5bddffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 24] = 0x277abdcdffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 25] = 0x25daf6657fffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 26] = 0x244c49c65fffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 27] = 0x22ce03cd5fffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 28] = 0x215f77c047ffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 29] = 0x1fffffffffffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 30] = 0x1eaefdbdabffffffffffffffffffffffff;\\n\\t\\t//  maxExpArray[ 31] = 0x1d6bd8b2ebffffffffffffffffffffffff;\\n\\t\\tmaxExpArray[32] = 0x1c35fedd14ffffffffffffffffffffffff;\\n\\t\\tmaxExpArray[33] = 0x1b0ce43b323fffffffffffffffffffffff;\\n\\t\\tmaxExpArray[34] = 0x19f0028ec1ffffffffffffffffffffffff;\\n\\t\\tmaxExpArray[35] = 0x18ded91f0e7fffffffffffffffffffffff;\\n\\t\\tmaxExpArray[36] = 0x17d8ec7f0417ffffffffffffffffffffff;\\n\\t\\tmaxExpArray[37] = 0x16ddc6556cdbffffffffffffffffffffff;\\n\\t\\tmaxExpArray[38] = 0x15ecf52776a1ffffffffffffffffffffff;\\n\\t\\tmaxExpArray[39] = 0x15060c256cb2ffffffffffffffffffffff;\\n\\t\\tmaxExpArray[40] = 0x1428a2f98d72ffffffffffffffffffffff;\\n\\t\\tmaxExpArray[41] = 0x13545598e5c23fffffffffffffffffffff;\\n\\t\\tmaxExpArray[42] = 0x1288c4161ce1dfffffffffffffffffffff;\\n\\t\\tmaxExpArray[43] = 0x11c592761c666fffffffffffffffffffff;\\n\\t\\tmaxExpArray[44] = 0x110a688680a757ffffffffffffffffffff;\\n\\t\\tmaxExpArray[45] = 0x1056f1b5bedf77ffffffffffffffffffff;\\n\\t\\tmaxExpArray[46] = 0x0faadceceeff8bffffffffffffffffffff;\\n\\t\\tmaxExpArray[47] = 0x0f05dc6b27edadffffffffffffffffffff;\\n\\t\\tmaxExpArray[48] = 0x0e67a5a25da4107fffffffffffffffffff;\\n\\t\\tmaxExpArray[49] = 0x0dcff115b14eedffffffffffffffffffff;\\n\\t\\tmaxExpArray[50] = 0x0d3e7a392431239fffffffffffffffffff;\\n\\t\\tmaxExpArray[51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\\n\\t\\tmaxExpArray[52] = 0x0c2d415c3db974afffffffffffffffffff;\\n\\t\\tmaxExpArray[53] = 0x0bad03e7d883f69bffffffffffffffffff;\\n\\t\\tmaxExpArray[54] = 0x0b320d03b2c343d5ffffffffffffffffff;\\n\\t\\tmaxExpArray[55] = 0x0abc25204e02828dffffffffffffffffff;\\n\\t\\tmaxExpArray[56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\\n\\t\\tmaxExpArray[57] = 0x09deaf736ac1f569ffffffffffffffffff;\\n\\t\\tmaxExpArray[58] = 0x0976bd9952c7aa957fffffffffffffffff;\\n\\t\\tmaxExpArray[59] = 0x09131271922eaa606fffffffffffffffff;\\n\\t\\tmaxExpArray[60] = 0x08b380f3558668c46fffffffffffffffff;\\n\\t\\tmaxExpArray[61] = 0x0857ddf0117efa215bffffffffffffffff;\\n\\t\\tmaxExpArray[62] = 0x07ffffffffffffffffffffffffffffffff;\\n\\t\\tmaxExpArray[63] = 0x07abbf6f6abb9d087fffffffffffffffff;\\n\\t\\tmaxExpArray[64] = 0x075af62cbac95f7dfa7fffffffffffffff;\\n\\t\\tmaxExpArray[65] = 0x070d7fb7452e187ac13fffffffffffffff;\\n\\t\\tmaxExpArray[66] = 0x06c3390ecc8af379295fffffffffffffff;\\n\\t\\tmaxExpArray[67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\\n\\t\\tmaxExpArray[68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\\n\\t\\tmaxExpArray[69] = 0x05f63b1fc104dbd39587ffffffffffffff;\\n\\t\\tmaxExpArray[70] = 0x05b771955b36e12f7235ffffffffffffff;\\n\\t\\tmaxExpArray[71] = 0x057b3d49dda84556d6f6ffffffffffffff;\\n\\t\\tmaxExpArray[72] = 0x054183095b2c8ececf30ffffffffffffff;\\n\\t\\tmaxExpArray[73] = 0x050a28be635ca2b888f77fffffffffffff;\\n\\t\\tmaxExpArray[74] = 0x04d5156639708c9db33c3fffffffffffff;\\n\\t\\tmaxExpArray[75] = 0x04a23105873875bd52dfdfffffffffffff;\\n\\t\\tmaxExpArray[76] = 0x0471649d87199aa990756fffffffffffff;\\n\\t\\tmaxExpArray[77] = 0x04429a21a029d4c1457cfbffffffffffff;\\n\\t\\tmaxExpArray[78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\\n\\t\\tmaxExpArray[79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\\n\\t\\tmaxExpArray[80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\\n\\t\\tmaxExpArray[81] = 0x0399e96897690418f785257fffffffffff;\\n\\t\\tmaxExpArray[82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\\n\\t\\tmaxExpArray[83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\\n\\t\\tmaxExpArray[84] = 0x032cbfd4a7adc790560b3337ffffffffff;\\n\\t\\tmaxExpArray[85] = 0x030b50570f6e5d2acca94613ffffffffff;\\n\\t\\tmaxExpArray[86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\\n\\t\\tmaxExpArray[87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\\n\\t\\tmaxExpArray[88] = 0x02af09481380a0a35cf1ba02ffffffffff;\\n\\t\\tmaxExpArray[89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\\n\\t\\tmaxExpArray[90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\\n\\t\\tmaxExpArray[91] = 0x025daf6654b1eaa55fd64df5efffffffff;\\n\\t\\tmaxExpArray[92] = 0x0244c49c648baa98192dce88b7ffffffff;\\n\\t\\tmaxExpArray[93] = 0x022ce03cd5619a311b2471268bffffffff;\\n\\t\\tmaxExpArray[94] = 0x0215f77c045fbe885654a44a0fffffffff;\\n\\t\\tmaxExpArray[95] = 0x01ffffffffffffffffffffffffffffffff;\\n\\t\\tmaxExpArray[96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\\n\\t\\tmaxExpArray[97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\\n\\t\\tmaxExpArray[98] = 0x01c35fedd14b861eb0443f7f133fffffff;\\n\\t\\tmaxExpArray[99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\\n\\t\\tmaxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\\n\\t\\tmaxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\\n\\t\\tmaxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\\n\\t\\tmaxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\\n\\t\\tmaxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\\n\\t\\tmaxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\\n\\t\\tmaxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\\n\\t\\tmaxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\\n\\t\\tmaxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\\n\\t\\tmaxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\\n\\t\\tmaxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\\n\\t\\tmaxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\\n\\t\\tmaxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\\n\\t\\tmaxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\\n\\t\\tmaxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\\n\\t\\tmaxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\\n\\t\\tmaxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\\n\\t\\tmaxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\\n\\t\\tmaxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\\n\\t\\tmaxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\\n\\t\\tmaxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\\n\\t\\tmaxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\\n\\t\\tmaxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\\n\\t\\tmaxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\\n\\t\\tmaxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\\n\\t\\tmaxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\\n\\t\\tmaxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\\n\\t\\tmaxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\\n\\t}\\n\\n\\t// Auto-generated via 'PrintLambertArray.py'\\n\\tuint256[128] private lambertArray;\\n\\n\\tfunction initLambertArray() private {\\n\\t\\tlambertArray[0] = 0x60e393c68d20b1bd09deaabc0373b9c5;\\n\\t\\tlambertArray[1] = 0x5f8f46e4854120989ed94719fb4c2011;\\n\\t\\tlambertArray[2] = 0x5e479ebb9129fb1b7e72a648f992b606;\\n\\t\\tlambertArray[3] = 0x5d0bd23fe42dfedde2e9586be12b85fe;\\n\\t\\tlambertArray[4] = 0x5bdb29ddee979308ddfca81aeeb8095a;\\n\\t\\tlambertArray[5] = 0x5ab4fd8a260d2c7e2c0d2afcf0009dad;\\n\\t\\tlambertArray[6] = 0x5998b31359a55d48724c65cf09001221;\\n\\t\\tlambertArray[7] = 0x5885bcad2b322dfc43e8860f9c018cf5;\\n\\t\\tlambertArray[8] = 0x577b97aa1fe222bb452fdf111b1f0be2;\\n\\t\\tlambertArray[9] = 0x5679cb5e3575632e5baa27e2b949f704;\\n\\t\\tlambertArray[10] = 0x557fe8241b3a31c83c732f1cdff4a1c5;\\n\\t\\tlambertArray[11] = 0x548d868026504875d6e59bbe95fc2a6b;\\n\\t\\tlambertArray[12] = 0x53a2465ce347cf34d05a867c17dd3088;\\n\\t\\tlambertArray[13] = 0x52bdce5dcd4faed59c7f5511cf8f8acc;\\n\\t\\tlambertArray[14] = 0x51dfcb453c07f8da817606e7885f7c3e;\\n\\t\\tlambertArray[15] = 0x5107ef6b0a5a2be8f8ff15590daa3cce;\\n\\t\\tlambertArray[16] = 0x5035f241d6eae0cd7bacba119993de7b;\\n\\t\\tlambertArray[17] = 0x4f698fe90d5b53d532171e1210164c66;\\n\\t\\tlambertArray[18] = 0x4ea288ca297a0e6a09a0eee240e16c85;\\n\\t\\tlambertArray[19] = 0x4de0a13fdcf5d4213fc398ba6e3becde;\\n\\t\\tlambertArray[20] = 0x4d23a145eef91fec06b06140804c4808;\\n\\t\\tlambertArray[21] = 0x4c6b5430d4c1ee5526473db4ae0f11de;\\n\\t\\tlambertArray[22] = 0x4bb7886c240562eba11f4963a53b4240;\\n\\t\\tlambertArray[23] = 0x4b080f3f1cb491d2d521e0ea4583521e;\\n\\t\\tlambertArray[24] = 0x4a5cbc96a05589cb4d86be1db3168364;\\n\\t\\tlambertArray[25] = 0x49b566d40243517658d78c33162d6ece;\\n\\t\\tlambertArray[26] = 0x4911e6a02e5507a30f947383fd9a3276;\\n\\t\\tlambertArray[27] = 0x487216c2b31be4adc41db8a8d5cc0c88;\\n\\t\\tlambertArray[28] = 0x47d5d3fc4a7a1b188cd3d788b5c5e9fc;\\n\\t\\tlambertArray[29] = 0x473cfce4871a2c40bc4f9e1c32b955d0;\\n\\t\\tlambertArray[30] = 0x46a771ca578ab878485810e285e31c67;\\n\\t\\tlambertArray[31] = 0x4615149718aed4c258c373dc676aa72d;\\n\\t\\tlambertArray[32] = 0x4585c8b3f8fe489c6e1833ca47871384;\\n\\t\\tlambertArray[33] = 0x44f972f174e41e5efb7e9d63c29ce735;\\n\\t\\tlambertArray[34] = 0x446ff970ba86d8b00beb05ecebf3c4dc;\\n\\t\\tlambertArray[35] = 0x43e9438ec88971812d6f198b5ccaad96;\\n\\t\\tlambertArray[36] = 0x436539d11ff7bea657aeddb394e809ef;\\n\\t\\tlambertArray[37] = 0x42e3c5d3e5a913401d86f66db5d81c2c;\\n\\t\\tlambertArray[38] = 0x4264d2395303070ea726cbe98df62174;\\n\\t\\tlambertArray[39] = 0x41e84a9a593bb7194c3a6349ecae4eea;\\n\\t\\tlambertArray[40] = 0x416e1b785d13eba07a08f3f18876a5ab;\\n\\t\\tlambertArray[41] = 0x40f6322ff389d423ba9dd7e7e7b7e809;\\n\\t\\tlambertArray[42] = 0x40807cec8a466880ecf4184545d240a4;\\n\\t\\tlambertArray[43] = 0x400cea9ce88a8d3ae668e8ea0d9bf07f;\\n\\t\\tlambertArray[44] = 0x3f9b6ae8772d4c55091e0ed7dfea0ac1;\\n\\t\\tlambertArray[45] = 0x3f2bee253fd84594f54bcaafac383a13;\\n\\t\\tlambertArray[46] = 0x3ebe654e95208bb9210c575c081c5958;\\n\\t\\tlambertArray[47] = 0x3e52c1fc5665635b78ce1f05ad53c086;\\n\\t\\tlambertArray[48] = 0x3de8f65ac388101ddf718a6f5c1eff65;\\n\\t\\tlambertArray[49] = 0x3d80f522d59bd0b328ca012df4cd2d49;\\n\\t\\tlambertArray[50] = 0x3d1ab193129ea72b23648a161163a85a;\\n\\t\\tlambertArray[51] = 0x3cb61f68d32576c135b95cfb53f76d75;\\n\\t\\tlambertArray[52] = 0x3c5332d9f1aae851a3619e77e4cc8473;\\n\\t\\tlambertArray[53] = 0x3bf1e08edbe2aa109e1525f65759ef73;\\n\\t\\tlambertArray[54] = 0x3b921d9cff13fa2c197746a3dfc4918f;\\n\\t\\tlambertArray[55] = 0x3b33df818910bfc1a5aefb8f63ae2ac4;\\n\\t\\tlambertArray[56] = 0x3ad71c1c77e34fa32a9f184967eccbf6;\\n\\t\\tlambertArray[57] = 0x3a7bc9abf2c5bb53e2f7384a8a16521a;\\n\\t\\tlambertArray[58] = 0x3a21dec7e76369783a68a0c6385a1c57;\\n\\t\\tlambertArray[59] = 0x39c9525de6c9cdf7c1c157ca4a7a6ee3;\\n\\t\\tlambertArray[60] = 0x39721bad3dc85d1240ff0190e0adaac3;\\n\\t\\tlambertArray[61] = 0x391c324344d3248f0469eb28dd3d77e0;\\n\\t\\tlambertArray[62] = 0x38c78df7e3c796279fb4ff84394ab3da;\\n\\t\\tlambertArray[63] = 0x387426ea4638ae9aae08049d3554c20a;\\n\\t\\tlambertArray[64] = 0x3821f57dbd2763256c1a99bbd2051378;\\n\\t\\tlambertArray[65] = 0x37d0f256cb46a8c92ff62fbbef289698;\\n\\t\\tlambertArray[66] = 0x37811658591ffc7abdd1feaf3cef9b73;\\n\\t\\tlambertArray[67] = 0x37325aa10e9e82f7df0f380f7997154b;\\n\\t\\tlambertArray[68] = 0x36e4b888cfb408d873b9a80d439311c6;\\n\\t\\tlambertArray[69] = 0x3698299e59f4bb9de645fc9b08c64cca;\\n\\t\\tlambertArray[70] = 0x364ca7a5012cb603023b57dd3ebfd50d;\\n\\t\\tlambertArray[71] = 0x36022c928915b778ab1b06aaee7e61d4;\\n\\t\\tlambertArray[72] = 0x35b8b28d1a73dc27500ffe35559cc028;\\n\\t\\tlambertArray[73] = 0x357033e951fe250ec5eb4e60955132d7;\\n\\t\\tlambertArray[74] = 0x3528ab2867934e3a21b5412e4c4f8881;\\n\\t\\tlambertArray[75] = 0x34e212f66c55057f9676c80094a61d59;\\n\\t\\tlambertArray[76] = 0x349c66289e5b3c4b540c24f42fa4b9bb;\\n\\t\\tlambertArray[77] = 0x34579fbbd0c733a9c8d6af6b0f7d00f7;\\n\\t\\tlambertArray[78] = 0x3413bad2e712288b924b5882b5b369bf;\\n\\t\\tlambertArray[79] = 0x33d0b2b56286510ef730e213f71f12e9;\\n\\t\\tlambertArray[80] = 0x338e82ce00e2496262c64457535ba1a1;\\n\\t\\tlambertArray[81] = 0x334d26a96b373bb7c2f8ea1827f27a92;\\n\\t\\tlambertArray[82] = 0x330c99f4f4211469e00b3e18c31475ea;\\n\\t\\tlambertArray[83] = 0x32ccd87d6486094999c7d5e6f33237d8;\\n\\t\\tlambertArray[84] = 0x328dde2dd617b6665a2e8556f250c1af;\\n\\t\\tlambertArray[85] = 0x324fa70e9adc270f8262755af5a99af9;\\n\\t\\tlambertArray[86] = 0x32122f443110611ca51040f41fa6e1e3;\\n\\t\\tlambertArray[87] = 0x31d5730e42c0831482f0f1485c4263d8;\\n\\t\\tlambertArray[88] = 0x31996ec6b07b4a83421b5ebc4ab4e1f1;\\n\\t\\tlambertArray[89] = 0x315e1ee0a68ff46bb43ec2b85032e876;\\n\\t\\tlambertArray[90] = 0x31237fe7bc4deacf6775b9efa1a145f8;\\n\\t\\tlambertArray[91] = 0x30e98e7f1cc5a356e44627a6972ea2ff;\\n\\t\\tlambertArray[92] = 0x30b04760b8917ec74205a3002650ec05;\\n\\t\\tlambertArray[93] = 0x3077a75c803468e9132ce0cf3224241d;\\n\\t\\tlambertArray[94] = 0x303fab57a6a275c36f19cda9bace667a;\\n\\t\\tlambertArray[95] = 0x3008504beb8dcbd2cf3bc1f6d5a064f0;\\n\\t\\tlambertArray[96] = 0x2fd19346ed17dac61219ce0c2c5ac4b0;\\n\\t\\tlambertArray[97] = 0x2f9b7169808c324b5852fd3d54ba9714;\\n\\t\\tlambertArray[98] = 0x2f65e7e711cf4b064eea9c08cbdad574;\\n\\t\\tlambertArray[99] = 0x2f30f405093042ddff8a251b6bf6d103;\\n\\t\\tlambertArray[100] = 0x2efc931a3750f2e8bfe323edfe037574;\\n\\t\\tlambertArray[101] = 0x2ec8c28e46dbe56d98685278339400cb;\\n\\t\\tlambertArray[102] = 0x2e957fd933c3926d8a599b602379b851;\\n\\t\\tlambertArray[103] = 0x2e62c882c7c9ed4473412702f08ba0e5;\\n\\t\\tlambertArray[104] = 0x2e309a221c12ba361e3ed695167feee2;\\n\\t\\tlambertArray[105] = 0x2dfef25d1f865ae18dd07cfea4bcea10;\\n\\t\\tlambertArray[106] = 0x2dcdcee821cdc80decc02c44344aeb31;\\n\\t\\tlambertArray[107] = 0x2d9d2d8562b34944d0b201bb87260c83;\\n\\t\\tlambertArray[108] = 0x2d6d0c04a5b62a2c42636308669b729a;\\n\\t\\tlambertArray[109] = 0x2d3d6842c9a235517fc5a0332691528f;\\n\\t\\tlambertArray[110] = 0x2d0e402963fe1ea2834abc408c437c10;\\n\\t\\tlambertArray[111] = 0x2cdf91ae602647908aff975e4d6a2a8c;\\n\\t\\tlambertArray[112] = 0x2cb15ad3a1eb65f6d74a75da09a1b6c5;\\n\\t\\tlambertArray[113] = 0x2c8399a6ab8e9774d6fcff373d210727;\\n\\t\\tlambertArray[114] = 0x2c564c4046f64edba6883ca06bbc4535;\\n\\t\\tlambertArray[115] = 0x2c2970c431f952641e05cb493e23eed3;\\n\\t\\tlambertArray[116] = 0x2bfd0560cd9eb14563bc7c0732856c18;\\n\\t\\tlambertArray[117] = 0x2bd1084ed0332f7ff4150f9d0ef41a2c;\\n\\t\\tlambertArray[118] = 0x2ba577d0fa1628b76d040b12a82492fb;\\n\\t\\tlambertArray[119] = 0x2b7a5233cd21581e855e89dc2f1e8a92;\\n\\t\\tlambertArray[120] = 0x2b4f95cd46904d05d72bdcde337d9cc7;\\n\\t\\tlambertArray[121] = 0x2b2540fc9b4d9abba3faca6691914675;\\n\\t\\tlambertArray[122] = 0x2afb5229f68d0830d8be8adb0a0db70f;\\n\\t\\tlambertArray[123] = 0x2ad1c7c63a9b294c5bc73a3ba3ab7a2b;\\n\\t\\tlambertArray[124] = 0x2aa8a04ac3cbe1ee1c9c86361465dbb8;\\n\\t\\tlambertArray[125] = 0x2a7fda392d725a44a2c8aeb9ab35430d;\\n\\t\\tlambertArray[126] = 0x2a57741b18cde618717792b4faa216db;\\n\\t\\tlambertArray[127] = 0x2a2f6c81f5d84dd950a35626d6d5503a;\\n\\t}\\n\\n\\t/**\\n\\t * @dev should be executed after construction (too large for the constructor)\\n\\t */\\n\\tfunction init() public {\\n\\t\\tinitMaxExpArray();\\n\\t\\tinitLambertArray();\\n\\t}\\n\\n\\t/**\\n\\t * @dev given a token supply, reserve balance, weight and a deposit amount (in the reserve token),\\n\\t * calculates the target amount for a given conversion (in the main token)\\n\\t *\\n\\t * Formula:\\n\\t * return = _supply * ((1 + _amount / _reserveBalance) ^ (_reserveWeight / 1000000) - 1)\\n\\t *\\n\\t * @param _supply          liquid token supply\\n\\t * @param _reserveBalance  reserve balance\\n\\t * @param _reserveWeight   reserve weight, represented in ppm (1-1000000)\\n\\t * @param _amount          amount of reserve tokens to get the target amount for\\n\\t *\\n\\t * @return target\\n\\t */\\n\\tfunction purchaseTargetAmount(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveWeight,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\t// validate input\\n\\t\\trequire(_supply > 0, \\\"ERR_INVALID_SUPPLY\\\");\\n\\t\\trequire(_reserveBalance > 0, \\\"ERR_INVALID_RESERVE_BALANCE\\\");\\n\\t\\trequire(\\n\\t\\t\\t_reserveWeight > 0 && _reserveWeight <= MAX_WEIGHT,\\n\\t\\t\\t\\\"ERR_INVALID_RESERVE_WEIGHT\\\"\\n\\t\\t);\\n\\n\\t\\t// special case for 0 deposit amount\\n\\t\\tif (_amount == 0) return 0;\\n\\n\\t\\t// special case if the weight = 100%\\n\\t\\tif (_reserveWeight == MAX_WEIGHT)\\n\\t\\t\\treturn _supply.mul(_amount) / _reserveBalance;\\n\\n\\t\\tuint256 result;\\n\\t\\tuint8 precision;\\n\\t\\tuint256 baseN = _amount.add(_reserveBalance);\\n\\t\\t(result, precision) = power(\\n\\t\\t\\tbaseN,\\n\\t\\t\\t_reserveBalance,\\n\\t\\t\\t_reserveWeight,\\n\\t\\t\\tMAX_WEIGHT\\n\\t\\t);\\n\\t\\tuint256 temp = _supply.mul(result) >> precision;\\n\\t\\treturn temp - _supply;\\n\\t}\\n\\n\\t/**\\n\\t * @dev given a token supply, reserve balance, weight and a sell amount (in the main token),\\n\\t * calculates the target amount for a given conversion (in the reserve token)\\n\\t *\\n\\t * Formula:\\n\\t * return = _reserveBalance * (1 - (1 - _amount / _supply) ^ (1000000 / _reserveWeight))\\n\\t *\\n\\t * @param _supply          liquid token supply\\n\\t * @param _reserveBalance  reserve balance\\n\\t * @param _reserveWeight   reserve weight, represented in ppm (1-1000000)\\n\\t * @param _amount          amount of liquid tokens to get the target amount for\\n\\t *\\n\\t * @return reserve token amount\\n\\t */\\n\\tfunction saleTargetAmount(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveWeight,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\t// validate input\\n\\t\\trequire(_supply > 0, \\\"ERR_INVALID_SUPPLY\\\");\\n\\t\\trequire(_reserveBalance > 0, \\\"ERR_INVALID_RESERVE_BALANCE\\\");\\n\\t\\trequire(\\n\\t\\t\\t_reserveWeight > 0 && _reserveWeight <= MAX_WEIGHT,\\n\\t\\t\\t\\\"ERR_INVALID_RESERVE_WEIGHT\\\"\\n\\t\\t);\\n\\t\\trequire(_amount <= _supply, \\\"ERR_INVALID_AMOUNT\\\");\\n\\n\\t\\t// special case for 0 sell amount\\n\\t\\tif (_amount == 0) return 0;\\n\\n\\t\\t// special case for selling the entire supply\\n\\t\\tif (_amount == _supply) return _reserveBalance;\\n\\n\\t\\t// special case if the weight = 100%\\n\\t\\tif (_reserveWeight == MAX_WEIGHT)\\n\\t\\t\\treturn _reserveBalance.mul(_amount) / _supply;\\n\\n\\t\\tuint256 result;\\n\\t\\tuint8 precision;\\n\\t\\tuint256 baseD = _supply - _amount;\\n\\t\\t(result, precision) = power(_supply, baseD, MAX_WEIGHT, _reserveWeight);\\n\\t\\tuint256 temp1 = _reserveBalance.mul(result);\\n\\t\\tuint256 temp2 = _reserveBalance << precision;\\n\\t\\treturn (temp1 - temp2) / result;\\n\\t}\\n\\n\\t/**\\n\\t * @dev given two reserve balances/weights and a sell amount (in the first reserve token),\\n\\t * calculates the target amount for a conversion from the source reserve token to the target reserve token\\n\\t *\\n\\t * Formula:\\n\\t * return = _targetReserveBalance * (1 - (_sourceReserveBalance / (_sourceReserveBalance + _amount)) ^ (_sourceReserveWeight / _targetReserveWeight))\\n\\t *\\n\\t * @param _sourceReserveBalance    source reserve balance\\n\\t * @param _sourceReserveWeight     source reserve weight, represented in ppm (1-1000000)\\n\\t * @param _targetReserveBalance    target reserve balance\\n\\t * @param _targetReserveWeight     target reserve weight, represented in ppm (1-1000000)\\n\\t * @param _amount                  source reserve amount\\n\\t *\\n\\t * @return target reserve amount\\n\\t */\\n\\tfunction crossReserveTargetAmount(\\n\\t\\tuint256 _sourceReserveBalance,\\n\\t\\tuint32 _sourceReserveWeight,\\n\\t\\tuint256 _targetReserveBalance,\\n\\t\\tuint32 _targetReserveWeight,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\t// validate input\\n\\t\\trequire(\\n\\t\\t\\t_sourceReserveBalance > 0 && _targetReserveBalance > 0,\\n\\t\\t\\t\\\"ERR_INVALID_RESERVE_BALANCE\\\"\\n\\t\\t);\\n\\t\\trequire(\\n\\t\\t\\t_sourceReserveWeight > 0 &&\\n\\t\\t\\t\\t_sourceReserveWeight <= MAX_WEIGHT &&\\n\\t\\t\\t\\t_targetReserveWeight > 0 &&\\n\\t\\t\\t\\t_targetReserveWeight <= MAX_WEIGHT,\\n\\t\\t\\t\\\"ERR_INVALID_RESERVE_WEIGHT\\\"\\n\\t\\t);\\n\\n\\t\\t// special case for equal weights\\n\\t\\tif (_sourceReserveWeight == _targetReserveWeight)\\n\\t\\t\\treturn\\n\\t\\t\\t\\t_targetReserveBalance.mul(_amount) /\\n\\t\\t\\t\\t_sourceReserveBalance.add(_amount);\\n\\n\\t\\tuint256 result;\\n\\t\\tuint8 precision;\\n\\t\\tuint256 baseN = _sourceReserveBalance.add(_amount);\\n\\t\\t(result, precision) = power(\\n\\t\\t\\tbaseN,\\n\\t\\t\\t_sourceReserveBalance,\\n\\t\\t\\t_sourceReserveWeight,\\n\\t\\t\\t_targetReserveWeight\\n\\t\\t);\\n\\t\\tuint256 temp1 = _targetReserveBalance.mul(result);\\n\\t\\tuint256 temp2 = _targetReserveBalance << precision;\\n\\t\\treturn (temp1 - temp2) / result;\\n\\t}\\n\\n\\t/**\\n\\t * @dev given a pool token supply, reserve balance, reserve ratio and an amount of requested pool tokens,\\n\\t * calculates the amount of reserve tokens required for purchasing the given amount of pool tokens\\n\\t *\\n\\t * Formula:\\n\\t * return = _reserveBalance * (((_supply + _amount) / _supply) ^ (MAX_WEIGHT / _reserveRatio) - 1)\\n\\t *\\n\\t * @param _supply          pool token supply\\n\\t * @param _reserveBalance  reserve balance\\n\\t * @param _reserveRatio    reserve ratio, represented in ppm (2-2000000)\\n\\t * @param _amount          requested amount of pool tokens\\n\\t *\\n\\t * @return reserve token amount\\n\\t */\\n\\tfunction fundCost(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveRatio,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\t// validate input\\n\\t\\trequire(_supply > 0, \\\"ERR_INVALID_SUPPLY\\\");\\n\\t\\trequire(_reserveBalance > 0, \\\"ERR_INVALID_RESERVE_BALANCE\\\");\\n\\t\\trequire(\\n\\t\\t\\t_reserveRatio > 1 && _reserveRatio <= MAX_WEIGHT * 2,\\n\\t\\t\\t\\\"ERR_INVALID_RESERVE_RATIO\\\"\\n\\t\\t);\\n\\n\\t\\t// special case for 0 amount\\n\\t\\tif (_amount == 0) return 0;\\n\\n\\t\\t// special case if the reserve ratio = 100%\\n\\t\\tif (_reserveRatio == MAX_WEIGHT)\\n\\t\\t\\treturn (_amount.mul(_reserveBalance) - 1) / _supply + 1;\\n\\n\\t\\tuint256 result;\\n\\t\\tuint8 precision;\\n\\t\\tuint256 baseN = _supply.add(_amount);\\n\\t\\t(result, precision) = power(baseN, _supply, MAX_WEIGHT, _reserveRatio);\\n\\t\\tuint256 temp = ((_reserveBalance.mul(result) - 1) >> precision) + 1;\\n\\t\\treturn temp - _reserveBalance;\\n\\t}\\n\\n\\t/**\\n\\t * @dev given a pool token supply, reserve balance, reserve ratio and an amount of reserve tokens to fund with,\\n\\t * calculates the amount of pool tokens received for purchasing with the given amount of reserve tokens\\n\\t *\\n\\t * Formula:\\n\\t * return = _supply * ((_amount / _reserveBalance + 1) ^ (_reserveRatio / MAX_WEIGHT) - 1)\\n\\t *\\n\\t * @param _supply          pool token supply\\n\\t * @param _reserveBalance  reserve balance\\n\\t * @param _reserveRatio    reserve ratio, represented in ppm (2-2000000)\\n\\t * @param _amount          amount of reserve tokens to fund with\\n\\t *\\n\\t * @return pool token amount\\n\\t */\\n\\tfunction fundSupplyAmount(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveRatio,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\t// validate input\\n\\t\\trequire(_supply > 0, \\\"ERR_INVALID_SUPPLY\\\");\\n\\t\\trequire(_reserveBalance > 0, \\\"ERR_INVALID_RESERVE_BALANCE\\\");\\n\\t\\trequire(\\n\\t\\t\\t_reserveRatio > 1 && _reserveRatio <= MAX_WEIGHT * 2,\\n\\t\\t\\t\\\"ERR_INVALID_RESERVE_RATIO\\\"\\n\\t\\t);\\n\\n\\t\\t// special case for 0 amount\\n\\t\\tif (_amount == 0) return 0;\\n\\n\\t\\t// special case if the reserve ratio = 100%\\n\\t\\tif (_reserveRatio == MAX_WEIGHT)\\n\\t\\t\\treturn _amount.mul(_supply) / _reserveBalance;\\n\\n\\t\\tuint256 result;\\n\\t\\tuint8 precision;\\n\\t\\tuint256 baseN = _reserveBalance.add(_amount);\\n\\t\\t(result, precision) = power(\\n\\t\\t\\tbaseN,\\n\\t\\t\\t_reserveBalance,\\n\\t\\t\\t_reserveRatio,\\n\\t\\t\\tMAX_WEIGHT\\n\\t\\t);\\n\\t\\tuint256 temp = _supply.mul(result) >> precision;\\n\\t\\treturn temp - _supply;\\n\\t}\\n\\n\\t/**\\n\\t * @dev given a pool token supply, reserve balance, reserve ratio and an amount of pool tokens to liquidate,\\n\\t * calculates the amount of reserve tokens received for selling the given amount of pool tokens\\n\\t *\\n\\t * Formula:\\n\\t * return = _reserveBalance * (1 - ((_supply - _amount) / _supply) ^ (MAX_WEIGHT / _reserveRatio))\\n\\t *\\n\\t * @param _supply          pool token supply\\n\\t * @param _reserveBalance  reserve balance\\n\\t * @param _reserveRatio    reserve ratio, represented in ppm (2-2000000)\\n\\t * @param _amount          amount of pool tokens to liquidate\\n\\t *\\n\\t * @return reserve token amount\\n\\t */\\n\\tfunction liquidateReserveAmount(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveRatio,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\t// validate input\\n\\t\\trequire(_supply > 0, \\\"ERR_INVALID_SUPPLY\\\");\\n\\t\\trequire(_reserveBalance > 0, \\\"ERR_INVALID_RESERVE_BALANCE\\\");\\n\\t\\trequire(\\n\\t\\t\\t_reserveRatio > 1 && _reserveRatio <= MAX_WEIGHT * 2,\\n\\t\\t\\t\\\"ERR_INVALID_RESERVE_RATIO\\\"\\n\\t\\t);\\n\\t\\trequire(_amount <= _supply, \\\"ERR_INVALID_AMOUNT\\\");\\n\\n\\t\\t// special case for 0 amount\\n\\t\\tif (_amount == 0) return 0;\\n\\n\\t\\t// special case for liquidating the entire supply\\n\\t\\tif (_amount == _supply) return _reserveBalance;\\n\\n\\t\\t// special case if the reserve ratio = 100%\\n\\t\\tif (_reserveRatio == MAX_WEIGHT)\\n\\t\\t\\treturn _amount.mul(_reserveBalance) / _supply;\\n\\n\\t\\tuint256 result;\\n\\t\\tuint8 precision;\\n\\t\\tuint256 baseD = _supply - _amount;\\n\\t\\t(result, precision) = power(_supply, baseD, MAX_WEIGHT, _reserveRatio);\\n\\t\\tuint256 temp1 = _reserveBalance.mul(result);\\n\\t\\tuint256 temp2 = _reserveBalance << precision;\\n\\t\\treturn (temp1 - temp2) / result;\\n\\t}\\n\\n\\t/**\\n\\t * @dev The arbitrage incentive is to convert to the point where the on-chain price is equal to the off-chain price.\\n\\t * We want this operation to also impact the primary reserve balance becoming equal to the primary reserve staked balance.\\n\\t * In other words, we want the arbitrager to convert the difference between the reserve balance and the reserve staked balance.\\n\\t *\\n\\t * Formula input:\\n\\t * - let t denote the primary reserve token staked balance\\n\\t * - let s denote the primary reserve token balance\\n\\t * - let r denote the secondary reserve token balance\\n\\t * - let q denote the numerator of the rate between the tokens\\n\\t * - let p denote the denominator of the rate between the tokens\\n\\t * Where p primary tokens are equal to q secondary tokens\\n\\t *\\n\\t * Formula output:\\n\\t * - compute x = W(t / r * q / p * log(s / t)) / log(s / t)\\n\\t * - return x / (1 + x) as the weight of the primary reserve token\\n\\t * - return 1 / (1 + x) as the weight of the secondary reserve token\\n\\t * Where W is the Lambert W Function\\n\\t *\\n\\t * If the rate-provider provides the rates for a common unit, for example:\\n\\t * - P = 2 ==> 2 primary reserve tokens = 1 ether\\n\\t * - Q = 3 ==> 3 secondary reserve tokens = 1 ether\\n\\t * Then you can simply use p = P and q = Q\\n\\t *\\n\\t * If the rate-provider provides the rates for a single unit, for example:\\n\\t * - P = 2 ==> 1 primary reserve token = 2 ethers\\n\\t * - Q = 3 ==> 1 secondary reserve token = 3 ethers\\n\\t * Then you can simply use p = Q and q = P\\n\\t *\\n\\t * @param _primaryReserveStakedBalance the primary reserve token staked balance\\n\\t * @param _primaryReserveBalance       the primary reserve token balance\\n\\t * @param _secondaryReserveBalance     the secondary reserve token balance\\n\\t * @param _reserveRateNumerator        the numerator of the rate between the tokens\\n\\t * @param _reserveRateDenominator      the denominator of the rate between the tokens\\n\\t *\\n\\t * Note that `numerator / denominator` should represent the amount of secondary tokens equal to one primary token\\n\\t *\\n\\t * @return the weight of the primary reserve token and the weight of the secondary reserve token, both in ppm (0-1000000)\\n\\t */\\n\\tfunction balancedWeights(\\n\\t\\tuint256 _primaryReserveStakedBalance,\\n\\t\\tuint256 _primaryReserveBalance,\\n\\t\\tuint256 _secondaryReserveBalance,\\n\\t\\tuint256 _reserveRateNumerator,\\n\\t\\tuint256 _reserveRateDenominator\\n\\t) public view returns (uint32, uint32) {\\n\\t\\tif (_primaryReserveStakedBalance == _primaryReserveBalance)\\n\\t\\t\\trequire(\\n\\t\\t\\t\\t_primaryReserveStakedBalance > 0 ||\\n\\t\\t\\t\\t\\t_secondaryReserveBalance > 0,\\n\\t\\t\\t\\t\\\"ERR_INVALID_RESERVE_BALANCE\\\"\\n\\t\\t\\t);\\n\\t\\telse\\n\\t\\t\\trequire(\\n\\t\\t\\t\\t_primaryReserveStakedBalance > 0 &&\\n\\t\\t\\t\\t\\t_primaryReserveBalance > 0 &&\\n\\t\\t\\t\\t\\t_secondaryReserveBalance > 0,\\n\\t\\t\\t\\t\\\"ERR_INVALID_RESERVE_BALANCE\\\"\\n\\t\\t\\t);\\n\\t\\trequire(\\n\\t\\t\\t_reserveRateNumerator > 0 && _reserveRateDenominator > 0,\\n\\t\\t\\t\\\"ERR_INVALID_RESERVE_RATE\\\"\\n\\t\\t);\\n\\n\\t\\tuint256 tq = _primaryReserveStakedBalance.mul(_reserveRateNumerator);\\n\\t\\tuint256 rp = _secondaryReserveBalance.mul(_reserveRateDenominator);\\n\\n\\t\\tif (_primaryReserveStakedBalance < _primaryReserveBalance)\\n\\t\\t\\treturn\\n\\t\\t\\t\\tbalancedWeightsByStake(\\n\\t\\t\\t\\t\\t_primaryReserveBalance,\\n\\t\\t\\t\\t\\t_primaryReserveStakedBalance,\\n\\t\\t\\t\\t\\ttq,\\n\\t\\t\\t\\t\\trp,\\n\\t\\t\\t\\t\\ttrue\\n\\t\\t\\t\\t);\\n\\n\\t\\tif (_primaryReserveStakedBalance > _primaryReserveBalance)\\n\\t\\t\\treturn\\n\\t\\t\\t\\tbalancedWeightsByStake(\\n\\t\\t\\t\\t\\t_primaryReserveStakedBalance,\\n\\t\\t\\t\\t\\t_primaryReserveBalance,\\n\\t\\t\\t\\t\\ttq,\\n\\t\\t\\t\\t\\trp,\\n\\t\\t\\t\\t\\tfalse\\n\\t\\t\\t\\t);\\n\\n\\t\\treturn normalizedWeights(tq, rp);\\n\\t}\\n\\n\\t/**\\n\\t * @dev General Description:\\n\\t *     Determine a value of precision.\\n\\t *     Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\\n\\t *     Return the result along with the precision used.\\n\\t *\\n\\t * Detailed Description:\\n\\t *     Instead of calculating \\\"base ^ exp\\\", we calculate \\\"e ^ (log(base) * exp)\\\".\\n\\t *     The value of \\\"log(base)\\\" is represented with an integer slightly smaller than \\\"log(base) * 2 ^ precision\\\".\\n\\t *     The larger \\\"precision\\\" is, the more accurately this value represents the real value.\\n\\t *     However, the larger \\\"precision\\\" is, the more bits are required in order to store this value.\\n\\t *     And the exponentiation function, which takes \\\"x\\\" and calculates \\\"e ^ x\\\", is limited to a maximum exponent (maximum value of \\\"x\\\").\\n\\t *     This maximum exponent depends on the \\\"precision\\\" used, and it is given by \\\"maxExpArray[precision] >> (MAX_PRECISION - precision)\\\".\\n\\t *     Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\\n\\t *     This allows us to compute \\\"base ^ exp\\\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\\n\\t *     This functions assumes that \\\"_expN < 2 ^ 256 / log(MAX_NUM - 1)\\\", otherwise the multiplication should be replaced with a \\\"safeMul\\\".\\n\\t *     Since we rely on unsigned-integer arithmetic and \\\"base < 1\\\" ==> \\\"log(base) < 0\\\", this function does not support \\\"_baseN < _baseD\\\".\\n\\t */\\n\\tfunction power(\\n\\t\\tuint256 _baseN,\\n\\t\\tuint256 _baseD,\\n\\t\\tuint32 _expN,\\n\\t\\tuint32 _expD\\n\\t) internal view returns (uint256, uint8) {\\n\\t\\trequire(_baseN < MAX_NUM);\\n\\n\\t\\tuint256 baseLog;\\n\\t\\tuint256 base = (_baseN * FIXED_1) / _baseD;\\n\\t\\tif (base < OPT_LOG_MAX_VAL) {\\n\\t\\t\\tbaseLog = optimalLog(base);\\n\\t\\t} else {\\n\\t\\t\\tbaseLog = generalLog(base);\\n\\t\\t}\\n\\n\\t\\tuint256 baseLogTimesExp = (baseLog * _expN) / _expD;\\n\\t\\tif (baseLogTimesExp < OPT_EXP_MAX_VAL) {\\n\\t\\t\\treturn (optimalExp(baseLogTimesExp), MAX_PRECISION);\\n\\t\\t} else {\\n\\t\\t\\tuint8 precision = findPositionInMaxExpArray(baseLogTimesExp);\\n\\t\\t\\treturn (\\n\\t\\t\\t\\tgeneralExp(\\n\\t\\t\\t\\t\\tbaseLogTimesExp >> (MAX_PRECISION - precision),\\n\\t\\t\\t\\t\\tprecision\\n\\t\\t\\t\\t),\\n\\t\\t\\t\\tprecision\\n\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes log(x / FIXED_1) * FIXED_1.\\n\\t * This functions assumes that \\\"x >= FIXED_1\\\", because the output would be negative otherwise.\\n\\t */\\n\\tfunction generalLog(uint256 x) internal pure returns (uint256) {\\n\\t\\tuint256 res = 0;\\n\\n\\t\\t// If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\\n\\t\\tif (x >= FIXED_2) {\\n\\t\\t\\tuint8 count = floorLog2(x / FIXED_1);\\n\\t\\t\\tx >>= count; // now x < 2\\n\\t\\t\\tres = count * FIXED_1;\\n\\t\\t}\\n\\n\\t\\t// If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\\n\\t\\tif (x > FIXED_1) {\\n\\t\\t\\tfor (uint8 i = MAX_PRECISION; i > 0; --i) {\\n\\t\\t\\t\\tx = (x * x) / FIXED_1; // now 1 < x < 4\\n\\t\\t\\t\\tif (x >= FIXED_2) {\\n\\t\\t\\t\\t\\tx >>= 1; // now 1 < x < 2\\n\\t\\t\\t\\t\\tres += ONE << (i - 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn (res * LN2_NUMERATOR) / LN2_DENOMINATOR;\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes the largest integer smaller than or equal to the binary logarithm of the input.\\n\\t */\\n\\tfunction floorLog2(uint256 _n) internal pure returns (uint8) {\\n\\t\\tuint8 res = 0;\\n\\n\\t\\tif (_n < 256) {\\n\\t\\t\\t// At most 8 iterations\\n\\t\\t\\twhile (_n > 1) {\\n\\t\\t\\t\\t_n >>= 1;\\n\\t\\t\\t\\tres += 1;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// Exactly 8 iterations\\n\\t\\t\\tfor (uint8 s = 128; s > 0; s >>= 1) {\\n\\t\\t\\t\\tif (_n >= (ONE << s)) {\\n\\t\\t\\t\\t\\t_n >>= s;\\n\\t\\t\\t\\t\\tres |= s;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\t/**\\n\\t * @dev the global \\\"maxExpArray\\\" is sorted in descending order, and therefore the following statements are equivalent:\\n\\t * - This function finds the position of [the smallest value in \\\"maxExpArray\\\" larger than or equal to \\\"x\\\"]\\n\\t * - This function finds the highest position of [a value in \\\"maxExpArray\\\" larger than or equal to \\\"x\\\"]\\n\\t */\\n\\tfunction findPositionInMaxExpArray(uint256 _x)\\n\\t\\tinternal\\n\\t\\tview\\n\\t\\treturns (uint8)\\n\\t{\\n\\t\\tuint8 lo = MIN_PRECISION;\\n\\t\\tuint8 hi = MAX_PRECISION;\\n\\n\\t\\twhile (lo + 1 < hi) {\\n\\t\\t\\tuint8 mid = (lo + hi) / 2;\\n\\t\\t\\tif (maxExpArray[mid] >= _x) lo = mid;\\n\\t\\t\\telse hi = mid;\\n\\t\\t}\\n\\n\\t\\tif (maxExpArray[hi] >= _x) return hi;\\n\\t\\tif (maxExpArray[lo] >= _x) return lo;\\n\\n\\t\\trequire(false);\\n\\t}\\n\\n\\t/**\\n\\t * @dev this function can be auto-generated by the script 'PrintFunctionGeneralExp.py'.\\n\\t * it approximates \\\"e ^ x\\\" via maclaurin summation: \\\"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\\\".\\n\\t * it returns \\\"e ^ (x / 2 ^ precision) * 2 ^ precision\\\", that is, the result is upshifted for accuracy.\\n\\t * the global \\\"maxExpArray\\\" maps each \\\"precision\\\" to \\\"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\\\".\\n\\t * the maximum permitted value for \\\"x\\\" is therefore given by \\\"maxExpArray[precision] >> (MAX_PRECISION - precision)\\\".\\n\\t */\\n\\tfunction generalExp(uint256 _x, uint8 _precision)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\tuint256 xi = _x;\\n\\t\\tuint256 res = 0;\\n\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x3442c4e6074a82f1797f72ac0000000; // add x^02 * (33! / 02!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x116b96f757c380fb287fd0e40000000; // add x^03 * (33! / 03!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x045ae5bdd5f0e03eca1ff4390000000; // add x^04 * (33! / 04!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x00defabf91302cd95b9ffda50000000; // add x^05 * (33! / 05!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x002529ca9832b22439efff9b8000000; // add x^06 * (33! / 06!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x00054f1cf12bd04e516b6da88000000; // add x^07 * (33! / 07!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x0000a9e39e257a09ca2d6db51000000; // add x^08 * (33! / 08!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x000012e066e7b839fa050c309000000; // add x^09 * (33! / 09!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x000001e33d7d926c329a1ad1a800000; // add x^10 * (33! / 10!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x0000002bee513bdb4a6b19b5f800000; // add x^11 * (33! / 11!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x00000003a9316fa79b88eccf2a00000; // add x^12 * (33! / 12!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x0000000048177ebe1fa812375200000; // add x^13 * (33! / 13!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x0000000005263fe90242dcbacf00000; // add x^14 * (33! / 14!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x000000000057e22099c030d94100000; // add x^15 * (33! / 15!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x0000000000057e22099c030d9410000; // add x^16 * (33! / 16!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x00000000000052b6b54569976310000; // add x^17 * (33! / 17!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x00000000000004985f67696bf748000; // add x^18 * (33! / 18!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x000000000000003dea12ea99e498000; // add x^19 * (33! / 19!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x00000000000000031880f2214b6e000; // add x^20 * (33! / 20!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x000000000000000025bcff56eb36000; // add x^21 * (33! / 21!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x000000000000000001b722e10ab1000; // add x^22 * (33! / 22!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x0000000000000000001317c70077000; // add x^23 * (33! / 23!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x00000000000000000000cba84aafa00; // add x^24 * (33! / 24!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x00000000000000000000082573a0a00; // add x^25 * (33! / 25!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x00000000000000000000005035ad900; // add x^26 * (33! / 26!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x000000000000000000000002f881b00; // add x^27 * (33! / 27!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x0000000000000000000000001b29340; // add x^28 * (33! / 28!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x00000000000000000000000000efc40; // add x^29 * (33! / 29!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x0000000000000000000000000007fe0; // add x^30 * (33! / 30!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x0000000000000000000000000000420; // add x^31 * (33! / 31!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x0000000000000000000000000000021; // add x^32 * (33! / 32!)\\n\\t\\txi = (xi * _x) >> _precision;\\n\\t\\tres += xi * 0x0000000000000000000000000000001; // add x^33 * (33! / 33!)\\n\\n\\t\\treturn\\n\\t\\t\\tres / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision); // divide by 33! and then add x^1 / 1! + x^0 / 0!\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes log(x / FIXED_1) * FIXED_1\\n\\t * Input range: FIXED_1 <= x <= OPT_LOG_MAX_VAL - 1\\n\\t * Auto-generated via 'PrintFunctionOptimalLog.py'\\n\\t * Detailed description:\\n\\t * - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2\\n\\t * - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\\n\\t * - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\\n\\t * - The natural logarithm of the input is calculated by summing up the intermediate results above\\n\\t * - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\\n\\t */\\n\\tfunction optimalLog(uint256 x) internal pure returns (uint256) {\\n\\t\\tuint256 res = 0;\\n\\n\\t\\tuint256 y;\\n\\t\\tuint256 z;\\n\\t\\tuint256 w;\\n\\n\\t\\tif (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {\\n\\t\\t\\tres += 0x40000000000000000000000000000000;\\n\\t\\t\\tx = (x * FIXED_1) / 0xd3094c70f034de4b96ff7d5b6f99fcd8;\\n\\t\\t} // add 1 / 2^1\\n\\t\\tif (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {\\n\\t\\t\\tres += 0x20000000000000000000000000000000;\\n\\t\\t\\tx = (x * FIXED_1) / 0xa45af1e1f40c333b3de1db4dd55f29a7;\\n\\t\\t} // add 1 / 2^2\\n\\t\\tif (x >= 0x910b022db7ae67ce76b441c27035c6a1) {\\n\\t\\t\\tres += 0x10000000000000000000000000000000;\\n\\t\\t\\tx = (x * FIXED_1) / 0x910b022db7ae67ce76b441c27035c6a1;\\n\\t\\t} // add 1 / 2^3\\n\\t\\tif (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {\\n\\t\\t\\tres += 0x08000000000000000000000000000000;\\n\\t\\t\\tx = (x * FIXED_1) / 0x88415abbe9a76bead8d00cf112e4d4a8;\\n\\t\\t} // add 1 / 2^4\\n\\t\\tif (x >= 0x84102b00893f64c705e841d5d4064bd3) {\\n\\t\\t\\tres += 0x04000000000000000000000000000000;\\n\\t\\t\\tx = (x * FIXED_1) / 0x84102b00893f64c705e841d5d4064bd3;\\n\\t\\t} // add 1 / 2^5\\n\\t\\tif (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {\\n\\t\\t\\tres += 0x02000000000000000000000000000000;\\n\\t\\t\\tx = (x * FIXED_1) / 0x8204055aaef1c8bd5c3259f4822735a2;\\n\\t\\t} // add 1 / 2^6\\n\\t\\tif (x >= 0x810100ab00222d861931c15e39b44e99) {\\n\\t\\t\\tres += 0x01000000000000000000000000000000;\\n\\t\\t\\tx = (x * FIXED_1) / 0x810100ab00222d861931c15e39b44e99;\\n\\t\\t} // add 1 / 2^7\\n\\t\\tif (x >= 0x808040155aabbbe9451521693554f733) {\\n\\t\\t\\tres += 0x00800000000000000000000000000000;\\n\\t\\t\\tx = (x * FIXED_1) / 0x808040155aabbbe9451521693554f733;\\n\\t\\t} // add 1 / 2^8\\n\\n\\t\\tz = y = x - FIXED_1;\\n\\t\\tw = (y * y) / FIXED_1;\\n\\t\\tres +=\\n\\t\\t\\t(z * (0x100000000000000000000000000000000 - y)) /\\n\\t\\t\\t0x100000000000000000000000000000000;\\n\\t\\tz = (z * w) / FIXED_1; // add y^01 / 01 - y^02 / 02\\n\\t\\tres +=\\n\\t\\t\\t(z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y)) /\\n\\t\\t\\t0x200000000000000000000000000000000;\\n\\t\\tz = (z * w) / FIXED_1; // add y^03 / 03 - y^04 / 04\\n\\t\\tres +=\\n\\t\\t\\t(z * (0x099999999999999999999999999999999 - y)) /\\n\\t\\t\\t0x300000000000000000000000000000000;\\n\\t\\tz = (z * w) / FIXED_1; // add y^05 / 05 - y^06 / 06\\n\\t\\tres +=\\n\\t\\t\\t(z * (0x092492492492492492492492492492492 - y)) /\\n\\t\\t\\t0x400000000000000000000000000000000;\\n\\t\\tz = (z * w) / FIXED_1; // add y^07 / 07 - y^08 / 08\\n\\t\\tres +=\\n\\t\\t\\t(z * (0x08e38e38e38e38e38e38e38e38e38e38e - y)) /\\n\\t\\t\\t0x500000000000000000000000000000000;\\n\\t\\tz = (z * w) / FIXED_1; // add y^09 / 09 - y^10 / 10\\n\\t\\tres +=\\n\\t\\t\\t(z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y)) /\\n\\t\\t\\t0x600000000000000000000000000000000;\\n\\t\\tz = (z * w) / FIXED_1; // add y^11 / 11 - y^12 / 12\\n\\t\\tres +=\\n\\t\\t\\t(z * (0x089d89d89d89d89d89d89d89d89d89d89 - y)) /\\n\\t\\t\\t0x700000000000000000000000000000000;\\n\\t\\tz = (z * w) / FIXED_1; // add y^13 / 13 - y^14 / 14\\n\\t\\tres +=\\n\\t\\t\\t(z * (0x088888888888888888888888888888888 - y)) /\\n\\t\\t\\t0x800000000000000000000000000000000; // add y^15 / 15 - y^16 / 16\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes e ^ (x / FIXED_1) * FIXED_1\\n\\t * input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\\n\\t * auto-generated via 'PrintFunctionOptimalExp.py'\\n\\t * Detailed description:\\n\\t * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\\n\\t * - The exponentiation of each binary exponent is given (pre-calculated)\\n\\t * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\\n\\t * - The exponentiation of the input is calculated by multiplying the intermediate results above\\n\\t * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\\n\\t */\\n\\tfunction optimalExp(uint256 x) internal pure returns (uint256) {\\n\\t\\tuint256 res = 0;\\n\\n\\t\\tuint256 y;\\n\\t\\tuint256 z;\\n\\n\\t\\tz = y = x % 0x10000000000000000000000000000000; // get the input modulo 2^(-3)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x000000000001c638; // add y^16 * (20! / 16!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x000000000000017c; // add y^18 * (20! / 18!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x0000000000000014; // add y^19 * (20! / 19!)\\n\\t\\tz = (z * y) / FIXED_1;\\n\\t\\tres += z * 0x0000000000000001; // add y^20 * (20! / 20!)\\n\\t\\tres = res / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\\n\\n\\t\\tif ((x & 0x010000000000000000000000000000000) != 0)\\n\\t\\t\\tres =\\n\\t\\t\\t\\t(res * 0x1c3d6a24ed82218787d624d3e5eba95f9) /\\n\\t\\t\\t\\t0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^2^(-3)\\n\\t\\tif ((x & 0x020000000000000000000000000000000) != 0)\\n\\t\\t\\tres =\\n\\t\\t\\t\\t(res * 0x18ebef9eac820ae8682b9793ac6d1e778) /\\n\\t\\t\\t\\t0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^2^(-2)\\n\\t\\tif ((x & 0x040000000000000000000000000000000) != 0)\\n\\t\\t\\tres =\\n\\t\\t\\t\\t(res * 0x1368b2fc6f9609fe7aceb46aa619baed5) /\\n\\t\\t\\t\\t0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^2^(-1)\\n\\t\\tif ((x & 0x080000000000000000000000000000000) != 0)\\n\\t\\t\\tres =\\n\\t\\t\\t\\t(res * 0x0bc5ab1b16779be3575bd8f0520a9f21e) /\\n\\t\\t\\t\\t0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^2^(+0)\\n\\t\\tif ((x & 0x100000000000000000000000000000000) != 0)\\n\\t\\t\\tres =\\n\\t\\t\\t\\t(res * 0x0454aaa8efe072e7f6ddbab84b40a55c5) /\\n\\t\\t\\t\\t0x00960aadc109e7a3bf4578099615711ea; // multiply by e^2^(+1)\\n\\t\\tif ((x & 0x200000000000000000000000000000000) != 0)\\n\\t\\t\\tres =\\n\\t\\t\\t\\t(res * 0x00960aadc109e7a3bf4578099615711d7) /\\n\\t\\t\\t\\t0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^2^(+2)\\n\\t\\tif ((x & 0x400000000000000000000000000000000) != 0)\\n\\t\\t\\tres =\\n\\t\\t\\t\\t(res * 0x0002bf84208204f5977f9a8cf01fdc307) /\\n\\t\\t\\t\\t0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^2^(+3)\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes W(x / FIXED_1) / (x / FIXED_1) * FIXED_1\\n\\t */\\n\\tfunction lowerStake(uint256 _x) internal view returns (uint256) {\\n\\t\\tif (_x <= LAMBERT_CONV_RADIUS) return lambertPos1(_x);\\n\\t\\tif (_x <= LAMBERT_POS2_MAXVAL) return lambertPos2(_x);\\n\\t\\tif (_x <= LAMBERT_POS3_MAXVAL) return lambertPos3(_x);\\n\\t\\trequire(false);\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes W(-x / FIXED_1) / (-x / FIXED_1) * FIXED_1\\n\\t */\\n\\tfunction higherStake(uint256 _x) internal pure returns (uint256) {\\n\\t\\tif (_x <= LAMBERT_CONV_RADIUS) return lambertNeg1(_x);\\n\\t\\treturn (FIXED_1 * FIXED_1) / _x;\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes W(x / FIXED_1) / (x / FIXED_1) * FIXED_1\\n\\t * input range: 1 <= x <= 1 / e * FIXED_1\\n\\t * auto-generated via 'PrintFunctionLambertPos1.py'\\n\\t */\\n\\tfunction lambertPos1(uint256 _x) internal pure returns (uint256) {\\n\\t\\tuint256 xi = _x;\\n\\t\\tuint256 res = (FIXED_1 - _x) * 0xde1bc4d19efcac82445da75b00000000; // x^(1-1) * (34! * 1^(1-1) / 1!) - x^(2-1) * (34! * 2^(2-1) / 2!)\\n\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x00000000014d29a73a6e7b02c3668c7b0880000000; // add x^(03-1) * (34! * 03^(03-1) / 03!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x0000000002504a0cd9a7f7215b60f9be4800000000; // sub x^(04-1) * (34! * 04^(04-1) / 04!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000000000484d0a1191c0ead267967c7a4a0000000; // add x^(05-1) * (34! * 05^(05-1) / 05!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x00000000095ec580d7e8427a4baf26a90a00000000; // sub x^(06-1) * (34! * 06^(06-1) / 06!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000000001440b0be1615a47dba6e5b3b1f10000000; // add x^(07-1) * (34! * 07^(07-1) / 07!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x000000002d207601f46a99b4112418400000000000; // sub x^(08-1) * (34! * 08^(08-1) / 08!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000000066ebaac4c37c622dd8288a7eb1b2000000; // add x^(09-1) * (34! * 09^(09-1) / 09!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x00000000ef17240135f7dbd43a1ba10cf200000000; // sub x^(10-1) * (34! * 10^(10-1) / 10!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000000233c33c676a5eb2416094a87b3657000000; // add x^(11-1) * (34! * 11^(11-1) / 11!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x0000000541cde48bc0254bed49a9f8700000000000; // sub x^(12-1) * (34! * 12^(12-1) / 12!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000000cae1fad2cdd4d4cb8d73abca0d19a400000; // add x^(13-1) * (34! * 13^(13-1) / 13!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x0000001edb2aa2f760d15c41ceedba956400000000; // sub x^(14-1) * (34! * 14^(14-1) / 14!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000004ba8d20d2dabd386c9529659841a2e200000; // add x^(15-1) * (34! * 15^(15-1) / 15!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x000000bac08546b867cdaa20000000000000000000; // sub x^(16-1) * (34! * 16^(16-1) / 16!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000001cfa8e70c03625b9db76c8ebf5bbf24820000; // add x^(17-1) * (34! * 17^(17-1) / 17!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x000004851d99f82060df265f3309b26f8200000000; // sub x^(18-1) * (34! * 18^(18-1) / 18!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x00000b550d19b129d270c44f6f55f027723cbb0000; // add x^(19-1) * (34! * 19^(19-1) / 19!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x00001c877dadc761dc272deb65d4b0000000000000; // sub x^(20-1) * (34! * 20^(20-1) / 20!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000048178ece97479f33a77f2ad22a81b64406c000; // add x^(21-1) * (34! * 21^(21-1) / 21!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x0000b6ca8268b9d810fedf6695ef2f8a6c00000000; // sub x^(22-1) * (34! * 22^(22-1) / 22!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0001d0e76631a5b05d007b8cb72a7c7f11ec36e000; // add x^(23-1) * (34! * 23^(23-1) / 23!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x0004a1c37bd9f85fd9c6c780000000000000000000; // sub x^(24-1) * (34! * 24^(24-1) / 24!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000bd8369f1b702bf491e2ebfcee08250313b65400; // add x^(25-1) * (34! * 25^(25-1) / 25!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x001e5c7c32a9f6c70ab2cb59d9225764d400000000; // sub x^(26-1) * (34! * 26^(26-1) / 26!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x004dff5820e165e910f95120a708e742496221e600; // add x^(27-1) * (34! * 27^(27-1) / 27!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x00c8c8f66db1fced378ee50e536000000000000000; // sub x^(28-1) * (34! * 28^(28-1) / 28!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0205db8dffff45bfa2938f128f599dbf16eb11d880; // add x^(29-1) * (34! * 29^(29-1) / 29!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x053a044ebd984351493e1786af38d39a0800000000; // sub x^(30-1) * (34! * 30^(30-1) / 30!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0d86dae2a4cc0f47633a544479735869b487b59c40; // add x^(31-1) * (34! * 31^(31-1) / 31!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0x231000000000000000000000000000000000000000; // sub x^(32-1) * (34! * 32^(32-1) / 32!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x5b0485a76f6646c2039db1507cdd51b08649680822; // add x^(33-1) * (34! * 33^(33-1) / 33!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres -= xi * 0xec983c46c49545bc17efa6b5b0055e242200000000; // sub x^(34-1) * (34! * 34^(34-1) / 34!)\\n\\n\\t\\treturn res / 0xde1bc4d19efcac82445da75b00000000; // divide by 34!\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes W(x / FIXED_1) / (x / FIXED_1) * FIXED_1\\n\\t * input range: LAMBERT_CONV_RADIUS + 1 <= x <= LAMBERT_POS2_MAXVAL\\n\\t */\\n\\tfunction lambertPos2(uint256 _x) internal view returns (uint256) {\\n\\t\\tuint256 x = _x - LAMBERT_CONV_RADIUS - 1;\\n\\t\\tuint256 i = x / LAMBERT_POS2_SAMPLE;\\n\\t\\tuint256 a = LAMBERT_POS2_SAMPLE * i;\\n\\t\\tuint256 b = LAMBERT_POS2_SAMPLE * (i + 1);\\n\\t\\tuint256 c = lambertArray[i];\\n\\t\\tuint256 d = lambertArray[i + 1];\\n\\t\\treturn (c * (b - x) + d * (x - a)) / LAMBERT_POS2_SAMPLE;\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes W(x / FIXED_1) / (x / FIXED_1) * FIXED_1\\n\\t * input range: LAMBERT_POS2_MAXVAL + 1 <= x <= LAMBERT_POS3_MAXVAL\\n\\t */\\n\\tfunction lambertPos3(uint256 _x) internal pure returns (uint256) {\\n\\t\\tuint256 l1 = _x < OPT_LOG_MAX_VAL ? optimalLog(_x) : generalLog(_x);\\n\\t\\tuint256 l2 = l1 < OPT_LOG_MAX_VAL ? optimalLog(l1) : generalLog(l1);\\n\\t\\treturn ((l1 - l2 + (l2 * FIXED_1) / l1) * FIXED_1) / _x;\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes W(-x / FIXED_1) / (-x / FIXED_1) * FIXED_1\\n\\t * input range: 1 <= x <= 1 / e * FIXED_1\\n\\t * auto-generated via 'PrintFunctionLambertNeg1.py'\\n\\t */\\n\\tfunction lambertNeg1(uint256 _x) internal pure returns (uint256) {\\n\\t\\tuint256 xi = _x;\\n\\t\\tuint256 res = 0;\\n\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x00000000014d29a73a6e7b02c3668c7b0880000000; // add x^(03-1) * (34! * 03^(03-1) / 03!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000000002504a0cd9a7f7215b60f9be4800000000; // add x^(04-1) * (34! * 04^(04-1) / 04!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000000000484d0a1191c0ead267967c7a4a0000000; // add x^(05-1) * (34! * 05^(05-1) / 05!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x00000000095ec580d7e8427a4baf26a90a00000000; // add x^(06-1) * (34! * 06^(06-1) / 06!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000000001440b0be1615a47dba6e5b3b1f10000000; // add x^(07-1) * (34! * 07^(07-1) / 07!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000000002d207601f46a99b4112418400000000000; // add x^(08-1) * (34! * 08^(08-1) / 08!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000000066ebaac4c37c622dd8288a7eb1b2000000; // add x^(09-1) * (34! * 09^(09-1) / 09!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x00000000ef17240135f7dbd43a1ba10cf200000000; // add x^(10-1) * (34! * 10^(10-1) / 10!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000000233c33c676a5eb2416094a87b3657000000; // add x^(11-1) * (34! * 11^(11-1) / 11!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000000541cde48bc0254bed49a9f8700000000000; // add x^(12-1) * (34! * 12^(12-1) / 12!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000000cae1fad2cdd4d4cb8d73abca0d19a400000; // add x^(13-1) * (34! * 13^(13-1) / 13!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000001edb2aa2f760d15c41ceedba956400000000; // add x^(14-1) * (34! * 14^(14-1) / 14!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000004ba8d20d2dabd386c9529659841a2e200000; // add x^(15-1) * (34! * 15^(15-1) / 15!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000000bac08546b867cdaa20000000000000000000; // add x^(16-1) * (34! * 16^(16-1) / 16!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000001cfa8e70c03625b9db76c8ebf5bbf24820000; // add x^(17-1) * (34! * 17^(17-1) / 17!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000004851d99f82060df265f3309b26f8200000000; // add x^(18-1) * (34! * 18^(18-1) / 18!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x00000b550d19b129d270c44f6f55f027723cbb0000; // add x^(19-1) * (34! * 19^(19-1) / 19!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x00001c877dadc761dc272deb65d4b0000000000000; // add x^(20-1) * (34! * 20^(20-1) / 20!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000048178ece97479f33a77f2ad22a81b64406c000; // add x^(21-1) * (34! * 21^(21-1) / 21!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0000b6ca8268b9d810fedf6695ef2f8a6c00000000; // add x^(22-1) * (34! * 22^(22-1) / 22!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0001d0e76631a5b05d007b8cb72a7c7f11ec36e000; // add x^(23-1) * (34! * 23^(23-1) / 23!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0004a1c37bd9f85fd9c6c780000000000000000000; // add x^(24-1) * (34! * 24^(24-1) / 24!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x000bd8369f1b702bf491e2ebfcee08250313b65400; // add x^(25-1) * (34! * 25^(25-1) / 25!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x001e5c7c32a9f6c70ab2cb59d9225764d400000000; // add x^(26-1) * (34! * 26^(26-1) / 26!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x004dff5820e165e910f95120a708e742496221e600; // add x^(27-1) * (34! * 27^(27-1) / 27!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x00c8c8f66db1fced378ee50e536000000000000000; // add x^(28-1) * (34! * 28^(28-1) / 28!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0205db8dffff45bfa2938f128f599dbf16eb11d880; // add x^(29-1) * (34! * 29^(29-1) / 29!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x053a044ebd984351493e1786af38d39a0800000000; // add x^(30-1) * (34! * 30^(30-1) / 30!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x0d86dae2a4cc0f47633a544479735869b487b59c40; // add x^(31-1) * (34! * 31^(31-1) / 31!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x231000000000000000000000000000000000000000; // add x^(32-1) * (34! * 32^(32-1) / 32!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0x5b0485a76f6646c2039db1507cdd51b08649680822; // add x^(33-1) * (34! * 33^(33-1) / 33!)\\n\\t\\txi = (xi * _x) / FIXED_1;\\n\\t\\tres += xi * 0xec983c46c49545bc17efa6b5b0055e242200000000; // add x^(34-1) * (34! * 34^(34-1) / 34!)\\n\\n\\t\\treturn res / 0xde1bc4d19efcac82445da75b00000000 + _x + FIXED_1; // divide by 34! and then add x^(2-1) * (34! * 2^(2-1) / 2!) + x^(1-1) * (34! * 1^(1-1) / 1!)\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes the weights based on \\\"W(log(hi / lo) * tq / rp) * tq / rp\\\", where \\\"W\\\" is a variation of the Lambert W function.\\n\\t */\\n\\tfunction balancedWeightsByStake(\\n\\t\\tuint256 _hi,\\n\\t\\tuint256 _lo,\\n\\t\\tuint256 _tq,\\n\\t\\tuint256 _rp,\\n\\t\\tbool _lowerStake\\n\\t) internal view returns (uint32, uint32) {\\n\\t\\t(_tq, _rp) = safeFactors(_tq, _rp);\\n\\t\\tuint256 f = _hi.mul(FIXED_1) / _lo;\\n\\t\\tuint256 g = f < OPT_LOG_MAX_VAL ? optimalLog(f) : generalLog(f);\\n\\t\\tuint256 x = g.mul(_tq) / _rp;\\n\\t\\tuint256 y = _lowerStake ? lowerStake(x) : higherStake(x);\\n\\t\\treturn normalizedWeights(y.mul(_tq), _rp.mul(FIXED_1));\\n\\t}\\n\\n\\t/**\\n\\t * @dev reduces \\\"a\\\" and \\\"b\\\" while maintaining their ratio.\\n\\t */\\n\\tfunction safeFactors(uint256 _a, uint256 _b)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (uint256, uint256)\\n\\t{\\n\\t\\tif (_a <= FIXED_2 && _b <= FIXED_2) return (_a, _b);\\n\\t\\tif (_a < FIXED_2) return ((_a * FIXED_2) / _b, FIXED_2);\\n\\t\\tif (_b < FIXED_2) return (FIXED_2, (_b * FIXED_2) / _a);\\n\\t\\tuint256 c = _a > _b ? _a : _b;\\n\\t\\tuint256 n = floorLog2(c / FIXED_1);\\n\\t\\treturn (_a >> n, _b >> n);\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes \\\"MAX_WEIGHT * a / (a + b)\\\" and \\\"MAX_WEIGHT * b / (a + b)\\\".\\n\\t */\\n\\tfunction normalizedWeights(uint256 _a, uint256 _b)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (uint32, uint32)\\n\\t{\\n\\t\\tif (_a <= _b) return accurateWeights(_a, _b);\\n\\t\\t(uint32 y, uint32 x) = accurateWeights(_b, _a);\\n\\t\\treturn (x, y);\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes \\\"MAX_WEIGHT * a / (a + b)\\\" and \\\"MAX_WEIGHT * b / (a + b)\\\", assuming that \\\"a <= b\\\".\\n\\t */\\n\\tfunction accurateWeights(uint256 _a, uint256 _b)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (uint32, uint32)\\n\\t{\\n\\t\\tif (_a > MAX_UNF_WEIGHT) {\\n\\t\\t\\tuint256 c = _a / (MAX_UNF_WEIGHT + 1) + 1;\\n\\t\\t\\t_a /= c;\\n\\t\\t\\t_b /= c;\\n\\t\\t}\\n\\t\\tuint256 x = roundDiv(_a * MAX_WEIGHT, _a.add(_b));\\n\\t\\tuint256 y = MAX_WEIGHT - x;\\n\\t\\treturn (uint32(x), uint32(y));\\n\\t}\\n\\n\\t/**\\n\\t * @dev computes the nearest integer to a given quotient without overflowing or underflowing.\\n\\t */\\n\\tfunction roundDiv(uint256 _n, uint256 _d) internal pure returns (uint256) {\\n\\t\\treturn _n / _d + (_n % _d) / (_d - _d / 2);\\n\\t}\\n\\n\\t/**\\n\\t * @dev deprecated, backward compatibility\\n\\t */\\n\\tfunction calculatePurchaseReturn(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveWeight,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\treturn\\n\\t\\t\\tpurchaseTargetAmount(\\n\\t\\t\\t\\t_supply,\\n\\t\\t\\t\\t_reserveBalance,\\n\\t\\t\\t\\t_reserveWeight,\\n\\t\\t\\t\\t_amount\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev deprecated, backward compatibility\\n\\t */\\n\\tfunction calculateSaleReturn(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveWeight,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\treturn\\n\\t\\t\\tsaleTargetAmount(_supply, _reserveBalance, _reserveWeight, _amount);\\n\\t}\\n\\n\\t/**\\n\\t * @dev deprecated, backward compatibility\\n\\t */\\n\\tfunction calculateCrossReserveReturn(\\n\\t\\tuint256 _sourceReserveBalance,\\n\\t\\tuint32 _sourceReserveWeight,\\n\\t\\tuint256 _targetReserveBalance,\\n\\t\\tuint32 _targetReserveWeight,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\treturn\\n\\t\\t\\tcrossReserveTargetAmount(\\n\\t\\t\\t\\t_sourceReserveBalance,\\n\\t\\t\\t\\t_sourceReserveWeight,\\n\\t\\t\\t\\t_targetReserveBalance,\\n\\t\\t\\t\\t_targetReserveWeight,\\n\\t\\t\\t\\t_amount\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev deprecated, backward compatibility\\n\\t */\\n\\tfunction calculateCrossConnectorReturn(\\n\\t\\tuint256 _sourceReserveBalance,\\n\\t\\tuint32 _sourceReserveWeight,\\n\\t\\tuint256 _targetReserveBalance,\\n\\t\\tuint32 _targetReserveWeight,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\treturn\\n\\t\\t\\tcrossReserveTargetAmount(\\n\\t\\t\\t\\t_sourceReserveBalance,\\n\\t\\t\\t\\t_sourceReserveWeight,\\n\\t\\t\\t\\t_targetReserveBalance,\\n\\t\\t\\t\\t_targetReserveWeight,\\n\\t\\t\\t\\t_amount\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev deprecated, backward compatibility\\n\\t */\\n\\tfunction calculateFundCost(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveRatio,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\treturn fundCost(_supply, _reserveBalance, _reserveRatio, _amount);\\n\\t}\\n\\n\\t/**\\n\\t * @dev deprecated, backward compatibility\\n\\t */\\n\\tfunction calculateLiquidateReturn(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveRatio,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\treturn\\n\\t\\t\\tliquidateReserveAmount(\\n\\t\\t\\t\\t_supply,\\n\\t\\t\\t\\t_reserveBalance,\\n\\t\\t\\t\\t_reserveRatio,\\n\\t\\t\\t\\t_amount\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev deprecated, backward compatibility\\n\\t */\\n\\tfunction purchaseRate(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveWeight,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\treturn\\n\\t\\t\\tpurchaseTargetAmount(\\n\\t\\t\\t\\t_supply,\\n\\t\\t\\t\\t_reserveBalance,\\n\\t\\t\\t\\t_reserveWeight,\\n\\t\\t\\t\\t_amount\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev deprecated, backward compatibility\\n\\t */\\n\\tfunction saleRate(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveWeight,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\treturn\\n\\t\\t\\tsaleTargetAmount(_supply, _reserveBalance, _reserveWeight, _amount);\\n\\t}\\n\\n\\t/**\\n\\t * @dev deprecated, backward compatibility\\n\\t */\\n\\tfunction crossReserveRate(\\n\\t\\tuint256 _sourceReserveBalance,\\n\\t\\tuint32 _sourceReserveWeight,\\n\\t\\tuint256 _targetReserveBalance,\\n\\t\\tuint32 _targetReserveWeight,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\treturn\\n\\t\\t\\tcrossReserveTargetAmount(\\n\\t\\t\\t\\t_sourceReserveBalance,\\n\\t\\t\\t\\t_sourceReserveWeight,\\n\\t\\t\\t\\t_targetReserveBalance,\\n\\t\\t\\t\\t_targetReserveWeight,\\n\\t\\t\\t\\t_amount\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev deprecated, backward compatibility\\n\\t */\\n\\tfunction liquidateRate(\\n\\t\\tuint256 _supply,\\n\\t\\tuint256 _reserveBalance,\\n\\t\\tuint32 _reserveRatio,\\n\\t\\tuint256 _amount\\n\\t) public view returns (uint256) {\\n\\t\\treturn\\n\\t\\t\\tliquidateReserveAmount(\\n\\t\\t\\t\\t_supply,\\n\\t\\t\\t\\t_reserveBalance,\\n\\t\\t\\t\\t_reserveRatio,\\n\\t\\t\\t\\t_amount\\n\\t\\t\\t);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMathUpgradeable {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/GReputation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport \\\"./Reputation.sol\\\";\\nimport \\\"../Interfaces.sol\\\";\\n\\n/**\\n * @title GReputation extends Reputation with delegation and cross blockchain merkle states\\n * @dev NOTICE: this breaks DAOStack nativeReputation usage, since it is not possiible to upgrade\\n * the original nativeReputation token. it means you can no longer rely on avatar.nativeReputation() or controller.nativeReputation()\\n * to return the current reputation token.\\n * The DAO avatar will be the owner of this reputation token and not the Controller.\\n * Minting by the DAO will be done using controller.genericCall and not via controller.mintReputation\\n */\\ncontract GReputation is Reputation {\\n\\tbytes32 public constant ROOT_STATE = keccak256(\\\"rootState\\\");\\n\\n\\t/// @notice The EIP-712 typehash for the contract's domain\\n\\tbytes32 public constant DOMAIN_TYPEHASH =\\n\\t\\tkeccak256(\\n\\t\\t\\t\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\"\\n\\t\\t);\\n\\n\\t/// @notice The EIP-712 typehash for the delegation struct used by the contract\\n\\tbytes32 public constant DELEGATION_TYPEHASH =\\n\\t\\tkeccak256(\\\"Delegation(address delegate,uint256 nonce,uint256 expiry)\\\");\\n\\n\\t/// @notice describe a single blockchain states\\n\\t/// @param stateHash the hash with the reputation state\\n\\t/// @param hashType the type of hash. currently just 0 = merkle tree root hash\\n\\t/// @param totalSupply the totalSupply at the blockchain\\n\\t/// @param blockNumber the effective blocknumber\\n\\tstruct BlockchainState {\\n\\t\\tbytes32 stateHash;\\n\\t\\tuint256 hashType;\\n\\t\\tuint256 totalSupply;\\n\\t\\tuint256 blockNumber;\\n\\t\\tuint256[5] __reserevedSpace;\\n\\t}\\n\\n\\t/// @notice A record of states for signing / validating signatures\\n\\tmapping(address => uint256) public nonces;\\n\\n\\t/// @notice mapping from blockchain id hash to list of states\\n\\tmapping(bytes32 => BlockchainState[]) public blockchainStates;\\n\\n\\t/// @notice mapping from stateHash to the user balance can be >0 only after supplying state proof\\n\\tmapping(bytes32 => mapping(address => uint256)) public stateHashBalances;\\n\\n\\t/// @notice list of blockchains having a statehash for easy iteration\\n\\tbytes32[] public activeBlockchains;\\n\\n\\t/// @notice keep map of user -> delegate\\n\\tmapping(address => address) public delegates;\\n\\n\\t/// @notice map of user non delegated + delegated votes to user. this is used for actual voting\\n\\tmapping(address => uint256[]) public activeVotes;\\n\\n\\t/// @notice keep map of address -> reputation recipient, an address can set that its earned rep will go to another address\\n\\tmapping(address => address) public reputationRecipients;\\n\\n\\t/// @notice An event thats emitted when a delegate account's vote balance changes\\n\\tevent DelegateVotesChanged(\\n\\t\\taddress indexed delegate,\\n\\t\\taddress indexed delegator,\\n\\t\\tuint256 previousBalance,\\n\\t\\tuint256 newBalance\\n\\t);\\n\\n\\tevent StateHash(string blockchain, bytes32 merkleRoot, uint256 totalSupply);\\n\\n\\tevent StateHashProof(string blockchain, address user, uint256 repBalance);\\n\\n\\t/**\\n\\t * @dev initialize\\n\\t */\\n\\tfunction initialize(\\n\\t\\tINameService _ns,\\n\\t\\tstring calldata _stateId,\\n\\t\\tbytes32 _stateHash,\\n\\t\\tuint256 _totalSupply\\n\\t) external initializer {\\n\\t\\t__Reputation_init(_ns);\\n\\t\\tif (_totalSupply > 0)\\n\\t\\t\\t_setBlockchainStateHash(_stateId, _stateHash, _totalSupply);\\n\\t}\\n\\n\\tfunction _canMint() internal view override {\\n\\t\\trequire(\\n\\t\\t\\t_msgSender() == nameService.getAddress(\\\"GDAO_CLAIMERS\\\") ||\\n\\t\\t\\t\\t_msgSender() == nameService.getAddress(\\\"GDAO_STAKING\\\") ||\\n\\t\\t\\t\\t_msgSender() == nameService.getAddress(\\\"GDAO_STAKERS\\\") ||\\n\\t\\t\\t\\thasRole(MINTER_ROLE, _msgSender()),\\n\\t\\t\\t\\\"GReputation: need minter role or be GDAO contract\\\"\\n\\t\\t);\\n\\t}\\n\\n\\t/// @notice internal function that overrides Reputation.sol with consideration to delegation\\n\\t/// @param _user the address to mint for\\n\\t/// @param _amount the amount of rep to mint\\n\\t/// @return the actual amount minted\\n\\tfunction _mint(address _user, uint256 _amount)\\n\\t\\tinternal\\n\\t\\toverride\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\taddress repTarget = reputationRecipients[_user];\\n\\t\\trepTarget = repTarget != address(0) ? repTarget : _user;\\n\\n\\t\\tsuper._mint(repTarget, _amount);\\n\\n\\t\\t//set self as initial delegator\\n\\t\\taddress delegator = delegates[repTarget];\\n\\t\\tif (delegator == address(0)) {\\n\\t\\t\\tdelegates[repTarget] = repTarget;\\n\\t\\t\\tdelegator = repTarget;\\n\\t\\t}\\n\\t\\tuint256 previousVotes = getVotesAt(delegator, false, block.number);\\n\\n\\t\\t_updateDelegateVotes(\\n\\t\\t\\tdelegator,\\n\\t\\t\\trepTarget,\\n\\t\\t\\tpreviousVotes,\\n\\t\\t\\tpreviousVotes + _amount\\n\\t\\t);\\n\\t\\treturn _amount;\\n\\t}\\n\\n\\t/// @notice internal function that overrides Reputation.sol with consideration to delegation\\n\\t/// @param _user the address to burn from\\n\\t/// @param _amount the amount of rep to mint\\n\\t/// @return the actual amount burned\\n\\tfunction _burn(address _user, uint256 _amount)\\n\\t\\tinternal\\n\\t\\toverride\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\tuint256 amountBurned = super._burn(_user, _amount);\\n\\t\\taddress delegator = delegates[_user];\\n\\t\\tdelegator = delegator != address(0) ? delegator : _user;\\n\\t\\tdelegates[_user] = delegator;\\n\\n\\t\\tuint256 previousVotes = getVotesAt(delegator, false, block.number);\\n\\n\\t\\t_updateDelegateVotes(\\n\\t\\t\\tdelegator,\\n\\t\\t\\t_user,\\n\\t\\t\\tpreviousVotes,\\n\\t\\t\\tpreviousVotes - amountBurned\\n\\t\\t);\\n\\n\\t\\treturn amountBurned;\\n\\t}\\n\\n\\t/// @notice sets the state hash of a blockchain, can only be called by owner\\n\\t/// @param _id the string name of the blockchain (will be hashed to produce byte32 id)\\n\\t/// @param _hash the state hash\\n\\t/// @param _totalSupply total supply of reputation on the specific blockchain\\n\\tfunction setBlockchainStateHash(\\n\\t\\tstring memory _id,\\n\\t\\tbytes32 _hash,\\n\\t\\tuint256 _totalSupply\\n\\t) public {\\n\\t\\t_onlyAvatar();\\n\\t\\t_setBlockchainStateHash(_id, _hash, _totalSupply);\\n\\t}\\n\\n\\t/// @notice sets the state hash of a blockchain, can only be called by owner\\n\\t/// @param _id the string name of the blockchain (will be hashed to produce byte32 id)\\n\\t/// @param _hash the state hash\\n\\t/// @param _totalSupply total supply of reputation on the specific blockchain\\n\\tfunction _setBlockchainStateHash(\\n\\t\\tstring memory _id,\\n\\t\\tbytes32 _hash,\\n\\t\\tuint256 _totalSupply\\n\\t) internal {\\n\\t\\tbytes32 idHash = keccak256(bytes(_id));\\n\\n\\t\\t//dont consider rootState as blockchain,  it is a special state hash\\n\\t\\tbool isRootState = idHash == ROOT_STATE;\\n\\t\\trequire(\\n\\t\\t\\t!isRootState || totalSupplyLocalAt(block.number) == 0,\\n\\t\\t\\t\\\"rootState already created\\\"\\n\\t\\t);\\n\\t\\tuint256 i = 0;\\n\\t\\tfor (; !isRootState && i < activeBlockchains.length; i++) {\\n\\t\\t\\tif (activeBlockchains[i] == idHash) break;\\n\\t\\t}\\n\\n\\t\\t//if new blockchain\\n\\t\\tif (!isRootState && i == activeBlockchains.length) {\\n\\t\\t\\tactiveBlockchains.push(idHash);\\n\\t\\t}\\n\\n\\t\\tBlockchainState memory state;\\n\\t\\tstate.stateHash = _hash;\\n\\t\\tstate.totalSupply = _totalSupply;\\n\\t\\tstate.blockNumber = block.number;\\n\\t\\tblockchainStates[idHash].push(state);\\n\\n\\t\\temit StateHash(_id, _hash, _totalSupply);\\n\\t}\\n\\n\\t/// @notice get the number of active votes a user holds after delegation (vs the basic balance of reputation he holds)\\n\\t/// @param _user the user to get active votes for\\n\\t/// @param _global wether to include reputation from other blockchains\\n\\t/// @param _blockNumber get votes state at specific block\\n\\t/// @return the number of votes\\n\\tfunction getVotesAt(\\n\\t\\taddress _user,\\n\\t\\tbool _global,\\n\\t\\tuint256 _blockNumber\\n\\t) public view returns (uint256) {\\n\\t\\tuint256 startingBalance = getValueAt(activeVotes[_user], _blockNumber);\\n\\n\\t\\tif (_global) {\\n\\t\\t\\tfor (uint256 i = 0; i < activeBlockchains.length; i++) {\\n\\t\\t\\t\\tstartingBalance += getVotesAtBlockchain(\\n\\t\\t\\t\\t\\tactiveBlockchains[i],\\n\\t\\t\\t\\t\\t_user,\\n\\t\\t\\t\\t\\t_blockNumber\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn startingBalance;\\n\\t}\\n\\n\\t/**\\n\\t * @notice returns aggregated active votes in all blockchains and delegated\\n\\t * @param _user the user to get active votes for\\n\\t * @return the number of votes\\n\\t */\\n\\tfunction getVotes(address _user) public view returns (uint256) {\\n\\t\\treturn getVotesAt(_user, true, block.number);\\n\\t}\\n\\n\\t/**\\n\\t * @notice same as getVotes, be compatible with metamask\\n\\t */\\n\\tfunction balanceOf(address _user) public view returns (uint256 balance) {\\n\\t\\treturn getVotesAt(_user, block.number);\\n\\t}\\n\\n\\t/**\\n\\t same as getVotes be compatible with compound \\n\\t */\\n\\tfunction getCurrentVotes(address _user) public view returns (uint256) {\\n\\t\\treturn getVotesAt(_user, true, block.number);\\n\\t}\\n\\n\\tfunction getPriorVotes(address _user, uint256 _block)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\treturn getVotesAt(_user, true, _block);\\n\\t}\\n\\n\\t/**\\n\\t * @notice returns aggregated active votes in all blockchains and delegated at specific block\\n\\t * @param _user user to get active votes for\\n\\t * @param _blockNumber get votes state at specific block\\n\\t * @return the number of votes\\n\\t */\\n\\tfunction getVotesAt(address _user, uint256 _blockNumber)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\treturn getVotesAt(_user, true, _blockNumber);\\n\\t}\\n\\n\\t/**\\n\\t * @notice returns total supply in current blockchain\\n\\t * @param _blockNumber get total supply at specific block\\n\\t * @return the totaly supply\\n\\t */\\n\\tfunction totalSupplyLocal(uint256 _blockNumber)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\treturn totalSupplyLocalAt(_blockNumber);\\n\\t}\\n\\n\\t/**\\n\\t * @notice returns total supply in all blockchain aggregated\\n\\t * @param _blockNumber get total supply at specific block\\n\\t * @return the totaly supply\\n\\t */\\n\\tfunction totalSupplyAt(uint256 _blockNumber) public view returns (uint256) {\\n\\t\\tuint256 startingSupply = totalSupplyLocalAt(_blockNumber);\\n\\t\\tfor (uint256 i = 0; i < activeBlockchains.length; i++) {\\n\\t\\t\\tstartingSupply += totalSupplyAtBlockchain(\\n\\t\\t\\t\\tactiveBlockchains[i],\\n\\t\\t\\t\\t_blockNumber\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\treturn startingSupply;\\n\\t}\\n\\n\\t/// @dev This function makes it easy to get the total number of reputation\\n\\t/// @return The total number of reputation\\n\\tfunction totalSupply() public view returns (uint256) {\\n\\t\\treturn totalSupplyAt(block.number);\\n\\t}\\n\\n\\t/// @notice get the number of active votes a user holds after delegation in specific blockchain\\n\\t/// @param _id the keccak hash of the blockchain string id\\n\\t/// @param _user the user to get active votes for\\n\\t/// @param _blockNumber get votes state at specific block\\n\\t/// @return the number of votes\\n\\tfunction getVotesAtBlockchain(\\n\\t\\tbytes32 _id,\\n\\t\\taddress _user,\\n\\t\\tuint256 _blockNumber\\n\\t) public view returns (uint256) {\\n\\t\\tBlockchainState[] storage states = blockchainStates[_id];\\n\\t\\tint256 i = int256(states.length);\\n\\n\\t\\tif (i == 0) return 0;\\n\\t\\tBlockchainState storage state = states[uint256(i - 1)];\\n\\t\\tfor (i = i - 1; i >= 0; i--) {\\n\\t\\t\\tif (state.blockNumber <= _blockNumber) break;\\n\\t\\t\\tstate = states[uint256(i - 1)];\\n\\t\\t}\\n\\t\\tif (i < 0) return 0;\\n\\n\\t\\treturn stateHashBalances[state.stateHash][_user];\\n\\t}\\n\\n\\t/**\\n\\t * @notice returns total supply in a specific blockchain\\n\\t * @param _blockNumber get total supply at specific block\\n\\t * @return the totaly supply\\n\\t */\\n\\tfunction totalSupplyAtBlockchain(bytes32 _id, uint256 _blockNumber)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\tBlockchainState[] storage states = blockchainStates[_id];\\n\\t\\tint256 i;\\n\\t\\tif (states.length == 0) return 0;\\n\\t\\tfor (i = int256(states.length - 1); i >= 0; i--) {\\n\\t\\t\\tif (states[uint256(i)].blockNumber <= _blockNumber) break;\\n\\t\\t}\\n\\t\\tif (i < 0) return 0;\\n\\n\\t\\tBlockchainState storage state = states[uint256(i)];\\n\\t\\treturn state.totalSupply;\\n\\t}\\n\\n\\t/**\\n\\t * @notice prove user balance in a specific blockchain state hash\\n\\t * @dev \\\"rootState\\\" is a special state that can be supplied once, and actually mints reputation on the current blockchain\\n\\t * we use non sorted merkle tree, as sorting while preparing merkle tree is heavy\\n\\t * @param _id the string id of the blockchain we supply proof for\\n\\t * @param _user the user to prove his balance\\n\\t * @param _balance the balance we are prooving\\n\\t * @param _proof array of byte32 with proof data (currently merkle tree path)\\n \\t * @param _nodeIndex index of node in the tree (for unsorted merkle tree proof)\\n\\n\\t * @return true if proof is valid\\n\\t */\\n\\tfunction proveBalanceOfAtBlockchain(\\n\\t\\tstring memory _id,\\n\\t\\taddress _user,\\n\\t\\tuint256 _balance,\\n\\t\\tbytes32[] memory _proof,\\n\\t\\tuint256 _nodeIndex\\n\\t) public returns (bool) {\\n\\t\\tbytes32 idHash = keccak256(bytes(_id));\\n\\t\\trequire(\\n\\t\\t\\tblockchainStates[idHash].length > 0,\\n\\t\\t\\t\\\"no state found for given _id\\\"\\n\\t\\t);\\n\\t\\tbytes32 stateHash = blockchainStates[idHash][\\n\\t\\t\\tblockchainStates[idHash].length - 1\\n\\t\\t].stateHash;\\n\\n\\t\\t//this is specifically important for rootState that should update real balance only once\\n\\t\\trequire(\\n\\t\\t\\tstateHashBalances[stateHash][_user] == 0,\\n\\t\\t\\t\\\"stateHash already proved\\\"\\n\\t\\t);\\n\\n\\t\\tbytes32 leafHash = keccak256(abi.encode(_user, _balance));\\n\\t\\tbool isProofValid = checkProofOrdered(\\n\\t\\t\\t_proof,\\n\\t\\t\\tstateHash,\\n\\t\\t\\tleafHash,\\n\\t\\t\\t_nodeIndex\\n\\t\\t);\\n\\n\\t\\trequire(isProofValid, \\\"invalid merkle proof\\\");\\n\\n\\t\\t//if initiial state then set real balance\\n\\t\\tif (idHash == ROOT_STATE) {\\n\\t\\t\\t_mint(_user, _balance);\\n\\t\\t}\\n\\n\\t\\t//if proof is valid then set balances\\n\\t\\tstateHashBalances[stateHash][_user] = _balance;\\n\\n\\t\\temit StateHashProof(_id, _user, _balance);\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/// @notice returns current delegate of _user\\n\\t/// @param _user the delegatee\\n\\t/// @return the address of the delegate (can be _user  if no delegate or 0x0 if _user doesnt exists)\\n\\tfunction delegateOf(address _user) public view returns (address) {\\n\\t\\treturn delegates[_user];\\n\\t}\\n\\n\\t/// @notice delegate votes to another user\\n\\t/// @param _delegate the recipient of votes\\n\\tfunction delegateTo(address _delegate) public {\\n\\t\\treturn _delegateTo(_msgSender(), _delegate);\\n\\t}\\n\\n\\t/// @notice cancel user delegation\\n\\t/// @dev makes user his own delegate\\n\\tfunction undelegate() public {\\n\\t\\treturn _delegateTo(_msgSender(), _msgSender());\\n\\t}\\n\\n\\t/**\\n\\t * @notice Delegates votes from signatory to `delegate`\\n\\t * @param _delegate The address to delegate votes to\\n\\t * @param _nonce The contract state required to match the signature\\n\\t * @param _expiry The time at which to expire the signature\\n\\t * @param _v The recovery byte of the signature\\n\\t * @param _r Half of the ECDSA signature pair\\n\\t * @param _s Half of the ECDSA signature pair\\n\\t */\\n\\tfunction delegateBySig(\\n\\t\\taddress _delegate,\\n\\t\\tuint256 _nonce,\\n\\t\\tuint256 _expiry,\\n\\t\\tuint8 _v,\\n\\t\\tbytes32 _r,\\n\\t\\tbytes32 _s\\n\\t) public {\\n\\t\\tbytes32 domainSeparator = keccak256(\\n\\t\\t\\tabi.encode(\\n\\t\\t\\t\\tDOMAIN_TYPEHASH,\\n\\t\\t\\t\\tkeccak256(bytes(name)),\\n\\t\\t\\t\\tgetChainId(),\\n\\t\\t\\t\\taddress(this)\\n\\t\\t\\t)\\n\\t\\t);\\n\\t\\tbytes32 structHash = keccak256(\\n\\t\\t\\tabi.encode(DELEGATION_TYPEHASH, _delegate, _nonce, _expiry)\\n\\t\\t);\\n\\t\\tbytes32 digest = keccak256(\\n\\t\\t\\tabi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash)\\n\\t\\t);\\n\\t\\taddress signatory = ecrecover(digest, _v, _r, _s);\\n\\t\\trequire(\\n\\t\\t\\tsignatory != address(0),\\n\\t\\t\\t\\\"GReputation::delegateBySig: invalid signature\\\"\\n\\t\\t);\\n\\t\\trequire(\\n\\t\\t\\t_nonce == nonces[signatory]++,\\n\\t\\t\\t\\\"GReputation::delegateBySig: invalid nonce\\\"\\n\\t\\t);\\n\\t\\trequire(\\n\\t\\t\\tblock.timestamp <= _expiry,\\n\\t\\t\\t\\\"GReputation::delegateBySig: signature expired\\\"\\n\\t\\t);\\n\\t\\treturn _delegateTo(signatory, _delegate);\\n\\t}\\n\\n\\t/// @notice internal function to delegate votes to another user\\n\\t/// @param _user the source of votes (delegator)\\n\\t/// @param _delegate the recipient of votes\\n\\tfunction _delegateTo(address _user, address _delegate) internal {\\n\\t\\trequire(\\n\\t\\t\\t_delegate != address(0),\\n\\t\\t\\t\\\"GReputation::delegate can't delegate to null address\\\"\\n\\t\\t);\\n\\n\\t\\taddress curDelegator = delegates[_user];\\n\\t\\trequire(curDelegator != _delegate, \\\"already delegating to delegator\\\");\\n\\n\\t\\tdelegates[_user] = _delegate;\\n\\n\\t\\t// remove votes from current delegator\\n\\t\\tuint256 coreBalance = balanceOfLocalAt(_user, block.number);\\n\\t\\t//redundant check - should not be possible to have address 0 as delegator\\n\\t\\tif (curDelegator != address(0)) {\\n\\t\\t\\tuint256 removeVotes = getVotesAt(curDelegator, false, block.number);\\n\\t\\t\\t_updateDelegateVotes(\\n\\t\\t\\t\\tcurDelegator,\\n\\t\\t\\t\\t_user,\\n\\t\\t\\t\\tremoveVotes,\\n\\t\\t\\t\\tremoveVotes - coreBalance\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\t//move votes to new delegator\\n\\t\\tuint256 addVotes = getVotesAt(_delegate, false, block.number);\\n\\t\\t_updateDelegateVotes(_delegate, _user, addVotes, addVotes + coreBalance);\\n\\t}\\n\\n\\t/// @notice internal function to update delegated votes, emits event with changes\\n\\t/// @param _delegate the delegate whose record we are updating\\n\\t/// @param _delegator the delegator\\n\\t/// @param _oldVotes the delegate previous votes\\n\\t/// @param _newVotes the delegate votes after the change\\n\\tfunction _updateDelegateVotes(\\n\\t\\taddress _delegate,\\n\\t\\taddress _delegator,\\n\\t\\tuint256 _oldVotes,\\n\\t\\tuint256 _newVotes\\n\\t) internal {\\n\\t\\tupdateValueAtNow(activeVotes[_delegate], _newVotes);\\n\\t\\temit DelegateVotesChanged(_delegate, _delegator, _oldVotes, _newVotes);\\n\\t}\\n\\n\\t// from StorJ -- https://github.com/nginnever/storj-audit-verifier/blob/master/contracts/MerkleVerifyv3.sol\\n\\t/**\\n\\t * @dev non sorted merkle tree proof check\\n\\t */\\n\\tfunction checkProofOrdered(\\n\\t\\tbytes32[] memory _proof,\\n\\t\\tbytes32 _root,\\n\\t\\tbytes32 _hash,\\n\\t\\tuint256 _index\\n\\t) public pure returns (bool) {\\n\\t\\t// use the index to determine the node ordering\\n\\t\\t// index ranges 1 to n\\n\\n\\t\\tbytes32 proofElement;\\n\\t\\tbytes32 computedHash = _hash;\\n\\t\\tuint256 remaining;\\n\\n\\t\\tfor (uint256 j = 0; j < _proof.length; j++) {\\n\\t\\t\\tproofElement = _proof[j];\\n\\n\\t\\t\\t// calculate remaining elements in proof\\n\\t\\t\\tremaining = _proof.length - j;\\n\\n\\t\\t\\t// we don't assume that the tree is padded to a power of 2\\n\\t\\t\\t// if the index is odd then the proof will start with a hash at a higher\\n\\t\\t\\t// layer, so we have to adjust the index to be the index at that layer\\n\\t\\t\\twhile (remaining > 0 && _index % 2 == 1 && _index > 2**remaining) {\\n\\t\\t\\t\\t_index = _index / 2 + 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (_index % 2 == 0) {\\n\\t\\t\\t\\tcomputedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n\\t\\t\\t\\t_index = _index / 2;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcomputedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n\\t\\t\\t\\t_index = _index / 2 + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn computedHash == _root;\\n\\t}\\n\\n\\t/// @notice helper function to get current chain id\\n\\t/// @return chain id\\n\\tfunction getChainId() internal view returns (uint256) {\\n\\t\\tuint256 chainId;\\n\\t\\tassembly {\\n\\t\\t\\tchainId := chainid()\\n\\t\\t}\\n\\t\\treturn chainId;\\n\\t}\\n\\n\\tfunction setReputationRecipient(address _target) public {\\n\\t\\treputationRecipients[msg.sender] = _target;\\n\\t}\\n\\n\\tfunction fix1() public {\\n\\t\\tif (\\n\\t\\t\\tgetVotes(0x7f8c1877Ed0DA352F78be4Fe4CdA58BB804a30dF) ==\\n\\t\\t\\t1008145362854518632309 &&\\n\\t\\t\\tgetVotes(0xDEb250aDD368b74ebCCd59862D62fa4Fb57E09D4) ==\\n\\t\\t\\t587905678906424942728383 &&\\n\\t\\t\\tgetVotes(0x1D5096665E79585019c448259D944090F28702E3) ==\\n\\t\\t\\t3421532080040613840050\\n\\t\\t) {\\n\\t\\t\\t_updateDelegateVotes(\\n\\t\\t\\t\\t0x7f8c1877Ed0DA352F78be4Fe4CdA58BB804a30dF,\\n\\t\\t\\t\\t0x7f8c1877Ed0DA352F78be4Fe4CdA58BB804a30dF,\\n\\t\\t\\t\\t1008145362854518632309,\\n\\t\\t\\t\\tbalanceOfLocal(0x7f8c1877Ed0DA352F78be4Fe4CdA58BB804a30dF)\\n\\t\\t\\t);\\n\\t\\t\\t_updateDelegateVotes(\\n\\t\\t\\t\\t0xDEb250aDD368b74ebCCd59862D62fa4Fb57E09D4,\\n\\t\\t\\t\\t0xDEb250aDD368b74ebCCd59862D62fa4Fb57E09D4,\\n\\t\\t\\t\\t587905678906424942728383,\\n\\t\\t\\t\\tbalanceOfLocal(0xDEb250aDD368b74ebCCd59862D62fa4Fb57E09D4)\\n\\t\\t\\t);\\n\\t\\t\\t_updateDelegateVotes(\\n\\t\\t\\t\\t0x1D5096665E79585019c448259D944090F28702E3,\\n\\t\\t\\t\\t0x1D5096665E79585019c448259D944090F28702E3,\\n\\t\\t\\t\\t3421532080040613840050,\\n\\t\\t\\t\\tbalanceOfLocal(0x1D5096665E79585019c448259D944090F28702E3)\\n\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/governance/MultiBaseGovernanceShareField.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\nimport \\\"../Interfaces.sol\\\";\\nimport \\\"../utils/DSMath.sol\\\";\\n\\n/***\\n * supports accounting for multiple staking contracts to calculate GDAO rewards\\n */\\nabstract contract MultiBaseGovernanceShareField is DSMath {\\n\\t// Total Amount of stakes\\n\\tmapping(address => uint256) totalProductivity;\\n\\t// Reward amount of the each share\\n\\tmapping(address => uint256) accAmountPerShare;\\n\\t// Amount of the rewards which minted so far\\n\\tmapping(address => uint256) public rewardsMintedSoFar;\\n\\t// Amount of the rewards with pending and minted ones together\\n\\tmapping(address => uint256) public totalRewardsAccumulated;\\n\\n\\t// Block number of last reward calculation made\\n\\tmapping(address => uint256) public lastRewardBlock;\\n\\t// Rewards amount that will be provided each block\\n\\tmapping(address => uint256) public rewardsPerBlock;\\n\\n\\tstruct UserInfo {\\n\\t\\tuint128 amount; // How many tokens the user has staked.\\n\\t\\tuint128 rewardDebt; // Rewards that accounted already so should be substracted while calculating rewards of staker\\n\\t\\tuint128 rewardEarn; // Reward earn and not minted\\n\\t\\tuint128 rewardMinted; // rewards sent to the user\\n\\t}\\n\\n\\tmapping(address => mapping(address => UserInfo)) public contractToUsers;\\n\\n\\tfunction getChainBlocksPerMonth() public virtual returns (uint256);\\n\\n\\t/**\\n\\t * @dev Calculate rewards per block from monthly amount of rewards and set it\\n\\t * @param _monthlyAmount total rewards which will distribute monthly\\n\\t */\\n\\tfunction _setMonthlyRewards(address _contract, uint256 _monthlyAmount)\\n\\t\\tinternal\\n\\t{\\n\\t\\trewardsPerBlock[_contract] = _monthlyAmount / getChainBlocksPerMonth();\\n\\t}\\n\\n\\t/**\\n\\t * @dev Update reward variables of the given pool to be up-to-date.\\n\\t * Make reward calculations according to passed blocks and updates rewards by\\n\\t * multiplying passed blocks since last calculation with rewards per block value\\n\\t * and add it to accumalated amount per share by dividing total productivity\\n\\t */\\n\\tfunction _update(\\n\\t\\taddress _contract,\\n\\t\\tuint256 _blockStart,\\n\\t\\tuint256 _blockEnd\\n\\t) internal virtual {\\n\\t\\tif (totalProductivity[_contract] == 0) {\\n\\t\\t\\tlastRewardBlock[_contract] = block.number;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t(uint256 _lastRewardBlock, uint256 _accAmountPerShare) = _calcUpdate(\\n\\t\\t\\t_contract,\\n\\t\\t\\t_blockStart,\\n\\t\\t\\t_blockEnd\\n\\t\\t);\\n\\n\\t\\taccAmountPerShare[_contract] = _accAmountPerShare;\\n\\t\\tlastRewardBlock[_contract] = _lastRewardBlock;\\n\\t}\\n\\n\\t/**\\n\\t * @dev helper to calculate global rewards accumulated per block so far\\n\\t * @param _contract the contract to calcualte the rewards for\\n\\t * @param _blockStart the block from which the contract is eligble for rewards\\n\\t * @param _blockEnd the block from which the contract is no longer eligble for rewards\\n\\t */\\n\\tfunction _calcUpdate(\\n\\t\\taddress _contract,\\n\\t\\tuint256 _blockStart,\\n\\t\\tuint256 _blockEnd\\n\\t)\\n\\t\\tinternal\\n\\t\\tview\\n\\t\\treturns (uint256 _lastRewardBlock, uint256 _accAmountPerShare)\\n\\t{\\n\\t\\t_accAmountPerShare = accAmountPerShare[_contract];\\n\\t\\t_lastRewardBlock = lastRewardBlock[_contract];\\n\\t\\t_lastRewardBlock = _lastRewardBlock < _blockStart &&\\n\\t\\t\\tblock.number >= _blockStart\\n\\t\\t\\t? _blockStart\\n\\t\\t\\t: _lastRewardBlock;\\n\\t\\tuint256 curRewardBlock = block.number > _blockEnd\\n\\t\\t\\t? _blockEnd\\n\\t\\t\\t: block.number;\\n\\t\\tif (curRewardBlock < _blockStart || _lastRewardBlock >= _blockEnd)\\n\\t\\t\\treturn (_lastRewardBlock, _accAmountPerShare);\\n\\n\\t\\tuint256 multiplier = curRewardBlock - _lastRewardBlock; // Blocks passed since last reward block\\n\\t\\tuint256 reward = multiplier * rewardsPerBlock[_contract]; // rewardsPerBlock is in GDAO which is in 18 decimals\\n\\n\\t\\t_accAmountPerShare += (reward * 1e27) / totalProductivity[_contract]; // totalProductivity in 18decimals  and reward in 18 decimals so rdiv result in 27decimals\\n\\t\\t_lastRewardBlock = curRewardBlock;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Audit user's rewards and calculate their earned rewards based on stake_amount * accAmountPerShare\\n\\t */\\n\\tfunction _audit(\\n\\t\\taddress _contract,\\n\\t\\taddress _user,\\n\\t\\tuint256 _updatedAmount\\n\\t) internal virtual {\\n\\t\\tUserInfo storage userInfo = contractToUsers[_contract][_user];\\n\\t\\tif (userInfo.amount > 0) {\\n\\t\\t\\tuint256 pending = (userInfo.amount * accAmountPerShare[_contract]) /\\n\\t\\t\\t\\t1e27 -\\n\\t\\t\\t\\tuserInfo.rewardDebt; // Divide 1e27(because userinfo.amount in 18 decimals and accAmountPerShare is in 27decimals) since rewardDebt in 18 decimals so we can calculate how much reward earned in that cycle\\n\\t\\t\\tuserInfo.rewardEarn = userInfo.rewardEarn + uint128(pending); // Add user's earned rewards to user's account so it can be minted later\\n\\t\\t\\ttotalRewardsAccumulated[_contract] =\\n\\t\\t\\t\\ttotalRewardsAccumulated[_contract] +\\n\\t\\t\\t\\tpending;\\n\\t\\t}\\n\\t\\tuserInfo.amount = uint128(_updatedAmount);\\n\\t\\tuserInfo.rewardDebt = uint128(\\n\\t\\t\\t(_updatedAmount * accAmountPerShare[_contract]) / 1e27\\n\\t\\t); // Divide to 1e27 to keep rewardDebt in 18 decimals since accAmountPerShare is in 27 decimals and amount is 18 decimals\\n\\t}\\n\\n\\t/**\\n\\t * @dev This function increase user's productivity and updates the global productivity.\\n\\t * This function increase user's productivity and updates the global productivity.\\n\\t * the users' actual share percentage will calculated by:\\n\\t * Formula:     user_productivity / global_productivity\\n\\t */\\n\\tfunction _increaseProductivity(\\n\\t\\taddress _contract,\\n\\t\\taddress _user,\\n\\t\\tuint256 _value,\\n\\t\\tuint256 _blockStart,\\n\\t\\tuint256 _blockEnd\\n\\t) internal virtual returns (bool) {\\n\\t\\t_update(_contract, _blockStart, _blockEnd);\\n\\t\\t_audit(_contract, _user, contractToUsers[_contract][_user].amount + _value);\\n\\n\\t\\ttotalProductivity[_contract] = totalProductivity[_contract] + _value;\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n\\t * @dev This function will decreases user's productivity by value, and updates the global productivity\\n\\t * it will record which block this is happenning and accumulates the area of (productivity * time)\\n\\t */\\n\\n\\tfunction _decreaseProductivity(\\n\\t\\taddress _contract,\\n\\t\\taddress _user,\\n\\t\\tuint256 _value,\\n\\t\\tuint256 _blockStart,\\n\\t\\tuint256 _blockEnd\\n\\t) internal virtual returns (bool) {\\n\\t\\t_update(_contract, _blockStart, _blockEnd);\\n\\t\\t_audit(_contract, _user, contractToUsers[_contract][_user].amount - _value);\\n\\n\\t\\ttotalProductivity[_contract] = totalProductivity[_contract] - _value;\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Query user's pending reward with updated variables\\n\\t * @param _contract the contract to calcualte the rewards for\\n\\t * @param _blockStart the block from which the contract is eligble for rewards\\n\\t * @param _blockEnd the block from which the contract is no longer eligble for rewards\\n\\t * @param _user the user to calculate rewards for\\n\\t * @return returns  amount of user's earned but not minted rewards\\n\\t */\\n\\tfunction getUserPendingReward(\\n\\t\\taddress _contract,\\n\\t\\tuint256 _blockStart,\\n\\t\\tuint256 _blockEnd,\\n\\t\\taddress _user\\n\\t) public view returns (uint256) {\\n\\t\\tUserInfo memory userInfo = contractToUsers[_contract][_user];\\n\\t\\tuint256 pending = 0;\\n\\t\\tif (totalProductivity[_contract] != 0) {\\n\\t\\t\\t(, uint256 _accAmountPerShare) = _calcUpdate(\\n\\t\\t\\t\\t_contract,\\n\\t\\t\\t\\t_blockStart,\\n\\t\\t\\t\\t_blockEnd\\n\\t\\t\\t);\\n\\n\\t\\t\\tpending = userInfo.rewardEarn;\\n\\t\\t\\tpending +=\\n\\t\\t\\t\\t(userInfo.amount * _accAmountPerShare) /\\n\\t\\t\\t\\t1e27 -\\n\\t\\t\\t\\tuserInfo.rewardDebt; // Divide 1e27(because userinfo.amount in 18 decimals and accAmountPerShare is in 27decimals) since rewardDebt in 18 decimals so we can calculate how much reward earned in that cycle\\n\\t\\t}\\n\\n\\t\\treturn pending;\\n\\t}\\n\\n\\t/**\\n    @dev Calculate earned rewards of the user and update their reward info\\n\\t* @param _contract address of the contract for accounting\\n    * @param _user address of the user that will be accounted\\n\\t* @param _blockStart the block from which the contract is eligble for rewards\\n\\t* @param _blockEnd the block from which the contract is no longer eligble for rewards\\n    * @return returns minted amount\\n    */\\n\\n\\tfunction _issueEarnedRewards(\\n\\t\\taddress _contract,\\n\\t\\taddress _user,\\n\\t\\tuint256 _blockStart,\\n\\t\\tuint256 _blockEnd\\n\\t) internal returns (uint256) {\\n\\t\\t_update(_contract, _blockStart, _blockEnd);\\n\\t\\t_audit(_contract, _user, contractToUsers[_contract][_user].amount);\\n\\t\\tuint128 amount = contractToUsers[_contract][_user].rewardEarn;\\n\\t\\tcontractToUsers[_contract][_user].rewardMinted += amount;\\n\\t\\tcontractToUsers[_contract][_user].rewardEarn = 0;\\n\\t\\trewardsMintedSoFar[_contract] = rewardsMintedSoFar[_contract] + amount;\\n\\t\\treturn amount;\\n\\t}\\n\\n\\t/**\\n\\t * @return Returns how much productivity a user has and total productivity.\\n\\t */\\n\\tfunction getProductivity(address _contract, address _user)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\tvirtual\\n\\t\\treturns (uint256, uint256)\\n\\t{\\n\\t\\treturn (\\n\\t\\t\\tcontractToUsers[_contract][_user].amount,\\n\\t\\t\\ttotalProductivity[_contract]\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @return Returns the current gross product rate.\\n\\t */\\n\\tfunction totalRewardsPerShare(address _contract)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\tvirtual\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\treturn accAmountPerShare[_contract];\\n\\t}\\n\\n\\t// for upgrades\\n\\tuint256[50] private _gap;\\n}\\n\"\r\n    },\r\n    \"contracts/governance/Reputation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\\\";\\n\\nimport \\\"../utils/DAOUpgradeableContract.sol\\\";\\n\\n/**\\n * based on https://github.com/daostack/infra/blob/60a79a1be02942174e21156c3c9655a7f0695dbd/contracts/Reputation.sol\\n * @title Reputation system\\n * @dev A DAO has Reputation System which allows peers to rate other peers in order to build trust .\\n * A reputation is used to assign influence measure to a DAO'S peers.\\n * Reputation is similar to regular tokens but with one crucial difference: It is non-transferable.\\n * The Reputation contract maintain a map of address to reputation value.\\n * It provides an only minter role functions to mint and burn reputation _to (or _from) a specific address.\\n */\\ncontract Reputation is DAOUpgradeableContract, AccessControlUpgradeable {\\n\\tbytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n\\n\\tstring public name;\\n\\tstring public symbol;\\n\\n\\tuint8 public decimals; //Number of decimals of the smallest unit\\n\\t// Event indicating minting of reputation to an address.\\n\\tevent Mint(address indexed _to, uint256 _amount);\\n\\t// Event indicating burning of reputation for an address.\\n\\tevent Burn(address indexed _from, uint256 _amount);\\n\\tuint256 private constant ZERO_HALF_256 = 0xffffffffffffffffffffffffffffffff;\\n\\n\\t/// @dev `Checkpoint` is the structure that attaches a block number to a\\n\\t///  given value, the block number attached is the one that last changed the\\n\\t///  value\\n\\t//Checkpoint is uint256 :\\n\\t// bits 0-127 `fromBlock` is the block number that the value was generated from\\n\\t// bits 128-255 `value` is the amount of reputation at a specific block number\\n\\n\\t// `balances` is the map that tracks the balance of each address, in this\\n\\t//  contract when the balance changes the block number that the change\\n\\t//  occurred is also included in the map\\n\\tmapping(address => uint256[]) public balances;\\n\\n\\t// Tracks the history of the `totalSupply` of the reputation\\n\\tuint256[] public totalSupplyHistory;\\n\\n\\t/**\\n\\t * @dev initialize\\n\\t */\\n\\tfunction initialize(INameService _ns) public initializer {\\n\\t\\t__Reputation_init(_ns);\\n\\t}\\n\\n\\tfunction __Reputation_init(INameService _ns) internal {\\n\\t\\tdecimals = 18;\\n\\t\\tname = \\\"GoodDAO\\\";\\n\\t\\tsymbol = \\\"GOOD\\\";\\n\\t\\t__Context_init_unchained();\\n\\t\\t__ERC165_init_unchained();\\n\\t\\t__AccessControl_init_unchained();\\n\\n\\t\\tsetDAO(_ns);\\n\\t\\t_setupRole(DEFAULT_ADMIN_ROLE, address(avatar));\\n\\t\\t_setupRole(MINTER_ROLE, address(avatar));\\n\\t}\\n\\n\\tfunction _canMint() internal view virtual {\\n\\t\\trequire(hasRole(MINTER_ROLE, _msgSender()), \\\"Reputation: need minter role\\\");\\n\\t}\\n\\n\\t/// @notice Generates `_amount` reputation that are assigned to `_owner`\\n\\t/// @param _user The address that will be assigned the new reputation\\n\\t/// @param _amount The quantity of reputation generated\\n\\t/// @return True if the reputation are generated correctly\\n\\tfunction mint(address _user, uint256 _amount) public returns (bool) {\\n\\t\\t_canMint();\\n\\t\\t_mint(_user, _amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction _mint(address _user, uint256 _amount)\\n\\t\\tinternal\\n\\t\\tvirtual\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\tuint256 curTotalSupply = totalSupplyLocalAt(block.number);\\n\\t\\tuint256 previousBalanceTo = balanceOfLocalAt(_user, block.number);\\n\\n\\t\\tupdateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\\n\\t\\tupdateValueAtNow(balances[_user], previousBalanceTo + _amount);\\n\\t\\temit Mint(_user, _amount);\\n\\t\\treturn _amount;\\n\\t}\\n\\n\\t/// @notice Burns `_amount` reputation from `_owner`\\n\\t/// @param _user The address that will lose the reputation\\n\\t/// @param _amount The quantity of reputation to burn\\n\\t/// @return True if the reputation are burned correctly\\n\\tfunction burn(address _user, uint256 _amount) public returns (bool) {\\n\\t\\t//user can burn his own rep other wise we check _canMint\\n\\t\\tif (_user != _msgSender()) _canMint();\\n\\t\\t_burn(_user, _amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction _burn(address _user, uint256 _amount)\\n\\t\\tinternal\\n\\t\\tvirtual\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\tuint256 curTotalSupply = totalSupplyLocalAt(block.number);\\n\\t\\tuint256 amountBurned = _amount;\\n\\t\\tuint256 previousBalanceFrom = balanceOfLocalAt(_user, block.number);\\n\\t\\tif (previousBalanceFrom < amountBurned) {\\n\\t\\t\\tamountBurned = previousBalanceFrom;\\n\\t\\t}\\n\\t\\tupdateValueAtNow(totalSupplyHistory, curTotalSupply - amountBurned);\\n\\t\\tupdateValueAtNow(balances[_user], previousBalanceFrom - amountBurned);\\n\\t\\temit Burn(_user, amountBurned);\\n\\t\\treturn amountBurned;\\n\\t}\\n\\n\\tfunction balanceOfLocal(address _owner) public view returns (uint256) {\\n\\t\\treturn balanceOfLocalAt(_owner, block.number);\\n\\t}\\n\\n\\t/// @dev Queries the balance of `_owner` at a specific `_blockNumber`\\n\\t/// @param _owner The address from which the balance will be retrieved\\n\\t/// @param _blockNumber The block number when the balance is queried\\n\\t/// @return The balance at `_blockNumber`\\n\\tfunction balanceOfLocalAt(address _owner, uint256 _blockNumber)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\tvirtual\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\tif (\\n\\t\\t\\t(balances[_owner].length == 0) ||\\n\\t\\t\\t(uint128(balances[_owner][0]) > _blockNumber)\\n\\t\\t) {\\n\\t\\t\\treturn 0;\\n\\t\\t\\t// This will return the expected balance during normal situations\\n\\t\\t} else {\\n\\t\\t\\treturn getValueAt(balances[_owner], _blockNumber);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction totalSupplyLocal() public view virtual returns (uint256) {\\n\\t\\treturn totalSupplyLocalAt(block.number);\\n\\t}\\n\\n\\t/// @notice Total amount of reputation at a specific `_blockNumber`.\\n\\t/// @param _blockNumber The block number when the totalSupply is queried\\n\\t/// @return The total amount of reputation at `_blockNumber`\\n\\tfunction totalSupplyLocalAt(uint256 _blockNumber)\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\tvirtual\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\tif (\\n\\t\\t\\t(totalSupplyHistory.length == 0) ||\\n\\t\\t\\t(uint128(totalSupplyHistory[0]) > _blockNumber)\\n\\t\\t) {\\n\\t\\t\\treturn 0;\\n\\t\\t\\t// This will return the expected totalSupply during normal situations\\n\\t\\t} else {\\n\\t\\t\\treturn getValueAt(totalSupplyHistory, _blockNumber);\\n\\t\\t}\\n\\t}\\n\\n\\t////////////////\\n\\t// Internal helper functions to query and set a value in a snapshot array\\n\\t////////////////\\n\\t/// @dev `getValueAt` retrieves the number of reputation at a given block number\\n\\t/// @param checkpoints The history of values being queried\\n\\t/// @param _block The block number to retrieve the value at\\n\\t/// @return The number of reputation being queried\\n\\tfunction getValueAt(uint256[] storage checkpoints, uint256 _block)\\n\\t\\tinternal\\n\\t\\tview\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\tuint256 len = checkpoints.length;\\n\\t\\tif (len == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\t// Shortcut for the actual value\\n\\t\\tuint256 cur = checkpoints[len - 1];\\n\\t\\tif (_block >= uint128(cur)) {\\n\\t\\t\\treturn cur >> 128;\\n\\t\\t}\\n\\n\\t\\tif (_block < uint128(checkpoints[0])) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\t// Binary search of the value in the array\\n\\t\\tuint256 min = 0;\\n\\t\\tuint256 max = len - 1;\\n\\t\\twhile (max > min) {\\n\\t\\t\\tuint256 mid = (max + min + 1) / 2;\\n\\t\\t\\tif (uint128(checkpoints[mid]) <= _block) {\\n\\t\\t\\t\\tmin = mid;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmax = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn checkpoints[min] >> 128;\\n\\t}\\n\\n\\t/// @dev `updateValueAtNow` used to update the `balances` map and the\\n\\t///  `totalSupplyHistory`\\n\\t/// @param checkpoints The history of data being updated\\n\\t/// @param _value The new number of reputation\\n\\tfunction updateValueAtNow(uint256[] storage checkpoints, uint256 _value)\\n\\t\\tinternal\\n\\t{\\n\\t\\trequire(uint128(_value) == _value, \\\"reputation overflow\\\"); //check value is in the 128 bits bounderies\\n\\t\\tif (\\n\\t\\t\\t(checkpoints.length == 0) ||\\n\\t\\t\\t(uint128(checkpoints[checkpoints.length - 1]) < block.number)\\n\\t\\t) {\\n\\t\\t\\tcheckpoints.push(uint256(uint128(block.number)) | (_value << 128));\\n\\t\\t} else {\\n\\t\\t\\tcheckpoints[checkpoints.length - 1] = uint256(\\n\\t\\t\\t\\t(checkpoints[checkpoints.length - 1] & uint256(ZERO_HALF_256)) |\\n\\t\\t\\t\\t\\t(_value << 128)\\n\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 0\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/staking/UniswapV2SwapHelper.sol\": {\r\n        \"UniswapV2SwapHelper\": \"0x62305662fa7c4bc442803b940d9192dbdc92d710\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iTokenGains\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenGains\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"actualTokenRedeemed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"actualRewardTokenEarned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestCollectedInDAI\",\"type\":\"uint256\"}],\"name\":\"InterestCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"StakeWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avatar\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReputation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"collectUBIInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"actualTokenRedeemed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actualRewardTokenRedeemed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actualDai\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_returnTokenBalanceInUSD\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_returnTokenGainsInUSD\",\"type\":\"bool\"}],\"name\":\"currentGains\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"iTokenGains\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenGains\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceInUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenGainsInUSD\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dao\",\"outputs\":[{\"internalType\":\"contract Controller\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGasCostForInterestTransfer\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getProductivity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRouter\",\"outputs\":[{\"internalType\":\"contract Uniswap\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSettings\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"_collectInterestGasCost\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_compCollectGasCost\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_accAmountPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"_mintedRewards\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_totalProductivity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_totalEffectiveStakes\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_accumulatedRewards\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_lastRewardBlock\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"_maxMultiplierThreshold\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"_tokenDecimalDifference\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"}],\"name\":\"getTokenValueInUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getUserMintedAndPending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardsPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockEnd\",\"type\":\"uint256\"}],\"name\":\"getUserPendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"iToken\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_iToken\",\"type\":\"address\"},{\"internalType\":\"contract INameService\",\"name\":\"_ns\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_tokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint64\",\"name\":\"_maxRewardThreshold\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_tokenUsdOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_compUsdOracle\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokenToDaiSwapPath\",\"type\":\"address[]\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_iToken\",\"type\":\"address\"},{\"internalType\":\"contract INameService\",\"name\":\"_ns\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_tokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint64\",\"name\":\"_maxRewardThreshold\",\"type\":\"uint64\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedUSDValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxLiquidityPercentageSwap\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nameService\",\"outputs\":[{\"internalType\":\"contract INameService\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeToken\",\"outputs\":[{\"internalType\":\"contract IGoodDollar\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isPaused\",\"type\":\"bool\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"recover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardsPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockEnd\",\"type\":\"uint256\"}],\"name\":\"rewardsMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"_maxPercentage\",\"type\":\"uint24\"}],\"name\":\"setMaxLiquidityPercentageSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_collectInterestGasCost\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_rewardTokenCollectCost\",\"type\":\"uint32\"}],\"name\":\"setcollectInterestGasCostParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_donationPer\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_inInterestToken\",\"type\":\"bool\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"tokenWorthIniToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenWorth\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateAvatar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"effectiveStakes\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rewardDebt\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rewardEarn\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rewardMinted\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"lastRewardTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"multiplierResetTime\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_inInterestToken\",\"type\":\"bool\"}],\"name\":\"withdrawStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GoodCompoundStakingV2", "CompilerVersion": "v0.8.8+commit.dddeac2f", "OptimizationUsed": "1", "Runs": "0", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}