{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity 0.8.21;\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ninterface IERC4626 is IERC20, IERC20Metadata {\r\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\r\n\r\n    event Withdraw(\r\n        address indexed sender,\r\n        address indexed receiver,\r\n        address indexed owner,\r\n        uint256 assets,\r\n        uint256 shares\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\r\n     *\r\n     * - MUST be an ERC-20 token contract.\r\n     * - MUST NOT revert.\r\n     */\r\n    function asset() external view returns (address assetTokenAddress);\r\n\r\n    /**\r\n     * @dev Returns the total amount of the underlying asset that is \u201cmanaged\u201d by Vault.\r\n     *\r\n     * - SHOULD include any compounding that occurs from yield.\r\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT revert.\r\n     */\r\n    function totalAssets() external view returns (uint256 totalManagedAssets);\r\n\r\n    /**\r\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\r\n     * scenario where all the conditions are met.\r\n     *\r\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT show any variations depending on the caller.\r\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\r\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\r\n     * from.\r\n     */\r\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\r\n     * scenario where all the conditions are met.\r\n     *\r\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\r\n     * - MUST NOT show any variations depending on the caller.\r\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\r\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\r\n     * from.\r\n     */\r\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\r\n     * through a deposit call.\r\n     *\r\n     * - MUST return a limited value if receiver is subject to some deposit limit.\r\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\r\n     * current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\r\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\r\n     *   in the same transaction.\r\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\r\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\r\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\r\n     */\r\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\r\n     *\r\n     * - MUST emit the Deposit event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   deposit execution, and are accounted for during deposit.\r\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\r\n     *   approving enough underlying tokens to the Vault contract, etc).\r\n     *\r\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\r\n     */\r\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\r\n     * - MUST return a limited value if receiver is subject to some mint limit.\r\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxMint(address receiver) external view returns (uint256 maxShares);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\r\n     * current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\r\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\r\n     *   same transaction.\r\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\r\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\r\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\r\n     */\r\n    function previewMint(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\r\n     *\r\n     * - MUST emit the Deposit event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\r\n     *   execution, and are accounted for during mint.\r\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\r\n     *   approving enough underlying tokens to the Vault contract, etc).\r\n     *\r\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\r\n     */\r\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\r\n     * Vault, through a withdraw call.\r\n     *\r\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\r\n     * given current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\r\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\r\n     *   called\r\n     *   in the same transaction.\r\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\r\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\r\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\r\n     */\r\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\r\n     *\r\n     * - MUST emit the Withdraw event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   withdraw execution, and are accounted for during withdraw.\r\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\r\n     *   not having enough shares, etc).\r\n     *\r\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\r\n     * Those methods should be performed separately.\r\n     */\r\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\r\n\r\n    /**\r\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\r\n     * through a redeem call.\r\n     *\r\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\r\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\r\n     * - MUST NOT revert.\r\n     */\r\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\r\n\r\n    /**\r\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\r\n     * given current on-chain conditions.\r\n     *\r\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\r\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\r\n     *   same transaction.\r\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\r\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\r\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\r\n     * - MUST NOT revert.\r\n     *\r\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\r\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\r\n     */\r\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /**\r\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\r\n     *\r\n     * - MUST emit the Withdraw event.\r\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\r\n     *   redeem execution, and are accounted for during redeem.\r\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\r\n     *   not having enough shares, etc).\r\n     *\r\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\r\n     * Those methods should be performed separately.\r\n     */\r\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\r\n}\r\n\r\ninterface IVault is IERC4626 {\r\n    // STRATEGY EVENTS\r\n    event StrategyChanged(address indexed strategy, uint256 change_type);\r\n    event StrategyReported(\r\n        address indexed strategy,\r\n        uint256 gain,\r\n        uint256 loss,\r\n        uint256 current_debt,\r\n        uint256 protocol_fees,\r\n        uint256 total_fees,\r\n        uint256 total_refunds\r\n    );\r\n    // DEBT MANAGEMENT EVENTS\r\n    event DebtUpdated(\r\n        address indexed strategy,\r\n        uint256 current_debt,\r\n        uint256 new_debt\r\n    );\r\n    // ROLE UPDATES\r\n    event RoleSet(address indexed account, uint256 role);\r\n    event RoleStatusChanged(uint256 role, uint256 status);\r\n    event UpdateRoleManager(address indexed role_manager);\r\n\r\n    event UpdateAccountant(address indexed accountant);\r\n    event UpdateDefaultQueue(address[] new_default_queue);\r\n    event UpdateUseDefaultQueue(bool use_default_queue);\r\n    event UpdatedMaxDebtForStrategy(\r\n        address indexed sender,\r\n        address indexed strategy,\r\n        uint256 new_debt\r\n    );\r\n    event UpdateDepositLimit(uint256 deposit_limit);\r\n    event UpdateMinimumTotalIdle(uint256 minimum_total_idle);\r\n    event UpdateProfitMaxUnlockTime(uint256 profit_max_unlock_time);\r\n    event DebtPurchased(address indexed strategy, uint256 amount);\r\n    event Shutdown();\r\n\r\n    struct StrategyParams {\r\n        uint256 activation;\r\n        uint256 last_report;\r\n        uint256 current_debt;\r\n        uint256 max_debt;\r\n    }\r\n\r\n    function FACTORY() external view returns (uint256);\r\n\r\n    function strategies(address) external view returns (StrategyParams memory);\r\n\r\n    function default_queue(uint256) external view returns (address);\r\n\r\n    function use_default_queue() external view returns (bool);\r\n\r\n    function total_supply() external view returns (uint256);\r\n\r\n    function minimum_total_idle() external view returns (uint256);\r\n\r\n    function deposit_limit() external view returns (uint256);\r\n\r\n    function deposit_limit_module() external view returns (address);\r\n\r\n    function withdraw_limit_module() external view returns (address);\r\n\r\n    function accountant() external view returns (address);\r\n\r\n    function roles(address) external view returns (uint256);\r\n\r\n    function open_roles(uint256) external view returns (bool);\r\n\r\n    function role_manager() external view returns (address);\r\n\r\n    function future_role_manager() external view returns (address);\r\n\r\n    function isShutdown() external view returns (bool);\r\n\r\n    function nonces(address) external view returns (uint256);\r\n\r\n    function set_accountant(address new_accountant) external;\r\n\r\n    function set_default_queue(address[] memory new_default_queue) external;\r\n\r\n    function set_use_default_queue(bool) external;\r\n\r\n    function set_deposit_limit(uint256 deposit_limit) external;\r\n\r\n    function set_deposit_limit_module(\r\n        address new_deposit_limit_module\r\n    ) external;\r\n\r\n    function set_withdraw_limit_module(\r\n        address new_withdraw_limit_module\r\n    ) external;\r\n\r\n    function set_minimum_total_idle(uint256 minimum_total_idle) external;\r\n\r\n    function setProfitMaxUnlockTime(\r\n        uint256 new_profit_max_unlock_time\r\n    ) external;\r\n\r\n    function set_role(address account, uint256 role) external;\r\n\r\n    function add_role(address account, uint256 role) external;\r\n\r\n    function remove_role(address account, uint256 role) external;\r\n\r\n    function set_open_role(uint256 role) external;\r\n\r\n    function close_open_role(uint256 role) external;\r\n\r\n    function transfer_role_manager(address role_manager) external;\r\n\r\n    function accept_role_manager() external;\r\n\r\n    function unlockedShares() external view returns (uint256);\r\n\r\n    function pricePerShare() external view returns (uint256);\r\n\r\n    function get_default_queue() external view returns (address[] memory);\r\n\r\n    function process_report(\r\n        address strategy\r\n    ) external returns (uint256, uint256);\r\n\r\n    function buy_debt(address strategy, uint256 amount) external;\r\n\r\n    function add_strategy(address new_strategy) external;\r\n\r\n    function revoke_strategy(address strategy) external;\r\n\r\n    function force_revoke_strategy(address strategy) external;\r\n\r\n    function update_max_debt_for_strategy(\r\n        address strategy,\r\n        uint256 new_max_debt\r\n    ) external;\r\n\r\n    function update_debt(\r\n        address strategy,\r\n        uint256 target_debt\r\n    ) external returns (uint256);\r\n\r\n    function shutdown_vault() external;\r\n\r\n    function totalIdle() external view returns (uint256);\r\n\r\n    function totalDebt() external view returns (uint256);\r\n\r\n    function apiVersion() external view returns (string memory);\r\n\r\n    function assess_share_of_unrealised_losses(\r\n        address strategy,\r\n        uint256 assets_needed\r\n    ) external view returns (uint256);\r\n\r\n    function profitMaxUnlockTime() external view returns (uint256);\r\n\r\n    function fullProfitUnlockDate() external view returns (uint256);\r\n\r\n    function profitUnlockingRate() external view returns (uint256);\r\n\r\n    function lastProfitUpdate() external view returns (uint256);\r\n\r\n    //// NON-STANDARD ERC-4626 FUNCTIONS \\\\\\\\\r\n\r\n    function withdraw(\r\n        uint256 assets,\r\n        address receiver,\r\n        address owner,\r\n        uint256 max_loss\r\n    ) external returns (uint256);\r\n\r\n    function withdraw(\r\n        uint256 assets,\r\n        address receiver,\r\n        address owner,\r\n        uint256 max_loss,\r\n        address[] memory strategies\r\n    ) external returns (uint256);\r\n\r\n    function redeem(\r\n        uint256 shares,\r\n        address receiver,\r\n        address owner,\r\n        uint256 max_loss\r\n    ) external returns (uint256);\r\n\r\n    function redeem(\r\n        uint256 shares,\r\n        address receiver,\r\n        address owner,\r\n        uint256 max_loss,\r\n        address[] memory strategies\r\n    ) external returns (uint256);\r\n\r\n    function maxWithdraw(\r\n        address owner,\r\n        uint256 max_loss\r\n    ) external view returns (uint256);\r\n\r\n    function maxWithdraw(\r\n        address owner,\r\n        uint256 max_loss,\r\n        address[] memory strategies\r\n    ) external view returns (uint256);\r\n\r\n    function maxRedeem(\r\n        address owner,\r\n        uint256 max_loss\r\n    ) external view returns (uint256);\r\n\r\n    function maxRedeem(\r\n        address owner,\r\n        uint256 max_loss,\r\n        address[] memory strategies\r\n    ) external view returns (uint256);\r\n\r\n    //// NON-STANDARD ERC-20 FUNCTIONS \\\\\\\\\r\n\r\n    function increaseAllowance(\r\n        address spender,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function decreaseAllowance(\r\n        address spender,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IAprOracle {\r\n    function getExpectedApr(\r\n        address _strategy,\r\n        int256 _debtChange\r\n    ) external view returns (uint256);\r\n\r\n    function getUtilizationInfo(\r\n        address _strategy\r\n    ) external view returns (uint256, uint256);\r\n\r\n    function oracles(address _strategy) external view returns (address);\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nlibrary Math {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n     * with further edits by Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\r\n                // The surrounding unchecked block does not change this fact.\r\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            require(denominator > prod1, \"Math: mulDiv overflow\");\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n            // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 twos = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10 ** 64) {\r\n                value /= 10 ** 64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10 ** 32) {\r\n                value /= 10 ** 32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10 ** 16) {\r\n                value /= 10 ** 16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10 ** 8) {\r\n                value /= 10 ** 8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10 ** 4) {\r\n                value /= 10 ** 4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10 ** 2) {\r\n                value /= 10 ** 2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10 ** 1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\r\n        }\r\n    }\r\n}\r\n\r\ncontract DebtManager is ReentrancyGuard, Ownable {\r\n    struct StrategyAllocation {\r\n        address strategy;\r\n        uint256 debt;\r\n    }\r\n\r\n    event AddStrategy(address strategy);\r\n    event RemoveStrategy(address strategy);\r\n    event SetZKVerifier(address zkVerifier);\r\n    event SetOracle(address oracle);\r\n    event SetSiloToStrategy(address indexed silo, address indexed strategy);\r\n    event SetWhitelistedGateway(address indexed gateway, bool enabled);\r\n    event SetUtilizationTargetOfStrategy(address indexed strategy, uint256 target);\r\n    event SetGlobalUtilizationTarget(uint256 target);\r\n    event SetManualAllocator(address allocator);\r\n\r\n    error AG_INVALID_CONFIGURATION();\r\n    error AG_ORACLE_NOT_SET();\r\n    error AG_CALLER_NOT_ADMIN();\r\n    error AG_NOT_AVAILABLE_STRATEGY();\r\n    error AG_NOT_MANUAL_ALLOCATOR();\r\n    error AG_NOT_ZK_VERIFIER();\r\n    error AG_INVALID_STRATEGY();\r\n    error AG_SUPPLY_LIMIT();\r\n    error AG_INSUFFICIENT_ASSETS();\r\n    error AG_HIGHER_DEBT();\r\n\r\n    uint256 private constant UTIL_PREC = 1e5;\r\n    \r\n    IVault public immutable vault;\r\n\r\n    address private _zkVerifier;\r\n    address[] private _strategies;\r\n\r\n    IAprOracle public oracle;\r\n    // silo -> strategy\r\n    mapping(address => address) public siloToStrategy;\r\n    // gateway -> bool\r\n    mapping(address => bool) public whitelistedGateway;\r\n    // strategy -> utilization target, 0 means no target\r\n    mapping(address => uint256) public utilizationTargets;\r\n    // strategy -> bool, if the strategy is added ? true : false\r\n    mapping(address => bool) public strategyAvails;\r\n    // global utilization target, 0 means no target\r\n    uint256 public globalTarget;\r\n    // manual allocator\r\n    address public manualAllocator;\r\n\r\n    constructor(IVault _vault, IAprOracle _oracle) {\r\n        vault = _vault;\r\n        oracle = _oracle;\r\n    }\r\n\r\n    /**\r\n     * @dev Add strategy to list.\r\n     * - Caller is Admin\r\n     * @param _strategy The strategy to manage debt.\r\n     */\r\n    function addStrategy(address _strategy) external payable onlyOwner {\r\n        if (vault.strategies(_strategy).activation == 0) revert AG_INVALID_CONFIGURATION();\r\n        if (oracle.oracles(_strategy) == address(0)) revert AG_ORACLE_NOT_SET();\r\n\r\n        uint256 strategyCount = _strategies.length;\r\n        for (uint256 i; i < strategyCount; ++i) {\r\n            if (_strategies[i] == _strategy) return;\r\n        }\r\n\r\n        _strategies.push(_strategy);\r\n        strategyAvails[_strategy] = true;\r\n\r\n        emit AddStrategy(_strategy);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove strategy from list.\r\n     * - Caller is Anyone\r\n     * @param _strategy The strategy to manage debt.\r\n     */\r\n    function removeStrategy(address _strategy) external {\r\n        if (vault.strategies(_strategy).activation != 0) {\r\n            if (msg.sender != owner()) revert AG_CALLER_NOT_ADMIN();\r\n        }\r\n\r\n        uint256 strategyCount = _strategies.length;\r\n        for (uint256 i; i < strategyCount; ++i) {\r\n            if (_strategies[i] == _strategy) {\r\n                // if not last element\r\n                if (i != strategyCount - 1) {\r\n                    _strategies[i] = _strategies[strategyCount - 1];\r\n                }\r\n                \r\n                _strategies.pop();\r\n                delete utilizationTargets[_strategy];\r\n                delete strategyAvails[_strategy];\r\n\r\n                emit RemoveStrategy(_strategy);\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set the manual allocator address\r\n     * - Caller is Admin\r\n     * @param _manualAllocator The allocator address.\r\n     */\r\n    function setManualAllocator(\r\n        address _manualAllocator\r\n    ) external payable onlyOwner {\r\n        manualAllocator = _manualAllocator;\r\n\r\n        emit SetManualAllocator(_manualAllocator);\r\n    }\r\n\r\n    /**\r\n     * @dev Set the apr oracle contract address.\r\n     * - Caller is Admin\r\n     * @param _oracle The oracle contract address.\r\n     */\r\n    function setOracle(\r\n        IAprOracle _oracle\r\n    ) external payable onlyOwner {\r\n        oracle = _oracle;\r\n\r\n        emit SetOracle(address(_oracle));\r\n    }\r\n\r\n    /**\r\n     * @dev Set the strategy's external silo address.\r\n     * - Caller is Admin\r\n     * @param _silo The external silo address.\r\n     * @param _strategy The strategy address to manage debt.\r\n     */\r\n    function setSiloToStrategy(\r\n        address _silo,\r\n        address _strategy\r\n    ) external payable onlyOwner {\r\n        siloToStrategy[_silo] = _strategy;\r\n\r\n        emit SetSiloToStrategy(_silo, _strategy);\r\n    }\r\n\r\n    /**\r\n     * @dev Set the whitelisted gateway.\r\n     * - Caller is Admin\r\n     * @param _gateway The Silo Gateway address.\r\n     * @param _enabled True if whitelisted gateway, else false.\r\n     */\r\n    function setWhitelistedGateway(\r\n        address _gateway,\r\n        bool _enabled\r\n    ) external payable onlyOwner {\r\n        whitelistedGateway[_gateway] = _enabled;\r\n\r\n        emit SetWhitelistedGateway(_gateway, _enabled);\r\n    }\r\n\r\n    /**\r\n     * @dev Set the strategy's utilization target value.\r\n     * - Caller is Admin\r\n     * @param _strategy The strategy address to manage debt.\r\n     * @param _target The utilization target of strategy.\r\n     */\r\n    function setUtilizationTargetOfStrategy(\r\n        address _strategy,\r\n        uint256 _target\r\n    ) external payable onlyOwner {\r\n        if (_target >= UTIL_PREC) revert AG_INVALID_CONFIGURATION();\r\n        if (!strategyAvails[_strategy]) revert AG_NOT_AVAILABLE_STRATEGY();\r\n\r\n        utilizationTargets[_strategy] = _target;\r\n\r\n        emit SetUtilizationTargetOfStrategy(_strategy, _target);\r\n    }\r\n\r\n    /**\r\n     * @dev Set the global utilization target value.\r\n     * - Caller is Admin\r\n     * @param _target The global utilization target value.\r\n     */\r\n    function setGlobalTarget(\r\n        uint256 _target\r\n    ) external payable onlyOwner {\r\n        if (_target >= UTIL_PREC) revert AG_INVALID_CONFIGURATION();\r\n\r\n        globalTarget = _target;\r\n\r\n        emit SetGlobalUtilizationTarget(_target);\r\n    }\r\n\r\n    /**\r\n     * @dev Set the zero knowledge verifier address.\r\n     * - Caller is Admin\r\n     * @param _verifier The zero knowledge verifier address.\r\n     */\r\n    function setZKVerifier(address _verifier) external payable onlyOwner {\r\n        _zkVerifier = _verifier;\r\n\r\n        emit SetZKVerifier(_verifier);\r\n    }\r\n\r\n    /**\r\n     * @dev Manual update the allocations.\r\n     *      The `_newPositions` list should be in order of decreasing debt and increasing debt.\r\n     * - Caller is Admin\r\n     * @param _newPositions The list of position info\r\n     */\r\n    function manualAllocation(\r\n        StrategyAllocation[] memory _newPositions\r\n    ) external payable {\r\n        if (msg.sender != manualAllocator) revert AG_NOT_MANUAL_ALLOCATOR();\r\n\r\n        _manualAllocation(_newPositions);\r\n    }\r\n\r\n    /**\r\n     * @dev Manual update the allocations from zk verifier.\r\n     *      ZK verifier guarantee newAPR > curAPR and it is optimal allocations as well.\r\n     *      The `_newPositions` list should be in order of decreasing debt and increasing debt.\r\n     * - Caller is ZKVerifier\r\n     * @param _newPositions The list of position info\r\n     */\r\n    function zkAllocation(\r\n        StrategyAllocation[] memory _newPositions\r\n    ) external payable {\r\n        if (msg.sender != _zkVerifier) revert AG_NOT_ZK_VERIFIER();\r\n        if (_strategies.length != _newPositions.length) revert AG_INVALID_CONFIGURATION();\r\n\r\n        _manualAllocation(_newPositions);\r\n    }\r\n\r\n    /**\r\n     * @dev Process the just in time liquidity.\r\n     *      If the sturdy silos have not enough liquidity in case of borrowing,\r\n     *      silos would request liquidity by reducing debts from other strategies.\r\n     * - Caller is Silo Gateways\r\n     * @param _amount The required liquidity amount.\r\n     * @param _silo The silo address.\r\n     - @param _slippage The _slippage percent value.\r\n     */\r\n    function requestLiquidity(uint256 _amount, address _silo, uint256 _slippage) external payable nonReentrant {\r\n        // only whitelisted gateways can request liquidity in case of borrow.\r\n        address requestingStrategy = siloToStrategy[_silo];\r\n\r\n        if (requestingStrategy == address(0)) revert AG_INVALID_STRATEGY();\r\n        if (!whitelistedGateway[msg.sender]) revert AG_INVALID_CONFIGURATION();\r\n\r\n        // update state of requesting strategy and check the supply cap\r\n        IVault.StrategyParams memory requestingStrategyData = vault\r\n            .strategies(requestingStrategy);\r\n        \r\n        uint256 strategyNewDebt = requestingStrategyData.current_debt + _amount;\r\n        if (strategyNewDebt >= requestingStrategyData.max_debt - 1) revert AG_SUPPLY_LIMIT();\r\n\r\n        uint256 minIdle = vault.minimum_total_idle();\r\n\r\n        // global utilization target check.\r\n        {\r\n            uint256 maxSupply = vault.totalAssets() - minIdle;\r\n            uint256 globalUtilizationTarget = globalTarget;\r\n            if (globalUtilizationTarget != 0) {\r\n                maxSupply = maxSupply * globalUtilizationTarget / UTIL_PREC;\r\n            }\r\n            if (strategyNewDebt >= maxSupply) revert AG_SUPPLY_LIMIT();\r\n        }\r\n\r\n        address[] memory strategies = _strategies;\r\n        uint256 totalIdle = vault.totalIdle();\r\n        uint256 requiredAmount = _amount + minIdle;\r\n        uint256 allowedSlippage = _amount * _slippage / UTIL_PREC;\r\n        uint256 strategyCount = strategies.length;\r\n\r\n        if (requiredAmount > totalIdle) {\r\n            unchecked {\r\n                requiredAmount -= totalIdle;\r\n            }\r\n\r\n            (\r\n                uint256[] memory availableAmounts,\r\n                IVault.StrategyParams[] memory strategyDatas\r\n             ) = _getAvailableAmountsAndDatas(strategies, requestingStrategy);\r\n\r\n            // withdraw from other strategies to fill the required amount using selection sort algorithm\r\n            for (uint256 i; i < strategyCount; ++i) {\r\n                // find best candidate which has max available amount\r\n                uint256 maxIndex = i;\r\n                for (uint256 j = i + 1; j < strategyCount; ++j) {\r\n                    if (availableAmounts[j] <= availableAmounts[maxIndex]) continue;\r\n                    \r\n                    maxIndex = j;\r\n                }\r\n\r\n                // swap the position of best candidate\r\n                if (i != maxIndex) {\r\n                    (strategies[i], strategies[maxIndex]) = (strategies[maxIndex], strategies[i]);\r\n                    (availableAmounts[i], availableAmounts[maxIndex]) = (availableAmounts[maxIndex], availableAmounts[i]);\r\n                    (strategyDatas[i], strategyDatas[maxIndex]) = (strategyDatas[maxIndex], strategyDatas[i]);\r\n                }\r\n\r\n                // get withdraw amount\r\n                uint256 withdrawAmount = availableAmounts[i];\r\n                if (withdrawAmount > requiredAmount) {\r\n                    withdrawAmount = requiredAmount;\r\n                }\r\n\r\n                if (withdrawAmount == 0) continue;\r\n\r\n                uint256 newDebt;\r\n                if (strategyDatas[i].current_debt > withdrawAmount) {\r\n                    unchecked {\r\n                        newDebt = strategyDatas[i].current_debt - withdrawAmount;\r\n                    }\r\n                }\r\n\r\n                if (vault.assess_share_of_unrealised_losses(strategies[i], strategyDatas[i].current_debt - newDebt) != 0) {\r\n                    continue;\r\n                }\r\n\r\n                totalIdle = vault.totalIdle();\r\n                vault.update_debt(strategies[i], newDebt);\r\n                unchecked {\r\n                    withdrawAmount = vault.totalIdle() - totalIdle;\r\n                }\r\n\r\n                if (withdrawAmount < requiredAmount) {\r\n                    unchecked {\r\n                        requiredAmount -= withdrawAmount;\r\n                    }\r\n                } else {\r\n                    requiredAmount = 0;\r\n                    break;\r\n                }\r\n\r\n                if (requiredAmount < allowedSlippage) break;\r\n            }\r\n\r\n            if (requiredAmount >= allowedSlippage) revert AG_INSUFFICIENT_ASSETS();\r\n        }\r\n\r\n        // update debt of msg.sender to fill the missing liquidity\r\n        vault.update_debt(\r\n            requestingStrategy,\r\n            strategyNewDebt\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Get the full array of strategies.\r\n     * @return the full array of strategies.\r\n     */\r\n    function getStrategies() external view returns (address[] memory) {\r\n        return _strategies;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the verifier address.\r\n     * @return the verifier address.\r\n     */\r\n    function getZKVerifier() external view returns (address) {\r\n        return _zkVerifier;\r\n    }\r\n\r\n    function _manualAllocation(\r\n        StrategyAllocation[] memory _newPositions\r\n    ) internal {\r\n        unchecked {\r\n            uint256 strategyLength = _newPositions.length;\r\n\r\n            for (uint256 i; i < strategyLength; ++i) {\r\n                StrategyAllocation memory position = _newPositions[i];\r\n                if (!strategyAvails[position.strategy]) revert AG_NOT_AVAILABLE_STRATEGY();\r\n\r\n                IVault.StrategyParams memory strategyData = vault.strategies(\r\n                    position.strategy\r\n                );\r\n\r\n                if (strategyData.activation == 0) revert AG_NOT_AVAILABLE_STRATEGY();\r\n\r\n                if (strategyData.current_debt == position.debt) continue;\r\n\r\n                if (position.debt > strategyData.max_debt) revert AG_HIGHER_DEBT();\r\n\r\n                // deposit/increase not possible because minimum total idle reached\r\n                if (position.debt > strategyData.current_debt && \r\n                    vault.totalIdle() <= vault.minimum_total_idle()) continue;\r\n\r\n                if (\r\n                    strategyData.current_debt > position.debt && \r\n                    vault.assess_share_of_unrealised_losses(position.strategy, strategyData.current_debt - position.debt) != 0\r\n                ) {\r\n                    vault.process_report(position.strategy);\r\n                }\r\n\r\n                // update debt.\r\n                vault.update_debt(position.strategy, position.debt);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _getAvailableAmountsAndDatas(\r\n        address[] memory _availableStrategies, \r\n        address _requestingStrategy\r\n    ) internal returns (uint256[] memory, IVault.StrategyParams[] memory) {\r\n        IAprOracle _oracle = oracle;\r\n        uint256 strategyCount = _availableStrategies.length;\r\n        uint256[] memory amounts = new uint256[](strategyCount);\r\n        IVault.StrategyParams[] memory strategyDatas = new IVault.StrategyParams[](strategyCount);\r\n\r\n        for (uint256 i; i < strategyCount; ++i) {\r\n            address strategy = _availableStrategies[i];\r\n            if (strategy == _requestingStrategy) continue;\r\n\r\n            strategyDatas[i] = vault.strategies(strategy);\r\n            if (strategyDatas[i].current_debt == 0) continue;\r\n\r\n            uint256 strategyUtilizationTarget = utilizationTargets[strategy];\r\n            \r\n            // 0 means no target.\r\n            if (strategyUtilizationTarget == 0) strategyUtilizationTarget = UTIL_PREC;\r\n\r\n            (uint256 borrows, uint256 supply) = _oracle.getUtilizationInfo(strategy);\r\n            \r\n            // if current utilization value is over the target, can't withdraw.\r\n            if (borrows * UTIL_PREC / supply > strategyUtilizationTarget) continue;\r\n\r\n            // get withdrawable amount from strategy\r\n            amounts[i] = Math.min(\r\n                supply - borrows * UTIL_PREC / strategyUtilizationTarget,\r\n                strategyDatas[i].current_debt\r\n            );\r\n        }\r\n\r\n        return (amounts, strategyDatas);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IVault\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"contract IAprOracle\",\"name\":\"_oracle\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AG_CALLER_NOT_ADMIN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AG_HIGHER_DEBT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AG_INSUFFICIENT_ASSETS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AG_INVALID_CONFIGURATION\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AG_INVALID_STRATEGY\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AG_NOT_AVAILABLE_STRATEGY\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AG_NOT_MANUAL_ALLOCATOR\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AG_NOT_ZK_VERIFIER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AG_ORACLE_NOT_SET\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AG_SUPPLY_LIMIT\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"AddStrategy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"RemoveStrategy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"}],\"name\":\"SetGlobalUtilizationTarget\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"allocator\",\"type\":\"address\"}],\"name\":\"SetManualAllocator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"SetOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"silo\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"SetSiloToStrategy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"}],\"name\":\"SetUtilizationTargetOfStrategy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gateway\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SetWhitelistedGateway\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"zkVerifier\",\"type\":\"address\"}],\"name\":\"SetZKVerifier\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"addStrategy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStrategies\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getZKVerifier\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalTarget\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"}],\"internalType\":\"struct DebtManager.StrategyAllocation[]\",\"name\":\"_newPositions\",\"type\":\"tuple[]\"}],\"name\":\"manualAllocation\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualAllocator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"contract IAprOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"removeStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_silo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"}],\"name\":\"requestLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_target\",\"type\":\"uint256\"}],\"name\":\"setGlobalTarget\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manualAllocator\",\"type\":\"address\"}],\"name\":\"setManualAllocator\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAprOracle\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_silo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"setSiloToStrategy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_target\",\"type\":\"uint256\"}],\"name\":\"setUtilizationTargetOfStrategy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gateway\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setWhitelistedGateway\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_verifier\",\"type\":\"address\"}],\"name\":\"setZKVerifier\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"siloToStrategy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"strategyAvails\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"utilizationTargets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract IVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedGateway\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"}],\"internalType\":\"struct DebtManager.StrategyAllocation[]\",\"name\":\"_newPositions\",\"type\":\"tuple[]\"}],\"name\":\"zkAllocation\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "DebtManager", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000073e4c11b670ef9c025a030a20b72cb9150e54523000000000000000000000000f7be7370005896c720c2a84da870e041acf41a4d", "EVMVersion": "paris", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bc9e1ba50e6e86f74aeb90dd4e6cddd1e8bd6e57278bc7083853b5f1bf29adaf"}