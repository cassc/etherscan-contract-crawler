{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/ProxyAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"./DakanPassProxy.sol\\\";\\n\\n\\ncontract ProxyAdmin {\\n    address private _owner;\\n    mapping(address => address) internal _implementation;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    event ImplementationChanged(address indexed proxy, address indexed previousImplementation, address indexed newImplementation);\\n\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"ProxyAdmin: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    constructor() {\\n        _setOwner(msg.sender);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    function getProxyAdmin(address proxy) external view returns (address) {\\n        (bool ok, bytes memory res) = proxy.staticcall(abi.encodeCall(IDakanPassProxy.admin, ()));\\n        require(ok, \\\"call failed\\\");\\n        return abi.decode(res, (address));\\n    }\\n\\n    function getProxyImplementation(address proxy) external view returns (address) {\\n        (bool ok, bytes memory res) = proxy.staticcall(abi.encodeCall(IDakanPassProxy.implementation, ()));\\n        require(ok, \\\"call failed\\\");\\n        return abi.decode(res, (address));\\n    }\\n\\n\\n    function changeProxyImplementation(address proxy, address newImplementation) public onlyOwner {\\n        IDakanPassProxy(proxy).upgradeTo(newImplementation);\\n        //_setProxyImplementation(proxy, newImplementation);\\n    }\\n\\n    function changeProxyAdmin(address payable proxy, address admin) external onlyOwner {\\n        IDakanPassProxy(proxy).changeAdmin(admin);\\n    }\\n\\n    function upgrade(address payable proxy, address implementation) external onlyOwner {\\n        IDakanPassProxy(proxy).upgradeTo(implementation);\\n    }\\n\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0), \\\"ProxyAdmin: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        _owner = newOwner;\\n    }\\n\\n    /*function _setProxyImplementation(address proxy, address newImplementation) private {\\n        address previousImplementation = _implementation[proxy];\\n        _implementation[proxy] = newImplementation;\\n        emit ImplementationChanged(proxy, previousImplementation, newImplementation);\\n    }*/\\n\\n    function isOwner() private view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/DakanPassProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.19;\\n\\n\\nimport { StorageSlotUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\\\";\\n\\n\\ninterface IDakanPassProxy {\\n    function upgradeTo(address newImplementation) external;\\n    function implementation() external returns (address);\\n    function admin() external returns (address);\\n    function changeAdmin(address _admin) external;\\n}\\n\\ncontract DakanPassProxy {\\n\\n    bytes32 private constant IMPLEMENTATION_SLOT =\\n        bytes32(uint(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1);\\n    bytes32 private constant ADMIN_SLOT =\\n        bytes32(uint(keccak256(\\\"eip1967.proxy.admin\\\")) - 1);\\n    \\n    constructor() {\\n        _setAdmin(msg.sender);\\n    }\\n\\n    modifier ifAdmin() {\\n        if (msg.sender == _getAdmin()) {\\n            _;\\n        } else {\\n            _fallback();\\n        }\\n    }\\n\\n    function _getAdmin() private view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(ADMIN_SLOT).value;\\n    }\\n\\n    function _setAdmin(address _admin) private {\\n        require(_admin != address(0), \\\"admin = zero address\\\");\\n        StorageSlotUpgradeable.getAddressSlot(ADMIN_SLOT).value = _admin;\\n    }\\n\\n    function _getImplementation() private view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    function _setImplementation(address _implementation) private {\\n        require(_implementation.code.length > 0, \\\"implementation is not contract\\\");\\n        StorageSlotUpgradeable.getAddressSlot(IMPLEMENTATION_SLOT).value = _implementation;\\n    }\\n\\n    function changeAdmin(address _admin) external ifAdmin {\\n        _setAdmin(_admin);\\n    }\\n\\n    function upgradeTo(address newImplementation) external ifAdmin {\\n        _setImplementation(newImplementation);\\n    }\\n\\n    function _delegate(address _implementation) internal virtual {\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n            let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            switch result\\n            case 0 { revert(0, returndatasize()) }\\n            default { return(0, returndatasize()) }\\n        }\\n    }\\n\\n\\n    function admin() external ifAdmin returns (address) {\\n        return _getAdmin();\\n    }\\n\\n\\n    function implementation() external ifAdmin returns (address) {\\n        return _getImplementation();\\n    }\\n\\n    function _fallback() private {\\n        _delegate(_getImplementation());\\n    }\\n\\n    fallback() external payable {\\n        _fallback();\\n    }\\n\\n    receive() external payable {\\n        _fallback();\\n    }\\n}\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/StorageSlotUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ERC721A-Upgradeable/=lib/ERC721A-Upgradeable/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"closedsea/=lib/closedsea/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\r\n      \"erc721a-upgradeable/=lib/closedsea/lib/erc721a-upgradeable/contracts/\",\r\n      \"erc721a/=lib/closedsea/lib/erc721a/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/closedsea/lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"operator-filter-registry/=lib/closedsea/lib/operator-filter-registry/\",\r\n      \"solady/=lib/closedsea/lib/solady/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousImplementation\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"ImplementationChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"changeProxyAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"changeProxyImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"getProxyAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"getProxyImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ProxyAdmin", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}