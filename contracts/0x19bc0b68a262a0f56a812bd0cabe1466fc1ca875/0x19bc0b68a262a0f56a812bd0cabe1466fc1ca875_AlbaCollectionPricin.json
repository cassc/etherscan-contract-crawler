{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/libraries/Pricing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.20;\\n\\nimport {SaleType, SaleConfig} from \\\"../Types.sol\\\";\\nimport {Math} from \\\"./Math.sol\\\";\\n\\nlibrary AlbaCollectionPricing {\\n    /**\\n     * @notice Returns the current price of the sale.\\n     * @dev Wrapper for different pricing strategies based on sale type.\\n     */\\n    function getPrice(SaleConfig storage saleConfig) public view returns (uint256) {\\n        if (saleConfig.saleType == SaleType.FixedPrice || saleConfig.saleType == SaleType.FixedPriceTimeLimited) {\\n            return saleConfig.initialPrice;\\n        }\\n        if (block.timestamp <= saleConfig.startTime) {\\n            return saleConfig.initialPrice;\\n        }\\n        if (saleConfig.saleType == SaleType.ExponentialDutchAuction) {\\n            return _getPriceExponentialDA(saleConfig);\\n        }\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice Returns the current price of the sale using a continuous dutch auction pricing strategy.\\n     * @dev This works by computing the time elapsed since the start of the auction, and then interpolating\\n     * the price based on the initial price and the final price. The interpolation is linear.\\n     */\\n    function _getPriceExponentialDA(SaleConfig storage saleConfig) internal view returns (uint256) {\\n        if (block.timestamp >= saleConfig.auctionEndTime) {\\n            return saleConfig.finalPrice;\\n        }\\n\\n        uint256 timeElapsed = block.timestamp - saleConfig.startTime;\\n        uint40 totalDuration = saleConfig.auctionEndTime - saleConfig.startTime;\\n\\n        // This choice guarantees that `elapsed/tau < 5` meaning that the approximant is applicable (with rel error < 1%)\\n        // and that the price difference has sufficiently decayed (to <0.007) at the end of the auction.\\n        uint40 tau = totalDuration / 5;\\n\\n        (uint256 expNumerator, uint256 expDenominator) =\\n            Math.expPadeApprox5(int48(int256(timeElapsed)), -int48(uint48(tau)));\\n\\n        uint256 priceDifference = saleConfig.initialPrice - saleConfig.finalPrice;\\n        return saleConfig.finalPrice + (priceDifference * expNumerator) / expDenominator;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.13;\\n\\nstruct CollectionConfig {\\n    bytes16 uuid;\\n    string name;\\n    string token;\\n    string slug;\\n    bytes16[] dependencies;\\n    string[] metadataKeys;\\n    string[] metadataValues;\\n}\\n\\nenum SaleType {\\n    FixedPrice,\\n    DeprecatedReserved,\\n    ExponentialDutchAuction,\\n    FixedPriceTimeLimited\\n}\\n\\nstruct SaleConfig {\\n    SaleType saleType; // uint8 for packing\\n    uint32 maxSalePieces; // Maximum number of pieces to sell (including reserves)\\n    uint32 numReserved; // Number of pieces to reserve for specific wallets\\n    uint16 numRetained; // Number of pieces to retain for the artist\\n    uint16 numAlba; // Number of pieces to retain for Alba\\n    uint40 startTime; // Sale start time\\n    uint40 auctionEndTime; // Sale doesn't stop here, but price decay stops. Needed for rebate if non-sellout.\\n    bool hasRebate; // Whether or not to give a rebate to resting price\\n    uint256 initialPrice; // Starting price for Dutch Auction\\n    uint256 finalPrice; // Ending price for Dutch Auction\\n}\\n\\nstruct PaymentConfig {\\n    address[] primaryPayees; // Addresses for primary payment.\\n    uint256[] primaryShareBasisPoints; // Share of primary sales for each address (basis points).\\n    address[] secondaryPayees; // Addresses for secondary payment.\\n    uint256[] secondaryShareBasisPoints; // Share of secondary sales for each address (basis points).\\n    uint16 royaltyBasisPoints; // Total royalty basis points.\\n}\\n\\nstruct StoredScript {\\n    string fileName;\\n    uint256 wrappedLength;\\n}\\n\"\r\n    },\r\n    \"src/libraries/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.20;\\n\\nlibrary Math {\\n    // Coefficients for the expanded Pade approximant of the exponential function exp(x/y).\\n    uint16 private constant EXP_PADE_5_COEFF_X0_Y5 = 30240;\\n    uint16 private constant EXP_PADE_5_COEFF_X1_Y4 = 15120;\\n    uint16 private constant EXP_PADE_5_COEFF_X2_Y3 = 3360;\\n    uint16 private constant EXP_PADE_5_COEFF_X3_Y2 = 420;\\n    uint16 private constant EXP_PADE_5_COEFF_X4_Y1 = 30;\\n    uint16 private constant EXP_PADE_5_COEFF_X5_Y0 = 1;\\n\\n    /// @notice Expanded Pade approximant of order 5 of the exponential function `exp(x/y)`.\\n    /// @dev The pade approximant is given by (latex notation): `\\\\frac{\\\\frac{x^5}{30240 y^5}+\\\\frac{x^4}{1008 y^4}+\\\\frac{x^3}{72 y^3}+\\\\frac{x^2}{9 y^2}+\\\\frac{x}{2 y}+1}{-\\\\frac{x^5}{30240 y^5}+\\\\frac{x^4}{1008 y^4}-\\\\frac{x^3}{72 y^3}+\\\\frac{x^2}{9 y^2}-\\\\frac{x}{2 y}+1}`\\n    /// @dev Both the numerator and the denominator were expanded (i.e. multiplied by `30240 y^5`) to obtain integer coefficients and avoid truncation errors in the divisions.\\n    /// @dev See also https://www.wolframalpha.com/input?i=PadeApproximant%5BExp%5Bx%2Fy%5D%2C+%7Bx%2C+0%2C+5%7D%5D\\n    /// @dev The relative accuracy is <1% for `x/y <= 5`.\\n    /// @dev The input types are limited to 48 bits to avoid overflow in the powers (max power `x^5` hence takes 240 bits)\\n    /// @param x The numerator of the exponent.\\n    /// @param y The denominator of the exponent.\\n    /// @return a The numerator of the result.\\n    /// @return b The denominator of the result.\\n    function expPadeApprox5(int48 x, int48 y) internal pure returns (uint256, uint256) {\\n        int256 a = 0;\\n        int256 b = 0;\\n\\n        assembly {\\n            let xyPowers := exp(y, 5)\\n            let c := 0\\n\\n            c := mul(EXP_PADE_5_COEFF_X0_Y5, xyPowers)\\n            a := add(a, c)\\n            b := add(b, c)\\n\\n            xyPowers := sdiv(mul(xyPowers, x), y)\\n            c := mul(EXP_PADE_5_COEFF_X1_Y4, xyPowers)\\n            a := add(a, c)\\n            b := sub(b, c)\\n\\n            xyPowers := sdiv(mul(xyPowers, x), y)\\n            c := mul(EXP_PADE_5_COEFF_X2_Y3, xyPowers)\\n            a := add(a, c)\\n            b := add(b, c)\\n\\n            xyPowers := sdiv(mul(xyPowers, x), y)\\n            c := mul(EXP_PADE_5_COEFF_X3_Y2, xyPowers)\\n            a := add(a, c)\\n            b := sub(b, c)\\n\\n            xyPowers := sdiv(mul(xyPowers, x), y)\\n            c := mul(EXP_PADE_5_COEFF_X4_Y1, xyPowers)\\n            a := add(a, c)\\n            b := add(b, c)\\n\\n            xyPowers := sdiv(mul(xyPowers, x), y)\\n            c := mul(EXP_PADE_5_COEFF_X5_Y0, xyPowers)\\n            a := add(a, c)\\n            b := sub(b, c)\\n        }\\n\\n        if (b < 0) {\\n            a = -a;\\n            b = -b;\\n        }\\n\\n        return (uint256(a), uint256(b));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[]", "ContractName": "AlbaCollectionPricing", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}