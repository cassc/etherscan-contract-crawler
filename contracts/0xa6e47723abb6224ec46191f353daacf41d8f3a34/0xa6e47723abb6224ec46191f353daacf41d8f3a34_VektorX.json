{"SourceCode": "//SPDX-License-Identifier: Unlicense\r\n\r\npragma solidity ^0.8.11;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ninterface IERC721A {\r\n\r\n    error ApprovalCallerNotOwnerNorApproved();\r\n\r\n    error ApprovalQueryForNonexistentToken();\r\n\r\n    error ApproveToCaller();\r\n\r\n    error ApprovalToCurrentOwner();\r\n\r\n    error BalanceQueryForZeroAddress();\r\n\r\n    error MintToZeroAddress();\r\n\r\n    error MintZeroQuantity();\r\n\r\n    error OwnerQueryForNonexistentToken();\r\n\r\n    error TransferCallerNotOwnerNorApproved();\r\n\r\n    error TransferFromIncorrectOwner();\r\n\r\n    error TransferToNonERC721ReceiverImplementer();\r\n\r\n    error TransferToZeroAddress();\r\n\r\n    error URIQueryForNonexistentToken();\r\n\r\n    struct TokenOwnership {\r\n        // The address of the owner.\r\n        address addr;\r\n        uint64 startTimestamp;    \r\n        bool burned;\r\n    }\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\ninterface ERC721A__IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\ncontract ERC721A is IERC721A {\r\n    // Mask of an entry in packed address data.\r\n    uint256 private constant BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\r\n\r\n    uint256 private constant BITPOS_NUMBER_MINTED = 64;\r\n\r\n    uint256 private constant BITPOS_NUMBER_BURNED = 128;\r\n\r\n    uint256 private constant BITPOS_AUX = 192;\r\n\r\n    uint256 private constant BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\r\n\r\n    uint256 private constant BITPOS_START_TIMESTAMP = 160;\r\n\r\n    uint256 private constant BITMASK_BURNED = 1 << 224;\r\n    \r\n    uint256 private constant BITPOS_NEXT_INITIALIZED = 225;\r\n\r\n    uint256 private constant BITMASK_NEXT_INITIALIZED = 1 << 225;\r\n\r\n    uint256 private _currentIndex;\r\n\r\n    uint256 private _burnCounter;\r\n\r\n    string private _name;\r\n\r\n    string private _symbol;\r\n\r\n    mapping(uint256 => uint256) private _packedOwnerships;\r\n\r\n    mapping(address => uint256) private _packedAddressData;\r\n\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _currentIndex = _startTokenId();\r\n    }\r\n\r\n    function _startTokenId() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    function _nextTokenId() internal view returns (uint256) {\r\n        return _currentIndex;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n\r\n        unchecked {\r\n            return _currentIndex - _burnCounter - _startTokenId();\r\n        }\r\n    }\r\n\r\n    function _totalMinted() internal view returns (uint256) {\r\n\r\n        unchecked {\r\n            return _currentIndex - _startTokenId();\r\n        }\r\n    }\r\n\r\n    function _totalBurned() internal view returns (uint256) {\r\n        return _burnCounter;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n\r\n        return\r\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\r\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\r\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\r\n    }\r\n\r\n    function balanceOf(address owner) public view override returns (uint256) {\r\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\r\n        return _packedAddressData[owner] & BITMASK_ADDRESS_DATA_ENTRY;\r\n    }\r\n\r\n    function _numberMinted(address owner) internal view returns (uint256) {\r\n        return (_packedAddressData[owner] >> BITPOS_NUMBER_MINTED) & BITMASK_ADDRESS_DATA_ENTRY;\r\n    }\r\n\r\n    function _numberBurned(address owner) internal view returns (uint256) {\r\n        return (_packedAddressData[owner] >> BITPOS_NUMBER_BURNED) & BITMASK_ADDRESS_DATA_ENTRY;\r\n    }\r\n\r\n    function _getAux(address owner) internal view returns (uint64) {\r\n        return uint64(_packedAddressData[owner] >> BITPOS_AUX);\r\n    }\r\n\r\n    function _setAux(address owner, uint64 aux) internal {\r\n        uint256 packed = _packedAddressData[owner];\r\n        uint256 auxCasted;\r\n        assembly { // Cast aux without masking.\r\n            auxCasted := aux\r\n        }\r\n        packed = (packed & BITMASK_AUX_COMPLEMENT) | (auxCasted << BITPOS_AUX);\r\n        _packedAddressData[owner] = packed;\r\n    }\r\n\r\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\r\n        uint256 curr = tokenId;\r\n\r\n        unchecked {\r\n            if (_startTokenId() <= curr)\r\n                if (curr < _currentIndex) {\r\n                    uint256 packed = _packedOwnerships[curr];\r\n                    // If not burned.\r\n                    if (packed & BITMASK_BURNED == 0) {\r\n \r\n                        while (packed == 0) {\r\n                            packed = _packedOwnerships[--curr];\r\n                        }\r\n                        return packed;\r\n                    }\r\n                }\r\n        }\r\n        revert OwnerQueryForNonexistentToken();\r\n    }\r\n\r\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\r\n        ownership.addr = address(uint160(packed));\r\n        ownership.startTimestamp = uint64(packed >> BITPOS_START_TIMESTAMP);\r\n        ownership.burned = packed & BITMASK_BURNED != 0;\r\n    }\r\n\r\n    function _ownershipAt(uint256 index) internal view returns (TokenOwnership memory) {\r\n        return _unpackedOwnership(_packedOwnerships[index]);\r\n    }\r\n\r\n    function _initializeOwnershipAt(uint256 index) internal {\r\n        if (_packedOwnerships[index] == 0) {\r\n            _packedOwnerships[index] = _packedOwnershipOf(index);\r\n        }\r\n    }\r\n\r\n    function _ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {\r\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId) public view override returns (address) {\r\n        return address(uint160(_packedOwnershipOf(tokenId)));\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\r\n\r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\r\n    }\r\n \r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return '';\r\n    }\r\n\r\n    function _addressToUint256(address value) private pure returns (uint256 result) {\r\n        assembly {\r\n            result := value\r\n        }\r\n    }\r\n\r\n    function _boolToUint256(bool value) private pure returns (uint256 result) {\r\n        assembly {\r\n            result := value\r\n        }\r\n    }\r\n\r\n    function approve(address to, uint256 tokenId) public override {\r\n        address owner = address(uint160(_packedOwnershipOf(tokenId)));\r\n        if (to == owner) revert ApprovalToCurrentOwner();\r\n\r\n        if (_msgSenderERC721A() != owner)\r\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\r\n                revert ApprovalCallerNotOwnerNorApproved();\r\n            }\r\n\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    function getApproved(uint256 tokenId) public view override returns (address) {\r\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        if (operator == _msgSenderERC721A()) revert ApproveToCaller();\r\n\r\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\r\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, '');\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public virtual override {\r\n        _transfer(from, to, tokenId);\r\n        if (to.code.length != 0)\r\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\r\n                revert TransferToNonERC721ReceiverImplementer();\r\n            }\r\n    }\r\n\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        return\r\n            _startTokenId() <= tokenId &&\r\n            tokenId < _currentIndex && // If within bounds,\r\n            _packedOwnerships[tokenId] & BITMASK_BURNED == 0; // and not burned.\r\n    }\r\n\r\n    function _safeMint(address to, uint256 quantity) internal {\r\n        _safeMint(to, quantity, '');\r\n    }\r\n\r\n    function _safeMint(\r\n        address to,\r\n        uint256 quantity,\r\n        bytes memory _data\r\n    ) internal {\r\n        uint256 startTokenId = _currentIndex;\r\n        if (to == address(0)) revert MintToZeroAddress();\r\n        if (quantity == 0) revert MintZeroQuantity();\r\n\r\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\r\n\r\n        unchecked {\r\n\r\n            _packedAddressData[to] += quantity * ((1 << BITPOS_NUMBER_MINTED) | 1);\r\n\r\n            _packedOwnerships[startTokenId] =\r\n                _addressToUint256(to) |\r\n                (block.timestamp << BITPOS_START_TIMESTAMP) |\r\n                (_boolToUint256(quantity == 1) << BITPOS_NEXT_INITIALIZED);\r\n\r\n            uint256 updatedIndex = startTokenId;\r\n            uint256 end = updatedIndex + quantity;\r\n\r\n            if (to.code.length != 0) {\r\n                do {\r\n                    emit Transfer(address(0), to, updatedIndex);\r\n                    if (!_checkContractOnERC721Received(address(0), to, updatedIndex++, _data)) {\r\n                        revert TransferToNonERC721ReceiverImplementer();\r\n                    }\r\n                } while (updatedIndex < end);\r\n                // Reentrancy protection\r\n                if (_currentIndex != startTokenId) revert();\r\n            } else {\r\n                do {\r\n                    emit Transfer(address(0), to, updatedIndex++);\r\n                } while (updatedIndex < end);\r\n            }\r\n            _currentIndex = updatedIndex;\r\n        }\r\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\r\n    }\r\n\r\n    function _mint(address to, uint256 quantity) internal {\r\n        uint256 startTokenId = _currentIndex;\r\n        if (to == address(0)) revert MintToZeroAddress();\r\n        if (quantity == 0) revert MintZeroQuantity();\r\n\r\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\r\n\r\n        unchecked {\r\n\r\n            _packedAddressData[to] += quantity * ((1 << BITPOS_NUMBER_MINTED) | 1);\r\n\r\n            _packedOwnerships[startTokenId] =\r\n                _addressToUint256(to) |\r\n                (block.timestamp << BITPOS_START_TIMESTAMP) |\r\n                (_boolToUint256(quantity == 1) << BITPOS_NEXT_INITIALIZED);\r\n\r\n            uint256 updatedIndex = startTokenId;\r\n            uint256 end = updatedIndex + quantity;\r\n\r\n            do {\r\n                emit Transfer(address(0), to, updatedIndex++);\r\n            } while (updatedIndex < end);\r\n\r\n            _currentIndex = updatedIndex;\r\n        }\r\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) private {\r\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\r\n\r\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\r\n\r\n        bool isApprovedOrOwner = (_msgSenderERC721A() == from ||\r\n            isApprovedForAll(from, _msgSenderERC721A()) ||\r\n            getApproved(tokenId) == _msgSenderERC721A());\r\n\r\n        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\r\n        if (to == address(0)) revert TransferToZeroAddress();\r\n\r\n        _beforeTokenTransfers(from, to, tokenId, 1);\r\n\r\n        delete _tokenApprovals[tokenId];\r\n\r\n        unchecked {\r\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\r\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\r\n\r\n            _packedOwnerships[tokenId] =\r\n                _addressToUint256(to) |\r\n                (block.timestamp << BITPOS_START_TIMESTAMP) |\r\n                BITMASK_NEXT_INITIALIZED;\r\n            \r\n            if (prevOwnershipPacked & BITMASK_NEXT_INITIALIZED == 0) {\r\n                uint256 nextTokenId = tokenId + 1;                \r\n                if (_packedOwnerships[nextTokenId] == 0) {                    \r\n                    if (nextTokenId != _currentIndex) {\r\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, to, tokenId);\r\n        _afterTokenTransfers(from, to, tokenId, 1);\r\n    }\r\n\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        _burn(tokenId, false);\r\n    }\r\n\r\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\r\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\r\n\r\n        address from = address(uint160(prevOwnershipPacked));\r\n\r\n        if (approvalCheck) {\r\n            bool isApprovedOrOwner = (_msgSenderERC721A() == from ||\r\n                isApprovedForAll(from, _msgSenderERC721A()) ||\r\n                getApproved(tokenId) == _msgSenderERC721A());\r\n\r\n            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\r\n        }\r\n\r\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\r\n\r\n        delete _tokenApprovals[tokenId];\r\n\r\n        unchecked {\r\n\r\n            _packedAddressData[from] += (1 << BITPOS_NUMBER_BURNED) - 1;\r\n\r\n            _packedOwnerships[tokenId] =\r\n                _addressToUint256(from) |\r\n                (block.timestamp << BITPOS_START_TIMESTAMP) |\r\n                BITMASK_BURNED | \r\n                BITMASK_NEXT_INITIALIZED;\r\n\r\n            if (prevOwnershipPacked & BITMASK_NEXT_INITIALIZED == 0) {\r\n                uint256 nextTokenId = tokenId + 1;\r\n                if (_packedOwnerships[nextTokenId] == 0) {\r\n                    if (nextTokenId != _currentIndex) {\r\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, address(0), tokenId);\r\n        _afterTokenTransfers(from, address(0), tokenId, 1);\r\n\r\n        unchecked {\r\n            _burnCounter++;\r\n        }\r\n    }\r\n\r\n    function _checkContractOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\r\n            bytes4 retval\r\n        ) {\r\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\r\n        } catch (bytes memory reason) {\r\n            if (reason.length == 0) {\r\n                revert TransferToNonERC721ReceiverImplementer();\r\n            } else {\r\n                assembly {\r\n                    revert(add(32, reason), mload(reason))\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _beforeTokenTransfers(\r\n        address from,\r\n        address to,\r\n        uint256 startTokenId,\r\n        uint256 quantity\r\n    ) internal virtual {}\r\n\r\n    function _afterTokenTransfers(\r\n        address from,\r\n        address to,\r\n        uint256 startTokenId,\r\n        uint256 quantity\r\n    ) internal virtual {}\r\n\r\n    function _msgSenderERC721A() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _toString(uint256 value) internal pure returns (string memory ptr) {\r\n        assembly {\r\n\r\n            ptr := add(mload(0x40), 128)\r\n\r\n            mstore(0x40, ptr)\r\n\r\n            let end := ptr\r\n\r\n            for { \r\n                let temp := value\r\n                ptr := sub(ptr, 1)\r\n                mstore8(ptr, add(48, mod(temp, 10)))\r\n                temp := div(temp, 10)\r\n            } temp { \r\n                temp := div(temp, 10)\r\n            } { // Body of the for loop.\r\n                ptr := sub(ptr, 1)\r\n                mstore8(ptr, add(48, mod(temp, 10)))\r\n            }\r\n            \r\n            let length := sub(end, ptr)\r\n            ptr := sub(ptr, 32)\r\n            mstore(ptr, length)\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC721ABurnable is IERC721A {\r\n\r\n    function burn(uint256 tokenId) external;\r\n}\r\n\r\nabstract contract ERC721ABurnable is ERC721A, IERC721ABurnable {\r\n\r\n    function burn(uint256 tokenId) public virtual override {\r\n        _burn(tokenId, true);\r\n    }\r\n}\r\n\r\ninterface IERC721AQueryable is IERC721A {\r\n\r\n    error InvalidQueryRange();\r\n\r\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\r\n\r\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\r\n\r\n    function tokensOfOwnerIn(\r\n        address owner,\r\n        uint256 start,\r\n        uint256 stop\r\n    ) external view returns (uint256[] memory);\r\n\r\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\r\n}\r\n\r\nabstract contract ERC721AQueryable is ERC721A, IERC721AQueryable {\r\n\r\n    function explicitOwnershipOf(uint256 tokenId) public view override returns (TokenOwnership memory) {\r\n        TokenOwnership memory ownership;\r\n        if (tokenId < _startTokenId() || tokenId >= _nextTokenId()) {\r\n            return ownership;\r\n        }\r\n        ownership = _ownershipAt(tokenId);\r\n        if (ownership.burned) {\r\n            return ownership;\r\n        }\r\n        return _ownershipOf(tokenId);\r\n    }\r\n\r\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view override returns (TokenOwnership[] memory) {\r\n        unchecked {\r\n            uint256 tokenIdsLength = tokenIds.length;\r\n            TokenOwnership[] memory ownerships = new TokenOwnership[](tokenIdsLength);\r\n            for (uint256 i; i != tokenIdsLength; ++i) {\r\n                ownerships[i] = explicitOwnershipOf(tokenIds[i]);\r\n            }\r\n            return ownerships;\r\n        }\r\n    }\r\n\r\n    function tokensOfOwnerIn(\r\n        address owner,\r\n        uint256 start,\r\n        uint256 stop\r\n    ) external view override returns (uint256[] memory) {\r\n        unchecked {\r\n            if (start >= stop) revert InvalidQueryRange();\r\n            uint256 tokenIdsIdx;\r\n            uint256 stopLimit = _nextTokenId();\r\n            // Set `start = max(start, _startTokenId())`.\r\n            if (start < _startTokenId()) {\r\n                start = _startTokenId();\r\n            }\r\n            // Set `stop = min(stop, stopLimit)`.\r\n            if (stop > stopLimit) {\r\n                stop = stopLimit;\r\n            }\r\n            uint256 tokenIdsMaxLength = balanceOf(owner);\r\n\r\n            if (start < stop) {\r\n                uint256 rangeLength = stop - start;\r\n                if (rangeLength < tokenIdsMaxLength) {\r\n                    tokenIdsMaxLength = rangeLength;\r\n                }\r\n            } else {\r\n                tokenIdsMaxLength = 0;\r\n            }\r\n            uint256[] memory tokenIds = new uint256[](tokenIdsMaxLength);\r\n            if (tokenIdsMaxLength == 0) {\r\n                return tokenIds;\r\n            }\r\n\r\n            TokenOwnership memory ownership = explicitOwnershipOf(start);\r\n            address currOwnershipAddr;\r\n\r\n            if (!ownership.burned) {\r\n                currOwnershipAddr = ownership.addr;\r\n            }\r\n            for (uint256 i = start; i != stop && tokenIdsIdx != tokenIdsMaxLength; ++i) {\r\n                ownership = _ownershipAt(i);\r\n                if (ownership.burned) {\r\n                    continue;\r\n                }\r\n                if (ownership.addr != address(0)) {\r\n                    currOwnershipAddr = ownership.addr;\r\n                }\r\n                if (currOwnershipAddr == owner) {\r\n                    tokenIds[tokenIdsIdx++] = i;\r\n                }\r\n            }\r\n            assembly {\r\n                mstore(tokenIds, tokenIdsIdx)\r\n            }\r\n            return tokenIds;\r\n        }\r\n    }\r\n\r\n    function tokensOfOwner(address owner) external view override returns (uint256[] memory) {\r\n        unchecked {\r\n            uint256 tokenIdsIdx;\r\n            address currOwnershipAddr;\r\n            uint256 tokenIdsLength = balanceOf(owner);\r\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\r\n            TokenOwnership memory ownership;\r\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\r\n                ownership = _ownershipAt(i);\r\n                if (ownership.burned) {\r\n                    continue;\r\n                }\r\n                if (ownership.addr != address(0)) {\r\n                    currOwnershipAddr = ownership.addr;\r\n                }\r\n                if (currOwnershipAddr == owner) {\r\n                    tokenIds[tokenIdsIdx++] = i;\r\n                }\r\n            }\r\n            return tokenIds;\r\n        }\r\n    }\r\n}\r\n\r\nlibrary EnumerableSet {\r\n\r\n    struct Set {\r\n        bytes32[] _values;\r\n\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastValue = set._values[lastIndex];\r\n\r\n                set._values[toDeleteIndex] = lastValue;\r\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\r\n            }\r\n\r\n            set._values.pop();\r\n\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        return set._values[index];\r\n    }\r\n\r\n    function _values(Set storage set) private view returns (bytes32[] memory) {\r\n        return set._values;\r\n    }\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\r\n        return _values(set._inner);\r\n    }\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    function values(AddressSet storage set) internal view returns (address[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        address[] memory result;\r\n\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n\r\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        uint256[] memory result;\r\n\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n\r\ncontract VektorX is ERC721AQueryable, ERC721ABurnable, Ownable {\r\n  using EnumerableSet for EnumerableSet.UintSet;\r\n\r\n  event ForceMoon(uint256 phase);\r\n\r\n  uint256 public constant MAX_SUPPLY = 1000;\r\n\r\n  uint256 public maxByWallet = 5;\r\n  mapping(address => uint256) public mintedByWallet;\r\n\r\n  // 0:close | 1:open\r\n  bool public saleState;\r\n  string public baseURI;\r\n  string public uriSuffix;\r\n\r\n  constructor(\r\n    string memory name,\r\n    string memory symbol,\r\n    string memory baseURI_\r\n  ) ERC721A(name, symbol) {\r\n    baseURI = baseURI_;\r\n    uriSuffix = \"\";\r\n  }\r\n\r\n  function mint(uint256 amount) external {\r\n    require(msg.sender == tx.origin, \"not allowed\");\r\n    require(saleState, \"Sale is closed!\");\r\n    require(_totalMinted() + amount <= MAX_SUPPLY, \"Exceed MAX_SUPPLY\");\r\n    require(amount > 0, \"Amount can't be 0\");\r\n    require(amount + mintedByWallet[msg.sender] <= maxByWallet, \"Exceed maxByWallet\");\r\n\r\n    mintedByWallet[msg.sender] += amount;\r\n\r\n    _safeMint(msg.sender, amount);\r\n  }\r\n\r\n  function _startTokenId() internal view virtual override returns (uint256) {\r\n    return 1;\r\n  }\r\n\r\n  function _baseURI() internal view virtual override returns (string memory) {\r\n    return baseURI;\r\n  }\r\n\r\n  function setBaseURI(string memory newBaseURI, string memory newUriSuffix) external onlyOwner {\r\n    baseURI = newBaseURI;\r\n    uriSuffix = newUriSuffix;\r\n  }\r\n\r\n  function setSaleState(bool newSaleState) external onlyOwner {\r\n    saleState = newSaleState;\r\n  }\r\n\r\n  function setMaxByWallet(uint256 newMaxByWallet) external onlyOwner {\r\n    maxByWallet = newMaxByWallet;\r\n  }\r\n\r\n  function alphaMint(address[] calldata addresses, uint256[] calldata count) external onlyOwner {\r\n    require(!saleState, \"sale is open!\");\r\n    require(addresses.length == count.length, \"mismatching lengths!\");\r\n\r\n    for (uint256 i; i < addresses.length; i++) {\r\n      _safeMint(addresses[i], count[i]);\r\n    }\r\n\r\n    require(_totalMinted() <= MAX_SUPPLY, \"Exceed MAX_SUPPLY\");\r\n  }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalToCurrentOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApproveToCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidQueryRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"URIQueryForNonexistentToken\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"phase\",\"type\":\"uint256\"}],\"name\":\"ForceMoon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"count\",\"type\":\"uint256[]\"}],\"name\":\"alphaMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"explicitOwnershipOf\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"startTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"burned\",\"type\":\"bool\"}],\"internalType\":\"struct IERC721A.TokenOwnership\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"explicitOwnershipsOf\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"startTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"burned\",\"type\":\"bool\"}],\"internalType\":\"struct IERC721A.TokenOwnership[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxByWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mintedByWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"newUriSuffix\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxByWallet\",\"type\":\"uint256\"}],\"name\":\"setMaxByWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newSaleState\",\"type\":\"bool\"}],\"name\":\"setSaleState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stop\",\"type\":\"uint256\"}],\"name\":\"tokensOfOwnerIn\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uriSuffix\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VektorX", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000756656b746f725800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000356583200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000036697066733a2f2f516d553979674c6566453431545373324c476b48547a7844443451575831326943714c436865633373696e6a566d2f00000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f6f59f061444daf13cad06d0ffb38f4ad039cd35e0dce3c919e9aaaaca6cfc0b"}