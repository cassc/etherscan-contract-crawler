{"SourceCode": "// SPDX-License-Identifier:  AGPL-3.0-or-later // hevm: flattened sources of contracts/Pool.sol\npragma solidity =0.6.11 >=0.6.0 <0.8.0 >=0.6.2 <0.8.0;\n\n////// contracts/interfaces/IBPool.sol\n/* pragma solidity 0.6.11; */\n\ninterface IBPool {\n\n    function transfer(address, uint256) external returns (bool);\n\n    function INIT_POOL_SUPPLY() external view returns (uint256);\n\n    function MAX_OUT_RATIO() external view returns (uint256);\n\n    function bind(address, uint256, uint256) external;\n\n    function balanceOf(address) external view returns (uint256);\n\n    function finalize() external;\n\n    function gulp(address) external;\n\n    function isFinalized() external view returns (bool);\n\n    function isBound(address) external view returns (bool);\n\n    function getNumTokens() external view returns (uint256);\n\n    function getBalance(address) external view returns (uint256);\n\n    function getNormalizedWeight(address) external view returns (uint256);\n\n    function getDenormalizedWeight(address) external view returns (uint256);\n\n    function getTotalDenormalizedWeight() external view returns (uint256);\n\n    function getSwapFee() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function getFinalTokens() external view returns (address[] memory);\n\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external;\n\n    function calcSingleOutGivenPoolIn(\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 poolAmountIn,\n        uint256 swapFee\n    ) external pure returns (uint256);\n\n    function calcPoolInGivenSingleOut(\n        uint256 tokenBalanceOut,\n        uint256 tokenWeightOut,\n        uint256 poolSupply,\n        uint256 totalWeight,\n        uint256 tokenAmountOut,\n        uint256 swapFee\n    ) external pure returns (uint256);\n\n    function exitswapExternAmountOut(\n        address tokenOut,\n        uint256 tokenAmountOut,\n        uint256 maxPoolAmountIn\n    ) external returns (uint256 poolAmountIn);\n\n}\n\n////// contracts/interfaces/IDebtLocker.sol\n/* pragma solidity 0.6.11; */\n\ninterface IDebtLocker {\n\n    function loan() external view returns (address);\n\n    function liquidityAsset() external view returns (address);\n\n    function pool() external view returns (address);\n\n    function lastPrincipalPaid() external view returns (uint256);\n\n    function lastInterestPaid() external view returns (uint256);\n\n    function lastFeePaid() external view returns (uint256);\n\n    function lastExcessReturned() external view returns (uint256);\n\n    function lastDefaultSuffered() external view returns (uint256);\n\n    function lastAmountRecovered() external view returns (uint256);\n\n    function claim() external returns (uint256[7] memory);\n    \n    function triggerDefault() external;\n\n}\n\n////// contracts/interfaces/ILiquidityLocker.sol\n/* pragma solidity 0.6.11; */\n\ninterface ILiquidityLocker {\n\n    function pool() external view returns (address);\n\n    function liquidityAsset() external view returns (address);\n\n    function transfer(address, uint256) external;\n\n    function fundLoan(address, address, uint256) external;\n\n}\n\n////// contracts/interfaces/ILiquidityLockerFactory.sol\n/* pragma solidity 0.6.11; */\n\ninterface ILiquidityLockerFactory {\n\n    function owner(address) external view returns (address);\n    \n    function isLocker(address) external view returns (bool);\n\n    function factoryType() external view returns (uint8);\n\n    function newLocker(address) external returns (address);\n\n}\n\n////// contracts/token/interfaces/IBaseFDT.sol\n/* pragma solidity 0.6.11; */\n\ninterface IBaseFDT {\n\n    /**\n        @dev    Returns the total amount of funds a given address is able to withdraw currently.\n        @param  owner Address of FDT holder.\n        @return A uint256 representing the available funds for a given account.\n    */\n    function withdrawableFundsOf(address owner) external view returns (uint256);\n\n    /**\n        @dev Withdraws all available funds for a FDT holder.\n    */\n    function withdrawFunds() external;\n\n    /**\n        @dev   This event emits when new funds are distributed.\n        @param by               The address of the sender that distributed funds.\n        @param fundsDistributed The amount of funds received for distribution.\n    */\n    event FundsDistributed(address indexed by, uint256 fundsDistributed);\n\n    /**\n        @dev   This event emits when distributed funds are withdrawn by a token holder.\n        @param by             The address of the receiver of funds.\n        @param fundsWithdrawn The amount of funds that were withdrawn.\n        @param totalWithdrawn The total amount of funds that were withdrawn.\n    */\n    event FundsWithdrawn(address indexed by, uint256 fundsWithdrawn, uint256 totalWithdrawn);\n\n}\n\n////// lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\n/* pragma solidity >=0.6.0 <0.8.0; */\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n////// contracts/token/interfaces/IBasicFDT.sol\n/* pragma solidity 0.6.11; */\n\n/* import \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\"; */\n\n/* import \"./IBaseFDT.sol\"; */\n\ninterface IBasicFDT is IBaseFDT, IERC20 {\n\n    event PointsPerShareUpdated(uint256);\n\n    event PointsCorrectionUpdated(address indexed, int256);\n\n    function withdrawnFundsOf(address) external view returns (uint256);\n\n    function accumulativeFundsOf(address) external view returns (uint256);\n\n    function updateFundsReceived() external;\n\n}\n\n////// contracts/token/interfaces/ILoanFDT.sol\n/* pragma solidity 0.6.11; */\n\n/* import \"./IBasicFDT.sol\"; */\n\ninterface ILoanFDT is IBasicFDT {\n\n    function fundsToken() external view returns (address);\n\n    function fundsTokenBalance() external view returns (uint256);\n\n}\n\n////// contracts/interfaces/ILoan.sol\n/* pragma solidity 0.6.11; */\n\n/* import \"../token/interfaces/ILoanFDT.sol\"; */\n\ninterface ILoan is ILoanFDT {\n    \n    // State Variables\n    function liquidityAsset() external view returns (address);\n    \n    function collateralAsset() external view returns (address);\n    \n    function fundingLocker() external view returns (address);\n    \n    function flFactory() external view returns (address);\n    \n    function collateralLocker() external view returns (address);\n    \n    function clFactory() external view returns (address);\n    \n    function borrower() external view returns (address);\n    \n    function repaymentCalc() external view returns (address);\n    \n    function lateFeeCalc() external view returns (address);\n    \n    function premiumCalc() external view returns (address);\n    \n    function loanState() external view returns (uint256);\n    \n    function collateralRequiredForDrawdown(uint256) external view returns (uint256);\n    \n\n    // Loan Specifications\n    function apr() external view returns (uint256);\n    \n    function paymentsRemaining() external view returns (uint256);\n    \n    function paymentIntervalSeconds() external view returns (uint256);\n    \n    function requestAmount() external view returns (uint256);\n    \n    function collateralRatio() external view returns (uint256);\n    \n    function fundingPeriod() external view returns (uint256);\n\n    function defaultGracePeriod() external view returns (uint256);\n    \n    function createdAt() external view returns (uint256);\n    \n    function principalOwed() external view returns (uint256);\n    \n    function principalPaid() external view returns (uint256);\n    \n    function interestPaid() external view returns (uint256);\n    \n    function feePaid() external view returns (uint256);\n    \n    function excessReturned() external view returns (uint256);\n    \n    function getNextPayment() external view returns (uint256, uint256, uint256, uint256);\n    \n    function superFactory() external view returns (address);\n    \n    function termDays() external view returns (uint256);\n    \n    function nextPaymentDue() external view returns (uint256);\n\n    function getFullPayment() external view returns (uint256, uint256, uint256);\n    \n\n    // Liquidations\n    function amountLiquidated() external view returns (uint256);\n\n    function defaultSuffered() external view returns (uint256);\n    \n    function amountRecovered() external view returns (uint256);\n    \n    function getExpectedAmountRecovered() external view returns (uint256);\n\n    function liquidationExcess() external view returns (uint256);\n    \n\n    // Functions\n    function fundLoan(address, uint256) external;\n    \n    function makePayment() external;\n    \n    function drawdown(uint256) external;\n    \n    function makeFullPayment() external;\n    \n    function triggerDefault() external;\n    \n    function unwind() external;\n    \n\n    // Security \n    function pause() external;\n\n    function unpause() external;\n\n    function loanAdmins(address) external view returns (address);\n\n    function setLoanAdmin(address, bool) external;\n\n\n    // Misc\n    function reclaimERC20(address) external;\n\n}\n\n////// contracts/interfaces/ILoanFactory.sol\n/* pragma solidity 0.6.11; */\n\ninterface ILoanFactory {\n\n    function CL_FACTORY() external view returns (uint8);\n\n    function FL_FACTORY() external view returns (uint8);\n\n    function INTEREST_CALC_TYPE() external view returns (uint8);\n\n    function LATEFEE_CALC_TYPE() external view returns (uint8);\n\n    function PREMIUM_CALC_TYPE() external view returns (uint8);\n\n    function globals() external view returns (address);\n\n    function loansCreated() external view returns (uint256);\n\n    function loans(uint256) external view returns (address);\n\n    function isLoan(address) external view returns (bool);\n\n    function loanFactoryAdmins(address) external view returns (bool);\n\n    function setGlobals(address) external;\n    \n    function createLoan(address, address, address, address, uint256[5] memory, address[3] memory) external returns (address);\n\n    function setLoanFactoryAdmin(address, bool) external;\n\n    function pause() external;\n\n    function unpause() external;\n\n}\n\n////// contracts/interfaces/IMapleGlobals.sol\n/* pragma solidity 0.6.11; */\n\ninterface IMapleGlobals {\n\n    function pendingGovernor() external view returns (address);\n\n    function governor() external view returns (address);\n\n    function globalAdmin() external view returns (address);\n\n    function mpl() external view returns (address);\n\n    function mapleTreasury() external view returns (address);\n\n    function isValidBalancerPool(address) external view returns (bool);\n\n    function treasuryFee() external view returns (uint256);\n\n    function investorFee() external view returns (uint256);\n\n    function defaultGracePeriod() external view returns (uint256);\n\n    function fundingPeriod() external view returns (uint256);\n\n    function swapOutRequired() external view returns (uint256);\n\n    function isValidLiquidityAsset(address) external view returns (bool);\n\n    function isValidCollateralAsset(address) external view returns (bool);\n\n    function isValidPoolDelegate(address) external view returns (bool);\n\n    function validCalcs(address) external view returns (bool);\n\n    function isValidCalc(address, uint8) external view returns (bool);\n\n    function getLpCooldownParams() external view returns (uint256, uint256);\n\n    function isValidLoanFactory(address) external view returns (bool);\n\n    function isValidSubFactory(address, address, uint8) external view returns (bool);\n\n    function isValidPoolFactory(address) external view returns (bool);\n    \n    function getLatestPrice(address) external view returns (uint256);\n    \n    function defaultUniswapPath(address, address) external view returns (address);\n\n    function minLoanEquity() external view returns (uint256);\n    \n    function maxSwapSlippage() external view returns (uint256);\n\n    function protocolPaused() external view returns (bool);\n\n    function stakerCooldownPeriod() external view returns (uint256);\n\n    function lpCooldownPeriod() external view returns (uint256);\n\n    function stakerUnstakeWindow() external view returns (uint256);\n\n    function lpWithdrawWindow() external view returns (uint256);\n\n    function oracleFor(address) external view returns (address);\n\n    function validSubFactories(address, address) external view returns (bool);\n\n    function setStakerCooldownPeriod(uint256) external;\n\n    function setLpCooldownPeriod(uint256) external;\n\n    function setStakerUnstakeWindow(uint256) external;\n\n    function setLpWithdrawWindow(uint256) external;\n\n    function setMaxSwapSlippage(uint256) external;\n\n    function setGlobalAdmin(address) external;\n\n    function setValidBalancerPool(address, bool) external;\n\n    function setProtocolPause(bool) external;\n\n    function setValidPoolFactory(address, bool) external;\n\n    function setValidLoanFactory(address, bool) external;\n\n    function setValidSubFactory(address, address, bool) external;\n\n    function setDefaultUniswapPath(address, address, address) external;\n\n    function setPoolDelegateAllowlist(address, bool) external;\n\n    function setCollateralAsset(address, bool) external;\n\n    function setLiquidityAsset(address, bool) external;\n\n    function setCalc(address, bool) external;\n\n    function setInvestorFee(uint256) external;\n\n    function setTreasuryFee(uint256) external;\n\n    function setMapleTreasury(address) external;\n\n    function setDefaultGracePeriod(uint256) external;\n\n    function setMinLoanEquity(uint256) external;\n\n    function setFundingPeriod(uint256) external;\n\n    function setSwapOutRequired(uint256) external;\n\n    function setPriceOracle(address, address) external;\n\n    function setPendingGovernor(address) external;\n\n    function acceptGovernor() external;\n\n}\n\n////// contracts/interfaces/IPoolFactory.sol\n/* pragma solidity 0.6.11; */\n\ninterface IPoolFactory {\n\n    function LL_FACTORY() external view returns (uint8);\n\n    function SL_FACTORY() external view returns (uint8);\n\n    function poolsCreated() external view returns (uint256);\n\n    function globals() external view returns (address);\n\n    function pools(uint256) external view returns (address);\n\n    function isPool(address) external view returns (bool);\n\n    function poolFactoryAdmins(address) external view returns (bool);\n\n    function setGlobals(address) external;\n\n    function createPool(address, address, address, address, uint256, uint256, uint256) external returns (address);\n\n    function setPoolFactoryAdmin(address, bool) external;\n\n    function pause() external;\n\n    function unpause() external;\n\n}\n\n////// contracts/token/interfaces/IExtendedFDT.sol\n/* pragma solidity 0.6.11; */\n\n/* import \"./IBasicFDT.sol\"; */\n\ninterface IExtendedFDT is IBasicFDT {\n\n    event LossesPerShareUpdated(uint256);\n\n    event LossesCorrectionUpdated(address indexed, int256);\n\n    event LossesDistributed(address indexed, uint256);\n\n    event LossesRecognized(address indexed, uint256, uint256);\n\n    function lossesPerShare() external view returns (uint256);\n\n    function recognizableLossesOf(address) external view returns (uint256);\n\n    function recognizedLossesOf(address) external view returns (uint256);\n\n    function accumulativeLossesOf(address) external view returns (uint256);\n\n    function updateLossesReceived() external;\n\n}\n\n////// contracts/token/interfaces/IStakeLockerFDT.sol\n/* pragma solidity 0.6.11; */\n\n/* import \"./IExtendedFDT.sol\"; */\n\ninterface IStakeLockerFDT is IExtendedFDT {\n\n    function fundsToken() external view returns (address);\n\n    function fundsTokenBalance() external view returns (uint256);\n\n    function bptLosses() external view returns (uint256);\n\n    function lossesBalance() external view returns (uint256);\n\n}\n\n////// contracts/interfaces/IStakeLocker.sol\n/* pragma solidity 0.6.11; */\n\n/* import \"../token/interfaces/IStakeLockerFDT.sol\"; */\n\ninterface IStakeLocker is IStakeLockerFDT {\n\n    function stakeDate(address) external returns (uint256);\n\n    function stake(uint256) external;\n\n    function unstake(uint256) external;\n\n    function pull(address, uint256) external;\n\n    function setAllowlist(address, bool) external;\n\n    function openStakeLockerToPublic() external;\n\n    function openToPublic() external view returns (bool);\n\n    function allowed(address) external view returns (bool);\n\n    function updateLosses(uint256) external;\n\n    function intendToUnstake() external;\n\n    function unstakeCooldown(address) external view returns (uint256);\n\n    function lockupPeriod() external view returns (uint256);\n\n    function stakeAsset() external view returns (address);\n\n    function liquidityAsset() external view returns (address);\n\n    function pool() external view returns (address);\n\n    function setLockupPeriod(uint256) external;\n\n    function cancelUnstake() external;\n\n    function increaseCustodyAllowance(address, uint256) external;\n\n    function transferByCustodian(address, address, uint256) external;\n\n    function pause() external;\n\n    function unpause() external;\n\n    function isUnstakeAllowed(address) external view returns (bool);\n\n    function isReceiveAllowed(uint256) external view returns (bool);\n\n}\n\n////// contracts/interfaces/IStakeLockerFactory.sol\n/* pragma solidity 0.6.11; */\n\ninterface IStakeLockerFactory {\n\n    function owner(address) external returns (address);\n\n    function isLocker(address) external returns (bool);\n\n    function factoryType() external returns (uint8);\n\n    function newLocker(address, address) external returns (address);\n\n}\n\n////// contracts/interfaces/IDebtLockerFactory.sol\n/* pragma solidity 0.6.11; */\n\ninterface IDebtLockerFactory {\n\n    function owner(address) external view returns (address);\n\n    function isLocker(address) external view returns (bool);\n\n    function factoryType() external view returns (uint8);\n\n    function newLocker(address) external returns (address);\n\n}\n\n////// contracts/interfaces/IERC20Details.sol\n/* pragma solidity 0.6.11; */\n\n/* import \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\"; */\n\ninterface IERC20Details is IERC20 {\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint256);\n\n}\n\n////// lib/openzeppelin-contracts/contracts/math/SafeMath.sol\n/* pragma solidity >=0.6.0 <0.8.0; */\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/utils/Address.sol\n/* pragma solidity >=0.6.2 <0.8.0; */\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/token/ERC20/SafeERC20.sol\n/* pragma solidity >=0.6.0 <0.8.0; */\n\n/* import \"./IERC20.sol\"; */\n/* import \"../../math/SafeMath.sol\"; */\n/* import \"../../utils/Address.sol\"; */\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n////// contracts/library/PoolLib.sol\n/* pragma solidity 0.6.11; */\n\n/* import \"lib/openzeppelin-contracts/contracts/math/SafeMath.sol\"; */\n/* import \"lib/openzeppelin-contracts/contracts/token/ERC20/SafeERC20.sol\"; */\n/* import \"../interfaces/ILoan.sol\"; */\n/* import \"../interfaces/IBPool.sol\"; */\n/* import \"../interfaces/IMapleGlobals.sol\"; */\n/* import \"../interfaces/ILiquidityLocker.sol\"; */\n/* import \"../interfaces/IERC20Details.sol\"; */\n/* import \"../interfaces/ILoanFactory.sol\"; */\n/* import \"../interfaces/IStakeLocker.sol\"; */\n/* import \"../interfaces/IDebtLockerFactory.sol\"; */\n\n/// @title PoolLib is a library of utility functions used by Pool.\nlibrary PoolLib {\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 public constant MAX_UINT256 = uint256(-1);\n    uint256 public constant WAD         = 10 ** 18;\n    uint8   public constant DL_FACTORY  = 1;         // Factory type of DebtLockerFactory\n\n    event         LoanFunded(address indexed loan, address debtLocker, uint256 amountFunded);\n    event DepositDateUpdated(address indexed liquidityProvider, uint256 depositDate);\n\n    /***************************************/\n    /*** Pool Delegate Utility Functions ***/\n    /***************************************/\n\n    /** \n        @dev   Conducts sanity checks for Pools in the constructor.\n        @param globals        Instance of a MapleGlobals.\n        @param liquidityAsset Asset used by Pool for liquidity to fund loans.\n        @param stakeAsset     Asset escrowed in StakeLocker.\n        @param stakingFee     Fee that the Stakers earn on interest, in basis points.\n        @param delegateFee    Fee that the Pool Delegate earns on interest, in basis points.\n    */\n    function poolSanityChecks(\n        IMapleGlobals globals, \n        address liquidityAsset, \n        address stakeAsset, \n        uint256 stakingFee, \n        uint256 delegateFee\n    ) external view {\n        IBPool bPool = IBPool(stakeAsset);\n\n        require(globals.isValidLiquidityAsset(liquidityAsset), \"P:INVALID_LIQ_ASSET\");\n        require(stakingFee.add(delegateFee) <= 10_000,         \"P:INVALID_FEES\");\n        require(\n            globals.isValidBalancerPool(address(stakeAsset)) &&\n            bPool.isBound(globals.mpl())                     && \n            bPool.isBound(liquidityAsset)                    &&\n            bPool.isFinalized(), \n            \"P:INVALID_BALANCER_POOL\"\n        );\n    }\n\n    /**\n        @dev   Funds a Loan for an amount, utilizing the supplied DebtLockerFactory for DebtLockers.\n        @dev   It emits a `LoanFunded` event.\n        @param debtLockers     Mapping contains the DebtLocker contract address corresponding to the DebtLockerFactory and Loan.\n        @param superFactory    Address of the PoolFactory.\n        @param liquidityLocker Address of the LiquidityLocker contract attached with this Pool.\n        @param loan            Address of the Loan to fund.\n        @param dlFactory       The DebtLockerFactory to utilize.\n        @param amt             Amount to fund the Loan.\n    */\n    function fundLoan(\n        mapping(address => mapping(address => address)) storage debtLockers,\n        address superFactory,\n        address liquidityLocker,\n        address loan,\n        address dlFactory,\n        uint256 amt\n    ) external {\n        IMapleGlobals globals = IMapleGlobals(ILoanFactory(superFactory).globals());\n        address loanFactory   = ILoan(loan).superFactory();\n\n        // Auth checks.\n        require(globals.isValidLoanFactory(loanFactory),                        \"P:INVALID_LF\");\n        require(ILoanFactory(loanFactory).isLoan(loan),                         \"P:INVALID_L\");\n        require(globals.isValidSubFactory(superFactory, dlFactory, DL_FACTORY), \"P:INVALID_DLF\");\n\n        address debtLocker = debtLockers[loan][dlFactory];\n\n        // Instantiate DebtLocker if it doesn't exist withing this factory\n        if (debtLocker == address(0)) {\n            debtLocker = IDebtLockerFactory(dlFactory).newLocker(loan);\n            debtLockers[loan][dlFactory] = debtLocker;\n        }\n    \n        // Fund the Loan.\n        ILiquidityLocker(liquidityLocker).fundLoan(loan, debtLocker, amt);\n        \n        emit LoanFunded(loan, debtLocker, amt);\n    }\n\n    /**\n        @dev    Helper function used by Pool `claim` function, for when if a default has occurred.\n        @param  liquidityAsset                  IERC20 of Liquidity Asset.\n        @param  stakeLocker                     Address of StakeLocker.\n        @param  stakeAsset                      Address of BPTs.\n        @param  defaultSuffered                 Amount of shortfall in defaulted Loan after liquidation.\n        @return bptsBurned                      Amount of BPTs burned to cover shortfall.\n        @return postBurnBptBal                  Amount of BPTs returned to StakeLocker after burn.\n        @return liquidityAssetRecoveredFromBurn Amount of Liquidity Asset recovered from burn.\n    */\n    function handleDefault(\n        IERC20  liquidityAsset,\n        address stakeLocker,\n        address stakeAsset,\n        uint256 defaultSuffered\n    ) \n        external\n        returns (\n            uint256 bptsBurned,\n            uint256 postBurnBptBal,\n            uint256 liquidityAssetRecoveredFromBurn\n        ) \n    {\n\n        IBPool bPool = IBPool(stakeAsset);  // stakeAsset = Balancer Pool Tokens\n\n        // Check amount of Liquidity Asset coverage that exists in the StakeLocker.\n        uint256 availableSwapOut = getSwapOutValueLocker(stakeAsset, address(liquidityAsset), stakeLocker);\n\n        // Pull BPTs from StakeLocker.\n        IStakeLocker(stakeLocker).pull(address(this), bPool.balanceOf(stakeLocker));\n\n        // To maintain accounting, account for direct transfers into Pool.\n        uint256 preBurnLiquidityAssetBal = liquidityAsset.balanceOf(address(this));\n        uint256 preBurnBptBal            = bPool.balanceOf(address(this));\n\n        // Burn enough BPTs for Liquidity Asset to cover default suffered.\n        bPool.exitswapExternAmountOut(\n            address(liquidityAsset), \n            availableSwapOut >= defaultSuffered ? defaultSuffered : availableSwapOut,  // Burn BPTs up to defaultSuffered amount\n            preBurnBptBal\n        );\n\n        // Return remaining BPTs to StakeLocker.\n        postBurnBptBal = bPool.balanceOf(address(this));\n        bptsBurned     = preBurnBptBal.sub(postBurnBptBal);\n        bPool.transfer(stakeLocker, postBurnBptBal);\n        liquidityAssetRecoveredFromBurn = liquidityAsset.balanceOf(address(this)).sub(preBurnLiquidityAssetBal);\n        IStakeLocker(stakeLocker).updateLosses(bptsBurned);  // Update StakeLockerFDT loss accounting for BPTs\n    }\n\n    /**\n        @dev    Calculates portions of claim from DebtLocker to be used by Pool `claim` function.\n        @param  claimInfo           [0] = Total Claimed\n                                    [1] = Interest Claimed\n                                    [2] = Principal Claimed\n                                    [3] = Fee Claimed\n                                    [4] = Excess Returned Claimed\n                                    [5] = Amount Recovered (from Liquidation)\n                                    [6] = Default Suffered\n        @param  delegateFee         Portion of interest (basis points) that goes to the Pool Delegate.\n        @param  stakingFee          Portion of interest (basis points) that goes to the StakeLocker.\n        @return poolDelegatePortion Total funds to send to the Pool Delegate.\n        @return stakeLockerPortion  Total funds to send to the StakeLocker.\n        @return principalClaim      Total principal claim.\n        @return interestClaim       Total interest claim.\n    */\n    function calculateClaimAndPortions(\n        uint256[7] calldata claimInfo,\n        uint256 delegateFee,\n        uint256 stakingFee\n    ) \n        external\n        pure\n        returns (\n            uint256 poolDelegatePortion,\n            uint256 stakeLockerPortion,\n            uint256 principalClaim,\n            uint256 interestClaim\n        ) \n    { \n        poolDelegatePortion = claimInfo[1].mul(delegateFee).div(10_000).add(claimInfo[3]);  // Pool Delegate portion of interest plus fee.\n        stakeLockerPortion  = claimInfo[1].mul(stakingFee).div(10_000);                     // StakeLocker portion of interest.\n\n        principalClaim = claimInfo[2].add(claimInfo[4]).add(claimInfo[5]);                                     // principal + excess + amountRecovered\n        interestClaim  = claimInfo[1].sub(claimInfo[1].mul(delegateFee).div(10_000)).sub(stakeLockerPortion);  // leftover interest\n    }\n\n    /**\n        @dev   Checks that the deactivation is allowed.\n        @param globals        Instance of a MapleGlobals.\n        @param principalOut   Amount of funds that are already funded to Loans.\n        @param liquidityAsset Liquidity Asset of the Pool.\n    */\n    function validateDeactivation(IMapleGlobals globals, uint256 principalOut, address liquidityAsset) external view {\n        require(principalOut <= _convertFromUsd(globals, liquidityAsset, 100), \"P:PRINCIPAL_OUTSTANDING\");\n    }\n\n    /********************************************/\n    /*** Liquidity Provider Utility Functions ***/\n    /********************************************/\n\n    /**\n        @dev   Updates the effective deposit date based on how much new capital has been added.\n               If more capital is added, the deposit date moves closer to the current timestamp.\n        @dev   It emits a `DepositDateUpdated` event.\n        @param amt     Total deposit amount.\n        @param account Address of account depositing.\n    */\n    function updateDepositDate(mapping(address => uint256) storage depositDate, uint256 balance, uint256 amt, address account) internal {\n        uint256 prevDate = depositDate[account];\n\n        // prevDate + (now - prevDate) * (amt / (balance + amt))\n        // NOTE: prevDate = 0 implies balance = 0, and equation reduces to now\n        uint256 newDate = (balance + amt) > 0\n            ? prevDate.add(block.timestamp.sub(prevDate).mul(amt).div(balance + amt))\n            : prevDate;\n\n        depositDate[account] = newDate;\n        emit DepositDateUpdated(account, newDate);\n    }\n\n    /**\n        @dev Performs all necessary checks for a `transferByCustodian` call.\n        @dev From and to must always be equal.\n    */\n    function transferByCustodianChecks(address from, address to, uint256 amount) external pure {\n        require(to == from,                 \"P:INVALID_RECEIVER\");\n        require(amount != uint256(0),       \"P:INVALID_AMT\");\n    }\n\n    /**\n        @dev Performs all necessary checks for an `increaseCustodyAllowance` call.\n    */\n    function increaseCustodyAllowanceChecks(address custodian, uint256 amount, uint256 newTotalAllowance, uint256 fdtBal) external pure {\n        require(custodian != address(0),     \"P:INVALID_CUSTODIAN\");\n        require(amount    != uint256(0),     \"P:INVALID_AMT\");\n        require(newTotalAllowance <= fdtBal, \"P:INSUF_BALANCE\");\n    }\n\n    /**********************************/\n    /*** Governor Utility Functions ***/\n    /**********************************/\n\n    /**\n        @dev   Transfers any locked funds to the Governor. Only the Governor can call this function.\n        @param token          Address of the token to be reclaimed.\n        @param liquidityAsset Address of Liquidity Asset that is supported by the Pool.\n        @param globals        Instance of a MapleGlobals.\n    */\n    function reclaimERC20(address token, address liquidityAsset, IMapleGlobals globals) external {\n        require(msg.sender == globals.governor(), \"P:NOT_GOV\");\n        require(token != liquidityAsset && token != address(0), \"P:INVALID_TOKEN\");\n        IERC20(token).safeTransfer(msg.sender, IERC20(token).balanceOf(address(this)));\n    }\n\n    /************************/\n    /*** Getter Functions ***/\n    /************************/\n\n    /**\n        @dev Official Balancer pool bdiv() function. Does synthetic float with 10^-18 precision.\n    */\n    function _bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"P:DIV_ZERO\");\n        uint256 c0 = a * WAD;\n        require(a == 0 || c0 / a == WAD, \"P:DIV_INTERNAL\");  // bmul overflow\n        uint256 c1 = c0 + (b / 2);\n        require(c1 >= c0, \"P:DIV_INTERNAL\");  //  badd require\n        return c1 / b;\n    }\n\n    /**\n        @dev    Calculates the value of BPT in units of Liquidity Asset.\n        @dev    Vulnerable to flash-loan attacks where the attacker can artificially inflate the BPT price by swapping a large amount\n                of Liquidity Asset into the Pool and swapping back after this function is called.\n        @param  _bPool         Address of Balancer pool.\n        @param  liquidityAsset Asset used by Pool for liquidity to fund Loans.\n        @param  staker         Address that deposited BPTs to StakeLocker.\n        @param  stakeLocker    Escrows BPTs deposited by Staker.\n        @return USDC value of Staker BPTs.\n    */\n    function BPTVal(\n        address _bPool,\n        address liquidityAsset,\n        address staker,\n        address stakeLocker\n    ) external view returns (uint256) {\n        IBPool bPool = IBPool(_bPool);\n\n        // StakeLockerFDTs are minted 1:1 (in wei) in the StakeLocker when staking BPTs, thus representing stake amount.\n        // These are burned when withdrawing staked BPTs, thus representing the current stake amount.\n        uint256 amountStakedBPT       = IERC20(stakeLocker).balanceOf(staker);\n        uint256 totalSupplyBPT        = IERC20(_bPool).totalSupply();\n        uint256 liquidityAssetBalance = bPool.getBalance(liquidityAsset);\n        uint256 liquidityAssetWeight  = bPool.getNormalizedWeight(liquidityAsset);\n\n        // liquidityAsset value = (amountStaked/totalSupply) * (liquidityAssetBalance/liquidityAssetWeight)\n        return _bdiv(amountStakedBPT, totalSupplyBPT).mul(_bdiv(liquidityAssetBalance, liquidityAssetWeight)).div(WAD);\n    }\n\n    /** \n        @dev    Calculates Liquidity Asset swap out value of staker BPT balance escrowed in StakeLocker.\n        @param  _bPool         Balancer pool that issues the BPTs.\n        @param  liquidityAsset Swap out asset (e.g. USDC) to receive when burning BPTs.\n        @param  staker         Address that deposited BPTs to StakeLocker.\n        @param  stakeLocker    Escrows BPTs deposited by Staker.\n        @return liquidityAsset Swap out value of staker BPTs.\n    */\n    function getSwapOutValue(\n        address _bPool,\n        address liquidityAsset,\n        address staker,\n        address stakeLocker\n    ) public view returns (uint256) {\n        return _getSwapOutValue(_bPool, liquidityAsset, IERC20(stakeLocker).balanceOf(staker));\n    }\n\n    /** \n        @dev    Calculates Liquidity Asset swap out value of entire BPT balance escrowed in StakeLocker.\n        @param  _bPool         Balancer pool that issues the BPTs.\n        @param  liquidityAsset Swap out asset (e.g. USDC) to receive when burning BPTs.\n        @param  stakeLocker    Escrows BPTs deposited by Staker.\n        @return liquidityAsset Swap out value of StakeLocker BPTs.\n    */\n    function getSwapOutValueLocker(\n        address _bPool,\n        address liquidityAsset,\n        address stakeLocker\n    ) public view returns (uint256) {\n        return _getSwapOutValue(_bPool, liquidityAsset, IBPool(_bPool).balanceOf(stakeLocker));\n    }\n\n    function _getSwapOutValue(\n        address _bPool,\n        address liquidityAsset,\n        uint256 poolAmountIn\n    ) internal view returns (uint256) {\n        // Fetch Balancer pool token information\n        IBPool bPool            = IBPool(_bPool);\n        uint256 tokenBalanceOut = bPool.getBalance(liquidityAsset);\n        uint256 tokenWeightOut  = bPool.getDenormalizedWeight(liquidityAsset);\n        uint256 poolSupply      = bPool.totalSupply();\n        uint256 totalWeight     = bPool.getTotalDenormalizedWeight();\n        uint256 swapFee         = bPool.getSwapFee();\n\n        // Returns the amount of liquidityAsset that can be recovered from BPT burning\n        uint256 tokenAmountOut = bPool.calcSingleOutGivenPoolIn(\n            tokenBalanceOut,\n            tokenWeightOut,\n            poolSupply,\n            totalWeight,\n            poolAmountIn,\n            swapFee\n        );\n\n        // Max amount that can be swapped based on amount of liquidityAsset in the Balancer Pool\n        uint256 maxSwapOut = tokenBalanceOut.mul(bPool.MAX_OUT_RATIO()).div(WAD);  \n\n        return tokenAmountOut <= maxSwapOut ? tokenAmountOut : maxSwapOut;\n    }\n\n    /**\n        @dev    Calculates BPTs required if burning BPTs for liquidityAsset, given supplied tokenAmountOutRequired.\n        @dev    Vulnerable to flash-loan attacks where the attacker can artificially inflate the BPT price by swapping a large amount\n                of liquidityAsset into the pool and swapping back after this function is called.\n        @param  _bPool                       Balancer pool that issues the BPTs.\n        @param  liquidityAsset               Swap out asset (e.g. USDC) to receive when burning BPTs.\n        @param  staker                       Address that deposited BPTs to stakeLocker.\n        @param  stakeLocker                  Escrows BPTs deposited by staker.\n        @param  liquidityAssetAmountRequired Amount of liquidityAsset required to recover.\n        @return poolAmountInRequired         poolAmountIn required.\n        @return stakerBalance                poolAmountIn currently staked.\n    */\n    function getPoolSharesRequired(\n        address _bPool,\n        address liquidityAsset,\n        address staker,\n        address stakeLocker,\n        uint256 liquidityAssetAmountRequired\n    ) public view returns (uint256 poolAmountInRequired, uint256 stakerBalance) {\n        // Fetch Balancer pool token information.\n        IBPool bPool = IBPool(_bPool);\n\n        uint256 tokenBalanceOut = bPool.getBalance(liquidityAsset);\n        uint256 tokenWeightOut  = bPool.getDenormalizedWeight(liquidityAsset);\n        uint256 poolSupply      = bPool.totalSupply();\n        uint256 totalWeight     = bPool.getTotalDenormalizedWeight();\n        uint256 swapFee         = bPool.getSwapFee();\n\n        // Fetch amount of BPTs required to burn to receive Liquidity Asset amount required.\n        poolAmountInRequired = bPool.calcPoolInGivenSingleOut(\n            tokenBalanceOut,\n            tokenWeightOut,\n            poolSupply,\n            totalWeight,\n            liquidityAssetAmountRequired,\n            swapFee\n        );\n\n        // Fetch amount staked in StakeLocker by Staker.\n        stakerBalance = IERC20(stakeLocker).balanceOf(staker);\n    }\n\n    /**\n        @dev    Returns information on the stake requirements.\n        @param  globals                    Instance of a MapleGlobals.\n        @param  balancerPool               Address of Balancer pool.\n        @param  liquidityAsset             Address of Liquidity Asset, to be returned from swap out.\n        @param  poolDelegate               Address of Pool Delegate.\n        @param  stakeLocker                Address of StakeLocker.\n        @return swapOutAmountRequired      Min amount of Liquidity Asset coverage from staking required (in Liquidity Asset units).\n        @return currentPoolDelegateCover   Present amount of Liquidity Asset coverage from Pool Delegate stake (in Liquidity Asset units).\n        @return enoughStakeForFinalization If enough stake is present from Pool Delegate for Pool finalization.\n        @return poolAmountInRequired       BPTs required for minimum Liquidity Asset coverage.\n        @return poolAmountPresent          Current staked BPTs.\n    */\n    function getInitialStakeRequirements(IMapleGlobals globals, address balancerPool, address liquidityAsset, address poolDelegate, address stakeLocker) external view returns (\n        uint256 swapOutAmountRequired,\n        uint256 currentPoolDelegateCover,\n        bool    enoughStakeForFinalization,\n        uint256 poolAmountInRequired,\n        uint256 poolAmountPresent\n    ) {\n        swapOutAmountRequired = _convertFromUsd(globals, liquidityAsset, globals.swapOutRequired());\n        (\n            poolAmountInRequired,\n            poolAmountPresent\n        ) = getPoolSharesRequired(balancerPool, liquidityAsset, poolDelegate, stakeLocker, swapOutAmountRequired);\n\n        currentPoolDelegateCover   = getSwapOutValue(balancerPool, liquidityAsset, poolDelegate, stakeLocker);\n        enoughStakeForFinalization = poolAmountPresent >= poolAmountInRequired;\n    }\n\n    /************************/\n    /*** Helper Functions ***/\n    /************************/\n\n    /**\n        @dev   Converts from WAD precision to Liquidity Asset precision.\n        @param amt                    Amount to convert.\n        @param liquidityAssetDecimals Liquidity Asset decimal.\n    */\n    function fromWad(uint256 amt, uint256 liquidityAssetDecimals) external pure returns (uint256) {\n        return amt.mul(10 ** liquidityAssetDecimals).div(WAD);\n    }\n\n    /** \n        @dev    Returns Liquidity Asset in Liquidity Asset units when given integer USD (E.g., $100 = 100).\n        @param  globals        Instance of a MapleGlobals.\n        @param  liquidityAsset Liquidity Asset of the pool.\n        @param  usdAmount      USD amount to convert, in integer units (e.g., $100 = 100).\n        @return usdAmount worth of Liquidity Asset, in Liquidity Asset units.\n    */\n    function _convertFromUsd(IMapleGlobals globals, address liquidityAsset, uint256 usdAmount) internal view returns (uint256) {\n        return usdAmount\n            .mul(10 ** 8)                                         // Cancel out 10 ** 8 decimals from oracle.\n            .mul(10 ** IERC20Details(liquidityAsset).decimals())  // Convert to Liquidity Asset precision.\n            .div(globals.getLatestPrice(liquidityAsset));         // Convert to Liquidity Asset value.\n    }\n}\n\n////// contracts/math/SafeMathInt.sol\n/* pragma solidity 0.6.11; */\n\nlibrary SafeMathInt {\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\n        require(a >= 0, \"SMI:NEG\");\n        return uint256(a);\n    }\n}\n\n////// contracts/math/SafeMathUint.sol\n/* pragma solidity 0.6.11; */\n\nlibrary SafeMathUint {\n    function toInt256Safe(uint256 a) internal pure returns (int256 b) {\n        b = int256(a);\n        require(b >= 0, \"SMU:OOB\");\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/math/SignedSafeMath.sol\n/* pragma solidity >=0.6.0 <0.8.0; */\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/GSN/Context.sol\n/* pragma solidity >=0.6.0 <0.8.0; */\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\n/* pragma solidity >=0.6.0 <0.8.0; */\n\n/* import \"../../GSN/Context.sol\"; */\n/* import \"./IERC20.sol\"; */\n/* import \"../../math/SafeMath.sol\"; */\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n\n////// contracts/token/BasicFDT.sol\n/* pragma solidity 0.6.11; */\n\n/* import \"lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\"; */\n/* import \"lib/openzeppelin-contracts/contracts/math/SafeMath.sol\"; */\n/* import \"lib/openzeppelin-contracts/contracts/math/SignedSafeMath.sol\"; */\n/* import \"./interfaces/IBaseFDT.sol\"; */\n/* import \"../math/SafeMathUint.sol\"; */\n/* import \"../math/SafeMathInt.sol\"; */\n\n/// @title BasicFDT implements base level FDT functionality for accounting for revenues.\nabstract contract BasicFDT is IBaseFDT, ERC20 {\n    using SafeMath       for uint256;\n    using SafeMathUint   for uint256;\n    using SignedSafeMath for  int256;\n    using SafeMathInt    for  int256;\n\n    uint256 internal constant pointsMultiplier = 2 ** 128;\n    uint256 internal pointsPerShare;\n\n    mapping(address => int256)  internal pointsCorrection;\n    mapping(address => uint256) internal withdrawnFunds;\n\n    event   PointsPerShareUpdated(uint256 pointsPerShare);\n    event PointsCorrectionUpdated(address indexed account, int256 pointsCorrection);\n\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) public { }\n\n    /**\n        @dev Distributes funds to token holders.\n        @dev It reverts if the total supply of tokens is 0.\n        @dev It emits a `FundsDistributed` event if the amount of received funds is greater than 0.\n        @dev It emits a `PointsPerShareUpdated` event if the amount of received funds is greater than 0.\n             About undistributed funds:\n                In each distribution, there is a small amount of funds which do not get distributed,\n                   which is `(value  pointsMultiplier) % totalSupply()`.\n                With a well-chosen `pointsMultiplier`, the amount funds that are not getting distributed\n                   in a distribution can be less than 1 (base unit).\n                We can actually keep track of the undistributed funds in a distribution\n                   and try to distribute it in the next distribution.\n    */\n    function _distributeFunds(uint256 value) internal {\n        require(totalSupply() > 0, \"FDT:ZERO_SUPPLY\");\n\n        if (value == 0) return;\n\n        pointsPerShare = pointsPerShare.add(value.mul(pointsMultiplier) / totalSupply());\n        emit FundsDistributed(msg.sender, value);\n        emit PointsPerShareUpdated(pointsPerShare);\n    }\n\n    /**\n        @dev    Prepares the withdrawal of funds.\n        @dev    It emits a `FundsWithdrawn` event if the amount of withdrawn funds is greater than 0.\n        @return withdrawableDividend The amount of dividend funds that can be withdrawn.\n    */\n    function _prepareWithdraw() internal returns (uint256 withdrawableDividend) {\n        withdrawableDividend       = withdrawableFundsOf(msg.sender);\n        uint256 _withdrawnFunds    = withdrawnFunds[msg.sender].add(withdrawableDividend);\n        withdrawnFunds[msg.sender] = _withdrawnFunds;\n\n        emit FundsWithdrawn(msg.sender, withdrawableDividend, _withdrawnFunds);\n    }\n\n    /**\n        @dev    Returns the amount of funds that an account can withdraw.\n        @param  _owner The address of a token holder.\n        @return The amount funds that `_owner` can withdraw.\n    */\n    function withdrawableFundsOf(address _owner) public view override returns (uint256) {\n        return accumulativeFundsOf(_owner).sub(withdrawnFunds[_owner]);\n    }\n\n    /**\n        @dev    Returns the amount of funds that an account has withdrawn.\n        @param  _owner The address of a token holder.\n        @return The amount of funds that `_owner` has withdrawn.\n    */\n    function withdrawnFundsOf(address _owner) external view returns (uint256) {\n        return withdrawnFunds[_owner];\n    }\n\n    /**\n        @dev    Returns the amount of funds that an account has earned in total.\n        @dev    accumulativeFundsOf(_owner) = withdrawableFundsOf(_owner) + withdrawnFundsOf(_owner)\n                                         = (pointsPerShare * balanceOf(_owner) + pointsCorrection[_owner]) / pointsMultiplier\n        @param  _owner The address of a token holder.\n        @return The amount of funds that `_owner` has earned in total.\n    */\n    function accumulativeFundsOf(address _owner) public view returns (uint256) {\n        return\n            pointsPerShare\n                .mul(balanceOf(_owner))\n                .toInt256Safe()\n                .add(pointsCorrection[_owner])\n                .toUint256Safe() / pointsMultiplier;\n    }\n\n    /**\n        @dev   Transfers tokens from one account to another. Updates pointsCorrection to keep funds unchanged.\n        @dev   It emits two `PointsCorrectionUpdated` events, one for the sender and one for the receiver.\n        @param from  The address to transfer from.\n        @param to    The address to transfer to.\n        @param value The amount to be transferred.\n    */\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal virtual override {\n        super._transfer(from, to, value);\n\n        int256 _magCorrection       = pointsPerShare.mul(value).toInt256Safe();\n        int256 pointsCorrectionFrom = pointsCorrection[from].add(_magCorrection);\n        pointsCorrection[from]      = pointsCorrectionFrom;\n        int256 pointsCorrectionTo   = pointsCorrection[to].sub(_magCorrection);\n        pointsCorrection[to]        = pointsCorrectionTo;\n\n        emit PointsCorrectionUpdated(from, pointsCorrectionFrom);\n        emit PointsCorrectionUpdated(to,   pointsCorrectionTo);\n    }\n\n    /**\n        @dev   Mints tokens to an account. Updates pointsCorrection to keep funds unchanged.\n        @param account The account that will receive the created tokens.\n        @param value   The amount that will be created.\n    */\n    function _mint(address account, uint256 value) internal virtual override {\n        super._mint(account, value);\n\n        int256 _pointsCorrection = pointsCorrection[account].sub(\n            (pointsPerShare.mul(value)).toInt256Safe()\n        );\n\n        pointsCorrection[account] = _pointsCorrection;\n\n        emit PointsCorrectionUpdated(account, _pointsCorrection);\n    }\n\n    /**\n        @dev   Burns an amount of the token of a given account. Updates pointsCorrection to keep funds unchanged.\n        @dev   It emits a `PointsCorrectionUpdated` event.\n        @param account The account whose tokens will be burnt.\n        @param value   The amount that will be burnt.\n    */\n    function _burn(address account, uint256 value) internal virtual override {\n        super._burn(account, value);\n\n        int256 _pointsCorrection = pointsCorrection[account].add(\n            (pointsPerShare.mul(value)).toInt256Safe()\n        );\n\n        pointsCorrection[account] = _pointsCorrection;\n\n        emit PointsCorrectionUpdated(account, _pointsCorrection);\n    }\n\n    /**\n        @dev Withdraws all available funds for a token holder.\n    */\n    function withdrawFunds() public virtual override {}\n\n    /**\n        @dev    Updates the current `fundsToken` balance and returns the difference of the new and previous `fundsToken` balance.\n        @return A int256 representing the difference of the new and previous `fundsToken` balance.\n    */\n    function _updateFundsTokenBalance() internal virtual returns (int256) {}\n\n    /**\n        @dev Registers a payment of funds in tokens. May be called directly after a deposit is made.\n        @dev Calls _updateFundsTokenBalance(), whereby the contract computes the delta of the new and previous\n             `fundsToken` balance and increments the total received funds (cumulative), by delta, by calling _distributeFunds().\n    */\n    function updateFundsReceived() public virtual {\n        int256 newFunds = _updateFundsTokenBalance();\n\n        if (newFunds <= 0) return;\n\n        _distributeFunds(newFunds.toUint256Safe());\n    }\n}\n\n////// contracts/token/ExtendedFDT.sol\n/* pragma solidity 0.6.11; */\n\n/* import \"./BasicFDT.sol\"; */\n\n/// @title ExtendedFDT implements FDT functionality for accounting for losses.\nabstract contract ExtendedFDT is BasicFDT {\n    using SafeMath       for uint256;\n    using SafeMathUint   for uint256;\n    using SignedSafeMath for  int256;\n    using SafeMathInt    for  int256;\n\n    uint256 internal lossesPerShare;\n\n    mapping(address => int256)  internal lossesCorrection;\n    mapping(address => uint256) internal recognizedLosses;\n\n    event   LossesPerShareUpdated(uint256 lossesPerShare);\n    event LossesCorrectionUpdated(address indexed account, int256 lossesCorrection);\n\n    /**\n        @dev   This event emits when new losses are distributed.\n        @param by                The address of the account that has distributed losses.\n        @param lossesDistributed The amount of losses received for distribution.\n    */\n    event LossesDistributed(address indexed by, uint256 lossesDistributed);\n\n    /**\n        @dev   This event emits when distributed losses are recognized by a token holder.\n        @param by                    The address of the receiver of losses.\n        @param lossesRecognized      The amount of losses that were recognized.\n        @param totalLossesRecognized The total amount of losses that are recognized.\n    */\n    event LossesRecognized(address indexed by, uint256 lossesRecognized, uint256 totalLossesRecognized);\n\n    constructor(string memory name, string memory symbol) BasicFDT(name, symbol) public { }\n\n    /**\n        @dev Distributes losses to token holders.\n        @dev It reverts if the total supply of tokens is 0.\n        @dev It emits a `LossesDistributed` event if the amount of received losses is greater than 0.\n        @dev It emits a `LossesPerShareUpdated` event if the amount of received losses is greater than 0.\n             About undistributed losses:\n                In each distribution, there is a small amount of losses which do not get distributed,\n                which is `(value * pointsMultiplier) % totalSupply()`.\n             With a well-chosen `pointsMultiplier`, the amount losses that are not getting distributed\n                in a distribution can be less than 1 (base unit).\n             We can actually keep track of the undistributed losses in a distribution\n                and try to distribute it in the next distribution.\n    */\n    function _distributeLosses(uint256 value) internal {\n        require(totalSupply() > 0, \"FDT:ZERO_SUPPLY\");\n\n        if (value == 0) return;\n\n        uint256 _lossesPerShare = lossesPerShare.add(value.mul(pointsMultiplier) / totalSupply());\n        lossesPerShare          = _lossesPerShare;\n\n        emit LossesDistributed(msg.sender, value);\n        emit LossesPerShareUpdated(_lossesPerShare);\n    }\n\n    /**\n        @dev    Prepares losses for a withdrawal.\n        @dev    It emits a `LossesWithdrawn` event if the amount of withdrawn losses is greater than 0.\n        @return recognizableDividend The amount of dividend losses that can be recognized.\n    */\n    function _prepareLossesWithdraw() internal returns (uint256 recognizableDividend) {\n        recognizableDividend = recognizableLossesOf(msg.sender);\n\n        uint256 _recognizedLosses    = recognizedLosses[msg.sender].add(recognizableDividend);\n        recognizedLosses[msg.sender] = _recognizedLosses;\n\n        emit LossesRecognized(msg.sender, recognizableDividend, _recognizedLosses);\n    }\n\n    /**\n        @dev    Returns the amount of losses that an address can withdraw.\n        @param  _owner The address of a token holder.\n        @return The amount of losses that `_owner` can withdraw.\n    */\n    function recognizableLossesOf(address _owner) public view returns (uint256) {\n        return accumulativeLossesOf(_owner).sub(recognizedLosses[_owner]);\n    }\n\n    /**\n        @dev    Returns the amount of losses that an address has recognized.\n        @param  _owner The address of a token holder\n        @return The amount of losses that `_owner` has recognized\n    */\n    function recognizedLossesOf(address _owner) external view returns (uint256) {\n        return recognizedLosses[_owner];\n    }\n\n    /**\n        @dev    Returns the amount of losses that an address has earned in total.\n        @dev    accumulativeLossesOf(_owner) = recognizableLossesOf(_owner) + recognizedLossesOf(_owner)\n                = (lossesPerShare * balanceOf(_owner) + lossesCorrection[_owner]) / pointsMultiplier\n        @param  _owner The address of a token holder\n        @return The amount of losses that `_owner` has earned in total\n    */\n    function accumulativeLossesOf(address _owner) public view returns (uint256) {\n        return\n            lossesPerShare\n                .mul(balanceOf(_owner))\n                .toInt256Safe()\n                .add(lossesCorrection[_owner])\n                .toUint256Safe() / pointsMultiplier;\n    }\n\n    /**\n        @dev   Transfers tokens from one account to another. Updates pointsCorrection to keep funds unchanged.\n        @dev         It emits two `LossesCorrectionUpdated` events, one for the sender and one for the receiver.\n        @param from  The address to transfer from.\n        @param to    The address to transfer to.\n        @param value The amount to be transferred.\n    */\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal virtual override {\n        super._transfer(from, to, value);\n\n        int256 _lossesCorrection    = lossesPerShare.mul(value).toInt256Safe();\n        int256 lossesCorrectionFrom = lossesCorrection[from].add(_lossesCorrection);\n        lossesCorrection[from]      = lossesCorrectionFrom;\n        int256 lossesCorrectionTo   = lossesCorrection[to].sub(_lossesCorrection);\n        lossesCorrection[to]        = lossesCorrectionTo;\n\n        emit LossesCorrectionUpdated(from, lossesCorrectionFrom);\n        emit LossesCorrectionUpdated(to,   lossesCorrectionTo);\n    }\n\n    /**\n        @dev   Mints tokens to an account. Updates lossesCorrection to keep losses unchanged.\n        @dev   It emits a `LossesCorrectionUpdated` event.\n        @param account The account that will receive the created tokens.\n        @param value   The amount that will be created.\n    */\n    function _mint(address account, uint256 value) internal virtual override {\n        super._mint(account, value);\n\n        int256 _lossesCorrection = lossesCorrection[account].sub(\n            (lossesPerShare.mul(value)).toInt256Safe()\n        );\n\n        lossesCorrection[account] = _lossesCorrection;\n\n        emit LossesCorrectionUpdated(account, _lossesCorrection);\n    }\n\n    /**\n        @dev   Burns an amount of the token of a given account. Updates lossesCorrection to keep losses unchanged.\n        @dev   It emits a `LossesCorrectionUpdated` event.\n        @param account The account from which tokens will be burnt.\n        @param value   The amount that will be burnt.\n    */\n    function _burn(address account, uint256 value) internal virtual override {\n        super._burn(account, value);\n\n        int256 _lossesCorrection = lossesCorrection[account].add(\n            (lossesPerShare.mul(value)).toInt256Safe()\n        );\n\n        lossesCorrection[account] = _lossesCorrection;\n\n        emit LossesCorrectionUpdated(account, _lossesCorrection);\n    }\n\n    /**\n        @dev Registers a loss. May be called directly after a shortfall after BPT burning occurs.\n        @dev Calls _updateLossesTokenBalance(), whereby the contract computes the delta of the new and previous\n             losses balance and increments the total losses (cumulative), by delta, by calling _distributeLosses().\n    */\n    function updateLossesReceived() public virtual {\n        int256 newLosses = _updateLossesBalance();\n\n        if (newLosses <= 0) return;\n\n        _distributeLosses(newLosses.toUint256Safe());\n    }\n\n    /**\n        @dev Recognizes all recognizable losses for an account using loss accounting.\n    */\n    function _recognizeLosses() internal virtual returns (uint256 losses) { }\n\n    /**\n        @dev    Updates the current losses balance and returns the difference of the new and previous losses balance.\n        @return A int256 representing the difference of the new and previous losses balance.\n    */\n    function _updateLossesBalance() internal virtual returns (int256) { }\n}\n\n////// contracts/token/PoolFDT.sol\n/* pragma solidity 0.6.11; */\n\n/* import \"./ExtendedFDT.sol\"; */\n\n/// @title PoolFDT inherits ExtendedFDT and accounts for gains/losses for Liquidity Providers.\nabstract contract PoolFDT is ExtendedFDT {\n    using SafeMath       for uint256;\n    using SafeMathUint   for uint256;\n    using SignedSafeMath for  int256;\n    using SafeMathInt    for  int256;\n\n    uint256 public interestSum;  // Sum of all withdrawable interest.\n    uint256 public poolLosses;   // Sum of all unrecognized losses.\n\n    uint256 public interestBalance;  // The amount of earned interest present and accounted for in this contract.\n    uint256 public lossesBalance;    // The amount of losses present and accounted for in this contract.\n\n    constructor(string memory name, string memory symbol) ExtendedFDT(name, symbol) public { }\n\n    /**\n        @dev Realizes losses incurred to LPs.\n    */\n    function _recognizeLosses() internal override returns (uint256 losses) {\n        losses = _prepareLossesWithdraw();\n\n        poolLosses = poolLosses.sub(losses);\n\n        _updateLossesBalance();\n    }\n\n    /**\n        @dev    Updates the current losses balance and returns the difference of the new and previous losses balance.\n        @return A int256 representing the difference of the new and previous losses balance.\n    */\n    function _updateLossesBalance() internal override returns (int256) {\n        uint256 _prevLossesTokenBalance = lossesBalance;\n\n        lossesBalance = poolLosses;\n\n        return int256(lossesBalance).sub(int256(_prevLossesTokenBalance));\n    }\n\n    /**\n        @dev    Updates the current interest balance and returns the difference of the new and previous interest balance.\n        @return A int256 representing the difference of the new and previous interest balance.\n    */\n    function _updateFundsTokenBalance() internal override returns (int256) {\n        uint256 _prevFundsTokenBalance = interestBalance;\n\n        interestBalance = interestSum;\n\n        return int256(interestBalance).sub(int256(_prevFundsTokenBalance));\n    }\n}\n\n////// contracts/Pool.sol\n/* pragma solidity 0.6.11; */\n\n/* import \"lib/openzeppelin-contracts/contracts/token/ERC20/SafeERC20.sol\"; */\n\n/* import \"./interfaces/IBPool.sol\"; */\n/* import \"./interfaces/IDebtLocker.sol\"; */\n/* import \"./interfaces/IMapleGlobals.sol\"; */\n/* import \"./interfaces/ILiquidityLocker.sol\"; */\n/* import \"./interfaces/ILiquidityLockerFactory.sol\"; */\n/* import \"./interfaces/ILoan.sol\"; */\n/* import \"./interfaces/ILoanFactory.sol\"; */\n/* import \"./interfaces/IPoolFactory.sol\"; */\n/* import \"./interfaces/IStakeLocker.sol\"; */\n/* import \"./interfaces/IStakeLockerFactory.sol\"; */\n\n/* import \"./library/PoolLib.sol\"; */\n\n/* import \"./token/PoolFDT.sol\"; */\n\n/// @title Pool maintains all accounting and functionality related to Pools.\ncontract Pool is PoolFDT {\n\n    using SafeMath  for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 constant WAD = 10 ** 18;\n\n    uint8 public constant DL_FACTORY = 1;  // Factory type of `DebtLockerFactory`.\n\n    IERC20  public immutable liquidityAsset;  // The asset deposited by Lenders into the LiquidityLocker, for funding Loans.\n\n    address public immutable poolDelegate;     // The Pool Delegate address, maintains full authority over the Pool.\n    address public immutable liquidityLocker;  // The LiquidityLocker owned by this contract\n    address public immutable stakeAsset;       // The address of the asset deposited by Stakers into the StakeLocker (BPTs), for liquidation during default events.\n    address public immutable stakeLocker;      // The address of the StakeLocker, escrowing `stakeAsset`.\n    address public immutable superFactory;     // The factory that deployed this Loan.\n\n    uint256 private immutable liquidityAssetDecimals;  // The precision for the Liquidity Asset (i.e. `decimals()`).\n\n    uint256 public           stakingFee;   // The fee Stakers earn            (in basis points).\n    uint256 public immutable delegateFee;  // The fee the Pool Delegate earns (in basis points).\n\n    uint256 public principalOut;  // The sum of all outstanding principal on Loans.\n    uint256 public liquidityCap;  // The amount of liquidity tokens accepted by the Pool.\n    uint256 public lockupPeriod;  // The period of time from an account's deposit date during which they cannot withdraw any funds.\n\n    bool public openToPublic;  // Boolean opening Pool to public for LP deposits\n\n    enum State { Initialized, Finalized, Deactivated }\n    State public poolState;\n\n    mapping(address => uint256)                     public depositDate;                // Used for withdraw penalty calculation.\n    mapping(address => mapping(address => address)) public debtLockers;                // Address of the DebtLocker corresponding to `[Loan][DebtLockerFactory]`.\n    mapping(address => bool)                        public poolAdmins;                 // The Pool Admin addresses that have permission to do certain operations in case of disaster management.\n    mapping(address => bool)                        public allowedLiquidityProviders;  // Mapping that contains the list of addresses that have early access to the pool.\n    mapping(address => uint256)                     public withdrawCooldown;           // The timestamp of when individual LPs have notified of their intent to withdraw.\n    mapping(address => mapping(address => uint256)) public custodyAllowance;           // The amount of PoolFDTs that are \"locked\" at a certain address.\n    mapping(address => uint256)                     public totalCustodyAllowance;      // The total amount of PoolFDTs that are \"locked\" for a given account. Cannot be greater than an account's balance.\n\n    event                   LoanFunded(address indexed loan, address debtLocker, uint256 amountFunded);\n    event                        Claim(address indexed loan, uint256 interest, uint256 principal, uint256 fee, uint256 stakeLockerPortion, uint256 poolDelegatePortion);\n    event               BalanceUpdated(address indexed liquidityProvider, address indexed token, uint256 balance);\n    event              CustodyTransfer(address indexed custodian, address indexed from, address indexed to, uint256 amount);\n    event      CustodyAllowanceChanged(address indexed liquidityProvider, address indexed custodian, uint256 oldAllowance, uint256 newAllowance);\n    event              LPStatusChanged(address indexed liquidityProvider, bool status);\n    event              LiquidityCapSet(uint256 newLiquidityCap);\n    event              LockupPeriodSet(uint256 newLockupPeriod);\n    event                StakingFeeSet(uint256 newStakingFee);\n    event             PoolStateChanged(State state);\n    event                     Cooldown(address indexed liquidityProvider, uint256 cooldown);\n    event           PoolOpenedToPublic(bool isOpen);\n    event                 PoolAdminSet(address indexed poolAdmin, bool allowed);\n    event           DepositDateUpdated(address indexed liquidityProvider, uint256 depositDate);\n    event TotalCustodyAllowanceUpdated(address indexed liquidityProvider, uint256 newTotalAllowance);\n    \n    event DefaultSuffered(\n        address indexed loan,\n        uint256 defaultSuffered,\n        uint256 bptsBurned,\n        uint256 bptsReturned,\n        uint256 liquidityAssetRecoveredFromBurn\n    );\n\n    /**\n        Universal accounting law:\n                                       fdtTotalSupply = liquidityLockerBal + principalOut - interestSum + poolLosses\n            fdtTotalSupply + interestSum - poolLosses = liquidityLockerBal + principalOut\n    */\n\n    /**\n        @dev   Constructor for a Pool.\n        @dev   It emits a `PoolStateChanged` event.\n        @param _poolDelegate   Address that has manager privileges of the Pool.\n        @param _liquidityAsset Asset used to fund the Pool, It gets escrowed in LiquidityLocker.\n        @param _stakeAsset     Asset escrowed in StakeLocker.\n        @param _slFactory      Factory used to instantiate the StakeLocker.\n        @param _llFactory      Factory used to instantiate the LiquidityLocker.\n        @param _stakingFee     Fee that Stakers earn on interest, in basis points.\n        @param _delegateFee    Fee that the Pool Delegate earns on interest, in basis points.\n        @param _liquidityCap   Max amount of Liquidity Asset accepted by the Pool.\n        @param name            Name of Pool token.\n        @param symbol          Symbol of Pool token.\n    */\n    constructor(\n        address _poolDelegate,\n        address _liquidityAsset,\n        address _stakeAsset,\n        address _slFactory,\n        address _llFactory,\n        uint256 _stakingFee,\n        uint256 _delegateFee,\n        uint256 _liquidityCap,\n        string memory name,\n        string memory symbol\n    ) PoolFDT(name, symbol) public {\n\n        // Conduct sanity checks on Pool parameters.\n        PoolLib.poolSanityChecks(_globals(msg.sender), _liquidityAsset, _stakeAsset, _stakingFee, _delegateFee);\n\n        // Assign variables relating to the Liquidity Asset.\n        liquidityAsset         = IERC20(_liquidityAsset);\n        liquidityAssetDecimals = ERC20(_liquidityAsset).decimals();\n\n        // Assign state variables.\n        stakeAsset   = _stakeAsset;\n        poolDelegate = _poolDelegate;\n        stakingFee   = _stakingFee;\n        delegateFee  = _delegateFee;\n        superFactory = msg.sender;\n        liquidityCap = _liquidityCap;\n\n        // Instantiate the LiquidityLocker and the StakeLocker.\n        stakeLocker     = address(IStakeLockerFactory(_slFactory).newLocker(_stakeAsset, _liquidityAsset));\n        liquidityLocker = address(ILiquidityLockerFactory(_llFactory).newLocker(_liquidityAsset));\n\n        lockupPeriod = 180 days;\n\n        emit PoolStateChanged(State.Initialized);\n    }\n\n    /*******************************/\n    /*** Pool Delegate Functions ***/\n    /*******************************/\n\n    /**\n        @dev Finalizes the Pool, enabling deposits. Checks the amount the Pool Delegate deposited to the StakeLocker.\n             Only the Pool Delegate can call this function.\n        @dev It emits a `PoolStateChanged` event.\n    */\n    function finalize() external {\n        _isValidDelegateAndProtocolNotPaused();\n        _isValidState(State.Initialized);\n        (,, bool stakeSufficient,,) = getInitialStakeRequirements();\n        require(stakeSufficient, \"P:INSUF_STAKE\");\n        poolState = State.Finalized;\n        emit PoolStateChanged(poolState);\n    }\n\n    /**\n        @dev   Funds a Loan for an amount, utilizing the supplied DebtLockerFactory for DebtLockers.\n               Only the Pool Delegate can call this function.\n        @dev   It emits a `LoanFunded` event.\n        @dev   It emits a `BalanceUpdated` event.\n        @param loan      Address of the Loan to fund.\n        @param dlFactory Address of the DebtLockerFactory to utilize.\n        @param amt       Amount to fund the Loan.\n    */\n    function fundLoan(address loan, address dlFactory, uint256 amt) external {\n        _isValidDelegateAndProtocolNotPaused();\n        _isValidState(State.Finalized);\n        principalOut = principalOut.add(amt);\n        PoolLib.fundLoan(debtLockers, superFactory, liquidityLocker, loan, dlFactory, amt);\n        _emitBalanceUpdatedEvent();\n    }\n\n    /**\n        @dev   Liquidates a Loan. The Pool Delegate could liquidate the Loan only when the Loan completes its grace period.\n               The Pool Delegate can claim its proportion of recovered funds from the liquidation using the `claim()` function.\n               Only the Pool Delegate can call this function.\n        @param loan      Address of the Loan to liquidate.\n        @param dlFactory Address of the DebtLockerFactory that is used to pull corresponding DebtLocker.\n    */\n    function triggerDefault(address loan, address dlFactory) external {\n        _isValidDelegateAndProtocolNotPaused();\n        IDebtLocker(debtLockers[loan][dlFactory]).triggerDefault();\n    }\n\n    /**\n        @dev    Claims available funds for the Loan through a specified DebtLockerFactory. Only the Pool Delegate or a Pool Admin can call this function.\n        @dev    It emits two `BalanceUpdated` events.\n        @dev    It emits a `Claim` event.\n        @param  loan      Address of the loan to claim from.\n        @param  dlFactory Address of the DebtLockerFactory.\n        @return claimInfo The claim details.\n                    claimInfo [0] = Total amount claimed\n                    claimInfo [1] = Interest  portion claimed\n                    claimInfo [2] = Principal portion claimed\n                    claimInfo [3] = Fee       portion claimed\n                    claimInfo [4] = Excess    portion claimed\n                    claimInfo [5] = Recovered portion claimed (from liquidations)\n                    claimInfo [6] = Default suffered\n    */\n    function claim(address loan, address dlFactory) external returns (uint256[7] memory claimInfo) {\n        _whenProtocolNotPaused();\n        _isValidDelegateOrPoolAdmin();\n        claimInfo = IDebtLocker(debtLockers[loan][dlFactory]).claim();\n\n        (uint256 poolDelegatePortion, uint256 stakeLockerPortion, uint256 principalClaim, uint256 interestClaim) = PoolLib.calculateClaimAndPortions(claimInfo, delegateFee, stakingFee);\n\n        // Subtract outstanding principal by the principal claimed plus excess returned.\n        // Considers possible `principalClaim` overflow if Liquidity Asset is transferred directly into the Loan.\n        if (principalClaim <= principalOut) {\n            principalOut = principalOut - principalClaim;\n        } else {\n            interestClaim  = interestClaim.add(principalClaim - principalOut);  // Distribute `principalClaim` overflow as interest to LPs.\n            principalClaim = principalOut;                                      // Set `principalClaim` to `principalOut` so correct amount gets transferred.\n            principalOut   = 0;                                                 // Set `principalOut` to zero to avoid subtraction overflow.\n        }\n\n        // Accounts for rounding error in StakeLocker / Pool Delegate / LiquidityLocker interest split.\n        interestSum = interestSum.add(interestClaim);\n\n        _transferLiquidityAsset(poolDelegate, poolDelegatePortion);  // Transfer the fee and portion of interest to the Pool Delegate.\n        _transferLiquidityAsset(stakeLocker,  stakeLockerPortion);   // Transfer the portion of interest to the StakeLocker.\n\n        // Transfer remaining claim (remaining interest + principal + excess + recovered) to the LiquidityLocker.\n        // Dust will accrue in the Pool, but this ensures that state variables are in sync with the LiquidityLocker balance updates.\n        // Not using `balanceOf` in case of external address transferring the Liquidity Asset directly into Pool.\n        // Ensures that internal accounting is exactly reflective of balance change.\n        _transferLiquidityAsset(liquidityLocker, principalClaim.add(interestClaim));\n\n        // Handle default if defaultSuffered > 0.\n        if (claimInfo[6] > 0) _handleDefault(loan, claimInfo[6]);\n\n        // Update funds received for StakeLockerFDTs.\n        IStakeLocker(stakeLocker).updateFundsReceived();\n\n        // Update funds received for PoolFDTs.\n        updateFundsReceived();\n\n        _emitBalanceUpdatedEvent();\n        emit BalanceUpdated(stakeLocker, address(liquidityAsset), liquidityAsset.balanceOf(stakeLocker));\n\n        emit Claim(loan, interestClaim, principalClaim, claimInfo[3], stakeLockerPortion, poolDelegatePortion);\n    }\n\n    /**\n        @dev   Handles if a claim has been made and there is a non-zero defaultSuffered amount.\n        @dev   It emits a `DefaultSuffered` event.\n        @param loan            Address of a Loan that has defaulted.\n        @param defaultSuffered Losses suffered from default after liquidation.\n    */\n    function _handleDefault(address loan, uint256 defaultSuffered) internal {\n\n        (uint256 bptsBurned, uint256 postBurnBptBal, uint256 liquidityAssetRecoveredFromBurn) = PoolLib.handleDefault(liquidityAsset, stakeLocker, stakeAsset, defaultSuffered);\n\n        // If BPT burn is not enough to cover full default amount, pass on losses to LPs with PoolFDT loss accounting.\n        if (defaultSuffered > liquidityAssetRecoveredFromBurn) {\n            poolLosses = poolLosses.add(defaultSuffered - liquidityAssetRecoveredFromBurn);\n            updateLossesReceived();\n        }\n\n        // Transfer Liquidity Asset from burn to LiquidityLocker.\n        liquidityAsset.safeTransfer(liquidityLocker, liquidityAssetRecoveredFromBurn);\n\n        principalOut = principalOut.sub(defaultSuffered);  // Subtract rest of the Loan's principal from `principalOut`.\n\n        emit DefaultSuffered(\n            loan,                            // The Loan that suffered the default.\n            defaultSuffered,                 // Total default suffered from the Loan by the Pool after liquidation.\n            bptsBurned,                      // Amount of BPTs burned from StakeLocker.\n            postBurnBptBal,                  // Remaining BPTs in StakeLocker post-burn.\n            liquidityAssetRecoveredFromBurn  // Amount of Liquidity Asset recovered from burning BPTs.\n        );\n    }\n\n    /**\n        @dev Triggers deactivation, permanently shutting down the Pool. Must have less than 100 USD worth of Liquidity Asset `principalOut`.\n             Only the Pool Delegate can call this function.\n        @dev It emits a `PoolStateChanged` event.\n    */\n    function deactivate() external {\n        _isValidDelegateAndProtocolNotPaused();\n        _isValidState(State.Finalized);\n        PoolLib.validateDeactivation(_globals(superFactory), principalOut, address(liquidityAsset));\n        poolState = State.Deactivated;\n        emit PoolStateChanged(poolState);\n    }\n\n    /**************************************/\n    /*** Pool Delegate Setter Functions ***/\n    /**************************************/\n\n    /**\n        @dev   Sets the liquidity cap. Only the Pool Delegate or a Pool Admin can call this function.\n        @dev   It emits a `LiquidityCapSet` event.\n        @param newLiquidityCap New liquidity cap value.\n    */\n    function setLiquidityCap(uint256 newLiquidityCap) external {\n        _whenProtocolNotPaused();\n        _isValidDelegateOrPoolAdmin();\n        liquidityCap = newLiquidityCap;\n        emit LiquidityCapSet(newLiquidityCap);\n    }\n\n    /**\n        @dev   Sets the lockup period. Only the Pool Delegate can call this function.\n        @dev   It emits a `LockupPeriodSet` event.\n        @param newLockupPeriod New lockup period used to restrict the withdrawals.\n    */\n    function setLockupPeriod(uint256 newLockupPeriod) external {\n        _isValidDelegateAndProtocolNotPaused();\n        require(newLockupPeriod <= lockupPeriod, \"P:BAD_VALUE\");\n        lockupPeriod = newLockupPeriod;\n        emit LockupPeriodSet(newLockupPeriod);\n    }\n\n    /**\n        @dev   Sets the staking fee. Only the Pool Delegate can call this function.\n        @dev   It emits a `StakingFeeSet` event.\n        @param newStakingFee New staking fee.\n    */\n    function setStakingFee(uint256 newStakingFee) external {\n        _isValidDelegateAndProtocolNotPaused();\n        require(newStakingFee.add(delegateFee) <= 10_000, \"P:BAD_FEE\");\n        stakingFee = newStakingFee;\n        emit StakingFeeSet(newStakingFee);\n    }\n\n    /**\n        @dev   Sets the account status in the Pool's allowlist. Only the Pool Delegate can call this function.\n        @dev   It emits an `LPStatusChanged` event.\n        @param account The address to set status for.\n        @param status  The status of an account in the allowlist.\n    */\n    function setAllowList(address account, bool status) external {\n        _isValidDelegateAndProtocolNotPaused();\n        allowedLiquidityProviders[account] = status;\n        emit LPStatusChanged(account, status);\n    }\n\n    /**\n        @dev   Sets a Pool Admin. Only the Pool Delegate can call this function.\n        @dev   It emits a `PoolAdminSet` event.\n        @param poolAdmin An address being allowed or disallowed as a Pool Admin.\n        @param allowed Status of a Pool Admin.\n    */\n    function setPoolAdmin(address poolAdmin, bool allowed) external {\n        _isValidDelegateAndProtocolNotPaused();\n        poolAdmins[poolAdmin] = allowed;\n        emit PoolAdminSet(poolAdmin, allowed);\n    }\n\n    /**\n        @dev   Sets whether the Pool is open to the public. Only the Pool Delegate can call this function.\n        @dev   It emits a `PoolOpenedToPublic` event.\n        @param open Public pool access status.\n    */\n    function setOpenToPublic(bool open) external {\n        _isValidDelegateAndProtocolNotPaused();\n        openToPublic = open;\n        emit PoolOpenedToPublic(open);\n    }\n\n    /************************************/\n    /*** Liquidity Provider Functions ***/\n    /************************************/\n\n    /**\n        @dev   Handles Liquidity Providers depositing of Liquidity Asset into the LiquidityLocker, minting PoolFDTs.\n        @dev   It emits a `DepositDateUpdated` event.\n        @dev   It emits a `BalanceUpdated` event.\n        @dev   It emits a `Cooldown` event.\n        @param amt Amount of Liquidity Asset to deposit.\n    */\n    function deposit(uint256 amt) external {\n        _whenProtocolNotPaused();\n        _isValidState(State.Finalized);\n        require(isDepositAllowed(amt), \"P:DEP_NOT_ALLOWED\");\n\n        withdrawCooldown[msg.sender] = uint256(0);  // Reset the LP's withdraw cooldown if they had previously intended to withdraw.\n\n        uint256 wad = _toWad(amt);\n        PoolLib.updateDepositDate(depositDate, balanceOf(msg.sender), wad, msg.sender);\n\n        liquidityAsset.safeTransferFrom(msg.sender, liquidityLocker, amt);\n        _mint(msg.sender, wad);\n\n        _emitBalanceUpdatedEvent();\n        emit Cooldown(msg.sender, uint256(0));\n    }\n\n    /**\n        @dev Activates the cooldown period to withdraw. It can't be called if the account is not providing liquidity.\n        @dev It emits a `Cooldown` event.\n    **/\n    function intendToWithdraw() external {\n        require(balanceOf(msg.sender) != uint256(0), \"P:ZERO_BAL\");\n        withdrawCooldown[msg.sender] = block.timestamp;\n        emit Cooldown(msg.sender, block.timestamp);\n    }\n\n    /**\n        @dev Cancels an initiated withdrawal by resetting the account's withdraw cooldown.\n        @dev It emits a `Cooldown` event.\n    **/\n    function cancelWithdraw() external {\n        require(withdrawCooldown[msg.sender] != uint256(0), \"P:NOT_WITHDRAWING\");\n        withdrawCooldown[msg.sender] = uint256(0);\n        emit Cooldown(msg.sender, uint256(0));\n    }\n\n    /**\n        @dev   Checks that the account can withdraw an amount.\n        @param account The address of the account.\n        @param wad     The amount to withdraw.\n    */\n    function _canWithdraw(address account, uint256 wad) internal view {\n        require(depositDate[account].add(lockupPeriod) <= block.timestamp,     \"P:FUNDS_LOCKED\");     // Restrict withdrawal during lockup period\n        require(balanceOf(account).sub(wad) >= totalCustodyAllowance[account], \"P:INSUF_TRANS_BAL\");  // Account can only withdraw tokens that aren't custodied\n    }\n\n    /**\n        @dev   Handles Liquidity Providers withdrawing of Liquidity Asset from the LiquidityLocker, burning PoolFDTs.\n        @dev   It emits two `BalanceUpdated` event.\n        @param amt Amount of Liquidity Asset to withdraw.\n    */\n    function withdraw(uint256 amt) external {\n        _whenProtocolNotPaused();\n        uint256 wad = _toWad(amt);\n        (uint256 lpCooldownPeriod, uint256 lpWithdrawWindow) = _globals(superFactory).getLpCooldownParams();\n\n        _canWithdraw(msg.sender, wad);\n        require((block.timestamp - (withdrawCooldown[msg.sender] + lpCooldownPeriod)) <= lpWithdrawWindow, \"P:WITHDRAW_NOT_ALLOWED\");\n\n        _burn(msg.sender, wad);  // Burn the corresponding PoolFDTs balance.\n        withdrawFunds();         // Transfer full entitled interest, decrement `interestSum`.\n\n        // Transfer amount that is due after realized losses are accounted for.\n        // Recognized losses are absorbed by the LP.\n        _transferLiquidityLockerFunds(msg.sender, amt.sub(_recognizeLosses()));\n\n        _emitBalanceUpdatedEvent();\n    }\n\n    /**\n        @dev   Transfers PoolFDTs.\n        @param from Address sending   PoolFDTs.\n        @param to   Address receiving PoolFDTs.\n        @param wad  Amount of PoolFDTs to transfer.\n    */\n    function _transfer(address from, address to, uint256 wad) internal override {\n        _whenProtocolNotPaused();\n\n        (uint256 lpCooldownPeriod, uint256 lpWithdrawWindow) = _globals(superFactory).getLpCooldownParams();\n\n        _canWithdraw(from, wad);\n        require(block.timestamp > (withdrawCooldown[to] + lpCooldownPeriod + lpWithdrawWindow), \"P:TO_NOT_ALLOWED\");  // Recipient must not be currently withdrawing.\n        require(recognizableLossesOf(from) == uint256(0),                                       \"P:RECOG_LOSSES\");    // If an LP has unrecognized losses, they must recognize losses using `withdraw`.\n\n        PoolLib.updateDepositDate(depositDate, balanceOf(to), wad, to);\n        super._transfer(from, to, wad);\n    }\n\n    /**\n        @dev Withdraws all claimable interest from the LiquidityLocker for an account using `interestSum` accounting.\n        @dev It emits a `BalanceUpdated` event.\n    */\n    function withdrawFunds() public override {\n        _whenProtocolNotPaused();\n        uint256 withdrawableFunds = _prepareWithdraw();\n\n        if (withdrawableFunds == uint256(0)) return;\n\n        _transferLiquidityLockerFunds(msg.sender, withdrawableFunds);\n        _emitBalanceUpdatedEvent();\n\n        interestSum = interestSum.sub(withdrawableFunds);\n\n        _updateFundsTokenBalance();\n    }\n\n    /**\n        @dev   Increases the custody allowance for a given Custodian corresponding to the calling account (`msg.sender`).\n        @dev   It emits a `CustodyAllowanceChanged` event.\n        @dev   It emits a `TotalCustodyAllowanceUpdated` event.\n        @param custodian Address which will act as Custodian of a given amount for an account.\n        @param amount    Number of additional FDTs to be custodied by the Custodian.\n    */\n    function increaseCustodyAllowance(address custodian, uint256 amount) external {\n        uint256 oldAllowance      = custodyAllowance[msg.sender][custodian];\n        uint256 newAllowance      = oldAllowance.add(amount);\n        uint256 newTotalAllowance = totalCustodyAllowance[msg.sender].add(amount);\n\n        PoolLib.increaseCustodyAllowanceChecks(custodian, amount, newTotalAllowance, balanceOf(msg.sender));\n\n        custodyAllowance[msg.sender][custodian] = newAllowance;\n        totalCustodyAllowance[msg.sender]       = newTotalAllowance;\n        emit CustodyAllowanceChanged(msg.sender, custodian, oldAllowance, newAllowance);\n        emit TotalCustodyAllowanceUpdated(msg.sender, newTotalAllowance);\n    }\n\n    /**\n        @dev   Transfers custodied PoolFDTs back to the account.\n        @dev   `from` and `to` should always be equal in this implementation.\n        @dev   This means that the Custodian can only decrease their own allowance and unlock funds for the original owner.\n        @dev   It emits a `CustodyTransfer` event.\n        @dev   It emits a `CustodyAllowanceChanged` event.\n        @dev   It emits a `TotalCustodyAllowanceUpdated` event.\n        @param from   Address which holds the PoolFDTs.\n        @param to     Address which will be the new owner of the amount of PoolFDTs.\n        @param amount Amount of PoolFDTs transferred.\n    */\n    function transferByCustodian(address from, address to, uint256 amount) external {\n        uint256 oldAllowance = custodyAllowance[from][msg.sender];\n        uint256 newAllowance = oldAllowance.sub(amount);\n\n        PoolLib.transferByCustodianChecks(from, to, amount);\n\n        custodyAllowance[from][msg.sender] = newAllowance;\n        uint256 newTotalAllowance          = totalCustodyAllowance[from].sub(amount);\n        totalCustodyAllowance[from]        = newTotalAllowance;\n        emit CustodyTransfer(msg.sender, from, to, amount);\n        emit CustodyAllowanceChanged(from, msg.sender, oldAllowance, newAllowance);\n        emit TotalCustodyAllowanceUpdated(msg.sender, newTotalAllowance);\n    }\n\n    /**************************/\n    /*** Governor Functions ***/\n    /**************************/\n\n    /**\n        @dev   Transfers any locked funds to the Governor. Only the Governor can call this function.\n        @param token Address of the token to be reclaimed.\n    */\n    function reclaimERC20(address token) external {\n        PoolLib.reclaimERC20(token, address(liquidityAsset), _globals(superFactory));\n    }\n\n    /*************************/\n    /*** Getter Functions ***/\n    /*************************/\n\n    /**\n        @dev    Calculates the value of BPT in units of Liquidity Asset.\n        @param  _bPool          Address of Balancer pool.\n        @param  _liquidityAsset Asset used by Pool for liquidity to fund Loans.\n        @param  _staker         Address that deposited BPTs to StakeLocker.\n        @param  _stakeLocker    Escrows BPTs deposited by Staker.\n        @return USDC value of staker BPTs.\n    */\n    function BPTVal(\n        address _bPool,\n        address _liquidityAsset,\n        address _staker,\n        address _stakeLocker\n    ) external view returns (uint256) {\n        return PoolLib.BPTVal(_bPool, _liquidityAsset, _staker, _stakeLocker);\n    }\n\n    /**\n        @dev   Checks that the given deposit amount is acceptable based on current liquidityCap.\n        @param depositAmt Amount of tokens (i.e liquidityAsset type) the account is trying to deposit.\n    */\n    function isDepositAllowed(uint256 depositAmt) public view returns (bool) {\n        return (openToPublic || allowedLiquidityProviders[msg.sender]) &&\n               _balanceOfLiquidityLocker().add(principalOut).add(depositAmt) <= liquidityCap;\n    }\n\n    /**\n        @dev    Returns information on the stake requirements.\n        @return [0] = Min amount of Liquidity Asset coverage from staking required.\n                [1] = Present amount of Liquidity Asset coverage from the Pool Delegate stake.\n                [2] = If enough stake is present from the Pool Delegate for finalization.\n                [3] = Staked BPTs required for minimum Liquidity Asset coverage.\n                [4] = Current staked BPTs.\n    */\n    function getInitialStakeRequirements() public view returns (uint256, uint256, bool, uint256, uint256) {\n        return PoolLib.getInitialStakeRequirements(_globals(superFactory), stakeAsset, address(liquidityAsset), poolDelegate, stakeLocker);\n    }\n\n    /**\n        @dev    Calculates BPTs required if burning BPTs for the Liquidity Asset, given supplied `tokenAmountOutRequired`.\n        @param  _bPool                        The Balancer pool that issues the BPTs.\n        @param  _liquidityAsset               Swap out asset (e.g. USDC) to receive when burning BPTs.\n        @param  _staker                       Address that deposited BPTs to StakeLocker.\n        @param  _stakeLocker                  Escrows BPTs deposited by Staker.\n        @param  _liquidityAssetAmountRequired Amount of Liquidity Asset required to recover.\n        @return [0] = poolAmountIn required.\n                [1] = poolAmountIn currently staked.\n    */\n    function getPoolSharesRequired(\n        address _bPool,\n        address _liquidityAsset,\n        address _staker,\n        address _stakeLocker,\n        uint256 _liquidityAssetAmountRequired\n    ) external view returns (uint256, uint256) {\n        return PoolLib.getPoolSharesRequired(_bPool, _liquidityAsset, _staker, _stakeLocker, _liquidityAssetAmountRequired);\n    }\n\n    /**\n      @dev    Checks that the Pool state is `Finalized`.\n      @return bool Boolean value indicating if Pool is in a Finalized state.\n    */\n    function isPoolFinalized() external view returns (bool) {\n        return poolState == State.Finalized;\n    }\n\n    /************************/\n    /*** Helper Functions ***/\n    /************************/\n\n    /**\n        @dev   Converts to WAD precision.\n        @param amt Amount to convert.\n    */\n    function _toWad(uint256 amt) internal view returns (uint256) {\n        return amt.mul(WAD).div(10 ** liquidityAssetDecimals);\n    }\n\n    /**\n        @dev    Returns the balance of this Pool's LiquidityLocker.\n        @return Balance of LiquidityLocker.\n    */\n    function _balanceOfLiquidityLocker() internal view returns (uint256) {\n        return liquidityAsset.balanceOf(liquidityLocker);\n    }\n\n    /**\n        @dev   Checks that the current state of Pool matches the provided state.\n        @param _state Enum of desired Pool state.\n    */\n    function _isValidState(State _state) internal view {\n        require(poolState == _state, \"P:BAD_STATE\");\n    }\n\n    /**\n        @dev Checks that `msg.sender` is the Pool Delegate.\n    */\n    function _isValidDelegate() internal view {\n        require(msg.sender == poolDelegate, \"P:NOT_DEL\");\n    }\n\n    /**\n        @dev Returns the MapleGlobals instance.\n    */\n    function _globals(address poolFactory) internal view returns (IMapleGlobals) {\n        return IMapleGlobals(IPoolFactory(poolFactory).globals());\n    }\n\n    /**\n        @dev Emits a `BalanceUpdated` event for LiquidityLocker.\n        @dev It emits a `BalanceUpdated` event.\n    */\n    function _emitBalanceUpdatedEvent() internal {\n        emit BalanceUpdated(liquidityLocker, address(liquidityAsset), _balanceOfLiquidityLocker());\n    }\n\n    /**\n        @dev   Transfers Liquidity Asset to given `to` address, from self (i.e. `address(this)`).\n        @param to    Address to transfer liquidityAsset.\n        @param value Amount of liquidity asset that gets transferred.\n    */\n    function _transferLiquidityAsset(address to, uint256 value) internal {\n        liquidityAsset.safeTransfer(to, value);\n    }\n\n    /**\n        @dev Checks that `msg.sender` is the Pool Delegate or a Pool Admin.\n    */\n    function _isValidDelegateOrPoolAdmin() internal view {\n        require(msg.sender == poolDelegate || poolAdmins[msg.sender], \"P:NOT_DEL_OR_ADMIN\");\n    }\n\n    /**\n        @dev Checks that the protocol is not in a paused state.\n    */\n    function _whenProtocolNotPaused() internal view {\n        require(!_globals(superFactory).protocolPaused(), \"P:PROTO_PAUSED\");\n    }\n\n    /**\n        @dev Checks that `msg.sender` is the Pool Delegate and that the protocol is not in a paused state.\n    */\n    function _isValidDelegateAndProtocolNotPaused() internal view {\n        _isValidDelegate();\n        _whenProtocolNotPaused();\n    }\n\n    function _transferLiquidityLockerFunds(address to, uint256 value) internal {\n        ILiquidityLocker(liquidityLocker).transfer(to, value);\n    }\n\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolDelegate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidityAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakeAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_slFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_llFactory\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_delegateFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityCap\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"BalanceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"loan\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeLockerPortion\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolDelegatePortion\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cooldown\",\"type\":\"uint256\"}],\"name\":\"Cooldown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"custodian\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldAllowance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAllowance\",\"type\":\"uint256\"}],\"name\":\"CustodyAllowanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"custodian\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CustodyTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"loan\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"defaultSuffered\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bptsBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bptsReturned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityAssetRecoveredFromBurn\",\"type\":\"uint256\"}],\"name\":\"DefaultSuffered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositDate\",\"type\":\"uint256\"}],\"name\":\"DepositDateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fundsDistributed\",\"type\":\"uint256\"}],\"name\":\"FundsDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fundsWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"LPStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLiquidityCap\",\"type\":\"uint256\"}],\"name\":\"LiquidityCapSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"loan\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"debtLocker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountFunded\",\"type\":\"uint256\"}],\"name\":\"LoanFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLockupPeriod\",\"type\":\"uint256\"}],\"name\":\"LockupPeriodSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"lossesCorrection\",\"type\":\"int256\"}],\"name\":\"LossesCorrectionUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lossesDistributed\",\"type\":\"uint256\"}],\"name\":\"LossesDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lossesPerShare\",\"type\":\"uint256\"}],\"name\":\"LossesPerShareUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lossesRecognized\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalLossesRecognized\",\"type\":\"uint256\"}],\"name\":\"LossesRecognized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"pointsCorrection\",\"type\":\"int256\"}],\"name\":\"PointsCorrectionUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pointsPerShare\",\"type\":\"uint256\"}],\"name\":\"PointsPerShareUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"PoolAdminSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"name\":\"PoolOpenedToPublic\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum Pool.State\",\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"PoolStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newStakingFee\",\"type\":\"uint256\"}],\"name\":\"StakingFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalAllowance\",\"type\":\"uint256\"}],\"name\":\"TotalCustodyAllowanceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidityAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakeLocker\",\"type\":\"address\"}],\"name\":\"BPTVal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DL_FACTORY\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"accumulativeFundsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"accumulativeLossesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedLiquidityProviders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"loan\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dlFactory\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256[7]\",\"name\":\"claimInfo\",\"type\":\"uint256[7]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"custodyAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deactivate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"debtLockers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delegateFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"loan\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dlFactory\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"fundLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInitialStakeRequirements\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidityAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakeLocker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityAssetAmountRequired\",\"type\":\"uint256\"}],\"name\":\"getPoolSharesRequired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"custodian\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseCustodyAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"intendToWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositAmt\",\"type\":\"uint256\"}],\"name\":\"isDepositAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPoolFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityAsset\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityLocker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockupPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lossesBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openToPublic\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolAdmins\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolDelegate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLosses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolState\",\"outputs\":[{\"internalType\":\"enum Pool.State\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"principalOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"reclaimERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"recognizableLossesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"recognizedLossesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setAllowList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLiquidityCap\",\"type\":\"uint256\"}],\"name\":\"setLiquidityCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLockupPeriod\",\"type\":\"uint256\"}],\"name\":\"setLockupPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"}],\"name\":\"setOpenToPublic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAdmin\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setPoolAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newStakingFee\",\"type\":\"uint256\"}],\"name\":\"setStakingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeLocker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"superFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalCustodyAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferByCustodian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"loan\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dlFactory\",\"type\":\"address\"}],\"name\":\"triggerDefault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateFundsReceived\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateLossesReceived\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawCooldown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"withdrawableFundsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"withdrawnFundsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Pool", "CompilerVersion": "v0.6.11+commit.5ef660b1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000990d11977378d4610776e6646b2caae543ea4eda000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000030b705bfa64be9ae395bd9238efc63e9f5f8d1cc00000000000000000000000053a597a4730eb02095dd798b203dcc306348b8d6000000000000000000000000966528bb1c44f96b3aa8fbf411ee896116b068c900000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000003e80000000000000000000000000000000000000000000001bc85dc2a89bb2000000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000000104d61706c6520506f6f6c20546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000064d504c2d4c500000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "PoolLib:2c1c30fb8cc313ef3cfd2e2bbf2da88add902c30", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}