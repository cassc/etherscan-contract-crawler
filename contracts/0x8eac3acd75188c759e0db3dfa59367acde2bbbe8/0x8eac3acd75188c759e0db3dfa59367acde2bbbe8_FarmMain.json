{"SourceCode": "// File: contracts\\amm-aggregator\\common\\AMMData.sol\r\n\r\n//SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.6;\r\n\r\nstruct LiquidityPoolData {\r\n    address liquidityPoolAddress;\r\n    uint256 amount;\r\n    address tokenAddress;\r\n    bool amountIsLiquidityPool;\r\n    bool involvingETH;\r\n    address receiver;\r\n}\r\n\r\nstruct SwapData {\r\n    bool enterInETH;\r\n    bool exitInETH;\r\n    address[] liquidityPoolAddresses;\r\n    address[] path;\r\n    address inputToken;\r\n    uint256 amount;\r\n    address receiver;\r\n}\r\n\r\n// File: contracts\\amm-aggregator\\common\\IAMM.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\npragma solidity ^0.7.6;\r\npragma abicoder v2;\r\n\r\n\r\ninterface IAMM {\r\n\r\n    event NewLiquidityPoolAddress(address indexed);\r\n\r\n    function info() external view returns(string memory name, uint256 version);\r\n\r\n    function data() external view returns(address ethereumAddress, uint256 maxTokensPerLiquidityPool, bool hasUniqueLiquidityPools);\r\n\r\n    function balanceOf(address liquidityPoolAddress, address owner) external view returns(uint256, uint256[] memory, address[] memory);\r\n\r\n    function byLiquidityPool(address liquidityPoolAddress) external view returns(uint256, uint256[] memory, address[] memory);\r\n\r\n    function byTokens(address[] calldata liquidityPoolTokens) external view returns(uint256, uint256[] memory, address, address[] memory);\r\n\r\n    function byPercentage(address liquidityPoolAddress, uint256 numerator, uint256 denominator) external view returns (uint256, uint256[] memory, address[] memory);\r\n\r\n    function byLiquidityPoolAmount(address liquidityPoolAddress, uint256 liquidityPoolAmount) external view returns(uint256[] memory, address[] memory);\r\n\r\n    function byTokenAmount(address liquidityPoolAddress, address tokenAddress, uint256 tokenAmount) external view returns(uint256, uint256[] memory, address[] memory);\r\n\r\n    function createLiquidityPoolAndAddLiquidity(address[] calldata tokenAddresses, uint256[] calldata amounts, bool involvingETH, address receiver) external payable returns(uint256, uint256[] memory, address, address[] memory);\r\n\r\n    function addLiquidity(LiquidityPoolData calldata data) external payable returns(uint256, uint256[] memory, address[] memory);\r\n    function addLiquidityBatch(LiquidityPoolData[] calldata data) external payable returns(uint256[] memory, uint256[][] memory, address[][] memory);\r\n\r\n    function removeLiquidity(LiquidityPoolData calldata data) external returns(uint256, uint256[] memory, address[] memory);\r\n    function removeLiquidityBatch(LiquidityPoolData[] calldata data) external returns(uint256[] memory, uint256[][] memory, address[][] memory);\r\n\r\n    function getSwapOutput(address tokenAddress, uint256 tokenAmount, address[] calldata, address[] calldata path) view external returns(uint256[] memory);\r\n\r\n    function swapLiquidity(SwapData calldata data) external payable returns(uint256);\r\n    function swapLiquidityBatch(SwapData[] calldata data) external payable returns(uint256[] memory);\r\n}\r\n\r\n// File: contracts\\farming\\FarmData.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\npragma solidity ^0.7.6;\r\n\r\nstruct FarmingPositionRequest {\r\n    uint256 setupIndex; // index of the chosen setup.\r\n    uint256 amount; // amount of main token or liquidity pool token.\r\n    bool amountIsLiquidityPool; //true if user wants to directly share the liquidity pool token amount, false to add liquidity to AMM\r\n    address positionOwner; // position extension or address(0) [msg.sender].\r\n}\r\n\r\nstruct FarmingSetupConfiguration {\r\n    bool add; // true if we're adding a new setup, false we're updating it.\r\n    bool disable;\r\n    uint256 index; // index of the setup we're updating.\r\n    FarmingSetupInfo info; // data of the new or updated setup\r\n}\r\n\r\nstruct FarmingSetupInfo {\r\n    bool free; // if the setup is a free farming setup or a locked one.\r\n    uint256 blockDuration; // duration of setup\r\n    uint256 originalRewardPerBlock;\r\n    uint256 minStakeable; // minimum amount of staking tokens.\r\n    uint256 maxStakeable; // maximum amount stakeable in the setup (used only if free is false).\r\n    uint256 renewTimes; // if the setup is renewable or if it's one time.\r\n    address ammPlugin; // amm plugin address used for this setup (eg. uniswap amm plugin address).\r\n    address liquidityPoolTokenAddress; // address of the liquidity pool token\r\n    address mainTokenAddress; // eg. buidl address.\r\n    address ethereumAddress;\r\n    bool involvingETH; // if the setup involves ETH or not.\r\n    uint256 penaltyFee; // fee paid when the user exits a still active locked farming setup (used only if free is false).\r\n    uint256 setupsCount; // number of setups created by this info.\r\n    uint256 lastSetupIndex; // index of last setup;\r\n}\r\n\r\nstruct FarmingSetup {\r\n    uint256 infoIndex; // setup info\r\n    bool active; // if the setup is active or not.\r\n    uint256 startBlock; // farming setup start block.\r\n    uint256 endBlock; // farming setup end block.\r\n    uint256 lastUpdateBlock; // number of the block where an update was triggered.\r\n    uint256 objectId; // items object id for the liquidity pool token (used only if free is false).\r\n    uint256 rewardPerBlock; // farming setup reward per single block.\r\n    uint256 totalSupply; // If free it's the LP amount, if locked is currentlyStaked.\r\n}\r\n\r\nstruct FarmingPosition {\r\n    address uniqueOwner; // address representing the owner of the position.\r\n    uint256 setupIndex; // the setup index related to this position.\r\n    uint256 creationBlock; // block when this position was created.\r\n    uint256 liquidityPoolTokenAmount; // amount of liquidity pool token in the position.\r\n    uint256 mainTokenAmount; // amount of main token in the position (used only if free is false).\r\n    uint256 reward; // position reward (used only if free is false).\r\n    uint256 lockedRewardPerBlock; // position locked reward per block (used only if free is false).\r\n}\r\n\r\n// File: contracts\\farming\\IFarmMain.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\npragma solidity ^0.7.6;\r\n//pragma abicoder v2;\r\n\r\n\r\ninterface IFarmMain {\r\n\r\n    function ONE_HUNDRED() external view returns(uint256);\r\n    function _rewardTokenAddress() external view returns(address);\r\n    function position(uint256 positionId) external view returns (FarmingPosition memory);\r\n    function setups() external view returns (FarmingSetup[] memory);\r\n    function setup(uint256 setupIndex) external view returns (FarmingSetup memory, FarmingSetupInfo memory);\r\n    function setFarmingSetups(FarmingSetupConfiguration[] memory farmingSetups) external;\r\n    function openPosition(FarmingPositionRequest calldata request) external payable returns(uint256 positionId);\r\n    function addLiquidity(uint256 positionId, FarmingPositionRequest calldata request) external payable;\r\n}\r\n\r\n// File: contracts\\farming\\IFarmExtension.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\npragma solidity ^0.7.6;\r\n//pragma abicoder v2;\r\n\r\n\r\ninterface IFarmExtension {\r\n\r\n    function init(bool byMint, address host, address treasury) external;\r\n\r\n    function setHost(address host) external;\r\n    function setTreasury(address treasury) external;\r\n\r\n    function data() external view returns(address farmMainContract, bool byMint, address host, address treasury, address rewardTokenAddress);\r\n\r\n    function transferTo(uint256 amount) external;\r\n    function backToYou(uint256 amount) external payable;\r\n\r\n    function setFarmingSetups(FarmingSetupConfiguration[] memory farmingSetups) external;\r\n\r\n}\r\n\r\n// File: contracts\\farming\\IFarmFactory.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\npragma solidity ^0.7.6;\r\n\r\ninterface IFarmFactory {\r\n\r\n    event ExtensionCloned(address indexed);\r\n\r\n    function feePercentageInfo() external view returns (uint256, address);\r\n    function farmDefaultExtension() external view returns(address);\r\n    function cloneFarmDefaultExtension() external returns(address);\r\n    function getFarmTokenCollectionURI() external view returns (string memory);\r\n    function getFarmTokenURI() external view returns (string memory);\r\n}\r\n\r\n// File: contracts\\farming\\util\\ERC1155Receiver.sol\r\n\r\n// File: contracts/usd-v2/util/ERC1155Receiver.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.7.6;\r\n\r\nabstract contract ERC1155Receiver {\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor() {\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n        _registerInterface(\r\n            ERC1155Receiver(0).onERC1155Received.selector ^\r\n            ERC1155Receiver(0).onERC1155BatchReceived.selector\r\n        );\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    function _registerInterface(bytes4 interfaceId) internal virtual {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        virtual\r\n        returns(bytes4);\r\n\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        virtual\r\n        returns(bytes4);\r\n}\r\n\r\n// File: contracts\\farming\\util\\IERC20.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.7.6;\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function safeApprove(address spender, uint256 amount) external;\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// File: contracts\\farming\\util\\IEthItemOrchestrator.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.7.6;\r\n\r\ninterface IEthItemOrchestrator {\r\n    function createNative(bytes calldata modelInitPayload, string calldata ens)\r\n        external\r\n        returns (address newNativeAddress, bytes memory modelInitCallResponse);\r\n}\r\n\r\n// File: contracts\\farming\\util\\IERC1155.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.7.6;\r\n\r\ninterface IERC1155 {\r\n\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\r\n\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\r\n\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\r\n\r\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\r\n}\r\n\r\n// File: contracts\\farming\\util\\IEthItemInteroperableInterface.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.7.6;\r\n\r\n\r\ninterface IEthItemInteroperableInterface is IERC20 {\r\n\r\n    function mainInterface() external view returns (address);\r\n\r\n    function objectId() external view returns (uint256);\r\n\r\n    function mint(address owner, uint256 amount) external;\r\n\r\n    function burn(address owner, uint256 amount) external;\r\n\r\n    function permitNonce(address sender) external view returns(uint256);\r\n\r\n    function permit(address owner, address spender, uint value, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    function interoperableInterfaceVersion() external pure returns(uint256 ethItemInteroperableInterfaceVersion);\r\n}\r\n\r\n// File: contracts\\farming\\util\\IEthItem.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.7.6;\r\n\r\n\r\n\r\ninterface IEthItem is IERC1155 {\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function totalSupply(uint256 objectId) external view returns (uint256);\r\n\r\n    function name(uint256 objectId) external view returns (string memory);\r\n\r\n    function symbol(uint256 objectId) external view returns (string memory);\r\n\r\n    function decimals(uint256 objectId) external view returns (uint256);\r\n\r\n    function uri(uint256 objectId) external view returns (string memory);\r\n\r\n    function mainInterfaceVersion() external pure returns(uint256 ethItemInteroperableVersion);\r\n\r\n    function toInteroperableInterfaceAmount(uint256 objectId, uint256 ethItemAmount) external view returns (uint256 interoperableInterfaceAmount);\r\n\r\n    function toMainInterfaceAmount(uint256 objectId, uint256 erc20WrapperAmount) external view returns (uint256 mainInterfaceAmount);\r\n\r\n    function interoperableInterfaceModel() external view returns (address, uint256);\r\n\r\n    function asInteroperable(uint256 objectId) external view returns (IEthItemInteroperableInterface);\r\n\r\n    function emitTransferSingleEvent(address sender, address from, address to, uint256 objectId, uint256 amount) external;\r\n\r\n    function mint(uint256 amount, string calldata partialUri)\r\n        external\r\n        returns (uint256, address);\r\n\r\n    function burn(\r\n        uint256 objectId,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function burnBatch(\r\n        uint256[] calldata objectIds,\r\n        uint256[] calldata amounts\r\n    ) external;\r\n}\r\n\r\n// File: contracts\\farming\\util\\INativeV1.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.7.6;\r\n\r\n\r\ninterface INativeV1 is IEthItem {\r\n\r\n    function init(string calldata name, string calldata symbol, bool hasDecimals, string calldata collectionUri, address extensionAddress, bytes calldata extensionInitPayload) external returns(bytes memory extensionInitCallResponse);\r\n    function extension() external view returns (address extensionAddress);\r\n    function canMint(address operator) external view returns (bool result);\r\n    function isEditable(uint256 objectId) external view returns (bool result);\r\n    function releaseExtension() external;\r\n    function uri() external view returns (string memory);\r\n    function decimals() external view returns (uint256);\r\n    function mint(uint256 amount, string calldata tokenName, string calldata tokenSymbol, string calldata objectUri, bool editable) external returns (uint256 objectId, address tokenAddress);\r\n    function mint(uint256 amount, string calldata tokenName, string calldata tokenSymbol, string calldata objectUri) external returns (uint256 objectId, address tokenAddress);\r\n    function mint(uint256 objectId, uint256 amount) external;\r\n    function makeReadOnly(uint256 objectId) external;\r\n    function setUri(string calldata newUri) external;\r\n    function setUri(uint256 objectId, string calldata newUri) external;\r\n}\r\n\r\n// File: contracts\\farming\\FarmMain.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\npragma solidity ^0.7.6;\r\n//pragma abicoder v2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract FarmMain is IFarmMain, ERC1155Receiver {\r\n\r\n    // percentage\r\n    uint256 public override constant ONE_HUNDRED = 1e18;\r\n    // event that tracks contracts deployed for the given reward token\r\n    event RewardToken(address indexed rewardTokenAddress);\r\n    // new or transferred farming position event\r\n    event Transfer(uint256 indexed positionId, address indexed from, address indexed to);\r\n    // event that tracks involved tokens for this contract\r\n    event SetupToken(address indexed mainToken, address indexed involvedToken);\r\n    // event that tracks farm tokens\r\n    event FarmToken(uint256 indexed objectId, address indexed liquidityPoolToken, uint256 setupIndex, uint256 endBlock);\r\n    // factory address that will create clones of this contract\r\n    address public _factory;\r\n    // address of the extension of this contract\r\n    address public _extension;\r\n    // address of the reward token\r\n    address public override _rewardTokenAddress;\r\n     // farm token collection\r\n    address public _farmTokenCollection;\r\n    // mapping containing all the currently available farming setups info\r\n    mapping(uint256 => FarmingSetupInfo) private _setupsInfo;\r\n    // counter for the farming setup info\r\n    uint256 public _farmingSetupsInfoCount;\r\n    // mapping containing all the currently available farming setups\r\n    mapping(uint256 => FarmingSetup) private _setups;\r\n    // counter for the farming setups\r\n    uint256 public _farmingSetupsCount;\r\n    // mapping containing all the positions\r\n    mapping(uint256 => FarmingPosition) private _positions;\r\n    // mapping containing the reward per token per setup per block\r\n    mapping(uint256 => uint256) private _rewardPerTokenPerSetup;\r\n    // mapping containing the reward per token paid per position\r\n    mapping(uint256 => uint256) private _rewardPerTokenPaid;\r\n    // mapping containing whether a farming position has been partially reedemed or not\r\n    mapping(uint256 => uint256) public _partiallyRedeemed;\r\n    // mapping containing object id to setup index\r\n    mapping(uint256 => uint256) private _objectIdSetup;\r\n    // mapping containing all the number of opened positions for each setups\r\n    mapping(uint256 => uint256) private _setupPositionsCount;\r\n    // mapping containing all the reward received/paid per setup\r\n    mapping(uint256 => uint256) public _rewardReceived;\r\n    mapping(uint256 => uint256) public _rewardPaid;\r\n\r\n    /** Modifiers. */\r\n\r\n    /** @dev byExtension modifier used to check for unauthorized changes. */\r\n    modifier byExtension() {\r\n        require(msg.sender == _extension, \"Unauthorized\");\r\n        _;\r\n    }\r\n\r\n    /** @dev byPositionOwner modifier used to check for unauthorized accesses. */\r\n    modifier byPositionOwner(uint256 positionId) {\r\n        require(_positions[positionId].uniqueOwner == msg.sender && _positions[positionId].creationBlock != 0, \"Not owned\");\r\n        _;\r\n    }\r\n\r\n    /** @dev activeSetupOnly modifier used to check for function calls only if the setup is active. */\r\n    modifier activeSetupOnly(uint256 setupIndex) {\r\n        require(_setups[setupIndex].active, \"Setup not active\");\r\n        require(_setups[setupIndex].startBlock <= block.number && _setups[setupIndex].endBlock > block.number, \"Invalid setup\");\r\n        _;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    /** Extension methods */\r\n\r\n    /** @dev initializes the farming contract.\r\n      * @param extension extension address.\r\n      * @param extensionInitData lm extension init payload.\r\n      * @param orchestrator address of the eth item orchestrator.\r\n      * @param rewardTokenAddress address of the reward token.\r\n      * @return extensionReturnCall result of the extension initialization function, if it was called.  \r\n     */\r\n    function init(address extension, bytes memory extensionInitData, address orchestrator, address rewardTokenAddress, bytes memory farmingSetupInfosBytes) public returns(bytes memory extensionReturnCall) {\r\n        require(_factory == address(0), \"Already initialized\");\r\n        require((_extension = extension) != address(0), \"extension\");\r\n        _factory = msg.sender;\r\n        emit RewardToken(_rewardTokenAddress = rewardTokenAddress);\r\n        if (keccak256(extensionInitData) != keccak256(\"\")) {\r\n            extensionReturnCall = _call(_extension, extensionInitData);\r\n        }\r\n        (_farmTokenCollection,) = IEthItemOrchestrator(orchestrator).createNative(abi.encodeWithSignature(\"init(string,string,bool,string,address,bytes)\", \"Covenants Farming\", \"cFARM\", true, IFarmFactory(_factory).getFarmTokenCollectionURI(), address(this), \"\"), \"\");\r\n        if(farmingSetupInfosBytes.length > 0) {\r\n            FarmingSetupInfo[] memory farmingSetupInfos = abi.decode(farmingSetupInfosBytes, (FarmingSetupInfo[]));\r\n            for(uint256 i = 0; i < farmingSetupInfos.length; i++) {\r\n                _setOrAddFarmingSetupInfo(farmingSetupInfos[i], true, false, 0);\r\n            }\r\n        }\r\n    }\r\n\r\n    function setFarmingSetups(FarmingSetupConfiguration[] memory farmingSetups) public override byExtension {\r\n        for (uint256 i = 0; i < farmingSetups.length; i++) {\r\n            _setOrAddFarmingSetupInfo(farmingSetups[i].info, farmingSetups[i].add, farmingSetups[i].disable, farmingSetups[i].index);\r\n        }\r\n    }\r\n\r\n    /** Public methods */\r\n\r\n    /** @dev returns the position with the given id.\r\n      * @param positionId id of the position.\r\n      * @return farming position with the given id.\r\n     */\r\n    function position(uint256 positionId) public override view returns (FarmingPosition memory) {\r\n        return _positions[positionId];\r\n    }\r\n\r\n    function setup(uint256 setupIndex) public override view returns (FarmingSetup memory, FarmingSetupInfo memory) {\r\n        return (_setups[setupIndex], _setupsInfo[_setups[setupIndex].infoIndex]);\r\n    }\r\n\r\n    function setups() public override view returns (FarmingSetup[] memory) {\r\n        FarmingSetup[] memory farmingSetups = new FarmingSetup[](_farmingSetupsCount);\r\n        for (uint256 i = 0; i < _farmingSetupsCount; i++) {\r\n            farmingSetups[i] = _setups[i];\r\n        }\r\n        return farmingSetups;\r\n    }\r\n\r\n    function activateSetup(uint256 setupInfoIndex) public {\r\n        require(_setupsInfo[setupInfoIndex].renewTimes > 0 && !_setups[_setupsInfo[setupInfoIndex].lastSetupIndex].active, \"Invalid toggle.\");\r\n        _toggleSetup(_setupsInfo[setupInfoIndex].lastSetupIndex);\r\n    }\r\n\r\n    function transferPosition(address to, uint256 positionId) public byPositionOwner(positionId) {\r\n        // retrieve liquidity mining position\r\n        FarmingPosition memory pos = _positions[positionId];\r\n        require(\r\n            to != address(0) &&\r\n            pos.creationBlock != 0,\r\n            \"Invalid position\"\r\n        );\r\n        // pos.uniqueOwner = to;\r\n        uint256 newPositionId = uint256(keccak256(abi.encode(to, _setupsInfo[_setups[pos.setupIndex].infoIndex].free ? 0 : block.number, pos.setupIndex)));\r\n        require(_positions[newPositionId].creationBlock == 0, \"Invalid transfer\");\r\n        _positions[newPositionId] = abi.decode(abi.encode(pos), (FarmingPosition));\r\n        _positions[newPositionId].uniqueOwner = to;\r\n        delete _positions[positionId];\r\n        emit Transfer(newPositionId, msg.sender, to);\r\n    }\r\n\r\n    function openPosition(FarmingPositionRequest memory request) public override payable activeSetupOnly(request.setupIndex) returns(uint256 positionId) {\r\n        // retrieve the setup\r\n        FarmingSetup storage chosenSetup = _setups[request.setupIndex];\r\n        // retrieve the unique owner\r\n        address uniqueOwner = (request.positionOwner != address(0)) ? request.positionOwner : msg.sender;\r\n        // create the position id\r\n        positionId = uint256(keccak256(abi.encode(uniqueOwner, _setupsInfo[chosenSetup.infoIndex].free ? 0 : block.number, request.setupIndex)));\r\n        require(_positions[positionId].creationBlock == 0, \"Invalid open\");\r\n        // create the lp data for the amm\r\n        (LiquidityPoolData memory liquidityPoolData, uint256 mainTokenAmount) = _addLiquidity(request.setupIndex, request);\r\n        // calculate the reward\r\n        uint256 reward;\r\n        uint256 lockedRewardPerBlock;\r\n        if (!_setupsInfo[chosenSetup.infoIndex].free) {\r\n            (reward, lockedRewardPerBlock) = calculateLockedFarmingReward(request.setupIndex, mainTokenAmount, false, 0);\r\n            require(reward > 0 && lockedRewardPerBlock > 0, \"Insufficient staked amount\");\r\n            chosenSetup.totalSupply = chosenSetup.totalSupply + mainTokenAmount;\r\n            chosenSetup.lastUpdateBlock = block.number;\r\n            _mintFarmTokenAmount(uniqueOwner, liquidityPoolData.amount, request.setupIndex);\r\n        } else {\r\n            _updateFreeSetup(request.setupIndex, liquidityPoolData.amount, positionId, false);\r\n        }\r\n        _positions[positionId] = FarmingPosition({\r\n            uniqueOwner: uniqueOwner,\r\n            setupIndex : request.setupIndex,\r\n            liquidityPoolTokenAmount: liquidityPoolData.amount,\r\n            mainTokenAmount: mainTokenAmount,\r\n            reward: reward,\r\n            lockedRewardPerBlock: lockedRewardPerBlock,\r\n            creationBlock: block.number\r\n        });\r\n        _setupPositionsCount[request.setupIndex] += (1 + (_setupsInfo[chosenSetup.infoIndex].free ? 0 : liquidityPoolData.amount));\r\n        emit Transfer(positionId, address(0), uniqueOwner);\r\n    }\r\n\r\n    function addLiquidity(uint256 positionId, FarmingPositionRequest memory request) public override payable activeSetupOnly(request.setupIndex) byPositionOwner(positionId) {\r\n        // retrieve farming position\r\n        FarmingPosition storage farmingPosition = _positions[positionId];\r\n        FarmingSetup storage chosenSetup = _setups[farmingPosition.setupIndex];\r\n        // check if farmoing position is valid\r\n        require(_setupsInfo[chosenSetup.infoIndex].free, \"Invalid add liquidity\");\r\n        // create the lp data for the amm\r\n        (LiquidityPoolData memory liquidityPoolData,) = _addLiquidity(farmingPosition.setupIndex, request);\r\n        // rebalance the reward per token\r\n        _rewardPerTokenPerSetup[farmingPosition.setupIndex] += (((block.number - chosenSetup.lastUpdateBlock) * chosenSetup.rewardPerBlock) * 1e18) / chosenSetup.totalSupply;\r\n        farmingPosition.reward = calculateFreeFarmingReward(positionId, false);\r\n        _rewardPerTokenPaid[positionId] = _rewardPerTokenPerSetup[farmingPosition.setupIndex];\r\n        farmingPosition.liquidityPoolTokenAmount += liquidityPoolData.amount;\r\n        // update the last block update variablex\r\n        chosenSetup.lastUpdateBlock = block.number;\r\n        chosenSetup.totalSupply += liquidityPoolData.amount;\r\n    }\r\n\r\n\r\n    /** @dev this function allows a user to withdraw the reward.\r\n      * @param positionId farming position id.\r\n     */\r\n    function withdrawReward(uint256 positionId) public byPositionOwner(positionId) {\r\n        // retrieve farming position\r\n        FarmingPosition storage farmingPosition = _positions[positionId];\r\n        uint256 reward = farmingPosition.reward;\r\n        uint256 currentBlock = block.number;\r\n        if (!_setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].free) {\r\n            // check if reward is available\r\n            require(farmingPosition.reward > 0, \"No reward\");\r\n            // check if it's a partial reward or not\r\n            // if (_setups[farmingPosition.setupIndex].endBlock > block.number) {\r\n            // calculate the reward from the farming position creation block to the current block multiplied by the reward per block\r\n            (reward,) = calculateLockedFarmingReward(0, 0, true, positionId);\r\n            //}\r\n            require(reward <= farmingPosition.reward, \"Reward is bigger than expected\");\r\n            // remove the partial reward from the liquidity mining position total reward\r\n            farmingPosition.reward = currentBlock >= _setups[farmingPosition.setupIndex].endBlock ? 0 : farmingPosition.reward - reward;\r\n            farmingPosition.creationBlock = block.number;\r\n        } else {\r\n            // rebalance setup\r\n            currentBlock = currentBlock > _setups[farmingPosition.setupIndex].endBlock ? _setups[farmingPosition.setupIndex].endBlock : currentBlock;\r\n            _rewardPerTokenPerSetup[farmingPosition.setupIndex] += (((currentBlock - _setups[farmingPosition.setupIndex].lastUpdateBlock) * _setups[farmingPosition.setupIndex].rewardPerBlock) * 1e18) / _setups[farmingPosition.setupIndex].totalSupply;\r\n            reward = calculateFreeFarmingReward(positionId, false);\r\n            _rewardPerTokenPaid[positionId] = _rewardPerTokenPerSetup[farmingPosition.setupIndex];\r\n            farmingPosition.reward = 0;\r\n            // update the last block update variable\r\n            _setups[farmingPosition.setupIndex].lastUpdateBlock = currentBlock;\r\n        }\r\n        if (reward > 0) {\r\n            // transfer the reward\r\n            if (_rewardTokenAddress != address(0)) {\r\n                _safeTransfer(_rewardTokenAddress, farmingPosition.uniqueOwner, reward);\r\n            } else {\r\n                (bool result,) = farmingPosition.uniqueOwner.call{value:reward}(\"\");\r\n                require(result, \"Invalid ETH transfer.\");\r\n            }\r\n            _rewardPaid[farmingPosition.setupIndex] += reward;\r\n        }\r\n        if (_setups[farmingPosition.setupIndex].endBlock <= block.number) {\r\n            if (_setups[farmingPosition.setupIndex].active) {\r\n                _toggleSetup(farmingPosition.setupIndex);\r\n            }\r\n            // close the locked position after withdrawing all the reward\r\n            if (!_setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].free) {\r\n                _setupPositionsCount[farmingPosition.setupIndex] -= 1;\r\n                if (_setupPositionsCount[farmingPosition.setupIndex] == 0 && !_setups[farmingPosition.setupIndex].active) {\r\n                    _giveBack(_rewardReceived[farmingPosition.setupIndex] - _rewardPaid[farmingPosition.setupIndex]);\r\n                    delete _setups[farmingPosition.setupIndex];\r\n                }\r\n                delete _positions[positionId];\r\n            }\r\n        } else if (!_setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].free) {\r\n            // set the partially redeemed amount\r\n            _partiallyRedeemed[positionId] += reward;\r\n        }\r\n    }\r\n\r\n    function withdrawLiquidity(uint256 positionId, uint256 objectId, bool unwrapPair, uint256 removedLiquidity) public {\r\n        // retrieve farming position\r\n        FarmingPosition memory farmingPosition = _positions[positionId];\r\n        uint256 setupIndex = farmingPosition.setupIndex;\r\n        if (objectId != 0 && address(INativeV1(_farmTokenCollection).asInteroperable(objectId)) != address(0)) {\r\n            setupIndex = _objectIdSetup[objectId];\r\n        }\r\n        require((positionId != 0 && objectId == 0) || (objectId != 0 && positionId == 0 && _setups[setupIndex].objectId == objectId), \"Invalid position\");\r\n        // current owned liquidity\r\n        require(\r\n            (\r\n                _setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].free && \r\n                farmingPosition.creationBlock != 0 &&\r\n                removedLiquidity <= farmingPosition.liquidityPoolTokenAmount &&\r\n                farmingPosition.uniqueOwner == msg.sender\r\n            ) || (INativeV1(_farmTokenCollection).balanceOf(msg.sender, objectId) >= removedLiquidity && (_setups[setupIndex].endBlock <= block.number)), \"Invalid withdraw\");\r\n        // burn the liquidity in the locked setup\r\n        if (positionId == 0) {\r\n            _burnFarmTokenAmount(objectId, removedLiquidity);\r\n        } else {\r\n            withdrawReward(positionId);\r\n            _setups[farmingPosition.setupIndex].totalSupply -= removedLiquidity;\r\n        }\r\n        _removeLiquidity(positionId, setupIndex, unwrapPair, removedLiquidity, false);\r\n        if (positionId == 0) {\r\n            _setupPositionsCount[setupIndex] -= removedLiquidity;\r\n            if (_setupPositionsCount[setupIndex] == 0 && !_setups[setupIndex].active) {\r\n                _giveBack(_rewardReceived[setupIndex] - _rewardPaid[setupIndex]);\r\n                delete _setups[setupIndex];\r\n            }\r\n        }\r\n    }\r\n\r\n    function unlock(uint256 positionId, bool unwrapPair) public payable byPositionOwner(positionId) {\r\n        // retrieve liquidity mining position\r\n        FarmingPosition storage farmingPosition = _positions[positionId];\r\n        require(!_setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].free && _setups[farmingPosition.setupIndex].endBlock > block.number, \"Invalid unlock\");\r\n        uint256 rewardToGiveBack = _partiallyRedeemed[positionId];\r\n        // must pay a penalty fee\r\n        rewardToGiveBack += _setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].penaltyFee == 0 ? 0 : (farmingPosition.reward * ((_setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].penaltyFee * 1e18) / ONE_HUNDRED) / 1e18);\r\n        // add all the unissued reward\r\n        if (rewardToGiveBack > 0) {\r\n            _safeTransferFrom(_rewardTokenAddress, msg.sender, address(this), rewardToGiveBack);\r\n            _giveBack(rewardToGiveBack);\r\n        } \r\n        _setups[farmingPosition.setupIndex].totalSupply -= farmingPosition.mainTokenAmount;\r\n        _burnFarmTokenAmount(_setups[farmingPosition.setupIndex].objectId, farmingPosition.liquidityPoolTokenAmount);\r\n        _removeLiquidity(positionId, farmingPosition.setupIndex, unwrapPair, farmingPosition.liquidityPoolTokenAmount, true);\r\n        _setupPositionsCount[farmingPosition.setupIndex] -= 1 + farmingPosition.liquidityPoolTokenAmount;\r\n        delete _positions[positionId];\r\n    }\r\n\r\n    function calculateLockedFarmingReward(uint256 setupIndex, uint256 mainTokenAmount, bool isPartial, uint256 positionId) public view returns(uint256 reward, uint256 relativeRewardPerBlock) {\r\n        if (isPartial) {\r\n            // retrieve the position\r\n            FarmingPosition memory farmingPosition = _positions[positionId];\r\n            // calculate the reward\r\n            uint256 currentBlock = block.number >= _setups[farmingPosition.setupIndex].endBlock ? _setups[farmingPosition.setupIndex].endBlock : block.number;\r\n            reward = ((currentBlock - farmingPosition.creationBlock) * farmingPosition.lockedRewardPerBlock);\r\n        } else {\r\n            FarmingSetup memory setup = _setups[setupIndex];\r\n            // check if main token amount is less than the stakeable liquidity\r\n            require(mainTokenAmount <= _setupsInfo[_setups[setupIndex].infoIndex].maxStakeable - setup.totalSupply, \"Invalid liquidity\");\r\n            uint256 remainingBlocks = block.number >= setup.endBlock ? 0 : setup.endBlock - block.number;\r\n            // get amount of remaining blocks\r\n            require(remainingBlocks > 0, \"FarmingSetup ended\");\r\n            // get total reward still available (= 0 if rewardPerBlock = 0)\r\n            require(setup.rewardPerBlock * remainingBlocks > 0, \"No rewards\");\r\n            // calculate relativeRewardPerBlock\r\n            relativeRewardPerBlock = (setup.rewardPerBlock * ((mainTokenAmount * 1e18) / _setupsInfo[_setups[setupIndex].infoIndex].maxStakeable)) / 1e18;\r\n            // check if rewardPerBlock is greater than 0\r\n            require(relativeRewardPerBlock > 0, \"Invalid rpb\");\r\n            // calculate reward by multiplying relative reward per block and the remaining blocks\r\n            reward = relativeRewardPerBlock * remainingBlocks;\r\n        }\r\n    }\r\n\r\n    function calculateFreeFarmingReward(uint256 positionId, bool isExt) public view returns(uint256 reward) {\r\n        FarmingPosition memory farmingPosition = _positions[positionId];\r\n        reward = ((_rewardPerTokenPerSetup[farmingPosition.setupIndex] - _rewardPerTokenPaid[positionId]) * farmingPosition.liquidityPoolTokenAmount) / 1e18;\r\n        if (isExt) {\r\n            uint256 currentBlock = block.number < _setups[farmingPosition.setupIndex].endBlock ? block.number : _setups[farmingPosition.setupIndex].endBlock;\r\n            uint256 lastUpdateBlock = _setups[farmingPosition.setupIndex].lastUpdateBlock < _setups[farmingPosition.setupIndex].startBlock ? _setups[farmingPosition.setupIndex].startBlock : _setups[farmingPosition.setupIndex].lastUpdateBlock;\r\n            uint256 rpt = (((currentBlock - lastUpdateBlock) * _setups[farmingPosition.setupIndex].rewardPerBlock) * 1e18) / _setups[farmingPosition.setupIndex].totalSupply;\r\n            reward += (rpt * farmingPosition.liquidityPoolTokenAmount) / 1e18;\r\n        }\r\n        reward += farmingPosition.reward;\r\n    }\r\n\r\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public view override returns(bytes4) {\r\n        require(_farmTokenCollection == msg.sender, \"Invalid sender\");\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n\r\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public view override returns(bytes4) {\r\n        require(_farmTokenCollection == msg.sender, \"Invalid sender\");\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    /** Private methods */\r\n\r\n    function _setOrAddFarmingSetupInfo(FarmingSetupInfo memory info, bool add, bool disable, uint256 setupIndex) private {\r\n        FarmingSetupInfo memory farmingSetupInfo = info;\r\n\r\n        if(add || !disable) {\r\n            farmingSetupInfo.renewTimes = farmingSetupInfo.renewTimes + 1;\r\n            if(farmingSetupInfo.renewTimes == 0) {\r\n                farmingSetupInfo.renewTimes = farmingSetupInfo.renewTimes - 1;\r\n            }\r\n        }\r\n\r\n        if (add) {\r\n            require(\r\n                farmingSetupInfo.ammPlugin != address(0) &&\r\n                farmingSetupInfo.liquidityPoolTokenAddress != address(0) &&\r\n                farmingSetupInfo.originalRewardPerBlock > 0 &&\r\n                (farmingSetupInfo.free || farmingSetupInfo.maxStakeable > 0),\r\n                \"Invalid setup configuration\"\r\n            );\r\n\r\n            (,,address[] memory tokenAddresses) = IAMM(farmingSetupInfo.ammPlugin).byLiquidityPool(farmingSetupInfo.liquidityPoolTokenAddress);\r\n            farmingSetupInfo.ethereumAddress = address(0);\r\n            if (farmingSetupInfo.involvingETH) {\r\n                (farmingSetupInfo.ethereumAddress,,) = IAMM(farmingSetupInfo.ammPlugin).data();\r\n            }\r\n            bool mainTokenFound = false;\r\n            bool ethTokenFound = false;\r\n            for(uint256 z = 0; z < tokenAddresses.length; z++) {\r\n                if(tokenAddresses[z] == farmingSetupInfo.mainTokenAddress) {\r\n                    mainTokenFound = true;\r\n                    if(tokenAddresses[z] == farmingSetupInfo.ethereumAddress) {\r\n                        ethTokenFound = true;\r\n                    }\r\n                } else {\r\n                    emit SetupToken(farmingSetupInfo.mainTokenAddress, tokenAddresses[z]);\r\n                    if(tokenAddresses[z] == farmingSetupInfo.ethereumAddress) {\r\n                        ethTokenFound = true;\r\n                    }\r\n                }\r\n            }\r\n            require(mainTokenFound, \"No main token\");\r\n            require(!farmingSetupInfo.involvingETH || ethTokenFound, \"No ETH token\");\r\n            farmingSetupInfo.setupsCount = 0;\r\n            _setupsInfo[_farmingSetupsInfoCount] = farmingSetupInfo;\r\n            _setups[_farmingSetupsCount] = FarmingSetup(_farmingSetupsInfoCount, false, 0, 0, 0, 0, farmingSetupInfo.originalRewardPerBlock, 0);\r\n            _setupsInfo[_farmingSetupsInfoCount].lastSetupIndex = _farmingSetupsCount;\r\n            _farmingSetupsInfoCount += 1;\r\n            _farmingSetupsCount += 1;\r\n            return;\r\n        }\r\n\r\n        FarmingSetup storage setup = _setups[setupIndex];\r\n        farmingSetupInfo = _setupsInfo[_setups[setupIndex].infoIndex];\r\n\r\n        if(disable) {\r\n            require(setup.active, \"Not possible\");\r\n            _toggleSetup(setupIndex);\r\n            return;\r\n        }\r\n\r\n        info.renewTimes -= 1;\r\n\r\n        if (setup.active && _setupsInfo[_setups[setupIndex].infoIndex].free) {\r\n            setup = _setups[setupIndex];\r\n            if(block.number < setup.endBlock) {\r\n                uint256 difference = info.originalRewardPerBlock < farmingSetupInfo.originalRewardPerBlock ? farmingSetupInfo.originalRewardPerBlock - info.originalRewardPerBlock : info.originalRewardPerBlock - farmingSetupInfo.originalRewardPerBlock;\r\n                uint256 duration = setup.endBlock - block.number;\r\n                uint256 amount = difference * duration;\r\n                if (amount > 0) {\r\n                    if (info.originalRewardPerBlock > farmingSetupInfo.originalRewardPerBlock) {\r\n                        require(_ensureTransfer(amount), \"Insufficient reward in extension.\");\r\n                        _rewardReceived[setupIndex] += amount;\r\n                    }\r\n                    _updateFreeSetup(setupIndex, 0, 0, false);\r\n                    setup.rewardPerBlock = info.originalRewardPerBlock;\r\n                }\r\n            }\r\n            _setupsInfo[_setups[setupIndex].infoIndex].originalRewardPerBlock = info.originalRewardPerBlock;\r\n        }\r\n        if(_setupsInfo[_setups[setupIndex].infoIndex].renewTimes > 0) {\r\n            _setupsInfo[_setups[setupIndex].infoIndex].renewTimes = info.renewTimes;\r\n        }\r\n    }\r\n\r\n    function _transferToMeAndCheckAllowance(FarmingSetup memory setup, FarmingPositionRequest memory request) private returns(IAMM amm, uint256 liquidityPoolAmount, uint256 mainTokenAmount) {\r\n        require(request.amount > 0, \"No amount\");\r\n        // retrieve the values\r\n        amm = IAMM(_setupsInfo[setup.infoIndex].ammPlugin);\r\n        liquidityPoolAmount = request.amountIsLiquidityPool ? request.amount : 0;\r\n        mainTokenAmount = request.amountIsLiquidityPool ? 0 : request.amount;\r\n        address[] memory tokens;\r\n        uint256[] memory tokenAmounts;\r\n        // if liquidity pool token amount is provided, the position is opened by liquidity pool token amount\r\n        if(request.amountIsLiquidityPool) {\r\n            _safeTransferFrom(_setupsInfo[setup.infoIndex].liquidityPoolTokenAddress, msg.sender, address(this), liquidityPoolAmount);\r\n            (tokenAmounts, tokens) = amm.byLiquidityPoolAmount(_setupsInfo[setup.infoIndex].liquidityPoolTokenAddress, liquidityPoolAmount);\r\n        } else {\r\n            // else it is opened by the tokens amounts\r\n            (liquidityPoolAmount, tokenAmounts, tokens) = amm.byTokenAmount(_setupsInfo[setup.infoIndex].liquidityPoolTokenAddress, _setupsInfo[setup.infoIndex].mainTokenAddress, mainTokenAmount);\r\n        }\r\n\r\n        // iterate the tokens and perform the transferFrom and the approve\r\n        for(uint256 i = 0; i < tokens.length; i++) {\r\n            if(tokens[i] == _setupsInfo[setup.infoIndex].mainTokenAddress) {\r\n                mainTokenAmount = tokenAmounts[i];\r\n                require(mainTokenAmount >= _setupsInfo[setup.infoIndex].minStakeable, \"Invalid liquidity.\");\r\n                if(request.amountIsLiquidityPool) {\r\n                    break;\r\n                }\r\n            }\r\n            if(request.amountIsLiquidityPool) {\r\n                continue;\r\n            }\r\n            if(_setupsInfo[setup.infoIndex].involvingETH && _setupsInfo[setup.infoIndex].ethereumAddress == tokens[i]) {\r\n                require(msg.value == tokenAmounts[i], \"Incorrect eth value\");\r\n            } else {\r\n                _safeTransferFrom(tokens[i], msg.sender, address(this), tokenAmounts[i]);\r\n                _safeApprove(tokens[i], _setupsInfo[setup.infoIndex].ammPlugin, tokenAmounts[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _addLiquidity(uint256 setupIndex, FarmingPositionRequest memory request) private returns(LiquidityPoolData memory liquidityPoolData, uint256 tokenAmount) {\r\n        (IAMM amm, uint256 liquidityPoolAmount, uint256 mainTokenAmount) = _transferToMeAndCheckAllowance(_setups[setupIndex], request);\r\n        // liquidity pool data struct for the AMM\r\n        liquidityPoolData = LiquidityPoolData(\r\n            _setupsInfo[_setups[setupIndex].infoIndex].liquidityPoolTokenAddress,\r\n            request.amountIsLiquidityPool ? liquidityPoolAmount : mainTokenAmount,\r\n            _setupsInfo[_setups[setupIndex].infoIndex].mainTokenAddress,\r\n            request.amountIsLiquidityPool,\r\n            _setupsInfo[_setups[setupIndex].infoIndex].involvingETH,\r\n            address(this)\r\n        );\r\n        tokenAmount = mainTokenAmount;\r\n        // amount is lp check\r\n        if (liquidityPoolData.amountIsLiquidityPool || !_setupsInfo[_setups[setupIndex].infoIndex].involvingETH) {\r\n            require(msg.value == 0, \"ETH not involved\");\r\n        }\r\n        if (liquidityPoolData.amountIsLiquidityPool) {\r\n            return(liquidityPoolData, tokenAmount);\r\n        }\r\n        // retrieve the poolTokenAmount from the amm\r\n        if(liquidityPoolData.involvingETH) {\r\n            (liquidityPoolData.amount,,) = amm.addLiquidity{value : msg.value}(liquidityPoolData);\r\n        } else {\r\n            (liquidityPoolData.amount,,) = amm.addLiquidity(liquidityPoolData);\r\n        }\r\n    }\r\n\r\n    /** @dev helper function used to remove liquidity from a free position or to burn item farm tokens and retrieve their content.\r\n      * @param positionId id of the position.\r\n      * @param setupIndex index of the setup related to the item farm tokens.\r\n      * @param unwrapPair whether to unwrap the liquidity pool tokens or not.\r\n      * @param isUnlock if we're removing liquidity from an unlock method or not.\r\n     */\r\n    function _removeLiquidity(uint256 positionId, uint256 setupIndex, bool unwrapPair, uint256 removedLiquidity, bool isUnlock) private {\r\n        FarmingSetupInfo memory setupInfo = _setupsInfo[_setups[setupIndex].infoIndex];\r\n        // create liquidity pool data struct for the AMM\r\n        LiquidityPoolData memory lpData = LiquidityPoolData(\r\n            setupInfo.liquidityPoolTokenAddress,\r\n            removedLiquidity,\r\n            setupInfo.mainTokenAddress,\r\n            true,\r\n            setupInfo.involvingETH,\r\n            msg.sender\r\n        );\r\n        // retrieve the position\r\n        FarmingPosition storage farmingPosition = _positions[positionId];\r\n        // remaining liquidity\r\n        uint256 remainingLiquidity;\r\n        // we are removing liquidity using the setup items\r\n        if (setupInfo.free && farmingPosition.creationBlock != 0 && positionId != 0) {\r\n            // update the remaining liquidity\r\n            remainingLiquidity = farmingPosition.liquidityPoolTokenAmount - removedLiquidity;\r\n        }\r\n        // retrieve fee stuff\r\n        (uint256 exitFeePercentage, address exitFeeWallet) = IFarmFactory(_factory).feePercentageInfo();\r\n        // pay the fees!\r\n        if (exitFeePercentage > 0) {\r\n            uint256 fee = (lpData.amount * ((exitFeePercentage * 1e18) / ONE_HUNDRED)) / 1e18;\r\n            _safeTransfer(setupInfo.liquidityPoolTokenAddress, exitFeeWallet, fee);\r\n            lpData.amount = lpData.amount - fee;\r\n        }\r\n        // check if the user wants to unwrap its pair or not\r\n        if (unwrapPair) {\r\n            // remove liquidity using AMM\r\n            _safeApprove(lpData.liquidityPoolAddress, setupInfo.ammPlugin, lpData.amount);\r\n            IAMM(setupInfo.ammPlugin).removeLiquidity(lpData);\r\n        } else {\r\n            // send back the liquidity pool token amount without the fee\r\n            _safeTransfer(lpData.liquidityPoolAddress, lpData.receiver, lpData.amount);\r\n        }\r\n        if (!setupInfo.free && _setups[setupIndex].active && !isUnlock) {\r\n            _toggleSetup(setupIndex);\r\n        } else if (setupInfo.free && positionId != 0) {\r\n            if (_setups[farmingPosition.setupIndex].active && _setups[farmingPosition.setupIndex].endBlock <= block.number) {\r\n                _toggleSetup(farmingPosition.setupIndex);\r\n            }\r\n            // delete the farming position after the withdraw\r\n            if (remainingLiquidity == 0) {\r\n                _setupPositionsCount[farmingPosition.setupIndex] -= 1;\r\n                if (_setupPositionsCount[farmingPosition.setupIndex] == 0 && !_setups[farmingPosition.setupIndex].active) {\r\n                    _giveBack(_rewardReceived[farmingPosition.setupIndex] - _rewardPaid[farmingPosition.setupIndex]);\r\n                    delete _setups[farmingPosition.setupIndex];\r\n                }\r\n                delete _positions[positionId];\r\n            } else {\r\n                // update the creation block and amount\r\n                farmingPosition.liquidityPoolTokenAmount = remainingLiquidity;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @dev updates the free setup with the given index.\r\n      * @param setupIndex index of the setup that we're updating.\r\n      * @param amount amount of liquidity that we're adding/removeing.\r\n      * @param positionId position id.\r\n      * @param fromExit if it's from an exit or not.\r\n     */\r\n    function _updateFreeSetup(uint256 setupIndex, uint256 amount, uint256 positionId, bool fromExit) private {\r\n        uint256 currentBlock = block.number < _setups[setupIndex].endBlock ? block.number : _setups[setupIndex].endBlock;\r\n        if (_setups[setupIndex].totalSupply != 0) {\r\n            uint256 lastUpdateBlock = _setups[setupIndex].lastUpdateBlock < _setups[setupIndex].startBlock ? _setups[setupIndex].startBlock : _setups[setupIndex].lastUpdateBlock;\r\n            _rewardPerTokenPerSetup[setupIndex] += (((currentBlock - lastUpdateBlock) * _setups[setupIndex].rewardPerBlock) * 1e18) / _setups[setupIndex].totalSupply;\r\n        }\r\n        // update the last block update variable\r\n        _setups[setupIndex].lastUpdateBlock = currentBlock;\r\n        if (positionId != 0) {\r\n            _rewardPerTokenPaid[positionId] = _rewardPerTokenPerSetup[setupIndex];\r\n        }\r\n        if (amount > 0) {\r\n            fromExit ? _setups[setupIndex].totalSupply -= amount : _setups[setupIndex].totalSupply += amount;\r\n        }\r\n    }\r\n\r\n    function _toggleSetup(uint256 setupIndex) private {\r\n        FarmingSetup storage setup = _setups[setupIndex];\r\n        // require(!setup.active || block.number >= setup.endBlock, \"Not valid activation\");\r\n\r\n        if (setup.active && block.number >= setup.endBlock && _setupsInfo[setup.infoIndex].renewTimes == 0) {\r\n            setup.active = false;\r\n            return;\r\n        } else if (block.number >= setup.startBlock && block.number < setup.endBlock && setup.active) {\r\n            setup.active = false;\r\n            _setupsInfo[setup.infoIndex].renewTimes = 0;\r\n            uint256 amount = (setup.endBlock - block.number) * setup.rewardPerBlock;\r\n            setup.endBlock = block.number;\r\n            if (_setupsInfo[setup.infoIndex].free) {\r\n                _updateFreeSetup(setupIndex, 0, 0, false);\r\n            }\r\n            _rewardReceived[setupIndex] -= amount;\r\n            _giveBack(amount);\r\n            return;\r\n        }\r\n\r\n        bool wasActive = setup.active;\r\n        setup.active = _ensureTransfer(setup.rewardPerBlock * _setupsInfo[setup.infoIndex].blockDuration);\r\n\r\n        if (setup.active && wasActive) {\r\n            _rewardReceived[_farmingSetupsCount] = setup.rewardPerBlock * _setupsInfo[setup.infoIndex].blockDuration;\r\n            // set new setup\r\n            _setups[_farmingSetupsCount] = abi.decode(abi.encode(setup), (FarmingSetup));\r\n            // update old setup\r\n            _setups[setupIndex].active = false;\r\n            // update new setup\r\n            _setupsInfo[setup.infoIndex].renewTimes -= 1;\r\n            _setupsInfo[setup.infoIndex].setupsCount += 1;\r\n            _setupsInfo[setup.infoIndex].lastSetupIndex = _farmingSetupsCount;\r\n            _setups[_farmingSetupsCount].startBlock = block.number;\r\n            _setups[_farmingSetupsCount].endBlock = block.number + _setupsInfo[_setups[_farmingSetupsCount].infoIndex].blockDuration;\r\n            _setups[_farmingSetupsCount].objectId = 0;\r\n            _setups[_farmingSetupsCount].totalSupply = 0;\r\n            _farmingSetupsCount += 1;\r\n        } else if (setup.active && !wasActive) {\r\n            _rewardReceived[setupIndex] = setup.rewardPerBlock * _setupsInfo[_setups[setupIndex].infoIndex].blockDuration;\r\n            // update new setup\r\n            _setups[setupIndex].startBlock = block.number;\r\n            _setups[setupIndex].endBlock = block.number + _setupsInfo[_setups[setupIndex].infoIndex].blockDuration;\r\n            _setups[setupIndex].totalSupply = 0;\r\n            _setupsInfo[_setups[setupIndex].infoIndex].renewTimes -= 1;\r\n        } else {\r\n            _setupsInfo[_setups[setupIndex].infoIndex].renewTimes = 0;\r\n        }\r\n    }\r\n\r\n    /** @dev mints a new FarmToken inside the collection for the given position.\r\n      * @param uniqueOwner farming position owner.\r\n      * @param amount amount of to mint for a farm token.\r\n      * @param setupIndex index of the setup.\r\n      * @return objectId new farm token object id.\r\n     */\r\n    function _mintFarmTokenAmount(address uniqueOwner, uint256 amount, uint256 setupIndex) private returns(uint256 objectId) {\r\n        if (_setups[setupIndex].objectId == 0) {\r\n            (objectId,) = INativeV1(_farmTokenCollection).mint(amount, string(abi.encodePacked(\"Farming LP \", _toString(_setupsInfo[_setups[setupIndex].infoIndex].liquidityPoolTokenAddress))), \"fLP\", IFarmFactory(_factory).getFarmTokenURI(), true);\r\n            emit FarmToken(objectId, _setupsInfo[_setups[setupIndex].infoIndex].liquidityPoolTokenAddress, setupIndex, _setups[setupIndex].endBlock);\r\n            _objectIdSetup[objectId] = setupIndex;\r\n            _setups[setupIndex].objectId = objectId;\r\n        } else {\r\n            INativeV1(_farmTokenCollection).mint(_setups[setupIndex].objectId, amount);\r\n        }\r\n        INativeV1(_farmTokenCollection).safeTransferFrom(address(this), uniqueOwner, _setups[setupIndex].objectId, amount, \"\");\r\n    }\r\n\r\n    /** @dev burns a farm token from the collection.\r\n      * @param objectId object id where to burn liquidity.\r\n      * @param amount amount of liquidity to burn.\r\n      */\r\n    function _burnFarmTokenAmount(uint256 objectId, uint256 amount) private {\r\n        INativeV1 tokenCollection = INativeV1(_farmTokenCollection);\r\n        // transfer the farm token to this contract\r\n        tokenCollection.safeTransferFrom(msg.sender, address(this), objectId, amount, \"\");\r\n        // burn the farm token\r\n        tokenCollection.burn(objectId, amount);\r\n    }\r\n\r\n    /** @dev function used to safely approve ERC20 transfers.\r\n      * @param erc20TokenAddress address of the token to approve.\r\n      * @param to receiver of the approval.\r\n      * @param value amount to approve for.\r\n     */\r\n    function _safeApprove(address erc20TokenAddress, address to, uint256 value) internal virtual {\r\n        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).approve.selector, to, value));\r\n        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'APPROVE_FAILED');\r\n    }\r\n\r\n    /** @dev function used to safe transfer ERC20 tokens.\r\n      * @param erc20TokenAddress address of the token to transfer.\r\n      * @param to receiver of the tokens.\r\n      * @param value amount of tokens to transfer.\r\n     */\r\n    function _safeTransfer(address erc20TokenAddress, address to, uint256 value) internal virtual {\r\n        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transfer.selector, to, value));\r\n        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFER_FAILED');\r\n    }\r\n\r\n    /** @dev this function safely transfers the given ERC20 value from an address to another.\r\n      * @param erc20TokenAddress erc20 token address.\r\n      * @param from address from.\r\n      * @param to address to.\r\n      * @param value amount to transfer.\r\n     */\r\n    function _safeTransferFrom(address erc20TokenAddress, address from, address to, uint256 value) private {\r\n        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transferFrom.selector, from, to, value));\r\n        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFERFROM_FAILED');\r\n    }\r\n\r\n    /** @dev calls the contract at the given location using the given payload and returns the returnData.\r\n      * @param location location to call.\r\n      * @param payload call payload.\r\n      * @return returnData call return data.\r\n     */\r\n    function _call(address location, bytes memory payload) private returns(bytes memory returnData) {\r\n        assembly {\r\n            let result := call(gas(), location, 0, add(payload, 0x20), mload(payload), 0, 0)\r\n            let size := returndatasize()\r\n            returnData := mload(0x40)\r\n            mstore(returnData, size)\r\n            let returnDataPayloadStart := add(returnData, 0x20)\r\n            returndatacopy(returnDataPayloadStart, 0, size)\r\n            mstore(0x40, add(returnDataPayloadStart, size))\r\n            switch result case 0 {revert(returnDataPayloadStart, size)}\r\n        }\r\n    }\r\n\r\n    /** @dev returns the input address to string.\r\n      * @param _addr address to convert as string.\r\n      * @return address as string.\r\n     */\r\n    function _toString(address _addr) internal pure returns(string memory) {\r\n        bytes32 value = bytes32(uint256(_addr));\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n\r\n        bytes memory str = new bytes(42);\r\n        str[0] = '0';\r\n        str[1] = 'x';\r\n        for (uint i = 0; i < 20; i++) {\r\n            str[2+i*2] = alphabet[uint(uint8(value[i + 12] >> 4))];\r\n            str[3+i*2] = alphabet[uint(uint8(value[i + 12] & 0x0f))];\r\n        }\r\n        return string(str);\r\n    }\r\n\r\n    /** @dev gives back the reward to the extension.\r\n      * @param amount to give back.\r\n     */\r\n    function _giveBack(uint256 amount) private {\r\n        if(amount == 0) {\r\n            return;\r\n        }\r\n        if (_rewardTokenAddress == address(0)) {\r\n            IFarmExtension(_extension).backToYou{value : amount}(amount);\r\n        } else {\r\n            _safeApprove(_rewardTokenAddress, _extension, amount);\r\n            IFarmExtension(_extension).backToYou(amount);\r\n        }\r\n    }\r\n\r\n    /** @dev ensures the transfer from the contract to the extension.\r\n      * @param amount amount to transfer.\r\n     */\r\n    function _ensureTransfer(uint256 amount) private returns(bool) {\r\n        uint256 initialBalance = _rewardTokenAddress == address(0) ? address(this).balance : IERC20(_rewardTokenAddress).balanceOf(address(this));\r\n        uint256 expectedBalance = initialBalance + amount;\r\n        try IFarmExtension(_extension).transferTo(amount) {} catch {}\r\n        uint256 actualBalance = _rewardTokenAddress == address(0) ? address(this).balance : IERC20(_rewardTokenAddress).balanceOf(address(this));\r\n        if(actualBalance == expectedBalance) {\r\n            return true;\r\n        }\r\n        _giveBack(actualBalance - initialBalance);\r\n        return false;\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"objectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityPoolToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setupIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"}],\"name\":\"FarmToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"}],\"name\":\"RewardToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"mainToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"involvedToken\",\"type\":\"address\"}],\"name\":\"SetupToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ONE_HUNDRED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_extension\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_farmTokenCollection\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_farmingSetupsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_farmingSetupsInfoCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_partiallyRedeemed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_rewardPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_rewardReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_rewardTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"setupInfoIndex\",\"type\":\"uint256\"}],\"name\":\"activateSetup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"setupIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"amountIsLiquidityPool\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"positionOwner\",\"type\":\"address\"}],\"internalType\":\"struct FarmingPositionRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isExt\",\"type\":\"bool\"}],\"name\":\"calculateFreeFarmingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"setupIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mainTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPartial\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"calculateLockedFarmingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"relativeRewardPerBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"extension\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"extensionInitData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"orchestrator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"farmingSetupInfosBytes\",\"type\":\"bytes\"}],\"name\":\"init\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"extensionReturnCall\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"setupIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"amountIsLiquidityPool\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"positionOwner\",\"type\":\"address\"}],\"internalType\":\"struct FarmingPositionRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"openPosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"position\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"uniqueOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"setupIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creationBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityPoolTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mainTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedRewardPerBlock\",\"type\":\"uint256\"}],\"internalType\":\"struct FarmingPosition\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"add\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"disable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"free\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"blockDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originalRewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minStakeable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStakeable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"renewTimes\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ammPlugin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidityPoolTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mainTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ethereumAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"involvingETH\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"penaltyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setupsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastSetupIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FarmingSetupInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"internalType\":\"struct FarmingSetupConfiguration[]\",\"name\":\"farmingSetups\",\"type\":\"tuple[]\"}],\"name\":\"setFarmingSetups\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"setupIndex\",\"type\":\"uint256\"}],\"name\":\"setup\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"infoIndex\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"objectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"internalType\":\"struct FarmingSetup\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"free\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"blockDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originalRewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minStakeable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStakeable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"renewTimes\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ammPlugin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidityPoolTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mainTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ethereumAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"involvingETH\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"penaltyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setupsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastSetupIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FarmingSetupInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setups\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"infoIndex\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"objectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"internalType\":\"struct FarmingSetup[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"transferPosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrapPair\",\"type\":\"bool\"}],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"objectId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrapPair\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"removedLiquidity\",\"type\":\"uint256\"}],\"name\":\"withdrawLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"withdrawReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "FarmMain", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d98942548d117adcfb74fc9c3961c809566e919169e0368dee4f72ddc9ad045f"}