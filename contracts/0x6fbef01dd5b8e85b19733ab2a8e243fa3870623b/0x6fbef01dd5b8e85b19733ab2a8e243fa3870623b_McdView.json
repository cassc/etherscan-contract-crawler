{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/external/DSMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\ncontract DSMath {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, \\\"\\\");\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, \\\"\\\");\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"\\\");\\n    }\\n\\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x / y;\\n    }\\n\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x <= y ? x : y;\\n    }\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\\n        return x <= y ? x : y;\\n    }\\n\\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    uint256 internal constant WAD = 10 ** 18;\\n    uint256 internal constant RAY = 10 ** 27;\\n\\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, y), WAD / 2) / WAD;\\n    }\\n\\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, y), RAY / 2) / RAY;\\n    }\\n\\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, WAD), y / 2) / y;\\n    }\\n\\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, RAY), y / 2) / y;\\n    }\\n\\n    // This famous algorithm is called \\\"exponentiation by squaring\\\"\\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\\n    //\\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\\n    //\\n    // These facts are why it works:\\n    //\\n    //  If n is even, then x^n = (x^2)^(n/2).\\n    //  If n is odd,  then x^n = x * x^(n-1),\\n    //   and applying the equation for even x gives\\n    //    x^n = x * (x^2)^((n-1) / 2).\\n    //\\n    //  Also, EVM division is flooring and\\n    //    floor[(n-1) / 2] = floor[n / 2].\\n    //\\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\\n        z = n % 2 != 0 ? x : RAY;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rmul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rmul(z, x);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ManagerLike.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface ManagerLike {\\n    function cdpCan(\\n        address owner,\\n        uint256 cdpId,\\n        address allowedAddr\\n    ) external view returns (uint256);\\n\\n    function vat() external view returns (address);\\n\\n    function ilks(uint256) external view returns (bytes32);\\n\\n    function owns(uint256) external view returns (address);\\n\\n    function urns(uint256) external view returns (address);\\n\\n    function open(bytes32 ilk, address usr) external returns (uint256);\\n\\n    function cdpAllow(uint256 cdp, address usr, uint256 ok) external;\\n\\n    function frob(uint256, int256, int256) external;\\n\\n    function flux(uint256, address, uint256) external;\\n\\n    function move(uint256, address, uint256) external;\\n\\n    function exit(address, uint256, address, uint256) external;\\n\\n    event NewCdp(address indexed usr, address indexed own, uint256 indexed cdp);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/OsmLike.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface OsmLike {\\n    function peep() external view returns (bytes32, bool);\\n\\n    function bud(address) external view returns (uint256);\\n\\n    function kiss(address a) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/OsmMomLike.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface OsmMomLike {\\n    function osms(bytes32) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/SpotterLike.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface IPipInterface {\\n    function read() external returns (bytes32);\\n}\\n\\ninterface SpotterLike {\\n    function ilks(bytes32) external view returns (IPipInterface pip, uint256 mat);\\n\\n    function par() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/VatLike.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface VatLike {\\n    function urns(bytes32, address) external view returns (uint256 ink, uint256 art);\\n\\n    function ilks(\\n        bytes32\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 art, // Total Normalised Debt      [wad]\\n            uint256 rate, // Accumulated Rates         [ray]\\n            uint256 spot, // Price with Safety Margin  [ray]\\n            uint256 line, // Debt Ceiling              [rad]\\n            uint256 dust // Urn Debt Floor             [rad]\\n        );\\n\\n    function gem(bytes32, address) external view returns (uint256); // [wad]\\n\\n    function can(address, address) external view returns (uint256);\\n\\n    function dai(address) external view returns (uint256);\\n\\n    function frob(bytes32, address, address, address, int256, int256) external;\\n\\n    function hope(address) external;\\n\\n    function move(address, address, uint256) external;\\n\\n    function fork(bytes32, address, address, int256, int256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/McdView.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\n/// McdView.sol\\n\\n// Copyright (C) 2021-2021 Oazo Apps Limited\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity ^0.8.0;\\nimport \\\"./interfaces/ManagerLike.sol\\\";\\nimport \\\"./ServiceRegistry.sol\\\";\\n\\nimport \\\"./interfaces/SpotterLike.sol\\\";\\nimport \\\"./interfaces/VatLike.sol\\\";\\nimport \\\"./interfaces/OsmMomLike.sol\\\";\\nimport \\\"./interfaces/OsmLike.sol\\\";\\nimport \\\"./external/DSMath.sol\\\";\\n\\n/// @title Getter contract for Vault info from Maker protocol\\ncontract McdView is DSMath {\\n    ManagerLike public manager;\\n    VatLike public vat;\\n    SpotterLike public spotter;\\n    OsmMomLike public osmMom;\\n    address public owner;\\n    mapping(address => bool) public whitelisted;\\n\\n    constructor(address _vat, address _manager, address _spotter, address _mom, address _owner) {\\n        manager = ManagerLike(_manager);\\n        vat = VatLike(_vat);\\n        spotter = SpotterLike(_spotter);\\n        osmMom = OsmMomLike(_mom);\\n        owner = _owner;\\n    }\\n\\n    function transferOwnership(address _newOwner) external {\\n        require(msg.sender == owner, \\\"mcd-view/not-authorised\\\");\\n        owner = _newOwner;\\n    }\\n\\n    function approve(address _allowedReader, bool isApproved) external {\\n        require(msg.sender == owner, \\\"mcd-view/not-authorised\\\");\\n        whitelisted[_allowedReader] = isApproved;\\n    }\\n\\n    /// @notice Gets Vault info (collateral, debt)\\n    /// @param vaultId Id of the Vault\\n    function getVaultInfo(uint256 vaultId) public view returns (uint256, uint256) {\\n        address urn = manager.urns(vaultId);\\n        bytes32 ilk = manager.ilks(vaultId);\\n\\n        (uint256 collateral, uint256 debt) = vat.urns(ilk, urn);\\n        (, uint256 rate, , , ) = vat.ilks(ilk);\\n\\n        return (collateral, rmul(debt, rate));\\n    }\\n\\n    /// @notice Gets a price of the asset\\n    /// @param ilk Ilk of the Vault\\n    function getPrice(bytes32 ilk) public view returns (uint256) {\\n        (, uint256 mat) = spotter.ilks(ilk);\\n        (, , uint256 spot, , ) = vat.ilks(ilk);\\n\\n        return div(rmul(rmul(spot, spotter.par()), mat), 10 ** 9);\\n    }\\n\\n    /// @notice Gets oracle next price of the asset\\n    /// @param ilk Ilk of the Vault\\n    function getNextPrice(bytes32 ilk) public view returns (uint256) {\\n        require(whitelisted[msg.sender], \\\"mcd-view/not-whitelisted\\\");\\n        OsmLike osm = OsmLike(osmMom.osms(ilk));\\n        (bytes32 val, bool status) = osm.peep();\\n        require(status, \\\"mcd-view/osm-price-error\\\");\\n        return uint256(val);\\n    }\\n\\n    /// @notice Gets Vaults ratio\\n    /// @param vaultId Id of the Vault\\n    function getRatio(uint256 vaultId, bool useNextPrice) public view returns (uint256) {\\n        bytes32 ilk = manager.ilks(vaultId);\\n        uint256 price = useNextPrice ? getNextPrice(ilk) : getPrice(ilk);\\n        (uint256 collateral, uint256 debt) = getVaultInfo(vaultId);\\n        if (debt == 0) return 0;\\n        return wdiv(wmul(collateral, price), debt);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ServiceRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\n/// ServiceRegistry.sol\\n\\n// Copyright (C) 2021-2021 Oazo Apps Limited\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity ^0.8.0;\\n\\ncontract ServiceRegistry {\\n    uint256 public constant MAX_DELAY = 30 days;\\n\\n    mapping(bytes32 => uint256) public lastExecuted;\\n    mapping(bytes32 => address) private namedService;\\n    mapping(bytes32 => bool) private invalidHashes;\\n    address public owner;\\n    uint256 public requiredDelay;\\n\\n    modifier validateInput(uint256 len) {\\n        require(msg.data.length == len, \\\"registry/illegal-padding\\\");\\n        _;\\n    }\\n\\n    modifier delayedExecution() {\\n        bytes32 operationHash = keccak256(msg.data);\\n        uint256 reqDelay = requiredDelay;\\n\\n        /* solhint-disable not-rely-on-time */\\n        if (lastExecuted[operationHash] == 0 && reqDelay > 0) {\\n            // not called before, scheduled for execution\\n            lastExecuted[operationHash] = block.timestamp;\\n            emit ChangeScheduled(operationHash, block.timestamp + reqDelay, msg.data);\\n        } else {\\n            require(\\n                block.timestamp - reqDelay > lastExecuted[operationHash],\\n                \\\"registry/delay-too-small\\\"\\n            );\\n            emit ChangeApplied(operationHash, block.timestamp, msg.data);\\n            _;\\n            lastExecuted[operationHash] = 0;\\n        }\\n        /* solhint-enable not-rely-on-time */\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"registry/only-owner\\\");\\n        _;\\n    }\\n\\n    constructor(uint256 initialDelay) {\\n        require(initialDelay <= MAX_DELAY, \\\"registry/invalid-delay\\\");\\n        requiredDelay = initialDelay;\\n        owner = msg.sender;\\n    }\\n\\n    function transferOwnership(\\n        address newOwner\\n    ) external onlyOwner validateInput(36) delayedExecution {\\n        owner = newOwner;\\n    }\\n\\n    function changeRequiredDelay(\\n        uint256 newDelay\\n    ) external onlyOwner validateInput(36) delayedExecution {\\n        require(newDelay <= MAX_DELAY, \\\"registry/invalid-delay\\\");\\n        requiredDelay = newDelay;\\n    }\\n\\n    function getServiceNameHash(string memory name) external pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(name));\\n    }\\n\\n    function addNamedService(\\n        bytes32 serviceNameHash,\\n        address serviceAddress\\n    ) external onlyOwner validateInput(68) delayedExecution {\\n        require(invalidHashes[serviceNameHash] == false, \\\"registry/service-name-used-before\\\");\\n        require(namedService[serviceNameHash] == address(0), \\\"registry/service-override\\\");\\n        namedService[serviceNameHash] = serviceAddress;\\n        emit NamedServiceAdded(serviceNameHash, serviceAddress);\\n    }\\n\\n    function removeNamedService(bytes32 serviceNameHash) external onlyOwner validateInput(36) {\\n        require(namedService[serviceNameHash] != address(0), \\\"registry/service-does-not-exist\\\");\\n        namedService[serviceNameHash] = address(0);\\n        invalidHashes[serviceNameHash] = true;\\n        emit NamedServiceRemoved(serviceNameHash);\\n    }\\n\\n    function getRegisteredService(string memory serviceName) external view returns (address) {\\n        return namedService[keccak256(abi.encodePacked(serviceName))];\\n    }\\n\\n    function getServiceAddress(bytes32 serviceNameHash) external view returns (address) {\\n        return namedService[serviceNameHash];\\n    }\\n\\n    function clearScheduledExecution(\\n        bytes32 scheduledExecution\\n    ) external onlyOwner validateInput(36) {\\n        require(lastExecuted[scheduledExecution] > 0, \\\"registry/execution-not-scheduled\\\");\\n        lastExecuted[scheduledExecution] = 0;\\n        emit ChangeCancelled(scheduledExecution);\\n    }\\n\\n    event ChangeScheduled(bytes32 dataHash, uint256 scheduledFor, bytes data);\\n    event ChangeApplied(bytes32 dataHash, uint256 appliedAt, bytes data);\\n    event ChangeCancelled(bytes32 dataHash);\\n    event NamedServiceRemoved(bytes32 nameHash);\\n    event NamedServiceAdded(bytes32 nameHash, address service);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vat\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spotter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mom\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_allowedReader\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"}],\"name\":\"getNextPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"useNextPrice\",\"type\":\"bool\"}],\"name\":\"getRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"getVaultInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"contract ManagerLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"osmMom\",\"outputs\":[{\"internalType\":\"contract OsmMomLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spotter\",\"outputs\":[{\"internalType\":\"contract SpotterLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vat\",\"outputs\":[{\"internalType\":\"contract VatLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "McdView", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "00000000000000000000000035d1b3f3d7966a1dfe207aa4514c12a259a0492b0000000000000000000000005ef30b9986345249bc32d8928b7ee64de9435e3900000000000000000000000065c79fcb50ca1594b025960e539ed7a9a6d434a300000000000000000000000076416a4d5190d071bfed309861527431304aa14f0000000000000000000000000b5a3c04d1199283938fbe887a2c82c808aa89fb", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}