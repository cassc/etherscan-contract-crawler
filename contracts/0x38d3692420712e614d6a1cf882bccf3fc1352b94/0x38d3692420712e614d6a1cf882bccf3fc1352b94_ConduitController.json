{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.13;\r\n\r\n/*\r\n * ...\r\n * The soldiers, like a fire consuming all the land,\r\n * moved on out. Earth groaned under them, just as it does\r\n * when Zeus, who loves thunder, in his anger lashes\r\n * the land around Typhoeus, among the Arimi,\r\n * where people say Typhoeus has his lair.\r\n * That\u2019s how the earth groaned loudly under marching feet.\r\n * ...\r\n */\r\n\r\nuint256 constant OrderReconciler_error_signature = (\r\n    0x4e5230cd00000000000000000000000000000000000000000000000000000000\r\n);\r\nuint256 constant OrderReconciler_error_ptr = 0x00;\r\nuint256 constant OrderReconciler_channel_ptr = 0x2;\r\nuint256 constant OrderReconciler_error_length = 0x24;\r\n\r\nuint256 constant ChannelClosed_error_signature = (\r\n    0x93daadf200000000000000000000000000000000000000000000000000000000\r\n);\r\nuint256 constant ChannelClosed_error_ptr = 0x00;\r\nuint256 constant ChannelClosed_channel_ptr = 0x4;\r\nuint256 constant ChannelClosed_error_length = 0x24;\r\n\r\nuint256 constant ChannelKey_channel_ptr = 0x00;\r\nuint256 constant ChannelKey_slot_ptr = 0x20;\r\nuint256 constant ChannelKey_length = 0x40;\r\n\r\nuint256 constant ThirtyOneBytes = 0x1f;\r\nuint256 constant OneWord = 0x20;\r\nuint256 constant TwoWords = 0x40;\r\nuint256 constant ThreeWords = 0x60;\r\n\r\nuint256 constant OneWordShift = 0x5;\r\nuint256 constant TwoWordsShift = 0x6;\r\n\r\nuint256 constant FreeMemoryPointerSlot = 0x40;\r\nuint256 constant ZeroSlot = 0x60;\r\nuint256 constant DefaultFreeMemoryPointer = 0x80;\r\n\r\nuint256 constant Slot0x80 = 0x80;\r\nuint256 constant Slot0xA0 = 0xa0;\r\nuint256 constant Slot0xC0 = 0xc0;\r\n\r\nuint256 constant Generic_error_selector_offset = 0x1c;\r\nuint256 constant ERC20_transferFrom_signature = (\r\n    0x23b872dd00000000000000000000000000000000000000000000000000000000\r\n);\r\nuint256 constant ERC20_transferFrom_sig_ptr = 0x0;\r\nuint256 constant ERC20_transferFrom_from_ptr = 0x04;\r\nuint256 constant ERC20_transferFrom_to_ptr = 0x24;\r\nuint256 constant ERC20_transferFrom_amount_ptr = 0x44;\r\nuint256 constant ERC20_transferFrom_length = 0x64;\r\nuint256 constant ERC1155_safeTransferFrom_signature = (\r\n    0xf242432a00000000000000000000000000000000000000000000000000000000\r\n);\r\nuint256 constant ERC1155_safeTransferFrom_sig_ptr = 0x0;\r\nuint256 constant ERC1155_safeTransferFrom_from_ptr = 0x04;\r\nuint256 constant ERC1155_safeTransferFrom_to_ptr = 0x24;\r\nuint256 constant ERC1155_safeTransferFrom_id_ptr = 0x44;\r\nuint256 constant ERC1155_safeTransferFrom_amount_ptr = 0x64;\r\nuint256 constant ERC1155_safeTransferFrom_data_offset_ptr = 0x84;\r\nuint256 constant ERC1155_safeTransferFrom_data_length_ptr = 0xa4;\r\nuint256 constant ERC1155_safeTransferFrom_length = 0xc4;\r\nuint256 constant ERC1155_safeTransferFrom_data_length_offset = 0xa0;\r\n\r\nuint256 constant ERC1155_safeBatchTransferFrom_signature = (\r\n    0x2eb2c2d600000000000000000000000000000000000000000000000000000000\r\n);\r\nuint256 constant ERC721_transferFrom_signature = (\r\n    0x23b872dd00000000000000000000000000000000000000000000000000000000\r\n);\r\nuint256 constant ERC721_transferFrom_sig_ptr = 0x0;\r\nuint256 constant ERC721_transferFrom_from_ptr = 0x04;\r\nuint256 constant ERC721_transferFrom_to_ptr = 0x24;\r\nuint256 constant ERC721_transferFrom_id_ptr = 0x44;\r\nuint256 constant ERC721_transferFrom_length = 0x64;\r\nuint256 constant NoContract_error_selector = 0x5f15d672;\r\nuint256 constant NoContract_error_account_ptr = 0x20;\r\nuint256 constant NoContract_error_length = 0x24;\r\nuint256 constant TokenTransferGenericFailure_error_selector = 0xf486bc87;\r\nuint256 constant TokenTransferGenericFailure_error_token_ptr = 0x20;\r\nuint256 constant TokenTransferGenericFailure_error_from_ptr = 0x40;\r\nuint256 constant TokenTransferGenericFailure_error_to_ptr = 0x60;\r\nuint256 constant TokenTransferGenericFailure_error_identifier_ptr = 0x80;\r\nuint256 constant TokenTransferGenericFailure_err_identifier_ptr = 0x80;\r\nuint256 constant TokenTransferGenericFailure_error_amount_ptr = 0xa0;\r\nuint256 constant TokenTransferGenericFailure_error_length = 0xa4;\r\n\r\nuint256 constant ExtraGasBuffer = 0x20;\r\nuint256 constant CostPerWord = 0x3;\r\nuint256 constant MemoryExpansionCoefficientShift = 0x9;\r\n\r\nuint256 constant BatchTransfer1155Params_ptr = 0x24;\r\nuint256 constant BatchTransfer1155Params_ids_head_ptr = 0x64;\r\nuint256 constant BatchTransfer1155Params_amounts_head_ptr = 0x84;\r\nuint256 constant BatchTransfer1155Params_data_head_ptr = 0xa4;\r\nuint256 constant BatchTransfer1155Params_data_length_basePtr = 0xc4;\r\nuint256 constant BatchTransfer1155Params_calldata_baseSize = 0xc4;\r\nuint256 constant BatchTransfer1155Params_ids_length_ptr = 0xc4;\r\nuint256 constant BatchTransfer1155Params_ids_length_offset = 0xa0;\r\nuint256 constant ConduitBatch1155Transfer_usable_head_size = 0x80;\r\nuint256 constant ConduitBatch1155Transfer_from_offset = 0x20;\r\nuint256 constant ConduitBatch1155Transfer_ids_head_offset = 0x60;\r\nuint256 constant ConduitBatch1155Transfer_ids_length_offset = 0xa0;\r\nuint256 constant ConduitBatch1155Transfer_amounts_length_baseOffset = 0xc0;\r\nuint256 constant ConduitBatchTransfer_amounts_head_offset = 0x80;\r\nuint256 constant Invalid1155BatchTransferEncoding_ptr = 0x00;\r\nuint256 constant Invalid1155BatchTransferEncoding_length = 0x04;\r\nuint256 constant Invalid1155BatchTransferEncoding_selector = (\r\n    0xeba2084c00000000000000000000000000000000000000000000000000000000\r\n);\r\n\r\nuint256 constant ERC1155BatchTransferGenericFailure_error_signature = (\r\n    0xafc445e200000000000000000000000000000000000000000000000000000000\r\n);\r\nuint256 constant ERC1155BatchTransferGenericFailure_token_ptr = 0x04;\r\nuint256 constant ERC1155BatchTransferGenericFailure_ids_offset = 0xc0;\r\n\r\nuint256 constant BadReturnValueFromERC20OnTransfer_error_selector = 0x98891923;\r\nuint256 constant BadReturnValueFromERC20OnTransfer_error_token_ptr = 0x20;\r\nuint256 constant BadReturnValueFromERC20OnTransfer_error_from_ptr = 0x40;\r\nuint256 constant BadReturnValueFromERC20OnTransfer_error_to_ptr = 0x60;\r\nuint256 constant BadReturnValueFromERC20OnTransfer_error_amount_ptr = 0x80;\r\nuint256 constant BadReturnValueFromERC20OnTransfer_error_length = 0x84;\r\n\r\nenum ConduitItemType {\r\n    NATIVE,\r\n    ERC20,\r\n    ERC721,\r\n    ERC1155\r\n}\r\n\r\nstruct ConduitTransfer {\r\n    ConduitItemType itemType;\r\n    address token;\r\n    address from;\r\n    address to;\r\n    uint256 identifier;\r\n    uint256 amount;\r\n}\r\n\r\nstruct ConduitBatch1155Transfer {\r\n    address token;\r\n    address from;\r\n    address to;\r\n    uint256[] ids;\r\n    uint256[] amounts;\r\n}\r\n\r\ninterface ConduitInterface {\r\n    error ChannelClosed(address channel);\r\n\r\n    error ChannelStatusAlreadySet(address channel, bool isOpen);\r\n\r\n    error InvalidItemType();\r\n\r\n    error InvalidController();\r\n\r\n    event ChannelUpdated(address indexed channel, bool open);\r\n\r\n    function execute(\r\n        ConduitTransfer[] calldata transfers\r\n    ) external returns (bytes4 magicValue);\r\n\r\n    function executeBatch1155(\r\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\r\n    ) external returns (bytes4 magicValue);\r\n\r\n    function executeWithBatch1155(\r\n        ConduitTransfer[] calldata standardTransfers,\r\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\r\n    ) external returns (bytes4 magicValue);\r\n\r\n    function updateChannel(address channel, bool isOpen) external;\r\n}\r\n\r\ninterface ConduitControllerInterface {\r\n    struct ConduitProperties {\r\n        bytes32 key;\r\n        address owner;\r\n        address potentialOwner;\r\n        address[] channels;\r\n        mapping(address => uint256) channelIndexesPlusOne;\r\n    }\r\n\r\n    event NewConduit(address conduit, bytes32 conduitKey);\r\n\r\n    event OwnershipTransferred(\r\n        address indexed conduit,\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    event PotentialOwnerUpdated(address indexed newPotentialOwner);\r\n\r\n    error InvalidCreator();\r\n\r\n    error InvalidInitialOwner();\r\n\r\n    error NewPotentialOwnerAlreadySet(\r\n        address conduit,\r\n        address newPotentialOwner\r\n    );\r\n\r\n    error NoPotentialOwnerCurrentlySet(address conduit);\r\n\r\n    error NoConduit();\r\n\r\n    error ConduitAlreadyExists(address conduit);\r\n\r\n    error CallerIsNotOwner(address conduit);\r\n\r\n    error NewPotentialOwnerIsZeroAddress(address conduit);\r\n\r\n    error CallerIsNotNewPotentialOwner(address conduit);\r\n\r\n    error ChannelOutOfRange(address conduit);\r\n\r\n    function createConduit(\r\n        bytes32 conduitKey,\r\n        address initialOwner\r\n    ) external returns (address conduit);\r\n\r\n    function updateChannel(\r\n        address conduit,\r\n        address channel,\r\n        bool isOpen\r\n    ) external;\r\n\r\n    function transferOwnership(\r\n        address conduit,\r\n        address newPotentialOwner\r\n    ) external;\r\n\r\n    function cancelOwnershipTransfer(address conduit) external;\r\n\r\n    function acceptOwnership(address conduit) external;\r\n\r\n    function ownerOf(address conduit) external view returns (address owner);\r\n\r\n    function getKey(address conduit) external view returns (bytes32 conduitKey);\r\n\r\n    function getConduit(\r\n        bytes32 conduitKey\r\n    ) external view returns (address conduit, bool exists);\r\n\r\n    function getPotentialOwner(\r\n        address conduit\r\n    ) external view returns (address potentialOwner);\r\n\r\n    function getChannelStatus(\r\n        address conduit,\r\n        address channel\r\n    ) external view returns (bool isOpen);\r\n\r\n    function getTotalChannels(\r\n        address conduit\r\n    ) external view returns (uint256 totalChannels);\r\n\r\n    function getChannel(\r\n        address conduit,\r\n        uint256 channelIndex\r\n    ) external view returns (address channel);\r\n\r\n    function getChannels(\r\n        address conduit\r\n    ) external view returns (address[] memory channels);\r\n\r\n    function getConduitCodeHashes()\r\n        external\r\n        view\r\n        returns (bytes32 creationCodeHash, bytes32 runtimeCodeHash);\r\n}\r\n\r\ninterface TokenTransferrerErrors {\r\n    error InvalidERC721TransferAmount(uint256 amount);\r\n\r\n    error MissingItemAmount();\r\n\r\n    error UnusedItemParameters();\r\n\r\n    error TokenTransferGenericFailure(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 identifier,\r\n        uint256 amount\r\n    );\r\n\r\n    error ERC1155BatchTransferGenericFailure(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256[] identifiers,\r\n        uint256[] amounts\r\n    );\r\n\r\n    error BadReturnValueFromERC20OnTransfer(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    );\r\n\r\n    error NoContract(address account);\r\n\r\n    error Invalid1155BatchTransferEncoding();\r\n}\r\n\r\ncontract TokenTransferrer is TokenTransferrerErrors {\r\n    function _performERC20Transfer(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        assembly {\r\n            let memPointer := mload(FreeMemoryPointerSlot)\r\n            mstore(ERC20_transferFrom_sig_ptr, ERC20_transferFrom_signature)\r\n            mstore(ERC20_transferFrom_from_ptr, from)\r\n            mstore(ERC20_transferFrom_to_ptr, to)\r\n            mstore(ERC20_transferFrom_amount_ptr, amount)\r\n            let callStatus := call(\r\n                gas(),\r\n                token,\r\n                0,\r\n                ERC20_transferFrom_sig_ptr,\r\n                ERC20_transferFrom_length,\r\n                0,\r\n                OneWord\r\n            )\r\n            let success := and(\r\n                or(\r\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\r\n                    iszero(returndatasize())\r\n                ),\r\n                callStatus\r\n            )\r\n            if iszero(and(success, iszero(iszero(returndatasize())))) {\r\n                if iszero(and(iszero(iszero(extcodesize(token))), success)) {\r\n                    if iszero(success) {\r\n                        if iszero(callStatus) {\r\n                            if returndatasize() {\r\n                                let returnDataWords := shr(\r\n                                    OneWordShift,\r\n                                    add(returndatasize(), ThirtyOneBytes)\r\n                                )\r\n                                let msizeWords := shr(OneWordShift, memPointer)\r\n                                let cost := mul(CostPerWord, returnDataWords)\r\n                                if gt(returnDataWords, msizeWords) {\r\n                                    cost := add(\r\n                                        cost,\r\n                                        add(\r\n                                            mul(\r\n                                                sub(\r\n                                                    returnDataWords,\r\n                                                    msizeWords\r\n                                                ),\r\n                                                CostPerWord\r\n                                            ),\r\n                                            shr(\r\n                                                MemoryExpansionCoefficientShift,\r\n                                                sub(\r\n                                                    mul(\r\n                                                        returnDataWords,\r\n                                                        returnDataWords\r\n                                                    ),\r\n                                                    mul(msizeWords, msizeWords)\r\n                                                )\r\n                                            )\r\n                                        )\r\n                                    )\r\n                                }\r\n                                if lt(add(cost, ExtraGasBuffer), gas()) {\r\n                                    returndatacopy(0, 0, returndatasize())\r\n                                    revert(0, returndatasize())\r\n                                }\r\n                            }\r\n                            mstore(\r\n                                0,\r\n                                TokenTransferGenericFailure_error_selector\r\n                            )\r\n                            mstore(\r\n                                TokenTransferGenericFailure_error_token_ptr,\r\n                                token\r\n                            )\r\n                            mstore(\r\n                                TokenTransferGenericFailure_error_from_ptr,\r\n                                from\r\n                            )\r\n                            mstore(TokenTransferGenericFailure_error_to_ptr, to)\r\n                            mstore(\r\n                                TokenTransferGenericFailure_err_identifier_ptr,\r\n                                0\r\n                            )\r\n                            mstore(\r\n                                TokenTransferGenericFailure_error_amount_ptr,\r\n                                amount\r\n                            )\r\n                            revert(\r\n                                Generic_error_selector_offset,\r\n                                TokenTransferGenericFailure_error_length\r\n                            )\r\n                        }\r\n                        mstore(\r\n                            0,\r\n                            BadReturnValueFromERC20OnTransfer_error_selector\r\n                        )\r\n                        mstore(\r\n                            BadReturnValueFromERC20OnTransfer_error_token_ptr,\r\n                            token\r\n                        )\r\n                        mstore(\r\n                            BadReturnValueFromERC20OnTransfer_error_from_ptr,\r\n                            from\r\n                        )\r\n                        mstore(\r\n                            BadReturnValueFromERC20OnTransfer_error_to_ptr,\r\n                            to\r\n                        )\r\n                        mstore(\r\n                            BadReturnValueFromERC20OnTransfer_error_amount_ptr,\r\n                            amount\r\n                        )\r\n                        revert(\r\n                            Generic_error_selector_offset,\r\n                            BadReturnValueFromERC20OnTransfer_error_length\r\n                        )\r\n                    }\r\n                    mstore(0, NoContract_error_selector)\r\n                    mstore(NoContract_error_account_ptr, token)\r\n                    revert(\r\n                        Generic_error_selector_offset,\r\n                        NoContract_error_length\r\n                    )\r\n                }\r\n            }\r\n            mstore(FreeMemoryPointerSlot, memPointer)\r\n            mstore(ZeroSlot, 0)\r\n        }\r\n    }\r\n\r\n    function _performERC721Transfer(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 identifier\r\n    ) internal {\r\n        assembly {\r\n            if iszero(extcodesize(token)) {\r\n                mstore(0, NoContract_error_selector)\r\n                mstore(NoContract_error_account_ptr, token)\r\n                revert(Generic_error_selector_offset, NoContract_error_length)\r\n            }\r\n            let memPointer := mload(FreeMemoryPointerSlot)\r\n            mstore(ERC721_transferFrom_sig_ptr, ERC721_transferFrom_signature)\r\n            mstore(ERC721_transferFrom_from_ptr, from)\r\n            mstore(ERC721_transferFrom_to_ptr, to)\r\n            mstore(ERC721_transferFrom_id_ptr, identifier)\r\n\r\n            let success := call(\r\n                gas(),\r\n                token,\r\n                0,\r\n                ERC721_transferFrom_sig_ptr,\r\n                ERC721_transferFrom_length,\r\n                0,\r\n                0\r\n            )\r\n\r\n            if iszero(success) {\r\n                if returndatasize() {\r\n                    let returnDataWords := shr(\r\n                        OneWordShift,\r\n                        add(returndatasize(), ThirtyOneBytes)\r\n                    )\r\n\r\n                    let msizeWords := shr(OneWordShift, memPointer)\r\n                    let cost := mul(CostPerWord, returnDataWords)\r\n                    if gt(returnDataWords, msizeWords) {\r\n                        cost := add(\r\n                            cost,\r\n                            add(\r\n                                mul(\r\n                                    sub(returnDataWords, msizeWords),\r\n                                    CostPerWord\r\n                                ),\r\n                                shr(\r\n                                    MemoryExpansionCoefficientShift,\r\n                                    sub(\r\n                                        mul(returnDataWords, returnDataWords),\r\n                                        mul(msizeWords, msizeWords)\r\n                                    )\r\n                                )\r\n                            )\r\n                        )\r\n                    }\r\n\r\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\r\n                        returndatacopy(0, 0, returndatasize())\r\n\r\n                        revert(0, returndatasize())\r\n                    }\r\n                }\r\n                mstore(0, TokenTransferGenericFailure_error_selector)\r\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\r\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\r\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\r\n                mstore(\r\n                    TokenTransferGenericFailure_error_identifier_ptr,\r\n                    identifier\r\n                )\r\n                mstore(TokenTransferGenericFailure_error_amount_ptr, 1)\r\n                revert(\r\n                    Generic_error_selector_offset,\r\n                    TokenTransferGenericFailure_error_length\r\n                )\r\n            }\r\n            mstore(FreeMemoryPointerSlot, memPointer)\r\n            mstore(ZeroSlot, 0)\r\n        }\r\n    }\r\n\r\n    function _performERC1155Transfer(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 identifier,\r\n        uint256 amount\r\n    ) internal {\r\n        assembly {\r\n            if iszero(extcodesize(token)) {\r\n                mstore(0, NoContract_error_selector)\r\n                mstore(NoContract_error_account_ptr, token)\r\n                revert(Generic_error_selector_offset, NoContract_error_length)\r\n            }\r\n            let memPointer := mload(FreeMemoryPointerSlot)\r\n            let slot0x80 := mload(Slot0x80)\r\n            let slot0xA0 := mload(Slot0xA0)\r\n            let slot0xC0 := mload(Slot0xC0)\r\n            mstore(\r\n                ERC1155_safeTransferFrom_sig_ptr,\r\n                ERC1155_safeTransferFrom_signature\r\n            )\r\n            mstore(ERC1155_safeTransferFrom_from_ptr, from)\r\n            mstore(ERC1155_safeTransferFrom_to_ptr, to)\r\n            mstore(ERC1155_safeTransferFrom_id_ptr, identifier)\r\n            mstore(ERC1155_safeTransferFrom_amount_ptr, amount)\r\n            mstore(\r\n                ERC1155_safeTransferFrom_data_offset_ptr,\r\n                ERC1155_safeTransferFrom_data_length_offset\r\n            )\r\n            mstore(ERC1155_safeTransferFrom_data_length_ptr, 0)\r\n\r\n            let success := call(\r\n                gas(),\r\n                token,\r\n                0,\r\n                ERC1155_safeTransferFrom_sig_ptr,\r\n                ERC1155_safeTransferFrom_length,\r\n                0,\r\n                0\r\n            )\r\n\r\n            if iszero(success) {\r\n                if returndatasize() {\r\n                    let returnDataWords := shr(\r\n                        OneWordShift,\r\n                        add(returndatasize(), ThirtyOneBytes)\r\n                    )\r\n                    let msizeWords := shr(OneWordShift, memPointer)\r\n                    let cost := mul(CostPerWord, returnDataWords)\r\n\r\n                    if gt(returnDataWords, msizeWords) {\r\n                        cost := add(\r\n                            cost,\r\n                            add(\r\n                                mul(\r\n                                    sub(returnDataWords, msizeWords),\r\n                                    CostPerWord\r\n                                ),\r\n                                shr(\r\n                                    MemoryExpansionCoefficientShift,\r\n                                    sub(\r\n                                        mul(returnDataWords, returnDataWords),\r\n                                        mul(msizeWords, msizeWords)\r\n                                    )\r\n                                )\r\n                            )\r\n                        )\r\n                    }\r\n\r\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\r\n                        returndatacopy(0, 0, returndatasize())\r\n                        revert(0, returndatasize())\r\n                    }\r\n                }\r\n                mstore(0, TokenTransferGenericFailure_error_selector)\r\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\r\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\r\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\r\n                mstore(\r\n                    TokenTransferGenericFailure_error_identifier_ptr,\r\n                    identifier\r\n                )\r\n                mstore(TokenTransferGenericFailure_error_amount_ptr, amount)\r\n                revert(\r\n                    Generic_error_selector_offset,\r\n                    TokenTransferGenericFailure_error_length\r\n                )\r\n            }\r\n\r\n            mstore(Slot0x80, slot0x80)\r\n            mstore(Slot0xA0, slot0xA0)\r\n            mstore(Slot0xC0, slot0xC0)\r\n\r\n            mstore(FreeMemoryPointerSlot, memPointer)\r\n\r\n            mstore(ZeroSlot, 0)\r\n        }\r\n    }\r\n\r\n    function _performERC1155BatchTransfers(\r\n        ConduitBatch1155Transfer[] calldata batchTransfers\r\n    ) internal {\r\n        assembly {\r\n            let len := batchTransfers.length\r\n            let nextElementHeadPtr := batchTransfers.offset\r\n\r\n            let arrayHeadPtr := nextElementHeadPtr\r\n\r\n            mstore(\r\n                ConduitBatch1155Transfer_from_offset,\r\n                ERC1155_safeBatchTransferFrom_signature\r\n            )\r\n\r\n            for {\r\n                let i := 0\r\n            } lt(i, len) {\r\n                i := add(i, 1)\r\n            } {\r\n                let elementPtr := add(\r\n                    arrayHeadPtr,\r\n                    calldataload(nextElementHeadPtr)\r\n                )\r\n                let token := calldataload(elementPtr)\r\n\r\n                if iszero(extcodesize(token)) {\r\n                    mstore(0, NoContract_error_selector)\r\n                    mstore(NoContract_error_account_ptr, token)\r\n\r\n                    revert(\r\n                        Generic_error_selector_offset,\r\n                        NoContract_error_length\r\n                    )\r\n                }\r\n\r\n                let idsLength := calldataload(\r\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset)\r\n                )\r\n\r\n                let expectedAmountsOffset := add(\r\n                    ConduitBatch1155Transfer_amounts_length_baseOffset,\r\n                    shl(OneWordShift, idsLength)\r\n                )\r\n\r\n                let invalidEncoding := iszero(\r\n                    and(\r\n                        eq(\r\n                            idsLength,\r\n                            calldataload(add(elementPtr, expectedAmountsOffset))\r\n                        ),\r\n                        and(\r\n                            eq(\r\n                                calldataload(\r\n                                    add(\r\n                                        elementPtr,\r\n                                        ConduitBatch1155Transfer_ids_head_offset\r\n                                    )\r\n                                ),\r\n                                ConduitBatch1155Transfer_ids_length_offset\r\n                            ),\r\n                            eq(\r\n                                calldataload(\r\n                                    add(\r\n                                        elementPtr,\r\n                                        ConduitBatchTransfer_amounts_head_offset\r\n                                    )\r\n                                ),\r\n                                expectedAmountsOffset\r\n                            )\r\n                        )\r\n                    )\r\n                )\r\n\r\n                if invalidEncoding {\r\n                    mstore(\r\n                        Invalid1155BatchTransferEncoding_ptr,\r\n                        Invalid1155BatchTransferEncoding_selector\r\n                    )\r\n                    revert(\r\n                        Invalid1155BatchTransferEncoding_ptr,\r\n                        Invalid1155BatchTransferEncoding_length\r\n                    )\r\n                }\r\n                nextElementHeadPtr := add(nextElementHeadPtr, OneWord)\r\n                calldatacopy(\r\n                    BatchTransfer1155Params_ptr,\r\n                    add(elementPtr, ConduitBatch1155Transfer_from_offset),\r\n                    ConduitBatch1155Transfer_usable_head_size\r\n                )\r\n                let idsAndAmountsSize := add(\r\n                    TwoWords,\r\n                    shl(TwoWordsShift, idsLength)\r\n                )\r\n                mstore(\r\n                    BatchTransfer1155Params_data_head_ptr,\r\n                    add(\r\n                        BatchTransfer1155Params_ids_length_offset,\r\n                        idsAndAmountsSize\r\n                    )\r\n                )\r\n                mstore(\r\n                    add(\r\n                        BatchTransfer1155Params_data_length_basePtr,\r\n                        idsAndAmountsSize\r\n                    ),\r\n                    0\r\n                )\r\n\r\n                let transferDataSize := add(\r\n                    BatchTransfer1155Params_calldata_baseSize,\r\n                    idsAndAmountsSize\r\n                )\r\n\r\n                calldatacopy(\r\n                    BatchTransfer1155Params_ids_length_ptr,\r\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset),\r\n                    idsAndAmountsSize\r\n                )\r\n\r\n                let success := call(\r\n                    gas(),\r\n                    token,\r\n                    0,\r\n                    ConduitBatch1155Transfer_from_offset,\r\n                    transferDataSize,\r\n                    0,\r\n                    0\r\n                )\r\n\r\n                if iszero(success) {\r\n                    if returndatasize() {\r\n                        let returnDataWords := shr(\r\n                            OneWordShift,\r\n                            add(returndatasize(), ThirtyOneBytes)\r\n                        )\r\n                        let msizeWords := shr(OneWordShift, transferDataSize)\r\n\r\n                        let cost := mul(CostPerWord, returnDataWords)\r\n\r\n                        if gt(returnDataWords, msizeWords) {\r\n                            cost := add(\r\n                                cost,\r\n                                add(\r\n                                    mul(\r\n                                        sub(returnDataWords, msizeWords),\r\n                                        CostPerWord\r\n                                    ),\r\n                                    shr(\r\n                                        MemoryExpansionCoefficientShift,\r\n                                        sub(\r\n                                            mul(\r\n                                                returnDataWords,\r\n                                                returnDataWords\r\n                                            ),\r\n                                            mul(msizeWords, msizeWords)\r\n                                        )\r\n                                    )\r\n                                )\r\n                            )\r\n                        }\r\n                        if lt(add(cost, ExtraGasBuffer), gas()) {\r\n                            returndatacopy(0, 0, returndatasize())\r\n                            revert(0, returndatasize())\r\n                        }\r\n                    }\r\n\r\n                    mstore(\r\n                        0,\r\n                        ERC1155BatchTransferGenericFailure_error_signature\r\n                    )\r\n\r\n                    mstore(ERC1155BatchTransferGenericFailure_token_ptr, token)\r\n\r\n                    mstore(\r\n                        BatchTransfer1155Params_ids_head_ptr,\r\n                        ERC1155BatchTransferGenericFailure_ids_offset\r\n                    )\r\n\r\n                    mstore(\r\n                        BatchTransfer1155Params_amounts_head_ptr,\r\n                        add(\r\n                            OneWord,\r\n                            mload(BatchTransfer1155Params_amounts_head_ptr)\r\n                        )\r\n                    )\r\n\r\n                    revert(0, transferDataSize)\r\n                }\r\n            }\r\n            mstore(FreeMemoryPointerSlot, DefaultFreeMemoryPointer)\r\n        }\r\n    }\r\n}\r\ncontract Conduit is ConduitInterface, TokenTransferrer {\r\n    address private immutable _controller;\r\n    mapping(address => bool) private _channels;\r\n    modifier onlyOpenChannel() {\r\n        assembly {\r\n            mstore(ChannelKey_channel_ptr, caller())\r\n            mstore(ChannelKey_slot_ptr, _channels.slot)\r\n            if iszero(\r\n                sload(keccak256(ChannelKey_channel_ptr, ChannelKey_length))\r\n            ) {\r\n                mstore(ChannelClosed_error_ptr, ChannelClosed_error_signature)\r\n                mstore(ChannelClosed_channel_ptr, caller())\r\n                revert(ChannelClosed_error_ptr, ChannelClosed_error_length)\r\n            }\r\n        }\r\n        _;\r\n    }\r\n    constructor() {\r\n        _controller = msg.sender;\r\n    }\r\n    function execute(\r\n        ConduitTransfer[] calldata transfers\r\n    ) external override onlyOpenChannel returns (bytes4 magicValue) {\r\n        uint256 totalStandardTransfers = transfers.length;\r\n        for (uint256 i = 0; i < totalStandardTransfers; ) {\r\n            _transfer(transfers[i]);\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        magicValue = this.execute.selector;\r\n    }\r\n\r\n    function executeBatch1155(\r\n        ConduitBatch1155Transfer[] calldata batchTransfers\r\n    ) external override onlyOpenChannel returns (bytes4 magicValue) {\r\n        _performERC1155BatchTransfers(batchTransfers);\r\n        magicValue = this.executeBatch1155.selector;\r\n    }\r\n    function executeWithBatch1155(\r\n        ConduitTransfer[] calldata standardTransfers,\r\n        ConduitBatch1155Transfer[] calldata batchTransfers\r\n    ) external override onlyOpenChannel returns (bytes4 magicValue) {\r\n        uint256 totalStandardTransfers = standardTransfers.length;\r\n        for (uint256 i = 0; i < totalStandardTransfers; ) {\r\n            _transfer(standardTransfers[i]);\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        _performERC1155BatchTransfers(batchTransfers);\r\n        magicValue = this.executeWithBatch1155.selector;\r\n    }\r\n    function updateChannel(address channel, bool isOpen) external override {\r\n        if (msg.sender != _controller) {\r\n            revert InvalidController();\r\n        }\r\n        if (_channels[channel] == isOpen) {\r\n            revert ChannelStatusAlreadySet(channel, isOpen);\r\n        }\r\n        _channels[channel] = isOpen;\r\n        emit ChannelUpdated(channel, isOpen);\r\n    }\r\n    function _transfer(ConduitTransfer calldata item) internal {\r\n        if (item.itemType == ConduitItemType.ERC20) {\r\n            _performERC20Transfer(item.token, item.from, item.to, item.amount);\r\n        } else if (item.itemType == ConduitItemType.ERC721) {\r\n            if (item.amount != 1) {\r\n                revert InvalidERC721TransferAmount(item.amount);\r\n            }\r\n            _performERC721Transfer(\r\n                item.token,\r\n                item.from,\r\n                item.to,\r\n                item.identifier\r\n            );\r\n        } else if (item.itemType == ConduitItemType.ERC1155) {\r\n            _performERC1155Transfer(\r\n                item.token,\r\n                item.from,\r\n                item.to,\r\n                item.identifier,\r\n                item.amount\r\n            );\r\n        } else {\r\n            revert InvalidItemType();\r\n        }\r\n    }\r\n}\r\n\r\ncontract ConduitController is ConduitControllerInterface {\r\n    uint256 internal immutable _CC_DEPLOYMENY_REVISION = 1;\r\n    mapping(address => ConduitProperties) internal _conduits;\r\n    bytes32 internal immutable _CONDUIT_CREATION_CODE_HASH;\r\n    bytes32 internal immutable _CONDUIT_RUNTIME_CODE_HASH;\r\n    constructor() {\r\n        _CONDUIT_CREATION_CODE_HASH = keccak256(type(Conduit).creationCode);\r\n\r\n        Conduit zeroConduit = new Conduit{ salt: bytes32(0) }();\r\n\r\n        _CONDUIT_RUNTIME_CODE_HASH = address(zeroConduit).codehash;\r\n    }\r\n\r\n    function createConduit(\r\n        bytes32 conduitKey,\r\n        address initialOwner\r\n    ) external override returns (address conduit) {\r\n        if (initialOwner == address(0)) {\r\n            revert InvalidInitialOwner();\r\n        }\r\n        if (address(uint160(bytes20(conduitKey))) != msg.sender) {\r\n            revert InvalidCreator();\r\n        }\r\n        conduit = address(\r\n            uint160(\r\n                uint256(\r\n                    keccak256(\r\n                        abi.encodePacked(\r\n                            bytes1(0xff),\r\n                            address(this),\r\n                            conduitKey,\r\n                            _CONDUIT_CREATION_CODE_HASH\r\n                        )\r\n                    )\r\n                )\r\n            )\r\n        );\r\n\r\n        if (conduit.codehash == _CONDUIT_RUNTIME_CODE_HASH) {\r\n            revert ConduitAlreadyExists(conduit);\r\n        }\r\n        new Conduit{ salt: conduitKey }();\r\n        ConduitProperties storage conduitProperties = _conduits[conduit];\r\n        conduitProperties.owner = initialOwner;\r\n\r\n        conduitProperties.key = conduitKey;\r\n        emit NewConduit(conduit, conduitKey);\r\n        emit OwnershipTransferred(conduit, address(0), initialOwner);\r\n    }\r\n\r\n    function updateChannel(\r\n        address conduit,\r\n        address channel,\r\n        bool isOpen\r\n    ) external override {\r\n        _assertCallerIsConduitOwner(conduit);\r\n\r\n        ConduitInterface(conduit).updateChannel(channel, isOpen);\r\n\r\n        ConduitProperties storage conduitProperties = _conduits[conduit];\r\n\r\n        uint256 channelIndexPlusOne = (\r\n            conduitProperties.channelIndexesPlusOne[channel]\r\n        );\r\n        bool channelPreviouslyOpen = channelIndexPlusOne != 0;\r\n\r\n        if (isOpen && !channelPreviouslyOpen) {\r\n            conduitProperties.channels.push(channel);\r\n\r\n            conduitProperties.channelIndexesPlusOne[channel] = (\r\n                conduitProperties.channels.length\r\n            );\r\n        } else if (!isOpen && channelPreviouslyOpen) {\r\n            uint256 removedChannelIndex;\r\n\r\n            unchecked {\r\n                removedChannelIndex = channelIndexPlusOne - 1;\r\n            }\r\n            uint256 finalChannelIndex = conduitProperties.channels.length - 1;\r\n\r\n            if (finalChannelIndex != removedChannelIndex) {\r\n                address finalChannel = (\r\n                    conduitProperties.channels[finalChannelIndex]\r\n                );\r\n                conduitProperties.channels[removedChannelIndex] = finalChannel;\r\n                conduitProperties.channelIndexesPlusOne[finalChannel] = (\r\n                    channelIndexPlusOne\r\n                );\r\n            }\r\n            conduitProperties.channels.pop();\r\n            delete conduitProperties.channelIndexesPlusOne[channel];\r\n        }\r\n    }\r\n    function transferOwnership(\r\n        address conduit,\r\n        address newPotentialOwner\r\n    ) external override {\r\n        _assertCallerIsConduitOwner(conduit);\r\n        if (newPotentialOwner == address(0)) {\r\n            revert NewPotentialOwnerIsZeroAddress(conduit);\r\n        }\r\n        if (newPotentialOwner == _conduits[conduit].potentialOwner) {\r\n            revert NewPotentialOwnerAlreadySet(conduit, newPotentialOwner);\r\n        }\r\n        emit PotentialOwnerUpdated(newPotentialOwner);\r\n\r\n        _conduits[conduit].potentialOwner = newPotentialOwner;\r\n    }\r\n    function cancelOwnershipTransfer(address conduit) external override {\r\n        _assertCallerIsConduitOwner(conduit);\r\n        if (_conduits[conduit].potentialOwner == address(0)) {\r\n            revert NoPotentialOwnerCurrentlySet(conduit);\r\n        }\r\n        emit PotentialOwnerUpdated(address(0));\r\n        _conduits[conduit].potentialOwner = address(0);\r\n    }\r\n\r\n    function acceptOwnership(address conduit) external override {\r\n        _assertConduitExists(conduit);\r\n        if (msg.sender != _conduits[conduit].potentialOwner) {\r\n            revert CallerIsNotNewPotentialOwner(conduit);\r\n        }\r\n        emit PotentialOwnerUpdated(address(0));\r\n        _conduits[conduit].potentialOwner = address(0);\r\n        emit OwnershipTransferred(\r\n            conduit,\r\n            _conduits[conduit].owner,\r\n            msg.sender\r\n        );\r\n        _conduits[conduit].owner = msg.sender;\r\n    }\r\n\r\n    function ownerOf(\r\n        address conduit\r\n    ) external view override returns (address owner) {\r\n        _assertConduitExists(conduit);\r\n        owner = _conduits[conduit].owner;\r\n    }\r\n\r\n    function getKey(\r\n        address conduit\r\n    ) external view override returns (bytes32 conduitKey) {\r\n        conduitKey = _conduits[conduit].key;\r\n        if (conduitKey == bytes32(0)) {\r\n            revert NoConduit();\r\n        }\r\n    }\r\n    function _NS_CONTRACT_ROLE() external pure returns (string memory) {\r\n        return \"ConduitController\";\r\n    }\r\n    function getConduit(\r\n        bytes32 conduitKey\r\n    ) external view override returns (address conduit, bool exists) {\r\n        conduit = address(\r\n            uint160(\r\n                uint256(\r\n                    keccak256(\r\n                        abi.encodePacked(\r\n                            bytes1(0xff),\r\n                            address(this),\r\n                            conduitKey,\r\n                            _CONDUIT_CREATION_CODE_HASH\r\n                        )\r\n                    )\r\n                )\r\n            )\r\n        );\r\n        exists = (conduit.codehash == _CONDUIT_RUNTIME_CODE_HASH);\r\n    }\r\n    function getPotentialOwner(\r\n        address conduit\r\n    ) external view override returns (address potentialOwner) {\r\n        _assertConduitExists(conduit);\r\n        potentialOwner = _conduits[conduit].potentialOwner;\r\n    }\r\n    function getChannelStatus(\r\n        address conduit,\r\n        address channel\r\n    ) external view override returns (bool isOpen) {\r\n        _assertConduitExists(conduit);\r\n        isOpen = _conduits[conduit].channelIndexesPlusOne[channel] != 0;\r\n    }\r\n    function getTotalChannels(\r\n        address conduit\r\n    ) external view override returns (uint256 totalChannels) {\r\n        _assertConduitExists(conduit);\r\n        totalChannels = _conduits[conduit].channels.length;\r\n    }\r\n    function getChannel(\r\n        address conduit,\r\n        uint256 channelIndex\r\n    ) external view override returns (address channel) {\r\n        _assertConduitExists(conduit);\r\n        uint256 totalChannels = _conduits[conduit].channels.length;\r\n        if (channelIndex >= totalChannels) {\r\n            revert ChannelOutOfRange(conduit);\r\n        }\r\n        channel = _conduits[conduit].channels[channelIndex];\r\n    }\r\n    function getChannels(\r\n        address conduit\r\n    ) external view override returns (address[] memory channels) {\r\n        _assertConduitExists(conduit);\r\n        channels = _conduits[conduit].channels;\r\n    }\r\n\r\n    function getConduitCodeHashes()\r\n        external\r\n        view\r\n        override\r\n        returns (bytes32 creationCodeHash, bytes32 runtimeCodeHash)\r\n    {\r\n        creationCodeHash = _CONDUIT_CREATION_CODE_HASH;\r\n        runtimeCodeHash = _CONDUIT_RUNTIME_CODE_HASH;\r\n    }\r\n    function _assertCallerIsConduitOwner(address conduit) private view {\r\n        _assertConduitExists(conduit);\r\n        if (msg.sender != _conduits[conduit].owner) {\r\n            revert CallerIsNotOwner(conduit);\r\n        }\r\n    }\r\n    function _assertConduitExists(address conduit) private view {\r\n        if (_conduits[conduit].key == bytes32(0)) {\r\n            revert NoConduit();\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"CallerIsNotNewPotentialOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"CallerIsNotOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"ChannelOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"ConduitAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCreator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newPotentialOwner\",\"type\":\"address\"}],\"name\":\"NewPotentialOwnerAlreadySet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"NewPotentialOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoConduit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"NoPotentialOwnerCurrentlySet\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"name\":\"NewConduit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPotentialOwner\",\"type\":\"address\"}],\"name\":\"PotentialOwnerUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_NS_CONTRACT_ROLE\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"initialOwner\",\"type\":\"address\"}],\"name\":\"createConduit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"channelIndex\",\"type\":\"uint256\"}],\"name\":\"getChannel\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"channel\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"channel\",\"type\":\"address\"}],\"name\":\"getChannelStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"getChannels\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"channels\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"name\":\"getConduit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConduitCodeHashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"creationCodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"runtimeCodeHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"getKey\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"getPotentialOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"potentialOwner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"getTotalChannels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalChannels\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newPotentialOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"channel\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"name\":\"updateChannel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ConduitController", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://30b09f58c5b31c04362ee64446cd3133b1a6f3559b3d98b8e1acd237f1f081bb"}