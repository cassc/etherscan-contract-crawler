{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/facets/diamond-core/DiamondCutFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport {IDiamondCut} from \\\"src/interfaces/diamond-core/IDiamondCut.sol\\\";\\nimport {LibDiamond} from \\\"src/libraries/diamond-core/LibDiamond.sol\\\";\\n\\n/**\\n * @title DiamondCutFacet\\n * @author Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n * @notice Required function selector modification to support EIP-2535\\n */\\ncontract DiamondCutFacet is IDiamondCut {\\n    /**\\n     * @notice Add/replace/remove any number of functions and optionally execute a function with delegatecall\\n     *\\n     * @dev    Throws if adding a function selector that is already assigned\\n     * @dev    Throws if adding or replacing and facet has no code\\n     * @dev    Throws if replacing with facet at address(0)\\n     * @dev    Throws if replacing function with same function from same facet\\n     * @dev    Throws if replacing or removing function that doesn't exist\\n     * @dev    Throws if replacing or removing an immutable facet\\n     * @dev    Throws if removing function and facet address is not address(0)\\n     * @dev    Throws if initialization contract provided does not contain code\\n     * @dev    Throws if initialization data is invalid\\n     * @dev    Throws if caller is not the contract owner\\n     *\\n     * @dev    <h4>Postconditions</h4>\\n     * @dev    1. A `DiamondCut` event has been emitted\\n     * @dev    2. The provided selectors have been added, replaced or removed from the diamond\\n     * @dev    3. The initialization function has been called\\n     *\\n     * @param _diamondCut Contains the facet addresses and function selectors\\n     * @param _init The address of the contract or facet to execute _calldata\\n     * @param _calldata A function call, including function selector and arguments\\n     */\\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external override {\\n        LibDiamond.requireContractOwner();\\n        LibDiamond.diamondCut(_diamondCut, _init, _calldata);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/diamond-core/IDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\ninterface IDiamond {\\n    enum FacetCutAction {\\n        Add,     // 0\\n        Replace, // 1\\n        Remove   // 2\\n    }\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    struct DiamondArgs {\\n        address owner;\\n        address init;\\n        bytes initCalldata;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/diamond-core/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport {IDiamond} from \\\"./IDiamond.sol\\\";\\n\\n/**\\n * @title DiamondCutFacet\\n * @author Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n * @notice Required function selector modification to support EIP-2535\\n */\\ninterface IDiamondCut is IDiamond {\\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\\n}\\n\"\r\n    },\r\n    \"src/libraries/diamond-core/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport {IDiamond} from \\\"src/interfaces/diamond-core/IDiamond.sol\\\";\\n\\nerror NoSelectorsGivenToAdd();\\nerror NotContractOwner(address _user, address _contractOwner);\\nerror NoSelectorsProvidedForFacetForCut(address _facetAddress);\\nerror CannotAddSelectorsToZeroAddress(bytes4[] _selectors);\\nerror NoBytecodeAtAddress(address _contractAddress, string _message);\\nerror IncorrectFacetCutAction(uint8 _action);\\nerror CannotAddFunctionToDiamondThatAlreadyExists(bytes4 _selector);\\nerror CannotReplaceFunctionsFromFacetWithZeroAddress(bytes4[] _selectors);\\nerror CannotReplaceImmutableFunction(bytes4 _selector);\\nerror CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(bytes4 _selector);\\nerror CannotReplaceFunctionThatDoesNotExists(bytes4 _selector);\\nerror RemoveFacetAddressMustBeZeroAddress(address _facetAddress);\\nerror CannotRemoveFunctionThatDoesNotExist(bytes4 _selector);\\nerror CannotRemoveImmutableFunction(bytes4 _selector);\\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\n\\n/**\\n * @title LibDiamond\\n * @author Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n * @notice Library of Diamond Functions\\n */\\nlibrary LibDiamond {\\n\\n    struct FacetAddressAndSelectorPosition {\\n        address facetAddress;\\n        uint16 selectorPosition;\\n    }\\n\\n    struct DiamondStorage {\\n        mapping(bytes4 => FacetAddressAndSelectorPosition) facetAddressAndSelectorPosition;\\n        bytes4[] selectors;\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        address contractOwner;\\n    }\\n\\n    /// @dev Standard storage slot for the shared diamond storage\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    /// @notice Emitted when Ownership of the diamond is transferred\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Emitted when a DiamondCut takes place\\n    event DiamondCut(IDiamond.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n\\n    /// @dev Returns data stored at the `DIAMOND_STORAGE_POSITION`\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfers ownership of the diamond to the provided owner\\n     *\\n     * @dev    Throws if caller is not the current owner\\n     *\\n     * @dev    <h4>Postconditions</h4>\\n     * @dev    1. The provided address is the new owner\\n     * @dev    2. The previous owner is no longer the owner\\n     *\\n     * @param  _newOwner address of the new owner\\n     */\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    /// @dev Returns the contract owner of the Diamond\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    /// @dev Internal function version of diamondCut\\n    function diamondCut(IDiamond.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            bytes4[] memory functionSelectors = _diamondCut[facetIndex].functionSelectors;\\n            address facetAddress = _diamondCut[facetIndex].facetAddress;\\n            if (functionSelectors.length == 0) {\\n                revert NoSelectorsProvidedForFacetForCut(facetAddress);\\n            }\\n            IDiamond.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamond.FacetCutAction.Add) {\\n                addFunctions(facetAddress, functionSelectors);\\n            } else if (action == IDiamond.FacetCutAction.Replace) {\\n                replaceFunctions(facetAddress, functionSelectors);\\n            } else if (action == IDiamond.FacetCutAction.Remove) {\\n                removeFunctions(facetAddress, functionSelectors);\\n            } else {\\n                revert IncorrectFacetCutAction(uint8(action));\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    /**\\n     * @dev Associates a facet address with an array of function selectors\\n     *\\n     * @dev Throws if the facet address is address(0)\\n     * @dev Throws if the facet address does not contain code\\n     * @dev Throws if the function selector is already assigned a facet\\n     *\\n     * @dev <h4>Postconditions</h4>\\n     * @dev 1. The facet address is associated with the list of function selectors\\n     */\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        if (_facetAddress == address(0)) {\\n            revert CannotAddSelectorsToZeroAddress(_functionSelectors);\\n        }\\n        DiamondStorage storage ds = diamondStorage();\\n        uint16 selectorCount = uint16(ds.selectors.length);\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\n            if (oldFacetAddress != address(0)) {\\n                revert CannotAddFunctionToDiamondThatAlreadyExists(selector);\\n            }\\n            ds.facetAddressAndSelectorPosition[selector] = FacetAddressAndSelectorPosition(_facetAddress, selectorCount);\\n            ds.selectors.push(selector);\\n            selectorCount++;\\n        }\\n    }\\n\\n    /**\\n     * @dev Replaces an array of function selectors with a new facet address\\n     *\\n     * @dev Throws if the provided facet address is the zero address\\n     * @dev Throws if the provided facet address does not contain code\\n     * @dev Throws if trying to replace an immutable function selector\\n     * @dev Throws if trying to replace with the same facet address and function selector\\n     * @dev Throws if any function selector in the `_functionSelectors` array does not exist\\n     *\\n     * @dev <h4>Postconditions</h4>\\n     * @dev 1. The list of function selectors are replaced with the new facet address\\n     */\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        if (_facetAddress == address(0)) {\\n            revert CannotReplaceFunctionsFromFacetWithZeroAddress(_functionSelectors);\\n        }\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\n            // can't replace immutable functions -- functions defined directly in the diamond in this case\\n            if (oldFacetAddress == address(this)) {\\n                revert CannotReplaceImmutableFunction(selector);\\n            }\\n            if (oldFacetAddress == _facetAddress) {\\n                revert CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(selector);\\n            }\\n            if (oldFacetAddress == address(0)) {\\n                revert CannotReplaceFunctionThatDoesNotExists(selector);\\n            }\\n            // replace old facet address\\n            ds.facetAddressAndSelectorPosition[selector].facetAddress = _facetAddress;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes functions from the Diamond\\n     *\\n     * @dev Throws if the provided facet address is not address(0)\\n     * @dev Throws if any function in the `_functionSelectors` does not exist\\n     * @dev Throws if any function in the `_functionSelectors` array is immutable\\n     *\\n     * @dev <h4>Postconditions</h4>\\n     * @dev 1. The provided array of function selectors have been removed from the Diamond\\n     */\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        uint256 selectorCount = ds.selectors.length;\\n        if (_facetAddress != address(0)) {\\n            revert RemoveFacetAddressMustBeZeroAddress(_facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            FacetAddressAndSelectorPosition memory oldFacetAddressAndSelectorPosition =\\n                ds.facetAddressAndSelectorPosition[selector];\\n            if (oldFacetAddressAndSelectorPosition.facetAddress == address(0)) {\\n                revert CannotRemoveFunctionThatDoesNotExist(selector);\\n            }\\n\\n            // can't remove immutable functions -- functions defined directly in the diamond\\n            if (oldFacetAddressAndSelectorPosition.facetAddress == address(this)) {\\n                revert CannotRemoveImmutableFunction(selector);\\n            }\\n            // replace selector with last selector\\n            selectorCount--;\\n            if (oldFacetAddressAndSelectorPosition.selectorPosition != selectorCount) {\\n                bytes4 lastSelector = ds.selectors[selectorCount];\\n                ds.selectors[oldFacetAddressAndSelectorPosition.selectorPosition] = lastSelector;\\n                ds.facetAddressAndSelectorPosition[lastSelector].selectorPosition =\\n                    oldFacetAddressAndSelectorPosition.selectorPosition;\\n            }\\n            // delete last selector\\n            ds.selectors.pop();\\n            delete ds.facetAddressAndSelectorPosition[selector];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calls the initialization address with the provide abi encoded calldata\\n     *\\n     * @dev Throws if invalid calldata is provided\\n     *\\n     * @dev <h4>Postconditions</h4>\\n     * @dev 1. The initialization address has performed any updates in the provided calldata\\n     */\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            return;\\n        }\\n        enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n        if (!success) {\\n            if (error.length > 0) {\\n                // bubble up error\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(error)\\n                    revert(add(32, error), returndata_size)\\n                }\\n            } else {\\n                revert InitializationFunctionReverted(_init, _calldata);\\n            }\\n        }\\n    }\\n\\n    /// @dev Enforces the msg.sender is the contract owner, reverts if not\\n    function requireContractOwner() internal view {\\n        if (msg.sender != diamondStorage().contractOwner) {\\n            revert NotContractOwner(msg.sender, diamondStorage().contractOwner);\\n        }\\n    }\\n\\n    /// @dev Enforces the provided address has code, reverts if not \\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        if (contractSize == 0) {\\n            revert NoBytecodeAtAddress(_contract, _errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@limit-break/=lib/limit-break-contracts/contracts/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"limit-break-contracts/=lib/limit-break-contracts/contracts/\",\r\n      \"murky/=lib/murky/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solidity-stringutils/=lib/solidity-stringutils/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_selector\",\"type\":\"bytes4\"}],\"name\":\"CannotAddFunctionToDiamondThatAlreadyExists\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"_selectors\",\"type\":\"bytes4[]\"}],\"name\":\"CannotAddSelectorsToZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_selector\",\"type\":\"bytes4\"}],\"name\":\"CannotRemoveFunctionThatDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_selector\",\"type\":\"bytes4\"}],\"name\":\"CannotRemoveImmutableFunction\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_selector\",\"type\":\"bytes4\"}],\"name\":\"CannotReplaceFunctionThatDoesNotExists\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_selector\",\"type\":\"bytes4\"}],\"name\":\"CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"_selectors\",\"type\":\"bytes4[]\"}],\"name\":\"CannotReplaceFunctionsFromFacetWithZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_selector\",\"type\":\"bytes4\"}],\"name\":\"CannotReplaceImmutableFunction\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_action\",\"type\":\"uint8\"}],\"name\":\"IncorrectFacetCutAction\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_initializationContractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"InitializationFunctionReverted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"NoBytecodeAtAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_facetAddress\",\"type\":\"address\"}],\"name\":\"NoSelectorsProvidedForFacetForCut\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_contractOwner\",\"type\":\"address\"}],\"name\":\"NotContractOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_facetAddress\",\"type\":\"address\"}],\"name\":\"RemoveFacetAddressMustBeZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamond.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamond.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"_init\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"diamondCut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DiamondCutFacet", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}