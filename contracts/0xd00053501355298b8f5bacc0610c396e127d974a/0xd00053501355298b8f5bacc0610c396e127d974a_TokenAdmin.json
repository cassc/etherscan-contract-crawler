{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/TokenAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport {Owned} from \\\"solmate/auth/Owned.sol\\\";\\nimport {ReentrancyGuard} from \\\"solmate/utils/ReentrancyGuard.sol\\\";\\n\\nimport {IMinter} from \\\"./interfaces/IMinter.sol\\\";\\nimport {ITokenAdmin} from \\\"./interfaces/ITokenAdmin.sol\\\";\\nimport {IERC20Mintable} from \\\"./interfaces/IERC20Mintable.sol\\\";\\n\\n// solhint-disable not-rely-on-time\\n\\n/**\\n * @title Token Admin\\n * @notice This contract holds all admin powers over the token passing through calls.\\n *\\n * In addition, calls to the mint function must respect the inflation schedule as defined in this contract.\\n * As this contract is the only way to mint tokens this ensures that the maximum allowed supply is enforced\\n * @dev This contract exists as a consequence of the gauge systems needing to know a fixed inflation schedule\\n * in order to know how much tokens a gauge is allowed to mint. As this does not exist within the token itself\\n * it is defined here, we must then wrap the token's minting functionality in order for this to be meaningful.\\n */\\ncontract TokenAdmin is ITokenAdmin, ReentrancyGuard, Owned {\\n    // Initial inflation rate of 1.3731M tokens per week.\\n    uint256 public constant override INITIAL_RATE = (1373100 * 1e18) / uint256(1 weeks); // token has 18 decimals\\n    uint256 public constant override RATE_REDUCTION_TIME = 365 days;\\n    uint256 public constant override RATE_REDUCTION_COEFFICIENT = 1189207115002721024; // 2 ** (1/4) * 1e18\\n    uint256 public constant override RATE_DENOMINATOR = 1e18;\\n\\n    IERC20Mintable private immutable _token;\\n\\n    event MiningParametersUpdated(uint256 rate, uint256 supply);\\n\\n    // Supply Variables\\n    uint256 private _miningEpoch;\\n    uint256 private _startEpochTime = type(uint256).max; // Sentinel value for contract not being activated\\n    uint256 private _startEpochSupply;\\n    uint256 private _rate;\\n\\n    IMinter public immutable minter;\\n\\n    constructor(IERC20Mintable token, IMinter minter_, address owner_) Owned(owner_) {\\n        _token = token;\\n        minter = minter_;\\n    }\\n\\n    /**\\n     * @dev Returns the token being controlled.\\n     */\\n    function getToken() external view override returns (IERC20Mintable) {\\n        return _token;\\n    }\\n\\n    /**\\n     * @notice Initiate token inflation schedule\\n     */\\n    function activate() external override nonReentrant onlyOwner {\\n        require(_startEpochTime == type(uint256).max, \\\"Already activated\\\");\\n\\n        // initialise the relevant variables.\\n        _startEpochSupply = _token.totalSupply();\\n        _startEpochTime = block.timestamp;\\n        _rate = INITIAL_RATE;\\n        emit MiningParametersUpdated(INITIAL_RATE, _startEpochSupply);\\n    }\\n\\n    /**\\n     * @notice Mint tokens subject to the defined inflation schedule\\n     */\\n    function mint(address to, uint256 amount) external override {\\n        require(msg.sender == address(minter), \\\"NOT_MINTER\\\");\\n\\n        // Check if we've passed into a new epoch such that we should calculate available supply with a smaller rate.\\n        if (block.timestamp >= _startEpochTime + RATE_REDUCTION_TIME) {\\n            _updateMiningParameters();\\n        }\\n\\n        require(_token.totalSupply() + amount <= _availableSupply(), \\\"Mint amount exceeds remaining available supply\\\");\\n        _token.mint(to, amount);\\n    }\\n\\n    /**\\n     * @notice Returns the current epoch number.\\n     */\\n    function getMiningEpoch() external view returns (uint256) {\\n        return _miningEpoch;\\n    }\\n\\n    /**\\n     * @notice Returns the start timestamp of the current epoch.\\n     */\\n    function getStartEpochTime() external view returns (uint256) {\\n        return _startEpochTime;\\n    }\\n\\n    /**\\n     * @notice Returns the start timestamp of the next epoch.\\n     */\\n    function getFutureEpochTime() external view returns (uint256) {\\n        return _startEpochTime + RATE_REDUCTION_TIME;\\n    }\\n\\n    /**\\n     * @notice Returns the available supply at the beginning of the current epoch.\\n     */\\n    function getStartEpochSupply() external view returns (uint256) {\\n        return _startEpochSupply;\\n    }\\n\\n    /**\\n     * @notice Returns the current inflation rate of tokens per second\\n     */\\n    function getInflationRate() external view returns (uint256) {\\n        return _rate;\\n    }\\n\\n    /**\\n     * @notice Maximum allowable number of tokens in existence (claimed or unclaimed)\\n     */\\n    function getAvailableSupply() external view returns (uint256) {\\n        return _availableSupply();\\n    }\\n\\n    /**\\n     * @notice Get timestamp of the current mining epoch start while simultaneously updating mining parameters\\n     * @return Timestamp of the current epoch\\n     */\\n    function startEpochTimeWrite() external override returns (uint256) {\\n        return _startEpochTimeWrite();\\n    }\\n\\n    /**\\n     * @notice Get timestamp of the next mining epoch start while simultaneously updating mining parameters\\n     * @return Timestamp of the next epoch\\n     */\\n    function futureEpochTimeWrite() external returns (uint256) {\\n        return _startEpochTimeWrite() + RATE_REDUCTION_TIME;\\n    }\\n\\n    /**\\n     * @notice Update mining rate and supply at the start of the epoch\\n     * @dev Callable by any address, but only once per epoch\\n     * Total supply becomes slightly larger if this function is called late\\n     */\\n    function updateMiningParameters() external {\\n        require(block.timestamp >= _startEpochTime + RATE_REDUCTION_TIME, \\\"Epoch has not finished yet\\\");\\n        _updateMiningParameters();\\n    }\\n\\n    /**\\n     * @notice How much supply is mintable from start timestamp till end timestamp\\n     * @param start Start of the time interval (timestamp)\\n     * @param end End of the time interval (timestamp)\\n     * @return Tokens mintable from `start` till `end`\\n     */\\n    function mintableInTimeframe(uint256 start, uint256 end) external view returns (uint256) {\\n        return _mintableInTimeframe(start, end);\\n    }\\n\\n    // Internal functions\\n\\n    /**\\n     * @notice Maximum allowable number of tokens in existence (claimed or unclaimed)\\n     */\\n    function _availableSupply() internal view returns (uint256) {\\n        uint256 newSupplyFromCurrentEpoch = (block.timestamp - _startEpochTime) * _rate;\\n        return _startEpochSupply + newSupplyFromCurrentEpoch;\\n    }\\n\\n    /**\\n     * @notice Get timestamp of the current mining epoch start while simultaneously updating mining parameters\\n     * @return Timestamp of the current epoch\\n     */\\n    function _startEpochTimeWrite() internal returns (uint256) {\\n        uint256 startEpochTime = _startEpochTime;\\n        if (block.timestamp >= startEpochTime + RATE_REDUCTION_TIME) {\\n            _updateMiningParameters();\\n            return _startEpochTime;\\n        }\\n        return startEpochTime;\\n    }\\n\\n    function _updateMiningParameters() internal {\\n        uint256 inflationRate = _rate;\\n        uint256 startEpochSupply = _startEpochSupply + (inflationRate * RATE_REDUCTION_TIME);\\n        inflationRate = inflationRate * RATE_DENOMINATOR / RATE_REDUCTION_COEFFICIENT;\\n\\n        ++_miningEpoch;\\n        _startEpochTime += RATE_REDUCTION_TIME;\\n        _rate = inflationRate;\\n        _startEpochSupply = startEpochSupply;\\n\\n        emit MiningParametersUpdated(inflationRate, startEpochSupply);\\n    }\\n\\n    /**\\n     * @notice How much supply is mintable from start timestamp till end timestamp\\n     * @param start Start of the time interval (timestamp)\\n     * @param end End of the time interval (timestamp)\\n     * @return Tokens mintable from `start` till `end`\\n     */\\n    function _mintableInTimeframe(uint256 start, uint256 end) internal view returns (uint256) {\\n        require(start <= end, \\\"start > end\\\");\\n\\n        uint256 currentEpochTime = _startEpochTime;\\n        uint256 currentRate = _rate;\\n\\n        // It shouldn't be possible to over/underflow in here but we add checked maths to be safe\\n\\n        // Special case if end is in future (not yet minted) epoch\\n        if (end > currentEpochTime + RATE_REDUCTION_TIME) {\\n            currentEpochTime += RATE_REDUCTION_TIME;\\n            currentRate = currentRate * RATE_DENOMINATOR / RATE_REDUCTION_COEFFICIENT;\\n        }\\n\\n        require(end <= currentEpochTime + RATE_REDUCTION_TIME, \\\"too far in future\\\");\\n\\n        uint256 toMint = 0;\\n        for (uint256 epoch = 0; epoch < 999; ++epoch) {\\n            if (end >= currentEpochTime) {\\n                uint256 currentEnd = end;\\n                if (currentEnd > currentEpochTime + RATE_REDUCTION_TIME) {\\n                    currentEnd = currentEpochTime + RATE_REDUCTION_TIME;\\n                }\\n\\n                uint256 currentStart = start;\\n                if (currentStart >= currentEpochTime + RATE_REDUCTION_TIME) {\\n                    // We should never get here but what if...\\n                    break;\\n                } else if (currentStart < currentEpochTime) {\\n                    currentStart = currentEpochTime;\\n                }\\n\\n                toMint += currentRate * (currentEnd - currentStart);\\n\\n                if (start >= currentEpochTime) {\\n                    break;\\n                }\\n            }\\n\\n            currentEpochTime -= RATE_REDUCTION_TIME;\\n            // double-division with rounding made rate a bit less => good\\n            currentRate = currentRate * RATE_REDUCTION_COEFFICIENT / RATE_DENOMINATOR;\\n            assert(currentRate <= INITIAL_RATE);\\n        }\\n\\n        return toMint;\\n    }\\n\\n    // The below functions are duplicates of functions available above.\\n    // They are included for ABI compatibility with snake_casing as used in vyper contracts.\\n    // solhint-disable func-name-mixedcase\\n\\n    function rate() external view override returns (uint256) {\\n        return _rate;\\n    }\\n\\n    function available_supply() external view returns (uint256) {\\n        return _availableSupply();\\n    }\\n\\n    /**\\n     * @notice Get timestamp of the current mining epoch start while simultaneously updating mining parameters\\n     * @return Timestamp of the current epoch\\n     */\\n    function start_epoch_time_write() external returns (uint256) {\\n        return _startEpochTimeWrite();\\n    }\\n\\n    /**\\n     * @notice Get timestamp of the next mining epoch start while simultaneously updating mining parameters\\n     * @return Timestamp of the next epoch\\n     */\\n    function future_epoch_time_write() external returns (uint256) {\\n        return _startEpochTimeWrite() + RATE_REDUCTION_TIME;\\n    }\\n\\n    /**\\n     * @notice Update mining rate and supply at the start of the epoch\\n     * @dev Callable by any address, but only once per epoch\\n     * Total supply becomes slightly larger if this function is called late\\n     */\\n    function update_mining_parameters() external {\\n        require(block.timestamp >= _startEpochTime + RATE_REDUCTION_TIME, \\\"Epoch has not finished yet\\\");\\n        _updateMiningParameters();\\n    }\\n\\n    /**\\n     * @notice How much supply is mintable from start timestamp till end timestamp\\n     * @param start Start of the time interval (timestamp)\\n     * @param end End of the time interval (timestamp)\\n     * @return Tokens mintable from `start` till `end`\\n     */\\n    function mintable_in_timeframe(uint256 start, uint256 end) external view returns (uint256) {\\n        return _mintableInTimeframe(start, end);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private locked = 1;\\n\\n    modifier nonReentrant() virtual {\\n        require(locked == 1, \\\"REENTRANCY\\\");\\n\\n        locked = 2;\\n\\n        _;\\n\\n        locked = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.7.0 <0.9.0;\\n\\nimport {IERC20} from \\\"forge-std/interfaces/IERC20.sol\\\";\\n\\nimport {ITokenAdmin} from \\\"./ITokenAdmin.sol\\\";\\nimport {IGaugeController} from \\\"./IGaugeController.sol\\\";\\n\\ninterface IMinter {\\n    event Minted(address indexed recipient, address gauge, uint256 minted);\\n\\n    /**\\n     * @notice Returns the address of the minted token\\n     */\\n    function getToken() external view returns (IERC20);\\n\\n    /**\\n     * @notice Returns the address of the Token Admin contract\\n     */\\n    function getTokenAdmin() external view returns (ITokenAdmin);\\n\\n    /**\\n     * @notice Returns the address of the Gauge Controller\\n     */\\n    function getGaugeController() external view returns (IGaugeController);\\n\\n    /**\\n     * @notice Mint everything which belongs to `msg.sender` and send to them\\n     * @param gauge `LiquidityGauge` address to get mintable amount from\\n     */\\n    function mint(address gauge) external returns (uint256);\\n\\n    /**\\n     * @notice Mint everything which belongs to `msg.sender` across multiple gauges\\n     * @param gauges List of `LiquidityGauge` addresses\\n     */\\n    function mintMany(address[] calldata gauges) external returns (uint256);\\n\\n    /**\\n     * @notice Mint tokens for `user`\\n     * @dev Only possible when `msg.sender` has been approved by `user` to mint on their behalf\\n     * @param gauge `LiquidityGauge` address to get mintable amount from\\n     * @param user Address to mint to\\n     */\\n    function mintFor(address gauge, address user) external returns (uint256);\\n\\n    /**\\n     * @notice Mint tokens for `user` across multiple gauges\\n     * @dev Only possible when `msg.sender` has been approved by `user` to mint on their behalf\\n     * @param gauges List of `LiquidityGauge` addresses\\n     * @param user Address to mint to\\n     */\\n    function mintManyFor(address[] calldata gauges, address user) external returns (uint256);\\n\\n    /**\\n     * @notice The total number of tokens minted for `user` from `gauge`\\n     */\\n    function minted(address user, address gauge) external view returns (uint256);\\n\\n    /**\\n     * @notice Whether `minter` is approved to mint tokens for `user`\\n     */\\n    function getMinterApproval(address minter, address user) external view returns (bool);\\n\\n    /**\\n     * @notice Set whether `minter` is approved to mint tokens on your behalf\\n     */\\n    function setMinterApproval(address minter, bool approval) external;\\n\\n    // The below functions are near-duplicates of functions available above.\\n    // They are included for ABI compatibility with snake_casing as used in vyper contracts.\\n    // solhint-disable func-name-mixedcase\\n\\n    /**\\n     * @notice Whether `minter` is approved to mint tokens for `user`\\n     */\\n    function allowed_to_mint_for(address minter, address user) external view returns (bool);\\n\\n    /**\\n     * @notice Mint everything which belongs to `msg.sender` across multiple gauges\\n     * @dev This function is not recommended as `mintMany()` is more flexible and gas efficient\\n     * @param gauges List of `LiquidityGauge` addresses\\n     */\\n    function mint_many(address[8] calldata gauges) external;\\n\\n    /**\\n     * @notice Mint tokens for `user`\\n     * @dev Only possible when `msg.sender` has been approved by `user` to mint on their behalf\\n     * @param gauge `LiquidityGauge` address to get mintable amount from\\n     * @param user Address to mint to\\n     */\\n    function mint_for(address gauge, address user) external;\\n\\n    /**\\n     * @notice Toggle whether `minter` is approved to mint tokens for `user`\\n     */\\n    function toggle_approve_mint(address minter) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ITokenAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.7.0 <0.9.0;\\n\\nimport {IERC20Mintable} from \\\"./IERC20Mintable.sol\\\";\\n\\ninterface ITokenAdmin {\\n    // solhint-disable func-name-mixedcase\\n    function INITIAL_RATE() external view returns (uint256);\\n\\n    function RATE_REDUCTION_TIME() external view returns (uint256);\\n\\n    function RATE_REDUCTION_COEFFICIENT() external view returns (uint256);\\n\\n    function RATE_DENOMINATOR() external view returns (uint256);\\n\\n    // solhint-enable func-name-mixedcase\\n    function getToken() external view returns (IERC20Mintable);\\n\\n    function activate() external;\\n\\n    function rate() external view returns (uint256);\\n\\n    function startEpochTimeWrite() external returns (uint256);\\n\\n    function mint(address to, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20Mintable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.7.0 <0.9.0;\\n\\nimport {IERC20} from \\\"forge-std/interfaces/IERC20.sol\\\";\\n\\ninterface IERC20Mintable is IERC20 {\\n    function mint(address to, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"lib/forge-std/src/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\n/// @dev Interface of the ERC20 standard as defined in the EIP.\\n/// @dev This includes the optional name, symbol, and decimals metadata.\\ninterface IERC20 {\\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\\n    /// is the new allowance.\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice Returns the amount of tokens in existence.\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Returns the amount of tokens owned by `account`.\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\\n    /// to spend on behalf of `owner`\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\\n    /// `amount` is then deducted from the caller's allowance.\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Returns the name of the token.\\n    function name() external view returns (string memory);\\n\\n    /// @notice Returns the symbol of the token.\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Returns the decimals places of the token.\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IGaugeController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.6.11;\\n\\n// https://github.com/swervefi/swerve/edit/master/packages/swerve-contracts/interfaces/IGaugeController.sol\\n\\ninterface IGaugeController {\\n    struct Point {\\n        uint256 bias;\\n        uint256 slope;\\n    }\\n\\n    struct VotedSlope {\\n        uint256 slope;\\n        uint256 power;\\n        uint256 end;\\n    }\\n\\n    // Public variables\\n    function admin() external view returns (address);\\n\\n    function token() external view returns (address);\\n\\n    function voting_escrow() external view returns (address);\\n\\n    function n_gauge_types() external view returns (int128);\\n\\n    function n_gauges() external view returns (int128);\\n\\n    function gauge_type_names(int128) external view returns (string memory);\\n\\n    function gauges(uint256) external view returns (address);\\n\\n    function vote_user_slopes(address, address) external view returns (VotedSlope memory);\\n\\n    function vote_user_power(address) external view returns (uint256);\\n\\n    function last_user_vote(address, address) external view returns (uint256);\\n\\n    function points_weight(address, uint256) external view returns (Point memory);\\n\\n    function time_weight(address) external view returns (uint256);\\n\\n    function points_sum(int128, uint256) external view returns (Point memory);\\n\\n    function time_sum(uint256) external view returns (uint256);\\n\\n    function points_total(uint256) external view returns (uint256);\\n\\n    function time_total() external view returns (uint256);\\n\\n    function points_type_weight(int128, uint256) external view returns (uint256);\\n\\n    function time_type_weight(uint256) external view returns (uint256);\\n\\n    // Getter functions\\n    function gauge_types(address) external view returns (int128);\\n\\n    function gauge_relative_weight(address) external view returns (uint256);\\n\\n    function gauge_relative_weight(address, uint256) external view returns (uint256);\\n\\n    function get_gauge_weight(address) external view returns (uint256);\\n\\n    function get_type_weight(int128) external view returns (uint256);\\n\\n    function get_total_weight() external view returns (uint256);\\n\\n    function get_weights_sum_per_type(int128) external view returns (uint256);\\n\\n    // External functions\\n    function add_gauge(address, int128, uint256) external;\\n\\n    function checkpoint() external;\\n\\n    function checkpoint_gauge(address) external;\\n\\n    function gauge_relative_weight_write(address) external returns (uint256);\\n\\n    function gauge_relative_weight_write(address, uint256) external returns (uint256);\\n\\n    function add_type(string memory, uint256) external;\\n\\n    function change_type_weight(int128, uint256) external;\\n\\n    function change_gauge_weight(address, uint256) external;\\n\\n    function vote_for_gauge_weights(address, uint256) external;\\n\\n    function change_pending_admin(address newPendingAdmin) external;\\n\\n    function claim_admin() external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"create3-factory/=lib/create3-factory/\",\r\n      \"ds-test/=lib/solmate/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/popcorn/lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/popcorn/lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"popcorn/=lib/popcorn/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20Mintable\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract IMinter\",\"name\":\"minter_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"name\":\"MiningParametersUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INITIAL_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RATE_DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RATE_REDUCTION_COEFFICIENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RATE_REDUCTION_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"available_supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"futureEpochTimeWrite\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"future_epoch_time_write\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAvailableSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFutureEpochTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInflationRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMiningEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStartEpochSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStartEpochTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"contract IERC20Mintable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"mintableInTimeframe\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"mintable_in_timeframe\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"internalType\":\"contract IMinter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startEpochTimeWrite\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start_epoch_time_write\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateMiningParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"update_mining_parameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TokenAdmin", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000dffa4d3ed6b433810354430464a5c00b6ea0f1df000000000000000000000000d37578f51cd8e66819c3689a9af540ca2a0aff04000000000000000000000000849664e1f06693103c4852c232034ae7a8c42736", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}