{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/antiMev/OneDirectionPerBlockAntiMevStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport {Ownable} from \\\"../oz/access/Ownable.sol\\\";\\nimport {IAntiMevStrategy} from \\\"../interfaces/IAntiMevStrategy.sol\\\";\\nimport {IPair} from \\\"../interfaces/IPair.sol\\\";\\nimport {IUniswapV2Factory} from \\\"../interfaces/IUniswapV2Factory.sol\\\";\\nimport {IUniswapV3Factory} from \\\"../interfaces/IUniswapV3Factory.sol\\\";\\nimport {IPoolV3} from \\\"../interfaces/IPoolV3.sol\\\";\\n\\n/**\\n * @title OneDirectionPerBlockAntiMevStrategy\\n * @dev OneDirectionPerBlockAntiMevStrategy contains the logic to prevent MEV bots from frontrunning transactions.\\n * This strategy enforces that each address can perform only one transaction per direction per block, preventing sandwich attacks which operate in this manner.\\n * It also provides mechanisms to whitelist certain addresses and factory contracts to allow for exceptions.\\n */\\ncontract OneDirectionPerBlockAntiMevStrategy is Ownable, IAntiMevStrategy {\\n  event SetFactoryWhitelist(address whitelist, uint8 version, bool isWhitelisted);\\n  event SetMEVWhitelist(address whitelist, bool isWhitelisted);\\n\\n  error OnlyOneTransferPerBlockPerAddress(address);\\n  error OnlyBen();\\n\\n  struct FactoryInfo {\\n    bool isWhitelisted;\\n    uint8 version;\\n  }\\n\\n  address public ben;\\n  mapping(bytes32 accountHash => bool[2] directions) private accountTransferredPerBlock;\\n  mapping(address whitelist => bool isWhitelisted) public MEVWhitelist; // For certain addresses to be exempt from MEV like exchanges\\n  mapping(address factory => FactoryInfo factoryInfo) public factoryInfos;\\n\\n  modifier onlyBen() {\\n    if (msg.sender != ben) {\\n      revert OnlyBen();\\n    }\\n    _;\\n  }\\n\\n  /**\\n   * @param _ben The address of the Ben token contract\\n   *\\n   * Constructor initializes the contract with the address of the Ben token, which is required for access control.\\n   * The Ben token contract address cannot be changed after deployment.\\n   */\\n  constructor(address _ben) {\\n    ben = _ben;\\n  }\\n\\n  /**\\n   * @notice Callback function to handle token transfers and enforce anti-MEV measures\\n   * @param _from The sender address\\n   * @param _to The receiver address\\n   * @param _amount The amount of tokens being transferred\\n   * @param _isTaxingInProgress A flag indicating whether a tax transaction is in progress\\n   *\\n   * This function is called during token transfers and enforces anti-MEV measures.\\n   * It ensures that each address can perform only one transaction per block, except for whitelisted addresses.\\n   * Additionally, it checks if the sender or receiver is a whitelisted pair contract to allow exceptions.\\n   */\\n  function onTransfer(address _from, address _to, uint256 _amount, bool _isTaxingInProgress) external override onlyBen {\\n    // If from or to an LP, then whitelist it from MEV\\n    if (_isTaxingInProgress || _from == _to || _amount == 0) {\\n      return;\\n    }\\n\\n    bool fromIsWhitelisted = MEVWhitelist[_from];\\n    if (!fromIsWhitelisted) {\\n      fromIsWhitelisted = _isPair(_from);\\n    }\\n\\n    bool toIsWhitelisted = MEVWhitelist[_to];\\n    if (!toIsWhitelisted) {\\n      toIsWhitelisted = _isPair(_to);\\n    }\\n\\n    if (!fromIsWhitelisted) {\\n      bytes32 key = keccak256(abi.encodePacked(block.number, _from));\\n      if (accountTransferredPerBlock[key][1]) {\\n        revert OnlyOneTransferPerBlockPerAddress(_from);\\n      }\\n      accountTransferredPerBlock[key][0] = true;\\n    }\\n    if (!toIsWhitelisted) {\\n      bytes32 key = keccak256(abi.encodePacked(block.number, _to));\\n      if (accountTransferredPerBlock[key][0]) {\\n        revert OnlyOneTransferPerBlockPerAddress(_to);\\n      }\\n      accountTransferredPerBlock[key][1] = true;\\n    }\\n  }\\n\\n  /**\\n   * @param _target The address to check\\n   * @return isPair A boolean indicating whether the address represents a pair contract\\n   *\\n   * Internal function to check if an address is a pair contract, such as a Uniswap LP token.\\n   * It verifies if the address is a contract, checks its factory, and determines if it is indeed a valid pair.\\n   */\\n  function _isPair(address _target) private view returns (bool isPair) {\\n    // Not a contract\\n    if (_target.code.length == 0) {\\n      return false;\\n    }\\n\\n    IPair pairContract = IPair(_target);\\n    address factory;\\n    try pairContract.factory() returns (address _factory) {\\n      factory = _factory;\\n    } catch {\\n      return false;\\n    }\\n\\n    // Possible pair, check if factory is whitelisted\\n    FactoryInfo memory factoryInfo = factoryInfos[factory];\\n    if (!factoryInfo.isWhitelisted) {\\n      return false;\\n    }\\n\\n    // Check if this is actually an LP\\n    address token0;\\n    try pairContract.token0() returns (address _token0) {\\n      token0 = _token0;\\n    } catch {\\n      return false;\\n    }\\n\\n    address token1;\\n    try pairContract.token1() returns (address _token1) {\\n      token1 = _token1;\\n    } catch {\\n      return false;\\n    }\\n\\n    if (factoryInfo.version == 2) {\\n      // UniV2 pairs\\n      return IUniswapV2Factory(factory).getPair(token0, token1) == _target;\\n    } else if (factoryInfo.version == 3) {\\n      // UniV3 pairs\\n      try IPoolV3(_target).fee() returns (uint24 _fee) {\\n        return IUniswapV3Factory(factory).getPool(token0, token1, _fee) == _target;\\n      } catch {\\n        return false;\\n      }\\n    }\\n  }\\n\\n  function _setMEVWhitelist(address _whitelist, bool _isWhitelisted) private {\\n    MEVWhitelist[_whitelist] = _isWhitelisted;\\n    emit SetMEVWhitelist(_whitelist, _isWhitelisted);\\n  }\\n\\n  /**\\n   * @notice Set or update the whitelist status and version of a factory contract\\n   * @param _whitelist The address of the factory contract to whitelist or update\\n   * @param _version The version of the factory contract (e.g., 2 for Uniswap V2, 3 for Uniswap V3)\\n   * @param _isWhitelisted A boolean indicating whether to whitelist or remove the factory contract\\n   *\\n   * Allows the owner (treasury) to set or update the whitelist status of a factory contract.\\n   * Factory contracts are responsible for creating pairs and pools in decentralized exchanges.\\n   * Whitelisting a factory contract allows its pairs to be exempt from certain anti-MEV checks.\\n   */\\n  function setFactoryWhitelist(address _whitelist, uint8 _version, bool _isWhitelisted) external onlyOwner {\\n    factoryInfos[_whitelist].isWhitelisted = _isWhitelisted;\\n    factoryInfos[_whitelist].version = _version;\\n    emit SetFactoryWhitelist(_whitelist, _version, _isWhitelisted);\\n  }\\n\\n  /**\\n   * @param _whitelist The address to add or remove from the MEV whitelist\\n   * @param _isWhitelisted A boolean indicating whether to add or remove the address from the whitelist\\n   *\\n   * Allows the owner (treasury) to add or remove addresses from the MEV whitelist.\\n   * Addresses on the whitelist are exempt from MEV checks\\n   */\\n  function setMEVWhitelist(address _whitelist, bool _isWhitelisted) external onlyOwner {\\n    _setMEVWhitelist(_whitelist, _isWhitelisted);\\n  }\\n\\n  /**\\n   * @param _whitelists An array of addresses to add or remove from the MEV whitelist\\n   * @param _isWhitelisted An array of booleans indicating whether to add or remove addresses from the whitelist\\n   *\\n   * Allows the owner (treasury) to add or remove multiple addresses from the MEV whitelist simultaneously.\\n   * This is an efficient way to manage the whitelist for multiple addresses.\\n   */\\n  function setMEVWhitelists(address[] calldata _whitelists, bool[] calldata _isWhitelisted) external onlyOwner {\\n    for (uint i; i < _whitelists.length; i++) {\\n      _setMEVWhitelist(_whitelists[i], _isWhitelisted[i]);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAntiMevStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.21;\\r\\n\\r\\ninterface IAntiMevStrategy {\\r\\n  function onTransfer(address from, address to, uint256 amount, bool isTaxingInProgress) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.21;\\r\\n\\r\\ninterface IPair {\\r\\n  function factory() external view returns (address);\\r\\n\\r\\n  function token0() external view returns (address);\\r\\n\\r\\n  function token1() external view returns (address);\\r\\n\\r\\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.21;\\r\\n\\r\\ninterface IPoolV3 {\\r\\n  function fee() external view returns (uint24);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.21;\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n  function getPair(address tokenA, address tokenB) external view returns (address);\\r\\n\\r\\n  function createPair(address tokenA, address tokenB) external returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV3Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.21;\\r\\n\\r\\ninterface IUniswapV3Factory {\\r\\n  function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address pool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/oz/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../utils/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    error OnlyOwner();\\r\\n    error NewOwnerIsZeroAddress();\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the sender is not the owner.\\r\\n     */\\r\\n    function _checkOwner() internal view virtual {\\r\\n        if (owner() != _msgSender()) {\\r\\n            revert OnlyOwner();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby disabling any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        if (newOwner == address(0)) {\\r\\n            revert NewOwnerIsZeroAddress();\\r\\n        }\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/oz/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999999,\r\n      \"details\": {\r\n        \"yul\": true\r\n      }\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ben\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyBen\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"OnlyOneTransferPerBlockPerAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"whitelist\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isWhitelisted\",\"type\":\"bool\"}],\"name\":\"SetFactoryWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"whitelist\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isWhitelisted\",\"type\":\"bool\"}],\"name\":\"SetMEVWhitelist\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"whitelist\",\"type\":\"address\"}],\"name\":\"MEVWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isWhitelisted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ben\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"name\":\"factoryInfos\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isWhitelisted\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isTaxingInProgress\",\"type\":\"bool\"}],\"name\":\"onTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_whitelist\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_version\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"_isWhitelisted\",\"type\":\"bool\"}],\"name\":\"setFactoryWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_whitelist\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isWhitelisted\",\"type\":\"bool\"}],\"name\":\"setMEVWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_whitelists\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_isWhitelisted\",\"type\":\"bool[]\"}],\"name\":\"setMEVWhitelists\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OneDirectionPerBlockAntiMevStrategy", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "9999999", "ConstructorArguments": "0000000000000000000000000b76f1456a4e44d11cf32b8c6398d68f94c578d6", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}