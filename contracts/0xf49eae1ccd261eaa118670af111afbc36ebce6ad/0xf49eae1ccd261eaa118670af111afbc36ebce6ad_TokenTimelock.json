{"SourceCode": "{\"IERC20.sol\":{\"content\":\"pragma solidity 0.5.0;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"Ownable.sol\":{\"content\":\"\\npragma solidity 0.5.0;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity 0.5.0;\\n\\n/**\\n * @title SafeMath\\n * @dev Unsigned math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Multiplies two unsigned integers, reverts on overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Adds two unsigned integers, reverts on overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\n     * reverts when dividing by zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n}\\n\"},\"TokenTimeLock.sol\":{\"content\":\"pragma solidity 0.5.0;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev A token holder contract that will allow a beneficiary to extract the\\n * tokens after a given release time.\\n *\\n * Useful for simple vesting schedules like \\\"advisors get all of their tokens\\n * after 1 year\\\".\\n *\\n * For a more complete vesting schedule, see {TokenVesting}.\\n */\\ncontract TokenTimelock is Ownable {\\n    using SafeMath for uint256;\\n\\n    // ERC20 basic token contract being held\\n    IERC20 private _token;\\n\\n    struct FreezeParams {\\n        uint256 releaseTime;\\n        uint256 initValue;\\n        uint256 monthlyUnlockPercent;\\n        uint256 currentBalance;\\n    }\\n\\n    mapping (address =\\u003e FreezeParams) public frozenTokens;\\n    mapping (address =\\u003e bool) private _admins;\\n    uint256 public totalReserved;\\n\\n    modifier onlyAdmin() {\\n        require(isAdmin(), \\\" caller is not the admin\\\");\\n        _;\\n    }\\n\\n    function isAdmin() public view returns (bool) {\\n        return _admins[msg.sender];\\n    }\\n\\n    function addAdmin(address admin) external onlyOwner {\\n        _admins[admin] = true;\\n    }\\n\\n    function renounceAdmin(address admin) external onlyOwner {\\n        _admins[admin] = false;\\n    }\\n\\n    constructor (IERC20 token) public {\\n        _token = token;\\n        _admins[msg.sender] = true;\\n    }\\n    /**\\n     * @return the token being held.\\n     */\\n    function token() public view returns (IERC20) {\\n        return _token;\\n    }\\n\\n    function totalHeld() public view returns (uint256) {\\n        return _token.balanceOf(address(this));\\n    }\\n\\n    event TokensHeld(address indexed _beneficiary, uint256 _value);\\n\\n    function holdTokens(\\n        address _beneficiary,\\n        uint256 _value,\\n        uint256 _releaseTime,\\n        uint256 _monthlyUnlockPercent) onlyAdmin external\\n    {\\n        /**\\n        * If \\\"monthlyUnlockPercent=0\\\" it means that there are not any subsequant unlock,\\n        * and all tokens will be unfrozen imidiately after \\\"_releaseTime\\\".\\n        */\\n        require(_monthlyUnlockPercent \\u003c= 100, \\\"_monthlyUnlockPercent shoulbe \\u003c= 100\\\");\\n        require(_releaseTime.sub(now) \\u003c= 365 days, \\\"freeze period is too long\\\");\\n        require(frozenTokens[_beneficiary].currentBalance == 0, \\\"there are unspended tokens\\\");\\n        require(totalHeld().sub(totalReserved) \\u003e= _value, \\\"not enough tokens\\\");\\n        frozenTokens[_beneficiary] = FreezeParams(_releaseTime,\\n            _value,\\n            _monthlyUnlockPercent,\\n            _value);\\n        totalReserved = totalReserved.add(_value);\\n        emit TokensHeld(_beneficiary, _value);\\n    }\\n\\n    function freezeOf(address _beneficiary) public view returns (uint256) {\\n        FreezeParams memory freezeData = frozenTokens[_beneficiary];\\n        if (freezeData.releaseTime \\u003c= now){\\n            if (freezeData.monthlyUnlockPercent != 0){\\n                uint256  monthsPassed;\\n                monthsPassed = now.sub(freezeData.releaseTime).div(30 days);\\n                uint256 unlockedValue = freezeData.initValue.mul(monthsPassed).mul(freezeData.monthlyUnlockPercent).div(100);\\n                if (freezeData.initValue \\u003c unlockedValue){\\n                    return 0;\\n                }\\n                else {\\n                    return freezeData.initValue.sub(unlockedValue);\\n                }\\n            }\\n            else {\\n                return 0;\\n            }\\n        }\\n        else\\n        {\\n            return freezeData.initValue;\\n        }\\n    }\\n\\n    /**\\n     * @return the beneficiaries available balance of the tokens.\\n     */\\n    function availableBalance(address _beneficiary) public view returns (uint256) {\\n        return frozenTokens[_beneficiary].currentBalance.sub(freezeOf(_beneficiary));\\n    }\\n\\n\\n    function release(address _beneficiary) external {\\n        uint256 value = availableBalance(_beneficiary);\\n        require(value \\u003e 0, \\\"TokenTimelock: no tokens to release\\\");\\n        require(_token.balanceOf(address(this)) \\u003e= value, \\\"insuficient funds\\\");\\n        totalReserved = totalReserved.sub(value);\\n        frozenTokens[_beneficiary].currentBalance = frozenTokens[_beneficiary].currentBalance.sub(value);\\n        _token.transfer(_beneficiary, value);\\n    }\\n\\n    function unfreeze(address _to, uint256 _value) external onlyAdmin {\\n        require(totalHeld().sub(totalReserved) \\u003e= _value, \\\"not enough available tokens\\\");\\n        _token.transfer(_to, _value);\\n    }\\n}\\n\"}}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"renounceAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"unfreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"availableBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_releaseTime\",\"type\":\"uint256\"},{\"name\":\"_monthlyUnlockPercent\",\"type\":\"uint256\"}],\"name\":\"holdTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenTokens\",\"outputs\":[{\"name\":\"releaseTime\",\"type\":\"uint256\"},{\"name\":\"initValue\",\"type\":\"uint256\"},{\"name\":\"monthlyUnlockPercent\",\"type\":\"uint256\"},{\"name\":\"currentBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalReserved\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"freezeOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalHeld\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TokensHeld\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "TokenTimelock", "CompilerVersion": "v0.5.0+commit.1d4f565a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000a31b1767e09f842ecfd4bc471fe44f830e3891aa", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://a12ee16dd803c6e9709fe221886d9a1869f9de563e4f0a9cd745cade650fd192"}