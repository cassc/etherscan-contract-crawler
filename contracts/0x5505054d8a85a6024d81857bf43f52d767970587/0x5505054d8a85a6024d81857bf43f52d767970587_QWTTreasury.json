{"SourceCode": "{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\r\\n}\"},\"IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\r\\n *\\r\\n * _Available since v4.1._\\r\\n */\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n}\"},\"IQWT.sol\":{\"content\":\"import \\\"./IERC20Metadata.sol\\\";\\r\\n\\r\\npragma solidity 0.8.19;\\r\\n\\r\\ninterface IQWT is IERC20Metadata {\\r\\n    function mint(address to_, uint256 amount_) external;\\r\\n\\r\\n    function burnFrom(address account_, uint256 amount_) external;\\r\\n\\r\\n    function burn(uint256 amount_) external;\\r\\n\\r\\n    function uniswapV2Pair() external view returns (address);\\r\\n}\"},\"IUniswapV2Router02.sol\":{\"content\":\"pragma solidity 0.8.19;\\r\\n\\r\\ninterface IUniswapV2Router02 {\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 amountADesired,\\r\\n        uint256 amountBDesired,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint256 amountTokenDesired,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable;\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n}\"},\"IWETH.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\r\\n\\r\\ninterface IWETH {\\r\\n    function deposit() external payable;\\r\\n\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint value\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function withdraw(uint) external;\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the sender is not the owner.\\r\\n     */\\r\\n    function _checkOwner() internal view virtual {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby disabling any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\"},\"Treasury.sol\":{\"content\":\"/*\\r\\nA Noob Testing \\\"Quantum Wealth Network\\\"\\r\\nBy Participating In\\r\\nThe Quantum Wealth Test\\r\\nYou Are Not Accelerating Your Wealth\\r\\nWith A Weak Test Network\\r\\n\\r\\nTelegram: https://t.me/QuantumWTest\\r\\nTwitter: https://twitter.com/QuantumWTest\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.19;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./IQWT.sol\\\";\\r\\nimport \\\"./IWETH.sol\\\";\\r\\nimport \\\"./IUniswapV2Router02.sol\\\";\\r\\n\\r\\n/// @title   QWTTreasury\\r\\n/// @notice  QWT TREASURY\\r\\ncontract QWTTreasury is Ownable {\\r\\n    /// STATE VARIABLS ///\\r\\n\\r\\n    /// @notice Address of UniswapV2Router\\r\\n    IUniswapV2Router02 public immutable uniswapV2Router;\\r\\n    /// @notice QWT address\\r\\n    address public immutable QWT;\\r\\n    /// @notice WETH address\\r\\n    address public immutable WETH;\\r\\n    /// @notice QWT/ETH LP\\r\\n    address public immutable uniswapV2Pair;\\r\\n\\r\\n    /// @notice Distributor\\r\\n    address public distributor;\\r\\n\\r\\n    /// @notice 0.0001 ETHER\\r\\n    uint256 public constant BACKING = 0.0001 ether;\\r\\n\\r\\n    /// @notice Time to wait before removing liquidity again\\r\\n    uint256 public constant TIME_TO_WAIT = 1 days;\\r\\n\\r\\n    /// @notice Max percent of liqudity that can be removed at one time\\r\\n    uint256 public constant MAX_REMOVAL = 10;\\r\\n\\r\\n    /// @notice Timestamp of last liquidity removal\\r\\n    uint256 public lastRemoval;\\r\\n\\r\\n    /// CONSTRUCTOR ///\\r\\n\\r\\n    /// @param _QWT  Address of QWT\\r\\n    /// @param _WETH  Address of WETH\\r\\n    constructor(address _QWT, address _WETH) {\\r\\n        QWT = _QWT;\\r\\n        WETH = _WETH;\\r\\n        uniswapV2Pair = IQWT(QWT).uniswapV2Pair();\\r\\n\\r\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(\\r\\n            0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\\r\\n        );\\r\\n\\r\\n        uniswapV2Router = _uniswapV2Router;\\r\\n    }\\r\\n\\r\\n    /// RECEIVE ///\\r\\n\\r\\n    /// @notice Allow to receive ETH\\r\\n    receive() external payable {}\\r\\n\\r\\n    /// MINTER FUNCTION ///\\r\\n\\r\\n    /// @notice         Distributor mints QWT\\r\\n    /// @param _to      Address where to mint QWT\\r\\n    /// @param _amount  Amount of QWT to mint\\r\\n    function mintQWT(address _to, uint256 _amount) external {\\r\\n        require(msg.sender == distributor, \\\"msg.sender is not distributor\\\");\\r\\n        IQWT(QWT).mint(_to, _amount);\\r\\n    }\\r\\n\\r\\n    /// VIEW FUNCTION ///\\r\\n\\r\\n    /// @notice         Returns amount of excess reserves\\r\\n    /// @return value_  Excess reserves\\r\\n    function excessReserves() external view returns (uint256 value_) {\\r\\n        uint256 _balance = IERC20(WETH).balanceOf(address(this));\\r\\n        uint256 _value = (_balance * 1e9) / BACKING;\\r\\n        if (IERC20(QWT).totalSupply() \\u003e _value) return 0;\\r\\n        return (_value - IERC20(QWT).totalSupply());\\r\\n    }\\r\\n\\r\\n    /// MUTATIVE FUNCTIONS ///\\r\\n\\r\\n    /// @notice         Redeem QWT for backing\\r\\n    /// @param _amount  Amount of QWT to redeem\\r\\n    function redeemQWT(uint256 _amount) external {\\r\\n        IQWT(QWT).burnFrom(msg.sender, _amount);\\r\\n        IERC20(WETH).transfer(msg.sender, (_amount * BACKING) / 1e9);\\r\\n    }\\r\\n\\r\\n    /// @notice Wrap any ETH in conract\\r\\n    function wrapETH() external {\\r\\n        uint256 ethBalance_ = address(this).balance;\\r\\n        if (ethBalance_ \\u003e 0) IWETH(WETH).deposit{value: ethBalance_}();\\r\\n    }\\r\\n\\r\\n    /// OWNER FUNCTIONS ///\\r\\n\\r\\n    /// @notice              Set QWT distributor\\r\\n    /// @param _distributor  Address of QWT distributor\\r\\n    function setDistributor(address _distributor) external onlyOwner {\\r\\n        require(distributor == address(0), \\\"distributor already set\\\");\\r\\n        distributor = _distributor;\\r\\n    }\\r\\n\\r\\n    /// @notice         Remove liquidity and add to backing\\r\\n    /// @param _amount  Amount of liquidity to remove\\r\\n    function removeLiquidity(uint256 _amount) external onlyOwner {\\r\\n        uint256 balance = IERC20(uniswapV2Pair).balanceOf(address(this));\\r\\n        require(\\r\\n            _amount \\u003c= (balance * MAX_REMOVAL) / 100,\\r\\n            \\\"Removing more than 10% of liquidity\\\"\\r\\n        );\\r\\n        require(\\r\\n            block.timestamp \\u003e lastRemoval + TIME_TO_WAIT,\\r\\n            \\\"Removed before 1 day lock\\\"\\r\\n        );\\r\\n        lastRemoval = block.timestamp;\\r\\n\\r\\n        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), _amount);\\r\\n\\r\\n        uniswapV2Router.removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n            QWT,\\r\\n            _amount,\\r\\n            0,\\r\\n            0,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n\\r\\n        _burnQWT();\\r\\n    }\\r\\n\\r\\n    /// @notice         Withdraw stuck token from treasury\\r\\n    /// @param _amount  Amount of token to remove\\r\\n    /// @param _token   Address of token to remove\\r\\n    function withdrawStuckToken(\\r\\n        uint256 _amount,\\r\\n        address _token\\r\\n    ) external onlyOwner {\\r\\n        require(_token != WETH, \\\"Can not withdraw WETH\\\");\\r\\n        require(_token != uniswapV2Pair, \\\"Can not withdraw LP\\\");\\r\\n        IERC20(_token).transfer(msg.sender, _amount);\\r\\n    }\\r\\n\\r\\n    /// INTERNAL FUNCTION ///\\r\\n\\r\\n    /// @notice Burn QWT from Treasury to increase backing\\r\\n    /// @dev    Invoked in `removeLiquidity()`\\r\\n    function _burnQWT() internal {\\r\\n        uint256 balance = IERC20(QWT).balanceOf(address(this));\\r\\n        IQWT(QWT).burn(balance);\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_QWT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BACKING\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_REMOVAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"QWT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_TO_WAIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"excessReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRemoval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintQWT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"redeemQWT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_distributor\",\"type\":\"address\"}],\"name\":\"setDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdrawStuckToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrapETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "QWTTreasury", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000db1ac2f1210794d4bafdbeadc64dd4f575d9a03000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6a0e8e8e569504587063f599fbe72ba409f528aa065ceb798271cc11bd421520"}