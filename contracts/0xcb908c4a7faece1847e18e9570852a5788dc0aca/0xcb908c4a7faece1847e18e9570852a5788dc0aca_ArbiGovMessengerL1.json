{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/arbi-fed/ArbiGovMessengerL1.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\nimport {IL1GatewayRouter} from \\\"arbitrum/tokenbridge/ethereum/gateway/IL1GatewayRouter.sol\\\";\\nimport {IInbox} from \\\"arbitrum-nitro/contracts/src/bridge/IInbox.sol\\\";\\nimport \\\"src/arbi-fed/ArbiGasManager.sol\\\";\\n\\ncontract ArbiGovMessengerL1 is ArbiGasManager{\\n    IL1GatewayRouter public immutable gatewayRouter = IL1GatewayRouter(0x72Ce9c846789fdB6fC1f34aC4AD25Dd9ef7031ef); \\n    \\n    IInbox public inbox;\\n    mapping(address => bool) public allowList;\\n\\n    event MessageSent(address to, bytes data);\\n\\n    constructor (address _gov, address _inbox, address _gasClerk) ArbiGasManager(gov, _gasClerk){\\n        gov = _gov;\\n        inbox = IInbox(_inbox);\\n    }\\n\\n    error OnlyAllowed();\\n\\n    modifier onlyAllowed {\\n        if (msg.sender != gov && !allowList[msg.sender]) revert OnlyAllowed();\\n        _;\\n    }\\n    /**\\n     * @notice Generalized function for sending messages to Arbitrum\\n     * @dev Call value of the function should be the funds necessary for gasLimit * gasPrice\\n     * @param _to The destination L2 address\\n     * @param _refundTo The L2 address to which the excess fee is credited (l1CallValue - (autoredeem ? ticket execution cost : submission cost) - l2CallValue)\\n     * @param _callValueRefundAddress The L2 address to which the l2CallValue is credited if the ticket times out or gets cancelled (this is also called the `beneficiary`, who's got a critical permission to cancel the ticket)\\n     * @param _l2CallValue The callvalue for retryable L2 message that is supplied within the deposit (l1CallValue)\\n     * @param _l2GasParams A struct consisting of three variables:\\n        - `uint256 maxSubmissionCost`: The maximum amount of ETH to be paid for submitting the ticket. This amount is (1) supplied within the deposit (l1CallValue) to be later deducted from sender's L2 balance and is (2) directly proportional to the size of the retryable\u2019s data and L1 basefee\\n        - `uint256 gasLimit`: Maximum amount of gas used to cover L2 execution of the ticket\\n        - `uint256 maxFeePerGas`: The gas price bid for L2 execution of the ticket that is supplied within the deposit (l1CallValue)\\n     * @param _data The calldata to the destination L2 address\\n     */    \\n    function sendMessage(\\n        address _to,\\n        address _refundTo,\\n        address _callValueRefundAddress,\\n        uint256 _l1CallValue,\\n        uint256 _l2CallValue,\\n        L2GasParams memory _l2GasParams,\\n        bytes memory _data\\n    ) external payable onlyAllowed() returns (uint256) {\\n        \\n        emit MessageSent(_to, _data);\\n\\n        return inbox.createRetryableTicket{ value: _l1CallValue }(\\n            _to,\\n            _l2CallValue,\\n            _l2GasParams._maxSubmissionCost,\\n            _refundTo, // only refund excess fee to the custom address\\n            _callValueRefundAddress, // user can cancel the retryable and receive call value refund\\n            _l2GasParams._maxGas,\\n            _l2GasParams._gasPriceBid,\\n            _data\\n        );\\n    }\\n\\n    /**\\n     * @notice Send message to L2 address\\n     * @dev This function automatically handles gas estimation. Default gas limit may be too low to execute.\\n     * @param _to L2 address to send message to\\n     * @param _functionSelector Function selector of the function to call at the L2 address\\n     * @param _data The calldata to the L2 address\\n     */\\n    function sendMessage(\\n        address _to,\\n        bytes4 _functionSelector,\\n        bytes calldata _data\\n    ) external payable onlyAllowed() returns (uint256) {\\n        emit MessageSent(_to, _data);\\n        bytes32 functionId = keccak256(abi.encodePacked(_functionSelector, _to)); //Hash of address + functionSelector should be collision resistant\\n        uint gasLimit = functionGasLimit[functionId];\\n        if(gasLimit == 0) gasLimit = defaultGasLimit;\\n\\n        return inbox.createRetryableTicket{ value: gasLimit * gasPrice + maxSubmissionCost}(\\n            _to,\\n            0,\\n            maxSubmissionCost,\\n            refundAddress,\\n            refundAddress, // refundAddress can cancel the retryable ticket and receive call value refund\\n            gasLimit,\\n            gasPrice,\\n            _data\\n        );\\n    }\\n\\n    /**\\n     * @notice Sets the arbitrum bridge inbox\\n     * @param _newInbox Address of the new inbox\\n     */\\n    function setInbox(address _newInbox) external onlyGov {\\n        inbox = IInbox(_newInbox);\\n    }\\n\\n    /**\\n     * @notice Sets the status of an address that is allowed to send messages on behalf of gov on L2\\n     * @dev Allows for the creation of governance contracts for specific contracts, simplifying proposal making. Should never allow an EOA, MSIG or upgradeable contract.\\n     * @param allowee Address of the contract to set allowed status for\\n     * @param isAllowed true for allowing a contract, false for disallowing\\n     */\\n    function setAllowed(address allowee, bool isAllowed) external onlyGov {\\n        allowList[allowee] = isAllowed;\\n    }\\n\\n    /**\\n     * @notice Sweep Eth to gov\\n     */\\n    function sweepEth() external onlyGov {\\n        uint amount = address(this).balance;\\n        payable(gov).transfer(amount);\\n    }\\n\\n    receive() external payable{}\\n}\\n\"\r\n    },\r\n    \"lib/arbitrum/contracts/tokenbridge/ethereum/gateway/IL1GatewayRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2020, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\nimport \\\"../../libraries/gateway/ITokenGateway.sol\\\";\\nimport \\\"../../libraries/IERC165.sol\\\";\\n\\n/**\\n * @title Handles deposits from Erhereum into Arbitrum. Tokens are routered to their appropriate L1 gateway (Router itself also conforms to the Gateway itnerface).\\n * @notice Router also serves as an L1-L2 token address oracle.\\n */\\ninterface IL1GatewayRouter is ITokenGateway, IERC165 {\\n    /**\\n     * @notice Deposit ERC20 token from Ethereum into Arbitrum using the registered or otherwise default gateway\\n     * @dev Some legacy gateway might not have the outboundTransferCustomRefund method and will revert, in such case use outboundTransfer instead\\n     *      L2 address alias will not be applied to the following types of addresses on L1:\\n     *      - an externally-owned account\\n     *      - a contract in construction\\n     *      - an address where a contract will be created\\n     *      - an address where a contract lived, but was destroyed\\n     * @param _token L1 address of ERC20\\n     * @param _refundTo Account, or its L2 alias if it have code in L1, to be credited with excess gas refund in L2\\n     * @param _to Account to be credited with the tokens in the L2 (can be the user's L2 account or a contract), not subject to L2 aliasing\\n                  This account, or its L2 alias if it have code in L1, will also be able to cancel the retryable ticket and receive callvalue refund\\n     * @param _amount Token Amount\\n     * @param _maxGas Max gas deducted from user's L2 balance to cover L2 execution\\n     * @param _gasPriceBid Gas price for L2 execution\\n     * @param _data encoded data from router and user\\n     * @return res abi encoded inbox sequence number\\n     */\\n    function outboundTransferCustomRefund(\\n        address _token,\\n        address _refundTo,\\n        address _to,\\n        uint256 _amount,\\n        uint256 _maxGas,\\n        uint256 _gasPriceBid,\\n        bytes calldata _data\\n    ) external payable returns (bytes memory);\\n\\n    /**\\n     * @notice Allows L1 Token contract to trustlessly register its gateway.\\n     * @param _gateway l1 gateway address\\n     * @param _maxGas max gas for L2 retryable exrecution\\n     * @param _gasPriceBid gas price for L2 retryable ticket\\n     * @param  _maxSubmissionCost base submission cost  L2 retryable tick3et\\n     * @param _creditBackAddress address for crediting back overpayment of _maxSubmissionCost\\n     * @return Retryable ticket ID\\n     */\\n    function setGateway(\\n        address _gateway,\\n        uint256 _maxGas,\\n        uint256 _gasPriceBid,\\n        uint256 _maxSubmissionCost,\\n        address _creditBackAddress\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @notice Allows L1 Token contract to trustlessly register its gateway. (other setGateway method allows excess eth recovery from _maxSubmissionCost and is recommended)\\n     * @param _gateway l1 gateway address\\n     * @param _maxGas max gas for L2 retryable exrecution\\n     * @param _gasPriceBid gas price for L2 retryable ticket\\n     * @param  _maxSubmissionCost base submission cost  L2 retryable tick3et\\n     * @return Retryable ticket ID\\n     */\\n    function setGateway(\\n        address _gateway,\\n        uint256 _maxGas,\\n        uint256 _gasPriceBid,\\n        uint256 _maxSubmissionCost\\n    ) external payable returns (uint256);\\n\\n    function owner() external view returns (address);\\n\\n    function inbox() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/arbitrum-nitro/contracts/src/bridge/IInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\nimport \\\"./IBridge.sol\\\";\\nimport \\\"./IDelayedMessageProvider.sol\\\";\\nimport \\\"./ISequencerInbox.sol\\\";\\n\\ninterface IInbox is IDelayedMessageProvider {\\n    function bridge() external view returns (IBridge);\\n\\n    function sequencerInbox() external view returns (ISequencerInbox);\\n\\n    /**\\n     * @notice Send a generic L2 message to the chain\\n     * @dev This method is an optimization to avoid having to emit the entirety of the messageData in a log. Instead validators are expected to be able to parse the data from the transaction's input\\n     *      This method will be disabled upon L1 fork to prevent replay attacks on L2\\n     * @param messageData Data of the message being sent\\n     */\\n    function sendL2MessageFromOrigin(bytes calldata messageData) external returns (uint256);\\n\\n    /**\\n     * @notice Send a generic L2 message to the chain\\n     * @dev This method can be used to send any type of message that doesn't require L1 validation\\n     *      This method will be disabled upon L1 fork to prevent replay attacks on L2\\n     * @param messageData Data of the message being sent\\n     */\\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\\n\\n    function sendL1FundedUnsignedTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 nonce,\\n        address to,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    function sendL1FundedContractTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        address to,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    function sendUnsignedTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 nonce,\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    function sendContractTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    /**\\n     * @dev This method can only be called upon L1 fork and will not alias the caller\\n     *      This method will revert if not called from origin\\n     */\\n    function sendL1FundedUnsignedTransactionToFork(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 nonce,\\n        address to,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @dev This method can only be called upon L1 fork and will not alias the caller\\n     *      This method will revert if not called from origin\\n     */\\n    function sendUnsignedTransactionToFork(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 nonce,\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Send a message to initiate L2 withdrawal\\n     * @dev This method can only be called upon L1 fork and will not alias the caller\\n     *      This method will revert if not called from origin\\n     */\\n    function sendWithdrawEthToFork(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 nonce,\\n        uint256 value,\\n        address withdrawTo\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Get the L1 fee for submitting a retryable\\n     * @dev This fee can be paid by funds already in the L2 aliased address or by the current message value\\n     * @dev This formula may change in the future, to future proof your code query this method instead of inlining!!\\n     * @param dataLength The length of the retryable's calldata, in bytes\\n     * @param baseFee The block basefee when the retryable is included in the chain, if 0 current block.basefee will be used\\n     */\\n    function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @notice Deposit eth from L1 to L2 to address of the sender if sender is an EOA, and to its aliased address if the sender is a contract\\n     * @dev This does not trigger the fallback function when receiving in the L2 side.\\n     *      Look into retryable tickets if you are interested in this functionality.\\n     * @dev This function should not be called inside contract constructors\\n     */\\n    function depositEth() external payable returns (uint256);\\n\\n    /**\\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\\n     * @dev all msg.value will deposited to callValueRefundAddress on L2\\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\\n     * @param to destination L2 contract address\\n     * @param l2CallValue call value for retryable L2 message\\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on L2 balance\\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param data ABI encoded data of L2 message\\n     * @return unique message number of the retryable transaction\\n     */\\n    function createRetryableTicket(\\n        address to,\\n        uint256 l2CallValue,\\n        uint256 maxSubmissionCost,\\n        address excessFeeRefundAddress,\\n        address callValueRefundAddress,\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\\n     * @dev Same as createRetryableTicket, but does not guarantee that submission will succeed by requiring the needed funds\\n     * come from the deposit alone, rather than falling back on the user's L2 balance\\n     * @dev Advanced usage only (does not rewrite aliases for excessFeeRefundAddress and callValueRefundAddress).\\n     * createRetryableTicket method is the recommended standard.\\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\\n     * @param to destination L2 contract address\\n     * @param l2CallValue call value for retryable L2 message\\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on L2 balance\\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param data ABI encoded data of L2 message\\n     * @return unique message number of the retryable transaction\\n     */\\n    function unsafeCreateRetryableTicket(\\n        address to,\\n        uint256 l2CallValue,\\n        uint256 maxSubmissionCost,\\n        address excessFeeRefundAddress,\\n        address callValueRefundAddress,\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    // ---------- onlyRollupOrOwner functions ----------\\n\\n    /// @notice pauses all inbox functionality\\n    function pause() external;\\n\\n    /// @notice unpauses all inbox functionality\\n    function unpause() external;\\n\\n    // ---------- initializer ----------\\n\\n    /**\\n     * @dev function to be called one time during the inbox upgrade process\\n     *      this is used to fix the storage slots\\n     */\\n    function postUpgradeInit(IBridge _bridge) external;\\n\\n    function initialize(IBridge _bridge, ISequencerInbox _sequencerInbox) external;\\n}\\n\"\r\n    },\r\n    \"src/arbi-fed/ArbiGasManager.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\nimport \\\"src/arbi-fed/Governable.sol\\\";\\n\\n\\ncontract ArbiGasManager is Governable{\\n    address public gasClerk;\\n    address public refundAddress;\\n    mapping(bytes32 => uint) public functionGasLimit;\\n    uint public defaultGasLimit;\\n    uint public maxSubmissionCostCeiling;\\n    uint public maxSubmissionCost;\\n    uint public gasPriceCeiling;\\n    uint public gasPrice;\\n\\n    struct L2GasParams {\\n        uint256 _maxSubmissionCost;\\n        uint256 _maxGas;\\n        uint256 _gasPriceBid;\\n    }\\n\\n\\n    constructor(address _gov, address _gasClerk) Governable(_gov){\\n        gasClerk = _gasClerk;\\n        refundAddress = _gasClerk;\\n        defaultGasLimit = 10**6; //Same gas stipend as Optimism bridge\\n        maxSubmissionCost = 0.01 ether;\\n        gasPriceCeiling = 10**10; //10 gWEI\\n        gasPrice = 10**1; //1 gWEI\\n    }\\n\\n    error OnlyGasClerk();\\n    error MaxSubmissionCostAboveCeiling();\\n    error GasPriceAboveCeiling();\\n\\n    modifier onlyGasClerk(){\\n        if(msg.sender != gasClerk) revert OnlyGasClerk();\\n        _;\\n    }\\n\\n    function setDefaultGasLimit(uint newDefaultGasLimit) external onlyGasClerk {\\n        defaultGasLimit = newDefaultGasLimit; \\n    }\\n\\n    function setFunctionGasLimit(address contractAddress, bytes4 functionSelector, uint gasLimit) external onlyGasClerk {\\n        bytes32 hash = keccak256(abi.encodePacked(functionSelector, contractAddress));\\n        functionGasLimit[hash] = gasLimit; \\n    }\\n\\n    function setMaxSubmissionCost(uint newMaxSubmissionCost) external onlyGasClerk {\\n        if(newMaxSubmissionCost > maxSubmissionCostCeiling) revert MaxSubmissionCostAboveCeiling();\\n        maxSubmissionCost = newMaxSubmissionCost;\\n    }\\n\\n    function setGasPrice(uint newGasPrice) external onlyGasClerk {\\n        if(newGasPrice > gasPriceCeiling) revert GasPriceAboveCeiling();\\n        gasPrice = newGasPrice;\\n    }\\n\\n    function getGasParams(address contractAddress, bytes4 functionSelector) public view returns(L2GasParams memory){\\n        L2GasParams memory gasParams;\\n        gasParams._maxSubmissionCost = maxSubmissionCost;\\n        gasParams._gasPriceBid = gasPrice;\\n        bytes32 hash = keccak256(abi.encodePacked(functionSelector, contractAddress));\\n        uint gasLimit = functionGasLimit[hash]; \\n        if(gasLimit == 0) gasLimit = defaultGasLimit;\\n        gasParams._maxGas = gasLimit;\\n        return gasParams;\\n    }\\n\\n    function setRefundAddress(address newRefundAddress) external onlyGov {\\n        refundAddress = newRefundAddress;\\n    }\\n\\n    function setSubmissionCostCeiling(uint newSubmissionCostCeiling) external onlyGov {\\n       maxSubmissionCostCeiling = newSubmissionCostCeiling; \\n    }\\n\\n    function setGasPriceCeiling(uint newGasPriceCeiling) external onlyGov {\\n       gasPriceCeiling = newGasPriceCeiling; \\n    }\\n\\n    function setGasClerk(address newGasClerk) external onlyGov {\\n        gasClerk = newGasClerk;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/arbitrum/contracts/tokenbridge/libraries/gateway/ITokenGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2020, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\ninterface ITokenGateway {\\n    /// @notice event deprecated in favor of DepositInitiated and WithdrawalInitiated\\n    // event OutboundTransferInitiated(\\n    //     address token,\\n    //     address indexed _from,\\n    //     address indexed _to,\\n    //     uint256 indexed _transferId,\\n    //     uint256 _amount,\\n    //     bytes _data\\n    // );\\n\\n    /// @notice event deprecated in favor of DepositFinalized and WithdrawalFinalized\\n    // event InboundTransferFinalized(\\n    //     address token,\\n    //     address indexed _from,\\n    //     address indexed _to,\\n    //     uint256 indexed _transferId,\\n    //     uint256 _amount,\\n    //     bytes _data\\n    // );\\n\\n    function outboundTransfer(\\n        address _token,\\n        address _to,\\n        uint256 _amount,\\n        uint256 _maxGas,\\n        uint256 _gasPriceBid,\\n        bytes calldata _data\\n    ) external payable returns (bytes memory);\\n\\n    function finalizeInboundTransfer(\\n        address _token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes calldata _data\\n    ) external payable;\\n\\n    /**\\n     * @notice Calculate the address used when bridging an ERC20 token\\n     * @dev the L1 and L2 address oracles may not always be in sync.\\n     * For example, a custom token may have been registered but not deploy or the contract self destructed.\\n     * @param l1ERC20 address of L1 token\\n     * @return L2 address of a bridged ERC20 token\\n     */\\n    function calculateL2TokenAddress(address l1ERC20) external view returns (address);\\n\\n    function getOutboundCalldata(\\n        address _token,\\n        address _from,\\n        address _to,\\n        uint256 _amount,\\n        bytes memory _data\\n    ) external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"lib/arbitrum/contracts/tokenbridge/libraries/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\n// With pragma modification to allow interface compatibility with >=0.6.9 <0.9.0\\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.6/contracts/utils/introspection/IERC165.sol\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/arbitrum-nitro/contracts/src/bridge/IBridge.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\nimport \\\"./IOwnable.sol\\\";\\n\\ninterface IBridge {\\n    event MessageDelivered(\\n        uint256 indexed messageIndex,\\n        bytes32 indexed beforeInboxAcc,\\n        address inbox,\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash,\\n        uint256 baseFeeL1,\\n        uint64 timestamp\\n    );\\n\\n    event BridgeCallTriggered(\\n        address indexed outbox,\\n        address indexed to,\\n        uint256 value,\\n        bytes data\\n    );\\n\\n    event InboxToggle(address indexed inbox, bool enabled);\\n\\n    event OutboxToggle(address indexed outbox, bool enabled);\\n\\n    event SequencerInboxUpdated(address newSequencerInbox);\\n\\n    function allowedDelayedInboxList(uint256) external returns (address);\\n\\n    function allowedOutboxList(uint256) external returns (address);\\n\\n    /// @dev Accumulator for delayed inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\\n    function delayedInboxAccs(uint256) external view returns (bytes32);\\n\\n    /// @dev Accumulator for sequencer inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\\n    function sequencerInboxAccs(uint256) external view returns (bytes32);\\n\\n    function rollup() external view returns (IOwnable);\\n\\n    function sequencerInbox() external view returns (address);\\n\\n    function activeOutbox() external view returns (address);\\n\\n    function allowedDelayedInboxes(address inbox) external view returns (bool);\\n\\n    function allowedOutboxes(address outbox) external view returns (bool);\\n\\n    function sequencerReportedSubMessageCount() external view returns (uint256);\\n\\n    /**\\n     * @dev Enqueue a message in the delayed inbox accumulator.\\n     *      These messages are later sequenced in the SequencerInbox, either\\n     *      by the sequencer as part of a normal batch, or by force inclusion.\\n     */\\n    function enqueueDelayedMessage(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external payable returns (uint256);\\n\\n    function executeCall(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData);\\n\\n    function delayedMessageCount() external view returns (uint256);\\n\\n    function sequencerMessageCount() external view returns (uint256);\\n\\n    // ---------- onlySequencerInbox functions ----------\\n\\n    function enqueueSequencerMessage(\\n        bytes32 dataHash,\\n        uint256 afterDelayedMessagesRead,\\n        uint256 prevMessageCount,\\n        uint256 newMessageCount\\n    )\\n        external\\n        returns (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 acc\\n        );\\n\\n    /**\\n     * @dev Allows the sequencer inbox to submit a delayed message of the batchPostingReport type\\n     *      This is done through a separate function entrypoint instead of allowing the sequencer inbox\\n     *      to call `enqueueDelayedMessage` to avoid the gas overhead of an extra SLOAD in either\\n     *      every delayed inbox or every sequencer inbox call.\\n     */\\n    function submitBatchSpendingReport(address batchPoster, bytes32 dataHash)\\n        external\\n        returns (uint256 msgNum);\\n\\n    // ---------- onlyRollupOrOwner functions ----------\\n\\n    function setSequencerInbox(address _sequencerInbox) external;\\n\\n    function setDelayedInbox(address inbox, bool enabled) external;\\n\\n    function setOutbox(address inbox, bool enabled) external;\\n\\n    // ---------- initializer ----------\\n\\n    function initialize(IOwnable rollup_) external;\\n}\\n\"\r\n    },\r\n    \"lib/arbitrum-nitro/contracts/src/bridge/IDelayedMessageProvider.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\ninterface IDelayedMessageProvider {\\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\\n\\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\\n    /// same as InboxMessageDelivered but the batch data is available in tx.input\\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\\n}\\n\"\r\n    },\r\n    \"lib/arbitrum-nitro/contracts/src/bridge/ISequencerInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../libraries/IGasRefunder.sol\\\";\\nimport \\\"./IDelayedMessageProvider.sol\\\";\\nimport \\\"./IBridge.sol\\\";\\n\\ninterface ISequencerInbox is IDelayedMessageProvider {\\n    struct MaxTimeVariation {\\n        uint256 delayBlocks;\\n        uint256 futureBlocks;\\n        uint256 delaySeconds;\\n        uint256 futureSeconds;\\n    }\\n\\n    struct TimeBounds {\\n        uint64 minTimestamp;\\n        uint64 maxTimestamp;\\n        uint64 minBlockNumber;\\n        uint64 maxBlockNumber;\\n    }\\n\\n    enum BatchDataLocation {\\n        TxInput,\\n        SeparateBatchEvent,\\n        NoData\\n    }\\n\\n    event SequencerBatchDelivered(\\n        uint256 indexed batchSequenceNumber,\\n        bytes32 indexed beforeAcc,\\n        bytes32 indexed afterAcc,\\n        bytes32 delayedAcc,\\n        uint256 afterDelayedMessagesRead,\\n        TimeBounds timeBounds,\\n        BatchDataLocation dataLocation\\n    );\\n\\n    event OwnerFunctionCalled(uint256 indexed id);\\n\\n    /// @dev a separate event that emits batch data when this isn't easily accessible in the tx.input\\n    event SequencerBatchData(uint256 indexed batchSequenceNumber, bytes data);\\n\\n    /// @dev a valid keyset was added\\n    event SetValidKeyset(bytes32 indexed keysetHash, bytes keysetBytes);\\n\\n    /// @dev a keyset was invalidated\\n    event InvalidateKeyset(bytes32 indexed keysetHash);\\n\\n    function totalDelayedMessagesRead() external view returns (uint256);\\n\\n    function bridge() external view returns (IBridge);\\n\\n    /// @dev The size of the batch header\\n    // solhint-disable-next-line func-name-mixedcase\\n    function HEADER_LENGTH() external view returns (uint256);\\n\\n    /// @dev If the first batch data byte after the header has this bit set,\\n    ///      the sequencer inbox has authenticated the data. Currently not used.\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DATA_AUTHENTICATED_FLAG() external view returns (bytes1);\\n\\n    function rollup() external view returns (IOwnable);\\n\\n    function isBatchPoster(address) external view returns (bool);\\n\\n    struct DasKeySetInfo {\\n        bool isValidKeyset;\\n        uint64 creationBlock;\\n    }\\n\\n    // https://github.com/ethereum/solidity/issues/11826\\n    // function maxTimeVariation() external view returns (MaxTimeVariation calldata);\\n    // function dasKeySetInfo(bytes32) external view returns (DasKeySetInfo calldata);\\n\\n    /// @notice Remove force inclusion delay after a L1 chainId fork\\n    function removeDelayAfterFork() external;\\n\\n    /// @notice Force messages from the delayed inbox to be included in the chain\\n    ///         Callable by any address, but message can only be force-included after maxTimeVariation.delayBlocks and\\n    ///         maxTimeVariation.delaySeconds has elapsed. As part of normal behaviour the sequencer will include these\\n    ///         messages so it's only necessary to call this if the sequencer is down, or not including any delayed messages.\\n    /// @param _totalDelayedMessagesRead The total number of messages to read up to\\n    /// @param kind The kind of the last message to be included\\n    /// @param l1BlockAndTime The l1 block and the l1 timestamp of the last message to be included\\n    /// @param baseFeeL1 The l1 gas price of the last message to be included\\n    /// @param sender The sender of the last message to be included\\n    /// @param messageDataHash The messageDataHash of the last message to be included\\n    function forceInclusion(\\n        uint256 _totalDelayedMessagesRead,\\n        uint8 kind,\\n        uint64[2] calldata l1BlockAndTime,\\n        uint256 baseFeeL1,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external;\\n\\n    function inboxAccs(uint256 index) external view returns (bytes32);\\n\\n    function batchCount() external view returns (uint256);\\n\\n    function isValidKeysetHash(bytes32 ksHash) external view returns (bool);\\n\\n    /// @notice the creation block is intended to still be available after a keyset is deleted\\n    function getKeysetCreationBlock(bytes32 ksHash) external view returns (uint256);\\n\\n    // ---------- BatchPoster functions ----------\\n\\n    function addSequencerL2BatchFromOrigin(\\n        uint256 sequenceNumber,\\n        bytes calldata data,\\n        uint256 afterDelayedMessagesRead,\\n        IGasRefunder gasRefunder\\n    ) external;\\n\\n    function addSequencerL2Batch(\\n        uint256 sequenceNumber,\\n        bytes calldata data,\\n        uint256 afterDelayedMessagesRead,\\n        IGasRefunder gasRefunder,\\n        uint256 prevMessageCount,\\n        uint256 newMessageCount\\n    ) external;\\n\\n    // ---------- onlyRollupOrOwner functions ----------\\n\\n    /**\\n     * @notice Set max delay for sequencer inbox\\n     * @param maxTimeVariation_ the maximum time variation parameters\\n     */\\n    function setMaxTimeVariation(MaxTimeVariation memory maxTimeVariation_) external;\\n\\n    /**\\n     * @notice Updates whether an address is authorized to be a batch poster at the sequencer inbox\\n     * @param addr the address\\n     * @param isBatchPoster_ if the specified address should be authorized as a batch poster\\n     */\\n    function setIsBatchPoster(address addr, bool isBatchPoster_) external;\\n\\n    /**\\n     * @notice Makes Data Availability Service keyset valid\\n     * @param keysetBytes bytes of the serialized keyset\\n     */\\n    function setValidKeyset(bytes calldata keysetBytes) external;\\n\\n    /**\\n     * @notice Invalidates a Data Availability Service keyset\\n     * @param ksHash hash of the keyset\\n     */\\n    function invalidateKeysetHash(bytes32 ksHash) external;\\n\\n    // ---------- initializer ----------\\n\\n    function initialize(IBridge bridge_, MaxTimeVariation calldata maxTimeVariation_) external;\\n}\\n\"\r\n    },\r\n    \"src/arbi-fed/Governable.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\nabstract contract Governable {\\n\\n    address public gov;\\n    address public pendingGov;\\n\\n    constructor(address _gov){\\n        gov = _gov;\\n    }\\n\\n    error OnlyGov();\\n    error OnlyPendingGov();\\n\\n    modifier onlyGov() {\\n        if(msg.sender != gov) revert OnlyGov();\\n        _;\\n    }\\n\\n    modifier onlyPendingGov() {\\n        if(msg.sender != gov) revert OnlyPendingGov();\\n        _;\\n    }\\n\\n    function setPendingGov(address newPendingGov) external onlyGov {\\n        pendingGov = newPendingGov;\\n    }\\n\\n    function claimPendingGov() external onlyPendingGov{\\n        gov = pendingGov;\\n        pendingGov = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/arbitrum-nitro/contracts/src/bridge/IOwnable.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.4.21 <0.9.0;\\n\\ninterface IOwnable {\\n    function owner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/arbitrum-nitro/contracts/src/libraries/IGasRefunder.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.6.9 <0.9.0;\\n\\ninterface IGasRefunder {\\n    function onGasSpent(\\n        address payable spender,\\n        uint256 gasUsed,\\n        uint256 calldataSize\\n    ) external returns (bool success);\\n}\\n\\nabstract contract GasRefundEnabled {\\n    /// @dev this refunds the sender for execution costs of the tx\\n    /// calldata costs are only refunded if `msg.sender == tx.origin` to guarantee the value refunded relates to charging\\n    /// for the `tx.input`. this avoids a possible attack where you generate large calldata from a contract and get over-refunded\\n    modifier refundsGas(IGasRefunder gasRefunder) {\\n        uint256 startGasLeft = gasleft();\\n        _;\\n        if (address(gasRefunder) != address(0)) {\\n            uint256 calldataSize;\\n            assembly {\\n                calldataSize := calldatasize()\\n            }\\n            uint256 calldataWords = (calldataSize + 31) / 32;\\n            // account for the CALLDATACOPY cost of the proxy contract, including the memory expansion cost\\n            startGasLeft += calldataWords * 6 + (calldataWords**2) / 512;\\n            // if triggered in a contract call, the spender may be overrefunded by appending dummy data to the call\\n            // so we check if it is a top level call, which would mean the sender paid calldata as part of tx.input\\n            // solhint-disable-next-line avoid-tx-origin\\n            if (msg.sender != tx.origin) {\\n                // We can't be sure if this calldata came from the top level tx,\\n                // so to be safe we tell the gas refunder there was no calldata.\\n                calldataSize = 0;\\n            }\\n            gasRefunder.onGasSpent(payable(msg.sender), startGasLeft - gasleft(), calldataSize);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"arbitrum-nitro/=lib/arbitrum-nitro/\",\r\n      \"arbitrum/=lib/arbitrum/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin/=lib/openzeppelin/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gov\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_inbox\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gasClerk\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"GasPriceAboveCeiling\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxSubmissionCostAboveCeiling\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyGasClerk\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyGov\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyPendingGov\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"MessageSent\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimPendingGov\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultGasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"functionGasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasClerk\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasPriceCeiling\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gatewayRouter\",\"outputs\":[{\"internalType\":\"contract IL1GatewayRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"functionSelector\",\"type\":\"bytes4\"}],\"name\":\"getGasParams\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_maxSubmissionCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasPriceBid\",\"type\":\"uint256\"}],\"internalType\":\"struct ArbiGasManager.L2GasParams\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gov\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inbox\",\"outputs\":[{\"internalType\":\"contract IInbox\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSubmissionCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSubmissionCostCeiling\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingGov\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"_functionSelector\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"sendMessage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_refundTo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_callValueRefundAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_l1CallValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_l2CallValue\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_maxSubmissionCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gasPriceBid\",\"type\":\"uint256\"}],\"internalType\":\"struct ArbiGasManager.L2GasParams\",\"name\":\"_l2GasParams\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"sendMessage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"allowee\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isAllowed\",\"type\":\"bool\"}],\"name\":\"setAllowed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDefaultGasLimit\",\"type\":\"uint256\"}],\"name\":\"setDefaultGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"functionSelector\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"setFunctionGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGasClerk\",\"type\":\"address\"}],\"name\":\"setGasClerk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newGasPrice\",\"type\":\"uint256\"}],\"name\":\"setGasPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newGasPriceCeiling\",\"type\":\"uint256\"}],\"name\":\"setGasPriceCeiling\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newInbox\",\"type\":\"address\"}],\"name\":\"setInbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxSubmissionCost\",\"type\":\"uint256\"}],\"name\":\"setMaxSubmissionCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingGov\",\"type\":\"address\"}],\"name\":\"setPendingGov\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRefundAddress\",\"type\":\"address\"}],\"name\":\"setRefundAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newSubmissionCostCeiling\",\"type\":\"uint256\"}],\"name\":\"setSubmissionCostCeiling\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sweepEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ArbiGovMessengerL1", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000011ec78492d53c9276dd7a184b1dbfb34e50b710d0000000000000000000000004dbd4fc535ac27206064b68ffcf827b0a60bab3f00000000000000000000000011ec78492d53c9276dd7a184b1dbfb34e50b710d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}