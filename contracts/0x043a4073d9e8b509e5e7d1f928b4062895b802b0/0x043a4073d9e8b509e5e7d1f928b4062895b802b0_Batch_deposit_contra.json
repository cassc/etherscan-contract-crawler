{"SourceCode": "# @version ^0.3.9\r\n\r\n# \u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2557\u2588\u2588\u2557     \u2588\u2588\u2588\u2557   \u2588\u2588\u2557\r\n# \u2588\u2588\u2551 \u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\r\n# \u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\r\n# \u2588\u2588\u2554\u2550\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\r\n# \u2588\u2588\u2551  \u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\r\n# \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\r\n\r\n\"\"\"\r\n@title Batch deposit contract\r\n@notice Allows for batched deposits to the the Ethereum beacon chain deposit contract\r\n@license MIT\r\n@author 0xvv <https://github.com/0xvv>\r\n@author Axxe <https://github.com/maximebrugel>\r\n\"\"\"\r\n\r\nMAX_LEN : constant(uint256) = 64 # lower is more gas efficient, but less flexible\r\nBIG_MAX_LEN: constant(uint256) = 512\r\nPUBLIC_KEY_LEN: constant(uint256) = 48\r\nWITHDRAWAL_CRED_LEN: constant(uint256) = 32\r\nSIGNATURE_LEN: constant(uint256) = 96\r\n\r\ndepositAddress: immutable(address)\r\n\r\n@external\r\ndef __init__(depositAdd: address):\r\n    depositAddress = depositAdd\r\n\r\n@payable\r\n@external\r\ndef batchDeposit(publicKeys: Bytes[MAX_LEN*PUBLIC_KEY_LEN],\r\n                withdrawalCreds: Bytes[MAX_LEN*WITHDRAWAL_CRED_LEN],\r\n                signatures: Bytes[MAX_LEN*SIGNATURE_LEN],\r\n                dataRoots:  DynArray[bytes32, MAX_LEN]) :\r\n    \"\"\"\r\n    @notice Deposit up to 64 validators to the offical staking contract\r\n    @dev Max of 64 validators to limit the gas overhead of bigger limits for smaller deposits\r\n    @param pulbicKeys The public keys of the validators to deposit\r\n    @param withdrawalCreds The withdrawal credentials of the validators to deposit\r\n    @param signatures The signatures of the validators to deposit\r\n    @param dataRoots The data roots of the validators to deposit\r\n    \"\"\"\r\n    assert len(publicKeys) % PUBLIC_KEY_LEN == 0\r\n    assert len(withdrawalCreds) % WITHDRAWAL_CRED_LEN == 0\r\n    assert len(signatures) % SIGNATURE_LEN == 0\r\n    l : uint256 = len(dataRoots)\r\n    assert l == len(publicKeys) / PUBLIC_KEY_LEN\r\n    assert l == len(withdrawalCreds) / WITHDRAWAL_CRED_LEN\r\n    assert l == len(signatures) / SIGNATURE_LEN\r\n    pk : uint256 = 0\r\n    wc : uint256 = 0\r\n    sig : uint256 = 0\r\n    for dataRoot in dataRoots:\r\n        raw_call(\r\n        depositAddress,\r\n        _abi_encode(slice(publicKeys, pk, PUBLIC_KEY_LEN),\r\n                    slice(withdrawalCreds, wc, WITHDRAWAL_CRED_LEN),\r\n                    slice(signatures, sig, SIGNATURE_LEN),\r\n                    dataRoot,\r\n                    method_id=method_id(\"deposit(bytes,bytes,bytes,bytes32)\")),\r\n        value= as_wei_value(32, \"ether\"),\r\n        revert_on_failure=True)\r\n        pk += PUBLIC_KEY_LEN\r\n        wc += WITHDRAWAL_CRED_LEN\r\n        sig += SIGNATURE_LEN\r\n\r\n@payable\r\n@external\r\ndef batchDepositCustom(publicKeys: Bytes[MAX_LEN*PUBLIC_KEY_LEN],\r\n                withdrawalCreds: Bytes[MAX_LEN*WITHDRAWAL_CRED_LEN],\r\n                signatures: Bytes[MAX_LEN*SIGNATURE_LEN],\r\n                dataRoots:  DynArray[bytes32, MAX_LEN],\r\n                amountPerValidator: uint256) :\r\n    \"\"\"\r\n    @notice Deposit up to 64 validators to the offical staking contract with a custom amount per validator\r\n    @dev Max of 64 validators to limit the gas overhead of bigger limits for smaller deposits\r\n    @dev This function is here for future proofing, but at deployment time 32 ETH is the max effective balance for a validator\r\n    @param pulbicKeys The public keys of the validators to deposit\r\n    @param withdrawalCreds The withdrawal credentials of the validators to deposit\r\n    @param signatures The signatures of the validators to deposit\r\n    @param dataRoots The data roots of the validators to deposit\r\n    \"\"\"\r\n    assert len(publicKeys) % PUBLIC_KEY_LEN == 0\r\n    assert len(withdrawalCreds) % WITHDRAWAL_CRED_LEN == 0\r\n    assert len(signatures) % SIGNATURE_LEN == 0\r\n    l : uint256 = len(dataRoots)\r\n    assert l == len(publicKeys) / PUBLIC_KEY_LEN\r\n    assert l == len(withdrawalCreds) / WITHDRAWAL_CRED_LEN\r\n    assert l == len(signatures) / SIGNATURE_LEN\r\n    if amountPerValidator * l != msg.value:\r\n        raise \"Incorrect amount sent\"\r\n    pk : uint256 = 0\r\n    wc : uint256 = 0\r\n    sig : uint256 = 0\r\n    for dataRoot in dataRoots:\r\n        raw_call(\r\n        depositAddress,\r\n        _abi_encode(slice(publicKeys, pk, PUBLIC_KEY_LEN),\r\n                    slice(withdrawalCreds, wc, WITHDRAWAL_CRED_LEN),\r\n                    slice(signatures, sig, SIGNATURE_LEN),\r\n                    dataRoot,\r\n                    method_id=method_id(\"deposit(bytes,bytes,bytes,bytes32)\")),\r\n        value= amountPerValidator,\r\n        revert_on_failure=True)\r\n        pk += PUBLIC_KEY_LEN\r\n        wc += WITHDRAWAL_CRED_LEN\r\n        sig += SIGNATURE_LEN\r\n\r\n@payable\r\n@external\r\ndef bigBatchDeposit(publicKeys: Bytes[BIG_MAX_LEN*PUBLIC_KEY_LEN],\r\n                withdrawalCreds: Bytes[BIG_MAX_LEN*WITHDRAWAL_CRED_LEN],\r\n                signatures: Bytes[BIG_MAX_LEN*SIGNATURE_LEN],\r\n                dataRoots: DynArray[bytes32, BIG_MAX_LEN]) :\r\n    \"\"\"\r\n    @notice Deposit up to 512 validators to the offical staking contract\r\n    @notice This function should only be used for large deposits (>64 validators)\r\n    @param pulbicKeys The public keys of the validators to deposit\r\n    @param withdrawalCreds The withdrawal credentials of the validators to deposit\r\n    @param signatures The signatures of the validators to deposit\r\n    @param dataRoots The data roots of the validators to deposit\r\n    \"\"\"\r\n    assert len(publicKeys) % PUBLIC_KEY_LEN == 0\r\n    assert len(withdrawalCreds) % WITHDRAWAL_CRED_LEN == 0\r\n    assert len(signatures) % SIGNATURE_LEN == 0\r\n    l : uint256 = len(dataRoots)\r\n    assert l == len(publicKeys) / PUBLIC_KEY_LEN\r\n    assert l == len(withdrawalCreds) / WITHDRAWAL_CRED_LEN\r\n    assert l == len(signatures) / SIGNATURE_LEN\r\n    pk : uint256 = 0\r\n    wc : uint256 = 0\r\n    sig : uint256 = 0\r\n    for dataRoot in dataRoots:\r\n        raw_call(\r\n        depositAddress,\r\n        _abi_encode(slice(publicKeys, pk, PUBLIC_KEY_LEN),\r\n                    slice(withdrawalCreds, wc, WITHDRAWAL_CRED_LEN),\r\n                    slice(signatures, sig, SIGNATURE_LEN),\r\n                    dataRoot,\r\n                    method_id=method_id(\"deposit(bytes,bytes,bytes,bytes32)\")),\r\n                    value= as_wei_value(32, \"ether\"),\r\n                    revert_on_failure=True)\r\n        pk += PUBLIC_KEY_LEN\r\n        wc += WITHDRAWAL_CRED_LEN\r\n        sig += SIGNATURE_LEN\r\n\r\n@payable\r\n@external\r\ndef bigBatchDepositCustom(publicKeys: Bytes[BIG_MAX_LEN*PUBLIC_KEY_LEN],\r\n                withdrawalCreds: Bytes[BIG_MAX_LEN*WITHDRAWAL_CRED_LEN],\r\n                signatures: Bytes[BIG_MAX_LEN*SIGNATURE_LEN],\r\n                dataRoots: DynArray[bytes32, BIG_MAX_LEN],\r\n                amountPerValidator: uint256) :\r\n    \"\"\"\r\n    @notice Deposit up to 512 validators to the offical staking contract\r\n    @notice This function should only be used for large deposits (>64 validators)\r\n    @dev This function is here for future proofing, but at deployment time 32 ETH is the max effective balance for a validator\r\n    @param pulbicKeys The public keys of the validators to deposit\r\n    @param withdrawalCreds The withdrawal credentials of the validators to deposit\r\n    @param signatures The signatures of the validators to deposit\r\n    @param dataRoots The data roots of the validators to deposit\r\n    \"\"\"\r\n    assert len(publicKeys) % PUBLIC_KEY_LEN == 0\r\n    assert len(withdrawalCreds) % WITHDRAWAL_CRED_LEN == 0\r\n    assert len(signatures) % SIGNATURE_LEN == 0\r\n    l : uint256 = len(dataRoots)\r\n    assert l == len(publicKeys) / PUBLIC_KEY_LEN\r\n    assert l == len(withdrawalCreds) / WITHDRAWAL_CRED_LEN\r\n    assert l == len(signatures) / SIGNATURE_LEN\r\n    if amountPerValidator * l != msg.value:\r\n        raise \"Incorrect amount sent\"\r\n    pk : uint256 = 0\r\n    wc : uint256 = 0\r\n    sig : uint256 = 0\r\n    for dataRoot in dataRoots:\r\n        raw_call(\r\n        depositAddress,\r\n        _abi_encode(slice(publicKeys, pk, PUBLIC_KEY_LEN),\r\n                    slice(withdrawalCreds, wc, WITHDRAWAL_CRED_LEN),\r\n                    slice(signatures, sig, SIGNATURE_LEN),\r\n                    dataRoot,\r\n                    method_id=method_id(\"deposit(bytes,bytes,bytes,bytes32)\")),\r\n                    value= amountPerValidator,\r\n                    revert_on_failure=True)\r\n        pk += PUBLIC_KEY_LEN\r\n        wc += WITHDRAWAL_CRED_LEN\r\n        sig += SIGNATURE_LEN", "ABI": "[{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"depositAdd\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"batchDeposit\",\"inputs\":[{\"name\":\"publicKeys\",\"type\":\"bytes\"},{\"name\":\"withdrawalCreds\",\"type\":\"bytes\"},{\"name\":\"signatures\",\"type\":\"bytes\"},{\"name\":\"dataRoots\",\"type\":\"bytes32[]\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"batchDepositCustom\",\"inputs\":[{\"name\":\"publicKeys\",\"type\":\"bytes\"},{\"name\":\"withdrawalCreds\",\"type\":\"bytes\"},{\"name\":\"signatures\",\"type\":\"bytes\"},{\"name\":\"dataRoots\",\"type\":\"bytes32[]\"},{\"name\":\"amountPerValidator\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"bigBatchDeposit\",\"inputs\":[{\"name\":\"publicKeys\",\"type\":\"bytes\"},{\"name\":\"withdrawalCreds\",\"type\":\"bytes\"},{\"name\":\"signatures\",\"type\":\"bytes\"},{\"name\":\"dataRoots\",\"type\":\"bytes32[]\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"bigBatchDepositCustom\",\"inputs\":[{\"name\":\"publicKeys\",\"type\":\"bytes\"},{\"name\":\"withdrawalCreds\",\"type\":\"bytes\"},{\"name\":\"signatures\",\"type\":\"bytes\"},{\"name\":\"dataRoots\",\"type\":\"bytes32[]\"},{\"name\":\"amountPerValidator\",\"type\":\"uint256\"}],\"outputs\":[]}]", "ContractName": "Batch deposit contract", "CompilerVersion": "vyper:0.3.9", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "00000000000000000000000000000000219ab540356cbb839cbe05303d7705fa", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}