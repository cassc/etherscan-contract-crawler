{"SourceCode": "# @version 0.3.7\r\n\"\"\"\r\n@title YFI Reward Pool\r\n@author Curve Finance, Yearn Finance\r\n@license MIT\r\n\"\"\"\r\nfrom vyper.interfaces import ERC20\r\n\r\ninterface VotingYFI:\r\n    def epoch(add: address) -> uint256: view\r\n    def point_history(addr: address, loc: uint256) -> Point: view\r\n    def checkpoint(): nonpayable\r\n    def token() -> ERC20: view\r\n    def modify_lock(amount: uint256, unlock_time: uint256, user: address) -> LockedBalance: nonpayable\r\n    def balanceOf(addr: address, epoch: uint256) -> uint256: view\r\n    def find_epoch_by_timestamp(user: address, ts: uint256) -> uint256: view \r\n\r\nevent Initialized:\r\n    veyfi: VotingYFI\r\n    start_time: uint256\r\n\r\nevent CheckpointToken:\r\n    time: uint256\r\n    tokens: uint256\r\n\r\nevent Claimed:\r\n    recipient: indexed(address)\r\n    amount: uint256\r\n    week_cursor: uint256\r\n    max_epoch: uint256\r\n\r\nevent AllowedToRelock:\r\n    user: indexed(address)\r\n    relocker: indexed(address)\r\n    allowed: bool\r\n\r\nevent RewardReceived:\r\n    sender: indexed(address)\r\n    amount: uint256\r\n\r\nstruct Point:\r\n    bias: int128\r\n    slope: int128  # - dweight / dt\r\n    ts: uint256\r\n    blk: uint256  # block\r\n\r\nstruct LockedBalance:\r\n    amount: uint256\r\n    end: uint256\r\n\r\n\r\nWEEK: constant(uint256) = 7 * 86400\r\nTOKEN_CHECKPOINT_DEADLINE: constant(uint256) = 86400\r\n\r\nYFI: immutable(ERC20)\r\nVEYFI: immutable(VotingYFI)\r\n\r\nstart_time: public(uint256)\r\ntime_cursor: public(uint256)\r\ntime_cursor_of: public(HashMap[address, uint256])\r\nallowed_to_relock: public(HashMap[address, HashMap[address, bool]])  # user -> relocker -> allowed\r\n\r\nlast_token_time: public(uint256)\r\ntokens_per_week: public(HashMap[uint256, uint256])\r\n\r\ntoken_last_balance: public(uint256)\r\nve_supply: public(HashMap[uint256, uint256])\r\n\r\n\r\n@external\r\ndef __init__(veyfi: VotingYFI, start_time: uint256):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param veyfi VotingYFI contract address\r\n    @param start_time Epoch time for fee distribution to start\r\n    \"\"\"\r\n    t: uint256 = start_time / WEEK * WEEK\r\n    self.start_time = t\r\n    self.last_token_time = t\r\n    self.time_cursor = t\r\n    VEYFI = veyfi\r\n    YFI = VEYFI.token()\r\n\r\n    log Initialized(veyfi, start_time)\r\n\r\n\r\n@internal\r\ndef _checkpoint_token():\r\n    token_balance: uint256 = YFI.balanceOf(self)\r\n    to_distribute: uint256 = token_balance - self.token_last_balance\r\n    # @dev gas optimization\r\n    if to_distribute == 0:\r\n        self.last_token_time = block.timestamp\r\n        log CheckpointToken(block.timestamp, 0)\r\n        return\r\n    \r\n    self.token_last_balance = token_balance\r\n    t: uint256 = self.last_token_time\r\n    since_last: uint256 = block.timestamp - t\r\n    self.last_token_time = block.timestamp\r\n    this_week: uint256 = t / WEEK * WEEK\r\n    next_week: uint256 = 0\r\n\r\n    for i in range(40):\r\n        next_week = this_week + WEEK\r\n        if block.timestamp < next_week:\r\n            if since_last == 0 and block.timestamp == t:\r\n                self.tokens_per_week[this_week] += to_distribute\r\n            else:\r\n                self.tokens_per_week[this_week] += to_distribute * (block.timestamp - t) / since_last\r\n            break\r\n        else:\r\n            if since_last == 0 and next_week == t:\r\n                self.tokens_per_week[this_week] += to_distribute\r\n            else:\r\n                self.tokens_per_week[this_week] += to_distribute * (next_week - t) / since_last\r\n        t = next_week\r\n        this_week = next_week\r\n\r\n    log CheckpointToken(block.timestamp, to_distribute)\r\n\r\n\r\n@external\r\ndef checkpoint_token():\r\n    \"\"\"\r\n    @notice Update the token checkpoint\r\n    @dev Calculates the total number of tokens to be distributed in a given week.\r\n    \"\"\"\r\n    assert block.timestamp > self.last_token_time + TOKEN_CHECKPOINT_DEADLINE\r\n    self._checkpoint_token()\r\n\r\n@internal\r\ndef _checkpoint_total_supply():\r\n    t: uint256 = self.time_cursor\r\n    rounded_timestamp: uint256 = block.timestamp / WEEK * WEEK\r\n    VEYFI.checkpoint()\r\n\r\n    for i in range(40):\r\n        if t > rounded_timestamp:\r\n            break\r\n        else:\r\n            epoch: uint256 = VEYFI.find_epoch_by_timestamp(VEYFI.address, t)\r\n            pt: Point = VEYFI.point_history(VEYFI.address, epoch)\r\n            dt: int128 = 0\r\n            if t > pt.ts:\r\n                # If the point is at 0 epoch, it can actually be earlier than the first deposit\r\n                # Then make dt 0\r\n                dt = convert(t - pt.ts, int128)\r\n            self.ve_supply[t] = convert(max(pt.bias - pt.slope * dt, 0), uint256)\r\n        t += WEEK\r\n\r\n    self.time_cursor = t\r\n\r\n\r\n@external\r\ndef checkpoint_total_supply():\r\n    \"\"\"\r\n    @notice Update the veYFI total supply checkpoint\r\n    @dev The checkpoint is also updated by the first claimant each\r\n         new epoch week. This function may be called independently\r\n         of a claim, to reduce claiming gas costs.\r\n    \"\"\"\r\n    self._checkpoint_total_supply()\r\n\r\n\r\n@internal\r\ndef _claim(addr: address, last_token_time: uint256) -> uint256:\r\n    to_distribute: uint256 = 0\r\n\r\n    max_user_epoch: uint256 = VEYFI.epoch(addr)\r\n    _start_time: uint256 = self.start_time\r\n\r\n    if max_user_epoch == 0:\r\n        # No lock = no fees\r\n        return 0\r\n\r\n    week_cursor: uint256 = self.time_cursor_of[addr]\r\n\r\n    if week_cursor == 0:\r\n        user_point: Point = VEYFI.point_history(addr, 1)\r\n        week_cursor = (user_point.ts + WEEK - 1) / WEEK * WEEK\r\n\r\n    if week_cursor >= last_token_time:\r\n        return 0\r\n\r\n    if week_cursor < _start_time:\r\n        week_cursor = _start_time\r\n\r\n    # Iterate over weeks\r\n    for i in range(50):\r\n        if week_cursor >= last_token_time:\r\n            break\r\n        balance_of: uint256 = VEYFI.balanceOf(addr, week_cursor)\r\n        if balance_of == 0:\r\n            break\r\n        to_distribute += balance_of * self.tokens_per_week[week_cursor] / self.ve_supply[week_cursor]\r\n        week_cursor += WEEK\r\n\r\n    self.time_cursor_of[addr] = week_cursor\r\n\r\n    log Claimed(addr, to_distribute, week_cursor, max_user_epoch)\r\n\r\n    return to_distribute\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef claim(user: address = msg.sender, relock: bool = False) -> uint256:\r\n    \"\"\"\r\n    @notice Claim fees for a user\r\n    @dev \r\n        Each call to claim looks at a maximum of 50 user veYFI points.\r\n        For accounts with many veYFI related actions, this function\r\n        may need to be called more than once to claim all available\r\n        fees. In the `Claimed` event that fires, if `claim_epoch` is\r\n        less than `max_epoch`, the account may claim again.\r\n    @param user account to claim the fees for\r\n    @param relock whether to increase the lock from the claimed fees\r\n    @return uint256 amount of the claimed fees\r\n    \"\"\"\r\n    if block.timestamp >= self.time_cursor:\r\n        self._checkpoint_total_supply()\r\n\r\n    last_token_time: uint256 = self.last_token_time\r\n\r\n    if block.timestamp > last_token_time + TOKEN_CHECKPOINT_DEADLINE:\r\n        self._checkpoint_token()\r\n        last_token_time = block.timestamp\r\n\r\n    last_token_time = last_token_time / WEEK * WEEK\r\n\r\n    amount: uint256 = self._claim(user, last_token_time)\r\n    if amount != 0:\r\n        # you can only relock for yourself\r\n        if relock and (msg.sender == user or self.allowed_to_relock[user][msg.sender]):\r\n            YFI.approve(VEYFI.address, amount)\r\n            VEYFI.modify_lock(amount, 0, user)\r\n        else:\r\n            assert YFI.transfer(user, amount)\r\n        self.token_last_balance -= amount\r\n\r\n    return amount\r\n\r\n\r\n@external\r\ndef burn(amount: uint256 = max_value(uint256)) -> bool:\r\n    \"\"\"\r\n    @notice Receive YFI into the contract and trigger a token checkpoint\r\n    @param amount Amount of tokens to pull [default: allowance]\r\n    @return bool success\r\n    \"\"\"\r\n    _amount: uint256 = amount\r\n    if _amount == max_value(uint256):\r\n        _amount = YFI.allowance(msg.sender, self)\r\n    if _amount > 0:\r\n        YFI.transferFrom(msg.sender, self, _amount)\r\n        log RewardReceived(msg.sender, _amount)\r\n        if block.timestamp > self.last_token_time + TOKEN_CHECKPOINT_DEADLINE:\r\n            self._checkpoint_token()\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef toggle_allowed_to_relock(user: address) -> bool:\r\n    \"\"\"\r\n    @notice Control whether a user or a contract can relock rewards on your behalf\r\n    @param user account to delegate the right to relock\r\n    \"\"\"\r\n    old_value: bool = self.allowed_to_relock[msg.sender][user]\r\n    self.allowed_to_relock[msg.sender][user] = not old_value\r\n    log AllowedToRelock(msg.sender, user, not old_value)\r\n    return True\r\n\r\n\r\n@view\r\n@external\r\ndef token() -> ERC20:\r\n    return YFI\r\n\r\n\r\n@view\r\n@external\r\ndef veyfi() -> VotingYFI:\r\n    return VEYFI", "ABI": "[{\"name\":\"Initialized\",\"inputs\":[{\"name\":\"veyfi\",\"type\":\"address\",\"indexed\":false},{\"name\":\"start_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"CheckpointToken\",\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"tokens\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Claimed\",\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"week_cursor\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"max_epoch\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AllowedToRelock\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\",\"indexed\":true},{\"name\":\"relocker\",\"type\":\"address\",\"indexed\":true},{\"name\":\"allowed\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RewardReceived\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"veyfi\",\"type\":\"address\"},{\"name\":\"start_time\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"checkpoint_token\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"checkpoint_total_supply\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"relock\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"burn\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"burn\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"toggle_allowed_to_relock\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"veyfi\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"start_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"time_cursor\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"time_cursor_of\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allowed_to_relock\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_token_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"tokens_per_week\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token_last_balance\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"ve_supply\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.3.7", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "00000000000000000000000090c1f9220d90d3966fbee24045edd73e1d588ad500000000000000000000000000000000000000000000000000000000637c9935", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}