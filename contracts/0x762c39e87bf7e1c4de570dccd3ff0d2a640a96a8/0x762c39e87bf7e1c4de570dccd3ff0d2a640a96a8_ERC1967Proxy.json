{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.16;\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\r\n\r\n/**\r\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\r\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\r\n * be specified by overriding the virtual {_implementation} function.\r\n *\r\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\r\n * different contract through the {_delegate} function.\r\n *\r\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\r\n */\r\nabstract contract Proxy {\r\n    /**\r\n     * @dev Delegates the current call to `implementation`.\r\n     *\r\n     * This function does not return to its internal call site, it will return directly to the external caller.\r\n     */\r\n    function _delegate(address implementation) internal virtual {\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize())\r\n\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\r\n\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize())\r\n\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 {\r\n                revert(0, returndatasize())\r\n            }\r\n            default {\r\n                return(0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\r\n     * and {_fallback} should delegate.\r\n     */\r\n    function _implementation() internal view virtual returns (address);\r\n\r\n    /**\r\n     * @dev Delegates the current call to the address returned by `_implementation()`.\r\n     *\r\n     * This function does not return to its internal call site, it will return directly to the external caller.\r\n     */\r\n    function _fallback() internal virtual {\r\n        _beforeFallback();\r\n        _delegate(_implementation());\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\r\n     * function in the contract matches the call data.\r\n     */\r\n    fallback() external payable virtual {\r\n        _fallback();\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\r\n     * is empty.\r\n     */\r\n    receive() external payable virtual {\r\n        _fallback();\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\r\n     * call, or as part of the Solidity `fallback` or `receive` functions.\r\n     *\r\n     * If overridden should call `super._beforeFallback()`.\r\n     */\r\n    function _beforeFallback() internal virtual {}\r\n}\r\n\r\n/// @title IERC1967Upgrade\r\n/// @author Rohan Kulkarni\r\n/// @notice The external ERC1967Upgrade events and errors\r\ninterface IERC1967Upgrade {\r\n    ///                                                          ///\r\n    ///                            EVENTS                        ///\r\n    ///                                                          ///\r\n\r\n    /// @notice Emitted when the implementation is upgraded\r\n    /// @param impl The address of the implementation\r\n    event Upgraded(address impl);\r\n\r\n    ///                                                          ///\r\n    ///                            ERRORS                        ///\r\n    ///                                                          ///\r\n\r\n    /// @dev Reverts if an implementation is an invalid upgrade\r\n    /// @param impl The address of the invalid implementation\r\n    error INVALID_UPGRADE(address impl);\r\n\r\n    /// @dev Reverts if an implementation upgrade is not stored at the storage slot of the original\r\n    error UNSUPPORTED_UUID();\r\n\r\n    /// @dev Reverts if an implementation does not support ERC1822 proxiableUUID()\r\n    error ONLY_UUPS();\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\r\n\r\n/**\r\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\r\n * proxy whose upgrades are fully controlled by the current implementation.\r\n */\r\ninterface IERC1822Proxiable {\r\n    /**\r\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\r\n     * address.\r\n     *\r\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\r\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\r\n     * function revert if invoked through a proxy.\r\n     */\r\n    function proxiableUUID() external view returns (bytes32);\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\r\n\r\n/**\r\n * @dev Library for reading and writing primitive types to specific storage slots.\r\n *\r\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\r\n * This library helps with reading and writing to such slots without the need for inline assembly.\r\n *\r\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\r\n *\r\n * Example usage to set ERC1967 implementation slot:\r\n * ```\r\n * contract ERC1967 {\r\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n *\r\n *     function _getImplementation() internal view returns (address) {\r\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\r\n *     }\r\n *\r\n *     function _setImplementation(address newImplementation) internal {\r\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\r\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\r\n */\r\nlibrary StorageSlot {\r\n    struct AddressSlot {\r\n        address value;\r\n    }\r\n\r\n    struct BooleanSlot {\r\n        bool value;\r\n    }\r\n\r\n    struct Bytes32Slot {\r\n        bytes32 value;\r\n    }\r\n\r\n    struct Uint256Slot {\r\n        uint256 value;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\r\n     */\r\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\r\n     */\r\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\r\n     */\r\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\r\n     */\r\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n}\r\n\r\n/// @title EIP712\r\n/// @author Rohan Kulkarni\r\n/// @notice Modified from OpenZeppelin Contracts v4.7.3 (utils/Address.sol)\r\n/// - Uses custom errors `INVALID_TARGET()` & `DELEGATE_CALL_FAILED()`\r\n/// - Adds util converting address to bytes32\r\nlibrary Address {\r\n    ///                                                          ///\r\n    ///                            ERRORS                        ///\r\n    ///                                                          ///\r\n\r\n    /// @dev Reverts if the target of a delegatecall is not a contract\r\n    error INVALID_TARGET();\r\n\r\n    /// @dev Reverts if a delegatecall has failed\r\n    error DELEGATE_CALL_FAILED();\r\n\r\n    ///                                                          ///\r\n    ///                           FUNCTIONS                      ///\r\n    ///                                                          ///\r\n\r\n    /// @dev Utility to convert an address to bytes32\r\n    function toBytes32(address _account) internal pure returns (bytes32) {\r\n        return bytes32(uint256(uint160(_account)) << 96);\r\n    }\r\n\r\n    /// @dev If an address is a contract\r\n    function isContract(address _account) internal view returns (bool rv) {\r\n        assembly {\r\n            rv := gt(extcodesize(_account), 0)\r\n        }\r\n    }\r\n\r\n    /// @dev Performs a delegatecall on an address\r\n    function functionDelegateCall(address _target, bytes memory _data) internal returns (bytes memory) {\r\n        if (!isContract(_target)) revert INVALID_TARGET();\r\n\r\n        (bool success, bytes memory returndata) = _target.delegatecall(_data);\r\n\r\n        return verifyCallResult(success, returndata);\r\n    }\r\n\r\n    /// @dev Verifies a delegatecall was successful\r\n    function verifyCallResult(bool _success, bytes memory _returndata) internal pure returns (bytes memory) {\r\n        if (_success) {\r\n            return _returndata;\r\n        } else {\r\n            if (_returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(_returndata)\r\n\r\n                    revert(add(32, _returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert DELEGATE_CALL_FAILED();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// @title ERC1967Upgrade\r\n/// @author Rohan Kulkarni\r\n/// @notice Modified from OpenZeppelin Contracts v4.7.3 (proxy/ERC1967/ERC1967Upgrade.sol)\r\n/// - Uses custom errors declared in IERC1967Upgrade\r\n/// - Removes ERC1967 admin and beacon support\r\nabstract contract ERC1967Upgrade is IERC1967Upgrade {\r\n    ///                                                          ///\r\n    ///                          CONSTANTS                       ///\r\n    ///                                                          ///\r\n\r\n    /// @dev bytes32(uint256(keccak256('eip1967.proxy.rollback')) - 1)\r\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\r\n\r\n    /// @dev bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\r\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n    ///                                                          ///\r\n    ///                          FUNCTIONS                       ///\r\n    ///                                                          ///\r\n\r\n    /// @dev Upgrades to an implementation with security checks for UUPS proxies and an additional function call\r\n    /// @param _newImpl The new implementation address\r\n    /// @param _data The encoded function call\r\n    function _upgradeToAndCallUUPS(\r\n        address _newImpl,\r\n        bytes memory _data,\r\n        bool _forceCall\r\n    ) internal {\r\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\r\n            _setImplementation(_newImpl);\r\n        } else {\r\n            try IERC1822Proxiable(_newImpl).proxiableUUID() returns (bytes32 slot) {\r\n                if (slot != _IMPLEMENTATION_SLOT) revert UNSUPPORTED_UUID();\r\n            } catch {\r\n                revert ONLY_UUPS();\r\n            }\r\n\r\n            _upgradeToAndCall(_newImpl, _data, _forceCall);\r\n        }\r\n    }\r\n\r\n    /// @dev Upgrades to an implementation with an additional function call\r\n    /// @param _newImpl The new implementation address\r\n    /// @param _data The encoded function call\r\n    function _upgradeToAndCall(\r\n        address _newImpl,\r\n        bytes memory _data,\r\n        bool _forceCall\r\n    ) internal {\r\n        _upgradeTo(_newImpl);\r\n\r\n        if (_data.length > 0 || _forceCall) {\r\n            Address.functionDelegateCall(_newImpl, _data);\r\n        }\r\n    }\r\n\r\n    /// @dev Performs an implementation upgrade\r\n    /// @param _newImpl The new implementation address\r\n    function _upgradeTo(address _newImpl) internal {\r\n        _setImplementation(_newImpl);\r\n\r\n        emit Upgraded(_newImpl);\r\n    }\r\n\r\n    /// @dev Stores the address of an implementation\r\n    /// @param _impl The implementation address\r\n    function _setImplementation(address _impl) private {\r\n        if (!Address.isContract(_impl)) revert INVALID_UPGRADE(_impl);\r\n\r\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = _impl;\r\n    }\r\n\r\n    /// @dev The address of the current implementation\r\n    function _getImplementation() internal view returns (address) {\r\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\r\n    }\r\n}\r\n\r\n/// @title ERC1967Proxy\r\n/// @author Rohan Kulkarni\r\n/// @notice Modified from OpenZeppelin Contracts v4.7.3 (proxy/ERC1967/ERC1967Proxy.sol)\r\n/// - Inherits a modern, minimal ERC1967Upgrade\r\ncontract ERC1967Proxy is IERC1967Upgrade, Proxy, ERC1967Upgrade {\r\n    ///                                                          ///\r\n    ///                         CONSTRUCTOR                      ///\r\n    ///                                                          ///\r\n\r\n    /// @dev Initializes the proxy with an implementation contract and encoded function call\r\n    /// @param _logic The implementation address\r\n    /// @param _data The encoded function call\r\n    constructor(address _logic, bytes memory _data) payable {\r\n        _upgradeToAndCall(_logic, _data, false);\r\n    }\r\n\r\n    ///                                                          ///\r\n    ///                          FUNCTIONS                       ///\r\n    ///                                                          ///\r\n\r\n    /// @dev The address of the current implementation\r\n    function _implementation() internal view virtual override returns (address) {\r\n        return ERC1967Upgrade._getImplementation();\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DELEGATE_CALL_FAILED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_TARGET\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"}],\"name\":\"INVALID_UPGRADE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ONLY_UUPS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UNSUPPORTED_UUID\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ERC1967Proxy", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "50000", "ConstructorArguments": "00000000000000000000000026f494af990123154e7cc067da7a311b07d54ae100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0x46ea3fd17deb7b291aea60e67e5cb3a104fea11d", "SwarmSource": "ipfs://dc4d3f0096ef746736792d21828a33955017294e8f127fdabcf6bf06082a5014"}