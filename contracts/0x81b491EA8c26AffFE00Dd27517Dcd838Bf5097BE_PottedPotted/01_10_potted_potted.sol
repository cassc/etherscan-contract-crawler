//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWXK0000KXXK0KKXNWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWX0kkOO00KKKKK0Ok0NWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWNKOOkxkOO0KKKKKOkONWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWKxddO0K00K000OkO0KKK0kxxkKWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWN0l,:okOkkO0K0kkO000OxddxKWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWMNkloooxkkkkO00OkOOkxxddOXWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW0dllxkxxkOkkOOxddlccd0NWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWXkddxKXk0NWWWWKc';dOkddoddddolcclldKWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWKo:::cc;:ccd0kc'..,lxd:;clllcccldooKWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWXKK0d;'....,,......,;;:lO0xdoollclKWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWN0dccc:......;clxKNNWWWNX0kxxkXWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWXx:....oNWWWWWWWWWWWWWWWWWNNNWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWx'...oNWWWWWMWWWNXXXXXXXKKKXNWWMWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWNx,..,xNWWMWWWWWXOO0000KKKKKKK0XWWWWWWWW
//WWWWWWWWWNXXXNWWWNKXNWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWXkl,.;ONWWWWWWMWNKkkkO0000KKK000KNWWWWWWW
//WWWWWWWWWKOOkk0XNkclkNWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWMKl,,:xXWWWWWWWNXKK0kxkO000KKKK00OONWWWWWW
//WWWWWWWWWXOxdxxxkl'':dKWWWWWWWWWWWWWWWWWWWWWWWWWWWMWWWWWWNOl;:dKWWWWWWWWWKOO0K0kxkOO0KKKKK0kOXWWWWWW
//WWWWWWWX0OOxooddl;.'',dNWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWN0o;''oXWWWNNNNNWN0OO00K00OOOO0KKK0kxxkKWWWWW
//WWWWWWWNKkxkdlooc:;'.';oONWWWWN0O0XWWWWWWWWMWWWWWWWWWWKd:,''.,ckOolllllkK0OOOkkO0KKOkO000OxdddONWWWW
//WWWWWWWWW0kkxollcx0d;''',oKWWWN0kxk0NWWWWWWWWWWWWWWWW0d:,''....,,'..'',,,,:lxkkkkO00OkOOkxxddkKWWWWW
//WWWWWWWWWWWWKOkxxKWWk,...,lxOXN0dldxkkOOKWWWWWWWWWWXOl;,'..,c;..............;lxkxxkOOkkOkxdolcxNWWWW
//WWWWWWWWWWWWWWWWWWWWO;.....',ldo:;:;'.',cxKWWWWWNOxo:,'..'ckXKxdol;....,codddxOK0kddddxxddoclxKWWWWW
//WWWWWWWWWWWWWWWWWWWWXOc''..............'',oKNWNOo:;,,'..:xKWWWWWWNKx:'.,lONWWWWWWNKKkollllccdKWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWX00x:,;,,,;,;'....',;lOkl:,''.....'c0WWWWWWWWWXx:,,;lk0XNWWWWWNXKKKOdkXWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWXXXXXXXXXkl:;'..',,'',,.......,l0WWMWWWWWWWWXKkocllxKWWWWWWWWWWWNWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWMWWWWWWWMWWWWWNW0:..''.........:lokNWWWWWWWWWWWWWWWWNNWWWWWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWMK:............'xWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWN0o,..........'xNWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWN0c..........,oXWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWMWWWWWWNkcc;........:KWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWN0o,......:0WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWXl......'lONWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWNNNXOl,........,cldKNWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWMWWWNKKkc;;;,.....','.....';dKNWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWX000kl;;'........',:o;......'';oO00KNWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWXOo::;,,''''''..',;:c:;,,,'.',:;,,,::cxKNWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWW0l:ccc:::clolc;;:lddxddocc:;:lllcccoollxXMWWWWWWWWWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWXOxxxxdddd                    xxddxkkxxONWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWNK0000OOkk   POTTED-POTTED    kkkkkkkkkkk0NWWWWWWWWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWNK00000000     Powered by     kkkkkkkkk0NWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWNK00000000   @tamagogi_dapp   kkkkkk0NWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWNK000OO000                    kkkkkkkxx0NWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWNK00OkkkOO        2022        kkkkkxdlokNWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWMWWWWN0Okxxkkkk                    kxddolc::dXMWWWWWWWWWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWKdc::codxxddxxddooooooooooooooolc::;;;;oXMWWWWWWWWWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWW0c;;;;;:cc::ccc:;;;;;;;;;;;;;;;::;;;;;;oXMWWWWWWWWWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWMMWWWWN0dc:::::::::::::::::::::::::::::::::cxKWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWNKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKXNWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "erc721a/contracts/ERC721A.sol";
import "base64-sol/base64.sol";

import "./potted_types.sol";

interface PPRenderer {
    function drawUnrevealPP(PottedTypes.Gene memory gene) external view returns (string memory);
    function drawRevealPP(PottedTypes.Gene memory gene) external view returns (string memory);
    function drawNoBgPP(PottedTypes.Gene memory gene, uint scale) external view returns (string memory);
    function getPP(PottedTypes.Gene memory gene) external view returns (PottedTypes.MyPotted memory);
}

contract PottedPotted is Ownable, ERC721A, ReentrancyGuard{
    PPRenderer public renderer = PPRenderer(0x795Fe5BA6Be2D37F08Cb96c003D57F6089103CA9);
    
    struct Config {
        uint maxPotted;
        uint publicPrice;
        uint publicMaxMint;
        address petContract;
        bytes32 claimHash;
        bytes32 presaleHash;
        Phase phase;
    }

    Config public config;
    uint private _mintedId = 1;
    uint private _teamReserve = 200;
    uint public currentReserve = 0;
    mapping(address => bool) public claimed;
    mapping(address => bool) public presaleMinted;
    mapping(address => uint) public publicMinted;
    mapping(uint => PottedTypes.Gene) public potteds;
    mapping(uint => bool) public petForReroll;

    constructor() ERC721A("POTTED-POTTED", "POTTED-POTTED") {
        config.maxPotted = 7777;
        config.publicPrice = 0;
        config.publicMaxMint = 1;
        config.petContract = 0x4C534034a06f11ECB638BF71A097c168a052a659;
        config.claimHash = 0x0;
        config.presaleHash = 0x0;
        config.phase = Phase.PAUSED;
    }

    enum Phase {
        PAUSED,
        CLAIM,
        PRESALE,
        PUBLIC,
        REVEAL
    }

    /*******
    * Event
    *******/
    event EReveal(
       uint tokenId
    );

    /*******
    * Modifier
    *******/
    modifier validToken(uint tokenId) {
        require(tokenId >= _startTokenId() && tokenId <= _totalMinted(), "Not valid id");
        _;
    }

    modifier validOwner(uint tokenId) {
        require(ownerOf(tokenId) == msg.sender, "Not token's owner");
        _;
    }

    modifier mintable(uint quantity) {
        require(_totalMinted() + quantity <= config.maxPotted, "No potted left");
        _;
    }

    modifier onlyReveal(uint tokenId) {
        require(potteds[tokenId].revealNum != 0, "Potted not reveal yet");
        _;
    }

    /*******
    * PreSale 1, maxMint is pet balance, free.
    *******/
    function claimPotted(bytes32[] calldata _proof) external {
        uint max = ERC721A(config.petContract).balanceOf(msg.sender);
        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));

        require(!claimed[msg.sender], "Claimed");
        require(config.phase == Phase.CLAIM, "Invalid phase");
        require(MerkleProof.verify(_proof, config.claimHash, leaf), "invalid proof");
        require(_totalMinted() + max <= config.maxPotted, "No potted left");
        
        _mintPotted(max);
        claimed[msg.sender] = true;
    }

    /*******
    * PreSale 2, maxMint = 1, free.
    *******/
    function getPotted(bytes32[] calldata _proof) external mintable(1) payable {
        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));

        require(!presaleMinted[msg.sender], "Minted");
        require(config.phase == Phase.PRESALE, "Invalid phase");
        require(MerkleProof.verify(_proof, config.presaleHash, leaf), "invalid proof");
        
        _mintPotted(1);
        presaleMinted[msg.sender] = true;
    }

    /*******
    * PublicSale
    *******/
    function buyPotted(uint quantity) external mintable(quantity) payable {
        require(publicMinted[msg.sender] + quantity <= config.publicMaxMint, "Exceed max buy");
        require(config.phase == Phase.PUBLIC, "Invalid phase");
        require(quantity * config.publicPrice <= msg.value, "No enough eth.");
        
        publicMinted[msg.sender] += quantity;
        _mintPotted(quantity);
    }

    /*******
    * Reveal by owner
    *******/
    function setPottedReveal(uint tokenId, uint revealNum) external validOwner(tokenId) {
        require(config.phase == Phase.REVEAL, "Not in valid phase");
        require(revealNum >= 1 && revealNum <= 8, "Out of range");
        require(potteds[tokenId].revealNum == 0, "Potted revealed");

        potteds[tokenId] = PottedTypes.Gene(potteds[tokenId].dna, revealNum, potteds[tokenId].isReroll);

        emit EReveal(tokenId);
    }

    /*******
    * Reroll by owner
    *******/
    function rerollPotted(uint tokenId, uint petId) external validToken(tokenId) validOwner(tokenId) {
        address petOwner = ERC721A(config.petContract).ownerOf(petId);
        require(petOwner == msg.sender, "Not pet owner");
        require(petId >= 1 && petId <= 3825, "Not valid Tamagogi Pets id");
        require(!petForReroll[petId], "This pet has been rerolled for potted");

        potteds[tokenId] = PottedTypes.Gene(_getRandom(tokenId), potteds[tokenId].revealNum, true);
    }

    function _mintPotted(uint quantity) private {
        for (uint i = 0; i < quantity; i++) {
            uint tokenId = _mintedId;
            uint seed = _getRandom(tokenId);

            potteds[tokenId] = PottedTypes.Gene(seed, 0, false);
            _mintedId++;
        }

        _safeMint(msg.sender, quantity);
    }

    /*******
    * PreviewPotted with no bg / only Reveal
    *******/
    function previewPottedNoBg(uint tokenId, uint scale) external onlyReveal(tokenId) validOwner(tokenId) view returns (string memory) {
        PottedTypes.Gene memory gene = potteds[tokenId];
        return renderer.drawNoBgPP(gene, scale);
    }

    /*******
    * PreviewPotted / only owner
    *******/
    function previewPotted(uint tokenId, uint revealNum) external validOwner(tokenId) view returns (string memory) {
        require(revealNum >= 1 && revealNum <= 8, "Out of range");
        PottedTypes.Gene memory gene = PottedTypes.Gene(potteds[tokenId].dna, revealNum, false);
        return renderer.drawRevealPP(gene);
    }

    function _getUnreveal(PottedTypes.Gene memory gene, PottedTypes.MyPotted memory myPotted, uint tokenId) private view returns (string memory) {
        string memory json = 
                string(
                    abi.encodePacked(
                        '{"name": "#',Strings.toString(tokenId),' Unreveal POTTED-POTTED",',
                        '"description": "Japanese-style bonsai has its charm, whether the type of pot, the direction of growth of the branches or whether flowering or not, there are multiple set of styles. POTTED-POTTED is The first on-chain generated Potted artwork.",', 
                        '"attributes": [',
                            '{ "trait_type": "background", "value": "',myPotted.bg.traitName,'"},',
                            '{ "trait_type": "potted", "value": "',myPotted.potted.traitName,'"},',
                            '{ "trait_type": "isReveal", "value": "No"}',
                        '],'
                        '"image": "data:image/svg+xml;base64,', Base64.encode(bytes(renderer.drawUnrevealPP(gene))), '"}' 
                        )
                    );

        return Base64.encode(
            bytes(
                string(json)
                )
            );
    }

    function _getReveal(PottedTypes.Gene memory gene, PottedTypes.MyPotted memory myPotted, uint tokenId) private view returns (string memory) {
        string memory json = 
                string(
                    abi.encodePacked(
                        '{"name": "#',Strings.toString(tokenId),' POTTED-POTTED",',
                        '"description": "Japanese-style bonsai has its charm, whether the type of pot, the direction of growth of the branches or whether flowering or not, there are multiple set of styles. POTTED-POTTED is The first on-chain generated Potted artwork.",', 
                        _getRevealAttr(gene, myPotted),
                        '"image": "data:image/svg+xml;base64,', Base64.encode(bytes(renderer.drawRevealPP(gene))), '"}' 
                        )
                    );

        return Base64.encode(
            bytes(
                string(json)
                )
            );
    }

    function _getRevealAttr(PottedTypes.Gene memory gene, PottedTypes.MyPotted memory myPotted) private pure returns (string memory) {
        uint blossomCount = (gene.dna + gene.revealNum - 1) % myPotted.branch.pointX.length;
        string memory json = 
                string(
                    abi.encodePacked(
                        '"attributes": [',
                            '{ "trait_type": "background", "value": "',myPotted.bg.traitName,'"},',
                            '{ "trait_type": "potted", "value": "',myPotted.potted.traitName,'"},',
                            '{ "trait_type": "branch", "value": "',myPotted.branch.traitName,'"},',
                            '{ "trait_type": "blossom", "value": "',myPotted.blossom.traitName,'"},',
                            '{ "trait_type": "blossom amount", "display_type": "number", "value": ',Strings.toString(blossomCount),'}',
                        '],'
                        )
                    );

        return json;
    }

    function _tokenURI(uint256 tokenId) private view  returns (string memory) {
        PottedTypes.Gene memory gene = potteds[tokenId];
        string memory json = potteds[tokenId].revealNum == 0 ? _getUnreveal(gene, renderer.getPP(gene), tokenId) : _getReveal(gene, renderer.getPP(gene), tokenId);

        return string(abi.encodePacked('data:application/json;base64,', json));
    }

    function tokenURI(uint256 tokenId) override (ERC721A) public view validToken(tokenId) returns (string memory) {
        return _tokenURI(tokenId);
    }

    function numberMinted(address _addr) public view returns(uint256){
        return _numberMinted(_addr);
    }

    function _startTokenId() override internal pure virtual returns (uint256) {
        return 1;
    }
    
    function _getRandom(uint tokenId) private view returns (uint) {
        uint randomlize = uint(keccak256(abi.encodePacked(blockhash(block.number - 1), tokenId, msg.sender)));
        return randomlize;
    }
    
    /*******
    * ERC721AQueryable.sol
    *******/
    function tokensOfOwner(address owner) public view virtual returns (uint256[] memory) {
        unchecked {
            uint256 tokenIdsIdx;
            address currOwnershipAddr;
            uint256 tokenIdsLength = balanceOf(owner);
            uint256[] memory tokenIds = new uint256[](tokenIdsLength);
            TokenOwnership memory ownership;
            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {
                ownership = _ownershipAt(i);
                if (ownership.burned) {
                    continue;
                }
                if (ownership.addr != address(0)) {
                    currOwnershipAddr = ownership.addr;
                }
                if (currOwnershipAddr == owner) {
                    tokenIds[tokenIdsIdx++] = i;
                }
            }
            return tokenIds;
        }
    }

    /*******
    * Admin function
    *******/
    function setPublicPrice(uint data) external onlyOwner {
        config.publicPrice = data;
    }
    function setPublicMaxMint(uint data) external onlyOwner {
        config.publicMaxMint = data;
    }
    function setClaimHash(bytes32 data) external onlyOwner {
        config.claimHash = data;
    }
    function setPresaleHash(bytes32 data) external onlyOwner {
        config.presaleHash = data;
    }
    function setPhase(Phase phase) external onlyOwner {
        config.phase = phase;
    }
    function setRenderContract(address _address) external onlyOwner {
        renderer = PPRenderer(_address);
    }
    function teamReserve(uint quantity) external mintable(quantity) onlyOwner {
        require(currentReserve + quantity <= _teamReserve, "Exceed max reserve");
        currentReserve += quantity;
        _mintPotted(quantity);
    }
    function withdraw() external onlyOwner nonReentrant {
        (bool success, ) = msg.sender.call{value: address(this).balance}("");
        require(success, ".");
    }
}