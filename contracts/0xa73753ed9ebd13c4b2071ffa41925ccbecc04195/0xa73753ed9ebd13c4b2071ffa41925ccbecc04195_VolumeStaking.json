{"SourceCode": "/**\r\n* Contract for LP staking for the Hibiki.finance token on the Ethereum network.\r\n* Rewards are accrued from received tokens.\r\n* The LP token for WETH-HIBIKI is: 0xF0aD9B5F6B8Ccd60806372Aa65f02cF7F02c69Cf\r\n* The Hibiki token is: 0xA693032e8cfDB8115c6E72B60Ae77a1A592fe4bD\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.16;\r\n\r\nabstract contract Auth {\r\n\taddress private owner;\r\n\tmapping (address => bool) private authorizations;\r\n\r\n\tconstructor(address _owner) {\r\n\t\towner = _owner;\r\n\t\tauthorizations[_owner] = true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Function modifier to require caller to be contract owner\r\n\t*/\r\n\tmodifier onlyOwner() {\r\n\t\trequire(isOwner(msg.sender), \"!OWNER\"); _;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Function modifier to require caller to be authorized\r\n\t*/\r\n\tmodifier authorized() {\r\n\t\trequire(isAuthorized(msg.sender), \"!AUTHORIZED\"); _;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Authorize address. Owner only\r\n\t*/\r\n\tfunction authorize(address adr) public onlyOwner {\r\n\t\tauthorizations[adr] = true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Remove address' authorization. Owner only\r\n\t*/\r\n\tfunction unauthorize(address adr) public onlyOwner {\r\n\t\tauthorizations[adr] = false;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Check if address is owner\r\n\t*/\r\n\tfunction isOwner(address account) public view returns (bool) {\r\n\t\treturn account == owner;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Return address' authorization status\r\n\t*/\r\n\tfunction isAuthorized(address adr) public view returns (bool) {\r\n\t\treturn authorizations[adr];\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Transfer ownership to new address. Caller must be owner. Leaves old owner authorized\r\n\t*/\r\n\tfunction transferOwnership(address payable adr) public onlyOwner {\r\n\t\towner = adr;\r\n\t\tauthorizations[adr] = true;\r\n\t\temit OwnershipTransferred(adr);\r\n\t}\r\n\r\n\tevent OwnershipTransferred(address owner);\r\n}\r\n\r\ninterface IERC20 {\r\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\r\n\tfunction balanceOf(address account) external view returns (uint256);\r\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface Flow {\r\n\tfunction process() external;\r\n}\r\n\r\ncontract VolumeStaking is Auth {\r\n\r\n\tstruct Stake {\r\n\t\tuint256 amount;\r\n\t\tuint256 totalExcluded;\r\n\t\tuint256 totalRealised;\r\n\t}\r\n\r\n\taddress public immutable stakingToken;\r\n\taddress public rewardToken;\r\n\taddress public hibikiFlow;\r\n\tuint256 public totalRealised;\r\n\tuint256 public totalStaked;\r\n\r\n\tmapping (address => Stake) public stakes;\r\n\r\n\t/**\r\n\t* @dev Make lower if the token has very high digits.\r\n\t*/\r\n\tuint256 private constant _accuracyFactor = 10 ** 36;\r\n\tuint256 private _rewardsPerToken;\r\n\tuint256 private _lastContractBalance;\r\n\r\n\tevent Realised(address account, uint256 amount);\r\n\tevent Staked(address account, uint256 amount);\r\n\tevent Unstaked(address account, uint256 amount);\r\n\r\n\terror ZeroAmount();\r\n\terror InsufficientStake(uint256 attempted, uint256 available);\r\n\terror StakingTokenRescue();\r\n\r\n\tconstructor (address _stakingToken, address _rewardToken, address flow) Auth(msg.sender) {\r\n\t\tstakingToken = _stakingToken;\r\n\t\trewardToken = _rewardToken;\r\n\t\thibikiFlow = flow;\r\n\t}\r\n\r\n\tfunction getTotalRewards() external view returns (uint256) {\r\n\t\treturn totalRealised + IERC20(rewardToken).balanceOf(address(this));\r\n\t}\r\n\r\n\tfunction getCumulativeRewardsPerLP() external view returns (uint256) {\r\n\t\treturn _rewardsPerToken;\r\n\t}\r\n\r\n\tfunction getLastContractBalance() external view returns (uint256) {\r\n\t\treturn _lastContractBalance;\r\n\t}\r\n\r\n\tfunction getStake(address account) external view returns (Stake memory) {\r\n\t\treturn stakes[account];\r\n\t}\r\n\r\n\tfunction getStakedAmount(address account) public view returns (uint256) {\r\n\t\treturn stakes[account].amount;\r\n\t}\r\n\r\n\tfunction getRealisedEarnings(address staker) external view returns (uint256) {\r\n\t\treturn stakes[staker].totalRealised;\r\n\t}\r\n\r\n\tfunction getUnrealisedEarnings(address staker) external view returns (uint256) {\r\n\t\tuint256 amount = getStakedAmount(staker);\r\n\t\tif (amount == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 stakerTotalRewards = amount * _getCurrentRewardsPerToken() / _accuracyFactor;\r\n\t\tuint256 stakerTotalExcluded = stakes[staker].totalExcluded;\r\n\r\n\t\tif (stakerTotalRewards <= stakerTotalExcluded) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\treturn stakerTotalRewards - stakerTotalExcluded;\r\n\t}\r\n\r\n\tfunction getCumulativeRewards(uint256 amount) public view returns (uint256) {\r\n\t\treturn amount * _rewardsPerToken / _accuracyFactor;\r\n\t}\r\n\r\n\tfunction stake(uint256 amount) external {\r\n\t\tif (amount == 0) {\r\n\t\t\trevert ZeroAmount();\r\n\t\t}\r\n\t\tIERC20(stakingToken).transferFrom(msg.sender, address(this), amount);\r\n\t\t_stake(msg.sender, amount);\r\n\t}\r\n\r\n\tfunction stakeFor(address staker, uint256 amount) external {\r\n\t\tif (amount == 0) {\r\n\t\t\trevert ZeroAmount();\r\n\t\t}\r\n\r\n\t\tIERC20(stakingToken).transferFrom(msg.sender, address(this), amount);\r\n\t\t_stake(staker, amount);\r\n\t}\r\n\r\n\tfunction stakeAll() external {\r\n\t\tuint256 amount = IERC20(stakingToken).balanceOf(msg.sender);\r\n\t\tif (amount == 0) {\r\n\t\t\trevert ZeroAmount();\r\n\t\t}\r\n\r\n\t\tIERC20(stakingToken).transferFrom(msg.sender, address(this), amount);\r\n\t\t_stake(msg.sender, amount);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Checks for HibikiFlow contract and processes it on unstakes and claims.\r\n\t* HibikiFlow buys and sends tokens to this contract when it has enough ether.\r\n\t*/\r\n\tfunction _checkFlow() private {\r\n\t\tif (hibikiFlow != address(0) && hibikiFlow.balance > 0) {\r\n\t\t\ttry Flow(hibikiFlow).process() {} catch {}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction unstake(uint256 amount) external {\r\n\t\tif (amount == 0) {\r\n\t\t\trevert ZeroAmount();\r\n\t\t}\r\n\t\t_checkFlow();\r\n\r\n\t\t_unstake(msg.sender, amount);\r\n\t}\r\n\r\n\tfunction forceUnstake(address account, uint256 amount) external authorized {\r\n\t\tif (amount == 0) {\r\n\t\t\trevert ZeroAmount();\r\n\t\t}\r\n\t\t_unstake(account, amount);\r\n\t}\r\n\r\n\tfunction unstakeAll() external {\r\n\t\tuint256 amount = getStakedAmount(msg.sender);\r\n\t\tif (amount == 0) {\r\n\t\t\trevert ZeroAmount();\r\n\t\t}\r\n\t\t_checkFlow();\r\n\r\n\t\t_unstake(msg.sender, amount);\r\n\t}\r\n\r\n\tfunction realise() external {\r\n\t\t_checkFlow();\r\n\t\t_realise(msg.sender);\r\n\t}\r\n\r\n\tfunction _realise(address staker) private {\r\n\t\t// Update rewards with received tokens.\r\n\t\t// It's important this is done before checks so new stakes do not dillute old stakes.\r\n\t\t_updateRewards();\r\n\r\n\t\t// Check first if there's a stake.\r\n\t\tif (getStakedAmount(staker) == 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Calculate accrued unclaimed reward.\r\n\t\tuint256 amount = earnt(staker);\r\n\t\tif (amount == 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tunchecked {\r\n\t\t\tstakes[staker].totalRealised += amount;\r\n\t\t\tstakes[staker].totalExcluded += amount;\r\n\t\t\ttotalRealised += amount;\r\n\t\t}\r\n\t\tIERC20(rewardToken).transfer(staker, amount);\r\n\t\t_updateRewards();\r\n\r\n\t\temit Realised(staker, amount);\r\n\t}\r\n\r\n\tfunction earnt(address staker) private view returns (uint256) {\r\n\t\tuint256 amount = getStakedAmount(msg.sender);\r\n\t\tif (amount == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 stakerTotalRewards = getCumulativeRewards(amount);\r\n\t\tuint256 stakerTotalExcluded = stakes[staker].totalExcluded;\r\n\t\tif (stakerTotalRewards <= stakerTotalExcluded) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\treturn stakerTotalRewards - stakerTotalExcluded;\r\n\t}\r\n\r\n\tfunction _stake(address staker, uint256 amount) private {\r\n\t\t_realise(staker);\r\n\r\n\t\t// Add to current stake.\r\n\t\t// Note: If the token has humongous decimals or digits do check for overflow.\r\n\t\tunchecked {\r\n\t\t\tstakes[staker].amount += amount;\r\n\t\t\tstakes[staker].totalExcluded = getCumulativeRewards(stakes[staker].amount);\r\n\t\t\ttotalStaked += amount;\r\n\t\t}\r\n\r\n\t\temit Staked(staker, amount);\r\n\t}\r\n\r\n\tfunction _unstake(address staker, uint256 amount) private {\r\n\t\tuint256 stakedAmount = getStakedAmount(staker);\r\n\t\tif (stakedAmount < amount) {\r\n\t\t\trevert InsufficientStake(amount, stakedAmount);\r\n\t\t}\r\n\r\n\t\t// Realise staking gains.\r\n\t\t_realise(staker);\r\n\r\n\t\t// Remove the stake amount.\r\n\t\tunchecked {\r\n\t\t\tstakes[staker].amount -= amount;\r\n\t\t\ttotalStaked -= amount;\r\n\t\t}\r\n\t\tstakes[staker].totalExcluded = getCumulativeRewards(stakes[staker].amount);\r\n\t\tIERC20(stakingToken).transfer(staker, amount);\r\n\r\n\t\temit Unstaked(staker, amount);\r\n\t}\r\n\r\n\tfunction _distribute(uint256 amount) private returns (bool) {\r\n\t\tuint256 totalSt = totalStaked;\r\n\t\tif (totalSt == 0 || amount == 0) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t_rewardsPerToken += amount * _accuracyFactor / totalSt;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction _updateRewards() private {\r\n\t\tuint256 tokenBalance = IERC20(rewardToken).balanceOf(address(this));\r\n\r\n\t\t// Nothing to update if balance did not change.\r\n\t\tif (tokenBalance == _lastContractBalance) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Store rewards accrued with the new balance.\r\n\t\tif (tokenBalance > _lastContractBalance) {\r\n\t\t\tif (!_distribute(tokenBalance - _lastContractBalance)) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t_lastContractBalance = tokenBalance;\r\n\t}\r\n\r\n\tfunction _getCurrentRewardsPerToken() private view returns (uint256) {\r\n\t\tuint256 total = totalStaked;\r\n\t\tif (total == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 tokenBalance = IERC20(rewardToken).balanceOf(address(this));\r\n\t\tif (tokenBalance > _lastContractBalance) {\r\n\t\t\tuint256 newRewards = tokenBalance - _lastContractBalance;\r\n\t\t\tuint256 additionalAmountPerLP = newRewards * _accuracyFactor / total;\r\n\t\t\treturn _rewardsPerToken + additionalAmountPerLP;\r\n\t\t}\r\n\r\n\t\treturn _rewardsPerToken;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Unstakes all at once ignoring token claims.\r\n\t */\r\n\tfunction emergencyUnstakeAll() external {\r\n\t\tuint256 amount = stakes[msg.sender].amount;\r\n\t\tif (amount == 0) {\r\n            revert ZeroAmount();\r\n        }\r\n\t\tIERC20(stakingToken).transfer(msg.sender, amount);\r\n\t\tunchecked {\r\n\t\t\ttotalStaked -= amount;\r\n\t\t}\r\n\t\tstakes[msg.sender].amount = 0;\r\n\t}\r\n\r\n\tfunction setRewardToken(address reward) external authorized {\r\n\t\trewardToken = reward;\r\n\t}\r\n\r\n\tfunction setFlowAddress(address flow) external authorized {\r\n\t\thibikiFlow = flow;\r\n\t}\r\n\r\n\tfunction rescueToken(address token) external authorized {\r\n\t\tif (token == stakingToken) {\r\n\t\t\trevert StakingTokenRescue();\r\n\t\t}\r\n\t\tIERC20 t = IERC20(token);\r\n\t\tt.transfer(msg.sender, t.balanceOf(address(this)));\r\n\t}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"flow\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"attempted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"}],\"name\":\"InsufficientStake\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StakingTokenRescue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAmount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Realised\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyUnstakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"forceUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getCumulativeRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCumulativeRewardsPerLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getRealisedEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getStake\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalExcluded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRealised\",\"type\":\"uint256\"}],\"internalType\":\"struct VolumeStaking.Stake\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getStakedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getUnrealisedEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hibikiFlow\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"realise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"rescueToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"flow\",\"type\":\"address\"}],\"name\":\"setFlowAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"}],\"name\":\"setRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalExcluded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRealised\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRealised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "VolumeStaking", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f0ad9b5f6b8ccd60806372aa65f02cf7f02c69cf000000000000000000000000a693032e8cfdb8115c6e72b60ae77a1a592fe4bd000000000000000000000000cf5bef994507ce385360da775b5c82799f31652a", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ca5ba4b3f8a6d2a0b2a79dca100a81a84c54fff036c72eea85a179f3948090ec"}