/**
 *Submitted for verification at Etherscan.io on 2023-08-03
*/

/**
https://we-are-x-token.com

https://t.me/WE_ARE_X

https://twitter.com/WE_ARE_X_TOKEN


                                              ...',;:cclooodddddddddddoollcc:;,''..                                               
                                      .';cldxO0KXXXXK00OkkxxxddddddddxxxkkO00KKXXXK0Oxdoc:,'..                                    
                                .,cox0KXX0Oxolc:,'....                      ....',:cloxO0XNNX0kdl;..                              
                           .;lxOXX0koc;'..                                              ..';cox0XWN0dc'                           
                       .;oOXX0xl;..                                                             .,lxKWNkc.                        
                    .:xKNKxc'.                                                                      .;dKWXo.                      
                  .c0WXx;.                                                                             .c0WKc.                    
                 ;0WXd'                                                                                  .lXWk.                   
                cXW0;                                                                                      ,OW0,                  
               :XWO'                            .........                     .,'                           .kW0,                 
              'OM0'                            .dKXKOOOO0k;                 .d0k;                            .kWO.                
              oWX:                              .cKXd'..,xKo.             .lK0c.                              '0Wx.               
             '0Wd.                                'xXk'   :0O;          .c0Kl.                                 :XNc               
             lWK,                                   :KKc.  .dKd.       ;OKo.                                   .xMO.              
            .OWd                                     .xXk'   ;00;.   ,kKx'                                      ;XNl              
            :XX:                                       :0Kl.  .dKKd:dKk,                                        .kMk.             
            oW0'                                        .xXO,   ;dOWKc                                           lWX;             
           .kMx.                                          :0Xo.   .oKx'                                          ;XWl             
           '0Mo                                            .xNO;    ;O0c.                                        '0Mx.            
           ;XWl                                            ;OXXXd;.  .oKk'                                       .kMk.            
           :NWc                                          ,xKx'.dXW0;   ,OKl.                                     .xM0'            
           cWNc                                        'dKk,    ;oOXd.  .lKk,                                    .dMK,            
           lWWc                                      .oKO:.       .oXK:   ,kKl.                                   dMK,            
           lWWl                                    .lKKl.           ,ONx.  .lKO,                                  dMK,            
           cWMo                                  .:0Ko.              .oXKc...cKXo.                                dM0'            
           :NMx.                                ;kKx'                  ,kK0OOO0XXx'                               dMO.            
           ;XMk.                                ';.                      ..........                              .dMk.            
           '0M0'                                                                                                 .xMd             
           .kMX;                                                                                                 .xWl             
            oWNc                                                                                                 .kN:             
            ;XWo                  ..'',;;;;,'..                                    ..',;;;;;;,'..                .kX;             
            .kMx.            ,ldk0KXXKKKKKXXXXK0xo:.                          .,ldOKXXXXKKKKXXXXKOxo;.           .OX;             
             oWO.           .dOkol:,'.......',:ld0NXkc.                    .;xKNKkoc;'........';coxOO:           '0N:             
             oWK,                                .'lONXo.                 ;ONKd;.                   .            '0Wd             
            ;KMN:          .,clddxxxxdolc;'.        .:0W0;              .dNXo.        ..;:lodxxxxddoc;.          ,KMK;            
           ,0MMWl       .:kXNKOxdoooodkO0XXKOdc'      .kWK;            .xWK;      .,lx0XXKOkddooodxk0XXOo.       ;KMM0;           
          cKNOKMd      .oWXo,.          ..,cdONNk:.    '0MO.           lNX:     'dKN0xl;..          ..c0W0'      ;XXOKNx'         
        .xN0:.xMx.     .xMO'                  'oKNd.    cNNc          .OMx.    cXNx;.                 .dWX;      ;X0,'kWXl.       
       ;0Nx. .xMk.      ,0WKo,.                 cNX;    ,KMd.         ;XNc    .OMk.                 .:kNXc       :N0, .lXWx.      
      lXNo.  .xMk.       .ckXN0dl;'...      ..;oKWk.    '0Mx.         :XN:    .lNXx:'..      ..',coOXN0o.        cN0,   ;KWO'     
     lNNl    .xMO.          .;ox0XXXK00OOOO0KXXKxc.     ,KMd          ;XWl      ,dOXXK0OOOOO00KXXKkdc'.          lW0'    ,0WO.    
    cXWo    .:KMX;               .';clloooll:;'.        lNNc          .kMk.        .,:clooollc;,..              .xMXo.    ;KWx.   
   '0Mk.  .cONMMWd.                                    '0Mk.           cNNc                                     :XMMWXd'   cNNc   
   oWX;  :0WWMWNWNl                                   .xWK;            .dWK;                                   '0WNWMMWXo. .kWk.  
  .OMk..dNXx0W0:oNXo.                                .xWK:              .xWK;                                 ,0Wk,dWNk0WO' cNK;  
  ,KWl.xWK;cXNc  :KWk,                              .xWK;                .kW0,                              .lXNd. '0Wd,kWK,;KNc  
  ;XXcoWK;.xMk.   'OWXd'                            lNNc                  ,0Mx.                           .c0WXc    oWK,.kMOl0Wl  
  ;KN0XNc ,KWo    '0WNNXx,                         .xM0'                  .xMK,                         .l0NNNXc    ;XWl ,KWXNWc  
  '0MMMx. ;XWl   .OWk,;xXNkc.                   ':lkXMNc                  ,KMW0l;..                  .;dXNOc'oNX:   '0Wo  lNMMX;  
  .dWMX;  '0Md  .dW0,   'oXWXx;.            .:d0NNKkdkNNd,.             .c0W0dxOKX0xl,.           .,o0NNk;.  .xW0'  ;XNc  .OMMO.  
   ;KMO.   oWK; ;XNc     .OWXKNKx:.      .:xXXOo:'.  .oNMN0dl:;,''',;cokXWWO'   .;lkXN0o'      .;d0NXKNN:     ,KWo .kWO.   dMNc   
    oWX:   .xW0cxW0'     cNX:.;dXWXkl,.'oKN0l'    .,okXX0xxOKNNWWWWWNKOkxkXN0d;.    .:kNNx,.'cxKWNk:.'OMx.    .dMOckWK,   'OWx.   
    .xWK;   .oXWNMO.    .xMO.  .kMKOKXKXWKc.    .cONXkc'.   .,kWMMMKc.    .:dKNKo'     ,kWNKXXO0WK,   oWK,     lWWNWO'   .kWO'    
     .xWK;    ,kNMK,    ,KMd   :XNc .oNM0,    .c0N0l.       'xNMMMMW0:.      .:kNXo.    .oNWk' ,0Wd.  :NWl     dMW0c.   .kW0,     
      .dNX:    .OMWd.   :NNc  .xMO.  dWK;    .kWKl.      .;xXNkOWMKkKNOc.       ;OW0;    .xMO.  oWK,  '0Mx.   ;KMX:    .OW0,      
       .oNX:  'kWMMNl.  oWK,  ,KWo  '0Mx.   ,0Wk'    .':d0NKd,.oMMO..cONXkl,.    .oNXc    :NN:  ;XWl  .kMO.  ,0MMMK:  .OW0,       
        .oNXolKWNWMMNx..dMO.  cWX;  ,KWl   .OWk.  'cx0NXOo;.   oMMO.   'lkKNKkl,.  lNX:   ,KWl  .OMx.  dM0'.cKMMMWWNd:OW0,        
         .dWWWKclXWkkNKd0Mx.  dM0'  ,KWc   oWK; ,kNMN0dc,''''',kMM0:''''',:dkXWNOc..xMO.  '0Wl  .xMO.  lWXxONKkXMx:OWWMX:         
          '0MNc '0Md.:ONMMd  .xMO.  ,KNc  '0Mx.cXMMNK000000000KKXXXK000000000KNWMWx.cNNc  ,KWl   dM0,  cWMWKo.cNNc '0MWo          
           oWK;  oWK, .cXMd  .kMO.  ;XNc  ;XWl:KMWMKl'.......................;kWWWWo:KMd  ,KWl   dMK,  :NWx. .OMO. .kM0'          
           :NNc  ,KWd. .OMx. .xM0'  :NN:  :NNodW0ldXNkc.                  .;dKNOcxWOo0Md  '0Md  .xM0'  cNX;  cNNc  ,KMd           
           ,KMo   oWX; .xMk.  lWK,  dMK,  :XNO0Md  'OWWNOxl:;,'.....',:cdkXWMXc. :XXkKMd  .xMO. .kMk.  lW0' .kMO.  ;XWl           
           ,KMx.  '0Mx..xMK,  ;XNc ;KWd   ,KWNWNc  .xM0llxKMWNXKKKKKXWMNOolkWK;  ,KWNNWc   ;XNo.'0Wo  .xM0' :NNc   :NWc           
           ,KMx.   oWKldNMNc  .OMkl0Wk.   .kMMMX;  ;XWl  .dWKc'''''';OM0'  ;KWo  .kMMMK,    cXNddNX;  '0MWOlOM0'   cNWc           
           '0Mx.   :XWWNKXMx.  oWWWXo.     lWMMO.  lWX;  .OMx.       cNX;  .OMk.  oWMMk.     ;0NWMO.  cNNKNWWMx.   cWNc           
           .OMk.   ,KMWx.lNX; :0WXd'       ,KMNl   dMK,  '0Md.       :XN:  .xMO.  ,KMWl       .c0WXo..kMk'cXMMo    oWN:           
           .xM0'   ;XMO. .kW0ONXo'        'xNNo.   oWX;  .xMO.       oWK,  .kMk.   ;KWO;.       .:0N0ONX;  oWMd   .xMK,           
            cNNc   lWN:   ;XMWO'      .;oONMMk.    :XWo   ;KWd.     cXWo   ;XWo     cNMN0d:.      .dNMWo   .OMk.  ,0Mx.           
            .kWO' .xMO.   '0MO.    .:xKNKxdKMx.    .xWK;   ;KWk'  .oXNd.  .kM0'     :NNkd0NXkl,     oWNc    oWK, .dWK;            
             '0Wk..OMk.   :XNc   .dKWMWx. .OMk.     .OWO'   'kWKdlkN0;   .dWX;      cWX: .lXMMNk;   '0Md    lWX;.lNXc             
              'OWOlOMk.   cNK,  :KWkkWNc  .kMO.      ,0Wx.   .dWMMWO'    cNNc       oWK,  '0MOxXNd. .kMx.   oWXoxNX:              
               .oXWNMK;   cNX; cXNo.cWN:   oWX;       cNNc    .OMMX:    'OWd.      .kMO.  .kMx.;KWx..OMx.  .kMWWNO,               
                 ,xXMWk.  ;XWl;KWd. lWX;   ;KWo       '0Md     dMM0'    ;XWc       ;XWl   .xMk. :XNl:KWo  .oNMW0c.                
                   'o0NXx;,kWKKWO.  cWX;   .dW0,      :XWl    .kMMX;    '0Wd      .xW0'   .kMx.  dWXKWXc,o0NNk:.                  
                     .,o0NKXWMMWl   :XN:    '0Wx.    .kMO.    cNMMWk.    lNX:     cNNc    '0Wo   ;KMMMNKNXkc'                     
                        .,dKWMMK,   '0Wo     ;KWd.  .dWK,    cXN0kKWx.   .xW0'   :XWo.    :XNc   .kMMMXkc.                        
                           .c0WXc    dW0'     ;KWx. cNX:    cXNo. ;KWx.   '0Mx..lXWd.    .xM0'   ,KMXd'                           
                             .dNXc   ,0Wd.     :XWOoOMx.   ,0Wd.   :XWl    lWXdkWWx.     :XNl   ,KWO,                             
                               oNK;   cXNl     ,KMWWWMd    oWK,    .xMO.   cNMWWMWl     ;KWx.  .kMO.                              
                               .kWx.   cXNo.   cNXolKWK,   oWK;    .kMk.  .kWNxcOMk.   ;KWx.   cNX;                               
                                cNX;    oWWk, '0Wd. .xNKo. .OWk.   lNN: .:OW0;  :NN: .oXM0'   .OWd.                               
                                '0Wd.  .dWWWXxkWK,   .:ONXkokWWk;'oNM0odKNKo.   .kM0d0WWW0'   cNX;                                
                                 oWX;  :XNd;xXWMK;      ,lkNMMMMWNWMMWW0o;.     .kMMWOcc0Wd. .OMx.                                
                                 .OM0,'OWx.  'oKWO'       .xMKdlddolOMK,       .dWNx;.  cNNc.xWK;                                 
                                  'kWK0WK,     'OWO.       lWX;    .OMk.      .oNXc     .kMXKWXc                                  
                                   .c0WMXo'.    ,0W0c:lodocoKM0;  .xWWxcloolcckNNl    ..c0MMWO,                                   
                                     .:x0NNKOkxxkXMWNXXKKKKXNMMXOkKMMWNNXXXXXNWWN0kxkO0XNXOo;.                                    
                                        .';cllllc:;,'.......':oxxxdoc;'......'',;::cc::;'.                                        
*/

// SPDX-License-Identifier: MIT

pragma solidity 0.8.21;


library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {return a + b;}
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {return a - b;}
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {return a * b;}
    function div(uint256 a, uint256 b) internal pure returns (uint256) {return a / b;}
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {return a % b;}
    
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {uint256 c = a + b; if(c < a) return(false, 0); return(true, c);}}

    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {if(b > a) return(false, 0); return(true, a - b);}}

    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {if (a == 0) return(true, 0); uint256 c = a * b;
        if(c / a != b) return(false, 0); return(true, c);}}

    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {if(b == 0) return(false, 0); return(true, a / b);}}

    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {if(b == 0) return(false, 0); return(true, a % b);}}

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked{require(b <= a, errorMessage); return a - b;}}

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked{require(b > 0, errorMessage); return a / b;}}

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked{require(b > 0, errorMessage); return a % b;}}}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
    function symbol() external view returns (string memory);
    function name() external view returns (string memory);
    function getOwner() external view returns (address);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address _owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);}

abstract contract Ownable {
    address internal owner;
    constructor(address _owner) {owner = _owner;}
    modifier onlyOwner() {require(isOwner(msg.sender), "!OWNER"); _;}
    function isOwner(address account) public view returns (bool) {return account == owner;}
    function transferOwnership(address payable adr) public onlyOwner {owner = adr; emit OwnershipTransferred(adr);}
    event OwnershipTransferred(address owner);
}

interface IFactory{
        function createPair(address tokenA, address tokenB) external returns (address pair);
        function getPair(address tokenA, address tokenB) external view returns (address pair);
}

interface IRouter {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);

    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline) external;
}

contract XmarkstheSpot is IERC20, Ownable {
    using SafeMath for uint256;
    string private constant _name = 'WE ARE X';
    string private constant _symbol = 'Xs';
    uint8 private constant _decimals = 9;
    uint256 private _totalSupply = 10000000 * (10 ** _decimals);
    uint256 private _maxTxAmountPercent = 200; // 10000;
    uint256 private _maxTransferPercent = 200;
    uint256 private _maxWalletPercent = 200;
    mapping (address => uint256) _balances;
    mapping (address => mapping (address => uint256)) private _allowances;
    mapping (address => bool) public isFeeExempt;
    IRouter router;
    address public pair;
    bool private tradingAllowed = false;
    uint256 private liquidityFee = 0;
    uint256 private marketingFee = 1200;
    uint256 private developmentFee = 600;
    uint256 private XFee = 200;
    uint256 private totalFee = 2000;
    uint256 private sellFee = 4000;
    uint256 private transferFee = 0;
    uint256 private denominator = 10000;
    bool private swapEnabled = true;
    uint256 private swapTimes;
    bool private swapping; 
    uint256 public swapThreshold = ( _totalSupply * 100 ) / 10000;
    uint256 private _minTokenAmount = ( _totalSupply * 10 ) / 100000;
    modifier lockTheSwap {swapping = true; _; swapping = false;}

    address internal constant DEAD = 0x000000000000000000000000000000000000dEaD;
    address internal development_receiver = 0xc000d2484098c0D6a8F1fe367B266fD57e2092Ea;
    address internal X_receiver = 0x801090253a4ea489E8D01a4376bd8cA5904a62E5; 
    address internal marketing_receiver = 0x34a7375Bb691ebB505F7Ab4313703F97852e31f5;
    address internal liquidity_receiver = 0xb103E0391324Ed58f1896b10f46A0D702486f321;

    constructor() Ownable(msg.sender) {
        IRouter _router = IRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
        address _pair = IFactory(_router.factory()).createPair(address(this), _router.WETH());
        router = _router;
        pair = _pair;
        isFeeExempt[address(this)] = true;
        isFeeExempt[liquidity_receiver] = true;
        isFeeExempt[marketing_receiver] = true;
        isFeeExempt[X_receiver] = true;
        isFeeExempt[msg.sender] = true;
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    receive() external payable {}
    function name() public pure returns (string memory) {return _name;}
    function symbol() public pure returns (string memory) {return _symbol;}
    function decimals() public pure returns (uint8) {return _decimals;}
    function weareX() external onlyOwner {tradingAllowed = true;}
    function getOwner() external view override returns (address) { return owner; }
    function balanceOf(address account) public view override returns (uint256) {return _balances[account];}
    function transfer(address recipient, uint256 amount) public override returns (bool) {_transfer(msg.sender, recipient, amount);return true;}
    function allowance(address owner, address spender) public view override returns (uint256) {return _allowances[owner][spender];}
    function isCont(address addr) internal view returns (bool) {uint size; assembly { size := extcodesize(addr) } return size > 0; }
    function setisfeeExempt(address _address, bool _enabled) external onlyOwner {isFeeExempt[_address] = _enabled;}
    function approve(address spender, uint256 amount) public override returns (bool) {_approve(msg.sender, spender, amount);return true;}
    function totalSupply() public view override returns (uint256) {return _totalSupply.sub(balanceOf(address(0)));}
    function _maxWalletToken() public view returns (uint256) {return totalSupply() * _maxWalletPercent / denominator;}
    function _maxTxAmount() public view returns (uint256) {return totalSupply() * _maxTxAmountPercent / denominator;}
    function _maxTransferAmount() public view returns (uint256) {return totalSupply() * _maxTransferPercent / denominator;}

    function preTxCheck(address sender, address recipient, uint256 amount) internal view {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");
        require(amount > uint256(0), "Transfer amount must be greater than zero");
        require(amount <= balanceOf(sender),"You are trying to transfer more than your balance");
    }

    function _transfer(address sender, address recipient, uint256 amount) private {
        preTxCheck(sender, recipient, amount);
        checkTradingAllowed(sender, recipient);
        checkMaxWallet(sender, recipient, amount); 
        swapbackCounters(sender, recipient);
        checkTxLimit(sender, recipient, amount); 
        swapBack(sender, recipient, amount);
        _balances[sender] = _balances[sender].sub(amount);
        uint256 amountReceived = shouldTakeFee(sender, recipient) ? takeFee(sender, recipient, amount) : amount;
        _balances[recipient] = _balances[recipient].add(amountReceived);
        emit Transfer(sender, recipient, amountReceived);
    }

    function setXTaxes(uint256 _liquidity, uint256 _marketing, uint256 _development, uint256 _X, uint256 _total, uint256 _sell, uint256 _trans) external onlyOwner {
        liquidityFee = _liquidity;
        marketingFee = _marketing;
        developmentFee = _development;
        XFee = _X;
        totalFee = _total;
        sellFee = _sell;
        transferFee = _trans;
        require(totalFee <= denominator.div(10) && sellFee <= denominator.div(10), "totalFee and sellFee cannot be more than 10%");
    }

    function setXLimits(uint256 _buy, uint256 _trans, uint256 _wallet) external onlyOwner {
        uint256 newTx = (totalSupply() * _buy) / 10000;
        uint256 newTransfer = (totalSupply() * _trans) / 10000;
        uint256 newWallet = (totalSupply() * _wallet) / 10000;
        _maxTxAmountPercent = _buy;
        _maxTransferPercent = _trans;
        _maxWalletPercent = _wallet;
        uint256 limit = totalSupply().mul(5).div(1000);
        require(newTx >= limit && newTransfer >= limit && newWallet >= limit, "Max TXs and Max Wallet cannot be less than .5%");
    }

    function changeReceiverAddresses(address _liquidity_receiver, address _marketing_receiver, address _development_receiver, address _X_receiver) external onlyOwner {
        liquidity_receiver = _liquidity_receiver;
        marketing_receiver = _marketing_receiver;
        development_receiver = _development_receiver;
        X_receiver = _X_receiver;
    }

    function checkTradingAllowed(address sender, address recipient) internal view {
        if(!isFeeExempt[sender] && !isFeeExempt[recipient]){require(tradingAllowed, "tradingAllowed");}
    }
    
    function checkMaxWallet(address sender, address recipient, uint256 amount) internal view {
        if(!isFeeExempt[sender] && !isFeeExempt[recipient] && recipient != address(pair) && recipient != address(DEAD)){
            require((_balances[recipient].add(amount)) <= _maxWalletToken(), "Exceeds maximum wallet amount.");}
    }

    function swapbackCounters(address sender, address recipient) internal {
        if(recipient == pair && !isFeeExempt[sender]){swapTimes += uint256(1);}
    }

    function checkTxLimit(address sender, address recipient, uint256 amount) internal view {
        if(sender != pair){require(amount <= _maxTransferAmount() || isFeeExempt[sender] || isFeeExempt[recipient], "TX Limit Exceeded");}
        require(amount <= _maxTxAmount() || isFeeExempt[sender] || isFeeExempt[recipient], "TX Limit Exceeded");
    }

    function swapAndLiquify(uint256 tokens) private lockTheSwap {
        uint256 _denominator = (liquidityFee.add(1).add(marketingFee).add(developmentFee).add(XFee)).mul(2);
        uint256 tokensToAddLiquidityWith = tokens.mul(liquidityFee).div(_denominator);
        uint256 toSwap = tokens.sub(tokensToAddLiquidityWith);
        uint256 initialBalance = address(this).balance;
        swapTokensForETH(toSwap);
        uint256 deltaBalance = address(this).balance.sub(initialBalance);
        uint256 unitBalance= deltaBalance.div(_denominator.sub(liquidityFee));
        uint256 ETHToAddLiquidityWith = unitBalance.mul(liquidityFee);
        if(ETHToAddLiquidityWith > uint256(0)){addLiquidity(tokensToAddLiquidityWith, ETHToAddLiquidityWith); }
        uint256 marketingAmt = unitBalance.mul(2).mul(marketingFee);
        if(marketingAmt > 0){payable(marketing_receiver).transfer(marketingAmt);}
        uint256 developmentAmt = unitBalance.mul(2).mul(developmentFee);
        if(developmentAmt > 0){payable(development_receiver).transfer(developmentAmt);}
        uint256 remainingBalance = address(this).balance;
        if(remainingBalance > uint256(0)){payable(X_receiver).transfer(remainingBalance);}
    }

    function addLiquidity(uint256 tokenAmount, uint256 ETHAmount) private {
        _approve(address(this), address(router), tokenAmount);
        router.addLiquidityETH{value: ETHAmount}(
            address(this),
            tokenAmount,
            0,
            0,
            liquidity_receiver,
            block.timestamp);
    }

    function swapTokensForETH(uint256 tokenAmount) private {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = router.WETH();
        _approve(address(this), address(router), tokenAmount);
        router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            address(this),
            block.timestamp);
    }

    function shouldSwapBack(address sender, address recipient, uint256 amount) internal view returns (bool) {
        bool aboveMin = amount >= _minTokenAmount;
        bool aboveThreshold = balanceOf(address(this)) >= swapThreshold;
        return !swapping && swapEnabled && tradingAllowed && aboveMin && !isFeeExempt[sender] && recipient == pair && swapTimes >= uint256(1) && aboveThreshold;
    }

    function swapBack(address sender, address recipient, uint256 amount) internal {
        if(shouldSwapBack(sender, recipient, amount)){swapAndLiquify(swapThreshold); swapTimes = uint256(0);}
    }

    function shouldTakeFee(address sender, address recipient) internal view returns (bool) {
        return !isFeeExempt[sender] && !isFeeExempt[recipient];
    }

    function getTotalFee(address sender, address recipient) internal view returns (uint256) {
        if(recipient == pair){return sellFee;}
        if(sender == pair){return totalFee;}
        return transferFee;
    }

    function setXswapbackamount(uint256 _swapThreshold) public onlyOwner {
        swapThreshold = _swapThreshold;
    
    }

    function takeFee(address sender, address recipient, uint256 amount) internal returns (uint256) {
        if(getTotalFee(sender, recipient) > 0){
        uint256 feeAmount = amount.div(denominator).mul(getTotalFee(sender, recipient));
        _balances[address(this)] = _balances[address(this)].add(feeAmount);
        emit Transfer(sender, address(this), feeAmount);
        return amount.sub(feeAmount);} return amount;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

}