{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/Dex.sol\": {\r\n      \"content\": \"// contracts/FlashLoan.sol\\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.10;\\r\\n\\r\\nimport {IERC20} from \\\"@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol\\\";\\r\\n\\r\\ninterface IUniswapV2Router {\\r\\n    function swapExactTokensForTokens(\\r\\n        //amount of tokens we are sending in\\r\\n        uint256 amountIn,\\r\\n        //the minimum amount of tokens we want out of the trade\\r\\n        uint256 amountOutMin,\\r\\n        //list of token addresses we are going to trade in.  this is necessary to calculate amounts\\r\\n        address[] calldata path,\\r\\n        //this is the address we are going to send the output tokens to\\r\\n        address to,\\r\\n        //the last time that the trade is valid for\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n}\\r\\n\\r\\ncontract Dex {\\r\\n    address payable public owner;\\r\\n\\r\\n    // address private constant wethAddress =\\r\\n    //     0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\r\\n    // address private constant daiAddress =\\r\\n    //     0x6B175474E89094C44Da98b954EedeAC495271d0F;\\r\\n    // address private constant usdcAddress =\\r\\n    //     0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\r\\n\\r\\n    // address private constant UNISWAP_ROUTER_ADDRESS =\\r\\n    //     0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\r\\n\\r\\n    IUniswapV2Router public uniswapRouter;\\r\\n    IUniswapV2Router public sushiswapRouter;\\r\\n\\r\\n    IERC20 private dai;\\r\\n    IERC20 private usdc;\\r\\n    IERC20 private weth;\\r\\n\\r\\n    constructor(\\r\\n        address _uRouter,\\r\\n        address _sRouter,\\r\\n        address _dai,\\r\\n        address _usdc,\\r\\n        address _weth\\r\\n    ) {\\r\\n        owner = payable(msg.sender);\\r\\n\\r\\n        uniswapRouter = IUniswapV2Router(_uRouter);\\r\\n        sushiswapRouter = IUniswapV2Router(_sRouter);\\r\\n        dai = IERC20(_dai);\\r\\n        usdc = IERC20(_usdc);\\r\\n        weth = IERC20(_weth);\\r\\n    }\\r\\n\\r\\n    function setFirstRouter(address _router) external {\\r\\n        require(\\r\\n            _router != address(0),\\r\\n            \\\"Router address must not be zero address\\\"\\r\\n        );\\r\\n        uniswapRouter = IUniswapV2Router(_router);\\r\\n    }\\r\\n\\r\\n    function setSecondRouter(address _router) external {\\r\\n        require(\\r\\n            _router != address(0),\\r\\n            \\\"Router address must not be zero address\\\"\\r\\n        );\\r\\n        sushiswapRouter = IUniswapV2Router(_router);\\r\\n    }\\r\\n\\r\\n    function setQuoteToken(address _token) external {\\r\\n        require(_token != address(0), \\\"Token must be balid\\\");\\r\\n        dai = IERC20(_token);\\r\\n    }\\r\\n\\r\\n    function setBaseToken(address _token) external {\\r\\n        require(_token != address(0), \\\"Token must be balid\\\");\\r\\n        usdc = IERC20(_token);\\r\\n    }\\r\\n\\r\\n    // Just buy DAI for USDC and resell it to pay back\\r\\n    // replace this logic to whatever you want\\r\\n    function simpleTrades(uint _amount) external {\\r\\n        // get the loan from flashloan contract\\r\\n        depositUSDC(msg.sender, _amount);\\r\\n        // buy other token\\r\\n        buyDAI(msg.sender);\\r\\n        // get purchased token\\r\\n        depositDAI(msg.sender, dai.balanceOf(msg.sender));\\r\\n        // sell it to pay back loan\\r\\n        sellDAI(msg.sender);\\r\\n    }\\r\\n\\r\\n    function depositUSDC(address _sender, uint256 _amount) public {\\r\\n        uint256 allowance = usdc.allowance(_sender, address(this));\\r\\n        require(allowance >= _amount, \\\"Check the token allowance\\\");\\r\\n        usdc.transferFrom(_sender, address(this), _amount);\\r\\n    }\\r\\n\\r\\n    function depositDAI(address _sender, uint256 _amount) public {\\r\\n        uint256 allowance = dai.allowance(_sender, address(this));\\r\\n        require(allowance >= _amount, \\\"Check the token allowance\\\");\\r\\n        dai.transferFrom(_sender, address(this), _amount);\\r\\n    }\\r\\n\\r\\n    function buyDAI(address _recipient) public {\\r\\n        uint256 usdcBalances = usdc.balanceOf(address(this));\\r\\n\\r\\n        usdc.approve(address(uniswapRouter), usdcBalances);\\r\\n\\r\\n        address[] memory path;\\r\\n        path = new address[](3);\\r\\n        path[0] = address(usdc);\\r\\n        path[1] = address(weth);\\r\\n        path[2] = address(dai);\\r\\n\\r\\n        uniswapRouter.swapExactTokensForTokens(\\r\\n            usdcBalances,\\r\\n            1,\\r\\n            path,\\r\\n            _recipient,\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function sellDAI(address _recipient) public {\\r\\n        uint256 daiBalance = dai.balanceOf(address(this));\\r\\n\\r\\n        dai.approve(address(uniswapRouter), daiBalance);\\r\\n\\r\\n        address[] memory path;\\r\\n        path = new address[](3);\\r\\n        path[0] = address(dai);\\r\\n        path[1] = address(weth);\\r\\n        path[2] = address(usdc);\\r\\n\\r\\n        uniswapRouter.swapExactTokensForTokens(\\r\\n            daiBalance,\\r\\n            1,\\r\\n            path,\\r\\n            _recipient,\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function getBalance(address _tokenAddress) external view returns (uint256) {\\r\\n        return IERC20(_tokenAddress).balanceOf(address(this));\\r\\n    }\\r\\n\\r\\n    function withdraw(address _tokenAddress) external onlyOwner {\\r\\n        IERC20 token = IERC20(_tokenAddress);\\r\\n        token.transfer(msg.sender, token.balanceOf(address(this)));\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(\\r\\n            msg.sender == owner,\\r\\n            \\\"Only the contract owner can call this function\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    fallback() external payable {}\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dai\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"buyDAI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositDAI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositUSDC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"sellDAI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setBaseToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"setFirstRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setQuoteToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"setSecondRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"simpleTrades\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushiswapRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Dex", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000d9e1ce17f2641f24ae83637ab66a2cca9c378b9f0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}