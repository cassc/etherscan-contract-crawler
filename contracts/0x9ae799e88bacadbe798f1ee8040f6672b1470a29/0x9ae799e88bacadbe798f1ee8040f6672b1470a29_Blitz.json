{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Blitz.sol\": {\r\n      \"content\": \"pragma solidity 0.8.22;\\r\\n\\r\\nimport \\\"@ERC721A/ERC721A.sol\\\";\\r\\nimport \\\"@solady/auth/Ownable.sol\\\";\\r\\nimport \\\"@solady/utils/MerkleProofLib.sol\\\";\\r\\nimport \\\"@openzeppelin/utils/cryptography/ECDSA.sol\\\";\\r\\nimport \\\"@openzeppelin/utils/Address.sol\\\";\\r\\nimport {LibString} from \\\"@solady/utils/LibString.sol\\\";\\r\\n\\r\\ninterface BEG {\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n}\\r\\n\\r\\ncontract Blitz is ERC721A, Ownable {\\r\\n    using ECDSA for bytes32;\\r\\n    using Address for address;\\r\\n\\r\\n    address public immutable begToken;\\r\\n    address private signerAddress;\\r\\n\\r\\n    bytes32 public begRoot;\\r\\n    bytes32 public whitelistRoot;\\r\\n\\r\\n    uint256 public constant MAX_SUPPLY = 10000;\\r\\n    uint256 public price = 0.08 ether;\\r\\n\\r\\n    uint256 public whitelistOpen;\\r\\n    uint256 public whitelistClosed;\\r\\n\\r\\n    uint256 public emissionTime;\\r\\n    uint256 public begPerBlitz;\\r\\n\\r\\n    bool public live;\\r\\n\\r\\n    string private _baseURIString;\\r\\n\\r\\n    struct Staker {\\r\\n        uint256 lastClaim;\\r\\n        uint256[] tokenIds;\\r\\n    }\\r\\n\\r\\n    mapping(address => bool) public begClaimed;\\r\\n    mapping(address => Staker) public stakers;\\r\\n    mapping(uint256 => bool) public stakedTokens;\\r\\n    mapping(address => uint256) public nonces;\\r\\n\\r\\n    event Staked(address indexed user, uint256[] tokenIds, uint256 stakeTime);\\r\\n    event Unstaked(address indexed user, uint256[] tokenIds);\\r\\n    event Claimed(address indexed user, uint256 amount);\\r\\n\\r\\n    error MintNotLive();\\r\\n    error WhitelistNotLive();\\r\\n    error PublicMintNotLive();\\r\\n    error BegMintClaimed();\\r\\n    error BegMintUnauthorized();\\r\\n    error WhitelistMintUnauthorized();\\r\\n    error SupplyExceeded();\\r\\n    error InsufficientPayment();\\r\\n    error InvalidWhitelistWindow();\\r\\n    error TokenDoesNotExist();\\r\\n    error NoTokens();\\r\\n    error NotOwner();\\r\\n    error AlreadyStaked();\\r\\n    error InsufficientBeg();\\r\\n    error NotStaked();\\r\\n    error InvalidNonce();\\r\\n    error InvalidSignature();\\r\\n\\r\\n    modifier whitelistMintActive() {\\r\\n        if (block.timestamp < whitelistOpen) revert WhitelistNotLive();\\r\\n        if (block.timestamp > whitelistClosed) revert WhitelistNotLive();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(bytes32 _begRoot, bytes32 _whitelistRoot, address _begToken, address _signerAddress)\\r\\n        ERC721A(\\\"Blitz\\\", \\\"BLITZ\\\")\\r\\n    {\\r\\n        _initializeOwner(msg.sender);\\r\\n        begToken = _begToken;\\r\\n        begRoot = _begRoot;\\r\\n        whitelistRoot = _whitelistRoot;\\r\\n        signerAddress = _signerAddress;\\r\\n        emissionTime = 24 hours;\\r\\n    }\\r\\n\\r\\n    function begMint(bytes32[] calldata proof) external whitelistMintActive {\\r\\n        if (!live) revert MintNotLive();\\r\\n        if (begClaimed[msg.sender]) revert BegMintClaimed();\\r\\n        if (!MerkleProofLib.verify(proof, begRoot, keccak256(abi.encodePacked(msg.sender)))) {\\r\\n            revert BegMintUnauthorized();\\r\\n        }\\r\\n\\r\\n        begClaimed[msg.sender] = true;\\r\\n        _mint(msg.sender, 1);\\r\\n    }\\r\\n\\r\\n    function whitelistMint(bytes32[] calldata proof, uint256 _amount) external payable whitelistMintActive {\\r\\n        if (!live) revert MintNotLive();\\r\\n        if (totalSupply() + _amount > MAX_SUPPLY) revert SupplyExceeded();\\r\\n        if (!MerkleProofLib.verify(proof, whitelistRoot, keccak256(abi.encodePacked(msg.sender)))) {\\r\\n            revert WhitelistMintUnauthorized();\\r\\n        }\\r\\n        if (msg.value != _amount * price) revert InsufficientPayment();\\r\\n\\r\\n        _mint(msg.sender, _amount);\\r\\n    }\\r\\n\\r\\n    function publicMint(uint256 _amount) external payable {\\r\\n        if (!live) revert MintNotLive();\\r\\n        if (block.timestamp < whitelistClosed) revert PublicMintNotLive();\\r\\n        if (totalSupply() + _amount > MAX_SUPPLY) revert SupplyExceeded();\\r\\n        if (msg.value != _amount * price) revert InsufficientPayment();\\r\\n\\r\\n        _mint(msg.sender, _amount);\\r\\n    }\\r\\n\\r\\n    function stake(uint256[] calldata _tokenIds) external {\\r\\n        if (_tokenIds.length == 0) revert NoTokens();\\r\\n\\r\\n        for (uint256 i; i < _tokenIds.length; i++) {\\r\\n            if (!_exists(_tokenIds[i])) revert TokenDoesNotExist();\\r\\n            if (ownerOf(_tokenIds[i]) != msg.sender) revert NotOwner();\\r\\n            if (stakedTokens[_tokenIds[i]]) revert AlreadyStaked();\\r\\n\\r\\n            stakers[msg.sender].tokenIds.push(_tokenIds[i]);\\r\\n            stakedTokens[_tokenIds[i]] = true;\\r\\n        }\\r\\n\\r\\n        stakers[msg.sender].lastClaim = block.timestamp;\\r\\n        emit Staked(msg.sender, _tokenIds, block.timestamp);\\r\\n    }\\r\\n\\r\\n    function claim() public {\\r\\n        uint256 reward = calculateReward(msg.sender);\\r\\n\\r\\n        if (reward == 0) return; // noop\\r\\n        if (reward > BEG(begToken).balanceOf(address(this))) revert InsufficientBeg();\\r\\n\\r\\n        stakers[msg.sender].lastClaim = block.timestamp;\\r\\n        BEG(begToken).transfer(msg.sender, reward);\\r\\n        emit Claimed(msg.sender, reward);\\r\\n    }\\r\\n\\r\\n    function calculateReward(address addr) public view returns (uint256) {\\r\\n        Staker storage staker = stakers[addr];\\r\\n        uint256 timeSinceClaim = block.timestamp - staker.lastClaim;\\r\\n        if (staker.tokenIds.length == 0 || timeSinceClaim < emissionTime) return 0;\\r\\n        return (timeSinceClaim / emissionTime) * begPerBlitz * staker.tokenIds.length;\\r\\n    }\\r\\n\\r\\n    function claimEngagement(uint256 _amount, uint256 _nonce, bytes memory _signature) public {\\r\\n        if (nonces[msg.sender] != _nonce) revert InvalidNonce();\\r\\n        if (!isValidSignature(msg.sender, _amount, _nonce, _signature)) revert InvalidSignature();\\r\\n\\r\\n        unchecked {\\r\\n            nonces[msg.sender]++;\\r\\n        }\\r\\n\\r\\n        BEG(begToken).transfer(msg.sender, _amount);\\r\\n\\r\\n        emit Claimed(msg.sender, _amount);\\r\\n    }\\r\\n\\r\\n    function unstake(uint256[] calldata _tokenIds) external {\\r\\n        if (_tokenIds.length == 0) revert NoTokens();\\r\\n        claim();\\r\\n\\r\\n        Staker storage staker = stakers[msg.sender];\\r\\n\\r\\n        for (uint256 j; j < _tokenIds.length; j++) {\\r\\n            bool found = false;\\r\\n            for (uint256 i; i < staker.tokenIds.length; i++) {\\r\\n                if (staker.tokenIds[i] == _tokenIds[j]) {\\r\\n                    if (!stakedTokens[_tokenIds[j]]) revert NotStaked();\\r\\n\\r\\n                    staker.tokenIds[i] = staker.tokenIds[staker.tokenIds.length - 1];\\r\\n                    staker.tokenIds.pop();\\r\\n                    delete stakedTokens[_tokenIds[j]];\\r\\n\\r\\n                    found = true;\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n            if (!found) revert NotStaked();\\r\\n        }\\r\\n        emit Unstaked(msg.sender, _tokenIds);\\r\\n    }\\r\\n\\r\\n    function setPrice(uint256 _price) external onlyOwner {\\r\\n        price = _price;\\r\\n    }\\r\\n\\r\\n    function setLive() external onlyOwner {\\r\\n        live = !live;\\r\\n    }\\r\\n\\r\\n    function setWhitelistMintWindow(uint256 _whitelistOpen, uint256 _whitelistClosed) external onlyOwner {\\r\\n        if (_whitelistOpen > _whitelistClosed) revert InvalidWhitelistWindow();\\r\\n        if (_whitelistOpen == 0) revert InvalidWhitelistWindow();\\r\\n        if (_whitelistClosed == 0) revert InvalidWhitelistWindow();\\r\\n\\r\\n        whitelistOpen = _whitelistOpen;\\r\\n        whitelistClosed = _whitelistClosed;\\r\\n    }\\r\\n\\r\\n    function setBegRoot(bytes32 _begRoot) external onlyOwner {\\r\\n        begRoot = _begRoot;\\r\\n    }\\r\\n\\r\\n    function setWhitelistRoot(bytes32 _whitelistRoot) external onlyOwner {\\r\\n        whitelistRoot = _whitelistRoot;\\r\\n    }\\r\\n\\r\\n    function setBegPerBlitz(uint256 _begPerBlitz) external onlyOwner {\\r\\n        begPerBlitz = _begPerBlitz;\\r\\n    }\\r\\n\\r\\n    function setTokenURI(string calldata uri) external onlyOwner {\\r\\n        _baseURIString = uri;\\r\\n    }\\r\\n\\r\\n    function setEmissionTime(uint256 _hours) external onlyOwner {\\r\\n        emissionTime = _hours * 1 hours;\\r\\n    }\\r\\n\\r\\n    function setSigner(address _signerAddress) external onlyOwner {\\r\\n        signerAddress = _signerAddress;\\r\\n    }\\r\\n\\r\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\r\\n        if (!_exists(tokenId)) revert TokenDoesNotExist();\\r\\n\\r\\n        string memory baseURI = _baseURIString;\\r\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, LibString.toString(tokenId))) : \\\"\\\";\\r\\n    }\\r\\n\\r\\n    function withdraw() external onlyOwner {\\r\\n        (bool success,) = payable(msg.sender).call{value: address(this).balance}(\\\"\\\");\\r\\n        require(success);\\r\\n    }\\r\\n\\r\\n    function rescueBeg() external onlyOwner {\\r\\n        BEG(begToken).transfer(msg.sender, BEG(begToken).balanceOf(address(this)));\\r\\n    }\\r\\n\\r\\n    function _beforeTokenTransfers(address from, address to, uint256 startTokenId, uint256 quantity)\\r\\n        internal\\r\\n        virtual\\r\\n        override\\r\\n    {\\r\\n        if (stakedTokens[startTokenId]) revert AlreadyStaked();\\r\\n        super._beforeTokenTransfers(from, to, startTokenId, quantity);\\r\\n    }\\r\\n\\r\\n    function getStaker(address stakerAddress) external view returns (Staker memory) {\\r\\n        return stakers[stakerAddress];\\r\\n    }\\r\\n\\r\\n    function getTokenStatuses(uint256[] calldata tokenIds) external view returns (bool[] memory) {\\r\\n        bool[] memory statuses = new bool[](tokenIds.length);\\r\\n        for (uint256 i; i < tokenIds.length; i++) {\\r\\n            statuses[i] = stakedTokens[tokenIds[i]];\\r\\n        }\\r\\n        return statuses;\\r\\n    }\\r\\n\\r\\n    function isValidSignature(address _user, uint256 _amount, uint256 _nonce, bytes memory _signature)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        bytes32 messageHash = keccak256(abi.encodePacked(_user, _amount, _nonce, address(this)));\\r\\n        bytes32 prefixedHash = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", messageHash));\\r\\n        address recoveredSigner = ECDSA.recover(prefixedHash, _signature);\\r\\n\\r\\n        return recoveredSigner == signerAddress;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/ERC721A/contracts/ERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// ERC721A Contracts v4.2.3\\r\\n// Creator: Chiru Labs\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport './IERC721A.sol';\\r\\n\\r\\n/**\\r\\n * @dev Interface of ERC721 token receiver.\\r\\n */\\r\\ninterface ERC721A__IERC721Receiver {\\r\\n    function onERC721Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 tokenId,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title ERC721A\\r\\n *\\r\\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\\r\\n * Non-Fungible Token Standard, including the Metadata extension.\\r\\n * Optimized for lower gas during batch mints.\\r\\n *\\r\\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\\r\\n * starting from `_startTokenId()`.\\r\\n *\\r\\n * Assumptions:\\r\\n *\\r\\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\\r\\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\\r\\n */\\r\\ncontract ERC721A is IERC721A {\\r\\n    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\\r\\n    struct TokenApprovalRef {\\r\\n        address value;\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                           CONSTANTS\\r\\n    // =============================================================\\r\\n\\r\\n    // Mask of an entry in packed address data.\\r\\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\\r\\n\\r\\n    // The bit position of `numberMinted` in packed address data.\\r\\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\\r\\n\\r\\n    // The bit position of `numberBurned` in packed address data.\\r\\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\\r\\n\\r\\n    // The bit position of `aux` in packed address data.\\r\\n    uint256 private constant _BITPOS_AUX = 192;\\r\\n\\r\\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\\r\\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\\r\\n\\r\\n    // The bit position of `startTimestamp` in packed ownership.\\r\\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\\r\\n\\r\\n    // The bit mask of the `burned` bit in packed ownership.\\r\\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\\r\\n\\r\\n    // The bit position of the `nextInitialized` bit in packed ownership.\\r\\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\\r\\n\\r\\n    // The bit mask of the `nextInitialized` bit in packed ownership.\\r\\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\\r\\n\\r\\n    // The bit position of `extraData` in packed ownership.\\r\\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\\r\\n\\r\\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\\r\\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\\r\\n\\r\\n    // The mask of the lower 160 bits for addresses.\\r\\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\\r\\n\\r\\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\\r\\n    // This limit is to prevent overflows on the address data entries.\\r\\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\\r\\n    // is required to cause an overflow, which is unrealistic.\\r\\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\\r\\n\\r\\n    // The `Transfer` event signature is given by:\\r\\n    // `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\r\\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\\r\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\r\\n\\r\\n    // =============================================================\\r\\n    //                            STORAGE\\r\\n    // =============================================================\\r\\n\\r\\n    // The next token ID to be minted.\\r\\n    uint256 private _currentIndex;\\r\\n\\r\\n    // The number of tokens burned.\\r\\n    uint256 private _burnCounter;\\r\\n\\r\\n    // Token name\\r\\n    string private _name;\\r\\n\\r\\n    // Token symbol\\r\\n    string private _symbol;\\r\\n\\r\\n    // Mapping from token ID to ownership details\\r\\n    // An empty struct value does not necessarily mean the token is unowned.\\r\\n    // See {_packedOwnershipOf} implementation for details.\\r\\n    //\\r\\n    // Bits Layout:\\r\\n    // - [0..159]   `addr`\\r\\n    // - [160..223] `startTimestamp`\\r\\n    // - [224]      `burned`\\r\\n    // - [225]      `nextInitialized`\\r\\n    // - [232..255] `extraData`\\r\\n    mapping(uint256 => uint256) private _packedOwnerships;\\r\\n\\r\\n    // Mapping owner address to address data.\\r\\n    //\\r\\n    // Bits Layout:\\r\\n    // - [0..63]    `balance`\\r\\n    // - [64..127]  `numberMinted`\\r\\n    // - [128..191] `numberBurned`\\r\\n    // - [192..255] `aux`\\r\\n    mapping(address => uint256) private _packedAddressData;\\r\\n\\r\\n    // Mapping from token ID to approved address.\\r\\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\\r\\n\\r\\n    // Mapping from owner to operator approvals\\r\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\r\\n\\r\\n    // =============================================================\\r\\n    //                          CONSTRUCTOR\\r\\n    // =============================================================\\r\\n\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n        _currentIndex = _startTokenId();\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                   TOKEN COUNTING OPERATIONS\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the starting token ID.\\r\\n     * To change the starting token ID, please override this function.\\r\\n     */\\r\\n    function _startTokenId() internal view virtual returns (uint256) {\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the next token ID to be minted.\\r\\n     */\\r\\n    function _nextTokenId() internal view virtual returns (uint256) {\\r\\n        return _currentIndex;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the total number of tokens in existence.\\r\\n     * Burned tokens will reduce the count.\\r\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\r\\n     */\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        // Counter underflow is impossible as _burnCounter cannot be incremented\\r\\n        // more than `_currentIndex - _startTokenId()` times.\\r\\n        unchecked {\\r\\n            return _currentIndex - _burnCounter - _startTokenId();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the total amount of tokens minted in the contract.\\r\\n     */\\r\\n    function _totalMinted() internal view virtual returns (uint256) {\\r\\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\\r\\n        // and it is initialized to `_startTokenId()`.\\r\\n        unchecked {\\r\\n            return _currentIndex - _startTokenId();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the total number of tokens burned.\\r\\n     */\\r\\n    function _totalBurned() internal view virtual returns (uint256) {\\r\\n        return _burnCounter;\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                    ADDRESS DATA OPERATIONS\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of tokens in `owner`'s account.\\r\\n     */\\r\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\r\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\r\\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Returns the number of tokens minted by `owner`.\\r\\n     */\\r\\n    function _numberMinted(address owner) internal view returns (uint256) {\\r\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Returns the number of tokens burned by or on behalf of `owner`.\\r\\n     */\\r\\n    function _numberBurned(address owner) internal view returns (uint256) {\\r\\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\r\\n     */\\r\\n    function _getAux(address owner) internal view returns (uint64) {\\r\\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\\r\\n     * If there are multiple variables, please pack them into a uint64.\\r\\n     */\\r\\n    function _setAux(address owner, uint64 aux) internal virtual {\\r\\n        uint256 packed = _packedAddressData[owner];\\r\\n        uint256 auxCasted;\\r\\n        // Cast `aux` with assembly to avoid redundant masking.\\r\\n        assembly {\\r\\n            auxCasted := aux\\r\\n        }\\r\\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\\r\\n        _packedAddressData[owner] = packed;\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                            IERC165\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n        // The interface IDs are constants representing the first 4 bytes\\r\\n        // of the XOR of all function selectors in the interface.\\r\\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\\r\\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\\r\\n        return\\r\\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\r\\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\\r\\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                        IERC721Metadata\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token collection name.\\r\\n     */\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token collection symbol.\\r\\n     */\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\r\\n     */\\r\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\r\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\r\\n\\r\\n        string memory baseURI = _baseURI();\\r\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\r\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\r\\n     * by default, it can be overridden in child contracts.\\r\\n     */\\r\\n    function _baseURI() internal view virtual returns (string memory) {\\r\\n        return '';\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                     OWNERSHIPS OPERATIONS\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the owner of the `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\r\\n        return address(uint160(_packedOwnershipOf(tokenId)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\\r\\n     * It gradually moves to O(1) as tokens get transferred around over time.\\r\\n     */\\r\\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\\r\\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\\r\\n     */\\r\\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\\r\\n        return _unpackedOwnership(_packedOwnerships[index]);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\\r\\n     */\\r\\n    function _initializeOwnershipAt(uint256 index) internal virtual {\\r\\n        if (_packedOwnerships[index] == 0) {\\r\\n            _packedOwnerships[index] = _packedOwnershipOf(index);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Returns the packed ownership data of `tokenId`.\\r\\n     */\\r\\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\\r\\n        uint256 curr = tokenId;\\r\\n\\r\\n        unchecked {\\r\\n            if (_startTokenId() <= curr)\\r\\n                if (curr < _currentIndex) {\\r\\n                    uint256 packed = _packedOwnerships[curr];\\r\\n                    // If not burned.\\r\\n                    if (packed & _BITMASK_BURNED == 0) {\\r\\n                        // Invariant:\\r\\n                        // There will always be an initialized ownership slot\\r\\n                        // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\\r\\n                        // before an unintialized ownership slot\\r\\n                        // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\\r\\n                        // Hence, `curr` will not underflow.\\r\\n                        //\\r\\n                        // We can directly compare the packed value.\\r\\n                        // If the address is zero, packed will be zero.\\r\\n                        while (packed == 0) {\\r\\n                            packed = _packedOwnerships[--curr];\\r\\n                        }\\r\\n                        return packed;\\r\\n                    }\\r\\n                }\\r\\n        }\\r\\n        revert OwnerQueryForNonexistentToken();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\\r\\n     */\\r\\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\\r\\n        ownership.addr = address(uint160(packed));\\r\\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\\r\\n        ownership.burned = packed & _BITMASK_BURNED != 0;\\r\\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Packs ownership data into a single uint256.\\r\\n     */\\r\\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\\r\\n        assembly {\\r\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\r\\n            owner := and(owner, _BITMASK_ADDRESS)\\r\\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\\r\\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\\r\\n     */\\r\\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\\r\\n        // For branchless setting of the `nextInitialized` flag.\\r\\n        assembly {\\r\\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\\r\\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                      APPROVAL OPERATIONS\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\r\\n     * The approval is cleared when the token is transferred.\\r\\n     *\\r\\n     * Only a single account can be approved at a time, so approving the\\r\\n     * zero address clears previous approvals.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The caller must own the token or be an approved operator.\\r\\n     * - `tokenId` must exist.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address to, uint256 tokenId) public payable virtual override {\\r\\n        address owner = ownerOf(tokenId);\\r\\n\\r\\n        if (_msgSenderERC721A() != owner)\\r\\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\\r\\n                revert ApprovalCallerNotOwnerNorApproved();\\r\\n            }\\r\\n\\r\\n        _tokenApprovals[tokenId].value = to;\\r\\n        emit Approval(owner, to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the account approved for `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\r\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\r\\n\\r\\n        return _tokenApprovals[tokenId].value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Approve or remove `operator` as an operator for the caller.\\r\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\r\\n     * for any token owned by the caller.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The `operator` cannot be the caller.\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\r\\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\\r\\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\r\\n     *\\r\\n     * See {setApprovalForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\r\\n        return _operatorApprovals[owner][operator];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns whether `tokenId` exists.\\r\\n     *\\r\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\r\\n     *\\r\\n     * Tokens start existing when they are minted. See {_mint}.\\r\\n     */\\r\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\r\\n        return\\r\\n            _startTokenId() <= tokenId &&\\r\\n            tokenId < _currentIndex && // If within bounds,\\r\\n            _packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\\r\\n     */\\r\\n    function _isSenderApprovedOrOwner(\\r\\n        address approvedAddress,\\r\\n        address owner,\\r\\n        address msgSender\\r\\n    ) private pure returns (bool result) {\\r\\n        assembly {\\r\\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\\r\\n            owner := and(owner, _BITMASK_ADDRESS)\\r\\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\\r\\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\\r\\n            // `msgSender == owner || msgSender == approvedAddress`.\\r\\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\\r\\n     */\\r\\n    function _getApprovedSlotAndAddress(uint256 tokenId)\\r\\n        private\\r\\n        view\\r\\n        returns (uint256 approvedAddressSlot, address approvedAddress)\\r\\n    {\\r\\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\\r\\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\\r\\n        assembly {\\r\\n            approvedAddressSlot := tokenApproval.slot\\r\\n            approvedAddress := sload(approvedAddressSlot)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                      TRANSFER OPERATIONS\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `tokenId` from `from` to `to`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be approved to move this token\\r\\n     * by either {approve} or {setApprovalForAll}.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) public payable virtual override {\\r\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\r\\n\\r\\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\\r\\n\\r\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\r\\n\\r\\n        // The nested ifs save around 20+ gas over a compound boolean condition.\\r\\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\r\\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\r\\n\\r\\n        if (to == address(0)) revert TransferToZeroAddress();\\r\\n\\r\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\r\\n\\r\\n        // Clear approvals from the previous owner.\\r\\n        assembly {\\r\\n            if approvedAddress {\\r\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\r\\n                sstore(approvedAddressSlot, 0)\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Underflow of the sender's balance is impossible because we check for\\r\\n        // ownership above and the recipient's balance can't realistically overflow.\\r\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\r\\n        unchecked {\\r\\n            // We can directly increment and decrement the balances.\\r\\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\\r\\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\\r\\n\\r\\n            // Updates:\\r\\n            // - `address` to the next owner.\\r\\n            // - `startTimestamp` to the timestamp of transfering.\\r\\n            // - `burned` to `false`.\\r\\n            // - `nextInitialized` to `true`.\\r\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\r\\n                to,\\r\\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\\r\\n            );\\r\\n\\r\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\r\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\r\\n                uint256 nextTokenId = tokenId + 1;\\r\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\r\\n                if (_packedOwnerships[nextTokenId] == 0) {\\r\\n                    // If the next slot is within bounds.\\r\\n                    if (nextTokenId != _currentIndex) {\\r\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\r\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, to, tokenId);\\r\\n        _afterTokenTransfers(from, to, tokenId, 1);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) public payable virtual override {\\r\\n        safeTransferFrom(from, to, tokenId, '');\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must exist and be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be approved to move this token\\r\\n     * by either {approve} or {setApprovalForAll}.\\r\\n     * - If `to` refers to a smart contract, it must implement\\r\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) public payable virtual override {\\r\\n        transferFrom(from, to, tokenId);\\r\\n        if (to.code.length != 0)\\r\\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\r\\n                revert TransferToNonERC721ReceiverImplementer();\\r\\n            }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before a set of serially-ordered token IDs\\r\\n     * are about to be transferred. This includes minting.\\r\\n     * And also called before burning one token.\\r\\n     *\\r\\n     * `startTokenId` - the first token ID to be transferred.\\r\\n     * `quantity` - the amount to be transferred.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\r\\n     * transferred to `to`.\\r\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\r\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     */\\r\\n    function _beforeTokenTransfers(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 startTokenId,\\r\\n        uint256 quantity\\r\\n    ) internal virtual {}\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called after a set of serially-ordered token IDs\\r\\n     * have been transferred. This includes minting.\\r\\n     * And also called after one token has been burned.\\r\\n     *\\r\\n     * `startTokenId` - the first token ID to be transferred.\\r\\n     * `quantity` - the amount to be transferred.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\\r\\n     * transferred to `to`.\\r\\n     * - When `from` is zero, `tokenId` has been minted for `to`.\\r\\n     * - When `to` is zero, `tokenId` has been burned by `from`.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     */\\r\\n    function _afterTokenTransfers(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 startTokenId,\\r\\n        uint256 quantity\\r\\n    ) internal virtual {}\\r\\n\\r\\n    /**\\r\\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\\r\\n     *\\r\\n     * `from` - Previous owner of the given token ID.\\r\\n     * `to` - Target address that will receive the token.\\r\\n     * `tokenId` - Token ID to be transferred.\\r\\n     * `_data` - Optional data to send along with the call.\\r\\n     *\\r\\n     * Returns whether the call correctly returned the expected magic value.\\r\\n     */\\r\\n    function _checkContractOnERC721Received(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) private returns (bool) {\\r\\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\\r\\n            bytes4 retval\\r\\n        ) {\\r\\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\\r\\n        } catch (bytes memory reason) {\\r\\n            if (reason.length == 0) {\\r\\n                revert TransferToNonERC721ReceiverImplementer();\\r\\n            } else {\\r\\n                assembly {\\r\\n                    revert(add(32, reason), mload(reason))\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                        MINT OPERATIONS\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `quantity` must be greater than 0.\\r\\n     *\\r\\n     * Emits a {Transfer} event for each mint.\\r\\n     */\\r\\n    function _mint(address to, uint256 quantity) internal virtual {\\r\\n        uint256 startTokenId = _currentIndex;\\r\\n        if (quantity == 0) revert MintZeroQuantity();\\r\\n\\r\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\r\\n\\r\\n        // Overflows are incredibly unrealistic.\\r\\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\\r\\n        // `tokenId` has a maximum limit of 2**256.\\r\\n        unchecked {\\r\\n            // Updates:\\r\\n            // - `balance += quantity`.\\r\\n            // - `numberMinted += quantity`.\\r\\n            //\\r\\n            // We can directly add to the `balance` and `numberMinted`.\\r\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\r\\n\\r\\n            // Updates:\\r\\n            // - `address` to the owner.\\r\\n            // - `startTimestamp` to the timestamp of minting.\\r\\n            // - `burned` to `false`.\\r\\n            // - `nextInitialized` to `quantity == 1`.\\r\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\r\\n                to,\\r\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\r\\n            );\\r\\n\\r\\n            uint256 toMasked;\\r\\n            uint256 end = startTokenId + quantity;\\r\\n\\r\\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\\r\\n            // The duplicated `log4` removes an extra check and reduces stack juggling.\\r\\n            // The assembly, together with the surrounding Solidity code, have been\\r\\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\\r\\n            assembly {\\r\\n                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\\r\\n                toMasked := and(to, _BITMASK_ADDRESS)\\r\\n                // Emit the `Transfer` event.\\r\\n                log4(\\r\\n                    0, // Start of data (0, since no data).\\r\\n                    0, // End of data (0, since no data).\\r\\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\\r\\n                    0, // `address(0)`.\\r\\n                    toMasked, // `to`.\\r\\n                    startTokenId // `tokenId`.\\r\\n                )\\r\\n\\r\\n                // The `iszero(eq(,))` check ensures that large values of `quantity`\\r\\n                // that overflows uint256 will make the loop run out of gas.\\r\\n                // The compiler will optimize the `iszero` away for performance.\\r\\n                for {\\r\\n                    let tokenId := add(startTokenId, 1)\\r\\n                } iszero(eq(tokenId, end)) {\\r\\n                    tokenId := add(tokenId, 1)\\r\\n                } {\\r\\n                    // Emit the `Transfer` event. Similar to above.\\r\\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\\r\\n                }\\r\\n            }\\r\\n            if (toMasked == 0) revert MintToZeroAddress();\\r\\n\\r\\n            _currentIndex = end;\\r\\n        }\\r\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Mints `quantity` tokens and transfers them to `to`.\\r\\n     *\\r\\n     * This function is intended for efficient minting only during contract creation.\\r\\n     *\\r\\n     * It emits only one {ConsecutiveTransfer} as defined in\\r\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\\r\\n     * instead of a sequence of {Transfer} event(s).\\r\\n     *\\r\\n     * Calling this function outside of contract creation WILL make your contract\\r\\n     * non-compliant with the ERC721 standard.\\r\\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\\r\\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `quantity` must be greater than 0.\\r\\n     *\\r\\n     * Emits a {ConsecutiveTransfer} event.\\r\\n     */\\r\\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\\r\\n        uint256 startTokenId = _currentIndex;\\r\\n        if (to == address(0)) revert MintToZeroAddress();\\r\\n        if (quantity == 0) revert MintZeroQuantity();\\r\\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();\\r\\n\\r\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\r\\n\\r\\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\\r\\n        unchecked {\\r\\n            // Updates:\\r\\n            // - `balance += quantity`.\\r\\n            // - `numberMinted += quantity`.\\r\\n            //\\r\\n            // We can directly add to the `balance` and `numberMinted`.\\r\\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\\r\\n\\r\\n            // Updates:\\r\\n            // - `address` to the owner.\\r\\n            // - `startTimestamp` to the timestamp of minting.\\r\\n            // - `burned` to `false`.\\r\\n            // - `nextInitialized` to `quantity == 1`.\\r\\n            _packedOwnerships[startTokenId] = _packOwnershipData(\\r\\n                to,\\r\\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\\r\\n            );\\r\\n\\r\\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\\r\\n\\r\\n            _currentIndex = startTokenId + quantity;\\r\\n        }\\r\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - If `to` refers to a smart contract, it must implement\\r\\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\\r\\n     * - `quantity` must be greater than 0.\\r\\n     *\\r\\n     * See {_mint}.\\r\\n     *\\r\\n     * Emits a {Transfer} event for each mint.\\r\\n     */\\r\\n    function _safeMint(\\r\\n        address to,\\r\\n        uint256 quantity,\\r\\n        bytes memory _data\\r\\n    ) internal virtual {\\r\\n        _mint(to, quantity);\\r\\n\\r\\n        unchecked {\\r\\n            if (to.code.length != 0) {\\r\\n                uint256 end = _currentIndex;\\r\\n                uint256 index = end - quantity;\\r\\n                do {\\r\\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\\r\\n                        revert TransferToNonERC721ReceiverImplementer();\\r\\n                    }\\r\\n                } while (index < end);\\r\\n                // Reentrancy protection.\\r\\n                if (_currentIndex != end) revert();\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\\r\\n     */\\r\\n    function _safeMint(address to, uint256 quantity) internal virtual {\\r\\n        _safeMint(to, quantity, '');\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                        BURN OPERATIONS\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to `_burn(tokenId, false)`.\\r\\n     */\\r\\n    function _burn(uint256 tokenId) internal virtual {\\r\\n        _burn(tokenId, false);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `tokenId`.\\r\\n     * The approval is cleared when the token is burned.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\\r\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\r\\n\\r\\n        address from = address(uint160(prevOwnershipPacked));\\r\\n\\r\\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\\r\\n\\r\\n        if (approvalCheck) {\\r\\n            // The nested ifs save around 20+ gas over a compound boolean condition.\\r\\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\\r\\n                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\\r\\n        }\\r\\n\\r\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\r\\n\\r\\n        // Clear approvals from the previous owner.\\r\\n        assembly {\\r\\n            if approvedAddress {\\r\\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\\r\\n                sstore(approvedAddressSlot, 0)\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Underflow of the sender's balance is impossible because we check for\\r\\n        // ownership above and the recipient's balance can't realistically overflow.\\r\\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\\r\\n        unchecked {\\r\\n            // Updates:\\r\\n            // - `balance -= 1`.\\r\\n            // - `numberBurned += 1`.\\r\\n            //\\r\\n            // We can directly decrement the balance, and increment the number burned.\\r\\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\\r\\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\\r\\n\\r\\n            // Updates:\\r\\n            // - `address` to the last owner.\\r\\n            // - `startTimestamp` to the timestamp of burning.\\r\\n            // - `burned` to `true`.\\r\\n            // - `nextInitialized` to `true`.\\r\\n            _packedOwnerships[tokenId] = _packOwnershipData(\\r\\n                from,\\r\\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\\r\\n            );\\r\\n\\r\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\r\\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\\r\\n                uint256 nextTokenId = tokenId + 1;\\r\\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\\r\\n                if (_packedOwnerships[nextTokenId] == 0) {\\r\\n                    // If the next slot is within bounds.\\r\\n                    if (nextTokenId != _currentIndex) {\\r\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\r\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, address(0), tokenId);\\r\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\r\\n\\r\\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\\r\\n        unchecked {\\r\\n            _burnCounter++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                     EXTRA DATA OPERATIONS\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Directly sets the extra data for the ownership data `index`.\\r\\n     */\\r\\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\\r\\n        uint256 packed = _packedOwnerships[index];\\r\\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\\r\\n        uint256 extraDataCasted;\\r\\n        // Cast `extraData` with assembly to avoid redundant masking.\\r\\n        assembly {\\r\\n            extraDataCasted := extraData\\r\\n        }\\r\\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\\r\\n        _packedOwnerships[index] = packed;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\\r\\n     * Intended to be overridden by the cosumer contract.\\r\\n     *\\r\\n     * `previousExtraData` - the value of `extraData` before transfer.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\\r\\n     * transferred to `to`.\\r\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\r\\n     * - When `to` is zero, `tokenId` will be burned by `from`.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     */\\r\\n    function _extraData(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint24 previousExtraData\\r\\n    ) internal view virtual returns (uint24) {}\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the next extra data for the packed ownership data.\\r\\n     * The returned result is shifted into position.\\r\\n     */\\r\\n    function _nextExtraData(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 prevOwnershipPacked\\r\\n    ) private view returns (uint256) {\\r\\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\\r\\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                       OTHER OPERATIONS\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the message sender (defaults to `msg.sender`).\\r\\n     *\\r\\n     * If you are writing GSN compatible contracts, you need to override this function.\\r\\n     */\\r\\n    function _msgSenderERC721A() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a uint256 to its ASCII string decimal representation.\\r\\n     */\\r\\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\\r\\n        assembly {\\r\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\r\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\r\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\r\\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\\r\\n            let m := add(mload(0x40), 0xa0)\\r\\n            // Update the free memory pointer to allocate.\\r\\n            mstore(0x40, m)\\r\\n            // Assign the `str` to the end.\\r\\n            str := sub(m, 0x20)\\r\\n            // Zeroize the slot after the string.\\r\\n            mstore(str, 0)\\r\\n\\r\\n            // Cache the end of the memory to calculate the length later.\\r\\n            let end := str\\r\\n\\r\\n            // We write the string from rightmost digit to leftmost digit.\\r\\n            // The following is essentially a do-while loop that also handles the zero case.\\r\\n            // prettier-ignore\\r\\n            for { let temp := value } 1 {} {\\r\\n                str := sub(str, 1)\\r\\n                // Write the character to the pointer.\\r\\n                // The ASCII index of the '0' character is 48.\\r\\n                mstore8(str, add(48, mod(temp, 10)))\\r\\n                // Keep dividing `temp` until zero.\\r\\n                temp := div(temp, 10)\\r\\n                // prettier-ignore\\r\\n                if iszero(temp) { break }\\r\\n            }\\r\\n\\r\\n            let length := sub(end, str)\\r\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\r\\n            str := sub(str, 0x20)\\r\\n            // Store the length.\\r\\n            mstore(str, length)\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solady/src/auth/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @notice Simple single owner authorization mixin.\\r\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\r\\n///\\r\\n/// @dev Note:\\r\\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\\r\\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\\r\\n///\\r\\n/// While the ownable portion follows\\r\\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\\r\\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\\r\\nabstract contract Ownable {\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                       CUSTOM ERRORS                        */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev The caller is not authorized to call the function.\\r\\n    error Unauthorized();\\r\\n\\r\\n    /// @dev The `newOwner` cannot be the zero address.\\r\\n    error NewOwnerIsZeroAddress();\\r\\n\\r\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\r\\n    error NoHandoverRequest();\\r\\n\\r\\n    /// @dev Cannot double-initialize.\\r\\n    error AlreadyInitialized();\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                           EVENTS                           */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\r\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\r\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\r\\n    /// despite it not being as lightweight as a single argument event.\\r\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\r\\n\\r\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\r\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\r\\n\\r\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\r\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\r\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\r\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\r\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\r\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\r\\n\\r\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\r\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\r\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                          STORAGE                           */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev The owner slot is given by:\\r\\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\\\"_OWNER_SLOT_NOT\\\")))))`.\\r\\n    /// It is intentionally chosen to be a high value\\r\\n    /// to avoid collision with lower slots.\\r\\n    /// The choice of manual storage layout is to enable compatibility\\r\\n    /// with both regular and upgradeable contracts.\\r\\n    bytes32 internal constant _OWNER_SLOT =\\r\\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\\r\\n\\r\\n    /// The ownership handover slot of `newOwner` is given by:\\r\\n    /// ```\\r\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\r\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\r\\n    /// ```\\r\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\r\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                     INTERNAL FUNCTIONS                     */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\\r\\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\\r\\n\\r\\n    /// @dev Initializes the owner directly without authorization guard.\\r\\n    /// This function must be called upon initialization,\\r\\n    /// regardless of whether the contract is upgradeable or not.\\r\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\r\\n    /// and to save gas in case the initial owner is not the caller.\\r\\n    /// For performance reasons, this function will not check if there\\r\\n    /// is an existing owner.\\r\\n    function _initializeOwner(address newOwner) internal virtual {\\r\\n        if (_guardInitializeOwner()) {\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                let ownerSlot := _OWNER_SLOT\\r\\n                if sload(ownerSlot) {\\r\\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\\r\\n                    revert(0x1c, 0x04)\\r\\n                }\\r\\n                // Clean the upper 96 bits.\\r\\n                newOwner := shr(96, shl(96, newOwner))\\r\\n                // Store the new value.\\r\\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\r\\n                // Emit the {OwnershipTransferred} event.\\r\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\r\\n            }\\r\\n        } else {\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                // Clean the upper 96 bits.\\r\\n                newOwner := shr(96, shl(96, newOwner))\\r\\n                // Store the new value.\\r\\n                sstore(_OWNER_SLOT, newOwner)\\r\\n                // Emit the {OwnershipTransferred} event.\\r\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Sets the owner directly without authorization guard.\\r\\n    function _setOwner(address newOwner) internal virtual {\\r\\n        if (_guardInitializeOwner()) {\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                let ownerSlot := _OWNER_SLOT\\r\\n                // Clean the upper 96 bits.\\r\\n                newOwner := shr(96, shl(96, newOwner))\\r\\n                // Emit the {OwnershipTransferred} event.\\r\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\r\\n                // Store the new value.\\r\\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\r\\n            }\\r\\n        } else {\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                let ownerSlot := _OWNER_SLOT\\r\\n                // Clean the upper 96 bits.\\r\\n                newOwner := shr(96, shl(96, newOwner))\\r\\n                // Emit the {OwnershipTransferred} event.\\r\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\r\\n                // Store the new value.\\r\\n                sstore(ownerSlot, newOwner)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Throws if the sender is not the owner.\\r\\n    function _checkOwner() internal view virtual {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // If the caller is not the stored owner, revert.\\r\\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\\r\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\r\\n    /// Override to return a different value if needed.\\r\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\r\\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\\r\\n        return 48 * 3600;\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\r\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            if iszero(shl(96, newOwner)) {\\r\\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n        }\\r\\n        _setOwner(newOwner);\\r\\n    }\\r\\n\\r\\n    /// @dev Allows the owner to renounce their ownership.\\r\\n    function renounceOwnership() public payable virtual onlyOwner {\\r\\n        _setOwner(address(0));\\r\\n    }\\r\\n\\r\\n    /// @dev Request a two-step ownership handover to the caller.\\r\\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\\r\\n    function requestOwnershipHandover() public payable virtual {\\r\\n        unchecked {\\r\\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                // Compute and set the handover slot to `expires`.\\r\\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\\r\\n                mstore(0x00, caller())\\r\\n                sstore(keccak256(0x0c, 0x20), expires)\\r\\n                // Emit the {OwnershipHandoverRequested} event.\\r\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\r\\n    function cancelOwnershipHandover() public payable virtual {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Compute and set the handover slot to 0.\\r\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\r\\n            mstore(0x00, caller())\\r\\n            sstore(keccak256(0x0c, 0x20), 0)\\r\\n            // Emit the {OwnershipHandoverCanceled} event.\\r\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\r\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\r\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Compute and set the handover slot to 0.\\r\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\r\\n            mstore(0x00, pendingOwner)\\r\\n            let handoverSlot := keccak256(0x0c, 0x20)\\r\\n            // If the handover does not exist, or has expired.\\r\\n            if gt(timestamp(), sload(handoverSlot)) {\\r\\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n            // Set the handover slot to 0.\\r\\n            sstore(handoverSlot, 0)\\r\\n        }\\r\\n        _setOwner(pendingOwner);\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                   PUBLIC READ FUNCTIONS                    */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Returns the owner of the contract.\\r\\n    function owner() public view virtual returns (address result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := sload(_OWNER_SLOT)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\r\\n    function ownershipHandoverExpiresAt(address pendingOwner)\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        returns (uint256 result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Compute the handover slot.\\r\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\r\\n            mstore(0x00, pendingOwner)\\r\\n            // Load the handover slot.\\r\\n            result := sload(keccak256(0x0c, 0x20))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                         MODIFIERS                          */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Marks a function as only callable by the owner.\\r\\n    modifier onlyOwner() virtual {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solady/src/utils/MerkleProofLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @notice Gas optimized verification of proof of inclusion for a leaf in a Merkle tree.\\r\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)\\r\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/MerkleProofLib.sol)\\r\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol)\\r\\nlibrary MerkleProofLib {\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*            MERKLE PROOF VERIFICATION OPERATIONS            */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.\\r\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool isValid)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            if mload(proof) {\\r\\n                // Initialize `offset` to the offset of `proof` elements in memory.\\r\\n                let offset := add(proof, 0x20)\\r\\n                // Left shift by 5 is equivalent to multiplying by 0x20.\\r\\n                let end := add(offset, shl(5, mload(proof)))\\r\\n                // Iterate over proof elements to compute root hash.\\r\\n                for {} 1 {} {\\r\\n                    // Slot of `leaf` in scratch space.\\r\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\r\\n                    let scratch := shl(5, gt(leaf, mload(offset)))\\r\\n                    // Store elements to hash contiguously in scratch space.\\r\\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\\r\\n                    mstore(scratch, leaf)\\r\\n                    mstore(xor(scratch, 0x20), mload(offset))\\r\\n                    // Reuse `leaf` to store the hash to reduce stack operations.\\r\\n                    leaf := keccak256(0x00, 0x40)\\r\\n                    offset := add(offset, 0x20)\\r\\n                    if iszero(lt(offset, end)) { break }\\r\\n                }\\r\\n            }\\r\\n            isValid := eq(leaf, root)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.\\r\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool isValid)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            if proof.length {\\r\\n                // Left shift by 5 is equivalent to multiplying by 0x20.\\r\\n                let end := add(proof.offset, shl(5, proof.length))\\r\\n                // Initialize `offset` to the offset of `proof` in the calldata.\\r\\n                let offset := proof.offset\\r\\n                // Iterate over proof elements to compute root hash.\\r\\n                for {} 1 {} {\\r\\n                    // Slot of `leaf` in scratch space.\\r\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\r\\n                    let scratch := shl(5, gt(leaf, calldataload(offset)))\\r\\n                    // Store elements to hash contiguously in scratch space.\\r\\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\\r\\n                    mstore(scratch, leaf)\\r\\n                    mstore(xor(scratch, 0x20), calldataload(offset))\\r\\n                    // Reuse `leaf` to store the hash to reduce stack operations.\\r\\n                    leaf := keccak256(0x00, 0x40)\\r\\n                    offset := add(offset, 0x20)\\r\\n                    if iszero(lt(offset, end)) { break }\\r\\n                }\\r\\n            }\\r\\n            isValid := eq(leaf, root)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns whether all `leaves` exist in the Merkle tree with `root`,\\r\\n    /// given `proof` and `flags`.\\r\\n    ///\\r\\n    /// Note:\\r\\n    /// - Breaking the invariant `flags.length == (leaves.length - 1) + proof.length`\\r\\n    ///   will always return false.\\r\\n    /// - The sum of the lengths of `proof` and `leaves` must never overflow.\\r\\n    /// - Any non-zero word in the `flags` array is treated as true.\\r\\n    /// - The memory offset of `proof` must be non-zero\\r\\n    ///   (i.e. `proof` is not pointing to the scratch space).\\r\\n    function verifyMultiProof(\\r\\n        bytes32[] memory proof,\\r\\n        bytes32 root,\\r\\n        bytes32[] memory leaves,\\r\\n        bool[] memory flags\\r\\n    ) internal pure returns (bool isValid) {\\r\\n        // Rebuilds the root by consuming and producing values on a queue.\\r\\n        // The queue starts with the `leaves` array, and goes into a `hashes` array.\\r\\n        // After the process, the last element on the queue is verified\\r\\n        // to be equal to the `root`.\\r\\n        //\\r\\n        // The `flags` array denotes whether the sibling\\r\\n        // should be popped from the queue (`flag == true`), or\\r\\n        // should be popped from the `proof` (`flag == false`).\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Cache the lengths of the arrays.\\r\\n            let leavesLength := mload(leaves)\\r\\n            let proofLength := mload(proof)\\r\\n            let flagsLength := mload(flags)\\r\\n\\r\\n            // Advance the pointers of the arrays to point to the data.\\r\\n            leaves := add(0x20, leaves)\\r\\n            proof := add(0x20, proof)\\r\\n            flags := add(0x20, flags)\\r\\n\\r\\n            // If the number of flags is correct.\\r\\n            for {} eq(add(leavesLength, proofLength), add(flagsLength, 1)) {} {\\r\\n                // For the case where `proof.length + leaves.length == 1`.\\r\\n                if iszero(flagsLength) {\\r\\n                    // `isValid = (proof.length == 1 ? proof[0] : leaves[0]) == root`.\\r\\n                    isValid := eq(mload(xor(leaves, mul(xor(proof, leaves), proofLength))), root)\\r\\n                    break\\r\\n                }\\r\\n\\r\\n                // The required final proof offset if `flagsLength` is not zero, otherwise zero.\\r\\n                let proofEnd := add(proof, shl(5, proofLength))\\r\\n                // We can use the free memory space for the queue.\\r\\n                // We don't need to allocate, since the queue is temporary.\\r\\n                let hashesFront := mload(0x40)\\r\\n                // Copy the leaves into the hashes.\\r\\n                // Sometimes, a little memory expansion costs less than branching.\\r\\n                // Should cost less, even with a high free memory offset of 0x7d00.\\r\\n                leavesLength := shl(5, leavesLength)\\r\\n                for { let i := 0 } iszero(eq(i, leavesLength)) { i := add(i, 0x20) } {\\r\\n                    mstore(add(hashesFront, i), mload(add(leaves, i)))\\r\\n                }\\r\\n                // Compute the back of the hashes.\\r\\n                let hashesBack := add(hashesFront, leavesLength)\\r\\n                // This is the end of the memory for the queue.\\r\\n                // We recycle `flagsLength` to save on stack variables (sometimes save gas).\\r\\n                flagsLength := add(hashesBack, shl(5, flagsLength))\\r\\n\\r\\n                for {} 1 {} {\\r\\n                    // Pop from `hashes`.\\r\\n                    let a := mload(hashesFront)\\r\\n                    // Pop from `hashes`.\\r\\n                    let b := mload(add(hashesFront, 0x20))\\r\\n                    hashesFront := add(hashesFront, 0x40)\\r\\n\\r\\n                    // If the flag is false, load the next proof,\\r\\n                    // else, pops from the queue.\\r\\n                    if iszero(mload(flags)) {\\r\\n                        // Loads the next proof.\\r\\n                        b := mload(proof)\\r\\n                        proof := add(proof, 0x20)\\r\\n                        // Unpop from `hashes`.\\r\\n                        hashesFront := sub(hashesFront, 0x20)\\r\\n                    }\\r\\n\\r\\n                    // Advance to the next flag.\\r\\n                    flags := add(flags, 0x20)\\r\\n\\r\\n                    // Slot of `a` in scratch space.\\r\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\r\\n                    let scratch := shl(5, gt(a, b))\\r\\n                    // Hash the scratch space and push the result onto the queue.\\r\\n                    mstore(scratch, a)\\r\\n                    mstore(xor(scratch, 0x20), b)\\r\\n                    mstore(hashesBack, keccak256(0x00, 0x40))\\r\\n                    hashesBack := add(hashesBack, 0x20)\\r\\n                    if iszero(lt(hashesBack, flagsLength)) { break }\\r\\n                }\\r\\n                isValid :=\\r\\n                    and(\\r\\n                        // Checks if the last value in the queue is same as the root.\\r\\n                        eq(mload(sub(hashesBack, 0x20)), root),\\r\\n                        // And whether all the proofs are used, if required.\\r\\n                        eq(proofEnd, proof)\\r\\n                    )\\r\\n                break\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns whether all `leaves` exist in the Merkle tree with `root`,\\r\\n    /// given `proof` and `flags`.\\r\\n    ///\\r\\n    /// Note:\\r\\n    /// - Breaking the invariant `flags.length == (leaves.length - 1) + proof.length`\\r\\n    ///   will always return false.\\r\\n    /// - Any non-zero word in the `flags` array is treated as true.\\r\\n    /// - The calldata offset of `proof` must be non-zero\\r\\n    ///   (i.e. `proof` is from a regular Solidity function with a 4-byte selector).\\r\\n    function verifyMultiProofCalldata(\\r\\n        bytes32[] calldata proof,\\r\\n        bytes32 root,\\r\\n        bytes32[] calldata leaves,\\r\\n        bool[] calldata flags\\r\\n    ) internal pure returns (bool isValid) {\\r\\n        // Rebuilds the root by consuming and producing values on a queue.\\r\\n        // The queue starts with the `leaves` array, and goes into a `hashes` array.\\r\\n        // After the process, the last element on the queue is verified\\r\\n        // to be equal to the `root`.\\r\\n        //\\r\\n        // The `flags` array denotes whether the sibling\\r\\n        // should be popped from the queue (`flag == true`), or\\r\\n        // should be popped from the `proof` (`flag == false`).\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // If the number of flags is correct.\\r\\n            for {} eq(add(leaves.length, proof.length), add(flags.length, 1)) {} {\\r\\n                // For the case where `proof.length + leaves.length == 1`.\\r\\n                if iszero(flags.length) {\\r\\n                    // `isValid = (proof.length == 1 ? proof[0] : leaves[0]) == root`.\\r\\n                    // forgefmt: disable-next-item\\r\\n                    isValid := eq(\\r\\n                        calldataload(\\r\\n                            xor(leaves.offset, mul(xor(proof.offset, leaves.offset), proof.length))\\r\\n                        ),\\r\\n                        root\\r\\n                    )\\r\\n                    break\\r\\n                }\\r\\n\\r\\n                // The required final proof offset if `flagsLength` is not zero, otherwise zero.\\r\\n                let proofEnd := add(proof.offset, shl(5, proof.length))\\r\\n                // We can use the free memory space for the queue.\\r\\n                // We don't need to allocate, since the queue is temporary.\\r\\n                let hashesFront := mload(0x40)\\r\\n                // Copy the leaves into the hashes.\\r\\n                // Sometimes, a little memory expansion costs less than branching.\\r\\n                // Should cost less, even with a high free memory offset of 0x7d00.\\r\\n                calldatacopy(hashesFront, leaves.offset, shl(5, leaves.length))\\r\\n                // Compute the back of the hashes.\\r\\n                let hashesBack := add(hashesFront, shl(5, leaves.length))\\r\\n                // This is the end of the memory for the queue.\\r\\n                // We recycle `flagsLength` to save on stack variables (sometimes save gas).\\r\\n                flags.length := add(hashesBack, shl(5, flags.length))\\r\\n\\r\\n                // We don't need to make a copy of `proof.offset` or `flags.offset`,\\r\\n                // as they are pass-by-value (this trick may not always save gas).\\r\\n\\r\\n                for {} 1 {} {\\r\\n                    // Pop from `hashes`.\\r\\n                    let a := mload(hashesFront)\\r\\n                    // Pop from `hashes`.\\r\\n                    let b := mload(add(hashesFront, 0x20))\\r\\n                    hashesFront := add(hashesFront, 0x40)\\r\\n\\r\\n                    // If the flag is false, load the next proof,\\r\\n                    // else, pops from the queue.\\r\\n                    if iszero(calldataload(flags.offset)) {\\r\\n                        // Loads the next proof.\\r\\n                        b := calldataload(proof.offset)\\r\\n                        proof.offset := add(proof.offset, 0x20)\\r\\n                        // Unpop from `hashes`.\\r\\n                        hashesFront := sub(hashesFront, 0x20)\\r\\n                    }\\r\\n\\r\\n                    // Advance to the next flag offset.\\r\\n                    flags.offset := add(flags.offset, 0x20)\\r\\n\\r\\n                    // Slot of `a` in scratch space.\\r\\n                    // If the condition is true: 0x20, otherwise: 0x00.\\r\\n                    let scratch := shl(5, gt(a, b))\\r\\n                    // Hash the scratch space and push the result onto the queue.\\r\\n                    mstore(scratch, a)\\r\\n                    mstore(xor(scratch, 0x20), b)\\r\\n                    mstore(hashesBack, keccak256(0x00, 0x40))\\r\\n                    hashesBack := add(hashesBack, 0x20)\\r\\n                    if iszero(lt(hashesBack, flags.length)) { break }\\r\\n                }\\r\\n                isValid :=\\r\\n                    and(\\r\\n                        // Checks if the last value in the queue is same as the root.\\r\\n                        eq(mload(sub(hashesBack, 0x20)), root),\\r\\n                        // And whether all the proofs are used, if required.\\r\\n                        eq(proofEnd, proof.offset)\\r\\n                    )\\r\\n                break\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                   EMPTY CALLDATA HELPERS                   */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Returns an empty calldata bytes32 array.\\r\\n    function emptyProof() internal pure returns (bytes32[] calldata proof) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            proof.length := 0\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns an empty calldata bytes32 array.\\r\\n    function emptyLeaves() internal pure returns (bytes32[] calldata leaves) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            leaves.length := 0\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns an empty calldata bool array.\\r\\n    function emptyFlags() internal pure returns (bool[] calldata flags) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            flags.length := 0\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\r\\n *\\r\\n * These functions can be used to verify that a message was signed by the holder\\r\\n * of the private keys of a given address.\\r\\n */\\r\\nlibrary ECDSA {\\r\\n    enum RecoverError {\\r\\n        NoError,\\r\\n        InvalidSignature,\\r\\n        InvalidSignatureLength,\\r\\n        InvalidSignatureS\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev The signature derives the `address(0)`.\\r\\n     */\\r\\n    error ECDSAInvalidSignature();\\r\\n\\r\\n    /**\\r\\n     * @dev The signature has an invalid length.\\r\\n     */\\r\\n    error ECDSAInvalidSignatureLength(uint256 length);\\r\\n\\r\\n    /**\\r\\n     * @dev The signature has an S value that is in the upper half order.\\r\\n     */\\r\\n    error ECDSAInvalidSignatureS(bytes32 s);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\\r\\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\\r\\n     * and a bytes32 providing additional information about the error.\\r\\n     *\\r\\n     * If no error is returned, then the address can be used for verification purposes.\\r\\n     *\\r\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\r\\n     * this function rejects them by requiring the `s` value to be in the lower\\r\\n     * half order, and the `v` value to be either 27 or 28.\\r\\n     *\\r\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\r\\n     * verification to be secure: it is possible to craft signatures that\\r\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\r\\n     * this is by receiving a hash of the original message (which may otherwise\\r\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\r\\n     *\\r\\n     * Documentation for signature generation:\\r\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\r\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\r\\n     */\\r\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\\r\\n        if (signature.length == 65) {\\r\\n            bytes32 r;\\r\\n            bytes32 s;\\r\\n            uint8 v;\\r\\n            // ecrecover takes the signature parameters, and the only way to get them\\r\\n            // currently is to use assembly.\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                r := mload(add(signature, 0x20))\\r\\n                s := mload(add(signature, 0x40))\\r\\n                v := byte(0, mload(add(signature, 0x60)))\\r\\n            }\\r\\n            return tryRecover(hash, v, r, s);\\r\\n        } else {\\r\\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\r\\n     * `signature`. This address can then be used for verification purposes.\\r\\n     *\\r\\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\\r\\n     * this function rejects them by requiring the `s` value to be in the lower\\r\\n     * half order, and the `v` value to be either 27 or 28.\\r\\n     *\\r\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\r\\n     * verification to be secure: it is possible to craft signatures that\\r\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\r\\n     * this is by receiving a hash of the original message (which may otherwise\\r\\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\\r\\n     */\\r\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\r\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\\r\\n        _throwError(error, errorArg);\\r\\n        return recovered;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\r\\n     *\\r\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\r\\n     */\\r\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\\r\\n        unchecked {\\r\\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\r\\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\\r\\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\\r\\n            return tryRecover(hash, v, r, s);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\r\\n     */\\r\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\r\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\\r\\n        _throwError(error, errorArg);\\r\\n        return recovered;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\r\\n     * `r` and `s` signature fields separately.\\r\\n     */\\r\\n    function tryRecover(\\r\\n        bytes32 hash,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) internal pure returns (address, RecoverError, bytes32) {\\r\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\r\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\r\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\r\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\r\\n        //\\r\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\r\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\r\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\r\\n        // these malleable signatures as well.\\r\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\r\\n            return (address(0), RecoverError.InvalidSignatureS, s);\\r\\n        }\\r\\n\\r\\n        // If the signature is valid (and not malleable), return the signer address\\r\\n        address signer = ecrecover(hash, v, r, s);\\r\\n        if (signer == address(0)) {\\r\\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\\r\\n        }\\r\\n\\r\\n        return (signer, RecoverError.NoError, bytes32(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\r\\n     * `r` and `s` signature fields separately.\\r\\n     */\\r\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\r\\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\\r\\n        _throwError(error, errorArg);\\r\\n        return recovered;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\\r\\n     */\\r\\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\\r\\n        if (error == RecoverError.NoError) {\\r\\n            return; // no error: do nothing\\r\\n        } else if (error == RecoverError.InvalidSignature) {\\r\\n            revert ECDSAInvalidSignature();\\r\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\r\\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\\r\\n        } else if (error == RecoverError.InvalidSignatureS) {\\r\\n            revert ECDSAInvalidSignatureS(errorArg);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\r\\n     */\\r\\n    error AddressInsufficientBalance(address account);\\r\\n\\r\\n    /**\\r\\n     * @dev There's no code at `target` (it is not a contract).\\r\\n     */\\r\\n    error AddressEmptyCode(address target);\\r\\n\\r\\n    /**\\r\\n     * @dev A call to an address target failed. The target may have reverted.\\r\\n     */\\r\\n    error FailedInnerCall();\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        if (address(this).balance < amount) {\\r\\n            revert AddressInsufficientBalance(address(this));\\r\\n        }\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        if (!success) {\\r\\n            revert FailedInnerCall();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain `call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\r\\n     * up by this function (like regular Solidity function calls). However, if\\r\\n     * the call reverted with no returned reason, this function reverts with a\\r\\n     * {FailedInnerCall} error.\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        if (address(this).balance < value) {\\r\\n            revert AddressInsufficientBalance(address(this));\\r\\n        }\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\r\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\r\\n     * unsuccessful call.\\r\\n     */\\r\\n    function verifyCallResultFromTarget(\\r\\n        address target,\\r\\n        bool success,\\r\\n        bytes memory returndata\\r\\n    ) internal view returns (bytes memory) {\\r\\n        if (!success) {\\r\\n            _revert(returndata);\\r\\n        } else {\\r\\n            // only check if target is a contract if the call was successful and the return data is empty\\r\\n            // otherwise we already know that it was a contract\\r\\n            if (returndata.length == 0 && target.code.length == 0) {\\r\\n                revert AddressEmptyCode(target);\\r\\n            }\\r\\n            return returndata;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\r\\n     * revert reason or with a default {FailedInnerCall} error.\\r\\n     */\\r\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\r\\n        if (!success) {\\r\\n            _revert(returndata);\\r\\n        } else {\\r\\n            return returndata;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\r\\n     */\\r\\n    function _revert(bytes memory returndata) private pure {\\r\\n        // Look for revert reason and bubble it up if present\\r\\n        if (returndata.length > 0) {\\r\\n            // The easiest way to bubble the revert reason is using memory via assembly\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                let returndata_size := mload(returndata)\\r\\n                revert(add(32, returndata), returndata_size)\\r\\n            }\\r\\n        } else {\\r\\n            revert FailedInnerCall();\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solady/src/utils/LibString.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/// @notice Library for converting numbers into strings and other string operations.\\r\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\r\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\r\\nlibrary LibString {\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                        CUSTOM ERRORS                       */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev The `length` of the output is too small to contain all the hex digits.\\r\\n    error HexLengthInsufficient();\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                         CONSTANTS                          */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev The constant returned when the `search` is not found in the string.\\r\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                     DECIMAL OPERATIONS                     */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Returns the base 10 decimal representation of `value`.\\r\\n    function toString(uint256 value) internal pure returns (string memory str) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\r\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\r\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\r\\n            // and 3 words for a maximum of 78 digits.\\r\\n            str := add(mload(0x40), 0x80)\\r\\n            // Update the free memory pointer to allocate.\\r\\n            mstore(0x40, add(str, 0x20))\\r\\n            // Zeroize the slot after the string.\\r\\n            mstore(str, 0)\\r\\n\\r\\n            // Cache the end of the memory to calculate the length later.\\r\\n            let end := str\\r\\n\\r\\n            let w := not(0) // Tsk.\\r\\n            // We write the string from rightmost digit to leftmost digit.\\r\\n            // The following is essentially a do-while loop that also handles the zero case.\\r\\n            for { let temp := value } 1 {} {\\r\\n                str := add(str, w) // `sub(str, 1)`.\\r\\n                // Write the character to the pointer.\\r\\n                // The ASCII index of the '0' character is 48.\\r\\n                mstore8(str, add(48, mod(temp, 10)))\\r\\n                // Keep dividing `temp` until zero.\\r\\n                temp := div(temp, 10)\\r\\n                if iszero(temp) { break }\\r\\n            }\\r\\n\\r\\n            let length := sub(end, str)\\r\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\r\\n            str := sub(str, 0x20)\\r\\n            // Store the length.\\r\\n            mstore(str, length)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the base 10 decimal representation of `value`.\\r\\n    function toString(int256 value) internal pure returns (string memory str) {\\r\\n        if (value >= 0) {\\r\\n            return toString(uint256(value));\\r\\n        }\\r\\n        unchecked {\\r\\n            str = toString(uint256(-value));\\r\\n        }\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // We still have some spare memory space on the left,\\r\\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\\r\\n            let length := mload(str) // Load the string length.\\r\\n            mstore(str, 0x2d) // Store the '-' character.\\r\\n            str := sub(str, 1) // Move back the string pointer by a byte.\\r\\n            mstore(str, add(length, 1)) // Update the string length.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                   HEXADECIMAL OPERATIONS                   */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Returns the hexadecimal representation of `value`,\\r\\n    /// left-padded to an input length of `length` bytes.\\r\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\r\\n    /// giving a total length of `length * 2 + 2` bytes.\\r\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\r\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\\r\\n        str = toHexStringNoPrefix(value, length);\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let strLength := add(mload(str), 2) // Compute the length.\\r\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\r\\n            str := sub(str, 2) // Move the pointer.\\r\\n            mstore(str, strLength) // Write the length.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the hexadecimal representation of `value`,\\r\\n    /// left-padded to an input length of `length` bytes.\\r\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\r\\n    /// giving a total length of `length * 2` bytes.\\r\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\r\\n    function toHexStringNoPrefix(uint256 value, uint256 length)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory str)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\r\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\r\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\r\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\r\\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\\r\\n            // Allocate the memory.\\r\\n            mstore(0x40, add(str, 0x20))\\r\\n            // Zeroize the slot after the string.\\r\\n            mstore(str, 0)\\r\\n\\r\\n            // Cache the end to calculate the length later.\\r\\n            let end := str\\r\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\r\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\r\\n\\r\\n            let start := sub(str, add(length, length))\\r\\n            let w := not(1) // Tsk.\\r\\n            let temp := value\\r\\n            // We write the string from rightmost digit to leftmost digit.\\r\\n            // The following is essentially a do-while loop that also handles the zero case.\\r\\n            for {} 1 {} {\\r\\n                str := add(str, w) // `sub(str, 2)`.\\r\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\r\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\r\\n                temp := shr(8, temp)\\r\\n                if iszero(xor(str, start)) { break }\\r\\n            }\\r\\n\\r\\n            if temp {\\r\\n                // Store the function selector of `HexLengthInsufficient()`.\\r\\n                mstore(0x00, 0x2194895a)\\r\\n                // Revert with (offset, size).\\r\\n                revert(0x1c, 0x04)\\r\\n            }\\r\\n\\r\\n            // Compute the string's length.\\r\\n            let strLength := sub(end, str)\\r\\n            // Move the pointer and write the length.\\r\\n            str := sub(str, 0x20)\\r\\n            mstore(str, strLength)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the hexadecimal representation of `value`.\\r\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\r\\n    /// As address are 20 bytes long, the output will left-padded to have\\r\\n    /// a length of `20 * 2 + 2` bytes.\\r\\n    function toHexString(uint256 value) internal pure returns (string memory str) {\\r\\n        str = toHexStringNoPrefix(value);\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let strLength := add(mload(str), 2) // Compute the length.\\r\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\r\\n            str := sub(str, 2) // Move the pointer.\\r\\n            mstore(str, strLength) // Write the length.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the hexadecimal representation of `value`.\\r\\n    /// The output is prefixed with \\\"0x\\\".\\r\\n    /// The output excludes leading \\\"0\\\" from the `toHexString` output.\\r\\n    /// `0x00: \\\"0x0\\\", 0x01: \\\"0x1\\\", 0x12: \\\"0x12\\\", 0x123: \\\"0x123\\\"`.\\r\\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\\r\\n        str = toHexStringNoPrefix(value);\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\r\\n            let strLength := add(mload(str), 2) // Compute the length.\\r\\n            mstore(add(str, o), 0x3078) // Write the \\\"0x\\\" prefix, accounting for leading zero.\\r\\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\\r\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the hexadecimal representation of `value`.\\r\\n    /// The output excludes leading \\\"0\\\" from the `toHexStringNoPrefix` output.\\r\\n    /// `0x00: \\\"0\\\", 0x01: \\\"1\\\", 0x12: \\\"12\\\", 0x123: \\\"123\\\"`.\\r\\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\r\\n        str = toHexStringNoPrefix(value);\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\r\\n            let strLength := mload(str) // Get the length.\\r\\n            str := add(str, o) // Move the pointer, accounting for leading zero.\\r\\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the hexadecimal representation of `value`.\\r\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\r\\n    /// As address are 20 bytes long, the output will left-padded to have\\r\\n    /// a length of `20 * 2` bytes.\\r\\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\r\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\r\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\r\\n            str := add(mload(0x40), 0x80)\\r\\n            // Allocate the memory.\\r\\n            mstore(0x40, add(str, 0x20))\\r\\n            // Zeroize the slot after the string.\\r\\n            mstore(str, 0)\\r\\n\\r\\n            // Cache the end to calculate the length later.\\r\\n            let end := str\\r\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\r\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\r\\n\\r\\n            let w := not(1) // Tsk.\\r\\n            // We write the string from rightmost digit to leftmost digit.\\r\\n            // The following is essentially a do-while loop that also handles the zero case.\\r\\n            for { let temp := value } 1 {} {\\r\\n                str := add(str, w) // `sub(str, 2)`.\\r\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\r\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\r\\n                temp := shr(8, temp)\\r\\n                if iszero(temp) { break }\\r\\n            }\\r\\n\\r\\n            // Compute the string's length.\\r\\n            let strLength := sub(end, str)\\r\\n            // Move the pointer and write the length.\\r\\n            str := sub(str, 0x20)\\r\\n            mstore(str, strLength)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the hexadecimal representation of `value`.\\r\\n    /// The output is prefixed with \\\"0x\\\", encoded using 2 hexadecimal digits per byte,\\r\\n    /// and the alphabets are capitalized conditionally according to\\r\\n    /// https://eips.ethereum.org/EIPS/eip-55\\r\\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\\r\\n        str = toHexString(value);\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\\r\\n            let o := add(str, 0x22)\\r\\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\\r\\n            let t := shl(240, 136) // `0b10001000 << 240`\\r\\n            for { let i := 0 } 1 {} {\\r\\n                mstore(add(i, i), mul(t, byte(i, hashed)))\\r\\n                i := add(i, 1)\\r\\n                if eq(i, 20) { break }\\r\\n            }\\r\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\\r\\n            o := add(o, 0x20)\\r\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the hexadecimal representation of `value`.\\r\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\r\\n    function toHexString(address value) internal pure returns (string memory str) {\\r\\n        str = toHexStringNoPrefix(value);\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let strLength := add(mload(str), 2) // Compute the length.\\r\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\r\\n            str := sub(str, 2) // Move the pointer.\\r\\n            mstore(str, strLength) // Write the length.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the hexadecimal representation of `value`.\\r\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\r\\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            str := mload(0x40)\\r\\n\\r\\n            // Allocate the memory.\\r\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\r\\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\\r\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\\r\\n            mstore(0x40, add(str, 0x80))\\r\\n\\r\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\r\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\r\\n\\r\\n            str := add(str, 2)\\r\\n            mstore(str, 40)\\r\\n\\r\\n            let o := add(str, 0x20)\\r\\n            mstore(add(o, 40), 0)\\r\\n\\r\\n            value := shl(96, value)\\r\\n\\r\\n            // We write the string from rightmost digit to leftmost digit.\\r\\n            // The following is essentially a do-while loop that also handles the zero case.\\r\\n            for { let i := 0 } 1 {} {\\r\\n                let p := add(o, add(i, i))\\r\\n                let temp := byte(i, value)\\r\\n                mstore8(add(p, 1), mload(and(temp, 15)))\\r\\n                mstore8(p, mload(shr(4, temp)))\\r\\n                i := add(i, 1)\\r\\n                if eq(i, 20) { break }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the hex encoded string from the raw bytes.\\r\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\r\\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\\r\\n        str = toHexStringNoPrefix(raw);\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let strLength := add(mload(str), 2) // Compute the length.\\r\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\r\\n            str := sub(str, 2) // Move the pointer.\\r\\n            mstore(str, strLength) // Write the length.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the hex encoded string from the raw bytes.\\r\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\r\\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let length := mload(raw)\\r\\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\\r\\n            mstore(str, add(length, length)) // Store the length of the output.\\r\\n\\r\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\r\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\r\\n\\r\\n            let o := add(str, 0x20)\\r\\n            let end := add(raw, length)\\r\\n\\r\\n            for {} iszero(eq(raw, end)) {} {\\r\\n                raw := add(raw, 1)\\r\\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\\r\\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\\r\\n                o := add(o, 2)\\r\\n            }\\r\\n            mstore(o, 0) // Zeroize the slot after the string.\\r\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                   RUNE STRING OPERATIONS                   */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    /// @dev Returns the number of UTF characters in the string.\\r\\n    function runeCount(string memory s) internal pure returns (uint256 result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            if mload(s) {\\r\\n                mstore(0x00, div(not(0), 255))\\r\\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\\r\\n                let o := add(s, 0x20)\\r\\n                let end := add(o, mload(s))\\r\\n                for { result := 1 } 1 { result := add(result, 1) } {\\r\\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\\r\\n                    if iszero(lt(o, end)) { break }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns if this string is a 7-bit ASCII string.\\r\\n    /// (i.e. all characters codes are in [0..127])\\r\\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let mask := shl(7, div(not(0), 255))\\r\\n            result := 1\\r\\n            let n := mload(s)\\r\\n            if n {\\r\\n                let o := add(s, 0x20)\\r\\n                let end := add(o, n)\\r\\n                let last := mload(end)\\r\\n                mstore(end, 0)\\r\\n                for {} 1 {} {\\r\\n                    if and(mask, mload(o)) {\\r\\n                        result := 0\\r\\n                        break\\r\\n                    }\\r\\n                    o := add(o, 0x20)\\r\\n                    if iszero(lt(o, end)) { break }\\r\\n                }\\r\\n                mstore(end, last)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\r\\n    /*                   BYTE STRING OPERATIONS                   */\\r\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\r\\n\\r\\n    // For performance and bytecode compactness, all indices of the following operations\\r\\n    // are byte (ASCII) offsets, not UTF character offsets.\\r\\n\\r\\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\\r\\n    function replace(string memory subject, string memory search, string memory replacement)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let subjectLength := mload(subject)\\r\\n            let searchLength := mload(search)\\r\\n            let replacementLength := mload(replacement)\\r\\n\\r\\n            subject := add(subject, 0x20)\\r\\n            search := add(search, 0x20)\\r\\n            replacement := add(replacement, 0x20)\\r\\n            result := add(mload(0x40), 0x20)\\r\\n\\r\\n            let subjectEnd := add(subject, subjectLength)\\r\\n            if iszero(gt(searchLength, subjectLength)) {\\r\\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\r\\n                let h := 0\\r\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\r\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\r\\n                let s := mload(search)\\r\\n                for {} 1 {} {\\r\\n                    let t := mload(subject)\\r\\n                    // Whether the first `searchLength % 32` bytes of\\r\\n                    // `subject` and `search` matches.\\r\\n                    if iszero(shr(m, xor(t, s))) {\\r\\n                        if h {\\r\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\r\\n                                mstore(result, t)\\r\\n                                result := add(result, 1)\\r\\n                                subject := add(subject, 1)\\r\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\r\\n                                continue\\r\\n                            }\\r\\n                        }\\r\\n                        // Copy the `replacement` one word at a time.\\r\\n                        for { let o := 0 } 1 {} {\\r\\n                            mstore(add(result, o), mload(add(replacement, o)))\\r\\n                            o := add(o, 0x20)\\r\\n                            if iszero(lt(o, replacementLength)) { break }\\r\\n                        }\\r\\n                        result := add(result, replacementLength)\\r\\n                        subject := add(subject, searchLength)\\r\\n                        if searchLength {\\r\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\r\\n                            continue\\r\\n                        }\\r\\n                    }\\r\\n                    mstore(result, t)\\r\\n                    result := add(result, 1)\\r\\n                    subject := add(subject, 1)\\r\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            let resultRemainder := result\\r\\n            result := add(mload(0x40), 0x20)\\r\\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\r\\n            // Copy the rest of the string one word at a time.\\r\\n            for {} lt(subject, subjectEnd) {} {\\r\\n                mstore(resultRemainder, mload(subject))\\r\\n                resultRemainder := add(resultRemainder, 0x20)\\r\\n                subject := add(subject, 0x20)\\r\\n            }\\r\\n            result := sub(result, 0x20)\\r\\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\\r\\n            mstore(last, 0)\\r\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\r\\n            mstore(result, k) // Store the length.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\r\\n    /// searching from left to right, starting from `from`.\\r\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\r\\n    function indexOf(string memory subject, string memory search, uint256 from)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256 result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            for { let subjectLength := mload(subject) } 1 {} {\\r\\n                if iszero(mload(search)) {\\r\\n                    if iszero(gt(from, subjectLength)) {\\r\\n                        result := from\\r\\n                        break\\r\\n                    }\\r\\n                    result := subjectLength\\r\\n                    break\\r\\n                }\\r\\n                let searchLength := mload(search)\\r\\n                let subjectStart := add(subject, 0x20)\\r\\n\\r\\n                result := not(0) // Initialize to `NOT_FOUND`.\\r\\n\\r\\n                subject := add(subjectStart, from)\\r\\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\r\\n\\r\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\r\\n                let s := mload(add(search, 0x20))\\r\\n\\r\\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\\r\\n\\r\\n                if iszero(lt(searchLength, 0x20)) {\\r\\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\r\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\r\\n                            if eq(keccak256(subject, searchLength), h) {\\r\\n                                result := sub(subject, subjectStart)\\r\\n                                break\\r\\n                            }\\r\\n                        }\\r\\n                        subject := add(subject, 1)\\r\\n                        if iszero(lt(subject, end)) { break }\\r\\n                    }\\r\\n                    break\\r\\n                }\\r\\n                for {} 1 {} {\\r\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\r\\n                        result := sub(subject, subjectStart)\\r\\n                        break\\r\\n                    }\\r\\n                    subject := add(subject, 1)\\r\\n                    if iszero(lt(subject, end)) { break }\\r\\n                }\\r\\n                break\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\r\\n    /// searching from left to right.\\r\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\r\\n    function indexOf(string memory subject, string memory search)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256 result)\\r\\n    {\\r\\n        result = indexOf(subject, search, 0);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\r\\n    /// searching from right to left, starting from `from`.\\r\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\r\\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256 result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            for {} 1 {} {\\r\\n                result := not(0) // Initialize to `NOT_FOUND`.\\r\\n                let searchLength := mload(search)\\r\\n                if gt(searchLength, mload(subject)) { break }\\r\\n                let w := result\\r\\n\\r\\n                let fromMax := sub(mload(subject), searchLength)\\r\\n                if iszero(gt(fromMax, from)) { from := fromMax }\\r\\n\\r\\n                let end := add(add(subject, 0x20), w)\\r\\n                subject := add(add(subject, 0x20), from)\\r\\n                if iszero(gt(subject, end)) { break }\\r\\n                // As this function is not too often used,\\r\\n                // we shall simply use keccak256 for smaller bytecode size.\\r\\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\r\\n                    if eq(keccak256(subject, searchLength), h) {\\r\\n                        result := sub(subject, add(end, 1))\\r\\n                        break\\r\\n                    }\\r\\n                    subject := add(subject, w) // `sub(subject, 1)`.\\r\\n                    if iszero(gt(subject, end)) { break }\\r\\n                }\\r\\n                break\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\r\\n    /// searching from right to left.\\r\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\r\\n    function lastIndexOf(string memory subject, string memory search)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256 result)\\r\\n    {\\r\\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\\r\\n    }\\r\\n\\r\\n    /// @dev Returns whether `subject` starts with `search`.\\r\\n    function startsWith(string memory subject, string memory search)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let searchLength := mload(search)\\r\\n            // Just using keccak256 directly is actually cheaper.\\r\\n            // forgefmt: disable-next-item\\r\\n            result := and(\\r\\n                iszero(gt(searchLength, mload(subject))),\\r\\n                eq(\\r\\n                    keccak256(add(subject, 0x20), searchLength),\\r\\n                    keccak256(add(search, 0x20), searchLength)\\r\\n                )\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns whether `subject` ends with `search`.\\r\\n    function endsWith(string memory subject, string memory search)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let searchLength := mload(search)\\r\\n            let subjectLength := mload(subject)\\r\\n            // Whether `search` is not longer than `subject`.\\r\\n            let withinRange := iszero(gt(searchLength, subjectLength))\\r\\n            // Just using keccak256 directly is actually cheaper.\\r\\n            // forgefmt: disable-next-item\\r\\n            result := and(\\r\\n                withinRange,\\r\\n                eq(\\r\\n                    keccak256(\\r\\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\r\\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\\r\\n                        searchLength\\r\\n                    ),\\r\\n                    keccak256(add(search, 0x20), searchLength)\\r\\n                )\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns `subject` repeated `times`.\\r\\n    function repeat(string memory subject, uint256 times)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let subjectLength := mload(subject)\\r\\n            if iszero(or(iszero(times), iszero(subjectLength))) {\\r\\n                subject := add(subject, 0x20)\\r\\n                result := mload(0x40)\\r\\n                let output := add(result, 0x20)\\r\\n                for {} 1 {} {\\r\\n                    // Copy the `subject` one word at a time.\\r\\n                    for { let o := 0 } 1 {} {\\r\\n                        mstore(add(output, o), mload(add(subject, o)))\\r\\n                        o := add(o, 0x20)\\r\\n                        if iszero(lt(o, subjectLength)) { break }\\r\\n                    }\\r\\n                    output := add(output, subjectLength)\\r\\n                    times := sub(times, 1)\\r\\n                    if iszero(times) { break }\\r\\n                }\\r\\n                mstore(output, 0) // Zeroize the slot after the string.\\r\\n                let resultLength := sub(output, add(result, 0x20))\\r\\n                mstore(result, resultLength) // Store the length.\\r\\n                // Allocate the memory.\\r\\n                mstore(0x40, add(result, add(resultLength, 0x20)))\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\r\\n    /// `start` and `end` are byte offsets.\\r\\n    function slice(string memory subject, uint256 start, uint256 end)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let subjectLength := mload(subject)\\r\\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\\r\\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\\r\\n            if lt(start, end) {\\r\\n                result := mload(0x40)\\r\\n                let resultLength := sub(end, start)\\r\\n                mstore(result, resultLength)\\r\\n                subject := add(subject, start)\\r\\n                let w := not(0x1f)\\r\\n                // Copy the `subject` one word at a time, backwards.\\r\\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\\r\\n                    mstore(add(result, o), mload(add(subject, o)))\\r\\n                    o := add(o, w) // `sub(o, 0x20)`.\\r\\n                    if iszero(o) { break }\\r\\n                }\\r\\n                // Zeroize the slot after the string.\\r\\n                mstore(add(add(result, 0x20), resultLength), 0)\\r\\n                // Allocate memory for the length and the bytes,\\r\\n                // rounded up to a multiple of 32.\\r\\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\r\\n    /// `start` is a byte offset.\\r\\n    function slice(string memory subject, uint256 start)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory result)\\r\\n    {\\r\\n        result = slice(subject, start, uint256(int256(-1)));\\r\\n    }\\r\\n\\r\\n    /// @dev Returns all the indices of `search` in `subject`.\\r\\n    /// The indices are byte offsets.\\r\\n    function indicesOf(string memory subject, string memory search)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256[] memory result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let subjectLength := mload(subject)\\r\\n            let searchLength := mload(search)\\r\\n\\r\\n            if iszero(gt(searchLength, subjectLength)) {\\r\\n                subject := add(subject, 0x20)\\r\\n                search := add(search, 0x20)\\r\\n                result := add(mload(0x40), 0x20)\\r\\n\\r\\n                let subjectStart := subject\\r\\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\\r\\n                let h := 0\\r\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\r\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\r\\n                let s := mload(search)\\r\\n                for {} 1 {} {\\r\\n                    let t := mload(subject)\\r\\n                    // Whether the first `searchLength % 32` bytes of\\r\\n                    // `subject` and `search` matches.\\r\\n                    if iszero(shr(m, xor(t, s))) {\\r\\n                        if h {\\r\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\r\\n                                subject := add(subject, 1)\\r\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\r\\n                                continue\\r\\n                            }\\r\\n                        }\\r\\n                        // Append to `result`.\\r\\n                        mstore(result, sub(subject, subjectStart))\\r\\n                        result := add(result, 0x20)\\r\\n                        // Advance `subject` by `searchLength`.\\r\\n                        subject := add(subject, searchLength)\\r\\n                        if searchLength {\\r\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\r\\n                            continue\\r\\n                        }\\r\\n                    }\\r\\n                    subject := add(subject, 1)\\r\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\r\\n                }\\r\\n                let resultEnd := result\\r\\n                // Assign `result` to the free memory pointer.\\r\\n                result := mload(0x40)\\r\\n                // Store the length of `result`.\\r\\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\r\\n                // Allocate memory for result.\\r\\n                // We allocate one more word, so this array can be recycled for {split}.\\r\\n                mstore(0x40, add(resultEnd, 0x20))\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\r\\n    function split(string memory subject, string memory delimiter)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string[] memory result)\\r\\n    {\\r\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let w := not(0x1f)\\r\\n            let indexPtr := add(indices, 0x20)\\r\\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\r\\n            mstore(add(indicesEnd, w), mload(subject))\\r\\n            mstore(indices, add(mload(indices), 1))\\r\\n            let prevIndex := 0\\r\\n            for {} 1 {} {\\r\\n                let index := mload(indexPtr)\\r\\n                mstore(indexPtr, 0x60)\\r\\n                if iszero(eq(index, prevIndex)) {\\r\\n                    let element := mload(0x40)\\r\\n                    let elementLength := sub(index, prevIndex)\\r\\n                    mstore(element, elementLength)\\r\\n                    // Copy the `subject` one word at a time, backwards.\\r\\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\\r\\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\r\\n                        o := add(o, w) // `sub(o, 0x20)`.\\r\\n                        if iszero(o) { break }\\r\\n                    }\\r\\n                    // Zeroize the slot after the string.\\r\\n                    mstore(add(add(element, 0x20), elementLength), 0)\\r\\n                    // Allocate memory for the length and the bytes,\\r\\n                    // rounded up to a multiple of 32.\\r\\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\\r\\n                    // Store the `element` into the array.\\r\\n                    mstore(indexPtr, element)\\r\\n                }\\r\\n                prevIndex := add(index, mload(delimiter))\\r\\n                indexPtr := add(indexPtr, 0x20)\\r\\n                if iszero(lt(indexPtr, indicesEnd)) { break }\\r\\n            }\\r\\n            result := indices\\r\\n            if iszero(mload(delimiter)) {\\r\\n                result := add(indices, 0x20)\\r\\n                mstore(result, sub(mload(indices), 2))\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns a concatenated string of `a` and `b`.\\r\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\r\\n    function concat(string memory a, string memory b)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let w := not(0x1f)\\r\\n            result := mload(0x40)\\r\\n            let aLength := mload(a)\\r\\n            // Copy `a` one word at a time, backwards.\\r\\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\\r\\n                mstore(add(result, o), mload(add(a, o)))\\r\\n                o := add(o, w) // `sub(o, 0x20)`.\\r\\n                if iszero(o) { break }\\r\\n            }\\r\\n            let bLength := mload(b)\\r\\n            let output := add(result, aLength)\\r\\n            // Copy `b` one word at a time, backwards.\\r\\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\\r\\n                mstore(add(output, o), mload(add(b, o)))\\r\\n                o := add(o, w) // `sub(o, 0x20)`.\\r\\n                if iszero(o) { break }\\r\\n            }\\r\\n            let totalLength := add(aLength, bLength)\\r\\n            let last := add(add(result, 0x20), totalLength)\\r\\n            // Zeroize the slot after the string.\\r\\n            mstore(last, 0)\\r\\n            // Stores the length.\\r\\n            mstore(result, totalLength)\\r\\n            // Allocate memory for the length and the bytes,\\r\\n            // rounded up to a multiple of 32.\\r\\n            mstore(0x40, and(add(last, 0x1f), w))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\\r\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\r\\n    function toCase(string memory subject, bool toUpper)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let length := mload(subject)\\r\\n            if length {\\r\\n                result := add(mload(0x40), 0x20)\\r\\n                subject := add(subject, 1)\\r\\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\\r\\n                let w := not(0)\\r\\n                for { let o := length } 1 {} {\\r\\n                    o := add(o, w)\\r\\n                    let b := and(0xff, mload(add(subject, o)))\\r\\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\\r\\n                    if iszero(o) { break }\\r\\n                }\\r\\n                result := mload(0x40)\\r\\n                mstore(result, length) // Store the length.\\r\\n                let last := add(add(result, 0x20), length)\\r\\n                mstore(last, 0) // Zeroize the slot after the string.\\r\\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns a string from a small bytes32 string.\\r\\n    /// `smallString` must be null terminated, or behavior will be undefined.\\r\\n    function fromSmallString(bytes32 smallString) internal pure returns (string memory result) {\\r\\n        if (smallString == bytes32(0)) return result;\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := mload(0x40)\\r\\n            let n := 0\\r\\n            for {} 1 {} {\\r\\n                n := add(n, 1)\\r\\n                if iszero(byte(n, smallString)) { break } // Scan for '\\\\0'.\\r\\n            }\\r\\n            mstore(result, n)\\r\\n            let o := add(result, 0x20)\\r\\n            mstore(o, smallString)\\r\\n            mstore(add(o, n), 0)\\r\\n            mstore(0x40, add(result, 0x40))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns a lowercased copy of the string.\\r\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\r\\n    function lower(string memory subject) internal pure returns (string memory result) {\\r\\n        result = toCase(subject, false);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns an UPPERCASED copy of the string.\\r\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\r\\n    function upper(string memory subject) internal pure returns (string memory result) {\\r\\n        result = toCase(subject, true);\\r\\n    }\\r\\n\\r\\n    /// @dev Escapes the string to be used within HTML tags.\\r\\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let end := add(s, mload(s))\\r\\n            result := add(mload(0x40), 0x20)\\r\\n            // Store the bytes of the packed offsets and strides into the scratch space.\\r\\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\\r\\n            mstore(0x1f, 0x900094)\\r\\n            mstore(0x08, 0xc0000000a6ab)\\r\\n            // Store \\\"&quot;&amp;&#39;&lt;&gt;\\\" into the scratch space.\\r\\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\\r\\n            for {} iszero(eq(s, end)) {} {\\r\\n                s := add(s, 1)\\r\\n                let c := and(mload(s), 0xff)\\r\\n                // Not in `[\\\"\\\\\\\"\\\",\\\"'\\\",\\\"&\\\",\\\"<\\\",\\\">\\\"]`.\\r\\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\\r\\n                    mstore8(result, c)\\r\\n                    result := add(result, 1)\\r\\n                    continue\\r\\n                }\\r\\n                let t := shr(248, mload(c))\\r\\n                mstore(result, mload(and(t, 0x1f)))\\r\\n                result := add(result, shr(5, t))\\r\\n            }\\r\\n            let last := result\\r\\n            mstore(last, 0) // Zeroize the slot after the string.\\r\\n            result := mload(0x40)\\r\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\r\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\r\\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\\r\\n    function escapeJSON(string memory s, bool addDoubleQuotes)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory result)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let end := add(s, mload(s))\\r\\n            result := add(mload(0x40), 0x20)\\r\\n            if addDoubleQuotes {\\r\\n                mstore8(result, 34)\\r\\n                result := add(1, result)\\r\\n            }\\r\\n            // Store \\\"\\\\\\\\u0000\\\" in scratch space.\\r\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\r\\n            // Also, store `{0x08:\\\"b\\\", 0x09:\\\"t\\\", 0x0a:\\\"n\\\", 0x0c:\\\"f\\\", 0x0d:\\\"r\\\"}`.\\r\\n            // into the scratch space.\\r\\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\\r\\n            // Bitmask for detecting `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\r\\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\\r\\n            for {} iszero(eq(s, end)) {} {\\r\\n                s := add(s, 1)\\r\\n                let c := and(mload(s), 0xff)\\r\\n                if iszero(lt(c, 0x20)) {\\r\\n                    if iszero(and(shl(c, 1), e)) {\\r\\n                        // Not in `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\r\\n                        mstore8(result, c)\\r\\n                        result := add(result, 1)\\r\\n                        continue\\r\\n                    }\\r\\n                    mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\r\\n                    mstore8(add(result, 1), c)\\r\\n                    result := add(result, 2)\\r\\n                    continue\\r\\n                }\\r\\n                if iszero(and(shl(c, 1), 0x3700)) {\\r\\n                    // Not in `[\\\"\\\\b\\\",\\\"\\\\t\\\",\\\"\\\\n\\\",\\\"\\\\f\\\",\\\"\\\\d\\\"]`.\\r\\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\\r\\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\\r\\n                    mstore(result, mload(0x19)) // \\\"\\\\\\\\u00XX\\\".\\r\\n                    result := add(result, 6)\\r\\n                    continue\\r\\n                }\\r\\n                mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\r\\n                mstore8(add(result, 1), mload(add(c, 8)))\\r\\n                result := add(result, 2)\\r\\n            }\\r\\n            if addDoubleQuotes {\\r\\n                mstore8(result, 34)\\r\\n                result := add(1, result)\\r\\n            }\\r\\n            let last := result\\r\\n            mstore(last, 0) // Zeroize the slot after the string.\\r\\n            result := mload(0x40)\\r\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\r\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\r\\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\\r\\n        result = escapeJSON(s, false);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns whether `a` equals `b`.\\r\\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns whether `a` equals `b`. For small strings up to 32 bytes.\\r\\n    /// `b` must be null terminated, or behavior will be undefined.\\r\\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // These should be evaluated on compile time, as far as possible.\\r\\n            let x := and(b, add(not(b), 1))\\r\\n            let r := or(shl(8, iszero(b)), shl(7, iszero(iszero(shr(128, x)))))\\r\\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\\r\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\r\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\r\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\r\\n            result := gt(eq(mload(a), sub(32, shr(3, r))), shr(r, xor(b, mload(add(a, 0x20)))))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Packs a single string with its length into a single word.\\r\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\r\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // We don't need to zero right pad the string,\\r\\n            // since this is our own custom non-standard packing scheme.\\r\\n            result :=\\r\\n                mul(\\r\\n                    // Load the length and the bytes.\\r\\n                    mload(add(a, 0x1f)),\\r\\n                    // `length != 0 && length < 32`. Abuses underflow.\\r\\n                    // Assumes that the length is valid and within the block gas limit.\\r\\n                    lt(sub(mload(a), 1), 0x1f)\\r\\n                )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Unpacks a string packed using {packOne}.\\r\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\r\\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\\r\\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Grab the free memory pointer.\\r\\n            result := mload(0x40)\\r\\n            // Allocate 2 words (1 for the length, 1 for the bytes).\\r\\n            mstore(0x40, add(result, 0x40))\\r\\n            // Zeroize the length slot.\\r\\n            mstore(result, 0)\\r\\n            // Store the length and bytes.\\r\\n            mstore(add(result, 0x1f), packed)\\r\\n            // Right pad with zeroes.\\r\\n            mstore(add(add(result, 0x20), mload(result)), 0)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Packs two strings with their lengths into a single word.\\r\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\r\\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            let aLength := mload(a)\\r\\n            // We don't need to zero right pad the strings,\\r\\n            // since this is our own custom non-standard packing scheme.\\r\\n            result :=\\r\\n                mul(\\r\\n                    // Load the length and the bytes of `a` and `b`.\\r\\n                    or(\\r\\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\\r\\n                        mload(sub(add(b, 0x1e), aLength))\\r\\n                    ),\\r\\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\\r\\n                    // Assumes that the lengths are valid and within the block gas limit.\\r\\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\\r\\n                )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Unpacks strings packed using {packTwo}.\\r\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\r\\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\\r\\n    function unpackTwo(bytes32 packed)\\r\\n        internal\\r\\n        pure\\r\\n        returns (string memory resultA, string memory resultB)\\r\\n    {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            // Grab the free memory pointer.\\r\\n            resultA := mload(0x40)\\r\\n            resultB := add(resultA, 0x40)\\r\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\r\\n            mstore(0x40, add(resultB, 0x40))\\r\\n            // Zeroize the length slots.\\r\\n            mstore(resultA, 0)\\r\\n            mstore(resultB, 0)\\r\\n            // Store the lengths and bytes.\\r\\n            mstore(add(resultA, 0x1f), packed)\\r\\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\\r\\n            // Right pad with zeroes.\\r\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\r\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Directly returns `a` without copying.\\r\\n    function directReturn(string memory a) internal pure {\\r\\n        assembly {\\r\\n            // Assumes that the string does not start from the scratch space.\\r\\n            let retStart := sub(a, 0x20)\\r\\n            let retSize := add(mload(a), 0x40)\\r\\n            // Right pad with zeroes. Just in case the string is produced\\r\\n            // by a method that doesn't zero right pad.\\r\\n            mstore(add(retStart, retSize), 0)\\r\\n            // Store the return offset.\\r\\n            mstore(retStart, 0x20)\\r\\n            // End the transaction, returning the string.\\r\\n            return(retStart, retSize)\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/ERC721A/contracts/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// ERC721A Contracts v4.2.3\\r\\n// Creator: Chiru Labs\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @dev Interface of ERC721A.\\r\\n */\\r\\ninterface IERC721A {\\r\\n    /**\\r\\n     * The caller must own the token or be an approved operator.\\r\\n     */\\r\\n    error ApprovalCallerNotOwnerNorApproved();\\r\\n\\r\\n    /**\\r\\n     * The token does not exist.\\r\\n     */\\r\\n    error ApprovalQueryForNonexistentToken();\\r\\n\\r\\n    /**\\r\\n     * Cannot query the balance for the zero address.\\r\\n     */\\r\\n    error BalanceQueryForZeroAddress();\\r\\n\\r\\n    /**\\r\\n     * Cannot mint to the zero address.\\r\\n     */\\r\\n    error MintToZeroAddress();\\r\\n\\r\\n    /**\\r\\n     * The quantity of tokens minted must be more than zero.\\r\\n     */\\r\\n    error MintZeroQuantity();\\r\\n\\r\\n    /**\\r\\n     * The token does not exist.\\r\\n     */\\r\\n    error OwnerQueryForNonexistentToken();\\r\\n\\r\\n    /**\\r\\n     * The caller must own the token or be an approved operator.\\r\\n     */\\r\\n    error TransferCallerNotOwnerNorApproved();\\r\\n\\r\\n    /**\\r\\n     * The token must be owned by `from`.\\r\\n     */\\r\\n    error TransferFromIncorrectOwner();\\r\\n\\r\\n    /**\\r\\n     * Cannot safely transfer to a contract that does not implement the\\r\\n     * ERC721Receiver interface.\\r\\n     */\\r\\n    error TransferToNonERC721ReceiverImplementer();\\r\\n\\r\\n    /**\\r\\n     * Cannot transfer to the zero address.\\r\\n     */\\r\\n    error TransferToZeroAddress();\\r\\n\\r\\n    /**\\r\\n     * The token does not exist.\\r\\n     */\\r\\n    error URIQueryForNonexistentToken();\\r\\n\\r\\n    /**\\r\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\r\\n     */\\r\\n    error MintERC2309QuantityExceedsLimit();\\r\\n\\r\\n    /**\\r\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\r\\n     */\\r\\n    error OwnershipNotInitializedForExtraData();\\r\\n\\r\\n    // =============================================================\\r\\n    //                            STRUCTS\\r\\n    // =============================================================\\r\\n\\r\\n    struct TokenOwnership {\\r\\n        // The address of the owner.\\r\\n        address addr;\\r\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\r\\n        uint64 startTimestamp;\\r\\n        // Whether the token has been burned.\\r\\n        bool burned;\\r\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\r\\n        uint24 extraData;\\r\\n    }\\r\\n\\r\\n    // =============================================================\\r\\n    //                         TOKEN COUNTERS\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the total number of tokens in existence.\\r\\n     * Burned tokens will reduce the count.\\r\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    // =============================================================\\r\\n    //                            IERC165\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n\\r\\n    // =============================================================\\r\\n    //                            IERC721\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `owner` enables or disables\\r\\n     * (`approved`) `operator` to manage all of its assets.\\r\\n     */\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of tokens in `owner`'s account.\\r\\n     */\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the owner of the `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\r\\n     * checking first that contract recipients are aware of the ERC721 protocol\\r\\n     * to prevent tokens from being forever locked.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must exist and be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be have been allowed to move\\r\\n     * this token by either {approve} or {setApprovalForAll}.\\r\\n     * - If `to` refers to a smart contract, it must implement\\r\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes calldata data\\r\\n    ) external payable;\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external payable;\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `tokenId` from `from` to `to`.\\r\\n     *\\r\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\r\\n     * whenever possible.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be approved to move this token\\r\\n     * by either {approve} or {setApprovalForAll}.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external payable;\\r\\n\\r\\n    /**\\r\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\r\\n     * The approval is cleared when the token is transferred.\\r\\n     *\\r\\n     * Only a single account can be approved at a time, so approving the\\r\\n     * zero address clears previous approvals.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The caller must own the token or be an approved operator.\\r\\n     * - `tokenId` must exist.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address to, uint256 tokenId) external payable;\\r\\n\\r\\n    /**\\r\\n     * @dev Approve or remove `operator` as an operator for the caller.\\r\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\r\\n     * for any token owned by the caller.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The `operator` cannot be the caller.\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool _approved) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the account approved for `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\r\\n     *\\r\\n     * See {setApprovalForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\r\\n\\r\\n    // =============================================================\\r\\n    //                        IERC721Metadata\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token collection name.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token collection symbol.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\r\\n     */\\r\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\r\\n\\r\\n    // =============================================================\\r\\n    //                           IERC2309\\r\\n    // =============================================================\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\r\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\r\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\r\\n     *\\r\\n     * See {_mintERC2309} for more details.\\r\\n     */\\r\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@ERC721A/=lib/ERC721A/contracts/\",\r\n      \"@solady/=lib/solady/src/\",\r\n      \"@murky/=lib/murky/src/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ERC721A/=lib/ERC721A/contracts/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"murky/=lib/murky/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solady/=lib/solady/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_begRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_whitelistRoot\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_begToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_signerAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyStaked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BegMintClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BegMintUnauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ECDSAInvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"ECDSAInvalidSignatureLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"ECDSAInvalidSignatureS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBeg\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientPayment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidNonce\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidWhitelistWindow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintERC2309QuantityExceedsLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintNotLive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoTokens\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotStaked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnershipNotInitializedForExtraData\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PublicMintNotLive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SupplyExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"URIQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WhitelistMintUnauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WhitelistNotLive\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ConsecutiveTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeTime\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"begClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"begMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"begPerBlitz\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"begRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"begToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"calculateReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"claimEngagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emissionTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"}],\"name\":\"getStaker\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lastClaim\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"internalType\":\"struct Blitz.Staker\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"getTokenStatuses\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"live\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"publicMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueBeg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_begPerBlitz\",\"type\":\"uint256\"}],\"name\":\"setBegPerBlitz\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_begRoot\",\"type\":\"bytes32\"}],\"name\":\"setBegRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hours\",\"type\":\"uint256\"}],\"name\":\"setEmissionTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setLive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signerAddress\",\"type\":\"address\"}],\"name\":\"setSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"setTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_whitelistOpen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_whitelistClosed\",\"type\":\"uint256\"}],\"name\":\"setWhitelistMintWindow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_whitelistRoot\",\"type\":\"bytes32\"}],\"name\":\"setWhitelistRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastClaim\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistClosed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"whitelistMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistOpen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Blitz", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "2aa6f33fcc6adc63b528f501d5be65247b6337452d22af62884dab33f210ba0b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000be6be64e9e5042b6e84e4c27956cce6353efa5f5000000000000000000000000a8ed7461a98259d03b1f7a2a2ce7000a54e78617", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}