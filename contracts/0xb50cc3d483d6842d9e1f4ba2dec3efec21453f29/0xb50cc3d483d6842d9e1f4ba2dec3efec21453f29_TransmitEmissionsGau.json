{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() external {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gauges/TransmitEmissionsGauge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\r\\nimport {TransferHelper} from \\\"light-lib/contracts/TransferHelper.sol\\\";\\r\\n\\r\\ninterface ILT {\\r\\n    function rate() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Update mining rate and supply at the start of the epoch\\r\\n     * @dev   Callable by any address, but only once per epoch\\r\\n     *        Total supply becomes slightly larger if this function is called late\\r\\n     */\\r\\n    function updateMiningParameters() external;\\r\\n\\r\\n    /**\\r\\n     * @notice Get timestamp of the next mining epoch start while simultaneously updating mining parameters\\r\\n     * @return Timestamp of the next epoch\\r\\n     */\\r\\n    function futureEpochTimeWrite() external returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IGaugeController {\\r\\n    /**\\r\\n     * @notice Checkpoint to fill data for both a specific gauge and common for all gauge\\r\\n     * @param addr Gauge address\\r\\n     */\\r\\n    function checkpointGauge(address addr) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18(e.g. 1.0 == 1e18). Inflation which will be received by\\r\\n     * it is inflation_rate * relative_weight / 1e18\\r\\n     * @param gaugeAddress Gauge address\\r\\n     * @param time Relative weight at the specified timestamp in the past or present\\r\\n     * @return Value of relative weight normalized to 1e18\\r\\n     */\\r\\n    function gaugeRelativeWeight(address gaugeAddress, uint256 time) external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IMinter {\\r\\n    function mint(address gaugeAddress) external;\\r\\n}\\r\\n\\r\\ncontract TransmitEmissionsGauge is Ownable2Step {\\r\\n    event UpdateReceiver(address oldReceiver, address newReceiver);\\r\\n    event UpdateStatus(bool isKilled, uint timestamp);\\r\\n\\r\\n    struct InflationParams {\\r\\n        uint256 rate;\\r\\n        uint256 finishTime;\\r\\n    }\\r\\n\\r\\n    uint256 private constant WEEK = 604800;\\r\\n    uint256 private constant YEAR = 86400 * 365;\\r\\n    uint256 private constant RATE_DENOMINATOR = 10 ** 18;\\r\\n    uint256 private constant RATE_REDUCTION_COEFFICIENT = 1189207115002721024; // 2 ** (1/4) * 1e18\\r\\n    uint256 private constant RATE_REDUCTION_TIME = YEAR;\\r\\n\\r\\n    address public immutable ltToken;\\r\\n    address public immutable minter;\\r\\n    address public immutable gaugeController;\\r\\n    address public receiver; // receive the lt token\\r\\n\\r\\n    uint256 public lastPeriod;\\r\\n    uint256 public totalEmissions;\\r\\n\\r\\n    bool public isKilled;\\r\\n\\r\\n    InflationParams public inflationParams;\\r\\n\\r\\n    constructor(address _ltToken, address _gaugeController, address _minter, address _receiver) {\\r\\n        require(_ltToken != address(0), \\\"CANNOT BE ZERO ADDRESS\\\");\\r\\n        require(_gaugeController != address(0), \\\"CANNOT BE ZERO ADDRESS\\\");\\r\\n        require(_minter != address(0), \\\"CANNOT BE ZERO ADDRESS\\\");\\r\\n        require(_receiver != address(0), \\\"CANNOT BE ZERO ADDRESS\\\");\\r\\n        ltToken = _ltToken;\\r\\n        gaugeController = _gaugeController;\\r\\n        minter = _minter;\\r\\n        receiver = _receiver;\\r\\n\\r\\n        inflationParams = InflationParams({rate: ILT(_ltToken).rate(), finishTime: ILT(_ltToken).futureEpochTimeWrite()});\\r\\n        assert(inflationParams.rate != 0);\\r\\n\\r\\n        lastPeriod = block.timestamp / WEEK;\\r\\n\\r\\n        emit UpdateReceiver(address(0), _receiver);\\r\\n    }\\r\\n\\r\\n    /***\\r\\n     * @notice Mint any new emissions and transmit to receiver, can be called by anyone\\r\\n     */\\r\\n    function transmitEmissions() external {\\r\\n        IMinter(minter).mint(address(this));\\r\\n        uint256 minted = ILT(ltToken).balanceOf(address(this));\\r\\n        assert(minted != 0);\\r\\n        TransferHelper.doTransferOut(ltToken, receiver, minted);\\r\\n    }\\r\\n\\r\\n    /***\\r\\n     * @notice Query the total emissions `_user` is entitled to\\r\\n     * @dev Any value of `_user` other than the gauge address will return 0\\r\\n     */\\r\\n    function integrateFraction(address _user) external view returns (uint256) {\\r\\n        if (_user == address(this)) return totalEmissions;\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    /***\\r\\n     * @notice Checkpoint the gauge updating total emissions\\r\\n     * @dev _user Vestigial parameter with no impact on the function\\r\\n     */\\r\\n    function userCheckpoint(address _user) external returns (bool) {\\r\\n        uint256 _lastPeriod = lastPeriod;\\r\\n        uint256 currentPeriod = block.timestamp / WEEK;\\r\\n\\r\\n        //only checkpoint if the current period is greater than the last period\\r\\n        //last period is always less than or equal to current period and we only calculate\\r\\n        //emissions up to current period (not including it)\\r\\n        if (_lastPeriod != currentPeriod) {\\r\\n            //checkpoint the gauge filling in any missing weight data\\r\\n            IGaugeController(gaugeController).checkpointGauge(address(this));\\r\\n\\r\\n            InflationParams memory _inflationParams = inflationParams;\\r\\n            uint256 emissions = 0;\\r\\n            //only calculate emissions for at most 256 periods since the last checkpoint\\r\\n            for (uint256 i = _lastPeriod; i < _lastPeriod + 256; i++) {\\r\\n                if (i == currentPeriod) break;\\r\\n                uint256 periodTime = i * WEEK;\\r\\n                uint256 weight = IGaugeController(gaugeController).gaugeRelativeWeight(address(this), periodTime);\\r\\n                if (periodTime <= _inflationParams.finishTime && _inflationParams.finishTime < periodTime + WEEK) {\\r\\n                    //calculate with old rate\\r\\n                    emissions += (weight * _inflationParams.rate * (_inflationParams.finishTime - periodTime)) / 10 ** 18;\\r\\n                    //update rate\\r\\n                    _inflationParams.rate = (_inflationParams.rate * RATE_DENOMINATOR) / RATE_REDUCTION_COEFFICIENT;\\r\\n                    //calculate with new rate\\r\\n                    emissions += (weight * _inflationParams.rate * (periodTime + WEEK - _inflationParams.finishTime)) / 10 ** 18;\\r\\n                    //update finish time\\r\\n                    _inflationParams.finishTime += RATE_REDUCTION_TIME;\\r\\n                    //update storage\\r\\n                    inflationParams = _inflationParams;\\r\\n                } else {\\r\\n                    emissions += (weight * _inflationParams.rate * WEEK) / 10 ** 18;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            lastPeriod = currentPeriod;\\r\\n            totalEmissions += emissions;\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /***\\r\\n     * @notice Set the killed status for this contract\\r\\n     * @dev When killed, the gauge always yields a rate of 0 and so cannot mint LT\\r\\n     * @param _is_killed Killed status to set\\r\\n     */\\r\\n    function setKilled(bool _isKilled) external onlyOwner {\\r\\n        if (_isKilled) {\\r\\n            inflationParams.rate = 0;\\r\\n        } else {\\r\\n            inflationParams.rate = ILT(ltToken).rate();\\r\\n            inflationParams.finishTime = ILT(ltToken).futureEpochTimeWrite();\\r\\n            lastPeriod = block.timestamp / WEEK;\\r\\n        }\\r\\n\\r\\n        isKilled = _isKilled;\\r\\n\\r\\n        emit UpdateStatus(_isKilled, block.timestamp);\\r\\n    }\\r\\n\\r\\n    /***\\r\\n     * @notice update the receiver\\r\\n     * @param newReceiver the new receiver\\r\\n     */\\r\\n    function updateReceiver(address newReceiver) external onlyOwner {\\r\\n        require(newReceiver != address(0), \\\"CANNOT BE ZERO ADDRESS\\\");\\r\\n        require(newReceiver != receiver, \\\"THE SAME RECEIVER\\\");\\r\\n        receiver = newReceiver;\\r\\n        emit UpdateReceiver(receiver, newReceiver);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"light-lib/contracts/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"light-lib/contracts/IPermit2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0\\n\\npragma solidity 0.8.17;\\n\\ninterface IPermit2 {\\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\\n    struct TokenPermissions {\\n        // ERC20 token address\\n        address token;\\n        // the maximum amount that can be spent\\n        uint256 amount;\\n    }\\n\\n    /// @notice The signed permit message for a single token transfer\\n    struct PermitTransferFrom {\\n        TokenPermissions permitted;\\n        // a unique value for every token owner's signature to prevent signature replays\\n        uint256 nonce;\\n        // deadline on the permit signature\\n        uint256 deadline;\\n    }\\n\\n    /// @notice Specifies the recipient address and amount for batched transfers.\\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\\n    struct SignatureTransferDetails {\\n        // recipient address\\n        address to;\\n        // spender requested amount\\n        uint256 requestedAmount;\\n    }\\n\\n    /// @notice Used to reconstruct the signed permit message for multiple token transfers\\n    /// @dev Do not need to pass in spender address as it is required that it is msg.sender\\n    /// @dev Note that a user still signs over a spender address\\n    struct PermitBatchTransferFrom {\\n        // the tokens and corresponding amounts permitted for a transfer\\n        TokenPermissions[] permitted;\\n        // a unique value for every token owner's signature to prevent signature replays\\n        uint256 nonce;\\n        // deadline on the permit signature\\n        uint256 deadline;\\n    }\\n\\n    /// @notice Details for a token transfer.\\n    struct AllowanceTransferDetails {\\n        // the owner of the token\\n        address from;\\n        // the recipient of the token\\n        address to;\\n        // the amount of the token\\n        uint160 amount;\\n        // the token to be transferred\\n        address token;\\n    }\\n\\n    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the bitmap to prevent against signature replay protection\\n    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order\\n    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce\\n    /// @dev It returns a uint256 bitmap\\n    /// @dev The index, or wordPosition is capped at type(uint248).max\\n    function nonceBitmap(address, uint256) external view returns (uint256);\\n\\n    /// @notice Transfers a token using a signed permit message\\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\\n    /// @param permit The permit data signed over by the owner\\n    /// @param owner The owner of the tokens to transfer\\n    /// @param transferDetails The spender's requested transfer details for the permitted token\\n    /// @param signature The signature to verify\\n    function permitTransferFrom(\\n        PermitTransferFrom memory permit,\\n        SignatureTransferDetails calldata transferDetails,\\n        address owner,\\n        bytes calldata signature\\n    ) external;\\n\\n    /// @notice Transfers a token using a signed permit message\\n    /// @notice Includes extra data provided by the caller to verify signature over\\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\\n    /// @param permit The permit data signed over by the owner\\n    /// @param owner The owner of the tokens to transfer\\n    /// @param transferDetails The spender's requested transfer details for the permitted token\\n    /// @param witness Extra data to include when checking the user signature\\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\\n    /// @param signature The signature to verify\\n    function permitWitnessTransferFrom(\\n        PermitTransferFrom memory permit,\\n        SignatureTransferDetails calldata transferDetails,\\n        address owner,\\n        bytes32 witness,\\n        string calldata witnessTypeString,\\n        bytes calldata signature\\n    ) external;\\n\\n    /// @notice Transfers multiple tokens using a signed permit message\\n    /// @param permit The permit data signed over by the owner\\n    /// @param owner The owner of the tokens to transfer\\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\\n    /// @param signature The signature to verify\\n    function permitTransferFrom(\\n        PermitBatchTransferFrom memory permit,\\n        SignatureTransferDetails[] calldata transferDetails,\\n        address owner,\\n        bytes calldata signature\\n    ) external;\\n\\n    /// @notice Transfers multiple tokens using a signed permit message\\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\\n    /// @notice Includes extra data provided by the caller to verify signature over\\n    /// @param permit The permit data signed over by the owner\\n    /// @param owner The owner of the tokens to transfer\\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\\n    /// @param witness Extra data to include when checking the user signature\\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\\n    /// @param signature The signature to verify\\n    function permitWitnessTransferFrom(\\n        PermitBatchTransferFrom memory permit,\\n        SignatureTransferDetails[] calldata transferDetails,\\n        address owner,\\n        bytes32 witness,\\n        string calldata witnessTypeString,\\n        bytes calldata signature\\n    ) external;\\n\\n    /// @notice Invalidates the bits specified in mask for the bitmap at the word position\\n    /// @dev The wordPos is maxed at type(uint248).max\\n    /// @param wordPos A number to index the nonceBitmap at\\n    /// @param mask A bitmap masked against msg.sender's current bitmap at the word position\\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;\\n\\n    /// @notice Transfer approved tokens from one address to another\\n    /// @param from The address to transfer from\\n    /// @param to The address of the recipient\\n    /// @param amount The amount of the token to transfer\\n    /// @param token The token address to transfer\\n    /// @dev Requires the from address to have approved at least the desired amount\\n    /// of tokens to msg.sender.\\n    function transferFrom(address from, address to, uint160 amount, address token) external;\\n\\n    /// @notice Transfer approved tokens in a batch\\n    /// @param transferDetails Array of owners, recipients, amounts, and tokens for the transfers\\n    /// @dev Requires the from addresses to have approved at least the desired amount\\n    /// of tokens to msg.sender.\\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\\n}\\n\"\r\n    },\r\n    \"light-lib/contracts/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IPermit2.sol\\\";\\n\\nlibrary TransferHelper {\\n    \\n    /**\\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\\n     *      This will revert due to insufficient balance or insufficient allowance.\\n     *      This function returns the actual amount received,\\n     *      which may be less than `amount` if there is a fee attached to the transfer.\\n     *\\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\n     */\\n    function doTransferFrom(address tokenAddress, address from, address to, uint256 amount) internal returns(uint256) {\\n        IERC20 token = IERC20(tokenAddress);\\n        uint256 balanceBefore = token.balanceOf(to);\\n        safeTransferFrom(token, from, to, amount);\\n        uint256 balanceAfter = token.balanceOf(to);\\n        uint256 actualAmount = balanceAfter - balanceBefore;\\n        assert(actualAmount <= amount);\\n        return actualAmount;\\n    }\\n\\n    /**\\n     * @dev transfer with permit2\\n     */\\n    function doTransferIn(\\n        address permit2Address,\\n        address tokenAddress,\\n        uint256 _value,\\n        address from,\\n        uint256 nonce,\\n        uint256 deadline,\\n        bytes memory signature\\n    ) internal returns (uint256) {\\n        IPermit2.PermitTransferFrom memory permit = IPermit2.PermitTransferFrom({\\n            permitted: IPermit2.TokenPermissions({token: tokenAddress, amount: _value}),\\n            nonce: nonce,\\n            deadline: deadline\\n        });\\n        IPermit2.SignatureTransferDetails memory transferDetails = IPermit2.SignatureTransferDetails({\\n            to: address(this),\\n            requestedAmount: _value\\n        });\\n        // Read from storage once\\n        IERC20 token = IERC20(permit.permitted.token);\\n        uint256 balanceBefore = token.balanceOf(transferDetails.to);\\n        if (nonce == 0 && deadline == 0) {\\n            safeTransferFrom(token, from, transferDetails.to, transferDetails.requestedAmount);\\n        } else {\\n            IPermit2(permit2Address).permitTransferFrom(permit, transferDetails, from, signature);\\n        }\\n        // Calculate the amount that was *actually* transferred\\n        uint256 balanceAfter = IERC20(permit.permitted.token).balanceOf(address(this));\\n        uint256 actualAmount = balanceAfter - balanceBefore;\\n        assert(actualAmount <= transferDetails.requestedAmount);\\n        \\n        return actualAmount;\\n    }\\n\\n    /**\\n     * @dev Permit2 allowance transfer\\n     */\\n    function doTransferFromWithPermit2Allowance(\\n        address permit2Address,\\n        address tokenAddress,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal returns (uint256) {\\n        // Read from storage once\\n        IERC20 token = IERC20(tokenAddress);\\n        uint256 balanceBefore = token.balanceOf(to);\\n        IPermit2(permit2Address).transferFrom(from, to, uint160(amount), tokenAddress);\\n        // Calculate the amount that was *actually* transferred\\n        uint256 balanceAfter = token.balanceOf(to);\\n        uint256 actualAmount = balanceAfter - balanceBefore;\\n        assert(actualAmount <= amount);\\n        \\n        return actualAmount;\\n    }\\n\\n    /**\\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\\n     *      it is >= amount, this should not revert in normal conditions.\\n     *\\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\n     */\\n    function doTransferOut(address tokenAddress, address to, uint256 amount) internal returns(uint256) {\\n        IERC20 token = IERC20(tokenAddress);\\n        uint256 balanceBefore = token.balanceOf(to);\\n        safeTransfer(token, to, amount);\\n        uint256 balanceAfter = token.balanceOf(to);\\n        uint256 actualAmount = balanceAfter - balanceBefore;\\n        assert(actualAmount <= amount);\\n        return actualAmount;\\n    }\\n\\n    function doApprove(address tokenAddress, address to, uint256 amount) internal {\\n        IERC20 token = IERC20(tokenAddress);\\n        safeApprove(token, to, amount);\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED11111\\\");\\n    }\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ltToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gaugeController\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newReceiver\",\"type\":\"address\"}],\"name\":\"UpdateReceiver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isKilled\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdateStatus\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gaugeController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inflationParams\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finishTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"integrateFraction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isKilled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ltToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isKilled\",\"type\":\"bool\"}],\"name\":\"setKilled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEmissions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transmitEmissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newReceiver\",\"type\":\"address\"}],\"name\":\"updateReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"userCheckpoint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TransmitEmissionsGauge", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000009ed1439d328647bdb148c20316ea024c719a735b000000000000000000000000a8b2706b45eb95e5d14f8c29a3c5cf0cd5b4dd7e00000000000000000000000094afb2c17af24cfacf19f364628f459dfab2688f0000000000000000000000008ecdfe286f808748f7ac4e1074b26fe4a52e014b", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}