{"SourceCode": "/**\r\n \r\nTelegram: https://t.me/pumpkinmusk\r\n\r\nTwitter: https://x.com/pumpkinelon\r\n\r\nWebsite: https://pelonmusk.carrd.co/\r\n\r\n*/\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\nabstract contract Context {\r\n function _msgSender() internal view virtual returns (address) {\r\n     return msg.sender;\r\n }\r\n function _msgData() internal view virtual returns (bytes calldata) {\r\n     return msg.data;\r\n }\r\n}\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n function balanceOf(address account) external view returns (uint256);\r\n function transfer(address recipient, uint256 amount) external returns (bool);\r\n function allowance(address owner, address spender) external view returns (uint256);\r\n function approve(address spender, uint256 amount) external returns (bool);\r\n function transferFrom(address sender,address recipient,uint256 amount) external returns (bool);\r\n event Transfer(address indexed from, address indexed to, uint256 value);\r\n event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\nlibrary Address {\r\n function isContract(address account) internal view returns (bool) {\r\n     // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n     // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n     // for accounts without code, i.e. `keccak256('')`\r\n     bytes32 codehash;\r\n     bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n     // solhint-disable-next-line no-inline-assembly\r\n     assembly { codehash := extcodehash(account) }\r\n     return (codehash != accountHash && codehash != 0x0);\r\n }\r\n function sendValue(address payable recipient, uint256 amount) internal {\r\n     require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n     // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n     (bool success, ) = recipient.call{ value: amount }(\"\");\r\n     require(success, \"Address: unable to send value, recipient may have reverted\");\r\n }\r\n function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n   return functionCall(target, data, \"Address: low-level call failed\");\r\n }\r\n function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n     return _functionCallWithValue(target, data, 0, errorMessage);\r\n }\r\n function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n     return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n }\r\n function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n     require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n     return _functionCallWithValue(target, data, value, errorMessage);\r\n }\r\n function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n     require(isContract(target), \"Address: call to non-contract\");\r\n     (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n     if (success) {\r\n         return returndata;\r\n     } else {\r\n      \r\n         if (returndata.length > 0) {\r\n             assembly {\r\n                 let returndata_size := mload(returndata)\r\n                 revert(add(32, returndata), returndata_size)\r\n             }\r\n         } else {\r\n             revert(errorMessage);\r\n         }\r\n     }\r\n }\r\n}\r\nabstract contract Ownable is Context {\r\n address private _owner;\r\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n /**\r\n  * @dev Initializes the contract setting the deployer as the initial owner.\r\n  */\r\n constructor() {\r\n     _setOwner(_msgSender());\r\n }\r\n /**\r\n  * @dev Returns the address of the current owner.\r\n  */\r\n function owner() public view virtual returns (address) {\r\n     return _owner;\r\n }\r\n /**\r\n  * @dev Throws if called by any account other than the owner.\r\n  */\r\n modifier onlyOwner() {\r\n     require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n     _;\r\n }\r\n /**\r\n  * @dev Leaves the contract without owner. It will not be possible to call\r\n  * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n  *\r\n  * NOTE: Renouncing ownership will leave the contract without an owner,\r\n  * thereby removing any functionality that is only available to the owner.\r\n  */\r\n function renounceOwnership() public virtual onlyOwner {\r\n     _setOwner(address(0));\r\n }\r\n /**\r\n  * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n  * Can only be called by the current owner.\r\n  */\r\n function transferOwnership(address newOwner) public virtual onlyOwner {\r\n     require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n     _setOwner(newOwner);\r\n }\r\n function _setOwner(address newOwner) private {\r\n     address oldOwner = _owner;\r\n     _owner = newOwner;\r\n     emit OwnershipTransferred(oldOwner, newOwner);\r\n }\r\n}\r\ncontract PELON is Context,IERC20, Ownable{\r\n using Address for address;\r\n string private _name = \"PELON MUSK\";\r\n string private _symbol = \"PELON\";\r\n uint8 private _decimals = 18;\r\n uint256 totalFeeFortx = 0;\r\n   uint256 maxWalletTreshold = 3;\r\n uint256 maxTxTreshold = 1;\r\n uint256 private swapTreshold =1;\r\n uint256 private currentThreshold = 20; //Once the token value goes up this number can be decreased (To reduce price impact on asset)\r\n uint256 private _totalSupply = (10000000 * 10**4) * 10**_decimals; //\r\n uint256 public requiredTokensToSwap = _totalSupply * swapTreshold /1000;\r\n mapping (address => uint256) private _balances;\r\n mapping (address => bool) private _excludedFromFees;\r\n mapping (address => mapping (address => uint256)) private _allowances;\r\n mapping (address => bool) public automatedMarketMakerPairs;\r\n address _owner;\r\n address payable public marketingAddress = payable(0x7fea25e7261C119d56eD1Ac12ae7eED42F56071C);\r\n uint256 maxWalletAmount = _totalSupply*maxWalletTreshold/300; // starting 3%\r\n uint256 maxTxAmount = _totalSupply*maxTxTreshold/100;\r\n mapping (address => bool) botWallets;\r\n bool botTradeEnabled = false;\r\n bool checkWalletSize = true;\r\n mapping (address => bool) private _liquidityHolders;\r\n mapping (address => bool) private presaleAddresses;\r\n //Taxes and more \r\n uint256 private buyliqFee = 1; //1\r\n uint256 private buyprevLiqFee = 1;\r\n uint256 private buymktFee = 20;//20\r\n uint256 private buyPrevmktFee = 20;\r\n uint256 PELONDaycooldown = 0;\r\n bool private tradeEnabled = false;\r\n  uint256 private sellliqFee = 1;\r\n uint256 private sellprevLiqFee = 1;\r\n uint256 private sellmktFee = 20;\r\n uint256 private sellPrevmktFee = 20;\r\n  bool public inSwapAndLiquify;\r\n bool public swapAndLiquifyEnabled = true;\r\n address public immutable deadAddress = 0x000000000000000000000000000000000000dEaD;\r\n uint256 private mktTokens = 0;\r\n uint256 private liqTokens = 0;\r\n  event SwapAndLiquify(uint256 tokensSwapped,\r\n     uint256 ethReceived,\r\n     uint256 tokensIntoLiquidity\r\n );\r\n event tokensSwappedDuringTokenomics(uint256 amount);\r\n event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\r\n  // 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\n IUniswapV2Router02 _router;\r\n address public uniswapV2Pair;\r\n //Balances tracker\r\n modifier lockTheSwap{\r\n     inSwapAndLiquify = true;\r\n     _;\r\n     inSwapAndLiquify = false;\r\n }\r\n  constructor(){\r\n     _balances[_msgSender()] = _totalSupply;\r\n     //0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D mainnet and all networks\r\n     IUniswapV2Router02 _uniRouter = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n  \r\n     uniswapV2Pair = IUniswapV2Factory(_uniRouter.factory())\r\n         .createPair(address(this), _uniRouter.WETH());\r\n  \r\n     _excludedFromFees[owner()] = true;      \r\n     _excludedFromFees[address(this)] = true;// exclude owner and contract instance from fees\r\n     _router = _uniRouter;\r\n     _liquidityHolders[address(_router)] = true;\r\n     _liquidityHolders[owner()] = true;\r\n     _liquidityHolders[address(this)] = true;\r\n     _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\r\n     emit Transfer(address(0),_msgSender(),_totalSupply);\r\n }\r\n receive() external payable{}\r\n //general token data and tracking of balances to be swapped.\r\n function getOwner()external view returns(address){\r\n         return owner();\r\n }\r\n function currentmktTokens() external view returns (uint256){\r\n         return mktTokens;\r\n  }\r\n  function currentLiqTokens() external view returns (uint256){\r\n         return liqTokens;\r\n  }\r\n  function totalSupply() external view override returns (uint256){\r\n         return _totalSupply;\r\n  }\r\n function balanceOf(address account) public view override returns (uint256){\r\n     return _balances[account];\r\n }\r\n function transfer(address recipient, uint256 amount) external override returns (bool){\r\n         _transfer(_msgSender(),recipient,amount);\r\n         return true;\r\n }\r\n function allowance(address owner, address spender) external view override returns (uint256){\r\n         return _allowances[owner][spender];\r\n }\r\n function approve(address spender, uint256 amount) external override returns (bool){\r\n         _approve(_msgSender(),spender,amount);\r\n         return true;\r\n }\r\n function decimals()external view returns(uint256){\r\n     return _decimals;\r\n }\r\n function name() external view returns (string memory) {\r\n     return _name;\r\n }\r\n function symbol() external view returns (string memory){\r\n     return _symbol;\r\n }\r\n     function updateMaxTxTreshold(uint256 newVal) public onlyOwner{\r\n     maxTxTreshold = newVal;\r\n     maxTxAmount = _totalSupply*maxTxTreshold/100;// 1%\r\n }\r\n  function updateMaxWalletTreshold(uint256 newVal) public onlyOwner{\r\n     maxWalletTreshold = newVal;\r\n     maxWalletAmount = _totalSupply*maxWalletTreshold/300;\r\n }\r\n  function transferFrom(\r\n     address sender,\r\n     address recipient,\r\n     uint256 amount\r\n ) public override returns (bool){\r\n     require(amount <= _allowances[sender][_msgSender()], \"ERC20: transfer amount exceeds allowance\");\r\n     _transfer(sender, recipient, amount);\r\n     _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\r\n     return true;\r\n }\r\n //Tokenomics related functions\r\n  function PELONDay() public onlyOwner{\r\n      require(block.timestamp > PELONDaycooldown, \"You cant call PELONCoinDay more than once a day\");\r\n      buyPrevmktFee = buymktFee;\r\n      buyprevLiqFee = buyliqFee;\r\n \r\n      buyliqFee = 0;\r\n      buymktFee = 0;\r\n }\r\n function PELONCoinDayOver() public onlyOwner{\r\n      buyliqFee = buyprevLiqFee;\r\n      buymktFee = buyPrevmktFee;\r\n      PELONDaycooldown = block.timestamp + 86400;\r\n }\r\n function addBotWallet (address payable detectedBot, bool isBot) public onlyOwner{\r\n     botWallets[detectedBot] = isBot;\r\n }\r\n function currentbuyliqFee() public view returns (uint256){\r\n         return buyliqFee;\r\n }\r\n function currentbuymktfee() public view returns (uint256){\r\n         return buymktFee;\r\n }\r\n   function currentsellLiqFee() public view returns (uint256){\r\n         return sellliqFee;\r\n }\r\n function currentsellmktfee() public view returns (uint256){\r\n         return sellmktFee;\r\n }\r\n function currentThresholdInt()public view returns (uint256){\r\n     return currentThreshold;\r\n }\r\n function isExcluded(address toCheck)public view returns (bool){\r\n         return _excludedFromFees[toCheck];\r\n }\r\n function _transfer(address from, address to, uint256 amount) internal{\r\n  \r\n     require(from != address(0), \"ERC20: transfer from the zero address\");\r\n     require(to != address(0), \"ERC20: transfer to the zero address\");\r\n     require(amount > 0,\"ERC20: transfered amount must be greater than zero\");\r\n     uint256 senderBalance = _balances[from];\r\n     require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n     if(tradeEnabled == false){\r\n         require(_liquidityHolders[to] || _liquidityHolders[from],\"Cant trade, trade is disabled\");\r\n     }\r\n     if(_liquidityHolders[to]==false && _liquidityHolders[from]==false){\r\n     require(amount <= maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\r\n      if(from == uniswapV2Pair){\r\n             require(balanceOf(to)+amount <= maxWalletAmount);\r\n         }\r\n     }\r\n     uint256 inContractBalance = balanceOf(address(this));\r\n     if(inContractBalance >=requiredTokensToSwap &&\r\n         !inSwapAndLiquify &&\r\n         from != uniswapV2Pair &&\r\n         swapAndLiquifyEnabled){\r\n             if(inContractBalance >= requiredTokensToSwap ){\r\n                 inContractBalance = requiredTokensToSwap;\r\n                 swapForTokenomics(inContractBalance);\r\n             }\r\n         }\r\n         bool takeFees = true;\r\n      \r\n      \r\n         if(_excludedFromFees[from] || _excludedFromFees[to]) {\r\n             totalFeeFortx = 0;\r\n             takeFees = false;\r\n         \r\n         }\r\n         uint256 mktAmount = 0;\r\n         uint256 liqAmount = 0;  // Amount to be added to liquidity.\r\n         if(takeFees){\r\n          \r\n          \r\n             //bot fees\r\n             if(botWallets[from] == true||botWallets[to]==true){\r\n                 revert(\"No bots can trade\");\r\n             }\r\n             //Selling fees\r\n             if (automatedMarketMakerPairs[to] && to != address(_router) ){\r\n                     totalFeeFortx = 0;\r\n                     mktAmount = amount * sellmktFee/100;\r\n                     liqAmount = amount * sellliqFee/100;\r\n                     totalFeeFortx = mktAmount + liqAmount;\r\n             }\r\n             //Buy Fees\r\n             else if(automatedMarketMakerPairs[from] && from != address(_router)) {\r\n          \r\n                 totalFeeFortx = 0;\r\n                 mktAmount = amount * buymktFee/100;\r\n                 liqAmount = amount * buyliqFee/100;\r\n                 totalFeeFortx = mktAmount + liqAmount ;\r\n             }\r\n          \r\n         }\r\n         _balances[from] = senderBalance - amount;\r\n         _balances[to] += amount - mktAmount - liqAmount;\r\n       if(liqAmount != 0) {\r\n         _balances[address(this)] += totalFeeFortx;\r\n         //tLiqTotal += liqAmount;\r\n         liqTokens += liqAmount;\r\n         mktTokens += mktAmount;\r\n         emit Transfer(from, address(this), totalFeeFortx);\r\n      \r\n         }\r\n         emit Transfer(from, to,amount-totalFeeFortx);\r\n      \r\n  \r\n }\r\n function swapForTokenomics(uint256 balanceToswap) private lockTheSwap{\r\n     swapAndLiquify(liqTokens);\r\n     swapTokensForETHmkt(mktTokens);\r\n     emit tokensSwappedDuringTokenomics(balanceToswap);\r\n     mktTokens = 0;\r\n     liqTokens = 0;\r\n }\r\n  function addLimitExempt(address newAddress)external onlyOwner{\r\n     _liquidityHolders[newAddress] = true;\r\n }\r\n function swapTokensForETHmkt(uint256 amount)private {\r\n     address[] memory path = new address[](2);\r\n     path[0] = address(this);\r\n     path[1] = _router.WETH();\r\n     _approve(address(this), address(_router), amount);\r\n  \r\n     _router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n         amount,\r\n         0, // Accept any amount of ETH.\r\n         path,\r\n         marketingAddress,\r\n         block.timestamp\r\n     );\r\n }\r\n function unstuckTokens (IERC20 tokenToClear, address payable destination, uint256 amount) public onlyOwner{\r\n     //uint256 contractBalance = tokenToClear.balanceOf(address(this));\r\n     tokenToClear.transfer(destination, amount);\r\n }\r\n function unstuckETH(address payable destination) public onlyOwner{\r\n     uint256 ethBalance = address(this).balance;\r\n     payable(destination).transfer(ethBalance);\r\n }\r\n function tradeStatus(bool status) public onlyOwner{\r\n     tradeEnabled = status;\r\n }\r\n function swapAndLiquify(uint256 liqTokensPassed) private {\r\n     uint256 half = liqTokensPassed / 2;\r\n     uint256 otherHalf = liqTokensPassed - half;\r\n     uint256 initialBalance = address(this).balance;\r\n     swapTokensForETH(half);\r\n     uint256 newBalance = address(this).balance - (initialBalance);\r\n     addLiquidity(otherHalf, newBalance);\r\n     emit SwapAndLiquify(half,newBalance,otherHalf);\r\n }\r\n function swapTokensForETH(uint256 tokenAmount) private{\r\n     address[] memory path = new address[](2);\r\n     path[0] = address(this);\r\n     path[1] = _router.WETH();\r\n     _approve(address(this), address(_router), tokenAmount);\r\n  \r\n     _router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n         tokenAmount,\r\n         0, // Accept any amount of ETH.\r\n         path,\r\n         address(this),\r\n         block.timestamp\r\n     );\r\n }\r\n  function addLiquidity(uint256 tokenAmount,uint256 ethAmount) private{\r\n     _approve(address(this), address(_router), tokenAmount);\r\n     _router.addLiquidityETH{value:ethAmount}(\r\n         address(this),\r\n         tokenAmount,\r\n         0,\r\n         0,\r\n         deadAddress,// tr\r\n         block.timestamp\r\n     );\r\n }\r\n function _approve(address owner,address spender, uint256 amount) internal{\r\n     require(owner != address(0), \"ERC20: approve from the zero address\");\r\n     require(spender != address(0), \"ERC20: approve to the zero address\");\r\n     _allowances[owner][spender] = amount;\r\n     emit Approval(owner, spender, amount);\r\n }\r\n //Fees related functions\r\n function addToExcluded(address toExclude) public onlyOwner{\r\n     _excludedFromFees[toExclude] = true;\r\n }\r\n function removeFromExcluded(address toRemove) public onlyOwner{\r\n     _excludedFromFees[toRemove] = false;\r\n }\r\n   function excludePresaleAddresses(address router, address presale) external onlyOwner {\r\n  \r\n     _liquidityHolders[address(router)] = true;\r\n     _liquidityHolders[presale] = true;\r\n     presaleAddresses[address(router)] = true;\r\n     presaleAddresses[presale] = true;\r\n \r\n }\r\n function endPresaleStatus() public onlyOwner{\r\n     buymktFee = 4;\r\n     buyliqFee = 2;\r\n     sellmktFee = 4;\r\n     sellliqFee = 2;\r\n     setSwapAndLiquify(true);\r\n }\r\n function updateThreshold(uint newThreshold) public onlyOwner{\r\n     currentThreshold = newThreshold;\r\n }\r\n function setSwapAndLiquify(bool _enabled) public onlyOwner{\r\n         swapAndLiquifyEnabled = _enabled;\r\n }\r\n //Marketing related\r\n function setMktAddress(address newAddress) external onlyOwner{\r\n     marketingAddress = payable(newAddress);\r\n }\r\n function transferAssetsETH(address payable to, uint256 amount) internal{\r\n         to.transfer(amount);\r\n }\r\n function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\r\n     require(pair != uniswapV2Pair, \"The pair cannot be removed from automatedMarketMakerPairs\");\r\n     _setAutomatedMarketMakerPair(pair, value);\r\n }\r\n function _setAutomatedMarketMakerPair(address pair, bool value) private {\r\n     automatedMarketMakerPairs[pair] = value;\r\n     emit SetAutomatedMarketMakerPair(pair, value);\r\n }\r\n function updatecurrentbuyliqFee(uint256 newAmount) public onlyOwner{\r\n         buyliqFee = newAmount;\r\n }\r\n function updatecurrentbuymktfee(uint256 newAmount) public onlyOwner{\r\n          buymktFee= newAmount;\r\n }\r\n   function updatecurrentsellLiqFee(uint256 newAmount) public onlyOwner{\r\n          sellliqFee= newAmount;\r\n }\r\n function updatecurrentsellmktfee(uint256 newAmount)public onlyOwner{\r\n          sellmktFee= newAmount;\r\n }\r\n function currentMaxWallet() public view returns(uint256){\r\n     return maxWalletAmount;\r\n }\r\n function currentMaxTx() public view returns(uint256){\r\n     return maxTxAmount;\r\n }\r\n function updateSwapTreshold(uint256 newVal) public onlyOwner{\r\n     swapTreshold = newVal;\r\n     requiredTokensToSwap = _totalSupply*swapTreshold/1000;\r\n  \r\n }\r\n function currentTradeStatus() public view returns (bool){\r\n     return tradeEnabled;\r\n }\r\n function currentSwapTreshold() public view returns(uint256){\r\n     return swapTreshold;\r\n }\r\n function currentTokensToSwap() public view returns(uint256){\r\n     return requiredTokensToSwap;\r\n }\r\n}\r\ninterface IUniswapV2Factory {\r\n event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n function feeTo() external view returns (address);\r\n function feeToSetter() external view returns (address);\r\n function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n function allPairs(uint) external view returns (address pair);\r\n function allPairsLength() external view returns (uint);\r\n function createPair(address tokenA, address tokenB) external returns (address pair);\r\n function setFeeTo(address) external;\r\n function setFeeToSetter(address) external;\r\n}\r\ninterface IUniswapV2Pair {\r\n event Approval(address indexed owner, address indexed spender, uint value);\r\n event Transfer(address indexed from, address indexed to, uint value);\r\n function name() external pure returns (string memory);\r\n function symbol() external pure returns (string memory);\r\n function decimals() external pure returns (uint8);\r\n function totalSupply() external view returns (uint);\r\n function balanceOf(address owner) external view returns (uint);\r\n function allowance(address owner, address spender) external view returns (uint);\r\n function approve(address spender, uint value) external returns (bool);\r\n function transfer(address to, uint value) external returns (bool);\r\n function transferFrom(address from, address to, uint value) external returns (bool);\r\n function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n function nonces(address owner) external view returns (uint);\r\n function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n event Mint(address indexed sender, uint amount0, uint amount1);\r\n event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n event Swap(\r\n     address indexed sender,\r\n     uint amount0In,\r\n     uint amount1In,\r\n     uint amount0Out,\r\n     uint amount1Out,\r\n     address indexed to\r\n );\r\n event Sync(uint112 reserve0, uint112 reserve1);\r\n function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n function factory() external view returns (address);\r\n function token0() external view returns (address);\r\n function token1() external view returns (address);\r\n function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n function price0CumulativeLast() external view returns (uint);\r\n function price1CumulativeLast() external view returns (uint);\r\n function kLast() external view returns (uint);\r\n function mint(address to) external returns (uint liquidity);\r\n function burn(address to) external returns (uint amount0, uint amount1);\r\n function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n function skim(address to) external;\r\n function sync() external;\r\n function initialize(address, address) external;\r\n}\r\ninterface IUniswapV2Router01 {\r\n function factory() external pure returns (address);\r\n function WETH() external pure returns (address);\r\n function addLiquidity(\r\n     address tokenA,\r\n     address tokenB,\r\n     uint amountADesired,\r\n     uint amountBDesired,\r\n     uint amountAMin,\r\n     uint amountBMin,\r\n     address to,\r\n     uint deadline\r\n ) external returns (uint amountA, uint amountB, uint liquidity);\r\n function addLiquidityETH(\r\n     address token,\r\n     uint amountTokenDesired,\r\n     uint amountTokenMin,\r\n     uint amountETHMin,\r\n     address to,\r\n     uint deadline\r\n ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n function removeLiquidity(\r\n     address tokenA,\r\n     address tokenB,\r\n     uint liquidity,\r\n     uint amountAMin,\r\n     uint amountBMin,\r\n     address to,\r\n     uint deadline\r\n ) external returns (uint amountA, uint amountB);\r\n function removeLiquidityETH(\r\n     address token,\r\n     uint liquidity,\r\n     uint amountTokenMin,\r\n     uint amountETHMin,\r\n     address to,\r\n     uint deadline\r\n ) external returns (uint amountToken, uint amountETH);\r\n function removeLiquidityWithPermit(\r\n     address tokenA,\r\n     address tokenB,\r\n     uint liquidity,\r\n     uint amountAMin,\r\n     uint amountBMin,\r\n     address to,\r\n     uint deadline,\r\n     bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n ) external returns (uint amountA, uint amountB);\r\n function removeLiquidityETHWithPermit(\r\n     address token,\r\n     uint liquidity,\r\n     uint amountTokenMin,\r\n     uint amountETHMin,\r\n     address to,\r\n     uint deadline,\r\n     bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n ) external returns (uint amountToken, uint amountETH);\r\n function swapExactTokensForTokens(\r\n     uint amountIn,\r\n     uint amountOutMin,\r\n     address[] calldata path,\r\n     address to,\r\n     uint deadline\r\n ) external returns (uint[] memory amounts);\r\n function swapTokensForExactTokens(\r\n     uint amountOut,\r\n     uint amountInMax,\r\n     address[] calldata path,\r\n     address to,\r\n     uint deadline\r\n ) external returns (uint[] memory amounts);\r\n function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n     external\r\n     payable\r\n     returns (uint[] memory amounts);\r\n function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n     external\r\n     returns (uint[] memory amounts);\r\n function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n     external\r\n     returns (uint[] memory amounts);\r\n function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n     external\r\n     payable\r\n     returns (uint[] memory amounts);\r\n function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n     address token,\r\n     uint liquidity,\r\n     uint amountTokenMin,\r\n     uint amountETHMin,\r\n     address to,\r\n     uint deadline\r\n ) external returns (uint amountETH);\r\n function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n     address token,\r\n     uint liquidity,\r\n     uint amountTokenMin,\r\n     uint amountETHMin,\r\n     address to,\r\n     uint deadline,\r\n     bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n ) external returns (uint amountETH);\r\n function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n     uint amountIn,\r\n     uint amountOutMin,\r\n     address[] calldata path,\r\n     address to,\r\n     uint deadline\r\n ) external;\r\n function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n     uint amountOutMin,\r\n     address[] calldata path,\r\n     address to,\r\n     uint deadline\r\n ) external payable;\r\n function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n     uint amountIn,\r\n     uint amountOutMin,\r\n     address[] calldata path,\r\n     address to,\r\n     uint deadline\r\n ) external;\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiquidity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"tokensSwappedDuringTokenomics\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PELONCoinDayOver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PELONDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"detectedBot\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBot\",\"type\":\"bool\"}],\"name\":\"addBotWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"addLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toExclude\",\"type\":\"address\"}],\"name\":\"addToExcluded\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentLiqTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentMaxTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentMaxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentSwapTreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentThresholdInt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTokensToSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTradeStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentbuyliqFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentbuymktfee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentmktTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentsellLiqFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentsellmktfee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endPresaleStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"presale\",\"type\":\"address\"}],\"name\":\"excludePresaleAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inSwapAndLiquify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toCheck\",\"type\":\"address\"}],\"name\":\"isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toRemove\",\"type\":\"address\"}],\"name\":\"removeFromExcluded\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requiredTokensToSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setMktAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"tradeStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"unstuckETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenToClear\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstuckTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newVal\",\"type\":\"uint256\"}],\"name\":\"updateMaxTxTreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newVal\",\"type\":\"uint256\"}],\"name\":\"updateMaxWalletTreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newVal\",\"type\":\"uint256\"}],\"name\":\"updateSwapTreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"}],\"name\":\"updateThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"updatecurrentbuyliqFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"updatecurrentbuymktfee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"updatecurrentsellLiqFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"updatecurrentsellmktfee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PELON", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b3517e5b2a17c304521753701d6564366c550a85827c34771fd54e9f473e6a53"}