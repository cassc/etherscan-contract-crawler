{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/eip/2535/core/DiamondCutFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.12;\\r\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\r\\nimport { LibDiamond } from \\\"../lib/LibDiamond.sol\\\";\\r\\ncontract DiamondCutFacet is IDiamondCut {\\r\\n    function diamondCut(\\r\\n        FacetCut[] calldata _diamondCut,\\r\\n        address _init,\\r\\n        bytes calldata _calldata\\r\\n    ) external override {\\r\\n        LibDiamond.diamondCut(_diamondCut, _init, _calldata);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/eip/2535/interfaces/IDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.12;\\r\\n\\r\\ninterface IDiamond {\\r\\n    struct FacetCut{\\r\\n        address  facetAddress;\\r\\n        bytes4[] addSelectors;\\r\\n        bytes4[] removeSelectors;   \\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/eip/2535/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.12;\\r\\n\\r\\nimport { IDiamond } from \\\"./IDiamond.sol\\\";\\r\\n\\r\\ninterface IDiamondCut is IDiamond {    \\r\\n    function diamondCut(\\r\\n        FacetCut[] calldata _diamondCut,\\r\\n        address _init,\\r\\n        bytes memory _calldata\\r\\n    ) external;    \\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/eip/2535/lib/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.12;\\r\\n\\r\\nimport { IDiamond } from \\\"../interfaces/IDiamond.sol\\\";\\r\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\r\\nlibrary LibDiamond {\\r\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\r\\n    struct DiamondStorage {\\r\\n        //facet's function selector\\r\\n        mapping(address=>bytes4[]) FacetAddressToSelectors;\\r\\n        //all facets\\r\\n        address[] facets;\\r\\n        //selector corresponding facet\\r\\n        mapping(bytes4=>address)  SelectorsToFacetAddress;\\r\\n        //\\r\\n        mapping(bytes4 => bool) supportedInterfaces;\\r\\n        // owner of the contract\\r\\n        address contractOwner;\\r\\n\\r\\n\\r\\n        //Allows access to the database whitelist\\r\\n        mapping(address=>bool) dBControlWhitelist;\\r\\n    }\\r\\n\\r\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\r\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    function setContractOwner(address newOwner) internal {\\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        address previousOwner = ds.contractOwner;\\r\\n        ds.contractOwner = newOwner;\\r\\n        emit OwnershipTransferred(previousOwner, newOwner);\\r\\n    }\\r\\n\\r\\n    function contractOwner() internal view returns (address contractOwner_) {\\r\\n        contractOwner_ = diamondStorage().contractOwner;\\r\\n    }\\r\\n\\r\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address init, bytes data);\\r\\n    event SetDBControlWhitelist(address[]  _lists,bool[]  _status);\\r\\n    function setDBControlWhitelist(address[] memory _lists,bool[] memory _status) internal {\\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        for(uint256 i;i<_lists.length;i++){\\r\\n            ds.dBControlWhitelist[_lists[i]]=_status[i];\\r\\n        }\\r\\n        emit SetDBControlWhitelist(_lists,_status);\\r\\n    }\\r\\n\\r\\n    function diamondCut(\\r\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\r\\n        address _init,\\r\\n        bytes memory _calldata\\r\\n    ) internal {\\r\\n          for(uint256 i=0;i<_diamondCut.length;i++){\\r\\n              require(_diamondCut[i].facetAddress!=address(0),\\\"facets must be valid address\\\");  \\r\\n              enforceHasContractCode(_diamondCut[i].facetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\r\\n               if(_diamondCut[i].addSelectors.length>0){\\r\\n                  addFunctions(_diamondCut[i].facetAddress,_diamondCut[i].addSelectors);   \\r\\n               }\\r\\n\\r\\n               if(_diamondCut[i].removeSelectors.length>0){\\r\\n                  removeFunctions(_diamondCut[i].facetAddress,_diamondCut[i].removeSelectors); \\r\\n               }\\r\\n          }\\r\\n          initializeDiamondCut(_init,_calldata);\\r\\n          emit DiamondCut(_diamondCut,_init,_calldata);\\r\\n    }\\r\\n\\r\\n\\r\\n    function addFunctions(address facetAddress, bytes4[] memory functionSelectors) internal {     \\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        for(uint256 i=0;i<functionSelectors.length;i++){\\r\\n              require(ds.SelectorsToFacetAddress[functionSelectors[i]]==address(0),\\\"selector have already added\\\");\\r\\n              ds.SelectorsToFacetAddress[functionSelectors[i]]=facetAddress;\\r\\n              ds.FacetAddressToSelectors[facetAddress].push(functionSelectors[i]);\\r\\n        }\\r\\n\\r\\n        address[] memory facets=ds.facets;\\r\\n        bool isExist;\\r\\n        for(uint256 i=0;i<facets.length;i++){\\r\\n            if(facets[i]==facetAddress){\\r\\n                isExist=true;\\r\\n            }\\r\\n        }\\r\\n        if(!isExist){\\r\\n             ds.facets.push(facetAddress);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function removeFunctions(address facetAddress, bytes4[] memory functionSelectors) internal {      \\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        for(uint256 i=0;i<functionSelectors.length;i++){\\r\\n            require(ds.SelectorsToFacetAddress[functionSelectors[i]]!=address(0),\\\"selector inexistence\\\");\\r\\n            delete ds.SelectorsToFacetAddress[functionSelectors[i]];\\r\\n            bytes4[] memory selectors=ds.FacetAddressToSelectors[facetAddress];\\r\\n            for(uint256 j=0;j<selectors.length;j++){\\r\\n                 if(selectors[j]==functionSelectors[i]){\\r\\n                      ds.FacetAddressToSelectors[facetAddress][j]=ds.FacetAddressToSelectors[facetAddress][selectors.length-1];\\r\\n                      ds.FacetAddressToSelectors[facetAddress].pop();\\r\\n                 }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\r\\n        if (_init == address(0)) {\\r\\n            return;\\r\\n        }\\r\\n        enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");        \\r\\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\\r\\n        if (!success) {\\r\\n            if (error.length > 0) {\\r\\n                // bubble up error\\r\\n                /// @solidity memory-safe-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(error)\\r\\n                    revert(add(32, error), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(\\\"delegatecall fail\\\");\\r\\n            }\\r\\n        }        \\r\\n    }\\r\\n\\r\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\r\\n        uint256 contractSize;\\r\\n        assembly {\\r\\n            contractSize := extcodesize(_contract)\\r\\n        }\\r\\n        require(contractSize != 0,_errorMessage);  \\r\\n    }\\r\\n\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"addSelectors\",\"type\":\"bytes4[]\"},{\"internalType\":\"bytes4[]\",\"name\":\"removeSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamond.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"_init\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"diamondCut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DiamondCutFacet", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}