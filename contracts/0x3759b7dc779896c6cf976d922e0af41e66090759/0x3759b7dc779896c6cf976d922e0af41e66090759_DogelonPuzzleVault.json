{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/DogelonPuzzleVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\n\\n/**\\n * @title DogelonPuzzleVault\\n * @dev This contract facilitates a riddle game where participants can win\\n * ETH, ERC20, or ERC721 prizes by guessing correctly.\\n */\\ncontract DogelonPuzzleVault is IERC721Receiver {\\n\\n  // Struct for storing ETH prizes\\n  struct EthVault {\\n    uint256 id;\\n    uint256 amount;\\n    address claimer;\\n  }\\n\\n  // Struct for returning ETH vaults from view functions\\n  struct EthVaultWithAnswerHash {\\n    uint256 id;\\n    uint256 answerHash;\\n    uint256 amount;\\n    address claimer;\\n  }\\n\\n  // Struct for storing ERC20 prizes\\n  struct Erc20Vault {\\n    uint256 id;\\n    uint256 amount;\\n    address addr; // Token address\\n    address claimer;\\n  }\\n\\n  // Struct for returning ERC20 vaults from view functions\\n  struct Erc20VaultWithAnswerHash {\\n    uint256 id;\\n    uint256 answerHash;\\n    uint256 amount;\\n    address addr; // Token address\\n    address claimer;\\n  }\\n\\n  // Struct for storing ERC721 prizes\\n  struct Erc721Vault {\\n    uint256 id;\\n    address addr; // Token address\\n    uint256 tokenId;\\n    address claimer;\\n  }\\n\\n  // Struct for returning ERC20 vaults from view functions\\n  struct Erc721VaultWithAnswerHash {\\n    uint256 id;\\n    uint256 answerHash;\\n    address addr; // Token address\\n    uint256 tokenId;\\n    address claimer;\\n  }\\n\\n  // Vault metadata using its hash and type (0 for ETH, 1 for ERC20, 2 for ERC721)\\n  struct VaultById {\\n    uint256 answerHash; // Hash of the correct answer\\n    uint256 vaultType;\\n  }\\n\\n  // Commitment struct to handle the commit-reveal mechanism\\n  struct Commitment {\\n    bytes32 saltedHash; // Hash of the committed answer + salt\\n    address committer; // Address of the user who made the commitment\\n    uint256 blockNumber; // Block number when the commit was made\\n  }\\n\\n  // Mapping to store ETH prize info using a combined key (answerHash + id)\\n  mapping(uint256 => EthVault) public ethVaults;\\n\\n  // Mapping to store ERC20 prize info using a combined key (answerHash + id)\\n  mapping(uint256 => Erc20Vault) public erc20Vaults;\\n\\n  // Mapping to store ERC721 prize info using a combined key (answerHash + id)\\n  mapping(uint256 => Erc721Vault) public erc721Vaults;\\n\\n  // Array to store all vaults by ID for easy iteration\\n  VaultById[] public vaultsById;\\n\\n  // Mapping to store user commitments\\n  mapping(address => Commitment) public commitments;\\n\\n  // Contract owner's address\\n  address public owner;\\n\\n  // Events\\n  event EthVaultCreated(uint256 indexed vaultId, uint256 amount);\\n  event Erc20VaultCreated(uint256 indexed vaultId, uint256 amount, address tokenAddress);\\n  event Erc721VaultCreated(uint256 indexed vaultId, address tokenAddress, uint256 tokenId);\\n  event VaultModified(uint256 indexed vaultId); // Split into three events, showing updated vault info\\n  event VaultDeleted(uint256 indexed vaultId);\\n  event VaultClaimed(uint256 vaultId, uint256 when, address by, uint256 vaultType);\\n\\n  // Modifier to ensure only the contract owner can call a function\\n  modifier onlyOwner() {\\n    require(msg.sender == owner, \\\"Must be owner\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Constructor initializes the contract setting the deployer as the owner.\\n   */\\n  constructor() {\\n    owner = msg.sender;\\n  }\\n\\n  /**\\n   * @dev Helper function to get the combined key used in the vault mappings.\\n   * @param hash Hash of the answer.\\n   * @param id Vault ID.\\n   * @return Combined key.\\n   */\\n  function _getCombinedKey(uint256 hash, uint256 id) internal pure returns (uint256) {\\n    return uint256(keccak256(abi.encodePacked(hash, id)));\\n  }\\n\\n  /**\\n   * @dev Create an ETH vault with a specific hash and amount.\\n   * @param answerHash Hash of the correct answer.\\n   * @param amount Amount of ETH to be won.\\n   */\\n  function createEthVault(uint256 answerHash, uint256 amount) external onlyOwner {\\n    EthVault memory vault = EthVault(vaultsById.length, amount, address(0));\\n    uint256 combinedKey = _getCombinedKey(answerHash, vaultsById.length);\\n    ethVaults[combinedKey] = vault;\\n    vaultsById.push(VaultById(answerHash, 0));\\n    emit EthVaultCreated(vaultsById.length - 1, amount);\\n  }\\n\\n  /**\\n   * @dev Create an ERC20 vault with a specific hash, amount, and token address.\\n   * @param answerHash Hash of the correct answer.\\n   * @param amount Amount of the ERC20 token to be won.\\n   * @param addr Address of the ERC20 token.\\n   */\\n  function createErc20Vault(uint256 answerHash, uint256 amount, address addr) external onlyOwner {\\n    Erc20Vault memory vault = Erc20Vault(vaultsById.length, amount, addr, address(0));\\n    uint256 combinedKey = _getCombinedKey(answerHash, vaultsById.length);\\n    erc20Vaults[combinedKey] = vault;\\n    vaultsById.push(VaultById(answerHash, 1));\\n    emit Erc20VaultCreated(vaultsById.length - 1, amount, addr);\\n  }\\n\\n  /**\\n   * @dev Create an ERC721 vault with a specific hash, token address, and token ID.\\n   * @param answerHash Hash of the correct answer.\\n   * @param addr Address of the ERC721 token.\\n   * @param tokenId ID of the ERC721 token to be won.\\n   */\\n  function createErc721Vault(uint256 answerHash, address addr, uint256 tokenId) external onlyOwner {\\n    Erc721Vault memory vault = Erc721Vault(vaultsById.length, addr, tokenId, address(0));\\n    uint256 combinedKey = _getCombinedKey(answerHash, vaultsById.length);\\n    erc721Vaults[combinedKey] = vault;\\n    vaultsById.push(VaultById(answerHash, 2));\\n    emit Erc721VaultCreated(vaultsById.length - 1, addr, tokenId);\\n  }\\n\\n  /**\\n   * @dev Modify an existing ETH vault.\\n   * @param id ID of the vault to be modified.\\n   * @param newHash New hash for the answer.\\n   * @param newAmount New amount for the ETH prize.\\n   */\\n  function modifyEthVault(uint256 id, uint256 newHash, uint256 newAmount) external onlyOwner {\\n    require(id < vaultsById.length, \\\"Invalid vault ID\\\");\\n    require(vaultsById[id].vaultType == 0, \\\"Not an ETH vault\\\");\\n    uint256 combinedKey = _getCombinedKey(vaultsById[id].answerHash, id);\\n    EthVault storage vault = ethVaults[combinedKey];\\n    require(vault.claimer == address(0), \\\"Cannot modify a claimed vault\\\");\\n    require(!(vault.id == 0 && vault.amount == 0 && vault.claimer == address(0)), \\\"Vault does not exist\\\");\\n\\n    vaultsById[id].answerHash = newHash;\\n    vault.amount = newAmount;\\n\\n    uint256 newCombinedKey = _getCombinedKey(newHash, id);\\n    if (newCombinedKey != combinedKey) {\\n      ethVaults[newCombinedKey] = vault;\\n      delete ethVaults[combinedKey];\\n    }\\n\\n    emit VaultModified(id);\\n  }\\n\\n  /**\\n   * @dev Modify an existing ERC20 vault.\\n   * @param id ID of the vault to be modified.\\n   * @param newHash New hash for the answer.\\n   * @param newAmount New amount for the ERC20 prize.\\n   * @param newAddr New address for the ERC20 token.\\n   */\\n  function modifyErc20Vault(uint256 id, uint256 newHash, uint256 newAmount, address newAddr) external onlyOwner {\\n    require(id < vaultsById.length, \\\"Invalid vault ID\\\");\\n    require(vaultsById[id].vaultType == 1, \\\"Not an ERC20 vault\\\");\\n    uint256 combinedKey = _getCombinedKey(vaultsById[id].answerHash, id);\\n    Erc20Vault storage vault = erc20Vaults[combinedKey];\\n    require(vault.claimer == address(0), \\\"Cannot modify a claimed vault\\\");\\n    require(!(vault.id == 0 && vault.addr == address(0) && vault.amount == 0 && vault.claimer == address(0)), \\\"Vault does not exist\\\");\\n    vaultsById[id].answerHash = newHash;\\n    vault.amount = newAmount;\\n    vault.addr = newAddr;\\n\\n    uint256 newCombinedKey = _getCombinedKey(newHash, id);\\n    if (newCombinedKey != combinedKey) {\\n      erc20Vaults[newCombinedKey] = vault;\\n      delete erc20Vaults[combinedKey];\\n    }\\n\\n    emit VaultModified(id);\\n  }\\n\\n  /**\\n   * @dev Modify an existing ERC721 vault.\\n   * @param id ID of the vault to be modified.\\n   * @param newHash New hash for the answer.\\n   * @param newAddr New address for the ERC721 token.\\n   * @param newTokenId New token ID for the ERC721 prize.\\n   */\\n  function modifyErc721Vault(uint256 id, uint256 newHash, address newAddr, uint256 newTokenId) external onlyOwner {\\n    require(id < vaultsById.length, \\\"Invalid vault ID\\\");\\n    require(vaultsById[id].vaultType == 2, \\\"Not an ERC721 vault\\\");\\n    uint256 combinedKey = _getCombinedKey(vaultsById[id].answerHash, id);\\n    Erc721Vault storage vault = erc721Vaults[combinedKey];\\n    require(vault.claimer == address(0), \\\"Cannot modify a claimed vault\\\");\\n    require(!(vault.id == 0 && vault.addr == address(0) && vault.tokenId == 0 && vault.claimer == address(0)), \\\"Vault does not exist\\\");\\n    vaultsById[id].answerHash = newHash;\\n    vault.addr = newAddr;\\n    vault.tokenId = newTokenId;\\n\\n    uint256 newCombinedKey = _getCombinedKey(newHash, id);\\n    if (newCombinedKey != combinedKey) {\\n      erc721Vaults[newCombinedKey] = vault;\\n      delete erc721Vaults[combinedKey];\\n    }\\n\\n    emit VaultModified(id);\\n  }\\n\\n  /**\\n   * @dev Delete an existing ETH vault.\\n   * @param id ID of the vault to be deleted.\\n   */\\n  function deleteEthVault(uint256 id) external onlyOwner {\\n    require(id < vaultsById.length, \\\"Invalid vault ID\\\");\\n    require(vaultsById[id].vaultType == 0, \\\"Not an ETH vault\\\");\\n    uint256 combinedKey = _getCombinedKey(vaultsById[id].answerHash, id);\\n    EthVault storage vault = ethVaults[combinedKey];\\n    require(!(vault.id == 0 && vault.amount == 0 && vault.claimer == address(0)), \\\"Vault does not exist\\\");\\n    delete ethVaults[combinedKey];\\n    delete vaultsById[id];\\n    emit VaultDeleted(id);\\n  }\\n\\n  /**\\n   * @dev Delete an existing ERC20 vault.\\n   * @param id ID of the vault to be deleted.\\n   */\\n  function deleteErc20Vault(uint256 id) external onlyOwner {\\n    require(id < vaultsById.length, \\\"Invalid vault ID\\\");\\n    require(vaultsById[id].vaultType == 1, \\\"Not an ERC20 vault\\\");\\n    uint256 combinedKey = _getCombinedKey(vaultsById[id].answerHash, id);\\n    Erc20Vault storage vault = erc20Vaults[combinedKey];\\n    require(!(vault.id == 0 && vault.addr == address(0) && vault.amount == 0 && vault.claimer == address(0)), \\\"Vault does not exist\\\");\\n    delete erc20Vaults[combinedKey];\\n    delete vaultsById[id];\\n    emit VaultDeleted(id);\\n  }\\n\\n  /**\\n   * @dev Delete an existing ERC721 vault.\\n   * @param id ID of the vault to be deleted.\\n   */\\n  function deleteErc721Vault(uint256 id) external onlyOwner {\\n    require(id < vaultsById.length, \\\"Invalid vault ID\\\");\\n    require(vaultsById[id].vaultType == 2, \\\"Not an ERC721 vault\\\");\\n    uint256 combinedKey = _getCombinedKey(vaultsById[id].answerHash, id);\\n    Erc721Vault storage vault = erc721Vaults[combinedKey];\\n    require(!(vault.id == 0 && vault.addr == address(0) && vault.tokenId == 0 && vault.claimer == address(0)), \\\"Vault does not exist\\\");\\n    delete erc721Vaults[combinedKey];\\n    delete vaultsById[id];\\n    emit VaultDeleted(id);\\n  }\\n\\n  /**\\n   * @dev Players use this function to commit their guess for a prize. This prevents front-running.\\n   * @param saltedHash Hash of the player's guess + a random salt.\\n   */\\n  function commitGuess(bytes32 saltedHash) external {\\n    commitments[msg.sender] = Commitment(saltedHash, msg.sender, block.number);\\n  }\\n\\n  /**\\n   * @dev Players use this function to reveal their original guess and claim a prize.\\n   * @param guess The original guess made by the player.\\n   * @param salt The random salt used in the commit.\\n   * @param id ID of the vault.\\n   */\\n  function revealGuess(string memory guess, uint256 salt, uint256 id) external {\\n    require(id < vaultsById.length, \\\"Invalid vault ID\\\");\\n\\n    bytes32 hashedGuess = keccak256(abi.encodePacked(guess, salt));\\n    Commitment memory userCommit = commitments[msg.sender];\\n\\n    require(block.number > userCommit.blockNumber, \\\"Trying to pull a fast one, eh?\\\");\\n    require(msg.sender == userCommit.committer, \\\"Imposter!\\\");\\n    require(hashedGuess == userCommit.saltedHash, \\\"There seems to be some kind of mix-up...\\\");\\n\\n    uint256 hash = uint256(keccak256(abi.encodePacked(guess)));\\n    VaultById memory targetVault = vaultsById[id];\\n\\n    require(hash == targetVault.answerHash, \\\"Wrong!\\\");\\n\\n    // Distribute prize\\n    uint256 combinedKey = _getCombinedKey(hash, id);\\n    if (targetVault.vaultType == 0) {\\n      EthVault storage vault = ethVaults[combinedKey];\\n      require(vault.claimer == address(0), \\\"Vault already claimed!\\\");\\n      payable(msg.sender).transfer(vault.amount);\\n      vault.claimer = msg.sender;\\n    } else if (targetVault.vaultType == 1) {\\n      Erc20Vault storage vault = erc20Vaults[combinedKey];\\n      require(vault.claimer == address(0), \\\"Vault already claimed!\\\");\\n      IERC20(vault.addr).transfer(msg.sender, vault.amount);\\n      vault.claimer = msg.sender;\\n    } else if (targetVault.vaultType == 2) {\\n      Erc721Vault storage vault = erc721Vaults[combinedKey];\\n      require(vault.claimer == address(0), \\\"Vault already claimed!\\\");\\n      IERC721(vault.addr).transferFrom(address(this), msg.sender, vault.tokenId);\\n      vault.claimer = msg.sender;\\n    }\\n\\n    delete commitments[msg.sender];\\n    emit VaultClaimed(id, block.timestamp, msg.sender, targetVault.vaultType);\\n  }\\n\\n  /**\\n   * @dev Allows the owner to retrieve any ETH that might be accidentally sent to the contract.\\n   */\\n  function sweepEth() external onlyOwner {\\n    payable(owner).transfer(address(this).balance);\\n  }\\n\\n  /**\\n   * @dev Allows the owner to retrieve any ERC20 tokens that might be accidentally sent to the contract.\\n   * @param erc20s Array of ERC20 token addresses to be retrieved.\\n   */\\n  function sweepErc20(address[] memory erc20s) external onlyOwner {\\n    for (uint256 i = 0; i < erc20s.length; i++) {\\n      uint256 amount = IERC20(erc20s[i]).balanceOf(address(this));\\n      IERC20(erc20s[i]).transfer(owner, amount);\\n    }\\n  }\\n\\n  /**\\n   * @dev Allows the owner to retrieve any ERC721 tokens that might be accidentally sent to the contract.\\n   * @param erc721s Array of ERC721 token addresses to be retrieved.\\n   * @param tokenIds 2D array of token IDs for each ERC721 token to be retrieved.\\n   */\\n  function sweepErc721(address[] memory erc721s, uint256[][] memory tokenIds) external onlyOwner {\\n    for (uint256 i = 0; i < erc721s.length; i++) {\\n      for (uint256 j = 0; j < tokenIds[i].length; j++) {\\n        IERC721(erc721s[i]).transferFrom(address(this), owner, tokenIds[i][j]);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Fetches the details of a range of vaults.\\n   * @param first The number of vaults to retrieve starting from `_after`.\\n   * @param _after The last vault ID to start from.\\n   * @return Arrays of EthVault, Erc20Vault, and Erc721Vault. Also returns a boolean indicating if there are more vaults.\\n   */\\n  function getVaults(uint256 first, uint256 _after) external view\\n  returns (\\n    EthVaultWithAnswerHash[] memory,\\n    Erc20VaultWithAnswerHash[] memory,\\n    Erc721VaultWithAnswerHash[] memory,\\n    bool hasMore\\n  ) {\\n    require(first > 0, \\\"First must be greater than 0\\\");\\n\\n    uint256 ethCount = 0;\\n    uint256 erc20Count = 0;\\n    uint256 erc721Count = 0;\\n\\n    // Count how many of each vault type we have in the specified range\\n    for (uint256 i = _after; i < _after + first && i < vaultsById.length; i++) {\\n      VaultById memory vaultInfo = vaultsById[i];\\n      if (vaultInfo.answerHash == 0) continue;\\n      uint256 combinedKey = _getCombinedKey(vaultInfo.answerHash, i);\\n      if (vaultInfo.vaultType == 0) {\\n        ethCount++;\\n      } else if (vaultInfo.vaultType == 1) {\\n        erc20Count++;\\n      } else if (vaultInfo.vaultType == 2) {\\n        erc721Count++;\\n      }\\n    }\\n\\n    EthVaultWithAnswerHash[] memory _ethVaults = new EthVaultWithAnswerHash[](ethCount);\\n    Erc20VaultWithAnswerHash[] memory _erc20Vaults = new Erc20VaultWithAnswerHash[](erc20Count);\\n    Erc721VaultWithAnswerHash[] memory _erc721Vaults = new Erc721VaultWithAnswerHash[](erc721Count);\\n\\n    uint256 ethCounter = 0;\\n    uint256 erc20Counter = 0;\\n    uint256 erc721Counter = 0;\\n\\n    // Populate the arrays\\n    for (uint256 i = _after; i < _after + first && i < vaultsById.length; i++) {\\n      VaultById memory vaultInfo = vaultsById[i];\\n      uint256 combinedKey = _getCombinedKey(vaultInfo.answerHash, i);\\n      if (vaultInfo.vaultType == 0 && ethCounter < ethCount) {\\n        EthVault memory ethVault = ethVaults[combinedKey];\\n        _ethVaults[ethCounter++] = EthVaultWithAnswerHash(\\n          ethVault.id,\\n          vaultInfo.answerHash,\\n          ethVault.amount,\\n          ethVault.claimer\\n        );\\n      } else if (vaultInfo.vaultType == 1 && erc20Counter < erc20Count) {\\n        Erc20Vault memory erc20Vault = erc20Vaults[combinedKey];\\n        _erc20Vaults[erc20Counter++] = Erc20VaultWithAnswerHash(\\n          erc20Vault.id,\\n          vaultInfo.answerHash,\\n          erc20Vault.amount,\\n          erc20Vault.addr,\\n          erc20Vault.claimer\\n        );\\n      } else if (vaultInfo.vaultType == 2 && erc721Counter < erc721Count) {\\n        Erc721Vault memory erc721Vault = erc721Vaults[combinedKey];\\n        _erc721Vaults[erc721Counter++] = Erc721VaultWithAnswerHash(\\n          erc721Vault.id,\\n          vaultInfo.answerHash,\\n          erc721Vault.addr,\\n          erc721Vault.tokenId,\\n          erc721Vault.claimer\\n        );\\n      }\\n    }\\n\\n    hasMore = _after + first < vaultsById.length;\\n    return (_ethVaults, _erc20Vaults, _erc721Vaults, hasMore);\\n  }\\n\\n  /**\\n   * @notice External function to receive Ether.\\n   * @dev This function is intentionally left empty, allowing the contract to accept plain Ether transfers.\\n   */\\n  receive() external payable {}\\n\\n  /**\\n   * @dev Handles the receipt of a single ERC721 token type.\\n   *\\n   * @param operator The address which called `safeTransferFrom` function\\n   * @param from The address which previously owned the token\\n   * @param tokenId The NFT identifier which is being transferred\\n   * @param data Additional data with no specified format\\n   * @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n   */\\n  function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) public override returns (bytes4) {\\n    return this.onERC721Received.selector;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"Erc20VaultCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Erc721VaultCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EthVaultCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultType\",\"type\":\"uint256\"}],\"name\":\"VaultClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"VaultDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"VaultModified\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"saltedHash\",\"type\":\"bytes32\"}],\"name\":\"commitGuess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"commitments\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"saltedHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"committer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"answerHash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"createErc20Vault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"answerHash\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"createErc721Vault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"answerHash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"createEthVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"deleteErc20Vault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"deleteErc721Vault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"deleteEthVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"erc20Vaults\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"erc721Vaults\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ethVaults\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"first\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_after\",\"type\":\"uint256\"}],\"name\":\"getVaults\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"answerHash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"}],\"internalType\":\"struct DogelonPuzzleVault.EthVaultWithAnswerHash[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"answerHash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"}],\"internalType\":\"struct DogelonPuzzleVault.Erc20VaultWithAnswerHash[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"answerHash\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"}],\"internalType\":\"struct DogelonPuzzleVault.Erc721VaultWithAnswerHash[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"hasMore\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newHash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newAddr\",\"type\":\"address\"}],\"name\":\"modifyErc20Vault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newHash\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newTokenId\",\"type\":\"uint256\"}],\"name\":\"modifyErc721Vault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newHash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"modifyEthVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"guess\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"revealGuess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"erc20s\",\"type\":\"address[]\"}],\"name\":\"sweepErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"erc721s\",\"type\":\"address[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"tokenIds\",\"type\":\"uint256[][]\"}],\"name\":\"sweepErc721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sweepEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vaultsById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"answerHash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultType\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DogelonPuzzleVault", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}