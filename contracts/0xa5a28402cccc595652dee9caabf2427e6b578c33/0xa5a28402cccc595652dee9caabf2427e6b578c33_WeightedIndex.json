{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/libraries/FixedPoint96.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.4.0;\\n\\n/// @title FixedPoint96\\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\\n/// @dev Used in SqrtPriceMath.sol\\nlibrary FixedPoint96 {\\n    uint8 internal constant RESOLUTION = 96;\\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Immutable state\\n/// @notice Functions that return immutable state of the router\\ninterface IPeripheryImmutableState {\\n    /// @return Returns the address of the Uniswap V3 factory\\n    function factory() external view returns (address);\\n\\n    /// @return Returns the address of WETH9\\n    function WETH9() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.5;\\npragma abicoder v2;\\n\\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter is IUniswapV3SwapCallback {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-periphery/contracts/libraries/PoolAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\\nlibrary PoolAddress {\\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\\n\\n    /// @notice The identifying key of the pool\\n    struct PoolKey {\\n        address token0;\\n        address token1;\\n        uint24 fee;\\n    }\\n\\n    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\\n    /// @param tokenA The first token of a pool, unsorted\\n    /// @param tokenB The second token of a pool, unsorted\\n    /// @param fee The fee level of the pool\\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\\n    function getPoolKey(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) internal pure returns (PoolKey memory) {\\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\\n    }\\n\\n    /// @notice Deterministically computes the pool address given the factory and PoolKey\\n    /// @param factory The Uniswap V3 factory contract address\\n    /// @param key The PoolKey\\n    /// @return pool The contract address of the V3 pool\\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\\n        require(key.token0 < key.token1);\\n        pool = address(\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        hex'ff',\\n                        factory,\\n                        keccak256(abi.encode(key.token0, key.token1, key.fee)),\\n                        POOL_INIT_CODE_HASH\\n                    )\\n                )\\n            )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DecentralizedIndex.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\nimport './interfaces/IDecentralizedIndex.sol';\\nimport './interfaces/IERC20Metadata.sol';\\nimport './interfaces/IFlashLoanRecipient.sol';\\nimport './interfaces/ITokenRewards.sol';\\nimport './interfaces/IUniswapV2Factory.sol';\\nimport './interfaces/IUniswapV2Router02.sol';\\nimport './StakingPoolToken.sol';\\n\\nabstract contract DecentralizedIndex is IDecentralizedIndex, ERC20 {\\n  using SafeERC20 for IERC20;\\n\\n  uint256 public constant override FLASH_FEE_DAI = 10; // 10 DAI\\n  uint256 public immutable override BOND_FEE;\\n  uint256 public immutable override DEBOND_FEE;\\n  address immutable V2_ROUTER;\\n  address immutable V2_POOL;\\n  address immutable DAI;\\n  address immutable WETH;\\n  IV3TwapUtilities immutable V3_TWAP_UTILS;\\n\\n  IndexType public override indexType;\\n  uint256 public override created;\\n  address public override lpStakingPool;\\n  address public override lpRewardsToken;\\n\\n  IndexAssetInfo[] public indexTokens;\\n  mapping(address => bool) _isTokenInIndex;\\n  mapping(address => uint256) _fundTokenIdx;\\n\\n  bool _swapping;\\n  bool _swapOn = true;\\n  bool _unlocked = true;\\n\\n  event FlashLoan(\\n    address indexed executor,\\n    address indexed recipient,\\n    address token,\\n    uint256 amount\\n  );\\n\\n  modifier lock() {\\n    require(_unlocked, 'LOCKED');\\n    _unlocked = false;\\n    _;\\n    _unlocked = true;\\n  }\\n\\n  modifier noSwap() {\\n    _swapOn = false;\\n    _;\\n    _swapOn = true;\\n  }\\n\\n  constructor(\\n    string memory _name,\\n    string memory _symbol,\\n    uint256 _bondFee,\\n    uint256 _debondFee,\\n    address _lpRewardsToken,\\n    address _v2Router,\\n    address _dai,\\n    bool _stakeRestriction,\\n    IV3TwapUtilities _v3TwapUtilities\\n  ) ERC20(_name, _symbol) {\\n    created = block.timestamp;\\n    BOND_FEE = _bondFee;\\n    DEBOND_FEE = _debondFee;\\n    lpRewardsToken = _lpRewardsToken;\\n    V2_ROUTER = _v2Router;\\n    address _v2Pool = IUniswapV2Factory(IUniswapV2Router02(_v2Router).factory())\\n      .createPair(address(this), _dai);\\n    lpStakingPool = address(\\n      new StakingPoolToken(\\n        string(abi.encodePacked('Staked ', _name)),\\n        string(abi.encodePacked('s', _symbol)),\\n        _dai,\\n        _v2Pool,\\n        lpRewardsToken,\\n        _stakeRestriction ? _msgSender() : address(0),\\n        _v3TwapUtilities\\n      )\\n    );\\n    V2_POOL = _v2Pool;\\n    DAI = _dai;\\n    WETH = IUniswapV2Router02(_v2Router).WETH();\\n    V3_TWAP_UTILS = _v3TwapUtilities;\\n    emit Create(address(this), _msgSender());\\n  }\\n\\n  function _transfer(\\n    address _from,\\n    address _to,\\n    uint256 _amount\\n  ) internal virtual override {\\n    if (_swapOn && !_swapping) {\\n      uint256 _bal = balanceOf(address(this));\\n      uint256 _min = totalSupply() / 10000; // 0.01%\\n      if (_from != V2_POOL && _bal >= _min && balanceOf(V2_POOL) > 0) {\\n        _swapping = true;\\n        _feeSwap(\\n          _bal >= _min * 100 ? _min * 100 : _bal >= _min * 20 ? _min * 20 : _min\\n        );\\n        _swapping = false;\\n      }\\n    }\\n    super._transfer(_from, _to, _amount);\\n  }\\n\\n  function _feeSwap(uint256 _amount) internal {\\n    address[] memory path = new address[](2);\\n    path[0] = address(this);\\n    path[1] = DAI;\\n    _approve(address(this), V2_ROUTER, _amount);\\n    address _rewards = StakingPoolToken(lpStakingPool).poolRewards();\\n    IUniswapV2Router02(V2_ROUTER)\\n      .swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        _amount,\\n        0,\\n        path,\\n        _rewards,\\n        block.timestamp\\n      );\\n    uint256 _rewardsDAIBal = IERC20(DAI).balanceOf(_rewards);\\n    if (_rewardsDAIBal > 0) {\\n      ITokenRewards(_rewards).depositFromDAI(0);\\n    }\\n  }\\n\\n  function _transferAndValidate(\\n    IERC20 _token,\\n    address _sender,\\n    uint256 _amount\\n  ) internal {\\n    uint256 _balanceBefore = _token.balanceOf(address(this));\\n    _token.safeTransferFrom(_sender, address(this), _amount);\\n    require(\\n      _token.balanceOf(address(this)) >= _balanceBefore + _amount,\\n      'TFRVAL'\\n    );\\n  }\\n\\n  function _isFirstIn() internal view returns (bool) {\\n    return totalSupply() == 0;\\n  }\\n\\n  function _isLastOut(uint256 _debondAmount) internal view returns (bool) {\\n    return _debondAmount >= (totalSupply() * 98) / 100;\\n  }\\n\\n  function isAsset(address _token) public view override returns (bool) {\\n    return _isTokenInIndex[_token];\\n  }\\n\\n  function getAllAssets()\\n    external\\n    view\\n    override\\n    returns (IndexAssetInfo[] memory)\\n  {\\n    return indexTokens;\\n  }\\n\\n  function addLiquidityV2(\\n    uint256 _idxLPTokens,\\n    uint256 _daiLPTokens,\\n    uint256 _slippage // 100 == 10%, 1000 == 100%\\n  ) external override lock noSwap {\\n    uint256 _idxTokensBefore = balanceOf(address(this));\\n    uint256 _daiBefore = IERC20(DAI).balanceOf(address(this));\\n\\n    _transfer(_msgSender(), address(this), _idxLPTokens);\\n    _approve(address(this), V2_ROUTER, _idxLPTokens);\\n\\n    IERC20(DAI).safeTransferFrom(_msgSender(), address(this), _daiLPTokens);\\n    IERC20(DAI).safeIncreaseAllowance(V2_ROUTER, _daiLPTokens);\\n\\n    IUniswapV2Router02(V2_ROUTER).addLiquidity(\\n      address(this),\\n      DAI,\\n      _idxLPTokens,\\n      _daiLPTokens,\\n      (_idxLPTokens * (1000 - _slippage)) / 1000,\\n      (_daiLPTokens * (1000 - _slippage)) / 1000,\\n      _msgSender(),\\n      block.timestamp\\n    );\\n\\n    // check & refund excess tokens from LPing\\n    if (balanceOf(address(this)) > _idxTokensBefore) {\\n      _transfer(\\n        address(this),\\n        _msgSender(),\\n        balanceOf(address(this)) - _idxTokensBefore\\n      );\\n    }\\n    if (IERC20(DAI).balanceOf(address(this)) > _daiBefore) {\\n      IERC20(DAI).safeTransfer(\\n        _msgSender(),\\n        IERC20(DAI).balanceOf(address(this)) - _daiBefore\\n      );\\n    }\\n    emit AddLiquidity(_msgSender(), _idxLPTokens, _daiLPTokens);\\n  }\\n\\n  function removeLiquidityV2(\\n    uint256 _lpTokens,\\n    uint256 _minIdxTokens, // 0 == 100% slippage\\n    uint256 _minDAI // 0 == 100% slippage\\n  ) external override lock noSwap {\\n    _lpTokens = _lpTokens == 0\\n      ? IERC20(V2_POOL).balanceOf(_msgSender())\\n      : _lpTokens;\\n    require(_lpTokens > 0, 'LPREM');\\n\\n    uint256 _balBefore = IERC20(V2_POOL).balanceOf(address(this));\\n    IERC20(V2_POOL).safeTransferFrom(_msgSender(), address(this), _lpTokens);\\n    IERC20(V2_POOL).safeIncreaseAllowance(V2_ROUTER, _lpTokens);\\n    IUniswapV2Router02(V2_ROUTER).removeLiquidity(\\n      address(this),\\n      DAI,\\n      _lpTokens,\\n      _minIdxTokens,\\n      _minDAI,\\n      _msgSender(),\\n      block.timestamp\\n    );\\n    if (IERC20(V2_POOL).balanceOf(address(this)) > _balBefore) {\\n      IERC20(V2_POOL).safeTransfer(\\n        _msgSender(),\\n        IERC20(V2_POOL).balanceOf(address(this)) - _balBefore\\n      );\\n    }\\n    emit RemoveLiquidity(_msgSender(), _lpTokens);\\n  }\\n\\n  function flash(\\n    address _recipient,\\n    address _token,\\n    uint256 _amount,\\n    bytes calldata _data\\n  ) external override lock {\\n    address _rewards = StakingPoolToken(lpStakingPool).poolRewards();\\n    IERC20(DAI).safeTransferFrom(\\n      _msgSender(),\\n      _rewards,\\n      FLASH_FEE_DAI * 10 ** IERC20Metadata(DAI).decimals()\\n    );\\n    uint256 _balance = IERC20(_token).balanceOf(address(this));\\n    IERC20(_token).safeTransfer(_recipient, _amount);\\n    IFlashLoanRecipient(_recipient).callback(_data);\\n    require(IERC20(_token).balanceOf(address(this)) >= _balance, 'FLASHAFTER');\\n    emit FlashLoan(_msgSender(), _recipient, _token, _amount);\\n  }\\n\\n  function rescueERC20(address _token) external lock {\\n    // cannot withdraw tokens/assets that belong to the index\\n    require(!isAsset(_token) && _token != address(this), 'UNAVAILABLE');\\n    IERC20(_token).safeTransfer(\\n      Ownable(address(V3_TWAP_UTILS)).owner(),\\n      IERC20(_token).balanceOf(address(this))\\n    );\\n  }\\n\\n  function rescueETH() external lock {\\n    require(address(this).balance > 0, 'NOETH');\\n    _rescueETH(address(this).balance);\\n  }\\n\\n  function _rescueETH(uint256 _amount) internal {\\n    if (_amount == 0) {\\n      return;\\n    }\\n    (bool _sent, ) = Ownable(address(V3_TWAP_UTILS)).owner().call{\\n      value: _amount\\n    }('');\\n    require(_sent, 'SENT');\\n  }\\n\\n  receive() external payable {\\n    _rescueETH(msg.value);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDecentralizedIndex.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IDecentralizedIndex is IERC20 {\\n  enum IndexType {\\n    WEIGHTED,\\n    UNWEIGHTED\\n  }\\n\\n  struct IndexAssetInfo {\\n    address token;\\n    uint256 weighting;\\n    uint256 basePriceUSDX96;\\n    address c1; // arbitrary contract/address field we can use for an index\\n    uint256 q1; // arbitrary quantity/number field we can use for an index\\n  }\\n\\n  event Create(address indexed newIdx, address indexed wallet);\\n  event Bond(\\n    address indexed wallet,\\n    address indexed token,\\n    uint256 amountTokensBonded,\\n    uint256 amountTokensMinted\\n  );\\n  event Debond(address indexed wallet, uint256 amountDebonded);\\n  event AddLiquidity(\\n    address indexed wallet,\\n    uint256 amountTokens,\\n    uint256 amountDAI\\n  );\\n  event RemoveLiquidity(address indexed wallet, uint256 amountLiquidity);\\n\\n  function FLASH_FEE_DAI() external view returns (uint256);\\n\\n  function BOND_FEE() external view returns (uint256); // 1 == 0.01%, 10 == 0.1%, 100 == 1%\\n\\n  function DEBOND_FEE() external view returns (uint256); // 1 == 0.01%, 10 == 0.1%, 100 == 1%\\n\\n  function indexType() external view returns (IndexType);\\n\\n  function created() external view returns (uint256);\\n\\n  function lpStakingPool() external view returns (address);\\n\\n  function lpRewardsToken() external view returns (address);\\n\\n  function getIdxPriceUSDX96() external view returns (uint256, uint256);\\n\\n  function isAsset(address token) external view returns (bool);\\n\\n  function getAllAssets() external view returns (IndexAssetInfo[] memory);\\n\\n  function getTokenPriceUSDX96(address token) external view returns (uint256);\\n\\n  function bond(address token, uint256 amount) external;\\n\\n  function debond(\\n    uint256 amount,\\n    address[] memory token,\\n    uint8[] memory percentage\\n  ) external;\\n\\n  function addLiquidityV2(\\n    uint256 idxTokens,\\n    uint256 daiTokens,\\n    uint256 slippage\\n  ) external;\\n\\n  function removeLiquidityV2(\\n    uint256 lpTokens,\\n    uint256 minTokens,\\n    uint256 minDAI\\n  ) external;\\n\\n  function flash(\\n    address recipient,\\n    address token,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\ninterface IERC20Metadata {\\n  function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFlashLoanRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\ninterface IFlashLoanRecipient {\\n  function callback(bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPEAS.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IPEAS is IERC20 {\\n  event Burn(address indexed user, uint256 amount);\\n\\n  function burn(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStakingPoolToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\ninterface IStakingPoolToken {\\n  event Stake(address indexed executor, address indexed user, uint256 amount);\\n\\n  event Unstake(address indexed user, uint256 amount);\\n\\n  function indexFund() external view returns (address);\\n\\n  function stakingToken() external view returns (address);\\n\\n  function poolRewards() external view returns (address);\\n\\n  function stakeUserRestriction() external view returns (address);\\n\\n  function stake(address user, uint256 amount) external;\\n\\n  function unstake(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\ninterface ITokenRewards {\\n  event AddShares(address indexed wallet, uint256 amount);\\n\\n  event RemoveShares(address indexed wallet, uint256 amount);\\n\\n  event ClaimReward(address indexed wallet);\\n\\n  event DistributeReward(address indexed wallet, uint256 amount);\\n\\n  event DepositRewards(address indexed wallet, uint256 amount);\\n\\n  function totalShares() external view returns (uint256);\\n\\n  function totalStakers() external view returns (uint256);\\n\\n  function rewardsToken() external view returns (address);\\n\\n  function trackingToken() external view returns (address);\\n\\n  function depositFromDAI(uint256 amount) external;\\n\\n  function depositRewards(uint256 amount) external;\\n\\n  function claimReward(address wallet) external;\\n\\n  function setShares(\\n    address wallet,\\n    uint256 amount,\\n    bool sharesRemoving\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\ninterface IUniswapV2Factory {\\n  function createPair(\\n    address tokenA,\\n    address tokenB\\n  ) external returns (address pair);\\n\\n  function getPair(\\n    address tokenA,\\n    address tokenB\\n  ) external view returns (address pair);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\ninterface IUniswapV2Pair {\\n  function token0() external view returns (address);\\n\\n  function token1() external view returns (address);\\n\\n  function getReserves()\\n    external\\n    view\\n    returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\ninterface IUniswapV2Router02 {\\n  function factory() external view returns (address);\\n\\n  function WETH() external view returns (address);\\n\\n  function addLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint amountADesired,\\n    uint amountBDesired,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n  function removeLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint liquidity,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountA, uint amountB);\\n\\n  function swapETHForExactTokens(\\n    uint256 amountOut,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external payable returns (uint256[] memory amounts);\\n\\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IV3TwapUtilities.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\ninterface IV3TwapUtilities {\\n  function getV3Pool(\\n    address v3Factory,\\n    address token0,\\n    address token1,\\n    uint24 poolFee\\n  ) external view returns (address);\\n\\n  function getPoolPriceUSDX96(\\n    address pricePool,\\n    address nativeStablePool,\\n    address WETH9\\n  ) external view returns (uint256);\\n\\n  function sqrtPriceX96FromPoolAndInterval(\\n    address pool\\n  ) external view returns (uint160);\\n\\n  function priceX96FromSqrtPriceX96(\\n    uint160 sqrtPriceX96\\n  ) external pure returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/BokkyPooBahsDateTimeLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\n// ----------------------------------------------------------------------------\\n// BokkyPooBah's DateTime Library v1.00\\n//\\n// A gas-efficient Solidity date and time library\\n//\\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\n//\\n// Tested date range 1970/01/01 to 2345/12/31\\n//\\n// Conventions:\\n// Unit      | Range         | Notes\\n// :-------- |:-------------:|:-----\\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\\n// year      | 1970 ... 2345 |\\n// month     | 1 ... 12      |\\n// day       | 1 ... 31      |\\n// hour      | 0 ... 23      |\\n// minute    | 0 ... 59      |\\n// second    | 0 ... 59      |\\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\\n//\\n//\\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018.\\n//\\n// GNU Lesser General Public License 3.0\\n// https://www.gnu.org/licenses/lgpl-3.0.en.html\\n// ----------------------------------------------------------------------------\\n\\nlibrary BokkyPooBahsDateTimeLibrary {\\n  uint constant SECONDS_PER_DAY = 24 * 60 * 60;\\n  int constant OFFSET19700101 = 2440588;\\n\\n  // ------------------------------------------------------------------------\\n  // Calculate year/month/day from the number of days since 1970/01/01 using\\n  // the date conversion algorithm from\\n  //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n  // and adding the offset 2440588 so that 1970/01/01 is day 0\\n  //\\n  // int L = days + 68569 + offset\\n  // int N = 4 * L / 146097\\n  // L = L - (146097 * N + 3) / 4\\n  // year = 4000 * (L + 1) / 1461001\\n  // L = L - 1461 * year / 4 + 31\\n  // month = 80 * L / 2447\\n  // dd = L - 2447 * month / 80\\n  // L = month / 11\\n  // month = month + 2 - 12 * L\\n  // year = 100 * (N - 49) + year + L\\n  // ------------------------------------------------------------------------\\n  function _daysToDate(\\n    uint _days\\n  ) internal pure returns (uint year, uint month, uint day) {\\n    int __days = int(_days);\\n\\n    int L = __days + 68569 + OFFSET19700101;\\n    int N = (4 * L) / 146097;\\n    L = L - (146097 * N + 3) / 4;\\n    int _year = (4000 * (L + 1)) / 1461001;\\n    L = L - (1461 * _year) / 4 + 31;\\n    int _month = (80 * L) / 2447;\\n    int _day = L - (2447 * _month) / 80;\\n    L = _month / 11;\\n    _month = _month + 2 - 12 * L;\\n    _year = 100 * (N - 49) + _year + L;\\n\\n    year = uint(_year);\\n    month = uint(_month);\\n    day = uint(_day);\\n  }\\n\\n  function timestampToDate(\\n    uint timestamp\\n  ) internal pure returns (uint year, uint month, uint day) {\\n    (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/StakingPoolToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\n\\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\nimport './interfaces/IStakingPoolToken.sol';\\nimport './TokenRewards.sol';\\n\\ncontract StakingPoolToken is IStakingPoolToken, ERC20 {\\n  using SafeERC20 for IERC20;\\n\\n  address public override indexFund;\\n  address public override stakingToken;\\n  address public override poolRewards;\\n  address public override stakeUserRestriction;\\n\\n  modifier onlyRestricted() {\\n    require(_msgSender() == stakeUserRestriction, 'RESUSERAUTH');\\n    _;\\n  }\\n\\n  constructor(\\n    string memory _name,\\n    string memory _symbol,\\n    address _dai,\\n    address _stakingToken,\\n    address _rewardsToken,\\n    address _stakeUserRestriction,\\n    IV3TwapUtilities _v3TwapUtilities\\n  ) ERC20(_name, _symbol) {\\n    indexFund = _msgSender();\\n    stakingToken = _stakingToken;\\n    stakeUserRestriction = _stakeUserRestriction;\\n    poolRewards = address(\\n      new TokenRewards(_v3TwapUtilities, _dai, address(this), _rewardsToken)\\n    );\\n  }\\n\\n  function stake(address _user, uint256 _amount) external override {\\n    if (stakeUserRestriction != address(0)) {\\n      require(_user == stakeUserRestriction, 'RESTRICT');\\n    }\\n    _mint(_user, _amount);\\n    IERC20(stakingToken).safeTransferFrom(_msgSender(), address(this), _amount);\\n    emit Stake(_msgSender(), _user, _amount);\\n  }\\n\\n  function unstake(uint256 _amount) external override {\\n    _burn(_msgSender(), _amount);\\n    IERC20(stakingToken).safeTransfer(_msgSender(), _amount);\\n    emit Unstake(_msgSender(), _amount);\\n  }\\n\\n  function removeStakeUserRestriction() external onlyRestricted {\\n    stakeUserRestriction = address(0);\\n  }\\n\\n  function setStakeUserRestriction(address _user) external onlyRestricted {\\n    stakeUserRestriction = _user;\\n  }\\n\\n  function _transfer(\\n    address _from,\\n    address _to,\\n    uint256 _amount\\n  ) internal virtual override {\\n    super._transfer(_from, _to, _amount);\\n    _afterTokenTransfer(_from, _to, _amount);\\n  }\\n\\n  function _mint(address _to, uint256 _amount) internal override {\\n    super._mint(_to, _amount);\\n    _afterTokenTransfer(address(0), _to, _amount);\\n  }\\n\\n  function _burn(address _from, uint256 _amount) internal override {\\n    super._burn(_from, _amount);\\n    _afterTokenTransfer(_from, address(0), _amount);\\n  }\\n\\n  function _afterTokenTransfer(\\n    address _from,\\n    address _to,\\n    uint256 _amount\\n  ) internal {\\n    if (_from != address(0) && _from != address(0xdead)) {\\n      TokenRewards(poolRewards).setShares(_from, _amount, true);\\n    }\\n    if (_to != address(0) && _to != address(0xdead)) {\\n      TokenRewards(poolRewards).setShares(_to, _amount, false);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/TokenRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\\nimport '@openzeppelin/contracts/utils/Context.sol';\\nimport '@uniswap/v3-core/contracts/libraries/FixedPoint96.sol';\\nimport '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';\\nimport '@uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol';\\nimport '@uniswap/v3-periphery/contracts/libraries/PoolAddress.sol';\\nimport './libraries/BokkyPooBahsDateTimeLibrary.sol';\\nimport './interfaces/IPEAS.sol';\\nimport './interfaces/ITokenRewards.sol';\\nimport './interfaces/IV3TwapUtilities.sol';\\n\\ncontract TokenRewards is ITokenRewards, Context {\\n  using SafeERC20 for IERC20;\\n\\n  address constant V3_ROUTER = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\\n  uint256 constant PRECISION = 10 ** 36;\\n  uint24 constant REWARDS_POOL_FEE = 10000; // 1%\\n  address immutable DAI;\\n  IV3TwapUtilities immutable V3_TWAP_UTILS;\\n\\n  struct Reward {\\n    uint256 excluded;\\n    uint256 realized;\\n  }\\n\\n  address public override trackingToken;\\n  address public override rewardsToken;\\n  uint256 public override totalShares;\\n  uint256 public override totalStakers;\\n  mapping(address => uint256) public shares;\\n  mapping(address => Reward) public rewards;\\n\\n  uint256 _rewardsSwapSlippage = 10; // 1%\\n  uint256 _rewardsPerShare;\\n  uint256 public rewardsDistributed;\\n  uint256 public rewardsDeposited;\\n  mapping(uint256 => uint256) public rewardsDepMonthly;\\n\\n  modifier onlyTrackingToken() {\\n    require(_msgSender() == trackingToken, 'UNAUTHORIZED');\\n    _;\\n  }\\n\\n  constructor(\\n    IV3TwapUtilities _v3TwapUtilities,\\n    address _dai,\\n    address _trackingToken,\\n    address _rewardsToken\\n  ) {\\n    V3_TWAP_UTILS = _v3TwapUtilities;\\n    DAI = _dai;\\n    trackingToken = _trackingToken;\\n    rewardsToken = _rewardsToken;\\n  }\\n\\n  function setShares(\\n    address _wallet,\\n    uint256 _amount,\\n    bool _sharesRemoving\\n  ) external override onlyTrackingToken {\\n    _setShares(_wallet, _amount, _sharesRemoving);\\n  }\\n\\n  function _setShares(\\n    address _wallet,\\n    uint256 _amount,\\n    bool _sharesRemoving\\n  ) internal {\\n    if (_sharesRemoving) {\\n      _removeShares(_wallet, _amount);\\n      emit RemoveShares(_wallet, _amount);\\n    } else {\\n      _addShares(_wallet, _amount);\\n      emit AddShares(_wallet, _amount);\\n    }\\n  }\\n\\n  function _addShares(address _wallet, uint256 _amount) internal {\\n    if (shares[_wallet] > 0) {\\n      _distributeReward(_wallet);\\n    }\\n    uint256 sharesBefore = shares[_wallet];\\n    totalShares += _amount;\\n    shares[_wallet] += _amount;\\n    if (sharesBefore == 0 && shares[_wallet] > 0) {\\n      totalStakers++;\\n    }\\n    rewards[_wallet].excluded = _cumulativeRewards(shares[_wallet]);\\n  }\\n\\n  function _removeShares(address _wallet, uint256 _amount) internal {\\n    require(shares[_wallet] > 0 && _amount <= shares[_wallet], 'REMOVE');\\n    _distributeReward(_wallet);\\n    totalShares -= _amount;\\n    shares[_wallet] -= _amount;\\n    if (shares[_wallet] == 0) {\\n      totalStakers--;\\n    }\\n    rewards[_wallet].excluded = _cumulativeRewards(shares[_wallet]);\\n  }\\n\\n  function depositFromDAI(uint256 _amountDAIDepositing) external override {\\n    if (_amountDAIDepositing > 0) {\\n      IERC20(DAI).safeTransferFrom(\\n        _msgSender(),\\n        address(this),\\n        _amountDAIDepositing\\n      );\\n    }\\n    uint256 _amountDAI = IERC20(DAI).balanceOf(address(this));\\n    require(_amountDAI > 0, 'NEEDDAI');\\n    (address _token0, address _token1) = DAI < rewardsToken\\n      ? (DAI, rewardsToken)\\n      : (rewardsToken, DAI);\\n    PoolAddress.PoolKey memory _poolKey = PoolAddress.PoolKey({\\n      token0: _token0,\\n      token1: _token1,\\n      fee: REWARDS_POOL_FEE\\n    });\\n    address _pool = PoolAddress.computeAddress(\\n      IPeripheryImmutableState(V3_ROUTER).factory(),\\n      _poolKey\\n    );\\n    uint160 _rewardsSqrtPriceX96 = V3_TWAP_UTILS\\n      .sqrtPriceX96FromPoolAndInterval(_pool);\\n    uint256 _rewardsPriceX96 = V3_TWAP_UTILS.priceX96FromSqrtPriceX96(\\n      _rewardsSqrtPriceX96\\n    );\\n    uint256 _amountOut = _token0 == DAI\\n      ? (_rewardsPriceX96 * _amountDAI) / FixedPoint96.Q96\\n      : (_amountDAI * FixedPoint96.Q96) / _rewardsPriceX96;\\n\\n    uint256 _rewardsBalBefore = IERC20(rewardsToken).balanceOf(address(this));\\n    IERC20(DAI).safeIncreaseAllowance(V3_ROUTER, _amountDAI);\\n    try\\n      ISwapRouter(V3_ROUTER).exactInputSingle(\\n        ISwapRouter.ExactInputSingleParams({\\n          tokenIn: DAI,\\n          tokenOut: rewardsToken,\\n          fee: REWARDS_POOL_FEE,\\n          recipient: address(this),\\n          deadline: block.timestamp,\\n          amountIn: _amountDAI,\\n          amountOutMinimum: (_amountOut * (1000 - _rewardsSwapSlippage)) / 1000,\\n          sqrtPriceLimitX96: 0\\n        })\\n      )\\n    {\\n      _rewardsSwapSlippage = 10;\\n      _depositRewards(\\n        IERC20(rewardsToken).balanceOf(address(this)) - _rewardsBalBefore\\n      );\\n    } catch {\\n      _rewardsSwapSlippage += 10;\\n      IERC20(DAI).safeDecreaseAllowance(V3_ROUTER, _amountDAI);\\n    }\\n  }\\n\\n  function depositRewards(uint256 _amount) external override {\\n    require(_amount > 0, 'DEPAM');\\n    uint256 _rewardsBalBefore = IERC20(rewardsToken).balanceOf(address(this));\\n    IERC20(rewardsToken).safeTransferFrom(_msgSender(), address(this), _amount);\\n    _depositRewards(\\n      IERC20(rewardsToken).balanceOf(address(this)) - _rewardsBalBefore\\n    );\\n  }\\n\\n  function _depositRewards(uint256 _amountTotal) internal {\\n    if (_amountTotal == 0) {\\n      return;\\n    }\\n    if (totalShares == 0) {\\n      _burnRewards(_amountTotal);\\n      return;\\n    }\\n\\n    uint256 _burnAmount = _amountTotal / 10;\\n    uint256 _depositAmount = _amountTotal - _burnAmount;\\n    _burnRewards(_burnAmount);\\n    rewardsDeposited += _depositAmount;\\n    rewardsDepMonthly[beginningOfMonth(block.timestamp)] += _depositAmount;\\n    _rewardsPerShare += (PRECISION * _depositAmount) / totalShares;\\n    emit DepositRewards(_msgSender(), _depositAmount);\\n  }\\n\\n  function _distributeReward(address _wallet) internal {\\n    if (shares[_wallet] == 0) {\\n      return;\\n    }\\n    uint256 _amount = getUnpaid(_wallet);\\n    rewards[_wallet].realized += _amount;\\n    rewards[_wallet].excluded = _cumulativeRewards(shares[_wallet]);\\n    if (_amount > 0) {\\n      rewardsDistributed += _amount;\\n      IERC20(rewardsToken).safeTransfer(_wallet, _amount);\\n      emit DistributeReward(_wallet, _amount);\\n    }\\n  }\\n\\n  function _burnRewards(uint256 _burnAmount) internal {\\n    try IPEAS(rewardsToken).burn(_burnAmount) {} catch {\\n      IERC20(rewardsToken).safeTransfer(address(0xdead), _burnAmount);\\n    }\\n  }\\n\\n  function beginningOfMonth(uint256 _timestamp) public pure returns (uint256) {\\n    (, , uint256 _dayOfMonth) = BokkyPooBahsDateTimeLibrary.timestampToDate(\\n      _timestamp\\n    );\\n    return _timestamp - ((_dayOfMonth - 1) * 1 days) - (_timestamp % 1 days);\\n  }\\n\\n  function claimReward(address _wallet) external override {\\n    _distributeReward(_wallet);\\n    emit ClaimReward(_wallet);\\n  }\\n\\n  function getUnpaid(address _wallet) public view returns (uint256) {\\n    if (shares[_wallet] == 0) {\\n      return 0;\\n    }\\n    uint256 earnedRewards = _cumulativeRewards(shares[_wallet]);\\n    uint256 rewardsExcluded = rewards[_wallet].excluded;\\n    if (earnedRewards <= rewardsExcluded) {\\n      return 0;\\n    }\\n    return earnedRewards - rewardsExcluded;\\n  }\\n\\n  function _cumulativeRewards(uint256 _share) internal view returns (uint256) {\\n    return (_share * _rewardsPerShare) / PRECISION;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/WeightedIndex.sol\": {\r\n      \"content\": \"// https://peapods.finance\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport '@uniswap/v3-core/contracts/libraries/FixedPoint96.sol';\\nimport './interfaces/IERC20Metadata.sol';\\nimport './interfaces/IUniswapV2Pair.sol';\\nimport './interfaces/IV3TwapUtilities.sol';\\nimport './DecentralizedIndex.sol';\\n\\ncontract WeightedIndex is DecentralizedIndex {\\n  using SafeERC20 for IERC20;\\n\\n  IUniswapV2Factory immutable V2_FACTORY;\\n\\n  uint256 _totalWeights;\\n\\n  constructor(\\n    string memory _name,\\n    string memory _symbol,\\n    uint256 _bondFee,\\n    uint256 _debondFee,\\n    address[] memory _tokens,\\n    uint256[] memory _weights,\\n    address _lpRewardsToken,\\n    address _v2Router,\\n    address _dai,\\n    bool _stakeRestriction,\\n    IV3TwapUtilities _v3TwapUtilities\\n  )\\n    DecentralizedIndex(\\n      _name,\\n      _symbol,\\n      _bondFee,\\n      _debondFee,\\n      _lpRewardsToken,\\n      _v2Router,\\n      _dai,\\n      _stakeRestriction,\\n      _v3TwapUtilities\\n    )\\n  {\\n    indexType = IndexType.WEIGHTED;\\n    V2_FACTORY = IUniswapV2Factory(IUniswapV2Router02(_v2Router).factory());\\n    require(_tokens.length == _weights.length, 'INIT');\\n    for (uint256 _i; _i < _tokens.length; _i++) {\\n      indexTokens.push(\\n        IndexAssetInfo({\\n          token: _tokens[_i],\\n          basePriceUSDX96: 0,\\n          weighting: _weights[_i],\\n          c1: address(0),\\n          q1: 0 // amountsPerIdxTokenX96\\n        })\\n      );\\n      _totalWeights += _weights[_i];\\n      _fundTokenIdx[_tokens[_i]] = _i;\\n      _isTokenInIndex[_tokens[_i]] = true;\\n    }\\n    // at idx == 0, need to find X in [1/X = tokenWeightAtIdx/totalWeights]\\n    // at idx > 0, need to find Y in (Y/X = tokenWeightAtIdx/totalWeights)\\n    uint256 _xX96 = (FixedPoint96.Q96 * _totalWeights) / _weights[0];\\n    for (uint256 _i; _i < _tokens.length; _i++) {\\n      indexTokens[_i].q1 =\\n        (_weights[_i] * _xX96 * 10 ** IERC20Metadata(_tokens[_i]).decimals()) /\\n        _totalWeights;\\n    }\\n  }\\n\\n  function _getNativePriceUSDX96() internal view returns (uint256) {\\n    IUniswapV2Pair _nativeStablePool = IUniswapV2Pair(\\n      V2_FACTORY.getPair(DAI, WETH)\\n    );\\n    address _token0 = _nativeStablePool.token0();\\n    (uint8 _decimals0, uint8 _decimals1) = (\\n      IERC20Metadata(_token0).decimals(),\\n      IERC20Metadata(_nativeStablePool.token1()).decimals()\\n    );\\n    (uint112 _res0, uint112 _res1, ) = _nativeStablePool.getReserves();\\n    return\\n      _token0 == DAI\\n        ? (FixedPoint96.Q96 * _res0 * 10 ** _decimals1) /\\n          _res1 /\\n          10 ** _decimals0\\n        : (FixedPoint96.Q96 * _res1 * 10 ** _decimals0) /\\n          _res0 /\\n          10 ** _decimals1;\\n  }\\n\\n  function _getTokenPriceUSDX96(\\n    address _token\\n  ) internal view returns (uint256) {\\n    if (_token == WETH) {\\n      return _getNativePriceUSDX96();\\n    }\\n    IUniswapV2Pair _pool = IUniswapV2Pair(V2_FACTORY.getPair(_token, WETH));\\n    address _token0 = _pool.token0();\\n    uint8 _decimals0 = IERC20Metadata(_token0).decimals();\\n    uint8 _decimals1 = IERC20Metadata(_pool.token1()).decimals();\\n    (uint112 _res0, uint112 _res1, ) = _pool.getReserves();\\n    uint256 _nativePriceUSDX96 = _getNativePriceUSDX96();\\n    return\\n      _token0 == WETH\\n        ? (_nativePriceUSDX96 * _res0 * 10 ** _decimals1) /\\n          _res1 /\\n          10 ** _decimals0\\n        : (_nativePriceUSDX96 * _res1 * 10 ** _decimals0) /\\n          _res0 /\\n          10 ** _decimals1;\\n  }\\n\\n  function bond(address _token, uint256 _amount) external override lock noSwap {\\n    require(_isTokenInIndex[_token], 'INVALIDTOKEN');\\n    uint256 _tokenIdx = _fundTokenIdx[_token];\\n    uint256 _tokensMinted = (_amount * FixedPoint96.Q96 * 10 ** decimals()) /\\n      indexTokens[_tokenIdx].q1;\\n    uint256 _feeTokens = _isFirstIn() ? 0 : (_tokensMinted * BOND_FEE) / 10000;\\n    _mint(_msgSender(), _tokensMinted - _feeTokens);\\n    if (_feeTokens > 0) {\\n      _mint(address(this), _feeTokens);\\n    }\\n    for (uint256 _i; _i < indexTokens.length; _i++) {\\n      uint256 _transferAmount = _i == _tokenIdx\\n        ? _amount\\n        : (_amount *\\n          indexTokens[_i].weighting *\\n          10 ** IERC20Metadata(indexTokens[_i].token).decimals()) /\\n          indexTokens[_tokenIdx].weighting /\\n          10 ** IERC20Metadata(_token).decimals();\\n      _transferAndValidate(\\n        IERC20(indexTokens[_i].token),\\n        _msgSender(),\\n        _transferAmount\\n      );\\n    }\\n    emit Bond(_msgSender(), _token, _amount, _tokensMinted);\\n  }\\n\\n  function debond(\\n    uint256 _amount,\\n    address[] memory,\\n    uint8[] memory\\n  ) external override lock noSwap {\\n    uint256 _amountAfterFee = _isLastOut(_amount)\\n      ? _amount\\n      : (_amount * (10000 - DEBOND_FEE)) / 10000;\\n    uint256 _percAfterFeeX96 = (_amountAfterFee * FixedPoint96.Q96) /\\n      totalSupply();\\n    _transfer(_msgSender(), address(this), _amount);\\n    _burn(address(this), _amountAfterFee);\\n    for (uint256 _i; _i < indexTokens.length; _i++) {\\n      uint256 _tokenSupply = IERC20(indexTokens[_i].token).balanceOf(\\n        address(this)\\n      );\\n      uint256 _debondAmount = (_tokenSupply * _percAfterFeeX96) /\\n        FixedPoint96.Q96;\\n      IERC20(indexTokens[_i].token).safeTransfer(_msgSender(), _debondAmount);\\n      require(\\n        IERC20(indexTokens[_i].token).balanceOf(address(this)) >=\\n          _tokenSupply - _debondAmount,\\n        'HEAVY'\\n      );\\n    }\\n    emit Debond(_msgSender(), _amount);\\n  }\\n\\n  function getTokenPriceUSDX96(\\n    address _token\\n  ) external view override returns (uint256) {\\n    return _getTokenPriceUSDX96(_token);\\n  }\\n\\n  function getIdxPriceUSDX96() public view override returns (uint256, uint256) {\\n    uint256 _priceX96;\\n    uint256 _X96_2 = 2 ** (96 / 2);\\n    for (uint256 _i; _i < indexTokens.length; _i++) {\\n      uint256 _tokenPriceUSDX96_2 = _getTokenPriceUSDX96(\\n        indexTokens[_i].token\\n      ) / _X96_2;\\n      _priceX96 +=\\n        (_tokenPriceUSDX96_2 * indexTokens[_i].q1) /\\n        10 ** IERC20Metadata(indexTokens[_i].token).decimals() /\\n        _X96_2;\\n    }\\n    return (0, _priceX96);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_bondFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_debondFee\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_weights\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_lpRewardsToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_v2Router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dai\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_stakeRestriction\",\"type\":\"bool\"},{\"internalType\":\"contract IV3TwapUtilities\",\"name\":\"_v3TwapUtilities\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountDAI\",\"type\":\"uint256\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokensBonded\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokensMinted\",\"type\":\"uint256\"}],\"name\":\"Bond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newIdx\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"Create\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountDebonded\",\"type\":\"uint256\"}],\"name\":\"Debond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FlashLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountLiquidity\",\"type\":\"uint256\"}],\"name\":\"RemoveLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BOND_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEBOND_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FLASH_FEE_DAI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_idxLPTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_daiLPTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"}],\"name\":\"addLiquidityV2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"bond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"created\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"}],\"name\":\"debond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"flash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllAssets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weighting\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basePriceUSDX96\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"c1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"q1\",\"type\":\"uint256\"}],\"internalType\":\"struct IDecentralizedIndex.IndexAssetInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIdxPriceUSDX96\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getTokenPriceUSDX96\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"indexTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weighting\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basePriceUSDX96\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"c1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"q1\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"indexType\",\"outputs\":[{\"internalType\":\"enum IDecentralizedIndex.IndexType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"isAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpRewardsToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpStakingPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lpTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minIdxTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minDAI\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityV2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"rescueERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "WeightedIndex", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a00000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000012c00000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000022000000000000000000000000002f92800f57bcd74066f5709f1daa1a4302df8750000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024ff47d552cb222b265d68c7aeb26e586d5229d00000000000000000000000000000000000000000000000000000000000000125045412c5045412028576569676874656429000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000047070505000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000002f92800f57bcd74066f5709f1daa1a4302df87500000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}