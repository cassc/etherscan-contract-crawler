{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n/*\r\n     .____    .__             .__    .___\r\n     |    |   |__| ________ __|__| __| _/\r\n     |    |   |  |/ ____/  |  \\  |/ __ |\r\n     |    |___|  < <_|  |  |  /  / /_/ |\r\n     |_______ \\__|\\__   |____/|__\\____ |\r\n             \\/      |__|             \\/\r\n ___________.__  __\r\n \\__    ___/|__|/  |______    ____   ______\r\n   |    |   |  \\   __\\__  \\  /    \\ /  ___/\r\n   |    |   |  ||  |  / __ \\|   |  \\\\___ \\\r\n   |____|   |__||__| (____  /___|  /____  >\r\n                          \\/     \\/     \\/\r\n\r\nWe don't need no water, let that motherf*cker burn!\r\n*/\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC721 {\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function getApproved(uint256 tokenId) external view returns (address);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC1155 {\r\n    function balanceOf(\r\n        address account,\r\n        uint256 id\r\n    ) external view returns (uint256);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ncontract TitanItemBurns {\r\n    address public DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address public Legends = 0x372405A6d95628Ad14518BfE05165D397f43dE1D;\r\n    address public Invaders = 0x2f3A9adc5301600Cd9205eF7657cF0733fF71D04;\r\n    address public Artifacts = 0xf85906f89aecA56aff6D34790677595aF6B4FBD7;\r\n    address public Titans = 0x21d6Fe3B109808Fc69CDaF9829457B0d780Bd975;\r\n    address public LiquidDeployer = 0x866cfDa1B7cD90Cd250485cd8b700211480845D7;\r\n\r\n    // NOTE: We could have done this brute-force with a bunch of static fields, but\r\n    //       instead we are doing it with a dynamic set of traits contained in the traits\r\n    //       struct and a mapping into that struct for updates. It's harder and takes\r\n    //       a bit more gas, but doesn't force us into static traits in the future if\r\n    //       we add additional items to the list\r\n    //\r\n\r\n    mapping(address => string) public BurnContracts;\r\n\r\n    struct TitanLevels {\r\n        address contractAddress;\r\n        uint256 tokenId;\r\n    }\r\n\r\n    mapping(uint256 => mapping(address => TitanLevels)) public AllTitanLevels;\r\n\r\n    constructor() {\r\n        BurnContracts[0x372405A6d95628Ad14518BfE05165D397f43dE1D] = \"Legend\";\r\n        BurnContracts[0x2f3A9adc5301600Cd9205eF7657cF0733fF71D04] = \"Invader\";\r\n        BurnContracts[0x813b5c4aE6b188F4581aa1dfdB7f4Aba44AA578B] = \"Ape\";\r\n        BurnContracts[0xf4744Ec5D846F7f1a0c5d389F590Cc1344eD3fCf] = \"Tiger\";\r\n        BurnContracts[0x7af6A74717a76423d67C2E684916E006d29eB0fa] = \"Pet\";\r\n        BurnContracts[0x65f9Bbea8d321CBec026aeea6f0F79011F8b85eB] = \"Pack\";\r\n        BurnContracts[0x21d6Fe3B109808Fc69CDaF9829457B0d780Bd975] = \"Titan\";\r\n        BurnContracts[0x753412F4FB7245BCF1c0714fDf59ba89110f39b8] = \"Key\";\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Add and remove tokens that can be burned, spindled, folded, & mutilated\r\n    // ------------------------------------------------------------------------\r\n    function removeTokenBurnContract(address contractAddress) public {\r\n        require(\r\n            msg.sender == LiquidDeployer,\r\n            \"Only LiquidDeployer can remove Token burn contracts\"\r\n        );\r\n\r\n        delete BurnContracts[contractAddress];\r\n    }\r\n\r\n    function updateTokenBurnContract(\r\n        address contractAddress,\r\n        string memory name\r\n    ) public {\r\n        require(\r\n            msg.sender == LiquidDeployer,\r\n            \"Only LiquidDeployer can update Token burn contracts\"\r\n        );\r\n        BurnContracts[contractAddress] = name;\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // The functions used by the account burning the artifact or nfts for traits\r\n    // -------------------------------------------------------------------------\r\n\r\n    function getTitanLevels(\r\n        uint256 key,\r\n        address addr\r\n    ) public view returns (TitanLevels memory) {\r\n        return AllTitanLevels[key][addr];\r\n    }\r\n\r\n    event TitanLevelUp(\r\n        address indexed owner,\r\n        uint256 titanId,\r\n        address contractAddress,\r\n        string contractName,\r\n        uint256 tokenId\r\n    );\r\n\r\n    // This requires an approval for the contract and token before it will work\r\n    // Go to the original contract and \"Approve All\" instead of each token id\r\n    // to save gas over the long term\r\n    function updateTitanLevel(\r\n        uint256 titanId,\r\n        address contractAddress,\r\n        uint256 tokenId\r\n    ) public {\r\n        require(\r\n            bytes(BurnContracts[contractAddress]).length > 0,\r\n            \"Contract address is not a burn contract\"\r\n        );\r\n\r\n        require(\r\n            IERC721(contractAddress).ownerOf(tokenId) == msg.sender,\r\n            \"Only the owner of the token can update the titan level\"\r\n        );\r\n\r\n        require(\r\n            IERC721(Titans).ownerOf(titanId) == msg.sender,\r\n            \"You do not own this Titan!\"\r\n        );\r\n        TitanLevels storage titanLevel = AllTitanLevels[titanId][\r\n            contractAddress\r\n        ];\r\n\r\n        // Entry not yet created\r\n        if (titanLevel.contractAddress == address(0)) {\r\n            sendNFTToDead(contractAddress, tokenId);\r\n\r\n            // Write the entry\r\n            titanLevel.contractAddress = contractAddress;\r\n            titanLevel.tokenId = tokenId;\r\n\r\n            emit TitanLevelUp(\r\n                msg.sender,\r\n                titanId,\r\n                contractAddress,\r\n                BurnContracts[contractAddress],\r\n                tokenId\r\n            );\r\n        }\r\n    }\r\n\r\n    // This requires an approval for the contract and token before it will work\r\n    // Go to the original contract and \"Approve All\" instead of each token id\r\n    // to save gas over the long term\r\n    function sendNFTToDead(address nftContractAddress, uint256 tokenId) public {\r\n        require(tokenId > 0, \"Invalid token ID\");\r\n\r\n        // Create an instance of the IERC721 interface\r\n        IERC721 nftContract = IERC721(nftContractAddress);\r\n\r\n        // Make sure the caller is the owner of the NFT\r\n        require(\r\n            nftContract.ownerOf(tokenId) == msg.sender,\r\n            \"Not the owner of the NFT\"\r\n        );\r\n\r\n        // Approve the contract to manage the NFT on behalf of the owner\r\n        require(\r\n            nftContract.getApproved(tokenId) == address(this),\r\n            \"Not approved to manage NFT\"\r\n        );\r\n\r\n        // Transfer the NFT to the dead address\r\n        nftContract.safeTransferFrom(msg.sender, DEAD, tokenId);\r\n    }\r\n\r\n    // This is the end. My only friend, the end [of the contract].\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"titanId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"TitanLevelUp\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"AllTitanLevels\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Artifacts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"BurnContracts\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEAD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Invaders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Legends\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LiquidDeployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Titans\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"key\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getTitanLevels\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct TitanItemBurns.TitanLevels\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"removeTokenBurnContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"sendNFTToDead\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"titanId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"updateTitanLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"updateTokenBurnContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TitanItemBurns", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://670ea4f68539e03b0b8cfe878149acaaa42f772fc88725a923b4aba71d5c0073"}