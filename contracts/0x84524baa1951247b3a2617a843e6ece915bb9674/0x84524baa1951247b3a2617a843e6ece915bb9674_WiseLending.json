{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/WiseLending.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.21;\\n\\n/**\\n * @author Christoph Krpoun\\n * @author Ren\u00e9 Hochmuth\\n * @author Vitally Marinchenko\\n */\\n\\nimport \\\"./PoolManager.sol\\\";\\n\\n/**\\n * @dev WISE lending is an automated lending platform on which users can collateralize\\n * their assets and borrow tokens against them.\\n *\\n * Users need to pay borrow rates for debt tokens, which are reflected in a borrow APY for\\n * each asset type (pool). This borrow rate is variable over time and determined through the\\n * utilization of the pool. The bounding curve is a family of different bonding curves adjusted\\n * automatically by LASA (Lending Automated Scaling Algorithm). For more information, see:\\n * [https://wisesoft.gitbook.io/wise/wise-lending-protocol/lasa-ai]\\n *\\n * In addition to normal deposit, withdraw, borrow, and payback functions, there are other\\n * interacting modes:\\n *\\n * - Solely deposit and withdraw allows the user to keep their funds private, enabling\\n *    them to withdraw even when the pools are borrowed empty.\\n *\\n * - Aave pools  allow for maximal capital efficiency by earning aave supply APY for not\\n *   borrowed funds.\\n *\\n * - Special curve pools nside beefy farms can be used as collateral, opening up new usage\\n *   possibilities for these asset types.\\n *\\n * - Users can pay back their borrow with lending shares of the same asset type, making it\\n *   easier to manage their positions.\\n *\\n * - Users save their collaterals and borrows inside a position NFT, making it possible\\n *   to trade their whole positions or use them in second-layer contracts\\n *   (e.g., spot trading with PTP NFT trading platforms).\\n */\\n\\ncontract WiseLending is PoolManager {\\n\\n    /**\\n     * @dev Standard receive functions forwarding\\n     * directly send ETH to the master address.\\n     */\\n    receive()\\n        external\\n        payable\\n    {\\n        if (msg.sender == WETH_ADDRESS) {\\n            return;\\n        }\\n\\n        payable(master).transfer(\\n            msg.value\\n        );\\n    }\\n\\n    /**\\n     * @dev Runs the LASA algorithm known as\\n     * Lending Automated Scaling Algorithm\\n     * and updates pool data based on token\\n     */\\n    modifier syncPool(\\n        address _poolToken\\n    ) {\\n        _syncPoolBeforeCodeExecution(\\n            _poolToken\\n        );\\n        _;\\n        _syncPoolAfterCodeExecution(\\n            _poolToken\\n        );\\n    }\\n\\n    constructor(\\n        address _master,\\n        address _wiseOracleHubAddress,\\n        address _nftContract,\\n        address _wethContract\\n    )\\n        WiseLendingDeclaration(\\n            _master,\\n            _wiseOracleHubAddress,\\n            _nftContract,\\n            _wethContract\\n        )\\n    {}\\n\\n    /**\\n     * @dev First part of pool sync updating pseudo\\n     * amounts. Is skipped when powerFarms or aaveHub\\n     * is calling the function.\\n     */\\n    function _syncPoolBeforeCodeExecution(\\n        address _poolToken\\n    )\\n        private\\n    {\\n        if (_byPassCase(msg.sender) == true) {\\n            return;\\n        }\\n\\n        _preparePool(\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev Second part of pool sync updating\\n     * the borrow rate of the pool.\\n     */\\n    function _syncPoolAfterCodeExecution(\\n        address _poolToken\\n    )\\n        private\\n    {\\n        _newBorrowRate(\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows to give permission for onBehalf function\\n     * execution, allowing 3rd party to perform actions such as\\n     * borrowOnBehalf and withdrawOnBehalf with amount limit\\n     */\\n    function approve(\\n        address _spender,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        external\\n    {\\n        allowance[msg.sender][_poolToken][_spender] = _amount;\\n\\n        emit Approve(\\n            _spender,\\n            _poolToken,\\n            msg.sender,\\n            _amount,\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev Enables _poolToken to be used as a collateral.\\n     */\\n    function collateralizeDeposit(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        external\\n        syncPool(_poolToken)\\n    {\\n        WISE_SECURITY.checksCollateralizeDeposit(\\n            _nftId,\\n            msg.sender,\\n            _poolToken\\n        );\\n\\n        userLendingData[_nftId][_poolToken].deCollteralized = false;\\n    }\\n\\n    /**\\n     * @dev Disables _poolToken to be used as a collateral.\\n     */\\n    function deCollateralizeDeposit(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        external\\n        syncPool(_poolToken)\\n    {\\n        WISE_SECURITY.checkOwnerPosition(\\n            _nftId,\\n            msg.sender\\n        );\\n\\n        _prepareAssociatedTokens(\\n            _nftId,\\n            _poolToken\\n        );\\n\\n        userLendingData[_nftId][_poolToken].deCollteralized = true;\\n\\n        WISE_SECURITY.checksDecollateralizeDeposit(\\n            _nftId,\\n            _poolToken\\n        );\\n    }\\n\\n    // --------------- Deposit Functions -------------\\n\\n    /**\\n     * @dev Allows to supply funds using ETH.\\n     * Without converting to WETH, use ETH directly.\\n     */\\n    function depositExactAmountETH(\\n        uint256 _nftId\\n    )\\n        external\\n        payable\\n        syncPool(WETH_ADDRESS)\\n        returns (uint256)\\n    {\\n        return _depositExactAmountETH(\\n            _nftId\\n        );\\n    }\\n\\n    function _depositExactAmountETH(\\n        uint256 _nftId\\n    )\\n        internal\\n        returns (uint256)\\n    {\\n        uint256 shareAmount = calculateLendingShares(\\n            WETH_ADDRESS,\\n            msg.value\\n        );\\n\\n        _handleDeposit(\\n            msg.sender,\\n            _nftId,\\n            WETH_ADDRESS,\\n            msg.value,\\n            shareAmount\\n        );\\n\\n        _wrapETH(\\n            msg.value\\n        );\\n\\n        return shareAmount;\\n    }\\n\\n    /**\\n     * @dev Allows to supply funds using ETH.\\n     * Without converting to WETH, use ETH directly,\\n     * also mints position to avoid extra transaction.\\n     */\\n    function depositExactAmountETHMint()\\n        external\\n        payable\\n        returns (uint256)\\n    {\\n        return _depositExactAmountETH(\\n            _reservePosition()\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows to supply _poolToken and user\\n     * can decide if _poolToken should be collateralized,\\n     * also mints position to avoid extra transaction.\\n     */\\n    function depositExactAmountMint(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        external\\n        returns (uint256)\\n    {\\n        return depositExactAmount(\\n            _reservePosition(),\\n            _poolToken,\\n            _amount\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows to supply _poolToken and user\\n     * can decide if _poolToken should be collateralized.\\n     */\\n    function depositExactAmount(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        public\\n        syncPool(_poolToken)\\n        returns (uint256)\\n    {\\n        uint256 shareAmount = calculateLendingShares(\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _handleDeposit(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _amount,\\n            shareAmount\\n        );\\n\\n        _safeTransferFrom(\\n            _poolToken,\\n            msg.sender,\\n            address(this),\\n            _amount\\n        );\\n\\n        return shareAmount;\\n    }\\n\\n    /**\\n     * @dev Allows to supply funds using ETH in solely mode,\\n     * which does not earn APY, but keeps the funds private.\\n     * Other users are restricted from borrowing these funds,\\n     * owner can always withdraw even if all funds are borrowed.\\n     * Also mints position to avoid extra transaction.\\n     */\\n    function solelyDepositETHMint()\\n        external\\n        payable\\n    {\\n        solelyDepositETH(\\n            _reservePosition()\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows to supply funds using ETH in solely mode,\\n     * which does not earn APY, but keeps the funds private.\\n     * Other users are restricted from borrowing these funds,\\n     * owner can always withdraw even if all funds are borrowed.\\n     */\\n    function solelyDepositETH(\\n        uint256 _nftId\\n    )\\n        public\\n        payable\\n        syncPool(WETH_ADDRESS)\\n    {\\n        _handleSolelyDeposit(\\n            msg.sender,\\n            _nftId,\\n            WETH_ADDRESS,\\n            msg.value\\n        );\\n\\n        _wrapETH(\\n            msg.value\\n        );\\n\\n        emit FundsSolelyDeposited(\\n            msg.sender,\\n            _nftId,\\n            WETH_ADDRESS,\\n            msg.value,\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows to supply funds using ERC20 in solely mode,\\n     * which does not earn APY, but keeps the funds private.\\n     * Other users are restricted from borrowing these funds,\\n     * owner can always withdraw even if all funds are borrowed.\\n     * Also mints position to avoid extra transaction.\\n     */\\n    function solelyDepositMint(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        external\\n    {\\n        solelyDeposit(\\n            _reservePosition(),\\n            _poolToken,\\n            _amount\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows to supply funds using ERC20 in solely mode,\\n     * which does not earn APY, but keeps the funds private.\\n     * Other users are restricted from borrowing these funds,\\n     * owner can always withdraw even if all funds are borrowed.\\n     */\\n    function solelyDeposit(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        public\\n        syncPool(_poolToken)\\n    {\\n        _handleSolelyDeposit(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _safeTransferFrom(\\n            _poolToken,\\n            msg.sender,\\n            address(this),\\n            _amount\\n        );\\n\\n        emit FundsSolelyDeposited(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _amount,\\n            block.timestamp\\n        );\\n    }\\n\\n    // --------------- Withdraw Functions -------------\\n\\n    /**\\n     * @dev Allows to withdraw publicly\\n     * deposited ETH funds using exact amount.\\n     */\\n    function withdrawExactAmountETH(\\n        uint256 _nftId,\\n        uint256 _amount\\n    )\\n        external\\n        syncPool(WETH_ADDRESS)\\n        returns (uint256)\\n    {\\n        uint256 withdrawShares = _preparationsWithdraw(\\n            _nftId,\\n            msg.sender,\\n            WETH_ADDRESS,\\n            _amount\\n        );\\n\\n        _coreWithdrawToken(\\n            msg.sender,\\n            _nftId,\\n            WETH_ADDRESS,\\n            _amount,\\n            withdrawShares\\n        );\\n\\n        _unwrapETH(\\n            _amount\\n        );\\n\\n        payable(msg.sender).transfer(\\n            _amount\\n        );\\n\\n        emit FundsWithdrawn(\\n            msg.sender,\\n            _nftId,\\n            WETH_ADDRESS,\\n            _amount,\\n            withdrawShares,\\n            block.timestamp\\n        );\\n\\n        return withdrawShares;\\n    }\\n\\n    /**\\n     * @dev Allows to withdraw publicly\\n     * deposited ETH funds using exact shares.\\n     */\\n    function withdrawExactSharesETH(\\n        uint256 _nftId,\\n        uint256 _shares\\n    )\\n        external\\n        syncPool(WETH_ADDRESS)\\n        returns (uint256)\\n    {\\n        WISE_SECURITY.checkOwnerPosition(\\n            _nftId,\\n            msg.sender\\n        );\\n\\n        uint256 withdrawAmount = cashoutAmount(\\n            WETH_ADDRESS,\\n            _shares\\n        );\\n\\n        _coreWithdrawToken(\\n            msg.sender,\\n            _nftId,\\n            WETH_ADDRESS,\\n            withdrawAmount,\\n            _shares\\n        );\\n\\n        _unwrapETH(\\n            withdrawAmount\\n        );\\n\\n        payable(msg.sender).transfer(\\n            withdrawAmount\\n        );\\n\\n        emit FundsWithdrawn(\\n            msg.sender,\\n            _nftId,\\n            WETH_ADDRESS,\\n            withdrawAmount,\\n            _shares,\\n            block.timestamp\\n        );\\n\\n        return withdrawAmount;\\n    }\\n\\n    /**\\n     * @dev Allows to withdraw publicly\\n     * deposited ERC20 funds using exact amount.\\n     */\\n    function withdrawExactAmount(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _withdrawAmount\\n    )\\n        external\\n        syncPool(_poolToken)\\n        returns (uint256)\\n    {\\n        uint256 withdrawShares = _preparationsWithdraw(\\n            _nftId,\\n            msg.sender,\\n            _poolToken,\\n            _withdrawAmount\\n        );\\n\\n        _coreWithdrawToken(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _withdrawAmount,\\n            withdrawShares\\n        );\\n\\n        _safeTransfer(\\n            _poolToken,\\n            msg.sender,\\n            _withdrawAmount\\n        );\\n\\n        emit FundsWithdrawn(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _withdrawAmount,\\n            withdrawShares,\\n            block.timestamp\\n        );\\n\\n        return withdrawShares;\\n    }\\n\\n    /**\\n     * @dev Allows to withdraw privately\\n     * deposited ETH funds using input amount.\\n     */\\n    function solelyWithdrawETH(\\n        uint256 _nftId,\\n        uint256 withdrawAmount\\n    )\\n        external\\n        syncPool(WETH_ADDRESS)\\n    {\\n        WISE_SECURITY.checkOwnerPosition(\\n            _nftId,\\n            msg.sender\\n        );\\n\\n        _coreSolelyWithdraw(\\n            msg.sender,\\n            _nftId,\\n            WETH_ADDRESS,\\n            withdrawAmount\\n        );\\n\\n        _unwrapETH(\\n            withdrawAmount\\n        );\\n\\n        payable(msg.sender).transfer(\\n            withdrawAmount\\n        );\\n\\n        emit FundsSolelyWithdrawn(\\n            msg.sender,\\n            _nftId,\\n            WETH_ADDRESS,\\n            withdrawAmount,\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows to withdraw privately\\n     * deposited ERC20 funds using input amount.\\n     */\\n    function solelyWithdraw(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _withdrawAmount\\n    )\\n        external\\n        syncPool(_poolToken)\\n    {\\n        WISE_SECURITY.checkOwnerPosition(\\n            _nftId,\\n            msg.sender\\n        );\\n\\n        _coreSolelyWithdraw(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _withdrawAmount\\n        );\\n\\n        _safeTransfer(\\n            _poolToken,\\n            msg.sender,\\n            _withdrawAmount\\n        );\\n\\n        emit FundsSolelyWithdrawn(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _withdrawAmount,\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows to withdraw privately\\n     * deposited ERC20 on behalf of owner.\\n     * Requires approval by _nftId owner.\\n     */\\n    function solelyWithdrawOnBehalf(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _withdrawAmount\\n    )\\n        external\\n        syncPool(_poolToken)\\n    {\\n        _reduceAllowance(\\n            _nftId,\\n            _poolToken,\\n            msg.sender,\\n            _withdrawAmount\\n        );\\n\\n        _coreSolelyWithdraw(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _withdrawAmount\\n        );\\n\\n        _safeTransfer(\\n            _poolToken,\\n            msg.sender,\\n            _withdrawAmount\\n        );\\n\\n        emit FundsSolelyWithdrawnOnBehalf(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _withdrawAmount,\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows to withdraw privately\\n     * deposited ERC20 on behalf of owner.\\n     * Requires approval by _nftId owner.\\n     */\\n    function withdrawOnBehalfExactAmount(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _withdrawAmount\\n    )\\n        external\\n        syncPool(_poolToken)\\n        returns (uint256)\\n    {\\n        _reduceAllowance(\\n            _nftId,\\n            _poolToken,\\n            msg.sender,\\n            _withdrawAmount\\n        );\\n\\n        uint256 withdrawShares = calculateLendingShares(\\n            _poolToken,\\n            _withdrawAmount\\n        );\\n\\n        _coreWithdrawToken(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _withdrawAmount,\\n            withdrawShares\\n        );\\n\\n        _safeTransfer(\\n            _poolToken,\\n            msg.sender,\\n            _withdrawAmount\\n        );\\n\\n        emit FundsWithdrawnOnBehalf(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _withdrawAmount,\\n            withdrawShares,\\n            block.timestamp\\n        );\\n\\n        return withdrawShares;\\n    }\\n\\n    /**\\n     * @dev Allows to withdraw ERC20\\n     * funds using shares as input value\\n     */\\n    function withdrawExactShares(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _shares\\n    )\\n        external\\n        syncPool(_poolToken)\\n        returns (uint256)\\n    {\\n        WISE_SECURITY.checkOwnerPosition(\\n            _nftId,\\n            msg.sender\\n        );\\n\\n        uint256 withdrawAmount = cashoutAmount(\\n            _poolToken,\\n            _shares\\n        );\\n\\n        _coreWithdrawToken(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            withdrawAmount,\\n            _shares\\n        );\\n\\n        _safeTransfer(\\n            _poolToken,\\n            msg.sender,\\n            withdrawAmount\\n        );\\n\\n        emit FundsWithdrawn(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            withdrawAmount,\\n            _shares,\\n            block.timestamp\\n        );\\n\\n        return withdrawAmount;\\n    }\\n\\n    /**\\n     * @dev Withdraws ERC20 funds on behalf\\n     * of _nftId owner, requires approval.\\n     */\\n    function withdrawOnBehalfExactShares(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _shares\\n    )\\n        external\\n        syncPool(_poolToken)\\n        returns (uint256)\\n    {\\n        uint256 withdrawAmount = cashoutAmount(\\n            _poolToken,\\n            _shares\\n        );\\n\\n        _reduceAllowance(\\n            _nftId,\\n            _poolToken,\\n            msg.sender,\\n            withdrawAmount\\n        );\\n\\n        _coreWithdrawToken(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            withdrawAmount,\\n            _shares\\n        );\\n\\n        _safeTransfer(\\n            _poolToken,\\n            msg.sender,\\n            withdrawAmount\\n        );\\n\\n        emit FundsWithdrawnOnBehalf(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            withdrawAmount,\\n            _shares,\\n            block.timestamp\\n        );\\n\\n        return withdrawAmount;\\n    }\\n\\n    // --------------- Borrow Functions -------------\\n\\n    /**\\n     * @dev Allows to borrow ETH funds\\n     * Requires user to have collateral.\\n     */\\n    function borrowExactAmountETH(\\n        uint256 _nftId,\\n        uint256 _amount\\n    )\\n        external\\n        syncPool(WETH_ADDRESS)\\n        returns (uint256)\\n    {\\n        WISE_SECURITY.checkOwnerPosition(\\n            _nftId,\\n            msg.sender\\n        );\\n\\n        uint256 shares = calculateBorrowShares(\\n            WETH_ADDRESS,\\n            _amount\\n        );\\n\\n        _coreBorrowTokens(\\n            msg.sender,\\n            _nftId,\\n            WETH_ADDRESS,\\n            _amount,\\n            shares\\n        );\\n\\n        _unwrapETH(\\n            _amount\\n        );\\n\\n        payable(msg.sender).transfer(\\n            _amount\\n        );\\n\\n        emit FundsBorrowed(\\n            msg.sender,\\n            _nftId,\\n            WETH_ADDRESS,\\n            _amount,\\n            shares,\\n            block.timestamp\\n        );\\n\\n        return shares;\\n    }\\n\\n    /**\\n     * @dev Allows to borrow ERC20 funds\\n     * Requires user to have collateral.\\n     */\\n    function borrowExactAmount(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        external\\n        syncPool(_poolToken)\\n        returns (uint256)\\n    {\\n        WISE_SECURITY.checkOwnerPosition(\\n            _nftId,\\n            msg.sender\\n        );\\n\\n        uint256 shares = calculateBorrowShares(\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _coreBorrowTokens(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _amount,\\n            shares\\n        );\\n\\n        _safeTransfer(\\n            _poolToken,\\n            msg.sender,\\n            _amount\\n        );\\n\\n        emit FundsBorrowed(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _amount,\\n            shares,\\n            block.timestamp\\n        );\\n\\n        return shares;\\n    }\\n\\n    /**\\n     * @dev Allows to borrow ERC20 funds\\n     * on behalf of _nftId owner, if approved.\\n     */\\n    function borrowOnBehalfExactAmount(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        external\\n        syncPool(_poolToken)\\n        returns (uint256)\\n    {\\n        _reduceAllowance(\\n            _nftId,\\n            _poolToken,\\n            msg.sender,\\n            _amount\\n        );\\n\\n        uint256 shares = calculateBorrowShares(\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _coreBorrowTokens(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _amount,\\n            shares\\n        );\\n\\n        _safeTransfer(\\n            _poolToken,\\n            msg.sender,\\n            _amount\\n        );\\n\\n        emit FundsBorrowedOnBehalf(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _amount,\\n            shares,\\n            block.timestamp\\n        );\\n\\n        return shares;\\n    }\\n\\n    // --------------- Payback Functions ------------\\n\\n    /**\\n     * @dev Ability to payback ETH loans\\n     * by providing exact payback amount.\\n     */\\n    function paybackExactAmountETH(\\n        uint256 _nftId\\n    )\\n        external\\n        payable\\n        syncPool(WETH_ADDRESS)\\n        returns (uint256)\\n    {\\n        _checkPositionLocked(\\n            _nftId,\\n            msg.sender\\n        );\\n\\n        uint256 maxBorrowShares = getPositionBorrowShares(\\n            _nftId,\\n            WETH_ADDRESS\\n        );\\n\\n        uint256 maxPaybackAmount = paybackAmount(\\n            WETH_ADDRESS,\\n            maxBorrowShares\\n        );\\n\\n        uint256 paybackShares = calculateBorrowShares(\\n            WETH_ADDRESS,\\n            msg.value\\n        );\\n\\n        uint256 refundAmount;\\n        uint256 requiredAmount = msg.value;\\n\\n        if (msg.value > maxPaybackAmount) {\\n\\n            refundAmount = msg.value\\n                - maxPaybackAmount;\\n\\n            requiredAmount = requiredAmount\\n                - refundAmount;\\n\\n            paybackShares = maxBorrowShares;\\n        }\\n\\n        _handlePayback(\\n            msg.sender,\\n            _nftId,\\n            WETH_ADDRESS,\\n            requiredAmount,\\n            paybackShares\\n        );\\n\\n        _wrapETH(\\n            requiredAmount\\n        );\\n\\n        if (refundAmount > 0) {\\n            payable(msg.sender).transfer(\\n                refundAmount\\n            );\\n        }\\n\\n        return paybackShares;\\n    }\\n\\n    /**\\n     * @dev Ability to payback ERC20 loans\\n     * by providing exact payback amount.\\n     */\\n    function paybackExactAmount(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        public\\n        syncPool(_poolToken)\\n        returns (uint256)\\n    {\\n        _checkPositionLocked(\\n            _nftId,\\n            msg.sender\\n        );\\n\\n        uint256 paybackShares = calculateBorrowShares(\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _handlePayback(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _amount,\\n            paybackShares\\n        );\\n\\n        _safeTransferFrom(\\n            _poolToken,\\n            msg.sender,\\n            address(this),\\n            _amount\\n        );\\n\\n        return paybackShares;\\n    }\\n\\n    /**\\n     * @dev Ability to payback ERC20 loans\\n     * by providing exact payback shares.\\n     */\\n    function paybackExactShares(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _shares\\n    )\\n        public\\n        syncPool(_poolToken)\\n        returns (uint256)\\n    {\\n        _checkPositionLocked(\\n            _nftId,\\n            msg.sender\\n        );\\n\\n        uint256 paybackAmount = paybackAmount(\\n            _poolToken,\\n            _shares\\n        );\\n\\n        _handlePayback(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            paybackAmount,\\n            _shares\\n        );\\n\\n        _safeTransferFrom(\\n            _poolToken,\\n            msg.sender,\\n            address(this),\\n            paybackAmount\\n        );\\n\\n        return paybackAmount;\\n    }\\n\\n    /**\\n     * @dev Ability to payback ERC20 loans\\n     * by providing exact lending shares.\\n     */\\n    function paybackExactLendingShares(\\n        uint256 _nftIdCaller,\\n        uint256 _nftIdReceiver,\\n        address _poolToken,\\n        uint256 _lendingShares\\n    )\\n        public\\n        syncPool(_poolToken)\\n        returns (uint256)\\n    {\\n        _prepareAssociatedTokens(\\n            _nftIdCaller,\\n            _poolToken\\n        );\\n\\n        uint256 paybackAmount = cashoutAmount(\\n            _poolToken,\\n            _lendingShares\\n        );\\n\\n        WISE_SECURITY.checkPaybackLendingShares(\\n            _nftIdReceiver,\\n            _nftIdCaller,\\n            msg.sender,\\n            _poolToken,\\n            paybackAmount\\n        );\\n\\n        _corePaybackLendingShares(\\n            _poolToken,\\n            paybackAmount,\\n            _lendingShares,\\n            _nftIdCaller,\\n            _nftIdReceiver\\n        );\\n\\n        emit FundsReturnedWithLendingShares(\\n            msg.sender,\\n            _poolToken,\\n            _nftIdCaller,\\n            paybackAmount,\\n            _lendingShares,\\n            block.timestamp\\n        );\\n\\n        if (getPositionBorrowShares(_nftIdReceiver, _poolToken) > 0) {\\n            return paybackAmount;\\n        }\\n\\n        _removePositionData({\\n            _nftId: _nftIdReceiver,\\n            _poolToken: _poolToken,\\n            _getPositionTokenLength: getPositionBorrowTokenLength,\\n            _getPositionTokenByIndex: getPositionBorrowTokenByIndex,\\n            _deleteLastPositionData: _deleteLastPositionBorrowData,\\n            isLending: false\\n        });\\n\\n        return paybackAmount;\\n    }\\n\\n    // --------------- Liquidation Functions ------------\\n\\n    /**\\n     * @dev Function to liquidate a postion which reaches\\n     * a debt ratio greater than 100%. The liquidator can choose\\n     * token to payback and receive. (Both can differ!). The\\n     * amount is in shares of the payback token. The liquidator\\n     * gets an incentive which is calculated inside the liquidation\\n     * logic.\\n     */\\n    function liquidatePartiallyFromTokens(\\n        uint256 _nftId,\\n        uint256 _nftIdLiquidator,\\n        address _paybackToken,\\n        address _receiveToken,\\n        uint256 _shareAmountToPay\\n    )\\n        external\\n        returns (uint256)\\n    {\\n        _preparationCollaterals(\\n            _nftId,\\n            ZERO_ADDRESS\\n        );\\n\\n        _preparationBorrows(\\n            _nftId,\\n            ZERO_ADDRESS\\n        );\\n\\n        _checkPositionLocked(\\n            _nftId,\\n            msg.sender\\n        );\\n\\n        WISE_SECURITY.checksLiquidation(\\n            _nftId,\\n            _paybackToken,\\n            _shareAmountToPay\\n        );\\n\\n        uint256 paybackAmount = paybackAmount(\\n            _paybackToken,\\n            _shareAmountToPay\\n        );\\n\\n        return _coreLiquidation(\\n            _nftId,\\n            _nftIdLiquidator,\\n            msg.sender,\\n            msg.sender,\\n            _paybackToken,\\n            _receiveToken,\\n            paybackAmount,\\n            _shareAmountToPay,\\n            WISE_SECURITY.maxFeeUSD(),\\n            WISE_SECURITY.baseRewardLiquidation()\\n        );\\n    }\\n\\n    /**\\n     * @dev Wrapper function for liqudaiton flow of\\n     * power farms.\\n     */\\n    function coreLiquidationIsolationPools(\\n        uint256 _nftId,\\n        uint256 _nftIdLiquidator,\\n        address _caller,\\n        address _receiver,\\n        address _paybackToken,\\n        address _receiveToken,\\n        uint256 _paybackAmount,\\n        uint256 _shareAmountToPay\\n    )\\n        external\\n        returns (uint256)\\n    {\\n        _onlyIsolationPool(\\n            msg.sender\\n        );\\n\\n        return _coreLiquidation(\\n            _nftId,\\n            _nftIdLiquidator,\\n            _caller,\\n            _receiver,\\n            _paybackToken,\\n            _receiveToken,\\n            _paybackAmount,\\n            _shareAmountToPay,\\n            WISE_SECURITY.maxFeeFarmUSD(),\\n            WISE_SECURITY.baseRewardLiquidationFarm()\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows to sync pool manually\\n     * so that the pool is up to date.\\n     */\\n    function syncManually(\\n        address _poolToken\\n    )\\n        external\\n        syncPool(_poolToken)\\n    {\\n        emit PoolSynced(\\n            _poolToken,\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev Registers position _nftId\\n     * for isolation pool functionality\\n     */\\n    function setRegistrationIsolationPool(\\n        uint256 _nftId,\\n        bool _registerState\\n    )\\n        external\\n    {\\n        _onlyIsolationPool(\\n            msg.sender\\n        );\\n\\n        positionLocked[_nftId] = _registerState;\\n\\n        emit RegisteredForIsolationPool(\\n            msg.sender,\\n            block.timestamp,\\n            _registerState\\n        );\\n    }\\n\\n    /**\\n     * @dev Wrapper for isolation pool\\n     * check.\\n     */\\n    function _onlyIsolationPool(\\n        address _poolAddress\\n    )\\n        private\\n        view\\n    {\\n        if (veryfiedIsolationPool[_poolAddress] == false) {\\n            revert();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PoolManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.21;\\n\\nimport \\\"./WiseCore.sol\\\";\\nimport \\\"./Babylonian.sol\\\";\\n\\nabstract contract PoolManager is WiseCore {\\n\\n    struct CreatePool {\\n        bool allowBorrow;\\n        address poolToken;\\n        uint256 poolMulFactor;\\n        uint256 poolCollFactor;\\n        uint256 maxDepositAmount;\\n    }\\n\\n    struct CurvePoolSettings {\\n        CurveSwapStructToken curveSecuritySwapsToken;\\n        CurveSwapStructData curveSecuritySwapsData;\\n    }\\n\\n    function setParamsLASA(\\n        address _poolToken,\\n        uint256 _poolMulFactor,\\n        uint256 _upperBoundMaxRate,\\n        uint256 _lowerBoundMaxRate,\\n        bool _steppingDirection,\\n        bool _isFinal\\n    )\\n        external\\n        onlyMaster\\n    {\\n        if (parametersLocked[_poolToken] == true) {\\n            revert ParametersLocked();\\n        }\\n\\n        parametersLocked[_poolToken] = _isFinal;\\n        algorithmData[_poolToken].increasePole = _steppingDirection;\\n\\n        uint256 staticMinPole = _getMinPole(\\n            _poolMulFactor,\\n            _upperBoundMaxRate\\n        );\\n\\n        uint256 staticMaxPole = _getMaxPole(\\n            _poolMulFactor,\\n            _lowerBoundMaxRate\\n        );\\n\\n        uint256 staticDeltaPole = _getDeltaPole(\\n            staticMaxPole,\\n            staticMinPole\\n        );\\n\\n        uint256 startValuePole = _getStartValue(\\n            staticMaxPole,\\n            staticMinPole\\n        );\\n\\n        borrowRatesData[_poolToken] = BorrowRatesEntry({\\n            pole: startValuePole,\\n            deltaPole: staticDeltaPole,\\n            minPole: staticMinPole,\\n            maxPole: staticMaxPole,\\n            multiplicativeFactor: _poolMulFactor\\n        });\\n\\n        algorithmData[_poolToken].bestPole = startValuePole;\\n        algorithmData[_poolToken].maxValue = lendingPoolData[_poolToken].totalDepositShares;\\n    }\\n\\n    function setPoolParameters(\\n        address _poolToken,\\n        uint256 _collateralFactor,\\n        uint256 _maximumDeposit\\n    )\\n        external\\n        onlyMaster\\n    {\\n        if (_maximumDeposit > 0) {\\n            maxDepositValueToken[_poolToken] = _maximumDeposit;\\n        }\\n\\n        if (_collateralFactor > 0) {\\n            lendingPoolData[_poolToken].collateralFactor = _collateralFactor;\\n        }\\n\\n        if (_collateralFactor > PRECISION_FACTOR_E18) {\\n            revert ForbiddenValue();\\n        }\\n    }\\n\\n    /**\\n     * @dev Allow to verify isolation pool.\\n     */\\n    function setVeryfiedIsolationPool(\\n        address _isolationPool,\\n        bool _state\\n    )\\n        external\\n        onlyMaster\\n    {\\n        veryfiedIsolationPool[_isolationPool] = _state;\\n    }\\n\\n    function createPool(\\n        CreatePool memory _params\\n    )\\n        external\\n        onlyMaster\\n    {\\n        _createPool(\\n            _params\\n        );\\n\\n    }\\n\\n    function createCurvePool(\\n        CreatePool memory _params,\\n        CurvePoolSettings memory _settings\\n    )\\n        external\\n        onlyMaster\\n    {\\n        _createPool(\\n            _params\\n        );\\n\\n        WISE_SECURITY.prepareCurvePools(\\n            _params.poolToken,\\n            _settings.curveSecuritySwapsData,\\n            _settings.curveSecuritySwapsToken\\n        );\\n    }\\n\\n    function _createPool(\\n        CreatePool memory _params\\n    )\\n        private\\n    {\\n        if (timestampsPoolData[_params.poolToken].timeStamp > 0) {\\n            revert AlreadyCreated();\\n        }\\n\\n        // Default boundary values for pool creation.\\n        uint256 LOWER_BOUND_MAX_RATE = 100 * PRECISION_FACTOR_E16;\\n        uint256 UPPER_BOUND_MAX_RATE = 300 * PRECISION_FACTOR_E16;\\n\\n        // Calculating lower bound for the pole\\n        uint256 staticMinPole = _getMinPole(\\n            _params.poolMulFactor,\\n            UPPER_BOUND_MAX_RATE\\n        );\\n\\n        // Calculating upper bound for the pole\\n        uint256 staticMaxPole = _getMaxPole(\\n            _params.poolMulFactor,\\n            LOWER_BOUND_MAX_RATE\\n        );\\n\\n        // Calculating fraction for algorithm step\\n        uint256 staticDeltaPole = _getDeltaPole(\\n            staticMaxPole,\\n            staticMinPole\\n        );\\n\\n        maxDepositValueToken[_params.poolToken] = _params.maxDepositAmount;\\n\\n        FEE_MANAGER.addPoolTokenAddress(\\n            _params.poolToken\\n        );\\n\\n        globalPoolData[_params.poolToken] = GlobalPoolEntry({\\n            totalPool: 0,\\n            utilization: 0,\\n            totalBareToken: 0,\\n            poolFee: 20 * PRECISION_FACTOR_E16\\n        });\\n\\n        // Setting start value as mean of min and max value\\n        uint256 startValuePole = _getStartValue(\\n            staticMaxPole,\\n            staticMinPole\\n        );\\n\\n        // Rates Pool Data\\n        borrowRatesData[_params.poolToken] = BorrowRatesEntry({\\n            pole: startValuePole,\\n            deltaPole: staticDeltaPole,\\n            minPole: staticMinPole,\\n            maxPole: staticMaxPole,\\n            multiplicativeFactor: _params.poolMulFactor\\n        });\\n\\n        // Borrow Pool Data\\n        borrowPoolData[_params.poolToken] = BorrowPoolEntry({\\n            allowBorrow: _params.allowBorrow,\\n            pseudoTotalBorrowAmount: 1,\\n            totalBorrowShares: 1,\\n            borrowRate: 0\\n        });\\n\\n        // Algorithm Pool Data\\n        algorithmData[_params.poolToken] = AlgorithmEntry({\\n            bestPole: startValuePole,\\n            maxValue: 0,\\n            previousValue: 0,\\n            increasePole: false\\n        });\\n\\n        uint256 fetchBalance = IERC20(_params.poolToken).balanceOf(\\n            address(this)\\n        );\\n\\n        if (fetchBalance > 0) {\\n            _safeTransfer(\\n                _params.poolToken,\\n                master,\\n                fetchBalance\\n            );\\n        }\\n\\n        // Lending Pool Data\\n        lendingPoolData[_params.poolToken] = LendingPoolEntry({\\n            pseudoTotalPool: 1,\\n            totalDepositShares: 1,\\n            collateralFactor: _params.poolCollFactor\\n        });\\n\\n        // Timestamp Pool Data\\n        timestampsPoolData[_params.poolToken] = TimestampsPoolEntry({\\n            timeStamp: block.timestamp,\\n            timeStampScaling: block.timestamp\\n        });\\n    }\\n\\n    function _getMaxPole(\\n        uint256 _poolMulFactor,\\n        uint256 _lowerBoundMaxRate\\n    )\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        return PRECISION_FACTOR_E18 / 2\\n            + Babylonian.sqrt(PRECISION_FACTOR_E36 / 4\\n                + _poolMulFactor\\n                    * PRECISION_FACTOR_E36\\n                    / _lowerBoundMaxRate\\n            );\\n    }\\n\\n    function _getMinPole(\\n        uint256 _poolMulFactor,\\n        uint256 _upperBoundMaxRate\\n    )\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        return PRECISION_FACTOR_E18 / 2\\n            + Babylonian.sqrt(PRECISION_FACTOR_E36 / 4\\n                + _poolMulFactor\\n                    * PRECISION_FACTOR_E36\\n                    / _upperBoundMaxRate\\n            );\\n    }\\n\\n    function _getDeltaPole(\\n        uint256 _maxPole,\\n        uint256 _minPole\\n    )\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        return (_maxPole - _minPole) / NORMALISATION_FACTOR;\\n    }\\n\\n    function _getStartValue(\\n        uint256 _maxPole,\\n        uint256 _minPole\\n    )\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        return (_maxPole + _minPole) / 2;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Babylonian.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: WISE\\n\\npragma solidity =0.8.21;\\n\\nlibrary Babylonian {\\n\\n    function sqrt(\\n        uint256 x\\n    )\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (x == 0) return 0;\\n\\n        uint256 xx = x;\\n        uint256 r = 1;\\n        if (xx >= 0x100000000000000000000000000000000) {\\n            xx >>= 128;\\n            r <<= 64;\\n        }\\n        if (xx >= 0x10000000000000000) {\\n            xx >>= 64;\\n            r <<= 32;\\n        }\\n        if (xx >= 0x100000000) {\\n            xx >>= 32;\\n            r <<= 16;\\n        }\\n        if (xx >= 0x10000) {\\n            xx >>= 16;\\n            r <<= 8;\\n        }\\n        if (xx >= 0x100) {\\n            xx >>= 8;\\n            r <<= 4;\\n        }\\n        if (xx >= 0x10) {\\n            xx >>= 4;\\n            r <<= 2;\\n        }\\n        if (xx >= 0x8) {\\n            r <<= 1;\\n        }\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n\\n        uint256 r1 = x / r;\\n        return (r < r1 ? r : r1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/WiseCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.21;\\n\\nimport \\\"./MainHelper.sol\\\";\\n\\nabstract contract WiseCore is MainHelper {\\n\\n    /**\\n     * @dev Wrapper function combining pool\\n     * preparations for borrow and collaterals.\\n     * Bypassed when called by powerFarms\\n     * or aaveHub.\\n     */\\n    function _prepareAssociatedTokens(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        internal\\n    {\\n        if (_byPassCase(msg.sender) == true) {\\n            return;\\n        }\\n\\n        _preparationCollaterals(\\n            _nftId,\\n            _poolToken\\n        );\\n\\n        _preparationBorrows(\\n            _nftId,\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev Core function combining withdraw\\n     * logic and security checks.\\n     */\\n    function _coreWithdrawToken(\\n        address _caller,\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount,\\n        uint256 _shares\\n    )\\n        internal\\n    {\\n        _prepareAssociatedTokens(\\n            _nftId,\\n            _poolToken\\n        );\\n\\n        WISE_SECURITY.checksWithdraw(\\n            _nftId,\\n            _caller,\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _coreWithdrawBare(\\n            _nftId,\\n            _poolToken,\\n            _amount,\\n            _shares\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal function combining payback\\n     * logic and emit of an event.\\n     */\\n    function _handlePayback(\\n        address _caller,\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount,\\n        uint256 _shares\\n    )\\n        internal\\n    {\\n        _corePayback(\\n            _nftId,\\n            _poolToken,\\n            _amount,\\n            _shares\\n        );\\n\\n        emit FundsReturned(\\n            _caller,\\n            _poolToken,\\n            _nftId,\\n            _amount,\\n            _shares,\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal function combining deposit\\n     * logic, security checks and event emit.\\n     */\\n    function _handleDeposit(\\n        address _caller,\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount,\\n        uint256 _shareAmount\\n    )\\n        internal\\n    {\\n        _checkDeposit(\\n            _nftId,\\n            _caller,\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _increasePositionLendingDeposit(\\n            _nftId,\\n            _poolToken,\\n            _shareAmount\\n        );\\n\\n        _updatePoolStorage(\\n            _poolToken,\\n            _amount,\\n            _shareAmount,\\n            _increaseTotalPool,\\n            _increasePseudoTotalPool,\\n            _increaseTotalDepositShares\\n        );\\n\\n        _addPositionTokenData(\\n            _nftId,\\n            _poolToken,\\n            hashMapPositionLending,\\n            positionLendingTokenData\\n        );\\n\\n        emit FundsDeposited(\\n            _caller,\\n            _nftId,\\n            _poolToken,\\n            _amount,\\n            _shareAmount,\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev External wrapper for\\n     * {_checkPositionLocked}.\\n     */\\n    function checkPositionLocked(\\n        uint256 _nftId,\\n        address _caller\\n    )\\n        external\\n        view\\n    {\\n        _checkPositionLocked(\\n            _nftId,\\n            _caller\\n        );\\n    }\\n\\n    /**\\n     * @dev Checks if a postion is locked\\n     * for powerFarms. Get skipped when\\n     * aaveHub or a powerFarm itself is\\n     * the {msg.sender}.\\n     */\\n    function _checkPositionLocked(\\n        uint256 _nftId,\\n        address _caller\\n    )\\n        internal\\n        view\\n    {\\n        if (_byPassCase(_caller) == true) {\\n            return;\\n        }\\n\\n        if (positionLocked[_nftId] == false) {\\n            return;\\n        }\\n\\n        revert PositionLocked();\\n    }\\n\\n    /**\\n     * @dev External wrapper for\\n     * {_checkDeposit}.\\n     */\\n    function checkDeposit(\\n        uint256 _nftId,\\n        address _caller,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        external\\n        view\\n    {\\n        _checkDeposit(\\n            _nftId,\\n            _caller,\\n            _poolToken,\\n            _amount\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal function including\\n     * security checks for deposit logic.\\n     */\\n    function _checkDeposit(\\n        uint256 _nftId,\\n        address _caller,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n        view\\n    {\\n        _checkPositionLocked(\\n            _nftId,\\n            _caller\\n        );\\n\\n        if (WISE_ORACLE.chainLinkIsDead(_poolToken) == true) {\\n            revert();\\n        }\\n\\n        _checkMaxDepositValue(\\n            _poolToken,\\n            _amount\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal function checking\\n     * if the deposit amount for the\\n     * pool token is reached.\\n     */\\n    function _checkMaxDepositValue(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n        view\\n    {\\n        bool state = maxDepositValueToken[_poolToken]\\n            < getTotalBareToken(_poolToken)\\n            + getPseudoTotalPool(_poolToken)\\n            + _amount;\\n\\n        if (state == true) {\\n            revert DepositCapReached();\\n        }\\n    }\\n\\n    /**\\n     * @dev Core function combining\\n     * supply logic with security\\n     * checks for solely deposit.\\n     */\\n    function _handleSolelyDeposit(\\n        address _caller,\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        _checkDeposit(\\n            _nftId,\\n            _caller,\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _increaseMappingValue(\\n            positionPureCollateralAmount,\\n            _nftId,\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _increaseTotalBareToken(\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _addPositionTokenData(\\n            _nftId,\\n            _poolToken,\\n            hashMapPositionLending,\\n            positionLendingTokenData\\n        );\\n    }\\n\\n    /**\\n     * @dev Low level core function combining\\n     * pure withdraw math (without security\\n     * checks).\\n     */\\n    function _coreWithdrawBare(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount,\\n        uint256 _shares\\n    )\\n        internal\\n    {\\n        _updatePoolStorage(\\n            _poolToken,\\n            _amount,\\n            _shares,\\n            _decreaseTotalPool,\\n            _decreasePseudoTotalPool,\\n            _decreaseTotalDepositShares\\n        );\\n\\n        _decreaseLendingShares(\\n            _nftId,\\n            _poolToken,\\n            _shares\\n        );\\n\\n        _removeEmptyLendingData(\\n            _nftId,\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev Core function combining borrow\\n     * logic with security checks.\\n     */\\n    function _coreBorrowTokens(\\n        address _caller,\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount,\\n        uint256 _shares\\n    )\\n        internal\\n    {\\n        _prepareAssociatedTokens(\\n            _nftId,\\n            _poolToken\\n        );\\n\\n        WISE_SECURITY.checksBorrow(\\n            _nftId,\\n            _caller,\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _updatePoolStorage(\\n            _poolToken,\\n            _amount,\\n            _shares,\\n            _increasePseudoTotalBorrowAmount,\\n            _decreaseTotalPool,\\n            _increaseTotalBorrowShares\\n        );\\n\\n        _increaseMappingValue(\\n            userBorrowShares,\\n            _nftId,\\n            _poolToken,\\n            _shares\\n        );\\n\\n        _addPositionTokenData(\\n            _nftId,\\n            _poolToken,\\n            hashMapPositionBorrow,\\n            positionBorrowTokenData\\n        );\\n    }\\n\\n    /**\\n     * @dev Core function combining payback\\n     * logic with security checks.\\n     */\\n    function _corePayback(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount,\\n        uint256 _shares\\n    )\\n        internal\\n    {\\n        _updatePoolStorage(\\n            _poolToken,\\n            _amount,\\n            _shares,\\n            _increaseTotalPool,\\n            _decreasePseudoTotalBorrowAmount,\\n            _decreaseTotalBorrowShares\\n        );\\n\\n        _decreasePositionMappingValue(\\n            userBorrowShares,\\n            _nftId,\\n            _poolToken,\\n            _shares\\n        );\\n\\n        if (getPositionBorrowShares(_nftId, _poolToken) > 0) {\\n            return;\\n        }\\n\\n        _removePositionData({\\n            _nftId: _nftId,\\n            _poolToken: _poolToken,\\n            _getPositionTokenLength: getPositionBorrowTokenLength,\\n            _getPositionTokenByIndex: getPositionBorrowTokenByIndex,\\n            _deleteLastPositionData: _deleteLastPositionBorrowData,\\n            isLending: false\\n        });\\n    }\\n\\n    /**\\n     * @dev External wrapper for\\n     * {_corePayback} logic callable\\n     * by feeMananger.\\n     */\\n    function corePaybackFeeManager(\\n        address _poolToken,\\n        uint256 _nftId,\\n        uint256 _amount,\\n        uint256 _shares\\n    )\\n        external\\n        onlyFeeManager\\n    {\\n        _corePayback(\\n            _nftId,\\n            _poolToken,\\n            _amount,\\n            _shares\\n        );\\n    }\\n\\n    /**\\n     * @dev Core function combining\\n     * withdraw logic for solely\\n     * withdraw with security checks.\\n     */\\n    function _coreSolelyWithdraw(\\n        address _caller,\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        WISE_SECURITY.checksSolelyWithdraw(\\n            _nftId,\\n            _caller,\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _solelyWithdrawBase(\\n            _poolToken,\\n            _nftId,\\n            _amount\\n        );\\n    }\\n\\n    /**\\n     * @dev Low level core function with\\n     * withdraw logic for solely\\n     * withdraw. (Without security checks)\\n     */\\n    function _solelyWithdrawBase(\\n        address _poolToken,\\n        uint256 _nftId,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        _decreasePositionMappingValue(\\n            positionPureCollateralAmount,\\n            _nftId,\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _decreaseTotalBareToken(\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _removeEmptyLendingData(\\n            _nftId,\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev Core function combining payback\\n     * logic for paying back borrow with\\n     * lending shares of same asset type.\\n     */\\n    function _corePaybackLendingShares(\\n        address _poolToken,\\n        uint256 _tokenAmount,\\n        uint256 _lendingShares,\\n        uint256 _nftIdCaller,\\n        uint256 _nftIdReceiver\\n    )\\n        internal\\n    {\\n        uint256 borrowShareEquivalent = _borrowShareEquivalent(\\n            _poolToken,\\n            _lendingShares\\n        );\\n\\n        _updatePoolStorage(\\n            _poolToken,\\n            _tokenAmount,\\n            _lendingShares,\\n            _decreasePseudoTotalPool,\\n            _decreasePseudoTotalBorrowAmount,\\n            _decreaseTotalDepositShares\\n        );\\n\\n        _decreaseLendingShares(\\n            _nftIdCaller,\\n            _poolToken,\\n            _lendingShares\\n        );\\n\\n        _decreaseTotalBorrowShares(\\n            _poolToken,\\n            borrowShareEquivalent\\n        );\\n\\n        _decreasePositionMappingValue(\\n            userBorrowShares,\\n            _nftIdReceiver,\\n            _poolToken,\\n            borrowShareEquivalent\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal math function for liquidation logic\\n     * caluclating amount to withdraw from pure\\n     * collateral for liquidation.\\n     */\\n    function _withdrawPureCollateralLiquidation(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _percentLiquidation\\n    )\\n        internal\\n        returns (uint256 transfereAmount)\\n    {\\n        transfereAmount = _percentLiquidation\\n            * positionPureCollateralAmount[_nftId][_poolToken]\\n            / PRECISION_FACTOR_E18;\\n\\n        _decreasePositionMappingValue(\\n            positionPureCollateralAmount,\\n            _nftId,\\n            _poolToken,\\n            transfereAmount\\n        );\\n\\n        _decreaseTotalBareToken(\\n            _poolToken,\\n            transfereAmount\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal math function for liquidation logic\\n     * which checks if pool has enough token to pay out\\n     * liquidator. If not, liquidator get corresponding\\n     * shares for later withdraw.\\n     */\\n    function _withdrawOrAllocateSharesLiquidation(\\n        uint256 _nftId,\\n        uint256 _nftIdLiquidator,\\n        address _poolToken,\\n        uint256 _percantageWishCollat\\n    )\\n        internal\\n        returns (uint256)\\n    {\\n        uint256 cashoutShares = _percantageWishCollat\\n            * getPositionLendingShares(\\n                _nftId,\\n                _poolToken\\n            ) / PRECISION_FACTOR_E18;\\n\\n        uint256 cashoutAmount = cashoutAmount(\\n            _poolToken,\\n            cashoutShares\\n        );\\n\\n        uint256 totalPoolToken = getTotalPool(\\n            _poolToken\\n        );\\n\\n        if (cashoutAmount <= totalPoolToken) {\\n\\n            _coreWithdrawBare(\\n                _nftId,\\n                _poolToken,\\n                cashoutAmount,\\n                cashoutShares\\n            );\\n\\n            return cashoutAmount;\\n        }\\n\\n        uint256 totalPoolInShares = calculateLendingShares(\\n            _poolToken,\\n            totalPoolToken\\n        );\\n\\n        uint256 shareDifference = cashoutShares\\n            - totalPoolInShares;\\n\\n        _coreWithdrawBare(\\n            _nftId,\\n            _poolToken,\\n            totalPoolToken,\\n            totalPoolInShares\\n        );\\n\\n        _decreaseLendingShares(\\n            _nftId,\\n            _poolToken,\\n            shareDifference\\n        );\\n\\n        _increasePositionLendingDeposit(\\n            _nftIdLiquidator,\\n            _poolToken,\\n            shareDifference\\n        );\\n\\n        _addPositionTokenData(\\n            _nftId,\\n            _poolToken,\\n            hashMapPositionLending,\\n            positionLendingTokenData\\n        );\\n\\n        return totalPoolToken;\\n    }\\n\\n    /**\\n     * @dev Internal math function combining functionallity\\n     * of {_withdrawPureCollateralLiquidation} and\\n     * {_withdrawOrAllocateSharesLiquidation}.\\n     */\\n    function _calculateReceiveAmount(\\n        uint256 _nftId,\\n        uint256 _nftIdLiquidator,\\n        address _receiveTokens,\\n        uint256 _removePercentage\\n    )\\n        internal\\n        returns (uint256)\\n    {\\n        uint256 receiveAmount = _withdrawPureCollateralLiquidation(\\n            _nftId,\\n            _receiveTokens,\\n            _removePercentage\\n        );\\n\\n        if (isDecollteralized(_nftId, _receiveTokens) == true) {\\n            return receiveAmount;\\n        }\\n\\n        return _withdrawOrAllocateSharesLiquidation(\\n            _nftId,\\n            _nftIdLiquidator,\\n            _receiveTokens,\\n            _removePercentage\\n        ) + receiveAmount;\\n    }\\n\\n    /**\\n     * @dev Core liquidation function for\\n     * security checks and liquidation math.\\n     */\\n    function _coreLiquidation(\\n        uint256 _nftId,\\n        uint256 _nftIdLiquidator,\\n        address _caller,\\n        address _receiver,\\n        address _tokenToPayback,\\n        address _tokenToRecieve,\\n        uint256 _paybackAmount,\\n        uint256 _shareAmountToPay,\\n        uint256 _maxFeeUSD,\\n        uint256 _baseRewardLiquidation\\n    )\\n        internal\\n        returns (uint256 receiveAmount)\\n    {\\n        uint256 paybackUSD = WISE_ORACLE.getTokensInUSD(\\n            _tokenToPayback,\\n            _paybackAmount\\n        );\\n\\n        uint256 collateralPercenage = WISE_SECURITY.calculateWishPercentage(\\n            _nftId,\\n            _tokenToRecieve,\\n            paybackUSD,\\n            _maxFeeUSD,\\n            _baseRewardLiquidation\\n        );\\n\\n        if (collateralPercenage > PRECISION_FACTOR_E18) {\\n            revert CollateralTooSmall();\\n        }\\n\\n        _corePayback(\\n            _nftId,\\n            _tokenToPayback,\\n            _paybackAmount,\\n            _shareAmountToPay\\n        );\\n\\n        receiveAmount = _calculateReceiveAmount(\\n            _nftId,\\n            _nftIdLiquidator,\\n            _tokenToRecieve,\\n            collateralPercenage\\n        );\\n\\n        WISE_SECURITY.checkBadDebt(\\n            _nftId\\n        );\\n\\n        _safeTransferFrom(\\n            _tokenToPayback,\\n            _caller,\\n            address(this),\\n            _paybackAmount\\n        );\\n\\n        _safeTransfer(\\n            _tokenToRecieve,\\n            _receiver,\\n            receiveAmount\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MainHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.21;\\n\\nimport \\\"./WiseLowLevelHelper.sol\\\";\\nimport \\\"./TransferHub/TransferHelper.sol\\\";\\n\\nabstract contract MainHelper is WiseLowLevelHelper, TransferHelper {\\n\\n    /**\\n     * @dev Internal helper function for reservating a\\n     * position NFT id.\\n     */\\n    function _reservePosition()\\n        internal\\n        returns (uint256)\\n    {\\n        return POSITION_NFT.reservePositionForUser(\\n            msg.sender\\n        );\\n    }\\n\\n    /**\\n     * @dev Helper function to convert {_amount}\\n     * of a certain pool with {_poolToken}\\n     * into lending shares. Includes devison\\n     * by zero and share security checks.\\n     * Needs latest pseudo amount for accurate\\n     * result.\\n     */\\n    function calculateLendingShares(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 shares = getTotalDepositShares(\\n            _poolToken\\n        );\\n\\n        if (shares <= 1) {\\n            return _amount;\\n        }\\n\\n        uint256 pseudo = getPseudoTotalPool(\\n            _poolToken\\n        );\\n\\n        if (pseudo == 0) {\\n            return _amount;\\n        }\\n\\n        return _amount\\n            * shares\\n            / pseudo;\\n    }\\n\\n    /**\\n     * @dev Helper function to convert {_amount}\\n     * of a certain pool with {_poolToken}\\n     * into borrow shares. Includes devison\\n     * by zero and share security checks.\\n     * Needs latest pseudo amount for accurate\\n     * result.\\n     */\\n    function calculateBorrowShares(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 shares = getTotalBorrowShares(\\n            _poolToken\\n        );\\n\\n        uint256 pseudo = getPseudoTotalBorrowAmount(\\n            _poolToken\\n        );\\n\\n        if (shares <= 1) {\\n            return _amount;\\n        }\\n\\n        if (pseudo == 0) {\\n            return _amount;\\n        }\\n\\n        return _amount\\n            * shares\\n            / pseudo;\\n    }\\n\\n    /**\\n     * @dev Helper function to convert {_shares}\\n     * of a certain pool with {_poolToken}\\n     * into lending token. Includes devison\\n     * by zero and share security checks.\\n     * Needs latest pseudo amount for accurate\\n     * result.\\n     */\\n    function cashoutAmount(\\n        address _poolToken,\\n        uint256 _shares\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _shares\\n            * getPseudoTotalPool(_poolToken)\\n            / getTotalDepositShares(_poolToken);\\n    }\\n\\n    /**\\n     * @dev Helper function to convert {_shares}\\n     * of a certain pool with {_poolToken}\\n     * into borrow token. Includes devison\\n     * by zero and share security checks.\\n     * Needs latest pseudo amount for accurate\\n     * result.\\n     */\\n    function paybackAmount(\\n        address _poolToken,\\n        uint256 _shares\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _shares\\n            * getPseudoTotalBorrowAmount(_poolToken)\\n            / getTotalBorrowShares(_poolToken);\\n    }\\n\\n    /**\\n     * @dev Internal helper combining one\\n     * security check with lending share\\n     * calculation for withdraw.\\n     */\\n    function _preparationsWithdraw(\\n        uint256 _nftId,\\n        address _caller,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        WISE_SECURITY.checkOwnerPosition(\\n            _nftId,\\n            _caller\\n        );\\n\\n        return calculateLendingShares(\\n            _poolToken,\\n            _amount\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal helper calculating utilization\\n     * of pool with {_poolToken}. Includes math underflow\\n     * check.\\n     */\\n    function _getValueUtilization(\\n        address _poolToken\\n    )\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        if (getTotalPool(_poolToken) >= getPseudoTotalPool(_poolToken)) {\\n            return 0;\\n        }\\n\\n        return PRECISION_FACTOR_E18 - (PRECISION_FACTOR_E18\\n            * getTotalPool(_poolToken)\\n            / getPseudoTotalPool(_poolToken)\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal helper function setting new pool\\n     * utilization by calling {_getValueUtilization}.\\n     */\\n    function _updateUtilization(\\n        address _poolToken\\n    )\\n        private\\n    {\\n        globalPoolData[_poolToken].utilization = _getValueUtilization(\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal helper function checking if\\n     * cleanup gathered new token to save into\\n     * pool variables.\\n     */\\n    function _checkCleanUp(\\n        uint256 _amountContract,\\n        uint256 _totalPool,\\n        uint256 _bareAmount\\n    )\\n        private\\n        pure\\n        returns (bool)\\n    {\\n        return _bareAmount + _totalPool >= _amountContract;\\n    }\\n\\n    /**\\n     * @dev Internal helper function checking if falsely\\n     * sent token are inside the contract for the pool with\\n     * {_poolToken}. If this is the case it adds those token\\n     * to the pool by increasing pseudo and total amount.\\n     * In context of aToken from aave pools it gathers the\\n     * rebase amount from supply APY of aave pools.\\n     */\\n    function _cleanUp(\\n        address _poolToken\\n    )\\n        internal\\n    {\\n        uint256 amountContract = IERC20(_poolToken).balanceOf(\\n            address(this)\\n        );\\n\\n        uint256 totalPool = getTotalPool(\\n            _poolToken\\n        );\\n\\n        uint256 bareToken = getTotalBareToken(\\n            _poolToken\\n        );\\n\\n        if (_checkCleanUp(amountContract, totalPool, bareToken)) {\\n            return;\\n        }\\n\\n        uint256 diff = amountContract - (\\n            totalPool + bareToken\\n        );\\n\\n        _increaseTotalAndPseudoTotalPool(\\n            _poolToken,\\n            diff\\n        );\\n    }\\n\\n    /**\\n     * @dev External wrapper for {_preparePole}\\n     * Only callable by powerFarms, feeManager\\n     * and aaveHub.\\n     */\\n    function preparePool(\\n        address _poolToken\\n    )\\n        external\\n        onlyAllowedContracts\\n    {\\n        _preparePool(\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev External wrapper for {_newBorrowRate}\\n     * Only callable by powerFarms, feeManager\\n     * and aaveHub.\\n     */\\n    function newBorrowRate(\\n        address _poolToken\\n    )\\n        external\\n        onlyAllowedContracts\\n    {\\n        _newBorrowRate(\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal helper function for\\n     * updating pools and calling {_cleanUp}.\\n     * Also includes re-entrancy guard for\\n     * curve pools security checks.\\n     */\\n    function _preparePool(\\n        address _poolToken\\n    )\\n        internal\\n    {\\n        WISE_SECURITY.curveSecurityCheck(\\n            _poolToken\\n        );\\n\\n        _cleanUp(\\n            _poolToken\\n        );\\n\\n        _updatePseudoTotalAmounts(\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal helper function for\\n     * updating all borrow tokens of a\\n     * position.\\n     */\\n    function _preparationBorrows(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        internal\\n    {\\n        _prepareTokens(\\n            _poolToken,\\n            positionBorrowTokenData[_nftId]\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal helper function for\\n     * updating all lending tokens of a\\n     * position.\\n     */\\n    function _preparationCollaterals(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        internal\\n    {\\n        _prepareTokens(\\n            _poolToken,\\n            positionLendingTokenData[_nftId]\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal helper function for\\n     * updating pseudo amounts of a pool\\n     * inside {tokens} array and sets new\\n     * borrow rates.\\n     */\\n    function _prepareTokens(\\n        address _poolToken,\\n        address[] memory tokens\\n    )\\n        private\\n    {\\n        address currentAddress;\\n\\n        for (uint8 i = 0; i < tokens.length; ++i) {\\n\\n            currentAddress = tokens[i];\\n\\n            if (currentAddress == _poolToken) {\\n                continue;\\n            }\\n\\n            _preparePool(\\n                currentAddress\\n            );\\n\\n            _newBorrowRate(\\n                currentAddress\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal helper function\\n     * updating pseudo amounts and\\n     * printing fee shares for the\\n     * feeManager proportional to the\\n     * fee percentage of the pool.\\n     */\\n    function _updatePseudoTotalAmounts(\\n        address _poolToken\\n    )\\n        internal\\n    {\\n        uint256 currentTime = block.timestamp;\\n\\n        uint256 bareIncrease = borrowPoolData[_poolToken].borrowRate\\n            * (currentTime - getTimeStamp(_poolToken))\\n            * getPseudoTotalBorrowAmount(_poolToken)\\n            + bufferIncrease[_poolToken];\\n\\n        if (bareIncrease < PRECISION_FACTOR_E18_YEAR) {\\n            bufferIncrease[_poolToken] = bareIncrease;\\n\\n            _setTimeStamp(\\n                _poolToken,\\n                currentTime\\n            );\\n\\n            return;\\n        }\\n\\n        delete bufferIncrease[_poolToken];\\n\\n        uint256 amountInterest = bareIncrease\\n            / PRECISION_FACTOR_E18_YEAR;\\n\\n        uint256 feeAmount = amountInterest\\n            * globalPoolData[_poolToken].poolFee\\n            / PRECISION_FACTOR_E18;\\n\\n        _increasePseudoTotalBorrowAmount(\\n            _poolToken,\\n            amountInterest\\n        );\\n\\n        _increasePseudoTotalPool(\\n            _poolToken,\\n            amountInterest\\n        );\\n\\n        if (feeAmount == 0) {\\n            return;\\n        }\\n\\n        uint256 feeShares = feeAmount\\n            * getTotalDepositShares(_poolToken)\\n            / (getPseudoTotalPool(_poolToken) - feeAmount);\\n\\n        _increasePositionLendingDeposit(\\n            FEE_MANAGER_NFT,\\n            _poolToken,\\n            feeShares\\n        );\\n\\n        _increaseTotalDepositShares(\\n            _poolToken,\\n            feeShares\\n        );\\n\\n        _setTimeStamp(\\n            _poolToken,\\n            currentTime\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal increas function for\\n     * lending shares of a postion {_nftId}\\n     * and {_poolToken}.\\n     */\\n    function _increasePositionLendingDeposit(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _shares\\n    )\\n        internal\\n    {\\n        userLendingData[_nftId][_poolToken].shares += _shares;\\n    }\\n\\n    /**\\n     * @dev Internal decrease function for\\n     * lending shares of a postion {_nftId}\\n     * and {_poolToken}.\\n     */\\n    function _decreaseLendingShares(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _shares\\n    )\\n        internal\\n    {\\n        userLendingData[_nftId][_poolToken].shares -= _shares;\\n    }\\n\\n    /**\\n     * @dev Internal helper function adding a new\\n     * {_poolToken} token to {userTokenData} if needed.\\n     * Check is done by using hash maps.\\n     */\\n    function _addPositionTokenData(\\n        uint256 _nftId,\\n        address _poolToken,\\n        mapping(bytes32 => bool) storage hashMap,\\n        mapping(uint256 => address[]) storage userTokenData\\n    )\\n        internal\\n    {\\n        bytes32 hashData = _getHash(\\n            _nftId,\\n            _poolToken\\n        );\\n\\n        if (hashMap[hashData] == true) {\\n            return;\\n        }\\n\\n        hashMap[hashData] = true;\\n\\n        userTokenData[_nftId].push(\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal helper calculating\\n     * a hash out of {_nftId} and {_poolToken}\\n     * using keccak256.\\n     */\\n    function _getHash(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(\\n            abi.encodePacked(\\n                _nftId,\\n                _poolToken\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal helper function deleting an\\n     * entry in {_deleteLastPositionData}.\\n     */\\n    function _removePositionData(\\n        uint256 _nftId,\\n        address _poolToken,\\n        function(uint256) view returns (uint256) _getPositionTokenLength,\\n        function(uint256, uint256) view returns (address) _getPositionTokenByIndex,\\n        function(uint256, address) internal _deleteLastPositionData,\\n        bool isLending\\n    )\\n        internal\\n    {\\n        uint256 length = _getPositionTokenLength(\\n            _nftId\\n        );\\n\\n        if (length == 1) {\\n            _deleteLastPositionData(\\n                _nftId,\\n                _poolToken\\n            );\\n\\n            return;\\n        }\\n\\n        uint8 index;\\n        uint256 endPosition = length - 1;\\n\\n        while (index < length) {\\n\\n            if (_getPositionTokenByIndex(_nftId, index) != _poolToken) {\\n                index += 1;\\n                continue;\\n            }\\n\\n            address poolToken = _getPositionTokenByIndex(\\n                _nftId,\\n                endPosition\\n            );\\n\\n            isLending\\n                ? positionLendingTokenData[_nftId][index] = poolToken\\n                : positionBorrowTokenData[_nftId][index] = poolToken;\\n\\n            _deleteLastPositionData(\\n                _nftId,\\n                _poolToken\\n            );\\n\\n            break;\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal helper deleting last entry\\n     * of postion lending data.\\n     */\\n    function _deleteLastPositionLendingData(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        internal\\n    {\\n        positionLendingTokenData[_nftId].pop();\\n        hashMapPositionLending[\\n            _getHash(\\n                _nftId,\\n                _poolToken\\n            )\\n        ] = false;\\n    }\\n\\n    /**\\n     * @dev Internal helper deleting last entry\\n     * of postion borrow data.\\n     */\\n    function _deleteLastPositionBorrowData(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        internal\\n    {\\n        positionBorrowTokenData[_nftId].pop();\\n        hashMapPositionBorrow[\\n            _getHash(\\n                _nftId,\\n                _poolToken\\n            )\\n        ] = false;\\n    }\\n\\n    /**\\n     * @dev Internal helper function calculating\\n     * returning if a {_poolToken} of a {_nftId}\\n     * is decollateralized.\\n     */\\n    function isDecollteralized(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return userLendingData[_nftId][_poolToken].deCollteralized;\\n    }\\n\\n    /**\\n     * @dev Internal helper function calculating\\n     * the borrow share amount corresponding to\\n     * certain {_lendingShares}.\\n     */\\n    function _borrowShareEquivalent(\\n        address _poolToken,\\n        uint256 _lendingShares\\n    )\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return _lendingShares\\n            * getPseudoTotalPool(_poolToken)\\n            * getTotalBorrowShares(_poolToken)\\n            / getTotalDepositShares(_poolToken)\\n            / getPseudoTotalBorrowAmount(_poolToken);\\n    }\\n\\n    /**\\n     * @dev Internal helper function\\n     * checking if {_nftId} as no\\n     * {_poolToken} left.\\n     */\\n    function checkLendingDataEmpty(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return userLendingData[_nftId][_poolToken].shares == 0\\n            && positionPureCollateralAmount[_nftId][_poolToken] == 0;\\n    }\\n\\n    /**\\n     * @dev Internal helper function\\n     * calculating new borrow rates\\n     * for {_poolToken}. Uses smooth\\n     * functions of the form\\n     * f(x) = a * x /(p(p-x)) with\\n     * p > 1E18 the {pole} and\\n     * a the {mulFactor}.\\n     */\\n\\n    function _calculateNewBorrowRate(\\n        address _poolToken\\n    )\\n        internal\\n    {\\n        uint256 pole = borrowRatesData[_poolToken].pole;\\n        uint256 utilization = globalPoolData[_poolToken].utilization;\\n\\n        uint256 baseDivider = pole\\n            * (pole - utilization);\\n\\n        _setBorrowRate(\\n            _poolToken,\\n            borrowRatesData[_poolToken].multiplicativeFactor\\n                * PRECISION_FACTOR_E18\\n                * utilization\\n                / baseDivider\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal helper function\\n     * updating utilization of the pool\\n     * with {_poolToken}, calculating the\\n     * new borrow rate and running LASA if\\n     * the time intervall of three hours has\\n     * passed.\\n     */\\n    function _newBorrowRate(\\n        address _poolToken\\n    )\\n        internal\\n    {\\n        _updateUtilization(\\n            _poolToken\\n        );\\n\\n        _calculateNewBorrowRate(\\n            _poolToken\\n        );\\n\\n        if (_aboveThreshold(_poolToken) == false) {\\n            return;\\n        }\\n\\n        _scalingAlgorithm(\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal helper function\\n     * checking if time interval for\\n     * next LASA call has passed.\\n     */\\n    function _aboveThreshold(\\n        address _poolToken\\n    )\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return block.timestamp - _getTimeStampScaling(_poolToken) >= THREE_HOURS;\\n    }\\n\\n    /**\\n     * @dev function that tries to maximise totalDepositShares of the pool.\\n     * Reacting to negative and positive feedback by changing the resonance\\n     * factor of the pool. Method similar to one parameter monte-carlo methods\\n     */\\n    function _scalingAlgorithm(\\n        address _poolToken\\n    )\\n        private\\n    {\\n        uint256 totalShares = getTotalDepositShares(\\n            _poolToken\\n        );\\n\\n        if (algorithmData[_poolToken].maxValue <= totalShares) {\\n\\n            _newMaxPoolShares(\\n                _poolToken,\\n                totalShares\\n            );\\n\\n            _saveUp(\\n                _poolToken,\\n                totalShares\\n            );\\n\\n            return;\\n        }\\n\\n        _resonanceOutcome(_poolToken, totalShares) == true\\n            ? _resetResonanceFactor(_poolToken, totalShares)\\n            : _updateResonanceFactor(_poolToken, totalShares);\\n\\n        _saveUp(\\n            _poolToken,\\n            totalShares\\n        );\\n    }\\n\\n    /**\\n     * @dev Sets the new max value in shares\\n     * and saves the corresponding resonance factor.\\n     */\\n    function _newMaxPoolShares(\\n        address _poolToken,\\n        uint256 _shareValue\\n    )\\n        private\\n    {\\n        _setMaxValue(\\n            _poolToken,\\n            _shareValue\\n        );\\n\\n        _setBestPole(\\n            _poolToken,\\n            borrowRatesData[_poolToken].pole\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal function setting {previousValue}\\n     * and {timestampScaling} for LASA of pool with\\n     * {_poolToken}.\\n     */\\n    function _saveUp(\\n        address _poolToken,\\n        uint256 _shareValue\\n    )\\n        private\\n    {\\n        _setPreviousValue(\\n            _poolToken,\\n            _shareValue\\n        );\\n\\n        _setTimeStampScaling(\\n            _poolToken,\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev Returns bool to determine if resonance\\n     * factor needs to be reset to last best value.\\n     */\\n    function _resonanceOutcome(\\n        address _poolToken,\\n        uint256 _shareValue\\n    )\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return _shareValue < THRESHOLD_RESET_RESONANCE_FACTOR\\n            * algorithmData[_poolToken].maxValue\\n            / PRECISION_FACTOR_E18;\\n    }\\n\\n    /**\\n     * @dev Resets resonance factor to old best value when system\\n     * evolves into too bad state and sets current totalDepositShares\\n     * amount to new maxPoolShares to exclude eternal loops and that\\n     * unorganic peaks do not set maxPoolShares forever.\\n     */\\n    function _resetResonanceFactor(\\n        address _poolToken,\\n        uint256 _shareValue\\n    )\\n        private\\n    {\\n        _setPole(\\n            _poolToken,\\n            algorithmData[_poolToken].bestPole\\n        );\\n\\n        _setMaxValue(\\n            _poolToken,\\n            _shareValue\\n        );\\n\\n        _revertDirectionSteppingState(\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev Reverts the flag for stepping direction from LASA.\\n     */\\n    function _revertDirectionSteppingState(\\n        address _poolToken\\n    )\\n        private\\n    {\\n        _setIncreasePole(\\n            _poolToken,\\n            !algorithmData[_poolToken].increasePole\\n        );\\n    }\\n\\n    /**\\n     * @dev Function combining all possible stepping scenarios.\\n     * Depending how share values has changed compared to last time.\\n     */\\n    function _updateResonanceFactor(\\n        address _poolToken,\\n        uint256 _shareValues\\n    )\\n        private\\n    {\\n        _shareValues < THRESHOLD_SWITCH_DIRECTION * algorithmData[_poolToken].previousValue / PRECISION_FACTOR_E18\\n            ? _reversedChangingResonanceFactor(_poolToken)\\n            : _changingResonanceFactor(_poolToken);\\n    }\\n\\n    /**\\n     * @dev Does a revert stepping and swaps stepping state in opposite flag.\\n     */\\n    function _reversedChangingResonanceFactor(\\n        address _poolToken\\n    )\\n        private\\n    {\\n        algorithmData[_poolToken].increasePole\\n            ? _decreaseResonanceFactor(_poolToken)\\n            : _increaseResonanceFactor(_poolToken);\\n\\n        _revertDirectionSteppingState(\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev Increasing or decresing resonance factor depending on flag value.\\n     */\\n    function _changingResonanceFactor(\\n        address _poolToken\\n    )\\n        private\\n    {\\n        algorithmData[_poolToken].increasePole\\n            ? _increaseResonanceFactor(_poolToken)\\n            : _decreaseResonanceFactor(_poolToken);\\n    }\\n\\n    /**\\n     * @dev stepping function increasing the resonance factor\\n     * depending on the time past in the last time interval.\\n     * Checks if current resonance factor is bigger than max value.\\n     * If this is the case sets current value to maximal value\\n     */\\n    function _increaseResonanceFactor(\\n        address _poolToken\\n    )\\n        private\\n    {\\n        BorrowRatesEntry memory borrowData = borrowRatesData[\\n            _poolToken\\n        ];\\n\\n        uint256 delta = borrowData.deltaPole\\n            * (block.timestamp - _getTimeStampScaling(_poolToken));\\n\\n        uint256 sum = delta\\n            + borrowData.pole;\\n\\n        uint256 setValue = sum > borrowData.maxPole\\n            ? borrowData.maxPole\\n            : sum;\\n\\n        _setPole(\\n            _poolToken,\\n            setValue\\n        );\\n    }\\n\\n    /**\\n     * @dev Stepping function decresing the resonance factor\\n     * depending on the time past in the last time interval.\\n     * Checks if current resonance factor undergoes the min value,\\n     * if this is the case sets current value to minimal value.\\n     */\\n    function _decreaseResonanceFactor(\\n        address _poolToken\\n    )\\n        private\\n    {\\n        uint256 minValue = borrowRatesData[_poolToken].minPole;\\n\\n        uint256 delta = borrowRatesData[_poolToken].deltaPole\\n            * (block.timestamp - _getTimeStampScaling(_poolToken));\\n\\n        uint256 sub = borrowRatesData[_poolToken].pole > delta\\n            ? borrowRatesData[_poolToken].pole - delta\\n            : 0;\\n\\n        uint256 setValue = sub < minValue\\n            ? minValue\\n            : sub;\\n\\n        _setPole(\\n            _poolToken,\\n            setValue\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal helper function for removing token address\\n     * from lending data array if all shares are removed. When\\n     * feeManager (nftId = 0) is calling this function is skipped\\n     * to save gase for continues fee accounting.\\n     */\\n    function _removeEmptyLendingData(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        internal\\n    {\\n        if (_nftId == 0) {\\n            return;\\n        }\\n\\n        if (checkLendingDataEmpty(_nftId, _poolToken) == false) {\\n            return;\\n        }\\n\\n        _removePositionData({\\n            _nftId: _nftId,\\n            _poolToken: _poolToken,\\n            _getPositionTokenLength: getPositionLendingTokenLength,\\n            _getPositionTokenByIndex: getPositionLendingTokenByIndex,\\n            _deleteLastPositionData: _deleteLastPositionLendingData,\\n            isLending: true\\n        });\\n    }\\n\\n    /**\\n     * @dev Internal helper function grouping several function\\n     * calls into one function for refactoring and code size\\n     * reduction.\\n     */\\n    function _updatePoolStorage(\\n        address _poolToken,\\n        uint256 _amount,\\n        uint256 _shares,\\n        function(address, uint256) functionAmountA,\\n        function(address, uint256) functionAmountB,\\n        function(address, uint256) functionSharesA\\n    )\\n        internal\\n    {\\n        functionAmountA(\\n            _poolToken,\\n            _amount\\n        );\\n\\n        functionAmountB(\\n            _poolToken,\\n            _amount\\n        );\\n\\n        functionSharesA(\\n            _poolToken,\\n            _shares\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TransferHub/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.21;\\n\\nimport \\\"./CallOptionalReturn.sol\\\";\\n\\ncontract TransferHelper is CallOptionalReturn {\\n\\n    bytes4 constant transfer = IERC20\\n        .transfer\\n        .selector;\\n\\n    bytes4 constant transferFrom = IERC20\\n        .transferFrom\\n        .selector;\\n\\n    /**\\n     * @dev\\n     * Allows to execute safe transfer for a token\\n     */\\n    function _safeTransfer(\\n        address _token,\\n        address _to,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        _callOptionalReturn(\\n            _token,\\n            abi.encodeWithSelector(\\n                transfer,\\n                _to,\\n                _value\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev\\n     * Allows to execute safe transferFrom for a token\\n     */\\n    function _safeTransferFrom(\\n        address _token,\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        _callOptionalReturn(\\n            _token,\\n            abi.encodeWithSelector(\\n                transferFrom,\\n                _from,\\n                _to,\\n                _value\\n            )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/WiseLowLevelHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.21;\\n\\nimport \\\"./WiseLendingDeclaration.sol\\\";\\n\\nabstract contract WiseLowLevelHelper is WiseLendingDeclaration {\\n\\n    modifier onlyFeeManager() {\\n        _onlyFeeManager();\\n        _;\\n    }\\n\\n    function _onlyFeeManager()\\n        private\\n        view\\n    {\\n        if (msg.sender == address(FEE_MANAGER)) {\\n            return;\\n        }\\n\\n        revert InvalidCaller();\\n    }\\n\\n    modifier onlyAllowedContracts() {\\n        _onlyAllowedContracts();\\n        _;\\n    }\\n\\n    function _onlyAllowedContracts()\\n        private\\n        view\\n    {\\n        if (_byPassCase(msg.sender) == true) {\\n            return;\\n        }\\n\\n        if (msg.sender == address(FEE_MANAGER)) {\\n            return;\\n        }\\n\\n        revert InvalidCaller();\\n    }\\n\\n    // --- Basic Public Views Functions ----\\n\\n    function getTotalPool(\\n        address _poolToken\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return globalPoolData[_poolToken].totalPool;\\n    }\\n\\n    function getPseudoTotalPool(\\n        address _poolToken\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return lendingPoolData[_poolToken].pseudoTotalPool;\\n    }\\n\\n    function getTotalBareToken(\\n        address _poolToken\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return globalPoolData[_poolToken].totalBareToken;\\n    }\\n\\n    function getPseudoTotalBorrowAmount(\\n        address _poolToken\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return borrowPoolData[_poolToken].pseudoTotalBorrowAmount;\\n    }\\n\\n    function getTotalDepositShares(\\n        address _poolToken\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return lendingPoolData[_poolToken].totalDepositShares;\\n    }\\n\\n    function getTotalBorrowShares(\\n        address _poolToken\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return borrowPoolData[_poolToken].totalBorrowShares;\\n    }\\n\\n    function getPositionLendingShares(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return userLendingData[_nftId][_poolToken].shares;\\n    }\\n\\n    function getPositionBorrowShares(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return userBorrowShares[_nftId][_poolToken];\\n    }\\n\\n    function getPureCollateralAmount(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return positionPureCollateralAmount[_nftId][_poolToken];\\n    }\\n\\n    // --- Basic Internal Get Functions ----\\n\\n    function getTimeStamp(\\n        address _poolToken\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return timestampsPoolData[_poolToken].timeStamp;\\n    }\\n\\n    function _getTimeStampScaling(\\n        address _poolToken\\n    )\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return timestampsPoolData[_poolToken].timeStampScaling;\\n    }\\n\\n    function getPositionLendingTokenByIndex(\\n        uint256 _nftId,\\n        uint256 _index\\n    )\\n        public\\n        view\\n        returns (address)\\n    {\\n        return positionLendingTokenData[_nftId][_index];\\n    }\\n\\n    function getPositionLendingTokenLength(\\n        uint256 _nftId\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return positionLendingTokenData[_nftId].length;\\n    }\\n\\n    function getPositionBorrowTokenByIndex(\\n        uint256 _nftId,\\n        uint256 _index\\n    )\\n        public\\n        view\\n        returns (address)\\n    {\\n        return positionBorrowTokenData[_nftId][_index];\\n    }\\n\\n    function getPositionBorrowTokenLength(\\n        uint256 _nftId\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return positionBorrowTokenData[_nftId].length;\\n    }\\n\\n    // --- Basic Internal Set Functions ----\\n\\n    function _setMaxValue(\\n        address _poolToken,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        algorithmData[_poolToken].maxValue = _value;\\n    }\\n\\n    function _setPreviousValue(\\n        address _poolToken,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        algorithmData[_poolToken].previousValue = _value;\\n    }\\n\\n    function _setBestPole(\\n        address _poolToken,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        algorithmData[_poolToken].bestPole = _value;\\n    }\\n\\n    function _setIncreasePole(\\n        address _poolToken,\\n        bool _state\\n    )\\n        internal\\n    {\\n        algorithmData[_poolToken].increasePole = _state;\\n    }\\n\\n    function _setPole(\\n        address _poolToken,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        borrowRatesData[_poolToken].pole = _value;\\n    }\\n\\n    function _increaseTotalPool(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        globalPoolData[_poolToken].totalPool += _amount;\\n    }\\n\\n    function _decreaseTotalPool(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        globalPoolData[_poolToken].totalPool -= _amount;\\n    }\\n\\n    function _increaseTotalDepositShares(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        lendingPoolData[_poolToken].totalDepositShares += _amount;\\n    }\\n\\n    function _decreaseTotalDepositShares(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        lendingPoolData[_poolToken].totalDepositShares -= _amount;\\n    }\\n\\n    function _increasePseudoTotalBorrowAmount(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        borrowPoolData[_poolToken].pseudoTotalBorrowAmount += _amount;\\n    }\\n\\n    function _decreasePseudoTotalBorrowAmount(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        borrowPoolData[_poolToken].pseudoTotalBorrowAmount -= _amount;\\n    }\\n\\n    function _increaseTotalBorrowShares(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        borrowPoolData[_poolToken].totalBorrowShares += _amount;\\n    }\\n\\n    function _decreaseTotalBorrowShares(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        borrowPoolData[_poolToken].totalBorrowShares -= _amount;\\n    }\\n\\n    function _increasePseudoTotalPool(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        lendingPoolData[_poolToken].pseudoTotalPool += _amount;\\n    }\\n\\n    function _decreasePseudoTotalPool(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        lendingPoolData[_poolToken].pseudoTotalPool -= _amount;\\n    }\\n\\n    function _setBorrowRate(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        borrowPoolData[_poolToken].borrowRate = _amount;\\n    }\\n\\n    function _setTimeStamp(\\n        address _poolToken,\\n        uint256 _time\\n    )\\n        internal\\n    {\\n        timestampsPoolData[_poolToken].timeStamp = _time;\\n    }\\n\\n    function _setTimeStampScaling(\\n        address _poolToken,\\n        uint256 _time\\n    )\\n        internal\\n    {\\n        timestampsPoolData[_poolToken].timeStampScaling = _time;\\n    }\\n\\n    function _increaseTotalBareToken(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        globalPoolData[_poolToken].totalBareToken += _amount;\\n    }\\n\\n    function _decreaseTotalBareToken(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        globalPoolData[_poolToken].totalBareToken -= _amount;\\n    }\\n\\n    function _reduceAllowance(\\n        uint256 _nftId,\\n        address _poolToken,\\n        address _spender,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        if (POSITION_NFT.getApproved(_nftId) == _spender) {\\n            return;\\n        }\\n\\n        address owner = POSITION_NFT.ownerOf(\\n            _nftId\\n        );\\n\\n        if (allowance[owner][_poolToken][_spender] != type(uint256).max) {\\n            allowance[owner][_poolToken][_spender] -= _amount;\\n        }\\n    }\\n\\n    function _decreasePositionMappingValue(\\n        mapping(uint256 => mapping(address => uint256)) storage userMapping,\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        userMapping[_nftId][_poolToken] -= _amount;\\n    }\\n\\n    function _increaseMappingValue(\\n        mapping(uint256 => mapping(address => uint256)) storage userMapping,\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        userMapping[_nftId][_poolToken] += _amount;\\n    }\\n\\n    function _byPassCase(\\n        address _sender\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        if (_sender == AAVE_HUB) {\\n            return true;\\n        }\\n\\n        if (veryfiedIsolationPool[_sender] == true) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    function _increaseTotalAndPseudoTotalPool(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        _increasePseudoTotalPool(\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _increaseTotalPool(\\n            _poolToken,\\n            _amount\\n        );\\n    }\\n\\n    function setPoolFee(\\n        address _poolToken,\\n        uint256 _newFee\\n    )\\n        external\\n        onlyFeeManager\\n    {\\n        globalPoolData[_poolToken].poolFee = _newFee;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/WiseLendingDeclaration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.21;\\n\\nimport \\\"./InterfaceHub/IWETH.sol\\\";\\nimport \\\"./InterfaceHub/IPositionNFTs.sol\\\";\\nimport \\\"./InterfaceHub/IWiseSecurity.sol\\\";\\nimport \\\"./InterfaceHub/IWiseOracleHub.sol\\\";\\nimport \\\"./InterfaceHub/IFeeManagerLight.sol\\\";\\n\\nimport \\\"./OwnableMaster.sol\\\";\\n\\nerror InvalidCaller();\\nerror AlreadyCreated();\\nerror PositionLocked();\\nerror ForbiddenValue();\\nerror ParametersLocked();\\nerror DepositCapReached();\\nerror CollateralTooSmall();\\n\\ncontract WiseLendingDeclaration is OwnableMaster {\\n\\n    event FundsDeposited(\\n        address indexed sender,\\n        uint256 indexed nftId,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares,\\n        uint256 timestamp\\n    );\\n\\n    event FundsSolelyDeposited(\\n        address indexed sender,\\n        uint256 indexed nftId,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 timestamp\\n    );\\n\\n    event FundsWithdrawn(\\n        address indexed sender,\\n        uint256 indexed nftId,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares,\\n        uint256 timestamp\\n    );\\n\\n    event FundsWithdrawnOnBehalf(\\n        address indexed sender,\\n        uint256 indexed nftId,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares,\\n        uint256 timestamp\\n    );\\n\\n    event FundsSolelyWithdrawn(\\n        address indexed sender,\\n        uint256 indexed nftId,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 timestamp\\n    );\\n\\n    event FundsSolelyWithdrawnOnBehalf(\\n        address indexed sender,\\n        uint256 indexed nftId,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 timestamp\\n    );\\n\\n    event FundsBorrowed(\\n        address indexed borrower,\\n        uint256 indexed nftId,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares,\\n        uint256 timestamp\\n    );\\n\\n    event FundsBorrowedOnBehalf(\\n        address indexed sender,\\n        uint256 indexed nftId,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares,\\n        uint256 timestamp\\n    );\\n\\n    event FundsReturned(\\n        address indexed sender,\\n        address indexed token,\\n        uint256 indexed nftId,\\n        uint256 totalPayment,\\n        uint256 totalPaymentShares,\\n        uint256 timestamp\\n    );\\n\\n    event FundsReturnedWithLendingShares(\\n        address indexed sender,\\n        address indexed token,\\n        uint256 indexed nftId,\\n        uint256 totalPayment,\\n        uint256 totalPaymentShares,\\n        uint256 timestamp\\n    );\\n\\n    event Approve(\\n        address indexed sender,\\n        address indexed token,\\n        address indexed user,\\n        uint256 amount,\\n        uint256 timestamp\\n    );\\n\\n    event PoolSynced(\\n        address pool,\\n        uint256 timestamp\\n    );\\n\\n    event RegisteredForIsolationPool(\\n        address user,\\n        uint256 timestamp,\\n        bool registration\\n    );\\n\\n    constructor(\\n        address _master,\\n        address _wiseOracleHub,\\n        address _nftContract,\\n        address _wethContract\\n    )\\n        OwnableMaster(\\n            _master\\n        )\\n    {\\n        WETH_ADDRESS = _wethContract;\\n\\n        WETH = IWETH(\\n            _wethContract\\n        );\\n\\n        WISE_ORACLE = IWiseOracleHub(\\n            _wiseOracleHub\\n        );\\n\\n        POSITION_NFT = IPositionNFTs(\\n            _nftContract\\n        );\\n    }\\n\\n    function setSecurity(\\n        address _wiseSecurity\\n    )\\n        external\\n        onlyMaster\\n    {\\n        WISE_SECURITY = IWiseSecurity(\\n            _wiseSecurity\\n        );\\n\\n        FEE_MANAGER = IFeeManagerLight(\\n            WISE_SECURITY.FEE_MANAGER()\\n        );\\n\\n        AAVE_HUB = WISE_SECURITY.AAVE_HUB();\\n    }\\n\\n    /**\\n     * @dev Wrapper for wrapping\\n     * ETH call.\\n     */\\n    function _wrapETH(\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        WETH.deposit{\\n            value: _value\\n        }();\\n    }\\n\\n    /**\\n     * @dev Wrapper for unwrapping\\n     * ETH call.\\n     */\\n    function _unwrapETH(\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        WETH.withdraw(\\n            _value\\n        );\\n    }\\n\\n    // Variables -----------------------------------------\\n\\n    // Aave address\\n    address public AAVE_HUB;\\n\\n    // Wrapped ETH address\\n    address public immutable WETH_ADDRESS;\\n\\n    // Nft id for feeManager\\n    uint256 constant FEE_MANAGER_NFT = 0;\\n\\n\\n    // Interfaces -----------------------------------------\\n\\n    // Wrapped ETH interface\\n    IWETH immutable WETH;\\n\\n    // WiseSecurity interface\\n    IWiseSecurity public WISE_SECURITY;\\n\\n    // FeeManager interface\\n    IFeeManagerLight public FEE_MANAGER;\\n\\n    // NFT contract interface for positions\\n    IPositionNFTs public immutable POSITION_NFT;\\n\\n    // OraceHub interface\\n    IWiseOracleHub public immutable WISE_ORACLE;\\n\\n    // Structs ------------------------------------------\\n\\n    struct LendingEntry {\\n        uint256 shares;\\n        bool deCollteralized;\\n    }\\n\\n    struct BorrowRatesEntry {\\n        uint256 pole;\\n        uint256 deltaPole;\\n        uint256 minPole;\\n        uint256 maxPole;\\n        uint256 multiplicativeFactor;\\n    }\\n\\n    struct AlgorithmEntry {\\n        uint256 bestPole;\\n        uint256 maxValue;\\n        uint256 previousValue;\\n        bool increasePole;\\n    }\\n\\n    struct GlobalPoolEntry {\\n        uint256 totalPool;\\n        uint256 utilization;\\n        uint256 totalBareToken;\\n        uint256 poolFee;\\n    }\\n\\n    struct LendingPoolEntry {\\n        uint256 pseudoTotalPool;\\n        uint256 totalDepositShares;\\n        uint256 collateralFactor;\\n    }\\n\\n    struct BorrowPoolEntry {\\n        bool allowBorrow;\\n        uint256 pseudoTotalBorrowAmount;\\n        uint256 totalBorrowShares;\\n        uint256 borrowRate;\\n    }\\n\\n    struct TimestampsPoolEntry {\\n        uint256 timeStamp;\\n        uint256 timeStampScaling;\\n    }\\n\\n    // Position mappings ------------------------------------------\\n    mapping(address => uint256) bufferIncrease;\\n    mapping(address => uint256) public maxDepositValueToken;\\n\\n    mapping(uint256 => address[]) public positionBorrowTokenData;\\n    mapping(uint256 => address[]) public positionLendingTokenData;\\n\\n    mapping(uint256 => mapping(address => uint256)) public userBorrowShares;\\n    mapping(uint256 => mapping(address => LendingEntry)) public userLendingData;\\n    mapping(uint256 => mapping(address => uint256)) public positionPureCollateralAmount;\\n\\n    // Owner -> PoolToken -> Spender -> Allowance Value\\n    mapping(address => mapping(address => mapping(address => uint256))) public allowance;\\n\\n    // Struct mappings -------------------------------------\\n    mapping(address => BorrowRatesEntry) public borrowRatesData;\\n    mapping(address => AlgorithmEntry) public algorithmData;\\n    mapping(address => GlobalPoolEntry) public globalPoolData;\\n    mapping(address => LendingPoolEntry) public lendingPoolData;\\n    mapping(address => BorrowPoolEntry) public borrowPoolData;\\n    mapping(address => TimestampsPoolEntry) public timestampsPoolData;\\n\\n    // Bool mappings -------------------------------------\\n    mapping(uint256 => bool) public positionLocked;\\n    mapping(address => bool) public parametersLocked;\\n    mapping(address => bool) public veryfiedIsolationPool;\\n\\n    // Hash mappings -------------------------------------\\n    mapping(bytes32 => bool) hashMapPositionBorrow;\\n    mapping(bytes32 => bool) hashMapPositionLending;\\n\\n    // PRECISION FACTORS ------------------------------------\\n    uint256 constant PRECISION_FACTOR_E16 = 1E16;\\n    uint256 constant PRECISION_FACTOR_E18 = 1E18;\\n    uint256 constant PRECISION_FACTOR_E36 = PRECISION_FACTOR_E18 * PRECISION_FACTOR_E18;\\n\\n    // TIME CONSTANTS --------------------------------------\\n    uint256 constant ONE_YEAR = 52 weeks;\\n    uint256 constant THREE_HOURS = 3 hours;\\n    uint256 constant PRECISION_FACTOR_E18_YEAR = PRECISION_FACTOR_E18 * ONE_YEAR;\\n\\n    // Two months in seconds:\\n    // Norming change in pole value that it steps from min to max value\\n    // within two month (if nothing changes)\\n    uint256 constant NORMALISATION_FACTOR = 4838400;\\n\\n    // LASA CONSTANTS -------------------------\\n    uint256 constant THRESHOLD_SWITCH_DIRECTION = 90 * PRECISION_FACTOR_E16;\\n    uint256 constant THRESHOLD_RESET_RESONANCE_FACTOR = 75 * PRECISION_FACTOR_E16;\\n}\\n\"\r\n    },\r\n    \"contracts/TransferHub/CallOptionalReturn.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.21;\\n\\nimport \\\"../InterfaceHub/IERC20.sol\\\";\\n\\nerror CallFailed();\\n\\ncontract CallOptionalReturn {\\n\\n    /**\\n     * @dev\\n     * Helper function to do low-level call\\n     */\\n    function _callOptionalReturn(\\n        address token,\\n        bytes memory data\\n    )\\n        internal\\n        returns (bool call)\\n    {\\n        (\\n            bool success,\\n            bytes memory returndata\\n        ) = token.call(\\n            data\\n        );\\n\\n        bool results = returndata.length == 0 || abi.decode(\\n            returndata,\\n            (bool)\\n        );\\n\\n        call = success\\n            && results\\n            && token.code.length > 0;\\n\\n        if (call == false) {\\n            revert CallFailed();\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/OwnableMaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.21;\\n\\nerror NotMaster();\\nerror NotProposed();\\n\\ncontract OwnableMaster {\\n\\n    address public master;\\n    address public proposedMaster;\\n\\n    address constant ZERO_ADDRESS = address(0x0);\\n\\n    modifier onlyProposed() {\\n        _onlyProposed();\\n        _;\\n    }\\n\\n    function _onlyMaster()\\n        private\\n        view\\n    {\\n        if (msg.sender == master) {\\n            return;\\n        }\\n\\n        revert NotMaster();\\n    }\\n\\n    modifier onlyMaster() {\\n        _onlyMaster();\\n        _;\\n    }\\n\\n    function _onlyProposed()\\n        private\\n        view\\n    {\\n        if (msg.sender == proposedMaster) {\\n            return;\\n        }\\n\\n        revert NotProposed();\\n    }\\n\\n    constructor(\\n        address _master\\n    ) {\\n        master = _master;\\n    }\\n\\n    /**\\n     * @dev Allows to propose next master.\\n     * Must be claimed by proposer.\\n     */\\n    function proposeOwner(\\n        address _proposedOwner\\n    )\\n        external\\n        onlyMaster\\n    {\\n        proposedMaster = _proposedOwner;\\n    }\\n\\n    /**\\n     * @dev Allows to claim master role.\\n     * Must be called by proposer.\\n     */\\n    function claimOwnership()\\n        external\\n        onlyProposed\\n    {\\n        master = proposedMaster;\\n    }\\n\\n    /**\\n     * @dev Removes master role.\\n     * No ability to be in control.\\n     */\\n    function renounceOwnership()\\n        external\\n        onlyMaster\\n    {\\n        master = ZERO_ADDRESS;\\n        proposedMaster = ZERO_ADDRESS;\\n    }\\n}\"\r\n    },\r\n    \"contracts/InterfaceHub/IFeeManagerLight.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.21;\\n\\ninterface IFeeManagerLight {\\n    function addPoolTokenAddress(\\n        address _poolToken\\n    )\\n        external;\\n}\\n\"\r\n    },\r\n    \"contracts/InterfaceHub/IWiseOracleHub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.21;\\n\\ninterface IWiseOracleHub {\\n\\n    function latestResolver(\\n        address _tokenAddress\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getTokensFromUSD(\\n        address _tokenAddress,\\n        uint256 _usdValue\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getTokensInUSD(\\n        address _tokenAddress,\\n        uint256 _amount\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function chainLinkIsDead(\\n        address _tokenAddress\\n    )\\n        external\\n        view\\n        returns (bool);\\n\\n    function decimalsUSD()\\n        external\\n        pure\\n        returns (uint8);\\n\\n    function previousValue(\\n        address _tokenAddress\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function setPreviousValue(\\n        address _tokenAddress\\n    )\\n        external;\\n}\"\r\n    },\r\n    \"contracts/InterfaceHub/IWiseSecurity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.21;\\n\\nstruct CurveSwapStructToken {\\n    uint256 curvePoolTokenIndexFrom;\\n    uint256 curvePoolTokenIndexTo;\\n    uint256 curveMetaPoolTokenIndexFrom;\\n    uint256 curveMetaPoolTokenIndexTo;\\n}\\n\\nstruct CurveSwapStructData {\\n    address curvePool;\\n    address curveMetaPool;\\n    bytes swapBytesPool;\\n    bytes swapBytesMeta;\\n}\\n\\ninterface IWiseSecurity {\\n\\n    function overallUSDBorrowHeartbeat(\\n        uint256 _nftId\\n    )\\n        external\\n        view\\n        returns (uint256 buffer);\\n\\n    function checkBadDebt(\\n        uint256 _nftId\\n    )\\n        external;\\n\\n    function getFullCollateralUSD(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function checksLiquidation(\\n        uint256 _nftIdLiquidate,\\n        address _tokenToPayback,\\n        uint256 _shareAmountToPay\\n    )\\n        external\\n        view;\\n\\n    function getPositionBorrowAmount(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getPositionLendingAmount(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getLiveDebtratioNormalPool(\\n        uint256 _nftId\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function overallUSDCollateralsBare(\\n        uint256 _nftId\\n    )\\n        external\\n        view\\n        returns (uint256 amount);\\n\\n    function FEE_MANAGER()\\n        external\\n        returns (address);\\n\\n    function AAVE_HUB()\\n        external\\n        returns (address);\\n\\n    function curveSecurityCheck(\\n        address _poolAddress\\n    )\\n        external;\\n\\n    function prepareCurvePools(\\n        address _poolToken,\\n        CurveSwapStructData memory _curveSwapStructData,\\n        CurveSwapStructToken memory _curveSwapStructToken\\n    )\\n        external;\\n\\n    function checksWithdraw(\\n        uint256 _nftId,\\n        address _caller,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        external\\n        view;\\n\\n    function checksBorrow(\\n        uint256 _nftId,\\n        address _caller,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        external\\n        view;\\n\\n    function checksSolelyWithdraw(\\n        uint256 _nftId,\\n        address _caller,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        external\\n        view;\\n\\n    function checkOwnerPosition(\\n        uint256 _nftId,\\n        address _caller\\n    )\\n        external\\n        view;\\n\\n    function checksCollateralizeDeposit(\\n        uint256 _nftIdCaller,\\n        address _caller,\\n        address _poolAddress\\n    )\\n        external\\n        view;\\n\\n    function calculateWishPercentage(\\n        uint256 _nftId,\\n        address _receiveToken,\\n        uint256 _paybackUSD,\\n        uint256 _maxFeeUSD,\\n        uint256 _baseRewardLiquidation\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function checksDecollateralizeDeposit(\\n        uint256 _nftIdCaller,\\n        address _poolToken\\n    )\\n        external\\n        view;\\n\\n    function checkBorrowLimit(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        external\\n        view;\\n\\n    function checkPositionLocked(\\n        uint256 _nftId,\\n        address _caller\\n    )\\n        external\\n        view;\\n\\n    function checkPaybackLendingShares(\\n        uint256 _nftIdReceiver,\\n        uint256 _nftIdCaller,\\n        address _caller,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        external\\n        view;\\n\\n    function maxFeeUSD()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function maxFeeFarmUSD()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function baseRewardLiquidation()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function baseRewardLiquidationFarm()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function checksRegister(\\n        uint256 _nftId,\\n        address _caller\\n    )\\n        external\\n        view;\\n\\n    function getLendingRate(\\n        address _poolToken\\n    )\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/InterfaceHub/IPositionNFTs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.21;\\n\\ninterface IPositionNFTs {\\n\\n    function ownerOf(\\n        uint256 _nftId\\n    )\\n        external\\n        view\\n        returns (address);\\n\\n    function getOwner(\\n        uint256 _nftId\\n    )\\n        external\\n        view\\n        returns (address);\\n\\n\\n    function totalSupply()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function reserved(\\n        address _owner\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function reservePosition()\\n        external;\\n\\n    function mintPosition()\\n        external;\\n\\n    function tokenOfOwnerByIndex(\\n        address _owner,\\n        uint256 _index\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function mintPositionForUser(\\n        address _user\\n    )\\n        external\\n        returns (uint256);\\n\\n    function reservePositionForUser(\\n        address _user\\n    )\\n        external\\n        returns (uint256);\\n\\n    function getApproved(\\n        uint256 _nftId\\n    )\\n        external\\n        returns (address);\\n}\"\r\n    },\r\n    \"contracts/InterfaceHub/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.21;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n\\n    function deposit()\\n        external\\n        payable;\\n\\n    function withdraw(\\n        uint256\\n    )\\n        external;\\n}\\n\"\r\n    },\r\n    \"contracts/InterfaceHub/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.21;\\n\\ninterface IERC20 {\\n\\n    function totalSupply()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function balanceOf(\\n        address _account\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function transferFrom(\\n        address _sender,\\n        address _recipient,\\n        uint256 _amount\\n    )\\n        external\\n        returns (bool);\\n\\n    function transfer(\\n        address _recipient,\\n        uint256 _amount\\n    )\\n        external\\n        returns (bool);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(\\n        address _spender,\\n        uint256 _amount\\n    )\\n        external\\n        returns (bool);\\n\\n    function decimals()\\n        external\\n        view\\n        returns (uint8);\\n\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 value\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    event  Deposit(\\n        address indexed dst,\\n        uint wad\\n    );\\n\\n    event  Withdrawal(\\n        address indexed src,\\n        uint wad\\n    );\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_master\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wiseOracleHubAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nftContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wethContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyCreated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CollateralTooSmall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DepositCapReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ForbiddenValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotMaster\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotProposed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParametersLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PositionLocked\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Approve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"FundsBorrowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"FundsBorrowedOnBehalf\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"FundsDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalPayment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalPaymentShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"FundsReturned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalPayment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalPaymentShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"FundsReturnedWithLendingShares\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"FundsSolelyDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"FundsSolelyWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"FundsSolelyWithdrawnOnBehalf\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawnOnBehalf\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"PoolSynced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"registration\",\"type\":\"bool\"}],\"name\":\"RegisteredForIsolationPool\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AAVE_HUB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE_MANAGER\",\"outputs\":[{\"internalType\":\"contract IFeeManagerLight\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"POSITION_NFT\",\"outputs\":[{\"internalType\":\"contract IPositionNFTs\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WISE_ORACLE\",\"outputs\":[{\"internalType\":\"contract IWiseOracleHub\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WISE_SECURITY\",\"outputs\":[{\"internalType\":\"contract IWiseSecurity\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"algorithmData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bestPole\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"previousValue\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"increasePole\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"borrowExactAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"borrowExactAmountETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"borrowOnBehalfExactAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"borrowPoolData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"allowBorrow\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pseudoTotalBorrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"borrowRatesData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pole\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deltaPole\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPole\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPole\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multiplicativeFactor\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"calculateBorrowShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"calculateLendingShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"cashoutAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"checkDeposit\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"checkLendingDataEmpty\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"checkPositionLocked\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"collateralizeDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nftIdLiquidator\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_paybackToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiveToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_paybackAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_shareAmountToPay\",\"type\":\"uint256\"}],\"name\":\"coreLiquidationIsolationPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"corePaybackFeeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"allowBorrow\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolMulFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolCollFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDepositAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolManager.CreatePool\",\"name\":\"_params\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"curvePoolTokenIndexFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"curvePoolTokenIndexTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"curveMetaPoolTokenIndexFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"curveMetaPoolTokenIndexTo\",\"type\":\"uint256\"}],\"internalType\":\"struct CurveSwapStructToken\",\"name\":\"curveSecuritySwapsToken\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"curvePool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"curveMetaPool\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapBytesPool\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"swapBytesMeta\",\"type\":\"bytes\"}],\"internalType\":\"struct CurveSwapStructData\",\"name\":\"curveSecuritySwapsData\",\"type\":\"tuple\"}],\"internalType\":\"struct PoolManager.CurvePoolSettings\",\"name\":\"_settings\",\"type\":\"tuple\"}],\"name\":\"createCurvePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"allowBorrow\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolMulFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolCollFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDepositAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolManager.CreatePool\",\"name\":\"_params\",\"type\":\"tuple\"}],\"name\":\"createPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"deCollateralizeDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositExactAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"depositExactAmountETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositExactAmountETHMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositExactAmountMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"getPositionBorrowShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getPositionBorrowTokenByIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"getPositionBorrowTokenLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"getPositionLendingShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getPositionLendingTokenByIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"getPositionLendingTokenLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"getPseudoTotalBorrowAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"getPseudoTotalPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"getPureCollateralAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"getTimeStamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"getTotalBareToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"getTotalBorrowShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"getTotalDepositShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"getTotalPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"globalPoolData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilization\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBareToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"isDecollteralized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lendingPoolData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pseudoTotalPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDepositShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralFactor\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nftIdLiquidator\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_paybackToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiveToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_shareAmountToPay\",\"type\":\"uint256\"}],\"name\":\"liquidatePartiallyFromTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"master\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxDepositValueToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"newBorrowRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"parametersLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"paybackAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"paybackExactAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"paybackExactAmountETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftIdCaller\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nftIdReceiver\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lendingShares\",\"type\":\"uint256\"}],\"name\":\"paybackExactLendingShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"paybackExactShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"positionBorrowTokenData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"positionLendingTokenData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"positionLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"positionPureCollateralAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"preparePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proposedOwner\",\"type\":\"address\"}],\"name\":\"proposeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposedMaster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_poolMulFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_upperBoundMaxRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lowerBoundMaxRate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_steppingDirection\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isFinal\",\"type\":\"bool\"}],\"name\":\"setParamsLASA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newFee\",\"type\":\"uint256\"}],\"name\":\"setPoolFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collateralFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maximumDeposit\",\"type\":\"uint256\"}],\"name\":\"setPoolParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_registerState\",\"type\":\"bool\"}],\"name\":\"setRegistrationIsolationPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wiseSecurity\",\"type\":\"address\"}],\"name\":\"setSecurity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_isolationPool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setVeryfiedIsolationPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"solelyDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"solelyDepositETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"solelyDepositETHMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"solelyDepositMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"solelyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"solelyWithdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"solelyWithdrawOnBehalf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"syncManually\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"timestampsPoolData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timeStamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeStampScaling\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userBorrowShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLendingData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deCollteralized\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"veryfiedIsolationPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawExactAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawExactAmountETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"withdrawExactShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"withdrawExactSharesETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawOnBehalfExactAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"withdrawOnBehalfExactShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "WiseLending", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000641ad78baca220c5bd28b51ce8e0f495e85fe689000000000000000000000000d2caa748b66768ac9c53a5443225bdf1365dd4b60000000000000000000000009d6d4e2afab382ae9b52807a4b36a8d2afc78b07000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}