{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"cse\": true,\r\n        \"deduplicate\": true,\r\n        \"inliner\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"peephole\": true,\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf\",\r\n          \"stackAllocation\": true\r\n        }\r\n      },\r\n      \"runs\": 2000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/OrbitalBlockade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"./interfaces/IERC721TokenReciever.sol\\\";\\nimport \\\"./interfaces/IOrbitalBlockade.sol\\\";\\nimport \\\"./interfaces/IPirateGames.sol\\\";\\nimport \\\"./interfaces/IPirates.sol\\\";\\nimport \\\"./interfaces/IRAW.sol\\\";\\nimport \\\"./interfaces/IMasterStaker.sol\\\";\\n\\ncontract OrbitalBlockade is IOrbitalBlockade, IERC721TokenReceiver, Pausable {\\n    // maximum rank for a Pirate\\n    uint8 public constant MAX_RANK = 8;\\n\\n    // struct to store a stake's token, sOwner, and earning values\\n    struct Stake {\\n        uint16 tokenId;\\n        uint80 value;\\n        address sOwner;\\n    }\\n\\n    event PirateStaked(\\n        address indexed sOwner,\\n        uint256 indexed tokenId,\\n        uint256 value\\n    );\\n\\n    event PirateClaimed(\\n        uint256 indexed tokenId,\\n        bool indexed unstaked,\\n        uint256 earned\\n    );\\n\\n    // reference to the Pirates NFT contract\\n    IPirates public pirateNFT;\\n    // reference to the game logic  contract\\n    IPirateGames public pirGames;\\n    // reference to the $rEON contract for minting $rEON earnings\\n    IRAW public raw;\\n    //reference to masterStaker contract\\n    IMasterStaker public masterStaker;\\n\\n    //maps token id to stake\\n    mapping(uint256 => Stake) private orbital;\\n    // maps rank to all Pirates staked with that rank\\n    mapping(uint256 => Stake[]) private crew;\\n    // tracks location of each Pirate in all pirate crews:\\n    mapping(uint256 => uint256) private crewIndices;\\n    // amount of rEON due for each fuel index point.\\n    // address => allowedToCallFunctions\\n    mapping(address => bool) private admins;\\n\\n    uint256 public rawEonPerRank = 0;\\n\\n    uint256 private totalRankStaked;\\n\\n    uint256 public piratesStaked;\\n\\n    // any rewards distributed when no pirates are staked\\n    uint256 private unaccountedRewards = 0;\\n\\n    address public auth;\\n\\n    bool rescueEnabled;\\n\\n    constructor() {\\n        _pause();\\n        auth = msg.sender;\\n        admins[msg.sender] = true;\\n    }\\n\\n    modifier noCheaters() {\\n        uint256 size = 0;\\n        address acc = msg.sender;\\n        assembly {\\n            size := extcodesize(acc)\\n        }\\n\\n        require(\\n            admins[msg.sender] || (msg.sender == tx.origin && size == 0),\\n            \\\"you're trying to cheat!\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == auth);\\n        _;\\n    }\\n\\n    /** CRITICAL TO SETUP */\\n    modifier requireContractsSet() {\\n        require(\\n            address(pirateNFT) != address(0) &&\\n                address(raw) != address(0) &&\\n                address(pirGames) != address(0) &&\\n                address(masterStaker) != address(0),\\n            \\\"Contracts not set\\\"\\n        );\\n        _;\\n    }\\n\\n    function setContracts(\\n        address _pirateNFT,\\n        address _raw,\\n        address _pirGames,\\n        address _masterStaker\\n    ) external onlyOwner {\\n        pirateNFT = IPirates(_pirateNFT);\\n        raw = IRAW(_raw);\\n        pirGames = IPirateGames(_pirGames);\\n        masterStaker = IMasterStaker(_masterStaker);\\n    }\\n\\n    /** STAKING */\\n\\n    /**\\n     * adds Pirates to the orbital blockade crew\\n     * @param account the address of the staker\\n     * @param tokenIds the IDs of the Pirates to stake\\n     */\\n    function addPiratesToCrew(address account, uint16[] calldata tokenIds)\\n        external\\n        override\\n        whenNotPaused\\n        noCheaters\\n    {\\n        require(account == tx.origin);\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            if (msg.sender == address(masterStaker)) {\\n                require(\\n                    pirateNFT.isOwner(tokenIds[i]) == account,\\n                    \\\"Not Pirate Owner\\\"\\n                );\\n                pirateNFT.transferFrom(account, address(this), tokenIds[i]);\\n            } else if (msg.sender != address(pirGames) && msg.sender != address (pirateNFT)) {\\n                // dont do this step if its a mint + stake or migration;\\n                require(\\n                    pirateNFT.isOwner(tokenIds[i]) == msg.sender,\\n                    \\\"Not Pirate Owner\\\"\\n                );\\n                pirateNFT.transferFrom(msg.sender, address(this), tokenIds[i]);\\n            }\\n            _addPirateToCrew(account, tokenIds[i]);\\n        }\\n    }\\n\\n    /**\\n     * adds a single Pirate to the Crew\\n     * @param account the address of the staker\\n     * @param tokenId the ID of the Pirate to add to the Crew\\n     */\\n    function _addPirateToCrew(address account, uint256 tokenId)\\n        internal\\n        whenNotPaused\\n    {\\n        uint8 rank = _rankForPirate(tokenId);\\n        totalRankStaked += rank; // Portion of earnings ranges from 8 to 5\\n        crewIndices[tokenId] = crew[rank].length; // Store the location of the Pirate in the Crew\\n        crew[rank].push(\\n            Stake({\\n                sOwner: account,\\n                tokenId: uint16(tokenId),\\n                value: uint80(rawEonPerRank)\\n            })\\n        ); // Add the Pirate to the Crew\\n        piratesStaked += 1;\\n        emit PirateStaked(account, tokenId, rawEonPerRank);\\n    }\\n\\n\\n    /** CLAIMING / UNSTAKING */\\n\\n    /**\\n     * realize $rEON earnings and optionally unstake tokens from the Orbital blockade\\n     * @param tokenIds the IDs of the tokens to claim earnings from\\n     * @param unstake whether or not to unstake ALL of the tokens listed in tokenIds\\n     */\\n    function claimPiratesFromCrew(\\n        address account,\\n        uint16[] calldata tokenIds,\\n        bool unstake\\n    ) external whenNotPaused noCheaters {\\n        uint256 owed = 0;\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            owed += _claimPiratesFromCrew(account, tokenIds[i], unstake);\\n        }\\n        raw.updateOriginAccess(account);\\n        if (owed == 0) {\\n            return;\\n        }\\n        raw.mint(1, owed, account);\\n    }\\n\\n    function calculateRewards(uint256 tokenId)\\n        external\\n        view\\n        returns (uint256 owed)\\n    {\\n        Stake memory stake = orbital[tokenId];\\n        uint8 rank = _rankForPirate(tokenId);\\n        owed = (rank) * (rawEonPerRank - stake.value); // Calculate portion of tokens based on Rank\\n    }\\n\\n    /**\\n     * realize $rEON earnings for a single Pirate and optionally unstake it\\n     * Pirates earn $rEON proportional to their rank\\n     * @param tokenId the ID of the Pirate to claim earnings from\\n     * @param unstake whether or not to unstake the Pirate\\n     * @return owed - the amount of $rEON earned\\n     */\\n    function _claimPiratesFromCrew(\\n        address account,\\n        uint256 tokenId,\\n        bool unstake\\n    ) internal returns (uint256 owed) {\\n        uint8 rank = _rankForPirate(tokenId);\\n        Stake memory stake = crew[rank][crewIndices[tokenId]];\\n        require(stake.sOwner == account, \\\"Not pirate Owner\\\");\\n        owed = (rank) * (rawEonPerRank - stake.value); // Calculate portion of tokens based on Rank\\n        if (unstake) {\\n            totalRankStaked -= rank; // Remove rank from total staked\\n            piratesStaked -= 1;\\n            Stake memory lastStake = crew[rank][crew[rank].length - 1];\\n            crew[rank][crewIndices[tokenId]] = lastStake; // Shuffle last Pirate to current position\\n            crewIndices[lastStake.tokenId] = crewIndices[tokenId];\\n            crew[rank].pop(); // Remove duplicate\\n            delete crewIndices[tokenId]; // Delete old mapping\\n            // Always remove last to guard against reentrance\\n            pirateNFT.safeTransferFrom(address(this), account, tokenId, \\\"\\\"); // Send back Pirate\\n        } else {\\n            crew[rank][crewIndices[tokenId]] = Stake({\\n                sOwner: account,\\n                tokenId: uint16(tokenId),\\n                value: uint80(rawEonPerRank)\\n            }); // reset stake\\n        }\\n        emit PirateClaimed(tokenId, unstake, owed);\\n    }\\n\\n\\n    /**\\n     * emergency unstake tokens\\n     * @param tokenIds the IDs of the tokens to claim earnings from\\n     */\\n    function rescue(uint256[] calldata tokenIds) external noCheaters {\\n        require(rescueEnabled, \\\"Rescue Not Enabled\\\");\\n        uint256 tokenId;\\n        Stake memory stake;\\n        Stake memory lastStake;\\n        uint8 rank;\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            rank = _rankForPirate(tokenId);\\n            stake = crew[rank][crewIndices[tokenId]];\\n            require(stake.sOwner == msg.sender, \\\"Not Owner\\\");\\n            totalRankStaked -= rank; // Remove Rank from total staked\\n            lastStake = crew[rank][crew[rank].length - 1];\\n            crew[rank][crewIndices[tokenId]] = lastStake; // Shuffle last Pirate to current position\\n            crewIndices[lastStake.tokenId] = crewIndices[tokenId];\\n            crew[rank].pop(); // Remove duplicate\\n            delete crewIndices[tokenId]; // Delete old mapping\\n            pirateNFT.safeTransferFrom(address(this), msg.sender, tokenId, \\\"\\\"); // Send back Pirate\\n            emit PirateClaimed(tokenId, true, 0);\\n        }\\n    }\\n\\n    /**\\n     * add $rEON to claimable pot for the Crew\\n     * @param amount $rEON to add to the pot\\n     */\\n    function payPirateTax(uint256 amount) external override {\\n        require(admins[msg.sender], \\\"Only admins\\\");\\n        if (totalRankStaked == 0) {\\n            // if there's no staked pirates\\n            unaccountedRewards += amount; // keep track of $rEON due to pirates\\n            return;\\n        }\\n        // makes sure to include any unaccounted $rEON\\n        rawEonPerRank += (amount + unaccountedRewards) / totalRankStaked;\\n        unaccountedRewards = 0;\\n    }\\n\\n    //Admin\\n    /**\\n     * allows owner to enable \\\"rescue mode\\\"\\n     * simplifies accounting, prioritizes tokens out in emergency\\n     */\\n    function setRescueEnabled(bool _enabled) external onlyOwner {\\n        rescueEnabled = _enabled;\\n    }\\n\\n    /**\\n     * enables owner to pause / unpause contract\\n     */\\n    function setPaused(bool _paused) external requireContractsSet onlyOwner {\\n        if (_paused) _pause();\\n        else _unpause();\\n    }\\n\\n    /**\\n     * enables an address to mint / burn\\n     * @param addr the address to enable\\n     */\\n    function addAdmin(address addr) external onlyOwner {\\n        admins[addr] = true;\\n    }\\n\\n    /**\\n     * disables an address from minting / burning\\n     * @param addr the address to disbale\\n     */\\n    function removeAdmin(address addr) external onlyOwner {\\n        admins[addr] = false;\\n    }\\n\\n    function transferOwnership(address newOwner) external onlyOwner {\\n        auth = newOwner;\\n    }\\n\\n    //READ ONLY\\n    /**\\n     * gets the rank score for a Pirate\\n     * @param tokenId the ID of the Pirate to get the rank score for\\n     * @return the rank score of the Pirate (5-8)\\n     */\\n    function _rankForPirate(uint256 tokenId) internal view returns (uint8) {\\n        if (pirateNFT.isHonors(tokenId)) {\\n            return 8;\\n        } else {\\n            IPirates.Pirate memory q = pirateNFT.getTokenTraitsPirate(tokenId);\\n            return MAX_RANK - q.rank; // rank index is 0-3\\n        }\\n    }\\n\\n    /**\\n     * chooses a random Pirate thief when a newly minted token is stolen\\n     * @param seed a random value to choose a Pirate from\\n     * @return the sOwner of the randomly selected Pirate thief\\n     */\\n    function randomPirateOwner(uint256 seed)\\n        external\\n        view\\n        override\\n        returns (address)\\n    {\\n        if (totalRankStaked == 0) {\\n            return address(0x0);\\n        }\\n        uint256 bucket = (seed & 0xFFFFFFFF) % totalRankStaked; // choose a value from 0 to total rank staked\\n        uint256 cumulative;\\n        seed >>= 32;\\n        // loop through each bucket of Pirates with the same rank score\\n        for (uint256 i = MAX_RANK - 3; i <= MAX_RANK; i++) {\\n            cumulative += crew[i].length * i;\\n            // if the value is not inside of that bucket, keep going\\n            if (bucket >= cumulative) continue;\\n            // get the address of a random Pirate with that rank score\\n            return crew[i][seed % crew[i].length].sOwner;\\n        }\\n        return address(0x0);\\n    }\\n\\n    function onERC721Received(\\n        address,\\n        address from,\\n        uint256,\\n        bytes calldata\\n    ) external pure override returns (bytes4) {\\n        require(from == address(0x0), \\\"Only EOA\\\");\\n        return IERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC721TokenReciever.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\npragma solidity ^0.8.11;\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\ninterface IERC721TokenReceiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMasterStaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\npragma solidity ^0.8.0;\\n\\ninterface IMasterStaker {\\n\\n function masterStake(\\n        uint16[] calldata colonistTokenIds,\\n        uint16[] calldata pirateTokenIds\\n    ) external;\\n\\n function masterUnstake(\\n        uint16[] calldata colonistTokenIds,\\n        uint16[] calldata pirateTokenIds\\n    ) external;\\n\\n function masterClaim(\\n        uint16[] calldata colonistTokenIds,\\n        uint16[] calldata pirateTokenIds\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IOrbitalBlockade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\n\\npragma solidity ^0.8.0;\\n\\ninterface IOrbitalBlockade {\\n    function addPiratesToCrew(address account, uint16[] calldata tokenIds)\\n        external;\\n    \\n    function claimPiratesFromCrew(address account, uint16[] calldata tokenIds, bool unstake)\\n        external;\\n\\n    function payPirateTax(uint256 amount) external;\\n\\n    function randomPirateOwner(uint256 seed) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPirateGames.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPirateGames {}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPirates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPirates {\\r\\n    // struct to store each Colonist's traits\\r\\n    struct Pirate {\\r\\n        bool isPirate;\\r\\n        uint8 sky;\\r\\n        uint8 cockpit;\\r\\n        uint8 base;\\r\\n        uint8 engine;\\r\\n        uint8 nose;\\r\\n        uint8 wing;\\r\\n        uint8 weapon1;\\r\\n        uint8 weapon2;\\r\\n        uint8 rank;\\r\\n    }\\r\\n\\r\\n    struct HPirates {\\r\\n        uint8 Legendary;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) external;\\r\\n\\r\\n    function minted() external returns (uint16);\\r\\n\\r\\n    function piratesMinted() external returns (uint16);\\r\\n\\r\\n    function isOwner(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (address);\\r\\n\\r\\n    function _mintPirate(address recipient, uint256 seed) external;\\r\\n\\r\\n    function burn(uint256 tokenId) external;\\r\\n\\r\\n    function getTokenTraitsPirate(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (Pirate memory);\\r\\n\\r\\n    function getTokenTraitsHonors(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (HPirates memory);\\r\\n\\r\\n    function tokenNameByIndex(uint256 index)\\r\\n        external\\r\\n        view\\r\\n        returns (string memory);\\r\\n    \\r\\n    function isHonors(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (bool);\\r\\n\\r\\n    function updateOriginAccess(uint16[] memory tokenIds) external;\\r\\n\\r\\n    function getTokenWriteBlock(uint256 tokenId) \\r\\n    external \\r\\n    view  \\r\\n    returns(uint64);\\r\\n\\r\\n    function hasBeenNamed(uint256 tokenId) external view returns (bool);\\r\\n\\r\\n    function namePirate(uint256 tokenId, string memory newName) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IRAW.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\npragma solidity ^0.8.0;\\n\\ninterface IRAW {\\n\\n    function updateOriginAccess(address user) external;\\n\\n\\n    function balanceOf(\\n        address account,\\n        uint256 id\\n    ) external returns(uint256);\\n\\n    function mint(\\n        uint256 typeId,\\n        uint256 qty,\\n        address recipient\\n    ) external;\\n\\n    function burn(\\n        uint256 typeId,\\n        uint256 qty,\\n        address burnFrom\\n    ) external;\\n\\n    function updateMintBurns(\\n        uint256 typeId,\\n        uint256 mintQty,\\n        uint256 burnQty\\n    ) external;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) external;\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) external;\\n\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"unstaked\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earned\",\"type\":\"uint256\"}],\"name\":\"PirateClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"PirateStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_RANK\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint16[]\",\"name\":\"tokenIds\",\"type\":\"uint16[]\"}],\"name\":\"addPiratesToCrew\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"calculateRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"owed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint16[]\",\"name\":\"tokenIds\",\"type\":\"uint16[]\"},{\"internalType\":\"bool\",\"name\":\"unstake\",\"type\":\"bool\"}],\"name\":\"claimPiratesFromCrew\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"masterStaker\",\"outputs\":[{\"internalType\":\"contract IMasterStaker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"payPirateTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pirGames\",\"outputs\":[{\"internalType\":\"contract IPirateGames\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pirateNFT\",\"outputs\":[{\"internalType\":\"contract IPirates\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"piratesStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"name\":\"randomPirateOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"raw\",\"outputs\":[{\"internalType\":\"contract IRAW\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rawEonPerRank\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"rescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pirateNFT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_raw\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pirGames\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_masterStaker\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setRescueEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OrbitalBlockade", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}