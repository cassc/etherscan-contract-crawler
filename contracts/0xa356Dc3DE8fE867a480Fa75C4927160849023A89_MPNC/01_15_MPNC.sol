//SPDX-License-Identifier: MIT-BROUGKR
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @dev: @brougkr
 */
pragma solidity 0.8.17;
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import {MerkleProof} from "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import {IERC721} from "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {ERC721MP} from "./ERC721MP.sol";
contract MPNC is ERC721MP, Ownable, ReentrancyGuard
{    
    struct MintPass
    {
        uint _PriceStart;                 // [0] -> _PriceStart
        uint _PriceEnd;                   // [1] -> _PriceEnd
        uint _MaximumAvailableForSale;    // [2] -> _MaximumAvailableForSale
        uint _StartingBlockUnixTimestamp; // [3] -> _StartingBlockUnixTimestamp
        uint _SecondsBetweenPriceDecay;   // [4] -> _SecondsBetweenPriceDecay
        bool _ActivePublic;               // [5] -> _ActivePublic
        bytes32 _Root;                    // [6] -> _Root
    }
    struct InternalSale
    {
        uint _AmountSold;         // [0] -> _AmountSold
        uint _FinalClearingPrice; // [1] -> _FinalClearingPrice
        uint _UniqueSales;        // [2] -> _UniqueSales
    }
    struct UserSaleInformation
    {
        // Mint Pass Information
        uint _MintPassCurrentPrice;    // [0] -> _MintPassCurrentPrice
        uint _MintPassAmountPurchased; // [1] -> _MintPassAmountPurchased
        uint _MintPassAmountRemaining; // [2] -> _MintPassAmountRemaining
        bool _MintPassEligible;        // [3] -> _MintPassEligible
        bool _MintPassSalePaused;      // [4] -> _MintPassSalePaused
    }
    struct SaleInformation
    {
        // Mint Pass Information
        uint _MintPassCurrentPrice;  // [0] -> _MintPassCurrentPrice
        uint _MintPassRemaining;     // [1] -> _MintPassRemaining
        uint _MintPassSaleStartTime; // [2] -> _MintPassSaleStartTime
        uint _MintPassStartingPrice; // [3] -> _MintPassStartingPrice
        uint _MintPassEndingPrice;   // [4] -> _MintPassEndingPrice
    }
    MintPass public MintPassSale = MintPass(
        3 ether,    // [0] -> _PriceStart    
        0.25 ether, // [1] -> _PriceEnd 
        75,         // [2] -> _MaximumAvailableForSale
        1667408400, // [3] -> _StartingBlockUnixTimestamp
        1004,       // [4] -> _SecondsBetweenPriceDecay
        true,       // [5] -> _ActivePublic
        0x7dea6bcef821a296007fda79780905b402f111f91ba6736fe61f17b3bc01a577 // [6] -> _Root
    ); 
    InternalSale public MintPassInternalSale = InternalSale(
        0,   // [0] -> _AmountSold
        0,   // [1] -> _FinalClearingPrice
        0    // [2] -> _UniqueSales
    );

    mapping(uint=>address) public UniqueSaleIndexToAddress;    // `OrderID` => `Recipient`
    mapping(uint=>uint) public UniqueSalePurchaseAmount;       // `OrderID` => `Order Amount`
    mapping(uint=>uint) public UniqueSaleToOrderValue;         // `OrderID` => `Order Value`
    mapping(uint=>bool) public UniqueSaleBrightListStatus;     // `OrderID` => `BrightListed`
    mapping(address=>uint) public _MintPassPurchasedAmt;       // `Wallet` => `Total Purchased Amount`

    uint public CurrentOrderRefundIndex;
    string public baseURI = "ipfs://QmStiGGs5jyEDwMDguzsZ4JNHkKmjNcTevfngvP8Vuamwa/";
    address public _LiveMint = 0xf441aAF6a47c8A0e2d6317de6cB20a8f43481544;   
    
    event Purchased(address Recipient, uint Amount, uint MessageValue, uint PurchaseValue, uint AmountSold);
    event NewStartingTimestamp(uint Timestamp);
    event Refunded(uint RefundAmount);

    constructor() ERC721MP("Mint Pass nth Culture | Fingacode | MPNC", "MPNC")
    {
        // Transfers Ownership 
        // _transferOwnership(0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700); // operator.brightmoments.eth
        // _mint(0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700, 25); // operator.brightmoments.eth
        _mint(msg.sender, 25);
        _WhitelistedSender[0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700] = true;
    }

    /*---------------------
     * EXTERNAL FUNCTIONS *
    ----------------------*/

    /**
     * @dev Purchases NFTs
     */
    function PurchasePass(uint Amount, bytes32[] calldata Proof) external payable nonReentrant
    { 
        require(tx.origin == msg.sender, "MP: Only EOA");
        require(block.timestamp >= MintPassSale._StartingBlockUnixTimestamp, "MP: Sale Not Started Yet");
        require(MintPassSale._ActivePublic, "MP: Sale Not Active");
        if(MintPassInternalSale._AmountSold + Amount > MintPassSale._MaximumAvailableForSale)
        {
            Amount = MintPassSale._MaximumAvailableForSale - MintPassInternalSale._AmountSold;
        }
        uint NewAmountSold = MintPassInternalSale._AmountSold + Amount;
        require(NewAmountSold <= MintPassSale._MaximumAvailableForSale, "MP: Sold Out");
        uint NewUserPurchasedAmount = _MintPassPurchasedAmt[msg.sender] + Amount;
        require(Amount > 0 && Amount <= 5, "MP: Incorrect Amount");
        bool BrightListEligible = VerifyBrightList(msg.sender, Proof, MintPassSale._Root);
        uint CurrentPrice = ViewCurrentPriceMintPass();
        uint CurrentPurchaseValue = CurrentPrice * Amount;
        require(msg.value >= CurrentPurchaseValue, "MP: Incorrect ETH Amount Sent");
        if(msg.value > CurrentPurchaseValue) { __Refund(msg.sender, (msg.value - CurrentPurchaseValue)); }
        UniqueSaleToOrderValue[MintPassInternalSale._UniqueSales] = CurrentPurchaseValue;
        UniqueSaleIndexToAddress[MintPassInternalSale._UniqueSales] = msg.sender; 
        UniqueSalePurchaseAmount[MintPassInternalSale._UniqueSales] = Amount;
        UniqueSaleBrightListStatus[MintPassInternalSale._UniqueSales] = BrightListEligible;
        MintPassInternalSale._UniqueSales = MintPassInternalSale._UniqueSales + 1;
        MintPassInternalSale._AmountSold = NewAmountSold;
        _MintPassPurchasedAmt[msg.sender] = NewUserPurchasedAmount;
        require(MintPassInternalSale._AmountSold <= MintPassSale._MaximumAvailableForSale, "MP: Overflow");
        if(MintPassInternalSale._AmountSold == MintPassSale._MaximumAvailableForSale) // End Sales
        { 
            MintPassInternalSale._FinalClearingPrice = CurrentPrice; 
            ___EndMintPassSale();
        }
        _mint(msg.sender, Amount);
        emit Purchased(msg.sender, Amount, msg.value, CurrentPurchaseValue, NewAmountSold);
    }
    
    /*------------------
     * ADMIN FUNCTIONS *
    -------------------*/

    /**
     * @dev Overrides Clearing Price
     */
    function __OverrideClearingPrice(uint Price) external onlyOwner { MintPassInternalSale._FinalClearingPrice = Price; }
    
    /**
     * @dev Toggles Active Public Sale State For Mint Pass
     */
    function __ToggleActivePublicMintPass() external onlyOwner { MintPassSale._ActivePublic = !MintPassSale._ActivePublic; }

    /**
     * @dev Initiates Withdraw Of Refunds & Sale Proceeds
     */
    function __InitiateRefundsAndProceeds() external onlyOwner
    {
        require(MintPassInternalSale._FinalClearingPrice > 0, "Final Clearing Price Not Seeded");
        for(uint OrderIndex = CurrentOrderRefundIndex; OrderIndex < MintPassInternalSale._UniqueSales; OrderIndex++)
        {
            if(!UniqueSaleBrightListStatus[OrderIndex]) // No Discount
            {
                (bool ConfirmedRefund,) = UniqueSaleIndexToAddress[OrderIndex].call{
                    value: UniqueSaleToOrderValue[OrderIndex] - (MintPassInternalSale._FinalClearingPrice * UniqueSalePurchaseAmount[OrderIndex])
                } (""); 
                require(ConfirmedRefund, "MP: Normal Refund failed");
            }
            else // BrightList Discount
            {
                (bool ConfirmedRefund,) = UniqueSaleIndexToAddress[OrderIndex].call{
                    value: UniqueSaleToOrderValue[OrderIndex] - (((MintPassInternalSale._FinalClearingPrice * 75) / 100) * UniqueSalePurchaseAmount[OrderIndex])
                } (""); 
                require(ConfirmedRefund, "MP: BrightList Refund failed");
            }
        }
        (bool ConfirmedWithdraw,) = msg.sender.call{ value: address(this).balance } (""); 
        require(ConfirmedWithdraw, "MP: Multisig Refund failed");
        CurrentOrderRefundIndex = MintPassInternalSale._UniqueSales;
    }

    /**
     * @dev Changes Starting Block Timestamps
     */
    function __NewBlockTimestamps(uint Timestamp) external onlyOwner
    {
        MintPassSale._StartingBlockUnixTimestamp = Timestamp;
        emit NewStartingTimestamp(Timestamp);
    }

    /**
     * @dev Changes Merkle Root
     */
    function __NewRoot(bytes32 Root) external onlyOwner { MintPassSale._Root = Root; }

    /**
     * @dev Changes Ending Price For Mint Pass *** DENOTED IN WEI ***
     */
    function __NewEndingPrice(uint PriceEnd) external onlyOwner 
    { 
        MintPassSale._PriceEnd = PriceEnd; 
    }

    /**
     * @dev Instantiates New LiveMint Address
     */
    function __NewLiveMintAddress(address NewAddress) external onlyOwner { _LiveMint = NewAddress; }

    /**
     * @dev Instantiates New LiveMint Contract Address
     */
    function __NewWhitelistedSenderAddress(address NewAddress) external onlyOwner 
    { 
        _WhitelistedSender[NewAddress] = !_WhitelistedSender[NewAddress]; 
    }

    /**
     * @dev Changes The BaseURI For JSON Metadata 
     */
    function __NewBaseURI(string calldata NewURI) external onlyOwner { baseURI = NewURI; }

    /**
     * @dev Ends All Sales
     */
    function __EndAllSales() external onlyOwner { MintPassSale._ActivePublic = false; }

    /**
     * @dev Withdraws All Ether From The Contract
     */
    function ___WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }

    /**
     * @dev Withdraws Ether From Contract To Address With An Amount
     */
    function ___WithdrawEtherToAddress(address payable Recipient, uint Amount) external onlyOwner
    {
        require(Amount > 0 && Amount <= address(this).balance, "Invalid Amount");
        (bool Success, ) = Recipient.call{value: Amount}("");
        require(Success, "Unable to Withdraw, Recipient May Have Reverted");
    }

    /**
     * @dev Withdraws ERC721s From Contract
     */
    function ___WithdrawERC721(address Contract, address Recipient, uint[] calldata TokenIDs) external onlyOwner 
    { 
        for(uint TokenID; TokenID < TokenIDs.length;)
        {
            IERC721(Contract).transferFrom(address(this), Recipient, TokenIDs[TokenID]);
            unchecked { TokenID++; }
        }
    }

    /*-----------------
     * VIEW FUNCTIONS *
    ------------------*/

    /**
     * @dev Returns Address & Corresponding Refund Amount At `OrderIndex`
     */
    function ViewOrderRefund(uint OrderIndex) public view returns(address Wallet, uint RefundAmount)
    {
        return(
            UniqueSaleIndexToAddress[OrderIndex], 
            UniqueSaleToOrderValue[OrderIndex] - (ViewCurrentPriceMintPass() * UniqueSalePurchaseAmount[OrderIndex])
        );
    }

    /**
     * @dev Returns All Order Information Including Addresses, Corresponding Refund Amounts, And Brightlist Eligibility
     */
    function ViewAllOrderRefunds() public view returns (address[] memory, uint[] memory, bool[] memory)
    {
        address[] memory Addresses = new address[](MintPassInternalSale._UniqueSales);
        uint[] memory Refunds = new uint[](MintPassInternalSale._UniqueSales);
        bool[] memory BrightlistEligibility = new bool[](MintPassInternalSale._UniqueSales);
        uint CurrentPrice = ViewCurrentPriceMintPass();
        for(uint OrderIndex; OrderIndex < MintPassInternalSale._UniqueSales;)
        {
            Addresses[OrderIndex] = UniqueSaleIndexToAddress[OrderIndex];
            Refunds[OrderIndex] = UniqueSaleToOrderValue[OrderIndex] - (CurrentPrice * UniqueSalePurchaseAmount[OrderIndex]);
            BrightlistEligibility[OrderIndex] = UniqueSaleBrightListStatus[OrderIndex];
            unchecked { OrderIndex++; }
        }
        return(Addresses, Refunds, BrightlistEligibility);
    }

    /**
     * @dev Returns Total Refund Amount & Sale Purchase Value
     */
    function ViewTotalRefundAmountAndSaleProceeds() public view returns (uint Refund, uint SaleProceeds)
    {
        unchecked
        {
            uint TotalRefundAmount;
            uint CurrentPrice = ViewCurrentPriceMintPass();
            for(uint OrderIndex; OrderIndex < MintPassInternalSale._UniqueSales; OrderIndex++)
            {
                TotalRefundAmount += UniqueSaleToOrderValue[OrderIndex] - (CurrentPrice * UniqueSalePurchaseAmount[OrderIndex]);
            }
            uint TotalSaleProceeds = address(this).balance - TotalRefundAmount;
            return (TotalRefundAmount, TotalSaleProceeds);
        }
    }

    /**
     * @dev Returns MP Sale Information
     */
    function ViewAllMPSaleInformation() public view returns (MintPass memory, SaleInformation memory) 
    {
        return(
            MintPassSale,
            SaleInformation(
                ViewCurrentPriceMintPass(),
                MintPassSale._MaximumAvailableForSale - MintPassInternalSale._AmountSold,
                MintPassSale._StartingBlockUnixTimestamp,
                MintPassSale._PriceStart,
                MintPassSale._PriceEnd
            )
        );
    }

    /**
     * @dev Returns MP Sale Information For A Given Wallet
     */
    function ViewWalletSaleInformation(
        address Wallet,
        bytes32[] calldata MintPassProof
    ) external view returns (UserSaleInformation memory) {
        bool MintPassSalePaused;
        if(
            !(MintPassSale._ActivePublic)
            &&
            (MintPassSale._MaximumAvailableForSale - MintPassInternalSale._AmountSold > 0)
        ) { MintPassSalePaused = true; }      
        return(
            UserSaleInformation(
                ViewCurrentPriceMintPass(),
                _MintPassPurchasedAmt[Wallet],
                MintPassSale._MaximumAvailableForSale - MintPassInternalSale._AmountSold,
                VerifyBrightList(Wallet, MintPassProof, MintPassSale._Root),
                MintPassSalePaused
            )
        );
    }

    /*---------------------
     * INTERNAL FUNCTIONS *
    ----------------------*/

    /**
     * @dev Returns Current Dutch Price For Mint Pass
     */
    function ViewCurrentPriceMintPass() internal view returns (uint Price) 
    {
        if(block.timestamp <= MintPassSale._StartingBlockUnixTimestamp) { return MintPassSale._PriceStart; }  // Sale Not Started
        if(MintPassInternalSale._FinalClearingPrice > 0) { return MintPassInternalSale._FinalClearingPrice; } // Sale Finished
        uint CurrentPrice = MintPassSale._PriceStart;
        uint SecondsElapsed = block.timestamp - MintPassSale._StartingBlockUnixTimestamp;
        CurrentPrice >>= SecondsElapsed / MintPassSale._SecondsBetweenPriceDecay; // Div/2 For Each Half Life Iterated Upon
        CurrentPrice -= (CurrentPrice * (SecondsElapsed % MintPassSale._SecondsBetweenPriceDecay)) / MintPassSale._SecondsBetweenPriceDecay / 2;
        if(CurrentPrice <= MintPassSale._PriceEnd) { return MintPassSale._PriceEnd; } // Sale Ended At Resting Band
        return CurrentPrice; // Sale Currently Active
    }

    /**
     * @dev Returns Base URI
     */
    function _baseURI() internal view virtual override returns (string memory) { return baseURI; }

    /**
     * @dev Returns If User Is On BrightList
     */
    function VerifyBrightList(address Recipient, bytes32[] calldata Proof, bytes32 Root) internal pure returns (bool)
    {
        bytes32 Leaf = keccak256(abi.encodePacked(Recipient));
        return MerkleProof.verify(Proof, Root, Leaf);
    }

    /**
     * @dev Ends Mint Pass Sale On Sellout
     */
    function ___EndMintPassSale() internal { MintPassSale._ActivePublic = false; }

    /**
     * @dev Refunds `Recipient` ETH Amount `Value`
     */
    function __Refund(address Recipient, uint Value) internal
    {
        (bool Confirmed,) = Recipient.call{value: Value}(""); 
        require(Confirmed, "MP: Refund failed");
        emit Refunded(Value);
    }

    /*--------------------
     * LIVEMINT FUNCTION *
    ---------------------*/

    /**
     * @dev LiveMint Redeems Mint Pass If Not Already Burned & Sends Minted Work To Owner's Wallet
     */
    function _LiveMintBurn(uint TokenID) external returns (address _Recipient)
    {
        require(msg.sender == _LiveMint, "MP: Sender Is Not Live Mint");
        address Recipient = IERC721(address(this)).ownerOf(TokenID);
        require(Recipient != address(0), "MP: Invalid Recipient");
        _burn(TokenID, false);
        return (Recipient);
    }
}