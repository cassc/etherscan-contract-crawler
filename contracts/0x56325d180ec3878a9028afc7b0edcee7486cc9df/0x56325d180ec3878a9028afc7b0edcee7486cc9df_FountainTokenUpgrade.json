{"SourceCode": "pragma solidity 0.4.25;\r\n\r\nlibrary SafeMath {\r\n\tfunction mul (uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 c = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction div (uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a / b;\r\n\t}\r\n\r\n\tfunction sub (uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\tfunction add (uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\ncontract ERCBasic {\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\tfunction totalSupply () public view returns (uint256);\r\n\tfunction balanceOf (address who) public view returns (uint256);\r\n\tfunction transfer (address to, uint256 value) public returns (bool);\r\n}\r\n\r\ncontract ERC is ERCBasic {\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n\tfunction transferFrom (address from, address to, uint256 value) public returns (bool);\r\n\tfunction allowance (address owner, address spender) public view returns (uint256);\r\n\tfunction approve (address spender, uint256 value) public returns (bool);\r\n}\r\n\r\ncontract Ownable {\r\n\tevent OwnershipTransferred(address indexed oldone, address indexed newone);\r\n\tevent FoundationOwnershipTransferred(address indexed oldFoundationOwner, address indexed newFoundationOwner);\r\n\r\n\taddress internal owner;\r\n\taddress internal foundationOwner;\r\n\r\n\tconstructor () public {\r\n\t\towner = msg.sender;\r\n\t\tfoundationOwner = owner;\r\n\t}\r\n\r\n\tmodifier onlyOwner () {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier hasMintability () {\r\n\t\trequire(msg.sender == owner || msg.sender == foundationOwner);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction transferOwnership (address newOwner) public returns (bool);\r\n\t\r\n\tfunction setFountainFoundationOwner (address foundation) public returns (bool);\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n\tevent ContractPause();\r\n\tevent ContractResume();\r\n\tevent ContractPauseSchedule(uint256 from, uint256 to);\r\n\r\n\tuint256 internal pauseFrom;\r\n\tuint256 internal pauseTo;\r\n\r\n\tmodifier whenRunning () {\r\n\t\trequire(now < pauseFrom || now > pauseTo);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier whenPaused () {\r\n\t\trequire(now >= pauseFrom && now <= pauseTo);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction pause () public onlyOwner {\r\n\t\tpauseFrom = now - 1;\r\n\t\tpauseTo = now + 30000 days;\r\n\t\temit ContractPause();\r\n\t}\r\n\r\n\tfunction pause (uint256 from, uint256 to) public onlyOwner {\r\n\t\trequire(to > from);\r\n\t\tpauseFrom = from;\r\n\t\tpauseTo = to;\r\n\t\temit ContractPauseSchedule(from, to);\r\n\t}\r\n\r\n\tfunction resume () public onlyOwner {\r\n\t\tpauseFrom = now - 2;\r\n\t\tpauseTo = now - 1;\r\n\t\temit ContractResume();\r\n\t}\r\n}\r\n\r\ncontract TokenForge is Ownable {\r\n\tevent ForgeStart();\r\n\tevent ForgeStop();\r\n\r\n\tbool public forge_running = true;\r\n\r\n\tmodifier canForge () {\r\n\t\trequire(forge_running);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier cannotForge () {\r\n\t\trequire(!forge_running);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction startForge () public onlyOwner cannotForge returns (bool) {\r\n\t\tforge_running = true;\r\n\t\temit ForgeStart();\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction stopForge () public onlyOwner canForge returns (bool) {\r\n\t\tforge_running = false;\r\n\t\temit ForgeStop();\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract CappedToken is Ownable {\r\n\tusing SafeMath for uint256;\r\n\r\n\tuint256 public token_cap;\r\n\tuint256 public token_created;\r\n\tuint256 public token_foundation_cap;\r\n\tuint256 public token_foundation_created;\r\n\r\n\r\n\tconstructor (uint256 _cap, uint256 _foundationCap) public {\r\n\t\ttoken_cap = _cap;\r\n\t\ttoken_foundation_cap = _foundationCap;\r\n\t}\r\n\r\n\tfunction changeCap (uint256 _cap) public onlyOwner returns (bool) {\r\n\t\tif (_cap < token_created && _cap > 0) return false;\r\n\t\ttoken_cap = _cap;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction canMint (uint256 amount) public view returns (bool) {\r\n\t\treturn (token_cap == 0) || (token_created.add(amount) <= token_cap);\r\n\t}\r\n\t\r\n\tfunction canMintFoundation(uint256 amount) internal view returns(bool) {\r\n\t\treturn(token_foundation_created.add(amount) <= token_foundation_cap);\r\n\t}\r\n}\r\n\r\ncontract BasicToken is ERCBasic, Pausable {\r\n\tusing SafeMath for uint256;\r\n\r\n\tmapping(address => uint256) public wallets;\r\n\r\n\tmodifier canTransfer (address _from, address _to, uint256 amount) {\r\n\t\trequire((_from != address(0)) && (_to != address(0)));\r\n\t\trequire(_from != _to);\r\n\t\trequire(amount > 0);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction balanceOf (address user) public view returns (uint256) {\r\n\t\treturn wallets[user];\r\n\t}\r\n}\r\n\r\ncontract DelegatableToken is ERC, BasicToken {\r\n\tusing SafeMath for uint256;\r\n\r\n\tmapping(address => mapping(address => uint256)) public warrants;\r\n\r\n\tfunction allowance (address owner, address delegator) public view returns (uint256) {\r\n\t\treturn warrants[owner][delegator];\r\n\t}\r\n\r\n\tfunction approve (address delegator, uint256 value) public whenRunning returns (bool) {\r\n\t\tif (delegator == msg.sender) return true;\r\n\t\twarrants[msg.sender][delegator] = value;\r\n\t\temit Approval(msg.sender, delegator, value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction increaseApproval (address delegator, uint256 delta) public whenRunning returns (bool) {\r\n\t\tif (delegator == msg.sender) return true;\r\n\t\tuint256 value = warrants[msg.sender][delegator].add(delta);\r\n\t\twarrants[msg.sender][delegator] = value;\r\n\t\temit Approval(msg.sender, delegator, value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction decreaseApproval (address delegator, uint256 delta) public whenRunning returns (bool) {\r\n\t\tif (delegator == msg.sender) return true;\r\n\t\tuint256 value = warrants[msg.sender][delegator];\r\n\t\tif (value < delta) {\r\n\t\t\tvalue = 0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tvalue = value.sub(delta);\r\n\t\t}\r\n\t\twarrants[msg.sender][delegator] = value;\r\n\t\temit Approval(msg.sender, delegator, value);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\ncontract LockableProtocol is BasicToken {\r\n\tfunction invest (address investor, uint256 amount) public returns (bool);\r\n\tfunction getInvestedToken (address investor) public view returns (uint256);\r\n\tfunction getLockedToken (address investor) public view returns (uint256);\r\n\tfunction availableWallet (address user) public view returns (uint256) {\r\n\t\treturn wallets[user].sub(getLockedToken(user));\r\n\t}\r\n}\r\n\r\ncontract MintAndBurnToken is TokenForge, CappedToken, LockableProtocol {\r\n\tusing SafeMath for uint256;\r\n\t\r\n\tevent Mint(address indexed user, uint256 amount);\r\n\tevent Burn(address indexed user, uint256 amount);\r\n\r\n\tconstructor (uint256 _initial, uint256 _cap, uint256 _fountainCap) public CappedToken(_cap, _fountainCap) {\r\n\t\ttoken_created = _initial;\r\n\t\twallets[msg.sender] = _initial;\r\n\r\n\t\temit Mint(msg.sender, _initial);\r\n\t\temit Transfer(address(0), msg.sender, _initial);\r\n\t}\r\n\r\n\tfunction totalSupply () public view returns (uint256) {\r\n\t\treturn token_created;\r\n\t}\r\n\r\n\tfunction totalFountainSupply() public view returns(uint256) {\r\n\t\treturn token_foundation_created;\r\n\t}\r\n\r\n\tfunction mint (address target, uint256 amount) public hasMintability whenRunning canForge returns (bool) {\r\n\t\trequire(target != owner && target != foundationOwner);\r\n\t\trequire(canMint(amount));\r\n\r\n\t\tif (msg.sender == foundationOwner) {\r\n\t\t\trequire(canMintFoundation(amount));\r\n\t\t\ttoken_foundation_created = token_foundation_created.add(amount);\r\n\t\t}\r\n\t\t\r\n\t\ttoken_created = token_created.add(amount);\r\n\t\twallets[target] = wallets[target].add(amount);\r\n\r\n\t\temit Mint(target, amount);\r\n\t\temit Transfer(address(0), target, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction burn (uint256 amount) public whenRunning canForge returns (bool) {\r\n\t\tuint256 balance = availableWallet(msg.sender);\r\n\t\trequire(amount <= balance);\r\n\r\n\t\ttoken_created = token_created.sub(amount);\r\n\t\twallets[msg.sender] = wallets[msg.sender].sub(amount);\r\n\r\n\t\temit Burn(msg.sender, amount);\r\n\t\temit Transfer(msg.sender, address(0), amount);\r\n\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\ncontract LockableToken is MintAndBurnToken, DelegatableToken {\r\n\tusing SafeMath for uint256;\r\n\r\n\tstruct LockBin {\r\n\t\tuint256 start;\r\n\t\tuint256 finish;\r\n\t\tuint256 duration;\r\n\t\tuint256 amount;\r\n\t}\r\n\r\n\tevent InvestStart();\r\n\tevent InvestStop();\r\n\tevent NewInvest(uint256 release_start, uint256 release_duration);\r\n\r\n\tuint256 public releaseStart;\r\n\tuint256 public releaseDuration;\r\n\tbool public forceStopInvest;\r\n\tmapping(address => mapping(uint => LockBin)) public lockbins;\r\n\r\n\tmodifier canInvest () {\r\n\t\trequire(!forceStopInvest);\r\n\t\t_;\r\n\t}\r\n\r\n\tconstructor (uint256 _initial, uint256 _cap, uint256 _fountainCap) public MintAndBurnToken(_initial, _cap, _fountainCap) {\r\n\t\tforceStopInvest = true;\r\n\t}\r\n\r\n\tfunction pauseInvest () public onlyOwner whenRunning returns (bool) {\r\n\t\trequire(!forceStopInvest);\r\n\t\tforceStopInvest = true;\r\n\t\temit InvestStop();\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction resumeInvest () public onlyOwner whenRunning returns (bool) {\r\n\t\trequire(forceStopInvest);\r\n\t\tforceStopInvest = false;\r\n\t\temit InvestStart();\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction setInvest (uint256 release_start, uint256 release_duration) public onlyOwner whenRunning returns (bool) {\r\n\t\treleaseStart = release_start;\r\n\t\treleaseDuration = release_duration;\r\n\t\trequire(releaseStart + releaseDuration > releaseStart);\r\n\t\tforceStopInvest = false;\r\n\r\n\t\temit NewInvest(release_start, release_duration);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction invest (address investor, uint256 amount) public onlyOwner whenRunning canInvest returns (bool) {\r\n\t\trequire(investor != address(0));\r\n\t\trequire(investor != owner);\r\n\t\trequire(investor != foundationOwner);\r\n\t\trequire(amount > 0);\r\n\t\trequire(canMint(amount));\r\n\r\n\t\tmapping(uint => LockBin) locks = lockbins[investor];\r\n\t\tLockBin storage info = locks[0];\r\n\t\tuint index = info.amount + 1;\r\n\t\tlocks[index] = LockBin({\r\n\t\t\tstart: releaseStart,\r\n\t\t\tfinish: releaseStart + releaseDuration,\r\n\t\t\tduration: releaseDuration / (1 days),\r\n\t\t\tamount: amount\r\n\t\t});\r\n\t\tinfo.amount = index;\r\n\r\n\t\ttoken_created = token_created.add(amount);\r\n\t\twallets[investor] = wallets[investor].add(amount);\r\n\t\temit Mint(investor, amount);\r\n\t\temit Transfer(address(0), investor, amount);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction batchInvest (address[] investors, uint256 amount) public onlyOwner whenRunning canInvest returns (bool) {\r\n\t\trequire(amount > 0);\r\n\r\n\t\tuint investorsLength = investors.length;\r\n\t\tuint investorsCount = 0;\r\n\t\tuint i;\r\n\t\taddress r;\r\n\t\tfor (i = 0; i < investorsLength; i ++) {\r\n\t\t\tr = investors[i];\r\n\t\t\tif (r == address(0) || r == owner || r == foundationOwner) continue;\r\n\t\t\tinvestorsCount ++;\r\n\t\t}\r\n\t\trequire(investorsCount > 0);\r\n\r\n\t\tuint256 totalAmount = amount.mul(uint256(investorsCount));\r\n\t\trequire(canMint(totalAmount));\r\n\r\n\t\ttoken_created = token_created.add(totalAmount);\r\n\r\n\t\tfor (i = 0; i < investorsLength; i ++) {\r\n\t\t\tr = investors[i];\r\n\t\t\tif (r == address(0) || r == owner || r == foundationOwner) continue;\r\n\r\n\t\t\tmapping(uint => LockBin) locks = lockbins[r];\r\n\t\t\tLockBin storage info = locks[0];\r\n\t\t\tuint index = info.amount + 1;\r\n\t\t\tlocks[index] = LockBin({\r\n\t\t\t\tstart: releaseStart,\r\n\t\t\t\tfinish: releaseStart + releaseDuration,\r\n\t\t\t\tduration: releaseDuration / (1 days),\r\n\t\t\t\tamount: amount\r\n\t\t\t});\r\n\t\t\tinfo.amount = index;\r\n\r\n\t\t\twallets[r] = wallets[r].add(amount);\r\n\t\t\temit Mint(r, amount);\r\n\t\t\temit Transfer(address(0), r, amount);\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction batchInvests (address[] investors, uint256[] amounts) public onlyOwner whenRunning canInvest returns (bool) {\r\n\t\tuint investorsLength = investors.length;\r\n\t\trequire(investorsLength == amounts.length);\r\n\r\n\t\tuint investorsCount = 0;\r\n\t\tuint256 totalAmount = 0;\r\n\t\tuint i;\r\n\t\taddress r;\r\n\t\tfor (i = 0; i < investorsLength; i ++) {\r\n\t\t\tr = investors[i];\r\n\t\t\tif (r == address(0) || r == owner || r == foundationOwner) continue;\r\n\t\t\tinvestorsCount ++;\r\n\t\t\ttotalAmount = totalAmount.add(amounts[i]);\r\n\t\t}\r\n\t\trequire(totalAmount > 0);\r\n\t\trequire(canMint(totalAmount));\r\n\r\n\t\tuint256 amount;\r\n\t\ttoken_created = token_created.add(totalAmount);\r\n\t\tfor (i = 0; i < investorsLength; i ++) {\r\n\t\t\tr = investors[i];\r\n\t\t\tif (r == address(0) || r == owner || r == foundationOwner) continue;\r\n\t\t\tamount = amounts[i];\r\n\t\t\tif (amount == 0) continue;\r\n\t\t\twallets[r] = wallets[r].add(amount);\r\n\t\t\temit Mint(r, amount);\r\n\t\t\temit Transfer(address(0), r, amount);\r\n\r\n\t\t\tmapping(uint => LockBin) locks = lockbins[r];\r\n\t\t\tLockBin storage info = locks[0];\r\n\t\t\tuint index = info.amount + 1;\r\n\t\t\tlocks[index] = LockBin({\r\n\t\t\t\tstart: releaseStart,\r\n\t\t\t\tfinish: releaseStart + releaseDuration,\r\n\t\t\t\tduration: releaseDuration / (1 days),\r\n\t\t\t\tamount: amount\r\n\t\t\t});\r\n\t\t\tinfo.amount = index;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction getInvestedToken (address investor) public view returns (uint256) {\r\n\t\trequire(investor != address(0) && investor != owner && investor != foundationOwner);\r\n\r\n\t\tmapping(uint => LockBin) locks = lockbins[investor];\r\n\t\tuint256 balance = 0;\r\n\t\tuint l = locks[0].amount;\r\n\t\tfor (uint i = 1; i <= l; i ++) {\r\n\t\t\tLockBin memory bin = locks[i];\r\n\t\t\tbalance = balance.add(bin.amount);\r\n\t\t}\r\n\t\treturn balance;\r\n\t}\r\n\r\n\tfunction getLockedToken (address investor) public view returns (uint256) {\r\n\t\trequire(investor != address(0) && investor != owner && investor != foundationOwner);\r\n\r\n\t\tmapping(uint => LockBin) locks = lockbins[investor];\r\n\t\tuint256 balance = 0;\r\n\t\tuint256 d = 1;\r\n\t\tuint l = locks[0].amount;\r\n\t\tfor (uint i = 1; i <= l; i ++) {\r\n\t\t\tLockBin memory bin = locks[i];\r\n\t\t\tif (now <= bin.start) {\r\n\t\t\t\tbalance = balance.add(bin.amount);\r\n\t\t\t}\r\n\t\t\telse if (now < bin.finish) {\r\n\t\t\t\td = (now - bin.start) / (1 days);\r\n\t\t\t\tbalance = balance.add(bin.amount - bin.amount * d / bin.duration);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn balance;\r\n\t}\r\n\r\n\tfunction canPay (address user, uint256 amount) internal view returns (bool) {\r\n\t\tuint256 balance = availableWallet(user);\r\n\t\treturn amount <= balance;\r\n\t}\r\n\r\n\tfunction transfer (address target, uint256 value) public whenRunning canTransfer(msg.sender, target, value) returns (bool) {\r\n\t\trequire(target != owner);\r\n\t\trequire(canPay(msg.sender, value));\r\n\r\n\t\twallets[msg.sender] = wallets[msg.sender].sub(value);\r\n\t\twallets[target] = wallets[target].add(value);\r\n\t\temit Transfer(msg.sender, target, value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\tfunction batchTransfer (address[] receivers, uint256 amount) public whenRunning returns (bool) {\r\n\t\trequire(amount > 0);\r\n\r\n\t\tuint receiveLength = receivers.length;\r\n\t\tuint receiverCount = 0;\r\n\t\tuint i;\r\n\t\taddress r;\r\n\t\tfor (i = 0; i < receiveLength; i ++) {\r\n\t\t\tr = receivers[i];\r\n\t\t\tif (r == address(0) || r == owner) continue;\r\n\t\t\treceiverCount ++;\r\n\t\t}\r\n\t\trequire(receiverCount > 0);\r\n\r\n\t\tuint256 totalAmount = amount.mul(uint256(receiverCount));\r\n\t\trequire(canPay(msg.sender, totalAmount));\r\n\r\n\t\twallets[msg.sender] = wallets[msg.sender].sub(totalAmount);\r\n\t\tfor (i = 0; i < receiveLength; i++) {\r\n\t\t\tr = receivers[i];\r\n\t\t\tif (r == address(0) || r == owner) continue;\r\n\t\t\twallets[r] = wallets[r].add(amount);\r\n\t\t\temit Transfer(msg.sender, r, amount);\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction batchTransfers (address[] receivers, uint256[] amounts) public whenRunning returns (bool) {\r\n\t\tuint receiveLength = receivers.length;\r\n\t\trequire(receiveLength == amounts.length);\r\n\r\n\t\tuint receiverCount = 0;\r\n\t\tuint256 totalAmount = 0;\r\n\t\tuint i;\r\n\t\taddress r;\r\n\t\tfor (i = 0; i < receiveLength; i ++) {\r\n\t\t\tr = receivers[i];\r\n\t\t\tif (r == address(0) || r == owner) continue;\r\n\t\t\treceiverCount ++;\r\n\t\t\ttotalAmount = totalAmount.add(amounts[i]);\r\n\t\t}\r\n\t\trequire(totalAmount > 0);\r\n\t\trequire(canPay(msg.sender, totalAmount));\r\n\r\n\t\twallets[msg.sender] = wallets[msg.sender].sub(totalAmount);\r\n\t\tuint256 amount;\r\n\t\tfor (i = 0; i < receiveLength; i++) {\r\n\t\t\tr = receivers[i];\r\n\t\t\tif (r == address(0) || r == owner) continue;\r\n\t\t\tamount = amounts[i];\r\n\t\t\tif (amount == 0) continue;\r\n\t\t\twallets[r] = wallets[r].add(amount);\r\n\t\t\temit Transfer(msg.sender, r, amount);\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferFrom (address from, address to, uint256 value) public whenRunning canTransfer(from, to, value) returns (bool) {\r\n\t\trequire(from != owner);\r\n\t\trequire(to != owner);\r\n\t\trequire(canPay(from, value));\r\n\r\n\t\tuint256 warrant;\r\n\t\tif (msg.sender != from) {\r\n\t\t\twarrant = warrants[from][msg.sender];\r\n\t\t\trequire(value <= warrant);\r\n\t\t\twarrants[from][msg.sender] = warrant.sub(value);\r\n\t\t}\r\n\r\n\t\twallets[from] = wallets[from].sub(value);\r\n\t\twallets[to] = wallets[to].add(value);\r\n\t\temit Transfer(from, to, value);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction batchTransferFrom (address from, address[] receivers, uint256 amount) public whenRunning returns (bool) {\r\n\t\trequire(from != address(0) && from != owner);\r\n\t\trequire(amount > 0);\r\n\r\n\t\tuint receiveLength = receivers.length;\r\n\t\tuint receiverCount = 0;\r\n\t\tuint i;\r\n\t\taddress r;\r\n\t\tfor (i = 0; i < receiveLength; i ++) {\r\n\t\t\tr = receivers[i];\r\n\t\t\tif (r == address(0) || r == owner) continue;\r\n\t\t\treceiverCount ++;\r\n\t\t}\r\n\t\trequire(receiverCount > 0);\r\n\r\n\t\tuint256 totalAmount = amount.mul(uint256(receiverCount));\r\n\t\trequire(canPay(from, totalAmount));\r\n\r\n\t\tuint256 warrant;\r\n\t\tif (msg.sender != from) {\r\n\t\t\twarrant = warrants[from][msg.sender];\r\n\t\t\trequire(totalAmount <= warrant);\r\n\t\t\twarrants[from][msg.sender] = warrant.sub(totalAmount);\r\n\t\t}\r\n\r\n\t\twallets[from] = wallets[from].sub(totalAmount);\r\n\t\tfor (i = 0; i < receiveLength; i++) {\r\n\t\t\tr = receivers[i];\r\n\t\t\tif (r == address(0) || r == owner) continue;\r\n\t\t\twallets[r] = wallets[r].add(amount);\r\n\t\t\temit Transfer(from, r, amount);\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction batchTransferFroms (address from, address[] receivers, uint256[] amounts) public whenRunning returns (bool) {\r\n\t\trequire(from != address(0) && from != owner);\r\n\r\n\t\tuint receiveLength = receivers.length;\r\n\t\trequire(receiveLength == amounts.length);\r\n\r\n\t\tuint receiverCount = 0;\r\n\t\tuint256 totalAmount = 0;\r\n\t\tuint i;\r\n\t\taddress r;\r\n\t\tfor (i = 0; i < receiveLength; i ++) {\r\n\t\t\tr = receivers[i];\r\n\t\t\tif (r == address(0) || r == owner) continue;\r\n\t\t\treceiverCount ++;\r\n\t\t\ttotalAmount = totalAmount.add(amounts[i]);\r\n\t\t}\r\n\t\trequire(totalAmount > 0);\r\n\t\trequire(canPay(from, totalAmount));\r\n\r\n\t\tuint256 warrant;\r\n\t\tif (msg.sender != from) {\r\n\t\t\twarrant = warrants[from][msg.sender];\r\n\t\t\trequire(totalAmount <= warrant);\r\n\t\t\twarrants[from][msg.sender] = warrant.sub(totalAmount);\r\n\t\t}\r\n\r\n\t\twallets[from] = wallets[from].sub(totalAmount);\r\n\t\tuint256 amount;\r\n\t\tfor (i = 0; i < receiveLength; i++) {\r\n\t\t\tr = receivers[i];\r\n\t\t\tif (r == address(0) || r == owner) continue;\r\n\t\t\tamount = amounts[i];\r\n\t\t\tif (amount == 0) continue;\r\n\t\t\twallets[r] = wallets[r].add(amount);\r\n\t\t\temit Transfer(from, r, amount);\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\ncontract PunchableToken is LockableToken {\r\n    using SafeMath for uint256;\r\n\t\r\n\tfunction punch (address addr, uint256 amount) public onlyOwner whenPaused returns (bool) {\r\n\t    require(addr != address(0) && addr != owner);\r\n\t\trequire(amount > 0);\r\n\t    uint256 accountAmount = availableWallet(addr);\r\n\t    uint256 burnAmount = amount;\r\n\t    if (amount > accountAmount) {\r\n\t        burnAmount = accountAmount;\r\n\t    }\r\n\t    token_created = token_created.sub(burnAmount);\r\n\t\twallets[addr] = wallets[addr].sub(burnAmount);\r\n\t\temit Burn(addr, burnAmount);\r\n\t\temit Transfer(addr, address(0), burnAmount);\r\n\t    \r\n\t    return true;\r\n\t}\r\n\t\r\n\tfunction batchPunchKO (address[] addrs) public onlyOwner whenPaused returns (bool) {\r\n\t    uint len = addrs.length;\r\n\t    require (len > 0);\r\n\t    address addr;\r\n\t    \r\n\t    for (uint i = 0; i < len; i++) {\r\n\t        addr = addrs[i];\r\n\t        if (addr == address(0) || addr == owner) continue;\r\n\t        uint256 amount = availableWallet(addr);\r\n\t        token_created = token_created.sub(amount);\r\n\t\t    wallets[addr] = wallets[addr].sub(amount);\r\n\t\t    emit Burn(addr, amount);\r\n\t\t    emit Transfer(addr, address(0), amount);\r\n\t    }\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\tfunction batchPunchs (address[] addrs, uint256[] amounts) public onlyOwner whenPaused returns (bool) {\r\n\t    uint len = addrs.length;\r\n\t    require (len > 0);\r\n\t    require (addrs.length == amounts.length);\r\n\r\n\t    address addr;\r\n\t    uint256 amount;\r\n\t    uint256 availableAmount;\r\n\t    \r\n\t    for (uint i = 0; i < len; i++) {\r\n\t        addr = addrs[i];\r\n\t        if (addr == address(0) || addr == owner) continue;\r\n\t        amount = amounts[i];\r\n\t        availableAmount = availableWallet(addr);\r\n\t        if (amount > availableAmount) {\r\n\t            amount = availableAmount;\r\n\t        }\r\n\t        token_created = token_created.sub(amount);\r\n\t\t    wallets[addr] = wallets[addr].sub(amount);\r\n\t\t    emit Burn(addr, amount);\r\n\t\t    emit Transfer(addr, address(0), amount);\r\n\t    }\r\n\t\treturn true;\r\n\t}\r\n\t\r\n    \r\n}\r\n\r\ncontract FountainToken is PunchableToken {\r\n\tstring  public constant name     = \"Fountain 3\";\r\n\tstring  public constant symbol   = \"FTN\";\r\n\tuint8   public constant decimals = 18;\r\n\r\n\tuint256 private constant TOKEN_CAP     = 10000000000 * 10 ** uint256(decimals);\r\n\tuint256 private constant TOKEN_FOUNDATION_CAP = 300000000   * 10 ** uint256(decimals);\r\n\tuint256 private constant TOKEN_INITIAL = 0   * 10 ** uint256(decimals);\r\n\r\n\tconstructor () public LockableToken(TOKEN_INITIAL, TOKEN_CAP, TOKEN_FOUNDATION_CAP) {\r\n\t}\r\n\r\n\tfunction suicide () public onlyOwner {\r\n\t\tselfdestruct(owner);\r\n\t}\r\n\r\n\tfunction transferOwnership (address newOwner) public onlyOwner returns (bool) {\r\n\t\trequire(newOwner != address(0));\r\n\t\trequire(newOwner != owner);\r\n\t\trequire(newOwner != foundationOwner);\r\n\t\trequire(wallets[owner] == 0);\r\n\t\trequire(wallets[newOwner] == 0);\r\n\r\n\t\taddress oldOwner = owner;\r\n\t\towner = newOwner;\r\n\t\temit OwnershipTransferred(oldOwner, newOwner);\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction setFountainFoundationOwner (address newFoundationOwner) public onlyOwner returns (bool) {\r\n\t\trequire(newFoundationOwner != address(0));\r\n\t\trequire(newFoundationOwner != foundationOwner);\r\n\t\trequire(newFoundationOwner != owner);\r\n\t\trequire(wallets[newFoundationOwner] == 0);\r\n\r\n\t\taddress oldFoundation = foundationOwner;\r\n\t\tfoundationOwner = newFoundationOwner;\r\n\r\n\t\temit FoundationOwnershipTransferred(oldFoundation, foundationOwner);\r\n\r\n\t\tuint256 all = wallets[oldFoundation];\r\n\t\twallets[oldFoundation] -= all;\r\n\t\twallets[newFoundationOwner] = all;\r\n\t\temit Transfer(oldFoundation, newFoundationOwner, all);\r\n\r\n\t\treturn true;\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\ncontract FountainTokenUpgrade is FountainToken {\r\n\tevent UpgradeStart();\r\n\tevent UpgradeStop();\r\n\tevent SetRefund(address, uint);\r\n\tevent Refund(address, uint);\r\n\tevent SetFoundation(uint);\r\n\tevent FinishUpgrade();\r\n\t\r\n\tbool public upgrade_running;\r\n\r\n\tbool public upgrade_finish;\r\n\t\r\n\tFountainToken ftn;\r\n\t\r\n\taddress public oldContract;\r\n\t\r\n\tmapping(address=>bool) public upgraded;\r\n\tmapping(address=>bool) public skiplist;\r\n\r\n\tmapping(address=>uint) public refundlist;\r\n\r\n\r\n\tconstructor(address old){\r\n\t\toldContract = old;\r\n\t\tftn = FountainToken(old);\r\n\t}\r\n\r\n\tmodifier canUpgrade(){\r\n\t\trequire(!upgrade_finish);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier whenUpgrading() {\r\n\t\trequire(upgrade_running);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier whenNotUpgrading() {\r\n\t\trequire(!upgrade_running);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction finishUpgrade() public whenNotUpgrading canUpgrade onlyOwner{\r\n\t\tupgrade_finish = true;\r\n\t\temit FinishUpgrade();\r\n\t}\r\n\r\n\tfunction setFoundation(uint amount) public whenUpgrading whenPaused canUpgrade onlyOwner {\r\n\t\ttoken_foundation_created = amount;\r\n\t\temit SetFoundation(amount);\r\n\t}\r\n\r\n\tfunction setRefund(address addr, uint amount) public whenUpgrading canUpgrade onlyOwner {\r\n\t\trequire(addr != address(0));\r\n\t\trequire(addr != foundationOwner);\r\n\t\trequire(addr != owner);\r\n\t\trefundlist[addr] = amount;\r\n\t\temit SetRefund(addr, amount);\r\n\t}\r\n\r\n\tfunction batchSetRefund(address[] addrs, uint[] amounts) public whenUpgrading canUpgrade onlyOwner {\r\n\t\tuint l1 = addrs.length;\r\n\t\tuint l2 = amounts.length;\r\n\t\taddress addr;\r\n\t\tuint amount;\r\n\t\trequire(l1 > 0 && l1 == l2);\r\n\t\tfor (uint i = 0; i < l1; i++){\r\n\t\t\taddr = addrs[i];\r\n\t\t\tamount = amounts[i];\r\n\t\t\tif (addr == address(0) || addr == foundationOwner || addr == owner) continue;\r\n\t\t\trefundlist[addr] = amount;\r\n\t\t\temit SetRefund(addr, amount);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfunction runRefund(address addr) public whenUpgrading canUpgrade onlyOwner {\r\n\t\tuint amount = refundlist[addr];\r\n\t\twallets[addr] = wallets[addr].add(amount); \r\n\t\ttoken_created = token_created.add(amount);\r\n\t\trefundlist[addr] = 0;\r\n\t\temit Refund(addr, amount);\r\n\t\temit Mint(addr, amount);\r\n\t\temit Transfer(address(0), addr, amount);\r\n\t}\r\n\r\n\tfunction batchRunRefund(address[] addrs) public whenUpgrading canUpgrade onlyOwner {\r\n\t\tuint l = addrs.length;\r\n\t\taddress addr;\r\n\t\tuint amount;\r\n\t\trequire(l > 0);\r\n\t\tfor (uint i = 0; i < l; i++){\r\n\t\t\taddr = addrs[i];\r\n\t\t\tamount = refundlist[addr];\r\n\t\t\twallets[addr] = wallets[addr].add(amount); \r\n\t\t\ttoken_created = token_created.add(amount);\r\n\t\t\trefundlist[addr] = 0;\r\n\t\t\temit Refund(addr, amount);\r\n\t\t\temit Mint(addr, amount);\r\n\t\t\temit Transfer(address(0), addr, amount);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction startUpgrade() public whenNotUpgrading canUpgrade onlyOwner {\r\n\t\tupgrade_running = true;\r\n\t\temit UpgradeStart();\r\n\t}\r\n\r\n\tfunction stopUpgrade() public whenUpgrading canUpgrade onlyOwner {\r\n\t\tupgrade_running = false;\r\n\t\temit UpgradeStop();\r\n\t}\r\n\r\n\tfunction setSkiplist(address[] addrs) public whenUpgrading whenPaused canUpgrade onlyOwner {\r\n\t\tuint len = addrs.length;\r\n\t\tif (len>0){\r\n\t\t\tfor (uint i = 0; i < len; i++){\r\n\t\t\t\tskiplist[addrs[i]] = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction upgrade(address addr) whenUpgrading whenPaused canUpgrade onlyOwner{\r\n\t\tuint amount = ftn.balanceOf(addr);\r\n\t\trequire(!upgraded[addr] && amount>0 && !skiplist[addr]);\r\n\r\n\t\tupgraded[addr] = true;\r\n\t\twallets[addr] = amount;\r\n\r\n\t\t(uint a, uint b, uint c, uint d) = ftn.lockbins(addr,0);\r\n\t\tuint len = d;\r\n\t\tif (len > 0){\r\n\t\t\tlockbins[addr][0].amount = len; \r\n\t\t\tfor (uint i=1; i <= len; i++){\r\n\t\t\t\t(a, b, c, d) = ftn.lockbins(addr,i);\r\n\t\t\t\tlockbins[addr][i] = LockBin({\r\n\t\t\t\t\tstart: a,\r\n\t\t\t\t\tfinish: b,\r\n\t\t\t\t\tduration: c,\r\n\t\t\t\t\tamount: d\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\ttoken_created = token_created.add(amount);\r\n\t\temit Mint(addr, amount);\r\n\t\temit Transfer(address(0), addr, amount);\r\n\t}\r\n\t\r\n\t\r\n\tfunction batchUpgrade(address[] addrs) whenUpgrading whenPaused canUpgrade onlyOwner{\r\n\t\tuint l = addrs.length;\r\n\t\trequire(l > 0);\r\n\t\tuint a;\r\n\t\tuint b; \r\n\t\tuint c; \r\n\t\tuint d;\r\n\t\tfor (uint i = 0; i < l; i++){\r\n\r\n\t\t\taddress addr = addrs[i];\r\n\t\t\tuint amount = ftn.balanceOf(addr);\r\n\t\t\tif (upgraded[addr] || amount == 0 || skiplist[addr]){\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tupgraded[addr] = true;\r\n\t\t\twallets[addr] = amount;\r\n\t\r\n\t\t\t(a, b, c, d) = ftn.lockbins(addr,0);\r\n\t\t\tuint len = d;\r\n\t\t\tif (len > 0){\r\n\t\t\t\tlockbins[addr][0].amount = len; \r\n\t\t\t\tfor (uint j=1; j <= len; j++){\r\n\t\t\t\t\t(a, b, c, d) = ftn.lockbins(addr, j);\r\n\t\t\t\t\tlockbins[addr][j] = LockBin({\r\n\t\t\t\t\t\tstart: a,\r\n\t\t\t\t\t\tfinish: b,\r\n\t\t\t\t\t\tduration: c,\r\n\t\t\t\t\t\tamount: d\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ttoken_created = token_created.add(amount);\r\n\t\t\temit Mint(addr, amount);\r\n\t\t\temit Transfer(address(0), addr, amount);\r\n\r\n\t\t} \r\n\t\t\r\n\t}\r\n\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delegator\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchPunchs\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"punch\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oldContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"batchPunchKO\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgrade_running\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receivers\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransfers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"release_start\",\"type\":\"uint256\"},{\"name\":\"release_duration\",\"type\":\"uint256\"}],\"name\":\"setInvest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchSetRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startForge\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"forge_running\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resumeInvest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lockbins\",\"outputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"finish\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"getLockedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setFoundation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"receivers\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferFroms\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"canMint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delegator\",\"type\":\"address\"},{\"name\":\"delta\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investors\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchInvests\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFoundationOwner\",\"type\":\"address\"}],\"name\":\"setFountainFoundationOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"releaseStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"receivers\",\"type\":\"address[]\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"batchTransferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"changeCap\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"receivers\",\"type\":\"address[]\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"batchTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"wallets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalFountainSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"warrants\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"forceStopInvest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"getInvestedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseInvest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"runRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"batchRunRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"skiplist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stopForge\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investors\",\"type\":\"address[]\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"batchInvest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token_foundation_cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"suicide\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgrade_finish\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"refundlist\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token_foundation_created\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"availableWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delegator\",\"type\":\"address\"},{\"name\":\"delta\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"batchUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"delegator\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token_created\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"setSkiplist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token_cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"upgraded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"releaseDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"old\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"UpgradeStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"UpgradeStop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"SetRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"SetFoundation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FinishUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"InvestStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"InvestStop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"release_start\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"release_duration\",\"type\":\"uint256\"}],\"name\":\"NewInvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ContractPause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ContractResume\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"ContractPauseSchedule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ForgeStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ForgeStop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldone\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newone\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldFoundationOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newFoundationOwner\",\"type\":\"address\"}],\"name\":\"FoundationOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]", "ContractName": "FountainTokenUpgrade", "CompilerVersion": "v0.4.25+commit.59dbf8f1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000066d9c4d19b4c8e23a54c6dc4ceed141f66b8111c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://587a64f3bcd76c41c61a153daa861225654f405755403f1f24c1c94c98a409af"}