{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/KekotronRouterV2.sol\": {\r\n      \"content\": \"/**\\n * Kekotron Router V2\\n * \\n * Website: kekotron.io\\n * Docs: docs.kekotron.io\\n * twitter.com/Kekotron_\\n * twitter.com/Nchart_\\n */\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {Owned} from \\\"solmate/auth/Owned.sol\\\";\\nimport {KekotronSwapV2} from \\\"./KekotronSwapV2.sol\\\";\\nimport {KekotronSwapTraderJoeV2_1} from \\\"./KekotronSwapTraderJoeV2_1.sol\\\";\\nimport {KekotronSwapV3} from \\\"./KekotronSwapV3.sol\\\";\\nimport {OnlyOwner, TooLittleReceived, InvalidVersion, TokenInCannotBeSameAsTokenOut, InvalidInputAmount} from \\\"./KekotronErrors.sol\\\";\\nimport {Swap, ProtocolData} from \\\"./DataTypes.sol\\\";\\nimport {INITIALIZER, POOL_FEE_MASK} from \\\"./Constants.sol\\\";\\nimport {IERC20} from \\\"./interfaces/IERC20.sol\\\";\\nimport {KekotronLib} from \\\"./KekotronLib.sol\\\";\\n\\n/**\\n * ........            \\n *        ..::::::::::::.  .       \\n *      .:::::::::::::::.  =+-.    \\n *    --::::::::::::::::.  =+++-   \\n *    ##*+::::::::::::::.  =+++++\\n *   #####:  .::::::::::.  =++++++\\n * -######:     .:::::::.  =++++++-\\n *  ######:  :.    .::::.  =+++++++\\n * #######:  -=-:.    .:.  =+++++++\\n * +######:  -=====:.      =++++++=\\n * :######:  -========-.   =++++++:\\n *  +#####:  -===========-.-+++++= \\n *   =####:  -==============-==+-  \\n *    :*##:  -================-.   \\n *      :+:  -==============-.     \\n *           :==========-:.        \\n *              ......\\n */\\n\\ncontract KekotronRouterV2 is Owned, KekotronSwapV2, KekotronSwapTraderJoeV2_1, KekotronSwapV3 {\\n    event FeeUpdated(uint8 fee);\\n    event FeeReceiverUpdated(address feeReceiver);\\n    event ProtocolDataUpdated(uint8 protocol, ProtocolData data);\\n    event AllowedV2CallbackUpdated(bytes4 selector, bool allowed);\\n    event AllowedV3CallbackUpdated(bytes4 selector, bool allowed);\\n\\n    address private immutable WRAPPED_NATIVE;\\n    bytes4 private constant V2_CALLBACK1 = 0x10d1e85c;\\n    bytes4 private constant V2_CALLBACK2 = 0x84800812;\\n    bytes4 private constant V2_CALLBACK3 = 0xee22dd87;\\n\\n    bytes4 private constant V3_CALLBACK1 = 0xfa461e33;\\n    bytes4 private constant V3_CALLBACK2 = 0x23a69e75;\\n    bytes4 private constant V3_CALLBACK3 = 0x2c8958f6;\\n\\n    uint8 public fee = 0; // 100 = 1% - max = 255 = 2.55%\\n    address public feeReceiver;\\n\\n    /// @dev Fallback selectors for callbacks, allowing for adding additional protocols in the future\\n    mapping(bytes4 => bool) public allowedV2Callbacks;\\n    mapping(bytes4 => bool) public allowedV3Callbacks;\\n\\n    constructor(address owner_) Owned(owner_) KekotronSwapV2() KekotronSwapTraderJoeV2_1() KekotronSwapV3() {\\n        (address receiver, address wrappedNative_,) = INITIALIZER.getSetupData();\\n\\n        WRAPPED_NATIVE = wrappedNative_;\\n        feeReceiver = receiver;\\n    }\\n\\n    modifier onlyOwner() virtual override {\\n        _requireIsOwner();\\n        _;\\n    }\\n\\n    function updateFee(uint8 newFee) external onlyOwner {\\n        fee = newFee;\\n\\n        emit FeeUpdated(newFee);\\n    }\\n\\n    function updateFeeReceiver(address newFeeReceiver) external onlyOwner {\\n        feeReceiver = newFeeReceiver;\\n\\n        emit FeeReceiverUpdated(newFeeReceiver);\\n    }\\n\\n    function withdrawNative() external onlyOwner {\\n        KekotronLib.safeTransferNative(owner, address(this).balance);\\n    }\\n\\n    function withdrawToken(address token) external onlyOwner {\\n        KekotronLib.safeTransfer(token, owner, IERC20(token).balanceOf(address(this)));\\n    }\\n\\n    function updateAllowedV2Callbacks(bytes4 selector, bool allowed) external onlyOwner {\\n        allowedV2Callbacks[selector] = allowed;\\n\\n        emit AllowedV2CallbackUpdated(selector, allowed);\\n    }\\n\\n    function updatedAllowedV3Callbacks(bytes4 selector, bool allowed) external onlyOwner {\\n        allowedV3Callbacks[selector] = allowed;\\n\\n        emit AllowedV3CallbackUpdated(selector, allowed);\\n    }\\n\\n    function updateProtocolData(uint8 protocol, ProtocolData memory data) external onlyOwner {\\n        _updateProtocolData(protocol, data);\\n\\n        emit ProtocolDataUpdated(protocol, data);\\n    }\\n\\n    /**\\n     * @dev The fallback function is used to handle both callbacks from the pools and swap initiators\\n     * @dev For swaps, a prefix is added to the calldata to indicate the type of call and certain parameters\\n     * @dev The prefix is 5 bytes long and is structured as follows:\\n     * @dev   0: version (1 byte)\\n     * @dev   1: feeOn (1 byte)\\n     * @dev   2: protocol (1 byte)\\n     * @dev   3: poolFee (2 bytes)\\n     *\\n     * @dev For callbacks, the selector is checked against the allowed callbacks and the call is forwarded\\n     * @dev to a callback handler. The callback handler is responsible for decoding the calldata and\\n     * @dev performing the appropriate actions. For v3 callbacks the msg.sender MUST be a pool launched\\n     * @dev by the cannonical factory of the protocol.\\n     *\\n     * @dev To support new V3 protocols, the owner MUST call updateProtocolData with the new protocol details\\n     * @dev there can be overlap of protocol selectors between different protocols, so numeric identifiers are\\n     * @dev used in the calldata prefix to differentiate between them.\\n     */\\n    fallback() external payable {\\n        bytes4 selector = bytes4(msg.data[:4]);\\n\\n        // First check immutable callbacks\\n        if (_isV2Callback(selector)) {\\n            return;\\n        }\\n\\n        if (_isV3Callback(selector)) {\\n            (int256 amount0Delta, int256 amount1Delta, bytes memory data) =\\n                abi.decode(msg.data[4:], (int256, int256, bytes));\\n            return _callbackV3(amount0Delta, amount1Delta, data);\\n        }\\n\\n        uint8 version;\\n        uint8 feeOn;\\n        uint8 protocol;\\n        uint16 poolFee;\\n\\n        assembly {\\n            let data := calldataload(0)\\n            version := byte(0, data)\\n            feeOn := byte(1, data)\\n            protocol := byte(2, data)\\n            poolFee := shr(216, and(data, POOL_FEE_MASK))\\n        }\\n\\n        Swap memory swapData;\\n\\n        // TOOD: M-03 - Add support for deadline in calldata\\n        assembly {\\n            let offset := 0x05\\n            calldatacopy(add(swapData, 0x0c), offset, 0x14) // pool\\n            calldatacopy(add(swapData, 0x2c), add(offset, 0x14), 0x14) // tokenIn\\n            calldatacopy(add(swapData, 0x4c), add(offset, 0x28), 0x14) // tokenOut\\n            calldatacopy(add(swapData, 0x70), add(offset, 0x3c), 0x10) // amountIn\\n            calldatacopy(add(swapData, 0x90), add(offset, 0x4c), 0x20) // amountOut\\n        }\\n\\n        if (swapData.tokenIn == swapData.tokenOut) {\\n            revert TokenInCannotBeSameAsTokenOut();\\n        }\\n\\n        if (swapData.tokenIn == address(0)) {\\n            if (msg.value != swapData.amountIn) {\\n                revert InvalidInputAmount();\\n            }\\n        }\\n\\n        if (version == 0) {\\n            // v2\\n            return _swapExactInputV2(swapData, feeReceiver, fee, feeOn, poolFee);\\n        }\\n\\n        if (version == 1) {\\n            // v3\\n            return _swapExactInputV3(swapData, feeReceiver, fee, feeOn, poolFee, protocol);\\n        }\\n\\n        if (version == 2) {\\n            // Trader Joe v2.1\\n            return _swapExactInputV2_1(swapData, feeReceiver, fee, feeOn);\\n        }\\n\\n        // Fallback to mutable callbacks if no version and no immutable match\\n        if (allowedV2Callbacks[selector]) {\\n            return;\\n        }\\n\\n        if (allowedV3Callbacks[selector]) {\\n            (int256 amount0Delta, int256 amount1Delta, bytes memory data) =\\n                abi.decode(msg.data[4:], (int256, int256, bytes));\\n            return _callbackV3(amount0Delta, amount1Delta, data);\\n        }\\n\\n        revert InvalidVersion();\\n    }\\n\\n    function _requireIsOwner() internal view {\\n        if (msg.sender != owner) {\\n            revert OnlyOwner();\\n        }\\n    }\\n\\n    function _isV2Callback(bytes4 selector) internal pure returns (bool isCallback) {\\n        if (selector == V2_CALLBACK1) {\\n            isCallback = true;\\n        } else if (selector == V2_CALLBACK2) {\\n            isCallback = true;\\n        } else if (selector == V2_CALLBACK3) {\\n            isCallback = true;\\n        }\\n    }\\n\\n    function _isV3Callback(bytes4 selector) internal pure returns (bool isCallback) {\\n        if (selector == V3_CALLBACK1) {\\n            isCallback = true;\\n        } else if (selector == V3_CALLBACK2) {\\n            isCallback = true;\\n        } else if (selector == V3_CALLBACK3) {\\n            isCallback = true;\\n        }\\n    }\\n\\n    function _wrappedNative()\\n        internal\\n        view\\n        override(KekotronSwapTraderJoeV2_1, KekotronSwapV2, KekotronSwapV3)\\n        returns (address)\\n    {\\n        return WRAPPED_NATIVE;\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/KekotronSwapV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"./interfaces/IPoolV2.sol\\\";\\nimport \\\"./KekotronRouterInitializer.sol\\\";\\nimport \\\"./KekotronLib.sol\\\";\\nimport \\\"./KekotronErrors.sol\\\";\\nimport {Swap} from \\\"./DataTypes.sol\\\";\\nimport {INITIALIZER, MAX_BPS} from \\\"./Constants.sol\\\";\\n\\nabstract contract KekotronSwapV2 {\\n    constructor() {}\\n\\n    function _getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut, uint16 poolFee)\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        if (amountIn == 0) {\\n            revert InsufficientInputAmount();\\n        }\\n        if (reserveIn == 0 || reserveOut == 0) {\\n            revert InsufficientLiquidity();\\n        }\\n\\n        uint256 amountInWithFee = amountIn * (100000 - poolFee) / 100;\\n        uint256 numerator = amountInWithFee * reserveOut;\\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\\n\\n        return numerator / denominator;\\n    }\\n\\n    function _swapV2(Swap memory param, address to, uint16 poolFee) private returns (uint256) {\\n        bool zeroForOne = param.tokenIn < param.tokenOut;\\n\\n        uint256 amountOut;\\n        {\\n            (uint256 reserve0, uint256 reserve1,) = IPoolV2(param.pool).getReserves();\\n            (uint256 reserveInput, uint256 reserveOutput) = zeroForOne ? (reserve0, reserve1) : (reserve1, reserve0);\\n\\n            amountOut = _getAmountOut(\\n                IERC20(param.tokenIn).balanceOf(param.pool) - reserveInput, reserveInput, reserveOutput, poolFee\\n            );\\n        }\\n\\n        (uint256 amount0Out, uint256 amount1Out) = zeroForOne ? (uint256(0), amountOut) : (amountOut, uint256(0));\\n\\n        uint256 balanceBefore = IERC20(param.tokenOut).balanceOf(to);\\n        IPoolV2(param.pool).swap(amount0Out, amount1Out, to, new bytes(0));\\n        uint256 balanceAfter = IERC20(param.tokenOut).balanceOf(to);\\n\\n        return balanceAfter - balanceBefore;\\n    }\\n\\n    function _swapExactNativeForTokensV2(Swap memory param, address feeReceiver, uint8 fee, uint8 feeOn, uint16 poolFee)\\n        private\\n    {\\n        (bool feeIn, bool feeOut) = fee > 0 ? (feeOn < 1, feeOn > 0) : (false, false);\\n        uint256 amountFee;\\n\\n        if (feeIn) {\\n            amountFee = param.amountIn * fee / MAX_BPS;\\n            KekotronLib.safeTransferNative(feeReceiver, amountFee);\\n            param.amountIn -= amountFee;\\n        }\\n\\n        KekotronLib.depositWrappedNative(_wrappedNative(), param.amountIn);\\n        KekotronLib.safeTransfer(_wrappedNative(), param.pool, param.amountIn);\\n\\n        uint256 amountOut = _swapV2(param, feeOut ? address(this) : msg.sender, poolFee);\\n        if (feeOut) {\\n            amountFee = amountOut * fee / MAX_BPS;\\n            amountOut = amountOut - amountFee;\\n            if (amountFee > 0) {\\n                KekotronLib.safeTransfer(param.tokenOut, feeReceiver, amountFee);\\n            }\\n        }\\n\\n        if (amountOut < param.amountOut) {\\n            revert TooLittleReceived();\\n        }\\n\\n        if (feeOut) {\\n            KekotronLib.safeTransfer(param.tokenOut, msg.sender, amountOut);\\n        }\\n    }\\n\\n    function _swapExactTokensForNativeV2(Swap memory param, address feeReceiver, uint8 fee, uint8 feeOn, uint16 poolFee)\\n        private\\n    {\\n        (bool feeIn, bool feeOut) = fee > 0 ? (feeOn < 1, feeOn > 0) : (false, false);\\n        uint256 amountFee;\\n\\n        if (feeIn) {\\n            amountFee = param.amountIn * fee / MAX_BPS;\\n            KekotronLib.safeTransferFrom(param.tokenIn, msg.sender, feeReceiver, amountFee);\\n            param.amountIn -= amountFee;\\n        }\\n\\n        KekotronLib.safeTransferFrom(param.tokenIn, msg.sender, param.pool, param.amountIn);\\n\\n        uint256 amountOut = _swapV2(param, address(this), poolFee);\\n\\n        KekotronLib.withdrawWrappedNative(_wrappedNative(), amountOut);\\n\\n        if (feeOut) {\\n            amountFee = amountOut * fee / MAX_BPS;\\n            amountOut = amountOut - amountFee;\\n            if (amountFee > 0) {\\n                KekotronLib.safeTransferNative(feeReceiver, amountFee);\\n            }\\n        }\\n\\n        if (amountOut < param.amountOut) {\\n            revert TooLittleReceived();\\n        }\\n\\n        KekotronLib.safeTransferNative(msg.sender, amountOut);\\n    }\\n\\n    function _swapExactTokensForTokensV2(Swap memory param, address feeReceiver, uint8 fee, uint8 feeOn, uint16 poolFee)\\n        private\\n    {\\n        (bool feeIn, bool feeOut) = fee > 0 ? (feeOn < 1, feeOn > 0) : (false, false);\\n        uint256 amountFee;\\n\\n        if (feeIn) {\\n            amountFee = param.amountIn * fee / MAX_BPS;\\n            KekotronLib.safeTransferFrom(param.tokenIn, msg.sender, feeReceiver, amountFee);\\n            param.amountIn -= amountFee;\\n        }\\n\\n        KekotronLib.safeTransferFrom(param.tokenIn, msg.sender, param.pool, param.amountIn);\\n\\n        uint256 amountOut = _swapV2(param, feeOut ? address(this) : msg.sender, poolFee);\\n\\n        if (feeOut) {\\n            amountFee = amountOut * fee / MAX_BPS;\\n            amountOut = amountOut - amountFee;\\n            if (amountFee > 0) {\\n                KekotronLib.safeTransfer(param.tokenOut, feeReceiver, amountFee);\\n            }\\n        }\\n\\n        if (amountOut < param.amountOut) {\\n            revert TooLittleReceived();\\n        }\\n\\n        if (feeOut) {\\n            KekotronLib.safeTransfer(param.tokenOut, msg.sender, amountOut);\\n        }\\n    }\\n\\n    function _swapExactInputV2(Swap memory param, address feeReceiver, uint8 fee, uint8 feeOn, uint16 poolFee)\\n        internal\\n    {\\n        if (param.tokenIn == address(0)) {\\n            param.tokenIn = _wrappedNative();\\n            return _swapExactNativeForTokensV2(param, feeReceiver, fee, feeOn, poolFee);\\n        }\\n\\n        if (param.tokenOut == address(0)) {\\n            param.tokenOut = _wrappedNative();\\n            return _swapExactTokensForNativeV2(param, feeReceiver, fee, feeOn, poolFee);\\n        }\\n\\n        return _swapExactTokensForTokensV2(param, feeReceiver, fee, feeOn, poolFee);\\n    }\\n\\n    /// @dev overwritten in top level contract\\n    function _wrappedNative() internal view virtual returns (address);\\n}\\n\"\r\n    },\r\n    \"src/KekotronSwapTraderJoeV2_1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"./interfaces/IPoolTraderJoeV2_1.sol\\\";\\nimport \\\"./KekotronRouterInitializer.sol\\\";\\nimport \\\"./KekotronLib.sol\\\";\\nimport {TooLittleReceived, TokenInCannotBeSameAsTokenOut} from \\\"./KekotronErrors.sol\\\";\\nimport {Swap} from \\\"./DataTypes.sol\\\";\\nimport {INITIALIZER, MAX_BPS} from \\\"./Constants.sol\\\";\\n\\nabstract contract KekotronSwapTraderJoeV2_1 {\\n    constructor() {}\\n\\n    function _swapV2_1(Swap memory param, address to) private returns (uint256) {\\n        bool zeroForOne = param.tokenIn < param.tokenOut;\\n\\n        uint256 balanceBefore = IERC20(param.tokenOut).balanceOf(to);\\n        IPoolTraderJoeV2_1(param.pool).swap(zeroForOne, to);\\n\\n        return IERC20(param.tokenOut).balanceOf(to) - balanceBefore;\\n    }\\n\\n    function _swapExactNativeForTokensV2_1(Swap memory param, address feeReceiver, uint8 fee, uint8 feeOn) private {\\n        (bool feeIn, bool feeOut) = fee > 0 ? (feeOn < 1, feeOn > 0) : (false, false);\\n        uint256 amountFee;\\n\\n        if (feeIn) {\\n            amountFee = param.amountIn * fee / MAX_BPS;\\n            KekotronLib.safeTransferNative(feeReceiver, amountFee);\\n            param.amountIn -= amountFee;\\n        }\\n\\n        KekotronLib.depositWrappedNative(_wrappedNative(), param.amountIn);\\n        KekotronLib.safeTransfer(_wrappedNative(), param.pool, param.amountIn);\\n\\n        uint256 amountOut = _swapV2_1(param, feeOut ? address(this) : msg.sender);\\n\\n        if (feeOut) {\\n            amountFee = amountOut * fee / MAX_BPS;\\n            amountOut = amountOut - amountFee;\\n            if (amountFee > 0) {\\n                KekotronLib.safeTransfer(param.tokenOut, feeReceiver, amountFee);\\n            }\\n        }\\n\\n        if (amountOut < param.amountOut) {\\n            revert TooLittleReceived();\\n        }\\n\\n        if (feeOut) {\\n            KekotronLib.safeTransfer(param.tokenOut, msg.sender, amountOut);\\n        }\\n    }\\n\\n    function _swapExactTokensForNativeV2_1(Swap memory param, address feeReceiver, uint8 fee, uint8 feeOn) private {\\n        (bool feeIn, bool feeOut) = fee > 0 ? (feeOn < 1, feeOn > 0) : (false, false);\\n        uint256 amountFee;\\n\\n        if (feeIn) {\\n            amountFee = param.amountIn * fee / MAX_BPS;\\n            KekotronLib.safeTransferFrom(param.tokenIn, msg.sender, feeReceiver, amountFee);\\n            param.amountIn -= amountFee;\\n        }\\n\\n        KekotronLib.safeTransferFrom(param.tokenIn, msg.sender, param.pool, param.amountIn);\\n\\n        uint256 amountOut = _swapV2_1(param, address(this));\\n\\n        KekotronLib.withdrawWrappedNative(_wrappedNative(), amountOut);\\n\\n        if (feeOut) {\\n            amountFee = amountOut * fee / MAX_BPS;\\n            amountOut = amountOut - amountFee;\\n            if (amountFee > 0) {\\n                KekotronLib.safeTransferNative(feeReceiver, amountFee);\\n            }\\n        }\\n\\n        if (amountOut < param.amountOut) {\\n            revert TooLittleReceived();\\n        }\\n\\n        KekotronLib.safeTransferNative(msg.sender, amountOut);\\n    }\\n\\n    function _swapExactTokensForTokensV2_1(Swap memory param, address feeReceiver, uint8 fee, uint8 feeOn) private {\\n        (bool feeIn, bool feeOut) = fee > 0 ? (feeOn < 1, feeOn > 0) : (false, false);\\n        uint256 amountFee;\\n\\n        if (feeIn) {\\n            amountFee = param.amountIn * fee / MAX_BPS;\\n            KekotronLib.safeTransferFrom(param.tokenIn, msg.sender, feeReceiver, amountFee);\\n            param.amountIn -= amountFee;\\n        }\\n\\n        KekotronLib.safeTransferFrom(param.tokenIn, msg.sender, param.pool, param.amountIn);\\n\\n        uint256 amountOut = _swapV2_1(param, feeOut ? address(this) : msg.sender);\\n\\n        if (feeOut) {\\n            amountFee = amountOut * fee / MAX_BPS;\\n            amountOut = amountOut - amountFee;\\n            if (amountFee > 0) {\\n                KekotronLib.safeTransfer(param.tokenOut, feeReceiver, amountFee);\\n            }\\n        }\\n\\n        if (amountOut < param.amountOut) {\\n            revert TooLittleReceived();\\n        }\\n\\n        if (feeOut) {\\n            KekotronLib.safeTransfer(param.tokenOut, msg.sender, amountOut);\\n        }\\n    }\\n\\n    function _swapExactInputV2_1(Swap memory param, address feeReceiver, uint8 fee, uint8 feeOn) internal {\\n        if (param.tokenIn == address(0)) {\\n            param.tokenIn = _wrappedNative();\\n            return _swapExactNativeForTokensV2_1(param, feeReceiver, fee, feeOn);\\n        }\\n\\n        if (param.tokenOut == address(0)) {\\n            param.tokenOut = _wrappedNative();\\n            return _swapExactTokensForNativeV2_1(param, feeReceiver, fee, feeOn);\\n        }\\n\\n        return _swapExactTokensForTokensV2_1(param, feeReceiver, fee, feeOn);\\n    }\\n\\n    function _wrappedNative() internal view virtual returns (address);\\n}\\n\"\r\n    },\r\n    \"src/KekotronSwapV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"./interfaces/IAlgebraFactory.sol\\\";\\nimport \\\"./interfaces/IPoolV3.sol\\\";\\nimport \\\"./KekotronRouterInitializer.sol\\\";\\nimport \\\"./KekotronLib.sol\\\";\\nimport {\\n    TooLittleReceived,\\n    InvalidCallbackPool,\\n    InsufficientLiquidity,\\n    ProtocolDataAlreadySet,\\n    ProtocolNotFound\\n} from \\\"./KekotronErrors.sol\\\";\\nimport {Swap} from \\\"./DataTypes.sol\\\";\\nimport {INITIALIZER, MAX_BPS, MIN_SQRT_RATIO, MAX_SQRT_RATIO} from \\\"./Constants.sol\\\";\\n\\nabstract contract KekotronSwapV3 {\\n    mapping(uint8 => ProtocolData) private _factories;\\n\\n    constructor() {\\n        ProtocolData[] memory protocoldata = INITIALIZER.getProtocolData();\\n\\n        for (uint8 i = 0; i < protocoldata.length;) {\\n            _factories[i] = protocoldata[i];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the factory ID for a given factory address or returns 0 if the factory is not supported\\n     * @dev    Do not use this on chain, as this function is gas intensive\\n     */\\n    function getProtocolNumber(address factory) external view returns (uint8 protocol) {\\n        bool found;\\n        for (uint8 i = 0; i < type(uint8).max;) {\\n            if (factory == _factories[i].factory) {\\n                protocol = uint8(i);\\n                found = true;\\n                break;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        if (!found) {\\n            revert ProtocolNotFound();\\n        }\\n    }\\n\\n    /**\\n     * @notice Allows the owner to update the protocol data for a given protocol\\n     *\\n     * @dev    This function is intended to be overridden by the inheriting contract - do not leave unguarded\\n     *\\n     * @param  protocol The protocol ID to update\\n     * @param  data     The new protocol data\\n     */\\n    function _updateProtocolData(uint8 protocol, ProtocolData memory data) internal {\\n        if (_factories[protocol].factory != address(0)) {\\n            revert ProtocolDataAlreadySet();\\n        }\\n\\n        _factories[protocol] = data;\\n    }\\n\\n    function _computePool(address tokenIn, address tokenOut, uint24 fee, uint8 protocol)\\n        private\\n        view\\n        returns (address pool)\\n    {\\n        address tokenA;\\n        address tokenB;\\n\\n        if (tokenIn < tokenOut) {\\n            tokenA = tokenIn;\\n            tokenB = tokenOut;\\n        } else {\\n            tokenA = tokenOut;\\n            tokenB = tokenIn;\\n        }\\n\\n        ProtocolData memory protocolData = _factories[protocol];\\n\\n        bytes memory typeData;\\n        if (protocolData.feeInHash) {\\n            typeData = abi.encode(tokenA, tokenB, fee);\\n        } else {\\n            typeData = abi.encode(tokenA, tokenB);\\n        }\\n\\n        pool = address(\\n            uint160(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            hex\\\"ff\\\",\\n                            protocolData.externalDeployer\\n                                ? IAlgebraFactory(protocolData.factory).poolDeployer()\\n                                : protocolData.factory,\\n                            keccak256(typeData),\\n                            protocolData.initHash\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    function _deriveData(Swap memory param, address payer, uint16 poolFee, uint8 protocol)\\n        private\\n        pure\\n        returns (bool, int256, uint160, bytes memory)\\n    {\\n        bool zeroForOne = param.tokenIn < param.tokenOut;\\n        // We shift the fee to save some calldata space in the original call\\n        uint24 shiftedFee = uint24(poolFee) * 10;\\n\\n        int256 amountSpecified = int256(param.amountIn);\\n        uint160 sqrtPriceLimitX96 = (zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1);\\n        bytes memory data = abi.encode(param.tokenIn, param.tokenOut, shiftedFee, param.amountOut, payer, protocol);\\n\\n        return (zeroForOne, amountSpecified, sqrtPriceLimitX96, data);\\n    }\\n\\n    function _swapV3(Swap memory param, address to, address payer, uint16 poolFee, uint8 protocol)\\n        private\\n        returns (uint256)\\n    {\\n        (bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes memory data) =\\n            _deriveData(param, payer, poolFee, protocol);\\n\\n        (int256 amount0, int256 amount1) =\\n            IPoolV3(param.pool).swap(to, zeroForOne, amountSpecified, sqrtPriceLimitX96, data);\\n        uint256 amountOut = uint256(-(zeroForOne ? amount1 : amount0));\\n\\n        return amountOut;\\n    }\\n\\n    function _swapExactNativeForTokensV3(\\n        Swap memory param,\\n        address feeReceiver,\\n        uint8 fee,\\n        uint8 feeOn,\\n        uint16 poolFee,\\n        uint8 protocol\\n    ) private {\\n        (bool feeIn, bool feeOut) = fee > 0 ? (feeOn < 1, feeOn > 0) : (false, false);\\n        uint256 amountFee;\\n\\n        if (feeIn) {\\n            amountFee = param.amountIn * fee / MAX_BPS;\\n            KekotronLib.safeTransferNative(feeReceiver, amountFee);\\n            param.amountIn -= amountFee;\\n        }\\n\\n        KekotronLib.depositWrappedNative(_wrappedNative(), param.amountIn);\\n\\n        uint256 amountOut = _swapV3(param, feeOut ? address(this) : msg.sender, address(this), poolFee, protocol);\\n\\n        if (feeOut) {\\n            amountFee = amountOut * fee / MAX_BPS;\\n            amountOut = amountOut - amountFee;\\n            if (amountFee > 0) {\\n                KekotronLib.safeTransfer(param.tokenOut, feeReceiver, amountFee);\\n            }\\n        }\\n\\n        if (amountOut < param.amountOut) {\\n            revert TooLittleReceived();\\n        }\\n\\n        if (feeOut) {\\n            KekotronLib.safeTransfer(param.tokenOut, msg.sender, amountOut);\\n        }\\n    }\\n\\n    function _swapExactTokensForNativeV3(\\n        Swap memory param,\\n        address feeReceiver,\\n        uint8 fee,\\n        uint8 feeOn,\\n        uint16 poolFee,\\n        uint8 protocol\\n    ) private {\\n        (bool feeIn, bool feeOut) = fee > 0 ? (feeOn < 1, feeOn > 0) : (false, false);\\n        uint256 amountFee;\\n\\n        if (feeIn) {\\n            amountFee = param.amountIn * fee / MAX_BPS;\\n            KekotronLib.safeTransferFrom(param.tokenIn, msg.sender, feeReceiver, amountFee);\\n            param.amountIn -= amountFee;\\n        }\\n\\n        uint256 amountOut = _swapV3(param, address(this), msg.sender, poolFee, protocol);\\n\\n        KekotronLib.withdrawWrappedNative(_wrappedNative(), amountOut);\\n\\n        if (feeOut) {\\n            amountFee = amountOut * fee / MAX_BPS;\\n            amountOut = amountOut - amountFee;\\n            if (amountFee > 0) {\\n                KekotronLib.safeTransfer(param.tokenOut, feeReceiver, amountFee);\\n            }\\n        }\\n\\n        if (amountOut < param.amountOut) {\\n            revert TooLittleReceived();\\n        }\\n\\n        KekotronLib.safeTransferNative(msg.sender, amountOut);\\n    }\\n\\n    function _swapExactTokensForTokensV3(\\n        Swap memory param,\\n        address feeReceiver,\\n        uint8 fee,\\n        uint8 feeOn,\\n        uint16 poolFee,\\n        uint8 protocol\\n    ) private {\\n        (bool feeIn, bool feeOut) = fee > 0 ? (feeOn < 1, feeOn > 0) : (false, false);\\n        uint256 amountFee;\\n\\n        if (feeIn) {\\n            amountFee = param.amountIn * fee / MAX_BPS;\\n            KekotronLib.safeTransferFrom(param.tokenIn, msg.sender, feeReceiver, amountFee);\\n            param.amountIn -= amountFee;\\n        }\\n\\n        uint256 amountOut = _swapV3(param, feeOut ? address(this) : msg.sender, msg.sender, poolFee, protocol);\\n\\n        if (feeOut) {\\n            amountFee = amountOut * fee / MAX_BPS;\\n            amountOut = amountOut - amountFee;\\n            if (amountFee > 0) {\\n                KekotronLib.safeTransfer(param.tokenOut, feeReceiver, amountFee);\\n            }\\n        }\\n\\n        if (amountOut < param.amountOut) {\\n            revert TooLittleReceived();\\n        }\\n\\n        if (feeOut) {\\n            KekotronLib.safeTransfer(param.tokenOut, msg.sender, amountOut);\\n        }\\n    }\\n\\n    function _swapExactInputV3(\\n        Swap memory param,\\n        address feeReceiver,\\n        uint8 fee,\\n        uint8 feeOn,\\n        uint16 poolFee,\\n        uint8 protocol\\n    ) internal {\\n        if (param.tokenIn == address(0)) {\\n            param.tokenIn = _wrappedNative();\\n            return _swapExactNativeForTokensV3(param, feeReceiver, fee, feeOn, poolFee, protocol);\\n        }\\n\\n        if (param.tokenOut == address(0)) {\\n            param.tokenOut = _wrappedNative();\\n            return _swapExactTokensForNativeV3(param, feeReceiver, fee, feeOn, poolFee, protocol);\\n        }\\n\\n        return _swapExactTokensForTokensV3(param, feeReceiver, fee, feeOn, poolFee, protocol);\\n    }\\n\\n    function _callbackV3(int256 amount0Delta, int256 amount1Delta, bytes memory data) internal {\\n        if (amount0Delta == 0 && amount1Delta == 0) {\\n            revert InsufficientLiquidity();\\n        }\\n\\n        (address tokenIn, address tokenOut, uint24 fee, uint256 limit, address payer, uint8 protocol) =\\n            abi.decode(data, (address, address, uint24, uint256, address, uint8));\\n\\n        if (msg.sender != _computePool(tokenIn, tokenOut, fee, protocol)) {\\n            revert InvalidCallbackPool();\\n        }\\n\\n        bool zeroForOne = tokenIn < tokenOut;\\n\\n        if (uint256(-(zeroForOne ? amount1Delta : amount0Delta)) < limit) {\\n            revert TooLittleReceived();\\n        }\\n\\n        if (payer == address(this)) {\\n            KekotronLib.safeTransfer(tokenIn, msg.sender, uint256(zeroForOne ? amount0Delta : amount1Delta));\\n        } else {\\n            KekotronLib.safeTransferFrom(tokenIn, payer, msg.sender, uint256(zeroForOne ? amount0Delta : amount1Delta));\\n        }\\n    }\\n\\n    function _wrappedNative() internal view virtual returns (address);\\n}\\n\"\r\n    },\r\n    \"src/KekotronErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nerror OnlyOwner();\\n\\nerror InvalidVersion();\\n\\nerror WrappedNativeCurrencyDeposit();\\nerror WrappedNativeCurrencyWithdraw();\\nerror NativeTransfer();\\nerror TokenTransfer();\\nerror TokenTransferFrom();\\nerror TokenMustBeContract();\\nerror TokenInCannotBeSameAsTokenOut();\\n\\nerror TooLittleReceived();\\nerror InvalidInputAmount();\\nerror InsufficientInputAmount();\\nerror InsufficientLiquidity();\\nerror InvalidCallbackPool();\\n\\nerror ProtocolNotFound();\\nerror ProtocolDataAlreadySet();\\nerror SetupAlreadyComplete();\\n\"\r\n    },\r\n    \"src/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nstruct Swap {\\n    address pool;\\n    address tokenIn;\\n    address tokenOut;\\n    uint256 amountIn;\\n    uint256 amountOut;\\n}\\n\\nstruct ProtocolData {\\n    bool feeInHash;\\n    bool externalDeployer;\\n    address factory;\\n    bytes32 initHash;\\n}\\n\"\r\n    },\r\n    \"src/Constants.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n\\nimport {KekotronRouterInitializer} from \\\"./KekotronRouterInitializer.sol\\\";\\n\\nKekotronRouterInitializer constant INITIALIZER =\\n    KekotronRouterInitializer(address(0x70B973006870a80073CE6d0022a2000000001914));\\n\\nuint256 constant MAX_BPS = 10_000;\\nuint160 constant MIN_SQRT_RATIO = 4295128739;\\nuint160 constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\nuint256 constant PUSH_PAYMENT_GAS_LIMIT = 10_000;\\n\\nbytes32 constant POOL_FEE_MASK = 0x000000ffff000000000000000000000000000000000000000000000000000000;\\n\"\r\n    },\r\n    \"src/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IERC20 {\\n    function balanceOf(address account) external view returns (uint256);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/KekotronLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {IERC20} from \\\"src/interfaces/IERC20.sol\\\";\\nimport {IWETH} from \\\"src/interfaces/IWETH.sol\\\";\\nimport {TokenTransfer, TokenTransferFrom, TokenMustBeContract, NativeTransfer, WrappedNativeCurrencyDeposit, WrappedNativeCurrencyWithdraw} from \\\"./KekotronErrors.sol\\\";\\nimport {PUSH_PAYMENT_GAS_LIMIT} from \\\"./Constants.sol\\\";\\n\\nlibrary KekotronLib {\\n    function safeTransfer(address token, address to, uint256 value) internal {\\n        if (token.code.length == 0) {\\n            revert TokenMustBeContract();\\n        }\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        if (!(success && (data.length == 0 || abi.decode(data, (bool))))) {\\n            revert TokenTransfer();\\n        }\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\\n        if (token.code.length == 0) {\\n            revert TokenMustBeContract();\\n        }\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        if (!(success && (data.length == 0 || abi.decode(data, (bool))))) {\\n            revert TokenTransferFrom();\\n        }\\n    }\\n\\n    function safeTransferNative(address to, uint256 value) internal {\\n        (bool success,) = to.call{value: value, gas: PUSH_PAYMENT_GAS_LIMIT}(new bytes(0));\\n        if (!success) {\\n            revert NativeTransfer();\\n        }\\n    }\\n\\n    function depositWrappedNative(address wrappedNative, uint256 value) internal {\\n        (bool success,) = wrappedNative.call{value: value}(new bytes(0));\\n        if (!success) {\\n            revert WrappedNativeCurrencyDeposit();\\n        }\\n    }\\n\\n    function withdrawWrappedNative(address wrappedNative, uint256 value) internal {\\n        (bool success,) = wrappedNative.call(abi.encodeWithSelector(IWETH.withdraw.selector, value));\\n        if (!success) {\\n            revert WrappedNativeCurrencyWithdraw();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPoolV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IPoolV2 {\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"src/KekotronRouterInitializer.sol\": {\r\n      \"content\": \"/**\\n * Kekotron Router V2\\n * \\n * Website: kekotron.io\\n * Docs: docs.kekotron.io\\n * twitter.com/Kekotron_\\n * twitter.com/Nchart_\\n */\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {Owned} from \\\"solmate/auth/Owned.sol\\\";\\nimport {ProtocolData} from \\\"./DataTypes.sol\\\";\\nimport {SetupAlreadyComplete} from \\\"./KekotronErrors.sol\\\";\\n\\n/**\\n * ........            \\n *        ..::::::::::::.  .       \\n *      .:::::::::::::::.  =+-.    \\n *    --::::::::::::::::.  =+++-   \\n *    ##*+::::::::::::::.  =+++++\\n *   #####:  .::::::::::.  =++++++\\n * -######:     .:::::::.  =++++++-\\n *  ######:  :.    .::::.  =+++++++\\n * #######:  -=-:.    .:.  =+++++++\\n * +######:  -=====:.      =++++++=\\n * :######:  -========-.   =++++++:\\n *  +#####:  -===========-.-+++++= \\n *   =####:  -==============-==+-  \\n *    :*##:  -================-.   \\n *      :+:  -==============-.     \\n *           :==========-:.        \\n *              ......\\n */\\n\\ncontract KekotronRouterInitializer is Owned {\\n    event Setup(\\n        address receiver, \\n        address wrappedNative, \\n        ProtocolData[] protocolData\\n    );\\n\\n    address private receiver;\\n    address private wrappedNative;\\n    ProtocolData[] private protocolData;\\n\\n    constructor(address owner_) Owned(owner_) {}\\n\\n    function setup(\\n        address receiver_,\\n        address wrappedNative_,\\n        ProtocolData[] calldata protocolData_\\n    ) external onlyOwner {\\n        if (protocolData.length > 0) {\\n            revert SetupAlreadyComplete();\\n        }\\n        receiver = receiver_;\\n        wrappedNative = wrappedNative_;\\n\\n        uint256 protocolLen = protocolData_.length;\\n\\n        for (uint256 i = 0; i < protocolLen;) {\\n            protocolData.push(protocolData_[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        \\n        emit Setup(receiver_, wrappedNative_, protocolData_);\\n    }\\n\\n    function getWrappedNative() external view returns (address) {\\n        return wrappedNative;\\n    }\\n\\n    function getProtocolData() external view returns (ProtocolData[] memory) {\\n        return protocolData;\\n    }\\n\\n    function getReceiver() external view returns (address) {\\n        return receiver;\\n    }\\n\\n    function getSetupData() external view returns (address, address, ProtocolData[] memory) {\\n        return (receiver, wrappedNative, protocolData);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPoolTraderJoeV2_1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IPoolTraderJoeV2_1 {\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1);\\n    function swap(bool zeroForOne, address to) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IAlgebraFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/**\\n * @title The interface for the Algebra Factory\\n * @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\n * https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\n */\\ninterface IAlgebraFactory {\\n    /**\\n     *  @notice Emitted when the owner of the factory is changed\\n     *  @param newOwner The owner after the owner was changed\\n     */\\n    event Owner(address indexed newOwner);\\n\\n    /**\\n     *  @notice Emitted when the vault address is changed\\n     *  @param newVaultAddress The vault address after the address was changed\\n     */\\n    event VaultAddress(address indexed newVaultAddress);\\n\\n    /**\\n     *  @notice Emitted when a pool is created\\n     *  @param token0 The first token of the pool by address sort order\\n     *  @param token1 The second token of the pool by address sort order\\n     *  @param pool The address of the created pool\\n     */\\n    event Pool(address indexed token0, address indexed token1, address pool);\\n\\n    /**\\n     *  @notice Emitted when the farming address is changed\\n     *  @param newFarmingAddress The farming address after the address was changed\\n     */\\n    event FarmingAddress(address indexed newFarmingAddress);\\n\\n    event FeeConfiguration(\\n        uint16 alpha1,\\n        uint16 alpha2,\\n        uint32 beta1,\\n        uint32 beta2,\\n        uint16 gamma1,\\n        uint16 gamma2,\\n        uint32 volumeBeta,\\n        uint16 volumeGamma,\\n        uint16 baseFee\\n    );\\n\\n    /**\\n     *  @notice Returns the current owner of the factory\\n     *  @dev Can be changed by the current owner via setOwner\\n     *  @return The address of the factory owner\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     *  @notice Returns the current poolDeployerAddress\\n     *  @return The address of the poolDeployer\\n     */\\n    function poolDeployer() external view returns (address);\\n\\n    /**\\n     * @dev Is retrieved from the pools to restrict calling\\n     * certain functions not by a tokenomics contract\\n     * @return The tokenomics contract address\\n     */\\n    function farmingAddress() external view returns (address);\\n\\n    function vaultAddress() external view returns (address);\\n\\n    /**\\n     *  @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\\n     *  @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\\n     *  @param tokenA The contract address of either token0 or token1\\n     *  @param tokenB The contract address of the other token\\n     *  @return pool The pool address\\n     */\\n    function poolByPair(address tokenA, address tokenB) external view returns (address pool);\\n\\n    /**\\n     *  @notice Creates a pool for the given two tokens and fee\\n     *  @param tokenA One of the two tokens in the desired pool\\n     *  @param tokenB The other of the two tokens in the desired pool\\n     *  @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\\n     *  from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\\n     *  are invalid.\\n     *  @return pool The address of the newly created pool\\n     */\\n    function createPool(address tokenA, address tokenB) external returns (address pool);\\n\\n    /**\\n     *  @notice Updates the owner of the factory\\n     *  @dev Must be called by the current owner\\n     *  @param _owner The new owner of the factory\\n     */\\n    function setOwner(address _owner) external;\\n\\n    /**\\n     * @dev updates tokenomics address on the factory\\n     * @param _farmingAddress The new tokenomics contract address\\n     */\\n    function setFarmingAddress(address _farmingAddress) external;\\n\\n    /**\\n     * @dev updates vault address on the factory\\n     * @param _vaultAddress The new vault contract address\\n     */\\n    function setVaultAddress(address _vaultAddress) external;\\n\\n    /**\\n     * @notice Changes initial fee configuration for new pools\\n     * @dev changes coefficients for sigmoids: \u03b1 / (1 + e^( (\u03b2-x) / \u03b3))\\n     * alpha1 + alpha2 + baseFee (max possible fee) must be <= type(uint16).max\\n     * gammas must be > 0\\n     * @param alpha1 max value of the first sigmoid\\n     * @param alpha2 max value of the second sigmoid\\n     * @param beta1 shift along the x-axis for the first sigmoid\\n     * @param beta2 shift along the x-axis for the second sigmoid\\n     * @param gamma1 horizontal stretch factor for the first sigmoid\\n     * @param gamma2 horizontal stretch factor for the second sigmoid\\n     * @param volumeBeta shift along the x-axis for the outer volume-sigmoid\\n     * @param volumeGamma horizontal stretch factor the outer volume-sigmoid\\n     * @param baseFee minimum possible fee\\n     */\\n    function setBaseFeeConfiguration(\\n        uint16 alpha1,\\n        uint16 alpha2,\\n        uint32 beta1,\\n        uint32 beta2,\\n        uint16 gamma1,\\n        uint16 gamma2,\\n        uint32 volumeBeta,\\n        uint16 volumeGamma,\\n        uint16 baseFee\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPoolV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IPoolV3 {\\n    function fee() external view returns (uint24);\\n    function swap(\\n        address recipient,\\n        bool zeroForOne,\\n        int256 amountSpecified,\\n        uint160 sqrtPriceLimitX96,\\n        bytes calldata data\\n    ) external returns (int256 amount0, int256 amount1);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function withdraw(uint256 amount) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"foundry-huff/=lib/foundry-huff/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"lib/forge-std:ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/solady:ds-test/=lib/solady/lib/ds-test/src/\",\r\n      \"lib/solady:forge-std/=lib/solady/test/utils/forge-std/\",\r\n      \"lib/solmate:ds-test/=lib/solmate/lib/ds-test/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 40000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InsufficientInputAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientLiquidity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCallbackPool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInputAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidVersion\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NativeTransfer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProtocolDataAlreadySet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProtocolNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenInCannotBeSameAsTokenOut\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenMustBeContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenTransfer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenTransferFrom\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooLittleReceived\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrappedNativeCurrencyDeposit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrappedNativeCurrencyWithdraw\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"AllowedV2CallbackUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"AllowedV3CallbackUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeReceiver\",\"type\":\"address\"}],\"name\":\"FeeReceiverUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"fee\",\"type\":\"uint8\"}],\"name\":\"FeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"protocol\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"feeInHash\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"externalDeployer\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"initHash\",\"type\":\"bytes32\"}],\"indexed\":false,\"internalType\":\"struct ProtocolData\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"ProtocolDataUpdated\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"allowedV2Callbacks\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"allowedV3Callbacks\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"name\":\"getProtocolNumber\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"protocol\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"updateAllowedV2Callbacks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newFee\",\"type\":\"uint8\"}],\"name\":\"updateFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeReceiver\",\"type\":\"address\"}],\"name\":\"updateFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"protocol\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"feeInHash\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"externalDeployer\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"initHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct ProtocolData\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"updateProtocolData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"updatedAllowedV3Callbacks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawNative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "KekotronRouterV2", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "40000", "ConstructorArguments": "000000000000000000000000ae010a324281de301d1bfb2611ef8873d8843622", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}