{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/Platform/Market/Auction/SingleTokenAuction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\r\\nimport {IMetaUnitTracker} from \\\"../../MetaUnit/Tracker/IMetaUnitTracker.sol\\\";\\r\\nimport {Pausable} from \\\"../../../Pausable.sol\\\";\\r\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\nimport {IERC2981} from \\\"@openzeppelin/contracts/interfaces/IERC2981.sol\\\";\\r\\nimport {IFeeStorage} from \\\"../../Collections/interfaces/IFeeStorage.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * @author MetaPlayerOne DAO\\r\\n * @title SingleTokenAuction\\r\\n */\\r\\ncontract SingleTokenAuction is Pausable, ReentrancyGuard {\\r\\n    struct Item { uint256 uid; address token_address; uint256 token_id; address owner_of; address curator_address; uint256 curator_fee; uint256 start_price; bool approved; uint256 highest_bid; address highest_bidder; uint256 end_time; uint256 duration; }\\r\\n\\r\\n    Item[] private _items;\\r\\n    mapping(address => mapping(uint256 => mapping(address => bool))) private _active_items;\\r\\n    mapping(address => uint256) availableClaim;\\r\\n    mapping(uint256 => bool) private _finished;\\r\\n\\r\\n    address private immutable _meta_unit_tracker_address;\\r\\n    address private immutable _creator_fee_storage;\\r\\n  \\r\\n    constructor(address owner_of_, address meta_unit_tracker_address_, address creator_fee_storage_) Pausable(owner_of_) {\\r\\n        _meta_unit_tracker_address = meta_unit_tracker_address_;\\r\\n        _creator_fee_storage = creator_fee_storage_;\\r\\n    }\\r\\n   \\r\\n    event itemAdded(uint256 uid, address token_address, uint256 token_id, address owner_of, address curator_address, uint256 curator_fee, uint256 start_price, bool approved, uint256 highest_bid, address highest_bidder,uint256 end_time);\\r\\n    event auctionApproved(uint256 uid, uint256 end_time);\\r\\n    event bidAdded(uint256 uid, uint256 highest_bid, address highest_bidder);\\r\\n    event itemResolved(uint256 uid);\\r\\n\\r\\n    function sale(address token_address, uint256 token_id, address curator_address, uint256 curator_fee, uint256 start_price, uint256 duration) public notPaused nonReentrant {\\r\\n        require(curator_address != address(0), \\\"Curator address should not be 0x0\\\");\\r\\n        require(curator_fee <= 200, \\\"\\\");\\r\\n        require(IERC721(token_address).ownerOf(token_id) == msg.sender, \\\"You are not an owner\\\");\\r\\n        require(IERC721(token_address).getApproved(token_id) == address(this), \\\"Token is not approved to contract\\\");\\r\\n        require(!_active_items[token_address][token_id][msg.sender], \\\"Item is already on sale\\\");\\r\\n        uint256 newItemId = _items.length;\\r\\n        _items.push(Item(newItemId, token_address, token_id, msg.sender, curator_address, curator_fee, start_price, false, 0, address(0), 0, duration));\\r\\n        _active_items[token_address][token_id][msg.sender] = true;\\r\\n        emit itemAdded(newItemId, token_address, token_id, msg.sender, curator_address, curator_fee, start_price, false, 0, address(0), duration);\\r\\n        if (curator_address == msg.sender) {\\r\\n            setCuratorApproval(newItemId);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setCuratorApproval(uint256 uid) public notPaused {\\r\\n        require(uid < _items.length && _items[uid].uid == uid, \\\"Token does not exists\\\");\\r\\n        Item memory item = _items[uid];\\r\\n        require(!item.approved, \\\"Auction is already approved\\\");\\r\\n        require(item.curator_address == msg.sender, \\\"You are not curator\\\");\\r\\n        _items[uid].approved = true;\\r\\n        _items[uid].end_time = block.timestamp + item.duration;\\r\\n        emit auctionApproved(uid, _items[uid].end_time);\\r\\n    }\\r\\n\\r\\n    function bid(uint256 uid) public payable nonReentrant {\\r\\n        require(uid < _items.length && _items[uid].uid == uid, \\\"Order does not exists\\\");\\r\\n        Item memory item = _items[uid];\\r\\n        IERC721 token = IERC721(item.token_address);\\r\\n        require(block.timestamp <= item.end_time, \\\"Auction has been finished\\\");\\r\\n        require(token.getApproved(item.token_id) == address(this), \\\"Token is not approved to contract\\\");\\r\\n        require(token.ownerOf(item.token_id) == item.owner_of, \\\"Token is already sold\\\");\\r\\n        require(item.approved, \\\"Auction is not approved\\\");\\r\\n        require(msg.value > item.start_price, \\\"Bid is lower than start price\\\");\\r\\n        require(msg.value > item.highest_bid, \\\"Bid is lower than previous one\\\");\\r\\n        require(item.owner_of != msg.sender, \\\"You are an owner of this auction\\\");\\r\\n        require(item.curator_address != msg.sender, \\\"You are an curator of this auction\\\");\\r\\n        if (item.highest_bidder != address(0)) {\\r\\n            availableClaim[item.highest_bidder] += item.highest_bid;\\r\\n        }\\r\\n        _items[uid].highest_bid = msg.value;\\r\\n        _items[uid].highest_bidder = msg.sender;\\r\\n        emit bidAdded(uid, _items[uid].highest_bid, _items[uid].highest_bidder);\\r\\n    }\\r\\n\\r\\n    function claim() public nonReentrant {\\r\\n        uint256 credit = availableClaim[msg.sender];\\r\\n        require(credit > 0 && address(this).balance >= credit, \\\"Claim failed\\\");\\r\\n        availableClaim[msg.sender] = 0;\\r\\n        payable(msg.sender).transfer(credit);\\r\\n    }\\r\\n\\r\\n    function resolve(uint256 uid) public notPaused nonReentrant {\\r\\n        require(uid < _items.length && _items[uid].uid == uid, \\\"Order does not exists\\\");\\r\\n        Item memory item = _items[uid];\\r\\n        IERC721 token = IERC721(item.token_address);\\r\\n        require(block.timestamp >= item.end_time, \\\"Auction does not finish\\\");\\r\\n        require(item.curator_address == msg.sender, \\\"You are not curator\\\");\\r\\n        require(item.approved, \\\"Auction is not approved\\\");\\r\\n        require(token.getApproved(item.token_id) == address(this), \\\"Token is not approved to contract\\\");\\r\\n        require(!_finished[uid], \\\"Auction has been resolved\\\");\\r\\n        if (item.highest_bidder != address(0)) {\\r\\n            uint256 creator_fee_total = 0;\\r\\n            address royalty_fee_receiver = address(0);\\r\\n            uint256 royalty_fee = 0;\\r\\n            try IFeeStorage(_creator_fee_storage).feeInfo(item.token_address, item.highest_bid) returns (address[] memory creator_fee_receiver_, uint256[] memory creator_fee_, uint256 total_) {\\r\\n                for (uint256 i = 0; i < creator_fee_receiver_.length; i ++) {\\r\\n                    (bool sent_creator,) = payable(creator_fee_receiver_[i]).call{value: creator_fee_[i]}(\\\"\\\");\\r\\n                    require(sent_creator, \\\"Creator fee transfer failed\\\");\\r\\n                }\\r\\n                creator_fee_total = total_;\\r\\n            } catch {}\\r\\n            try IERC2981(item.token_address).royaltyInfo(item.token_id, item.highest_bid) returns (address royalty_fee_receiver_, uint256 royalty_fee_) {\\r\\n                royalty_fee_receiver = royalty_fee_receiver_;\\r\\n                royalty_fee = royalty_fee_;\\r\\n            } catch {}\\r\\n            uint256 project_fee = (item.highest_bid * 25) / 1000;\\r\\n            uint256 curator_fee = (item.highest_bid * item.curator_fee) / 1000;\\r\\n            if (royalty_fee_receiver != address(0)) {\\r\\n                (bool sent_royalty_fee,) = payable(royalty_fee_receiver).call{value: royalty_fee}(\\\"\\\");\\r\\n                require(sent_royalty_fee, \\\"Royalty fee transfer failed\\\");\\r\\n            }\\r\\n            (bool sent_project,) = payable(_owner_of).call{value: project_fee}(\\\"\\\");\\r\\n            (bool sent_curator,) = payable(item.curator_address).call{value: curator_fee}(\\\"\\\");\\r\\n            (bool sent_owner,) = payable(item.owner_of).call{value: (item.highest_bid - creator_fee_total - royalty_fee - project_fee - curator_fee)}(\\\"\\\");\\r\\n            require(sent_project && sent_curator && sent_owner, \\\"Rewards transfer failed\\\");\\r\\n            IMetaUnitTracker(_meta_unit_tracker_address).track(item.owner_of, item.highest_bid);\\r\\n            IERC721(item.token_address).safeTransferFrom(item.owner_of, item.highest_bidder, item.token_id);\\r\\n        }\\r\\n        _finished[uid] = true;\\r\\n        _active_items[item.token_address][item.token_id][item.owner_of] = false;\\r\\n        emit itemResolved(uid);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/Platform/MetaUnit/Tracker/IMetaUnitTracker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IMetaUnitTracker {\\r\\n    struct Transaction { address owner_of; uint256 value; uint256 timestamp; }\\r\\n\\r\\n    function track(address eth_address_, uint256 value_) external;\\r\\n    function getUserResalesSum(address eth_address_) external view returns(uint256);\\r\\n    function getUserTransactionQuantity(address eth_address_) external view returns(uint256);\\r\\n    function getTransactions() external view returns (Transaction[] memory);\\r\\n    function getTransactionsForPeriod(uint256 from_, uint256 to_) external view returns (address[] memory, uint256[] memory);\\r\\n}\"\r\n    },\r\n    \"/contracts/Platform/Collections/interfaces/IFeeStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IFeeStorage {\\r\\n    function feeInfo(address token_address, uint256 salePrice) external view returns (address[] memory, uint256[] memory, uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @author MetaPlayerOne DAO\\r\\n * @title Pausable\\r\\n */\\r\\ncontract Pausable {\\r\\n    address internal _owner_of;\\r\\n    bool internal _paused = false;\\r\\n\\r\\n    /**\\r\\n     * @dev setup owner of this contract with paused off state.\\r\\n     */\\r\\n    constructor(address owner_of_) {\\r\\n        _owner_of = owner_of_;\\r\\n        _paused = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev modifier which can be used on child contract for checking if contract services are paused.\\r\\n     */\\r\\n    modifier notPaused() {\\r\\n        require(!_paused, \\\"Contract is paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev function which setup paused variable.\\r\\n     * @param paused_ new boolean value of paused condition.\\r\\n     */\\r\\n    function setPaused(bool paused_) external {\\r\\n        require(_paused != paused_, \\\"Param has been asigned already\\\");\\r\\n        require(_owner_of == msg.sender, \\\"Permission address\\\");\\r\\n        _paused = paused_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev function which setup owner variable.\\r\\n     * @param owner_of_ new owner of contract.\\r\\n     */\\r\\n    function setOwner(address owner_of_) external {\\r\\n        require(_owner_of == msg.sender, \\\"Permission address\\\");\\r\\n        _owner_of = owner_of_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev function returns owner of contract.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner_of;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(\\n        uint256 tokenId,\\n        uint256 salePrice\\n    ) external view returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_of_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"meta_unit_tracker_address_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creator_fee_storage_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end_time\",\"type\":\"uint256\"}],\"name\":\"auctionApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"highest_bid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"highest_bidder\",\"type\":\"address\"}],\"name\":\"bidAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"token_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner_of\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"curator_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"curator_fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start_price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"highest_bid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"highest_bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end_time\",\"type\":\"uint256\"}],\"name\":\"itemAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"}],\"name\":\"itemResolved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"}],\"name\":\"resolve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"token_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"curator_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"curator_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"sale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"}],\"name\":\"setCuratorApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_of_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"paused_\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SingleTokenAuction", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008e66691515badbaca6ee686d74c8ef29e1afe57f0000000000000000000000003adf09d2d5292adc2874b2c867fecbb3b0b0b174000000000000000000000000de38a0ea6308793ec1deaaf1daa2a9fe56e11c66", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}