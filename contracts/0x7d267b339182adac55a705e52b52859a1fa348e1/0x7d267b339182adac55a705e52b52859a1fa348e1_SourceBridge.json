{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/bridge/SourceBridge.sol\": {\r\n      \"content\": \"/**SPDX-License-Identifier: BUSL-1.1\\n\\n      \u2584\u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\\n   \u2553\u2588\u2588\u2580\u2514 ,\u2553\u2584\u2584\u2584, '\u2580\u2588\u2588\u2584\\n  \u2588\u2588\u2580 \u2584\u2588\u2588\u2580\u2580\u2559\u2559\u2580\u2580\u2588\u2588\u2584 \u2514\u2588\u2588\u00b5           ,,       ,,      ,     ,,,            ,,,\\n \u2588\u2588 ,\u2588\u2588\u00ac \u2584\u2588\u2588\u2588\u2588\u2584  \u2580\u2588\u2584 \u2559\u2588\u2584      \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2584   \u2588\u2588\u2588\u2584    \u2588\u2588  \u2588\u2588\u2588\u2580\u2580\u2580\u2588\u2588\u2588\u2584    \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588,\\n\u2588\u2588  \u2588\u2588 \u2552\u2588\u2580'   \u2559\u2588\u258c \u2559\u2588\u258c \u2588\u2588     \u2590\u2588\u2588      \u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588,  \u2588\u2588  \u2588\u2588\u258c    \u2514\u2588\u2588\u258c  \u2588\u2588\u258c     \u2514\u2588\u2588\u258c\\n\u2588\u2588 \u2590\u2588\u258c \u2588\u2588      \u255f\u2588  \u2588\u258c \u255f\u2588     \u2588\u2588\u258c      \u2590\u2588\u2588  \u2588\u2588 \u2514\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u258c     \u255f\u2588\u2588 j\u2588\u2588       \u255f\u2588\u2588\\n\u255f\u2588  \u2588\u2588 \u2559\u2588\u2588    \u2584\u2588\u2580 \u2590\u2588\u258c \u2588\u2588     \u2559\u2588\u2588      \u2588\u2588\u258c  \u2588\u2588   \u2559\u2588\u2588\u2588\u2588  \u2588\u2588\u258c    \u2584\u2588\u2588\u2580  \u2588\u2588\u258c     ,\u2588\u2588\u2580\\n \u2588\u2588 \\\"\u2588\u2588, \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2310      \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580   \u2588\u2588     \u2559\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580     \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580`\\n  \u2588\u2588\u2584 \u2559\u2580\u2588\u2588\u2584\u2584\u2584\u2584\u2584,,,                \u00ac\u2500                                    '\u2500\u00ac\\n   \u2559\u2580\u2588\u2588\u2584 '\u2559\u2559\u2559\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\\n      \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588R\u2310\\n\\n */\\npragma solidity 0.8.16;\\n\\nimport \\\"contracts/interfaces/IAxelarGateway.sol\\\";\\nimport \\\"contracts/interfaces/IAxelarGasService.sol\\\";\\nimport \\\"contracts/interfaces/IMulticall.sol\\\";\\nimport \\\"contracts/interfaces/IRWALike.sol\\\";\\nimport {AddressToString} from \\\"contracts/external/axelar/StringAddressUtils.sol\\\";\\nimport \\\"contracts/external/openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"contracts/external/openzeppelin/contracts/security/Pausable.sol\\\";\\n\\ncontract SourceBridge is Ownable, Pausable, IMulticall {\\n  /// @notice Mapping from destination chain to bridge address on that chain\\n  /// @dev Axelar uses the string representation of addresses, hence we store\\n  ///      the address as a string\\n  mapping(string => string) public destChainToContractAddr;\\n\\n  /// @notice Token contract bridged by this contract\\n  IRWALike public immutable TOKEN;\\n\\n  /// @notice Pointer  to AxelarGateway contract\\n  IAxelarGateway public immutable AXELAR_GATEWAY;\\n\\n  /// @notice Pointer to AxelarGasService contract\\n  IAxelarGasService public immutable GAS_RECEIVER;\\n\\n  /// @notice Versioning for payload\\n  bytes32 public constant VERSION = \\\"1.0\\\";\\n\\n  /// @notice Monotonically increasing nonce for each transaction\\n  uint256 public nonce;\\n\\n  /// @notice src Chain Id, used to salt txnHash on dst Chain\\n  uint256 public immutable CHAIN_ID;\\n\\n  /**\\n   * @notice Constructor\\n   *\\n   * @param _token The address of the token bridged\\n   * @param _axelarGateway The address of the AxelarGateway contract\\n   * @param _gasService The address of the AxelarGasService contract\\n   * @param owner The owner of the contract\\n   */\\n  constructor(\\n    address _token,\\n    address _axelarGateway,\\n    address _gasService,\\n    address owner\\n  ) {\\n    TOKEN = IRWALike(_token);\\n    AXELAR_GATEWAY = IAxelarGateway(_axelarGateway);\\n    GAS_RECEIVER = IAxelarGasService(_gasService);\\n    _transferOwnership(owner);\\n    CHAIN_ID = block.chainid;\\n  }\\n\\n  /**\\n   * @notice Burns tokens on the source Chain and calls AxelarGateway contract\\n   *         to mint tokens on the destination chain\\n   *\\n   * @param amount The amount of tokens to burn\\n   * @param destinationChain The destination chain to mint tokens on\\n   *\\n   * @dev The amount of tokens to mint is the same as the amount burned\\n   * @dev User must approve `amount` tokens to this contract before bridging\\n   */\\n  function burnAndCallAxelar(\\n    uint256 amount,\\n    string calldata destinationChain\\n  ) external payable whenNotPaused {\\n    // Ensure that some gas is sent\\n    if (msg.value == 0) {\\n      revert GasFeeTooLow();\\n    }\\n\\n    // Ensure that amount bridged is not zero\\n    if (amount == 0) {\\n      revert CannotBridgeZero();\\n    }\\n\\n    // Check destinationChain is correct\\n    string memory destContract = destChainToContractAddr[destinationChain];\\n\\n    if (bytes(destContract).length == 0) {\\n      revert DestinationNotSupported();\\n    }\\n\\n    // burn amount\\n    TOKEN.burnFrom(msg.sender, amount);\\n\\n    bytes memory payload = abi.encode(\\n      VERSION,\\n      CHAIN_ID,\\n      msg.sender,\\n      amount,\\n      nonce++\\n    );\\n\\n    _payGasAndCallContract(destinationChain, destContract, payload);\\n    emit BridgeInitiated(msg.sender, nonce - 1, CHAIN_ID, VERSION, amount);\\n  }\\n\\n  /**\\n   * @notice Helper function that pays gas and calls the AxelarGateway contract\\n   *\\n   * @param destinationChain The destination chain to mint tokens on\\n   * @param destContract The contract address on the destination chain\\n   * @param payload The payload to send to the AxelarGateway contract\\n   */\\n  function _payGasAndCallContract(\\n    string calldata destinationChain,\\n    string memory destContract,\\n    bytes memory payload\\n  ) private {\\n    GAS_RECEIVER.payNativeGasForContractCall{value: msg.value}(\\n      address(this),\\n      destinationChain,\\n      destContract,\\n      payload,\\n      msg.sender\\n    );\\n\\n    // Send all information to AxelarGateway contract.\\n    AXELAR_GATEWAY.callContract(destinationChain, destContract, payload);\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                          Admin Functions\\n  //////////////////////////////////////////////////////////////*/\\n\\n  /**\\n   * @notice Sets the destination chain to contract address mapping\\n   *\\n   * @param destinationChain The destination chain\\n   * @param contractAddress The contract address on the destination chain\\n   *\\n   * @dev Chain name must come from list of supported chains\\n   *      at https://docs.axelar.dev/dev/reference/mainnet-chain-names\\n   */\\n  function setDestinationChainContractAddress(\\n    string calldata destinationChain,\\n    address contractAddress\\n  ) external onlyOwner {\\n    destChainToContractAddr[destinationChain] = AddressToString.toString(\\n      contractAddress\\n    );\\n    emit DestinationChainContractAddressSet(destinationChain, contractAddress);\\n  }\\n\\n  /**\\n   * @notice Deletes an entry w/n the destination chain to contract address\\n   *         mapping\\n   *\\n   * @param destinationChain The destination chain to disallow\\n   */\\n  function removeDestinationChainContractAddress(\\n    string calldata destinationChain\\n  ) external onlyOwner {\\n    delete destChainToContractAddr[destinationChain];\\n    emit ChainSupportRemoved(destinationChain);\\n  }\\n\\n  /**\\n   * @notice Admin function to pause the contract\\n   *\\n   * @dev Only used for bridge functions\\n   */\\n  function pause() external onlyOwner {\\n    _pause();\\n  }\\n\\n  /**\\n   * @notice Admin function to unpause the contract\\n   *\\n   * @dev Only used for bridge functions\\n   */\\n  function unpause() external onlyOwner {\\n    _unpause();\\n  }\\n\\n  /**\\n   * @notice Allows for arbitrary batched calls\\n   *\\n   * @dev All external calls made through this function will\\n   *      msg.sender == contract address\\n   *\\n   * @param exCallData Struct consisting of\\n   *       1) target - contract to call\\n   *       2) data - data to call target with\\n   *       3) value - eth value to call target with\\n   */\\n  function multiexcall(\\n    ExCallData[] calldata exCallData\\n  ) external payable override onlyOwner returns (bytes[] memory results) {\\n    results = new bytes[](exCallData.length);\\n    for (uint256 i = 0; i < exCallData.length; ++i) {\\n      (bool success, bytes memory ret) = address(exCallData[i].target).call{\\n        value: exCallData[i].value\\n      }(exCallData[i].data);\\n      require(success, \\\"Call Failed\\\");\\n      results[i] = ret;\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                           Events & Errors\\n  //////////////////////////////////////////////////////////////*/\\n\\n  /**\\n   * @notice Event emitted when the destination chain to contract address mapping is set\\n   *\\n   * @param destinationChain The destination chain\\n   * @param contractAddress The contract address on the destination chain\\n   */\\n  event DestinationChainContractAddressSet(\\n    string indexed destinationChain,\\n    address contractAddress\\n  );\\n\\n  /**\\n   * @notice Event emitted when a message is passed to an Axelar gateway\\n   *\\n   * @param user    The account initiating the msg pass\\n   * @param nonce   The nonce of the src bridge for this msg pass\\n   * @param chainId The chainId of the chain which the src bridge is deployed to\\n   * @param version The payload version\\n   * @param amount  The amount field in the msg being passed\\n   */\\n  event BridgeInitiated(\\n    address indexed user,\\n    uint256 indexed nonce,\\n    uint256 indexed chainId,\\n    bytes32 version,\\n    uint256 amount\\n  );\\n  /**\\n   * @notice Event emitted when the destination chain to contract address mapping is\\n   *         deleted\\n   *\\n   * @param destinationChain The destination chain to be removed;\\n   */\\n  event ChainSupportRemoved(string indexed destinationChain);\\n\\n  // Errors\\n  error DestinationNotSupported();\\n  error GasFeeTooLow();\\n  error CannotBridgeZero();\\n}\\n\"\r\n    },\r\n    \"contracts/external/axelar/StringAddressUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary StringToAddress {\\n  error InvalidAddressString();\\n\\n  function toAddress(\\n    string memory addressString\\n  ) internal pure returns (address) {\\n    bytes memory stringBytes = bytes(addressString);\\n    uint160 addressNumber = 0;\\n    uint8 stringByte;\\n\\n    if (\\n      stringBytes.length != 42 || stringBytes[0] != \\\"0\\\" || stringBytes[1] != \\\"x\\\"\\n    ) revert InvalidAddressString();\\n\\n    for (uint256 i = 2; i < 42; ++i) {\\n      stringByte = uint8(stringBytes[i]);\\n\\n      if ((stringByte >= 97) && (stringByte <= 102)) stringByte -= 87;\\n      else if ((stringByte >= 65) && (stringByte <= 70)) stringByte -= 55;\\n      else if ((stringByte >= 48) && (stringByte <= 57)) stringByte -= 48;\\n      else revert InvalidAddressString();\\n\\n      addressNumber |= uint160(uint256(stringByte) << ((41 - i) << 2));\\n    }\\n    return address(addressNumber);\\n  }\\n}\\n\\nlibrary AddressToString {\\n  function toString(address addr) internal pure returns (string memory) {\\n    bytes memory addressBytes = abi.encodePacked(addr);\\n    uint256 length = addressBytes.length;\\n    bytes memory characters = \\\"0123456789abcdef\\\";\\n    bytes memory stringBytes = new bytes(2 + addressBytes.length * 2);\\n\\n    stringBytes[0] = \\\"0\\\";\\n    stringBytes[1] = \\\"x\\\";\\n\\n    for (uint256 i; i < length; ++i) {\\n      stringBytes[2 + i * 2] = characters[uint8(addressBytes[i] >> 4)];\\n      stringBytes[3 + i * 2] = characters[uint8(addressBytes[i] & 0x0f)];\\n    }\\n    return string(stringBytes);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/external/openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"contracts/external/openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  constructor() {\\n    _transferOwnership(_msgSender());\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view virtual returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby removing any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    _transferOwnership(address(0));\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n    _transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Internal function without access restriction.\\n   */\\n  function _transferOwnership(address newOwner) internal virtual {\\n    address oldOwner = _owner;\\n    _owner = newOwner;\\n    emit OwnershipTransferred(oldOwner, newOwner);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/external/openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"contracts/external/openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n  /**\\n   * @dev Emitted when the pause is triggered by `account`.\\n   */\\n  event Paused(address account);\\n\\n  /**\\n   * @dev Emitted when the pause is lifted by `account`.\\n   */\\n  event Unpaused(address account);\\n\\n  bool private _paused;\\n\\n  /**\\n   * @dev Initializes the contract in unpaused state.\\n   */\\n  constructor() {\\n    _paused = false;\\n  }\\n\\n  /**\\n   * @dev Returns true if the contract is paused, and false otherwise.\\n   */\\n  function paused() public view virtual returns (bool) {\\n    return _paused;\\n  }\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is not paused.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must not be paused.\\n   */\\n  modifier whenNotPaused() {\\n    require(!paused(), \\\"Pausable: paused\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is paused.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must be paused.\\n   */\\n  modifier whenPaused() {\\n    require(paused(), \\\"Pausable: not paused\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Triggers stopped state.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must not be paused.\\n   */\\n  function _pause() internal virtual whenNotPaused {\\n    _paused = true;\\n    emit Paused(_msgSender());\\n  }\\n\\n  /**\\n   * @dev Returns to normal state.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must be paused.\\n   */\\n  function _unpause() internal virtual whenPaused {\\n    _paused = false;\\n    emit Unpaused(_msgSender());\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/external/openzeppelin/contracts/token/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `to`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address to, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `from` to `to` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/external/openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    return msg.data;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAxelarGasService.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// This should be owned by the microservice that is paying for gas.\\ninterface IAxelarGasService {\\n  // This is called on the source chain before calling the gateway to execute a remote contract.\\n  function payNativeGasForContractCall(\\n    address sender,\\n    string calldata destinationChain,\\n    string calldata destinationAddress,\\n    bytes calldata payload,\\n    address refundAddress\\n  ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAxelarGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IAxelarGateway {\\n  function callContract(\\n    string calldata destinationChain,\\n    string calldata contractAddress,\\n    bytes calldata payload\\n  ) external;\\n\\n  function validateContractCall(\\n    bytes32 commandId,\\n    string calldata sourceChain,\\n    string calldata sourceAddress,\\n    bytes32 payloadHash\\n  ) external returns (bool);\\n\\n  function validateContractCallAndMint(\\n    bytes32 commandId,\\n    string calldata sourceChain,\\n    string calldata sourceAddress,\\n    bytes32 payloadHash,\\n    string calldata symbol,\\n    uint256 amount\\n  ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMulticall.sol\": {\r\n      \"content\": \"/**SPDX-License-Identifier: BUSL-1.1\\n\\n      \u2584\u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\\n   \u2553\u2588\u2588\u2580\u2514 ,\u2553\u2584\u2584\u2584, '\u2580\u2588\u2588\u2584\\n  \u2588\u2588\u2580 \u2584\u2588\u2588\u2580\u2580\u2559\u2559\u2580\u2580\u2588\u2588\u2584 \u2514\u2588\u2588\u00b5           ,,       ,,      ,     ,,,            ,,,\\n \u2588\u2588 ,\u2588\u2588\u00ac \u2584\u2588\u2588\u2588\u2588\u2584  \u2580\u2588\u2584 \u2559\u2588\u2584      \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2584   \u2588\u2588\u2588\u2584    \u2588\u2588  \u2588\u2588\u2588\u2580\u2580\u2580\u2588\u2588\u2588\u2584    \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588,\\n\u2588\u2588  \u2588\u2588 \u2552\u2588\u2580'   \u2559\u2588\u258c \u2559\u2588\u258c \u2588\u2588     \u2590\u2588\u2588      \u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588,  \u2588\u2588  \u2588\u2588\u258c    \u2514\u2588\u2588\u258c  \u2588\u2588\u258c     \u2514\u2588\u2588\u258c\\n\u2588\u2588 \u2590\u2588\u258c \u2588\u2588      \u255f\u2588  \u2588\u258c \u255f\u2588     \u2588\u2588\u258c      \u2590\u2588\u2588  \u2588\u2588 \u2514\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u258c     \u255f\u2588\u2588 j\u2588\u2588       \u255f\u2588\u2588\\n\u255f\u2588  \u2588\u2588 \u2559\u2588\u2588    \u2584\u2588\u2580 \u2590\u2588\u258c \u2588\u2588     \u2559\u2588\u2588      \u2588\u2588\u258c  \u2588\u2588   \u2559\u2588\u2588\u2588\u2588  \u2588\u2588\u258c    \u2584\u2588\u2588\u2580  \u2588\u2588\u258c     ,\u2588\u2588\u2580\\n \u2588\u2588 \\\"\u2588\u2588, \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2310      \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580   \u2588\u2588     \u2559\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580     \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580`\\n  \u2588\u2588\u2584 \u2559\u2580\u2588\u2588\u2584\u2584\u2584\u2584\u2584,,,                \u00ac\u2500                                    '\u2500\u00ac\\n   \u2559\u2580\u2588\u2588\u2584 '\u2559\u2559\u2559\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\\n      \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588R\u2310\\n\\n */\\npragma solidity 0.8.16;\\n\\n/**\\n * @title IMulticall\\n * @author Ondo Finance\\n * @notice This interface dictates the required external functions for Ondo's\\n *         multicall contract.\\n */\\ninterface IMulticall {\\n  /// @dev External call data structure\\n  struct ExCallData {\\n    // The contract we intend to call\\n    address target;\\n    // The encoded function data for the call\\n    bytes data;\\n    // The ether value to be sent in the call\\n    uint256 value;\\n  }\\n\\n  /**\\n   * @notice Batches multiple function calls to different target contracts\\n   *         and returns the resulting data provided all calls were successful\\n   *\\n   * @dev The `msg.sender` is always the contract from which this function\\n   *      is being called\\n   *\\n   * @param exdata The ExCallData struct array containing the information\\n   *               regarding which contract to call, what data to call with,\\n   *               and what ether value to send along with the call\\n   *\\n   * @return results The resulting data returned from each call made\\n   */\\n  function multiexcall(\\n    ExCallData[] calldata exdata\\n  ) external payable returns (bytes[] memory results);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRWALike.sol\": {\r\n      \"content\": \"/**SPDX-License-Identifier: BUSL-1.1\\n\\n      \u2584\u2584\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2584\\n   \u2553\u2588\u2588\u2580\u2514 ,\u2553\u2584\u2584\u2584, '\u2580\u2588\u2588\u2584\\n  \u2588\u2588\u2580 \u2584\u2588\u2588\u2580\u2580\u2559\u2559\u2580\u2580\u2588\u2588\u2584 \u2514\u2588\u2588\u00b5           ,,       ,,      ,     ,,,            ,,,\\n \u2588\u2588 ,\u2588\u2588\u00ac \u2584\u2588\u2588\u2588\u2588\u2584  \u2580\u2588\u2584 \u2559\u2588\u2584      \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\u2584   \u2588\u2588\u2588\u2584    \u2588\u2588  \u2588\u2588\u2588\u2580\u2580\u2580\u2588\u2588\u2588\u2584    \u2584\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588,\\n\u2588\u2588  \u2588\u2588 \u2552\u2588\u2580'   \u2559\u2588\u258c \u2559\u2588\u258c \u2588\u2588     \u2590\u2588\u2588      \u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588,  \u2588\u2588  \u2588\u2588\u258c    \u2514\u2588\u2588\u258c  \u2588\u2588\u258c     \u2514\u2588\u2588\u258c\\n\u2588\u2588 \u2590\u2588\u258c \u2588\u2588      \u255f\u2588  \u2588\u258c \u255f\u2588     \u2588\u2588\u258c      \u2590\u2588\u2588  \u2588\u2588 \u2514\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u258c     \u255f\u2588\u2588 j\u2588\u2588       \u255f\u2588\u2588\\n\u255f\u2588  \u2588\u2588 \u2559\u2588\u2588    \u2584\u2588\u2580 \u2590\u2588\u258c \u2588\u2588     \u2559\u2588\u2588      \u2588\u2588\u258c  \u2588\u2588   \u2559\u2588\u2588\u2588\u2588  \u2588\u2588\u258c    \u2584\u2588\u2588\u2580  \u2588\u2588\u258c     ,\u2588\u2588\u2580\\n \u2588\u2588 \\\"\u2588\u2588, \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2310      \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580   \u2588\u2588     \u2559\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580\u2580     \u2559\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2580`\\n  \u2588\u2588\u2584 \u2559\u2580\u2588\u2588\u2584\u2584\u2584\u2584\u2584,,,                \u00ac\u2500                                    '\u2500\u00ac\\n   \u2559\u2580\u2588\u2588\u2584 '\u2559\u2559\u2559\u2580\u2580\u2580\u2580\u2580\u2580\u2580\u2580\\n      \u2559\u2580\u2580\u2588\u2588\u2588\u2588\u2588\u2588R\u2310\\n */\\npragma solidity 0.8.16;\\n\\n// This interface is not inherited directly by RWA, instead, it is a\\n// subset of functions provided by all RWA tokens that the RWA Hub\\n// Client uses.\\nimport \\\"contracts/external/openzeppelin/contracts/token/IERC20.sol\\\";\\n\\ninterface IRWALike is IERC20 {\\n  function mint(address to, uint256 amount) external;\\n\\n  function burn(uint256 amount) external;\\n\\n  function burnFrom(address from, uint256 amount) external;\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_axelarGateway\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gasService\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CannotBridgeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DestinationNotSupported\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GasFeeTooLow\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"version\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BridgeInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"destinationChain\",\"type\":\"string\"}],\"name\":\"ChainSupportRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"destinationChain\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"DestinationChainContractAddressSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AXELAR_GATEWAY\",\"outputs\":[{\"internalType\":\"contract IAxelarGateway\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CHAIN_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GAS_RECEIVER\",\"outputs\":[{\"internalType\":\"contract IAxelarGasService\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN\",\"outputs\":[{\"internalType\":\"contract IRWALike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"destinationChain\",\"type\":\"string\"}],\"name\":\"burnAndCallAxelar\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"destChainToContractAddr\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct IMulticall.ExCallData[]\",\"name\":\"exCallData\",\"type\":\"tuple[]\"}],\"name\":\"multiexcall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"destinationChain\",\"type\":\"string\"}],\"name\":\"removeDestinationChainContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"destinationChain\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"setDestinationChainContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SourceBridge", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "00000000000000000000000049cc578ae695a66c45eef728f2aaf22646363cc60000000000000000000000004f4495243837681061c4743b74b3eedf548d56a50000000000000000000000002d5d7d31f671f86c782533cc367f14109a08271200000000000000000000000043997c583ed206770754aa63cc4ef0d326720862", "EVMVersion": "london", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": ""}