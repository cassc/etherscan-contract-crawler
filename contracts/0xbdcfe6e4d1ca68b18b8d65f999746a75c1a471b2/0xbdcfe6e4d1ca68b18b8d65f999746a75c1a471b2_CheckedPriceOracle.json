{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"CheckedPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"Math.sol\\\";\\nimport \\\"SafeCast.sol\\\";\\nimport \\\"EnumerableSet.sol\\\";\\n\\nimport \\\"IUSDPriceOracle.sol\\\";\\nimport \\\"IRelativePriceOracle.sol\\\";\\nimport \\\"IUSDBatchPriceOracle.sol\\\";\\nimport \\\"EnumerableExtensions.sol\\\";\\n\\nimport \\\"Governable.sol\\\";\\n\\nimport \\\"Errors.sol\\\";\\nimport \\\"FixedPoint.sol\\\";\\n\\ncontract CheckedPriceOracle is IUSDPriceOracle, IUSDBatchPriceOracle, Governable {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    using FixedPoint for uint256;\\n    using SafeCast for uint256;\\n    using SafeCast for int256;\\n\\n    uint256 public constant INITIAL_MAX_PCT_WETH_USD_DEVIATION = 0.02e18;\\n    uint256 public constant INITIAL_RELATIVE_EPSILON = 0.02e18;\\n    uint256 public constant MAX_RELATIVE_EPSILON = 0.1e18;\\n\\n    address public immutable wethAddress;\\n\\n    IUSDPriceOracle public usdOracle;\\n    IRelativePriceOracle public relativeOracle;\\n\\n    uint256 public maxPctWethUsdDeviation;\\n\\n    uint256 public relativeEpsilon;\\n\\n    EnumerableSet.AddressSet internal ethPriceOracles;\\n\\n    /// These are the addresses of the assets to be paired with ETH e.g. USDC or USDT.\\n    /// Subset of (assetsForRelativePriceCheck union ultimate reserve assets).\\n    /// Must all be stablecoins.\\n    EnumerableSet.AddressSet internal quoteAssetsForPriceLevelTWAPS;\\n\\n    /// @dev This list is used to check if the relative price of the tokens are consistent\\n    EnumerableSet.AddressSet internal assetsForRelativePriceCheck;\\n\\n    /// @dev Assets in this list are not required to have a relative price\\n    EnumerableSet.AddressSet internal assetsWithIgnorableRelativePriceCheck;\\n\\n    event USDOracleUpdated(address indexed oracle);\\n    event RelativeOracleUpdated(address indexed oracle);\\n\\n    event PriceLevelTWAPQuoteAssetAdded(address _addressToAdd);\\n    event PriceLevelTWAPQuoteAssetRemoved(address _addressToRemove);\\n\\n    event AssetForRelativePriceCheckAdded(address _addressToAdd);\\n    event AssetForRelativePriceCheckRemoved(address _addressToRemove);\\n\\n    event TrustedSignerOracleAdded(address _addressToAdd);\\n    event TrustedSignerOracleRemoved(address _addressToRemove);\\n\\n    event AssetsWithIgnorableRelativePriceCheckAdded(address assetToAdd);\\n    event AssetsWithIgnorableRelativePriceCheckRemoved(address assetToRemove);\\n\\n    /// _usdOracle is for Chainlink\\n    constructor(\\n        address _governor,\\n        address _usdOracle,\\n        address _relativeOracle,\\n        address _wethAddress\\n    ) Governable(_governor) {\\n        require(_usdOracle != address(0), Errors.INVALID_ARGUMENT);\\n        require(_relativeOracle != address(0), Errors.INVALID_ARGUMENT);\\n        usdOracle = IUSDPriceOracle(_usdOracle);\\n        relativeOracle = IRelativePriceOracle(_relativeOracle);\\n        relativeEpsilon = INITIAL_RELATIVE_EPSILON;\\n        wethAddress = _wethAddress;\\n        maxPctWethUsdDeviation = INITIAL_MAX_PCT_WETH_USD_DEVIATION;\\n    }\\n\\n    function setUSDOracle(address _usdOracle) external governanceOnly {\\n        usdOracle = IUSDPriceOracle(_usdOracle);\\n        emit USDOracleUpdated(_usdOracle);\\n    }\\n\\n    function setRelativeOracle(address _relativeOracle) external governanceOnly {\\n        relativeOracle = IRelativePriceOracle(_relativeOracle);\\n        emit RelativeOracleUpdated(_relativeOracle);\\n    }\\n\\n    function addETHPriceOracle(address oracleToAdd) external governanceOnly {\\n        ethPriceOracles.add(oracleToAdd);\\n        emit TrustedSignerOracleAdded(oracleToAdd);\\n    }\\n\\n    function removeETHPriceOracle(address oracleToRemove) external governanceOnly {\\n        ethPriceOracles.remove(oracleToRemove);\\n        emit TrustedSignerOracleRemoved(oracleToRemove);\\n    }\\n\\n    function listETHPriceOracles() external view returns (address[] memory) {\\n        return ethPriceOracles.values();\\n    }\\n\\n    function addQuoteAssetsForPriceLevelTwap(address _quoteAssetToAdd) external governanceOnly {\\n        quoteAssetsForPriceLevelTWAPS.add(_quoteAssetToAdd);\\n        emit PriceLevelTWAPQuoteAssetAdded(_quoteAssetToAdd);\\n    }\\n\\n    function listQuoteAssetsForPriceLevelTwap() external view returns (address[] memory) {\\n        return quoteAssetsForPriceLevelTWAPS.values();\\n    }\\n\\n    function removeQuoteAssetsForPriceLevelTwap(address _quoteAssetToRemove)\\n        external\\n        governanceOnly\\n    {\\n        quoteAssetsForPriceLevelTWAPS.remove(_quoteAssetToRemove);\\n        emit PriceLevelTWAPQuoteAssetRemoved(_quoteAssetToRemove);\\n    }\\n\\n    function addAssetForRelativePriceCheck(address assetToAdd) external governanceOnly {\\n        assetsForRelativePriceCheck.add(assetToAdd);\\n        emit AssetForRelativePriceCheckAdded(assetToAdd);\\n    }\\n\\n    function listAssetForRelativePriceCheck() external view returns (address[] memory) {\\n        return assetsForRelativePriceCheck.values();\\n    }\\n\\n    function removeAssetForRelativePriceCheck(address assetToRemove) external governanceOnly {\\n        assetsForRelativePriceCheck.remove(assetToRemove);\\n        emit AssetForRelativePriceCheckRemoved(assetToRemove);\\n    }\\n\\n    function addAssetsWithIgnorableRelativePriceCheck(address assetToAdd) external governanceOnly {\\n        assetsWithIgnorableRelativePriceCheck.add(assetToAdd);\\n        emit AssetsWithIgnorableRelativePriceCheckAdded(assetToAdd);\\n    }\\n\\n    function listAssetsWithIgnorableRelativePriceCheck() external view returns (address[] memory) {\\n        return assetsWithIgnorableRelativePriceCheck.values();\\n    }\\n\\n    function removeAssetsWithIgnorableRelativePriceCheck(address assetToRemove)\\n        external\\n        governanceOnly\\n    {\\n        assetsWithIgnorableRelativePriceCheck.remove(assetToRemove);\\n        emit AssetsWithIgnorableRelativePriceCheckRemoved(assetToRemove);\\n    }\\n\\n    function batchRelativePriceCheck(address[] memory tokenAddresses, uint256[] memory prices)\\n        internal\\n        view\\n        returns (uint256[] memory)\\n    {\\n        uint256[] memory priceLevelTwaps = new uint256[](tokenAddresses.length);\\n\\n        uint256 k;\\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\\n            bool couldCheck = false;\\n\\n            for (uint256 j = 0; j < assetsForRelativePriceCheck.length(); j++) {\\n                address assetForCheck = assetsForRelativePriceCheck.at(j);\\n                if (\\n                    tokenAddresses[i] == assetForCheck ||\\n                    !relativeOracle.isPairSupported(tokenAddresses[i], assetForCheck)\\n                ) {\\n                    continue;\\n                }\\n\\n                uint256 relativePrice = relativeOracle.getRelativePrice(\\n                    tokenAddresses[i],\\n                    assetForCheck\\n                );\\n\\n                if (\\n                    tokenAddresses[i] == wethAddress &&\\n                    quoteAssetsForPriceLevelTWAPS.contains(assetForCheck)\\n                ) {\\n                    priceLevelTwaps[k] = relativePrice;\\n                    k++;\\n                } else if (\\n                    assetForCheck == wethAddress &&\\n                    quoteAssetsForPriceLevelTWAPS.contains(tokenAddresses[i])\\n                ) {\\n                    priceLevelTwaps[k] = FixedPoint.ONE.divDown(relativePrice);\\n                    k++;\\n                }\\n\\n                uint256 assetForCheckPrice = _findPrice(assetForCheck, tokenAddresses, prices);\\n                _ensureRelativePriceConsistency(prices[i], assetForCheckPrice, relativePrice);\\n\\n                couldCheck = true;\\n                break;\\n            }\\n\\n            require(\\n                couldCheck || assetsWithIgnorableRelativePriceCheck.contains(tokenAddresses[i]),\\n                Errors.ASSET_NOT_SUPPORTED\\n            );\\n        }\\n\\n        uint256[] memory foundTwaps = new uint256[](k);\\n        for (uint256 i = 0; i < k; i++) {\\n            foundTwaps[i] = priceLevelTwaps[i];\\n        }\\n\\n        return foundTwaps;\\n    }\\n\\n    /// @inheritdoc IUSDPriceOracle\\n    function getPriceUSD(address tokenAddress) public view override returns (uint256) {\\n        address[] memory tokenAddresses = new address[](1);\\n        tokenAddresses[0] = tokenAddress;\\n        uint256[] memory prices = getPricesUSD(tokenAddresses);\\n        return prices[0];\\n    }\\n\\n    /// @inheritdoc IUSDBatchPriceOracle\\n    function getPricesUSD(address[] memory tokenAddresses)\\n        public\\n        view\\n        override\\n        returns (uint256[] memory)\\n    {\\n        (uint256[] memory prices, , , ) = getPricesUSDWithMetadata(tokenAddresses);\\n        return prices;\\n    }\\n\\n    function getPricesUSDWithMetadata(address[] memory tokenAddresses)\\n        public\\n        view\\n        returns (\\n            uint256[] memory,\\n            uint256,\\n            uint256[] memory,\\n            uint256[] memory\\n        )\\n    {\\n        require(tokenAddresses.length > 0, Errors.INVALID_ARGUMENT);\\n\\n        uint256[] memory prices = new uint256[](tokenAddresses.length);\\n\\n        /// Will start with this being the WETH/USD price, this can be modified later if desired.\\n        uint256 priceLevel;\\n\\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\\n            prices[i] = usdOracle.getPriceUSD(tokenAddresses[i]);\\n            if (tokenAddresses[i] == wethAddress) {\\n                priceLevel = prices[i];\\n            }\\n        }\\n\\n        // avoid fetching the price of WETH twice\\n        if (priceLevel == 0) {\\n            priceLevel = usdOracle.getPriceUSD(wethAddress);\\n        }\\n\\n        uint256[] memory priceLevelTwaps = batchRelativePriceCheck(tokenAddresses, prices);\\n\\n        uint256[] memory ethPrices = getETHPrices();\\n\\n        _checkPriceLevel(priceLevel, ethPrices, priceLevelTwaps);\\n\\n        return (prices, priceLevel, ethPrices, priceLevelTwaps);\\n    }\\n\\n    function setRelativeMaxEpsilon(uint256 _relativeEpsilon) external governanceOnly {\\n        require(_relativeEpsilon > 0, Errors.INVALID_ARGUMENT);\\n        require(_relativeEpsilon < MAX_RELATIVE_EPSILON, Errors.INVALID_ARGUMENT);\\n\\n        relativeEpsilon = _relativeEpsilon;\\n    }\\n\\n    function setMaxPctWethUsdDeviation(uint256 _maxPctWethUsdDeviation) external governanceOnly {\\n        maxPctWethUsdDeviation = _maxPctWethUsdDeviation;\\n    }\\n\\n    function _checkPriceLevel(\\n        uint256 priceLevel,\\n        uint256[] memory signedPrices,\\n        uint256[] memory priceLevelTwaps\\n    ) internal view {\\n        uint256 trueWETH = getRobustWETHPrice(signedPrices, priceLevelTwaps);\\n        uint256 relativePriceDifference = priceLevel.absSub(trueWETH).divDown(trueWETH);\\n        require(relativePriceDifference <= maxPctWethUsdDeviation, Errors.ROOT_PRICE_NOT_GROUNDED);\\n    }\\n\\n    function _ensureRelativePriceConsistency(\\n        uint256 aUSDPrice,\\n        uint256 bUSDPrice,\\n        uint256 abPrice\\n    ) internal view {\\n        uint256 abPriceFromUSD = aUSDPrice.divDown(bUSDPrice);\\n        uint256 priceDifference = abPrice.absSub(abPriceFromUSD);\\n        uint256 relativePriceDifference = priceDifference.divDown(abPrice);\\n\\n        require(relativePriceDifference <= relativeEpsilon, Errors.STALE_PRICE);\\n    }\\n\\n    function _computeMinOrSecondMin(uint256[] memory twapPrices) internal pure returns (uint256) {\\n        // min if there are two, or the 2nd min if more than two\\n        if (twapPrices.length == 1) return twapPrices[0];\\n        (uint256 min, uint256 secondMin) = twapPrices[0] < twapPrices[1]\\n            ? (twapPrices[0], twapPrices[1])\\n            : (twapPrices[1], twapPrices[0]);\\n        if (twapPrices.length == 2) return min;\\n\\n        for (uint256 i = 2; i < twapPrices.length; i++) {\\n            if (twapPrices[i] < min) {\\n                secondMin = min;\\n                min = twapPrices[i];\\n            } else if (twapPrices[i] < secondMin) {\\n                secondMin = twapPrices[i];\\n            }\\n        }\\n        return secondMin;\\n    }\\n\\n    function _findPrice(\\n        address target,\\n        address[] memory tokenAddresses,\\n        uint256[] memory prices\\n    ) internal view returns (uint256) {\\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\\n            if (tokenAddresses[i] == target) {\\n                return prices[i];\\n            }\\n        }\\n        return usdOracle.getPriceUSD(target);\\n    }\\n\\n    function _sort(uint256[] memory data) internal view returns (uint256[] memory) {\\n        _quickSort(data, int256(0), int256(data.length - 1));\\n        return data;\\n    }\\n\\n    function _quickSort(\\n        uint256[] memory arr,\\n        int256 left,\\n        int256 right\\n    ) internal view {\\n        int256 i = left;\\n        int256 j = right;\\n        if (i == j) return;\\n        uint256 pivot = arr[uint256(left + (right - left) / 2)];\\n        while (i <= j) {\\n            while (arr[uint256(i)] < pivot) i++;\\n            while (pivot < arr[uint256(j)]) j--;\\n            if (i <= j) {\\n                (arr[uint256(i)], arr[uint256(j)]) = (arr[uint256(j)], arr[uint256(i)]);\\n                i++;\\n                j--;\\n            }\\n        }\\n        if (left < j) _quickSort(arr, left, j);\\n        if (i < right) _quickSort(arr, i, right);\\n    }\\n\\n    function _median(uint256[] memory array) internal view returns (uint256) {\\n        _sort(array);\\n        return\\n            array.length % 2 == 0\\n                ? Math.average(array[array.length / 2 - 1], array[array.length / 2])\\n                : array[array.length / 2];\\n    }\\n\\n    function getETHPrices() public view returns (uint256[] memory ethPrices) {\\n        uint256[] memory prices = new uint256[](ethPriceOracles.length());\\n        uint256 successCount;\\n        for (uint256 i; i < ethPriceOracles.length(); i++) {\\n            IUSDPriceOracle oracle = IUSDPriceOracle(ethPriceOracles.at(i));\\n            try oracle.getPriceUSD(wethAddress) returns (uint256 price) {\\n                prices[successCount++] = price;\\n            } catch {}\\n        }\\n        require(successCount > 0, Errors.NO_WETH_PRICE);\\n        ethPrices = new uint256[](successCount);\\n        for (uint256 i = 0; i < successCount; i++) {\\n            ethPrices[i] = prices[i];\\n        }\\n    }\\n\\n    /// @notice this function provides an estimate of the true WETH price.\\n    /// 1. Find the minimum TWAP price (or second minumum if >2 TWAP prices) from a given array.\\n    /// 2. Add this to an array of signed prices\\n    /// 3. Compute the median of this array\\n    /// @param signedPrices an array of prices from trusted providers (e.g. Chainlink, Coinbase, OKEx ETH/USD price)\\n    /// @param twapPrices an array of Time Weighted Moving Average ETH/stablecoin prices\\n    function getRobustWETHPrice(uint256[] memory signedPrices, uint256[] memory twapPrices)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 minTWAP;\\n        if (twapPrices.length == 0) {\\n            return _median(signedPrices);\\n        } else {\\n            minTWAP = _computeMinOrSecondMin(twapPrices);\\n            uint256[] memory prices = new uint256[](signedPrices.length + 1);\\n            prices[prices.length - 1] = minTWAP;\\n            for (uint256 i = 0; i < prices.length - 1; i++) {\\n                prices[i] = signedPrices[i];\\n            }\\n            return _median(prices);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"IUSDPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\ninterface IUSDPriceOracle {\\n    /// @notice Quotes the USD price of `tokenAddress`\\n    /// The quoted price is always scaled with 18 decimals regardless of the\\n    /// source used for the oracle.\\n    /// @param tokenAddress the asset of which the price is to be quoted\\n    /// @return the USD price of the asset\\n    function getPriceUSD(address tokenAddress) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"IRelativePriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\ninterface IRelativePriceOracle {\\n    /// @notice Quotes the price of `baseToken` relative to `quoteToken`\\n    /// The quoted price is always scaled with 18 decimals regardless of the\\n    /// source used for the oracle.\\n    /// @param baseToken the token of which the price is to be quoted\\n    /// @param quoteToken the token used to denominate the price\\n    /// @return the number of units of quote token per base token\\n    function getRelativePrice(address baseToken, address quoteToken)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @notice Returns whether the oracle currently supports prices\\n    /// for `baseToken` relative to `quoteToken`\\n    function isPairSupported(address baseToken, address quoteToken) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"IUSDBatchPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\ninterface IUSDBatchPriceOracle {\\n    /// @notice Quotes the USD price of `baseAssets`\\n    /// The quoted prices is always scaled with 18 decimals regardless of the\\n    /// source used for the oracle.\\n    /// @param baseAssets the assets of which the price is to be quoted\\n    /// @return the USD prices of the asset\\n    function getPricesUSD(address[] memory baseAssets) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"EnumerableExtensions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"EnumerableSet.sol\\\";\\nimport \\\"EnumerableMap.sol\\\";\\nimport \\\"EnumerableMapping.sol\\\";\\n\\nlibrary EnumerableExtensions {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using EnumerableMapping for EnumerableMapping.AddressToAddressMap;\\n    using EnumerableMapping for EnumerableMapping.AddressToUintMap;\\n\\n    // AddressSet\\n\\n    function toArray(EnumerableSet.AddressSet storage addresses)\\n        internal\\n        view\\n        returns (address[] memory)\\n    {\\n        uint256 len = addresses.length();\\n        address[] memory result = new address[](len);\\n        for (uint256 i = 0; i < len; i++) {\\n            result[i] = addresses.at(i);\\n        }\\n        return result;\\n    }\\n\\n    // Bytes32Set\\n\\n    function toArray(EnumerableSet.Bytes32Set storage values)\\n        internal\\n        view\\n        returns (bytes32[] memory)\\n    {\\n        uint256 len = values.length();\\n        bytes32[] memory result = new bytes32[](len);\\n        for (uint256 i = 0; i < len; i++) {\\n            result[i] = values.at(i);\\n        }\\n        return result;\\n    }\\n\\n    // AddressToAddressMap\\n\\n    function keyAt(EnumerableMapping.AddressToAddressMap storage map, uint256 index)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        (address key, ) = map.at(index);\\n        return key;\\n    }\\n\\n    function valueAt(EnumerableMapping.AddressToAddressMap storage map, uint256 index)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        (, address value) = map.at(index);\\n        return value;\\n    }\\n\\n    function keysArray(EnumerableMapping.AddressToAddressMap storage map)\\n        internal\\n        view\\n        returns (address[] memory)\\n    {\\n        uint256 len = map.length();\\n        address[] memory result = new address[](len);\\n        for (uint256 i = 0; i < len; i++) {\\n            result[i] = keyAt(map, i);\\n        }\\n        return result;\\n    }\\n\\n    function valuesArray(EnumerableMapping.AddressToAddressMap storage map)\\n        internal\\n        view\\n        returns (address[] memory)\\n    {\\n        uint256 len = map.length();\\n        address[] memory result = new address[](len);\\n        for (uint256 i = 0; i < len; i++) {\\n            result[i] = valueAt(map, i);\\n        }\\n        return result;\\n    }\\n\\n    // AddressToUintMap\\n\\n    function keyAt(EnumerableMapping.AddressToUintMap storage map, uint256 index)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        (address key, ) = map.at(index);\\n        return key;\\n    }\\n\\n    function valueAt(EnumerableMapping.AddressToUintMap storage map, uint256 index)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        (, uint256 value) = map.at(index);\\n        return value;\\n    }\\n\\n    function keysArray(EnumerableMapping.AddressToUintMap storage map)\\n        internal\\n        view\\n        returns (address[] memory)\\n    {\\n        uint256 len = map.length();\\n        address[] memory result = new address[](len);\\n        for (uint256 i = 0; i < len; i++) {\\n            result[i] = keyAt(map, i);\\n        }\\n        return result;\\n    }\\n\\n    function valuesArray(EnumerableMapping.AddressToUintMap storage map)\\n        internal\\n        view\\n        returns (uint256[] memory)\\n    {\\n        uint256 len = map.length();\\n        uint256[] memory result = new uint256[](len);\\n        for (uint256 i = 0; i < len; i++) {\\n            result[i] = valueAt(map, i);\\n        }\\n        return result;\\n    }\\n\\n    // EnumerableMap.UintToAddressMap\\n\\n    function valueAt(EnumerableMap.UintToAddressMap storage map, uint256 index)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        (, address value) = map.at(index);\\n        return value;\\n    }\\n\\n    function valuesArray(EnumerableMap.UintToAddressMap storage map)\\n        internal\\n        view\\n        returns (address[] memory)\\n    {\\n        uint256 len = map.length();\\n        address[] memory result = new address[](len);\\n        for (uint256 i = 0; i < len; i++) {\\n            result[i] = valueAt(map, i);\\n        }\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"EnumerableMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableMap.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * The following map types are supported:\\n *\\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableMap.\\n * ====\\n */\\nlibrary EnumerableMap {\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // bytes32 keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in bytes32.\\n\\n    struct Bytes32ToBytes32Map {\\n        // Storage of keys\\n        EnumerableSet.Bytes32Set _keys;\\n        mapping(bytes32 => bytes32) _values;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        Bytes32ToBytes32Map storage map,\\n        bytes32 key,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        map._values[key] = value;\\n        return map._keys.add(key);\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\\n        delete map._values[key];\\n        return map._keys.remove(key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\\n        return map._keys.contains(key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\\n        return map._keys.length();\\n    }\\n\\n    /**\\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\\n        bytes32 key = map._keys.at(index);\\n        return (key, map._values[key]);\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\\n        bytes32 value = map._values[key];\\n        if (value == bytes32(0)) {\\n            return (contains(map, key), bytes32(0));\\n        } else {\\n            return (true, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        require(value != 0 || contains(map, key), \\\"EnumerableMap: nonexistent key\\\");\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        Bytes32ToBytes32Map storage map,\\n        bytes32 key,\\n        string memory errorMessage\\n    ) internal view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        require(value != 0 || contains(map, key), errorMessage);\\n        return value;\\n    }\\n\\n    // UintToUintMap\\n\\n    struct UintToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        UintToUintMap storage map,\\n        uint256 key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return set(map._inner, bytes32(key), bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\\n        return remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (uint256(key), uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(key)));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        UintToUintMap storage map,\\n        uint256 key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(key), errorMessage));\\n    }\\n\\n    // UintToAddressMap\\n\\n    struct UintToAddressMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        address value\\n    ) internal returns (bool) {\\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n        return (success, address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        string memory errorMessage\\n    ) internal view returns (address) {\\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\\n    }\\n\\n    // AddressToUintMap\\n\\n    struct AddressToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        AddressToUintMap storage map,\\n        address key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n        return remove(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (address(uint160(uint256(key))), uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        AddressToUintMap storage map,\\n        address key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\\n    }\\n\\n    // Bytes32ToUintMap\\n\\n    struct Bytes32ToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        Bytes32ToUintMap storage map,\\n        bytes32 key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return set(map._inner, key, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\\n        return remove(map._inner, key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\\n        return contains(map._inner, key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (key, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, key);\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\\n        return uint256(get(map._inner, key));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        Bytes32ToUintMap storage map,\\n        bytes32 key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, key, errorMessage));\\n    }\\n}\\n\"\r\n    },\r\n    \"EnumerableMapping.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"EnumerableSet.sol\\\";\\n\\nlibrary EnumerableMapping {\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n    // Code take from contracts/utils/structs/EnumerableMap.sol\\n    // because the helper functions are private\\n\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // bytes32 keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in bytes32.\\n\\n    struct Map {\\n        // Storage of keys\\n        EnumerableSet.Bytes32Set _keys;\\n        mapping(bytes32 => bytes32) _values;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function _set(\\n        Map storage map,\\n        bytes32 key,\\n        bytes32 value\\n    ) private returns (bool) {\\n        map._values[key] = value;\\n        return map._keys.add(key);\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\\n        delete map._values[key];\\n        return map._keys.remove(key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\\n        return map._keys.contains(key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function _length(Map storage map) private view returns (uint256) {\\n        return map._keys.length();\\n    }\\n\\n    /**\\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\\n        bytes32 key = map._keys.at(index);\\n        return (key, map._values[key]);\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\\n        bytes32 value = map._values[key];\\n        if (value == bytes32(0)) {\\n            return (_contains(map, key), bytes32(0));\\n        } else {\\n            return (true, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        require(value != 0 || _contains(map, key), \\\"EnumerableMap: nonexistent key\\\");\\n        return value;\\n    }\\n\\n    // AddressToAddressMap\\n\\n    struct AddressToAddressMap {\\n        Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        AddressToAddressMap storage map,\\n        address key,\\n        address value\\n    ) internal returns (bool) {\\n        return _set(map._inner, bytes32(uint256(uint160(key))), bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(AddressToAddressMap storage map, address key) internal returns (bool) {\\n        return _remove(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(AddressToAddressMap storage map, address key) internal view returns (bool) {\\n        return _contains(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(AddressToAddressMap storage map) internal view returns (uint256) {\\n        return _length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressToAddressMap storage map, uint256 index)\\n        internal\\n        view\\n        returns (address, address)\\n    {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n        return (address(uint160(uint256(key))), address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryGet(AddressToAddressMap storage map, address key)\\n        internal\\n        view\\n        returns (bool, address)\\n    {\\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(uint256(uint160(key))));\\n        return (success, address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(AddressToAddressMap storage map, address key) internal view returns (address) {\\n        return address(uint160(uint256(_get(map._inner, bytes32(uint256(uint160(key)))))));\\n    }\\n\\n    // AddressToUintMap\\n\\n    struct AddressToUintMap {\\n        Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        AddressToUintMap storage map,\\n        address key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return _set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n        return _remove(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n        return _contains(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\\n        return _length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressToUintMap storage map, uint256 index)\\n        internal\\n        view\\n        returns (address, uint256)\\n    {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n        return (address(uint160(uint256(key))), uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryGet(AddressToUintMap storage map, address key)\\n        internal\\n        view\\n        returns (bool, uint256)\\n    {\\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(uint256(uint160(key))));\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n        return uint256(_get(map._inner, bytes32(uint256(uint160(key)))));\\n    }\\n\\n    // Bytes32ToUIntMap\\n\\n    struct Bytes32ToUIntMap {\\n        Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        Bytes32ToUIntMap storage map,\\n        bytes32 key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return _set(map._inner, key, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(Bytes32ToUIntMap storage map, bytes32 key) internal returns (bool) {\\n        return _remove(map._inner, key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(Bytes32ToUIntMap storage map, bytes32 key) internal view returns (bool) {\\n        return _contains(map._inner, key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(Bytes32ToUIntMap storage map) internal view returns (uint256) {\\n        return _length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32ToUIntMap storage map, uint256 index)\\n        internal\\n        view\\n        returns (bytes32, uint256)\\n    {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n        return (key, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryGet(Bytes32ToUIntMap storage map, bytes32 key)\\n        internal\\n        view\\n        returns (bool, uint256)\\n    {\\n        (bool success, bytes32 value) = _tryGet(map._inner, key);\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(Bytes32ToUIntMap storage map, bytes32 key) internal view returns (uint256) {\\n        return uint256(_get(map._inner, key));\\n    }\\n}\\n\"\r\n    },\r\n    \"Governable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"GovernableBase.sol\\\";\\n\\ncontract Governable is GovernableBase {\\n    constructor(address _governor) {\\n        governor = _governor;\\n        emit GovernorChanged(address(0), _governor);\\n    }\\n}\\n\"\r\n    },\r\n    \"GovernableBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"Errors.sol\\\";\\nimport \\\"IGovernable.sol\\\";\\n\\ncontract GovernableBase is IGovernable {\\n    address public override governor;\\n    address public override pendingGovernor;\\n\\n    modifier governanceOnly() {\\n        require(msg.sender == governor, Errors.NOT_AUTHORIZED);\\n        _;\\n    }\\n\\n    /// @inheritdoc IGovernable\\n    function changeGovernor(address newGovernor) external override governanceOnly {\\n        require(address(newGovernor) != address(0), Errors.INVALID_ARGUMENT);\\n        pendingGovernor = newGovernor;\\n        emit GovernorChangeRequested(newGovernor);\\n    }\\n\\n    /// @inheritdoc IGovernable\\n    function acceptGovernance() external override {\\n        require(msg.sender == pendingGovernor, Errors.NOT_AUTHORIZED);\\n        address currentGovernor = governor;\\n        governor = pendingGovernor;\\n        pendingGovernor = address(0);\\n        emit GovernorChanged(currentGovernor, msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\n/// @notice Defines different errors emitted by Gyroscope contracts\\nlibrary Errors {\\n    string public constant TOKEN_AND_AMOUNTS_LENGTH_DIFFER = \\\"1\\\";\\n    string public constant TOO_MUCH_SLIPPAGE = \\\"2\\\";\\n    string public constant EXCHANGER_NOT_FOUND = \\\"3\\\";\\n    string public constant POOL_IDS_NOT_FOUND = \\\"4\\\";\\n    string public constant WOULD_UNBALANCE_GYROSCOPE = \\\"5\\\";\\n    string public constant VAULT_ALREADY_EXISTS = \\\"6\\\";\\n    string public constant VAULT_NOT_FOUND = \\\"7\\\";\\n\\n    string public constant X_OUT_OF_BOUNDS = \\\"20\\\";\\n    string public constant Y_OUT_OF_BOUNDS = \\\"21\\\";\\n    string public constant PRODUCT_OUT_OF_BOUNDS = \\\"22\\\";\\n    string public constant INVALID_EXPONENT = \\\"23\\\";\\n    string public constant OUT_OF_BOUNDS = \\\"24\\\";\\n    string public constant ZERO_DIVISION = \\\"25\\\";\\n    string public constant ADD_OVERFLOW = \\\"26\\\";\\n    string public constant SUB_OVERFLOW = \\\"27\\\";\\n    string public constant MUL_OVERFLOW = \\\"28\\\";\\n    string public constant DIV_INTERNAL = \\\"29\\\";\\n\\n    // User errors\\n    string public constant NOT_AUTHORIZED = \\\"30\\\";\\n    string public constant INVALID_ARGUMENT = \\\"31\\\";\\n    string public constant KEY_NOT_FOUND = \\\"32\\\";\\n    string public constant KEY_FROZEN = \\\"33\\\";\\n    string public constant INSUFFICIENT_BALANCE = \\\"34\\\";\\n    string public constant INVALID_ASSET = \\\"35\\\";\\n    string public constant FORBIDDEN_EXTERNAL_ACTION = \\\"35\\\";\\n\\n    // Oracle related errors\\n    string public constant ASSET_NOT_SUPPORTED = \\\"40\\\";\\n    string public constant STALE_PRICE = \\\"41\\\";\\n    string public constant NEGATIVE_PRICE = \\\"42\\\";\\n    string public constant INVALID_MESSAGE = \\\"43\\\";\\n    string public constant TOO_MUCH_VOLATILITY = \\\"44\\\";\\n    string public constant WETH_ADDRESS_NOT_FIRST = \\\"44\\\";\\n    string public constant ROOT_PRICE_NOT_GROUNDED = \\\"45\\\";\\n    string public constant NOT_ENOUGH_TWAPS = \\\"46\\\";\\n    string public constant ZERO_PRICE_TWAP = \\\"47\\\";\\n    string public constant INVALID_NUMBER_WEIGHTS = \\\"48\\\";\\n    string public constant NO_WETH_PRICE = \\\"49\\\";\\n\\n    //Vault safety check related errors\\n    string public constant A_VAULT_HAS_ALL_STABLECOINS_OFF_PEG = \\\"51\\\";\\n    string public constant NOT_SAFE_TO_MINT = \\\"52\\\";\\n    string public constant NOT_SAFE_TO_REDEEM = \\\"53\\\";\\n    string public constant AMOUNT_AND_PRICE_LENGTH_DIFFER = \\\"54\\\";\\n    string public constant TOKEN_PRICES_TOO_SMALL = \\\"55\\\";\\n    string public constant TRYING_TO_REDEEM_MORE_THAN_VAULT_CONTAINS = \\\"56\\\";\\n    string public constant CALLER_NOT_MOTHERBOARD = \\\"57\\\";\\n    string public constant CALLER_NOT_RESERVE_MANAGER = \\\"58\\\";\\n    string public constant VAULT_CANNOT_BE_REMOVED = \\\"59\\\";\\n\\n    string public constant VAULT_FLOW_TOO_HIGH = \\\"60\\\";\\n    string public constant OPERATION_SUCCEEDS_BUT_SAFETY_MODE_ACTIVATED = \\\"61\\\";\\n    string public constant ORACLE_GUARDIAN_TIME_LIMIT = \\\"62\\\";\\n    string public constant NOT_ENOUGH_FLOW_DATA = \\\"63\\\";\\n    string public constant SUPPLY_CAP_EXCEEDED = \\\"64\\\";\\n    string public constant SAFETY_MODE_ACTIVATED = \\\"65\\\";\\n\\n    // misc errors\\n    string public constant REDEEM_AMOUNT_BUG = \\\"100\\\";\\n    string public constant EXTERNAL_ACTION_FAILED = \\\"101\\\";\\n    string public constant TOKENS_NOT_SORTED = \\\"102\\\";\\n    string public constant NO_SHARES_MINTED = \\\"103\\\";\\n    string public constant TRYING_TO_REDEEM_MORE_THAN_SUPPLY = \\\"104\\\";\\n}\\n\"\r\n    },\r\n    \"IGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\ninterface IGovernable {\\n    /// @notice Emmited when the governor is changed\\n    event GovernorChanged(address oldGovernor, address newGovernor);\\n\\n    /// @notice Emmited when the governor is change is requested\\n    event GovernorChangeRequested(address newGovernor);\\n\\n    /// @notice Returns the current governor\\n    function governor() external view returns (address);\\n\\n    /// @notice Returns the pending governor\\n    function pendingGovernor() external view returns (address);\\n\\n    /// @notice Changes the governor\\n    /// can only be called by the current governor\\n    function changeGovernor(address newGovernor) external;\\n\\n    /// @notice Called by the pending governor to approve the change\\n    function acceptGovernance() external;\\n}\\n\"\r\n    },\r\n    \"FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"LogExpMath.sol\\\";\\nimport \\\"Errors.sol\\\";\\n\\n/* solhint-disable private-vars-leading-underscore */\\n\\nlibrary FixedPoint {\\n    uint256 internal constant ONE = 1e18; // 18 decimal places\\n    uint256 internal constant MAX_POW_RELATIVE_ERROR = 10000; // 10^(-14)\\n\\n    // Minimum base for the power function when the exponent is 'free' (larger than ONE).\\n    uint256 internal constant MIN_POW_BASE_FREE_EXPONENT = 0.7e18;\\n\\n    function absSub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a - b : b - a;\\n    }\\n\\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 product = a * b;\\n\\n        return product / ONE;\\n    }\\n\\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 product = a * b;\\n\\n        if (product == 0) {\\n            return 0;\\n        } else {\\n            // The traditional divUp formula is:\\n            // divUp(x, y) := (x + y - 1) / y\\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\\n            // divUp(x, y) := (x - 1) / y + 1\\n            // Note that this requires x != 0, which we already tested for.\\n\\n            return ((product - 1) / ONE) + 1;\\n        }\\n    }\\n\\n    function squareUp(uint256 a) internal pure returns (uint256) {\\n        return mulUp(a, a);\\n    }\\n\\n    function squareDown(uint256 a) internal pure returns (uint256) {\\n        return mulDown(a, a);\\n    }\\n\\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, Errors.ZERO_DIVISION);\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            uint256 aInflated = a * ONE;\\n\\n            return aInflated / b;\\n        }\\n    }\\n\\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, Errors.ZERO_DIVISION);\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            uint256 aInflated = a * ONE;\\n\\n            // The traditional divUp formula is:\\n            // divUp(x, y) := (x + y - 1) / y\\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\\n            // divUp(x, y) := (x - 1) / y + 1\\n            // Note that this requires x != 0, which we already tested for.\\n\\n            unchecked {\\n                return ((aInflated - 1) / b) + 1;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above\\n     * the true value (that is, the error function expected - actual is always positive).\\n     */\\n    function powDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        uint256 raw = LogExpMath.pow(x, y);\\n        uint256 maxError = mulUp(raw, MAX_POW_RELATIVE_ERROR) + 1;\\n\\n        if (raw < maxError) {\\n            return 0;\\n        } else {\\n            return raw - maxError;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below\\n     * the true value (that is, the error function expected - actual is always negative).\\n     */\\n    function powUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        uint256 raw = LogExpMath.pow(x, y);\\n        uint256 maxError = mulUp(raw, MAX_POW_RELATIVE_ERROR) + 1;\\n\\n        return raw + maxError;\\n    }\\n\\n    /**\\n     * @dev Returns the complement of a value (1 - x), capped to 0 if x is larger than 1.\\n     *\\n     * Useful when computing the complement for values with some level of relative error, as it strips this error and\\n     * prevents intermediate negative values.\\n     */\\n    function complement(uint256 x) internal pure returns (uint256) {\\n        return (x < ONE) ? (ONE - x) : 0;\\n    }\\n\\n    /**\\n     * @dev returns the minimum between x and y\\n     */\\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x < y ? x : y;\\n    }\\n\\n    /**\\n     * @dev returns the maximum between x and y\\n     */\\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x > y ? x : y;\\n    }\\n\\n    /**\\n     * @notice This is taken from the Balancer V1 code base.\\n     * Computes a**b where a is a scaled fixed-point number and b is an integer\\n     * The computation is performed in O(log n)\\n     */\\n    function intPowDown(uint256 base, uint256 exp) internal pure returns (uint256) {\\n        uint256 result = FixedPoint.ONE;\\n        while (exp > 0) {\\n            if (exp % 2 == 1) {\\n                result = mulDown(result, base);\\n            }\\n            exp /= 2;\\n            base = mulDown(base, base);\\n        }\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"LogExpMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"Errors.sol\\\";\\n\\n/* solhint-disable */\\n\\n/**\\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\\n *\\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\\n * exponentiation and logarithm (where the base is Euler's number).\\n *\\n * @author Fernando Martinelli - @fernandomartinelli\\n * @author Sergio Yuhjtman - @sergioyuhjtman\\n * @author Daniel Fernandez - @dmf7z\\n */\\nlibrary LogExpMath {\\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\\n    // two numbers, and multiply by ONE when dividing them.\\n\\n    // All arguments and return values are 18 decimal fixed point numbers.\\n    int256 constant ONE_18 = 1e18;\\n\\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\\n    // case of ln36, 36 decimals.\\n    int256 constant ONE_20 = 1e20;\\n    int256 constant ONE_36 = 1e36;\\n\\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\\n    //\\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\\n    // The smallest possible result is 10^(-18), which makes largest negative argument\\n    // ln(10^(-18)) = -41.446531673892822312.\\n    // We use 130.0 and -41.0 to have some safety margin.\\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\\n\\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\\n    // 256 bit integer.\\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\\n\\n    uint256 constant MILD_EXPONENT_BOUND = 2**254 / uint256(ONE_20);\\n\\n    // 18 decimal constants\\n    int256 constant x0 = 128000000000000000000; // 2\u02c67\\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // e\u02c6(x0) (no decimals)\\n    int256 constant x1 = 64000000000000000000; // 2\u02c66\\n    int256 constant a1 = 6235149080811616882910000000; // e\u02c6(x1) (no decimals)\\n\\n    // 20 decimal constants\\n    int256 constant x2 = 3200000000000000000000; // 2\u02c65\\n    int256 constant a2 = 7896296018268069516100000000000000; // e\u02c6(x2)\\n    int256 constant x3 = 1600000000000000000000; // 2\u02c64\\n    int256 constant a3 = 888611052050787263676000000; // e\u02c6(x3)\\n    int256 constant x4 = 800000000000000000000; // 2\u02c63\\n    int256 constant a4 = 298095798704172827474000; // e\u02c6(x4)\\n    int256 constant x5 = 400000000000000000000; // 2\u02c62\\n    int256 constant a5 = 5459815003314423907810; // e\u02c6(x5)\\n    int256 constant x6 = 200000000000000000000; // 2\u02c61\\n    int256 constant a6 = 738905609893065022723; // e\u02c6(x6)\\n    int256 constant x7 = 100000000000000000000; // 2\u02c60\\n    int256 constant a7 = 271828182845904523536; // e\u02c6(x7)\\n    int256 constant x8 = 50000000000000000000; // 2\u02c6-1\\n    int256 constant a8 = 164872127070012814685; // e\u02c6(x8)\\n    int256 constant x9 = 25000000000000000000; // 2\u02c6-2\\n    int256 constant a9 = 128402541668774148407; // e\u02c6(x9)\\n    int256 constant x10 = 12500000000000000000; // 2\u02c6-3\\n    int256 constant a10 = 113314845306682631683; // e\u02c6(x10)\\n    int256 constant x11 = 6250000000000000000; // 2\u02c6-4\\n    int256 constant a11 = 106449445891785942956; // e\u02c6(x11)\\n\\n    /**\\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\\n     *\\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\\n        unchecked {\\n            if (y == 0) {\\n                // We solve the 0^0 indetermination by making it equal one.\\n                return uint256(ONE_18);\\n            }\\n\\n            if (x == 0) {\\n                return 0;\\n            }\\n\\n            // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\\n            // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\\n            // x^y = exp(y * ln(x)).\\n\\n            // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\\n            require(x < 2**255, Errors.X_OUT_OF_BOUNDS);\\n            int256 x_int256 = int256(x);\\n\\n            // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\\n            // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\\n\\n            // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\\n            require(y < MILD_EXPONENT_BOUND, Errors.Y_OUT_OF_BOUNDS);\\n            int256 y_int256 = int256(y);\\n\\n            int256 logx_times_y;\\n            if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\\n                int256 ln_36_x = _ln_36(x_int256);\\n\\n                // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\\n                // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\\n                // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\\n                // (downscaled) last 18 decimals.\\n                logx_times_y = ((ln_36_x / ONE_18) *\\n                    y_int256 +\\n                    ((ln_36_x % ONE_18) * y_int256) /\\n                    ONE_18);\\n            } else {\\n                logx_times_y = _ln(x_int256) * y_int256;\\n            }\\n            logx_times_y /= ONE_18;\\n\\n            // Finally, we compute exp(y * ln(x)) to arrive at x^y\\n            require(\\n                MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\\n                Errors.PRODUCT_OUT_OF_BOUNDS\\n            );\\n\\n            return uint256(exp(logx_times_y));\\n        }\\n    }\\n\\n    /**\\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\\n     *\\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\\n     */\\n    function exp(int256 x) internal pure returns (int256) {\\n        require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, Errors.INVALID_EXPONENT);\\n        unchecked {\\n            if (x < 0) {\\n                // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\\n                // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\\n                // Fixed point division requires multiplying by ONE_18.\\n                return ((ONE_18 * ONE_18) / exp(-x));\\n            }\\n\\n            // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\\n            // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\\n            // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\\n            // decomposition.\\n            // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\\n            // decomposition, which will be lower than the smallest x_n.\\n            // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\\n            // We mutate x by subtracting x_n, making it the remainder of the decomposition.\\n\\n            // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\\n            // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\\n            // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\\n            // decomposition.\\n\\n            // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\\n            // it and compute the accumulated product.\\n\\n            int256 firstAN;\\n            if (x >= x0) {\\n                x -= x0;\\n                firstAN = a0;\\n            } else if (x >= x1) {\\n                x -= x1;\\n                firstAN = a1;\\n            } else {\\n                firstAN = 1; // One with no decimal places\\n            }\\n\\n            // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\\n            // smaller terms.\\n            x *= 100;\\n\\n            // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\\n            // one. Recall that fixed point multiplication requires dividing by ONE_20.\\n            int256 product = ONE_20;\\n\\n            if (x >= x2) {\\n                x -= x2;\\n                product = (product * a2) / ONE_20;\\n            }\\n            if (x >= x3) {\\n                x -= x3;\\n                product = (product * a3) / ONE_20;\\n            }\\n            if (x >= x4) {\\n                x -= x4;\\n                product = (product * a4) / ONE_20;\\n            }\\n            if (x >= x5) {\\n                x -= x5;\\n                product = (product * a5) / ONE_20;\\n            }\\n            if (x >= x6) {\\n                x -= x6;\\n                product = (product * a6) / ONE_20;\\n            }\\n            if (x >= x7) {\\n                x -= x7;\\n                product = (product * a7) / ONE_20;\\n            }\\n            if (x >= x8) {\\n                x -= x8;\\n                product = (product * a8) / ONE_20;\\n            }\\n            if (x >= x9) {\\n                x -= x9;\\n                product = (product * a9) / ONE_20;\\n            }\\n\\n            // x10 and x11 are unnecessary here since we have high enough precision already.\\n\\n            // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\\n            // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\\n\\n            int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\\n            int256 term; // Each term in the sum, where the nth term is (x^n / n!).\\n\\n            // The first term is simply x.\\n            term = x;\\n            seriesSum += term;\\n\\n            // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\\n            // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\\n\\n            term = ((term * x) / ONE_20) / 2;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 3;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 4;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 5;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 6;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 7;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 8;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 9;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 10;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 11;\\n            seriesSum += term;\\n\\n            term = ((term * x) / ONE_20) / 12;\\n            seriesSum += term;\\n\\n            // 12 Taylor terms are sufficient for 18 decimal precision.\\n\\n            // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\\n            // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\\n            // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\\n            // and then drop two digits to return an 18 decimal value.\\n\\n            return (((product * seriesSum) / ONE_20) * firstAN) / 100;\\n        }\\n    }\\n\\n    /**\\n     * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\\n     */\\n    function log(int256 arg, int256 base) internal pure returns (int256) {\\n        unchecked {\\n            // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\\n\\n            // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\\n            // upscaling.\\n\\n            int256 logBase;\\n            if (LN_36_LOWER_BOUND < base && base < LN_36_UPPER_BOUND) {\\n                logBase = _ln_36(base);\\n            } else {\\n                logBase = _ln(base) * ONE_18;\\n            }\\n\\n            int256 logArg;\\n            if (LN_36_LOWER_BOUND < arg && arg < LN_36_UPPER_BOUND) {\\n                logArg = _ln_36(arg);\\n            } else {\\n                logArg = _ln(arg) * ONE_18;\\n            }\\n\\n            // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\\n            return (logArg * ONE_18) / logBase;\\n        }\\n    }\\n\\n    /**\\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function ln(int256 a) internal pure returns (int256) {\\n        unchecked {\\n            // The real natural logarithm is not defined for negative numbers or zero.\\n            require(a > 0, Errors.OUT_OF_BOUNDS);\\n            if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\\n                return _ln_36(a) / ONE_18;\\n            } else {\\n                return _ln(a);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\\n     */\\n    function _ln(int256 a) private pure returns (int256) {\\n        unchecked {\\n            if (a < ONE_18) {\\n                // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\\n                // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\\n                // Fixed point division requires multiplying by ONE_18.\\n                return (-_ln((ONE_18 * ONE_18) / a));\\n            }\\n\\n            // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\\n            // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\\n            // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\\n            // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\\n            // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\\n            // decomposition, which will be lower than the smallest a_n.\\n            // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\\n            // We mutate a by subtracting a_n, making it the remainder of the decomposition.\\n\\n            // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\\n            // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\\n            // ONE_18 to convert them to fixed point.\\n            // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\\n            // by it and compute the accumulated sum.\\n\\n            int256 sum = 0;\\n            if (a >= a0 * ONE_18) {\\n                a /= a0; // Integer, not fixed point division\\n                sum += x0;\\n            }\\n\\n            if (a >= a1 * ONE_18) {\\n                a /= a1; // Integer, not fixed point division\\n                sum += x1;\\n            }\\n\\n            // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\\n            sum *= 100;\\n            a *= 100;\\n\\n            // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\\n\\n            if (a >= a2) {\\n                a = (a * ONE_20) / a2;\\n                sum += x2;\\n            }\\n\\n            if (a >= a3) {\\n                a = (a * ONE_20) / a3;\\n                sum += x3;\\n            }\\n\\n            if (a >= a4) {\\n                a = (a * ONE_20) / a4;\\n                sum += x4;\\n            }\\n\\n            if (a >= a5) {\\n                a = (a * ONE_20) / a5;\\n                sum += x5;\\n            }\\n\\n            if (a >= a6) {\\n                a = (a * ONE_20) / a6;\\n                sum += x6;\\n            }\\n\\n            if (a >= a7) {\\n                a = (a * ONE_20) / a7;\\n                sum += x7;\\n            }\\n\\n            if (a >= a8) {\\n                a = (a * ONE_20) / a8;\\n                sum += x8;\\n            }\\n\\n            if (a >= a9) {\\n                a = (a * ONE_20) / a9;\\n                sum += x9;\\n            }\\n\\n            if (a >= a10) {\\n                a = (a * ONE_20) / a10;\\n                sum += x10;\\n            }\\n\\n            if (a >= a11) {\\n                a = (a * ONE_20) / a11;\\n                sum += x11;\\n            }\\n\\n            // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\\n            // that converges rapidly for values of `a` close to one - the same one used in ln_36.\\n            // Let z = (a - 1) / (a + 1).\\n            // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n            // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\\n            // division by ONE_20.\\n            int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\\n            int256 z_squared = (z * z) / ONE_20;\\n\\n            // num is the numerator of the series: the z^(2 * n + 1) term\\n            int256 num = z;\\n\\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n            int256 seriesSum = num;\\n\\n            // In each step, the numerator is multiplied by z^2\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 3;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 5;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 7;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 9;\\n\\n            num = (num * z_squared) / ONE_20;\\n            seriesSum += num / 11;\\n\\n            // 6 Taylor terms are sufficient for 36 decimal precision.\\n\\n            // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\\n            seriesSum *= 2;\\n\\n            // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\\n            // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\\n            // value.\\n\\n            return (sum + seriesSum) / 100;\\n        }\\n    }\\n\\n    /**\\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\\n     * for x close to one.\\n     *\\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\\n     */\\n    function _ln_36(int256 x) private pure returns (int256) {\\n        unchecked {\\n            // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\\n            // worthwhile.\\n\\n            // First, we transform x to a 36 digit fixed point value.\\n            x *= ONE_18;\\n\\n            // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\\n            // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\\n\\n            // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\\n            // division by ONE_36.\\n            int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\\n            int256 z_squared = (z * z) / ONE_36;\\n\\n            // num is the numerator of the series: the z^(2 * n + 1) term\\n            int256 num = z;\\n\\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\\n            int256 seriesSum = num;\\n\\n            // In each step, the numerator is multiplied by z^2\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 3;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 5;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 7;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 9;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 11;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 13;\\n\\n            num = (num * z_squared) / ONE_36;\\n            seriesSum += num / 15;\\n\\n            // 8 Taylor terms are sufficient for 36 decimal precision.\\n\\n            // All that remains is multiplying by 2 (non fixed point).\\n            return seriesSum * 2;\\n        }\\n    }\\n\\n    function sqrt(uint256 x) internal pure returns (uint256) {\\n        return pow(x, uint256(ONE_18) / 2);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"CheckedPriceOracle.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_relativeOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wethAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_addressToAdd\",\"type\":\"address\"}],\"name\":\"AssetForRelativePriceCheckAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_addressToRemove\",\"type\":\"address\"}],\"name\":\"AssetForRelativePriceCheckRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"assetToAdd\",\"type\":\"address\"}],\"name\":\"AssetsWithIgnorableRelativePriceCheckAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"assetToRemove\",\"type\":\"address\"}],\"name\":\"AssetsWithIgnorableRelativePriceCheckRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"GovernorChangeRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldGovernor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"GovernorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_addressToAdd\",\"type\":\"address\"}],\"name\":\"PriceLevelTWAPQuoteAssetAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_addressToRemove\",\"type\":\"address\"}],\"name\":\"PriceLevelTWAPQuoteAssetRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"RelativeOracleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_addressToAdd\",\"type\":\"address\"}],\"name\":\"TrustedSignerOracleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_addressToRemove\",\"type\":\"address\"}],\"name\":\"TrustedSignerOracleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"USDOracleUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INITIAL_MAX_PCT_WETH_USD_DEVIATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INITIAL_RELATIVE_EPSILON\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_RELATIVE_EPSILON\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetToAdd\",\"type\":\"address\"}],\"name\":\"addAssetForRelativePriceCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetToAdd\",\"type\":\"address\"}],\"name\":\"addAssetsWithIgnorableRelativePriceCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracleToAdd\",\"type\":\"address\"}],\"name\":\"addETHPriceOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_quoteAssetToAdd\",\"type\":\"address\"}],\"name\":\"addQuoteAssetsForPriceLevelTwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"changeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getETHPrices\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ethPrices\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getPriceUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"getPricesUSD\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"getPricesUSDWithMetadata\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"signedPrices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"twapPrices\",\"type\":\"uint256[]\"}],\"name\":\"getRobustWETHPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listAssetForRelativePriceCheck\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listAssetsWithIgnorableRelativePriceCheck\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listETHPriceOracles\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listQuoteAssetsForPriceLevelTwap\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPctWethUsdDeviation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingGovernor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relativeEpsilon\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relativeOracle\",\"outputs\":[{\"internalType\":\"contract IRelativePriceOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetToRemove\",\"type\":\"address\"}],\"name\":\"removeAssetForRelativePriceCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetToRemove\",\"type\":\"address\"}],\"name\":\"removeAssetsWithIgnorableRelativePriceCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracleToRemove\",\"type\":\"address\"}],\"name\":\"removeETHPriceOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_quoteAssetToRemove\",\"type\":\"address\"}],\"name\":\"removeQuoteAssetsForPriceLevelTwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxPctWethUsdDeviation\",\"type\":\"uint256\"}],\"name\":\"setMaxPctWethUsdDeviation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_relativeEpsilon\",\"type\":\"uint256\"}],\"name\":\"setRelativeMaxEpsilon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_relativeOracle\",\"type\":\"address\"}],\"name\":\"setRelativeOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdOracle\",\"type\":\"address\"}],\"name\":\"setUSDOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdOracle\",\"outputs\":[{\"internalType\":\"contract IUSDPriceOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wethAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CheckedPriceOracle", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000078ecf97572c3890ed02221a611014f30219f6219000000000000000000000000a2b76e60215617e676c6a0041b26a7c3c126db5e0000000000000000000000005ada07ff0d2772e202776be8a8ec69ac3345050f000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "london", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}