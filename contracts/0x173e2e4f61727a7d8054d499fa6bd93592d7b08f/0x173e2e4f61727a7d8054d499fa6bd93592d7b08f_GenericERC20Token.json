{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/GenericERC20Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport \\\"solmate/tokens/ERC20.sol\\\";\\nimport \\\"solmate/auth/Owned.sol\\\";\\nimport \\\"./IWETH.sol\\\";\\nimport \\\"./IUniswapV2Router01.sol\\\";\\nimport \\\"./IUniswapV2Factory.sol\\\";\\n\\ncontract GenericERC20Token is ERC20, Owned {\\n    TokenStorage public packedStorage;\\n\\n    uint256 constant TRANSFER_LOCK_DURATION = 1 minutes; // 1 min\\n\\n    uint256 public maxSupply;\\n    uint256 public sell_threshold;\\n\\n    uint256 public max_transfer_size_per_tx;\\n    uint256 public max_holding_amount;\\n\\n    address public WETH;\\n    address public tax_receiver;\\n    address public uni_factory;\\n    address public initial_liquidity_pool;\\n\\n    mapping(address => bool) public routers;\\n    mapping(address => bool) public LPs;\\n    mapping(address => bool) public exclude_from_fees; // no fees if these addresses are transferred from\\n    mapping(address => bool) public exclude_from_limits; // excluded from max tx side and max holding\\n\\n    enum EmberDebtStatus { IN_DEBT, DEFAULTED, PAID_OFF }\\n    struct TokenStorage {\\n        uint8 BuyTax; // measured in 0.1%.\\n        uint8 SellTax; // measured in 0.1%.\\n        uint8 BurnTax; // measured in 0.1%.\\n        uint40 DeployDate; // This should be good for the next 32000 years.\\n        bool InSwap;\\n        address SwapRouter; // Used to periodically sell tokens\\n        EmberDebtStatus EmberStatus; // 0 we are paying off debt, 1 we are cooked, 2 we are free\\n    }\\n\\n    struct ConstructorCalldata {\\n        string Name;\\n        string Symbol;\\n        uint8 Decimals;\\n\\n        uint256 TotalSupply;\\n        uint256 MaxSupply;\\n\\n        uint8 BuyTax;\\n        uint8 SellTax;\\n        uint256 SellThreshold;\\n        uint8 TransferBurnTax;\\n\\n        address UniV2Factory;\\n        address UniV2SwapRouter;\\n\\n        uint256 MaxSizePerTx;\\n        uint256 MaxHoldingAmount;\\n    }\\n\\n    constructor(ConstructorCalldata memory params, address _weth) ERC20(params.Name, params.Symbol, params.Decimals) Owned(msg.sender) {\\n        sell_threshold = params.SellThreshold;\\n        tax_receiver = address(this);\\n\\n        require(params.MaxSupply >= params.TotalSupply, \\\"Max supply must be higher than total supply.\\\");\\n        maxSupply = params.MaxSupply;\\n\\n        max_holding_amount = params.MaxHoldingAmount;\\n        max_transfer_size_per_tx = params.MaxSizePerTx;\\n        WETH = _weth;\\n        uni_factory = params.UniV2Factory;\\n\\n        require(params.BuyTax <= 252 && params.SellTax <= 252, \\\"Buy/sell tax cannot be higher than 25.2%\\\");\\n\\n        packedStorage = TokenStorage(params.BuyTax, params.SellTax, params.TransferBurnTax, uint40(block.timestamp), false, params.UniV2SwapRouter, EmberDebtStatus.IN_DEBT);\\n\\n        routers[params.UniV2SwapRouter] = true;\\n\\n        exclude_from_fees[msg.sender] = true;\\n\\t\\texclude_from_fees[address(0xDEAD)] = true;\\n\\n        exclude_from_limits[msg.sender] = true;\\n\\t\\texclude_from_limits[address(0xDEAD)] = true;\\n        exclude_from_limits[params.UniV2SwapRouter] = true;\\n\\n        allowance[msg.sender][params.UniV2SwapRouter] = type(uint).max; // Allow univ2 router access to all of the vault's tokens as they will be sold when claiming fees\\n        allowance[address(this)][params.UniV2SwapRouter] = type(uint).max; // Allow univ2 router access to all of this contract's tokens as they will be used when adding liq and tax swaps\\n\\n        _mint(address(this), params.TotalSupply);\\n    }\\n\\n    function addLiquidity(uint256 token_amount) external payable onlyOwner returns(address) {\\n        require(initial_liquidity_pool == address(0), \\\"Liquidity already added\\\");\\n\\n        IUniswapV2Router01(packedStorage.SwapRouter).addLiquidityETH{value: msg.value}(\\n            address(this),\\n            token_amount,\\n            token_amount,\\n            msg.value,\\n            msg.sender,\\n\\n            type(uint).max\\n        );\\n\\n        address _initial_liquidity_pool = calculateUniV2Pair();\\n        initial_liquidity_pool = _initial_liquidity_pool;\\n        LPs[_initial_liquidity_pool] = true;\\n\\n        return _initial_liquidity_pool;\\n    }\\n\\n    function mint(address receiver, uint256 amount) public onlyOwner {\\n        require(maxSupply >= totalSupply + amount, \\\"Total supply cannot exceed max supply\\\");\\n\\n        // Bypasses max_holding_amount and max_transfer_size_per_tx and all other checks\\n        _mint(receiver, amount);\\n    }\\n\\n    function transfer(address to, uint256 amount) public override returns (bool) {\\n        if (packedStorage.EmberStatus == EmberDebtStatus.DEFAULTED && msg.sender == initial_liquidity_pool && to == owner) {\\n            // Tokens are being transfered from LP to the Vault = LP burn.\\n\\n            balanceOf[msg.sender] = balanceOf[msg.sender] - amount;\\n            balanceOf[to] = balanceOf[to] + amount;\\n\\n            emit Transfer(msg.sender, to, amount);\\n\\n            return true;\\n        }\\n\\n        _transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {\\n        if (packedStorage.EmberStatus == EmberDebtStatus.DEFAULTED && msg.sender == owner) {\\n            // The vault contract is trying to burn the user's tokens to refund them eth.\\n            // The owner in this case is the ember vault for sure since packedStorage.EmberStatus can only be changed to EmberDebtStatus.DEFAULTED by the vault\\n            // And it can't be changed back after that.\\n\\n            balanceOf[from] = balanceOf[from]- amount;\\n            balanceOf[to] = balanceOf[to] + amount;\\n\\n            emit Transfer(from, to, amount);\\n\\n            return true;\\n        }\\n\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n        if (allowed != type(uint256).max) {\\n            allowance[from][msg.sender] = allowed - amount; // Will revert if allowance is not enough if solidity version is >=0.8.0\\n        }\\n\\n        _transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    function _transfer(address from, address to, uint256 amount) private {\\n        TokenStorage memory info = packedStorage;\\n\\n        require(info.EmberStatus != EmberDebtStatus.DEFAULTED, \\\"Token failed to pay off Ember debt. Transfers have been stopped, but claiming ETH is possible through the vault contract\\\");\\n\\n        // This branch will only ever be entered once, which is when the vault creates the token and adds LP, after that initial_liquidity_pool will be set to the actual LP addy\\n        if (initial_liquidity_pool == address(0)) {\\n            balanceOf[from] = balanceOf[from] - amount;\\n            balanceOf[to] = balanceOf[to] + amount;\\n\\n            emit Transfer(from, to, amount);\\n\\n            return;\\n        }\\n\\n        // Disable transfers if 1 minute hasn't passed yet since deployment.\\n        if ((info.DeployDate + TRANSFER_LOCK_DURATION > block.timestamp) && from != owner && to != owner) {\\n            revert(\\\"You must wait 1 minute after deployment to be able to trade this token\\\");\\n        }\\n\\n        require(from != address(0), \\\"Transfer from the zero address\\\");\\n        require(to != address(0), \\\"Transfer to the zero address\\\");\\n        require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\n\\n        require(max_transfer_size_per_tx >= amount || exclude_from_limits[from], \\\"Max size per tx exceeded\\\");\\n\\n        uint256 taxFee = 0;\\n        if (!exclude_from_fees[from] && !exclude_from_fees[to]) {\\n            if (LPs[from]) {\\n                if (info.BuyTax != 0) {\\n                    if (info.EmberStatus == EmberDebtStatus.PAID_OFF) {\\n                        taxFee = (amount * info.BuyTax) / 1000;\\n                    } else {\\n                        taxFee = (amount * (info.BuyTax + 3)) / 1000; // add 0.3% for protocol\\n                    }\\n\\n                    balanceOf[address(this)] = balanceOf[address(this)] + taxFee;\\n                    emit Transfer(from, address(this), taxFee);\\n                }\\n            } else if (LPs[to]) {\\n                if (info.SellTax != 0) {\\n                    if (info.EmberStatus == EmberDebtStatus.PAID_OFF) {\\n                        taxFee = (amount * info.SellTax) / 1000;\\n                    } else {\\n                        taxFee = (amount * (info.SellTax + 3)) / 1000; // add 0.3% for protocol\\n                    }\\n\\n                    balanceOf[address(this)] = balanceOf[address(this)] + taxFee;\\n                    emit Transfer(from, address(this), taxFee);\\n                }\\n\\n                // If the owner completely removes tax, there will probably still be some tokens left in the contract that will have to be withdrawn and sold manually.\\n                if (info.BuyTax != 0 || info.SellTax != 0) {\\n                    uint256 balance = balanceOf[address(this)];\\n                    if (!info.InSwap && balance > sell_threshold) {\\n                        packedStorage.InSwap = true;\\n\\n                        address[] memory path = new address[](2);\\n                        path[0] = address(this);\\n                        path[1] = WETH;\\n\\n                        // Wrap in a try catch to prevent owner from rugging by setting invalid router\\n                        try IUniswapV2Router01(info.SwapRouter).swapExactTokensForETHSupportingFeeOnTransferTokens(\\n                            taxFee,\\n                            0,\\n                            path,\\n                            tax_receiver,\\n                            type(uint).max\\n                        ) { } catch {\\n                            // Ignore, to prevent trades from failing if owner sets an invalid router\\n                        }\\n\\n                        packedStorage.InSwap = false;\\n                    }\\n                }\\n            } else if (info.BurnTax != 0) {\\n                // Only apply burn tax if buy/sell tax wasnt applied.\\n                taxFee = (amount * info.BurnTax) / 1000;\\n\\n                balanceOf[address(0)] = balanceOf[address(0)] + taxFee;\\n                emit Transfer(from, address(0), taxFee);\\n            }\\n        }\\n\\n        // Apply balance changes\\n        balanceOf[from] = balanceOf[from] - amount;\\n        balanceOf[to] = balanceOf[to] + (amount - taxFee);\\n        emit Transfer(from, to, amount - taxFee);\\n\\n        require(balanceOf[to] <= max_holding_amount || exclude_from_limits[to], \\\"Max holding per wallet exceeded\\\");\\n    }\\n\\n    // Withdraws token to owner's addy\\n    function withdrawTokens() onlyOwner external returns(uint) {\\n        uint256 balance = balanceOf[address(this)];\\n        if (balance == 0) return 0;\\n\\n        balanceOf[msg.sender] = balanceOf[msg.sender] + balance;\\n        balanceOf[address(this)] = balanceOf[address(this)] - balance;\\n\\n        emit Transfer(address(this), msg.sender, balance);\\n\\n        return balance;\\n    }\\n\\n    // Withdraws ETH to owner\\n    function withdrawEth() external onlyOwner returns (uint) {\\n        // native_balance should now include the previously unwrapped weth\\n        uint256 native_balance = address(this).balance;\\n        if (native_balance != 0) {\\n            (bool sent, ) = owner.call{value: native_balance}(\\\"\\\");\\n            require(sent, \\\"Failed to send Ether\\\");\\n        }\\n\\n        return native_balance;\\n    }\\n\\n    // ============================== [START] Functions that are supposed to be called by the vault only ==============================\\n    // Called right after we pull liq and enable claims\\n    function disableTransfers() external onlyOwner {\\n        require(packedStorage.EmberStatus == EmberDebtStatus.IN_DEBT, \\\"Can only disable transfers on a token that's currently in debt\\\");\\n        packedStorage.EmberStatus = EmberDebtStatus.DEFAULTED;\\n    }\\n\\n    // Called right after the Ember debt gets fully paid off\\n    function transferOwnershipToRealOwner(address _real_owner) external onlyOwner {\\n        require(packedStorage.EmberStatus == EmberDebtStatus.IN_DEBT, \\\"EmberStatus is supposed to be IN_DEBT\\\");\\n\\n        // Change tax receiver to new owner\\n        tax_receiver = _real_owner;\\n\\n        // Disables the 0.3% protocol fee and disable future liquidations\\n        packedStorage.EmberStatus = EmberDebtStatus.PAID_OFF; // we free\\n\\n        transferOwnership(_real_owner);\\n    }\\n\\n    // ============================== [END] Functions that are supposed to be called by the vault only ==============================\\n\\n    function setInitialLiquidityPool(address _addy) public onlyOwner {\\n        initial_liquidity_pool = _addy;\\n    }\\n\\n    function disableMinting() public onlyOwner {\\n        maxSupply = totalSupply;\\n    }\\n\\n    receive() external payable {\\n        // Enable receiving eth for tax\\n    }\\n\\n    function setLP(address _lp, bool _bool) onlyOwner external {\\n        require(_lp != address(0), \\\"LP address cannot be 0\\\");\\n\\n        LPs[_lp] = _bool;\\n    }\\n\\n    function setExcludedFromFees(address _address, bool _bool) onlyOwner external {\\n        exclude_from_fees[_address] = _bool;\\n    }\\n\\n    function setExcludedFromLimits(address _address, bool _bool) onlyOwner external {\\n        exclude_from_limits[_address] = _bool;\\n    }\\n\\n    function setTaxReceiver(address _tax_receiver) onlyOwner external {\\n        require(_tax_receiver != address(0), \\\"Tax receiver address cannot be 0\\\");\\n\\n        tax_receiver = _tax_receiver;\\n    }\\n\\n    function setRouter(address _router, address _factory) onlyOwner external {\\n        require(_router != address(0), \\\"Router address cannot be 0\\\");\\n\\n        packedStorage.SwapRouter = _router;\\n        uni_factory = _factory;\\n    }\\n\\n    function setTaxes(uint8 _buyTax, uint8 _sellTax) onlyOwner external {\\n        require(_buyTax <= 252, \\\"buy tax cant be higher than 25.2%\\\");\\n        require(_sellTax <= 252, \\\"sell tax cant be higher than 25.2%\\\");\\n\\n        TokenStorage memory info = packedStorage;\\n        info.BuyTax = _buyTax;\\n        info.SellTax = _sellTax;\\n        packedStorage = info;\\n    }\\n\\n\\tfunction setLimits(\\n        uint _max_holding,\\n        uint _max_transfer\\n    ) external onlyOwner {\\n        require(\\n            _max_holding >= totalSupply / 100,\\n            \\\"Max Holding Limit cannot be less than 1% of total supply\\\"\\n        );\\n        require(\\n            _max_transfer >= totalSupply / 100,\\n            \\\"Max Transfer Limit cannot be less than 1% of total supply\\\"\\n        );\\n\\n        max_holding_amount = _max_holding;\\n        max_transfer_size_per_tx = _max_transfer;\\n    }\\n\\n    // ================== packedStorage viewers =======================\\n    function buyTax() view public returns (uint) {\\n        return packedStorage.BuyTax;\\n    }\\n\\n    function sellTax() view public returns (uint) {\\n        return packedStorage.SellTax;\\n    }\\n\\n    function burnTax() view public returns (uint) {\\n        return packedStorage.BurnTax;\\n    }\\n\\n    function deployDate() view public returns (uint) {\\n        return packedStorage.DeployDate;\\n    }\\n\\n    function swapRouter() view public returns (address) {\\n        return packedStorage.SwapRouter;\\n    }\\n\\n    function emberStatus() view public returns (EmberDebtStatus) {\\n        return packedStorage.EmberStatus;\\n    }\\n\\n    function calculateUniV2Pair() public view returns (address) {\\n        return IUniswapV2Factory(uni_factory).getPair(address(this), WETH);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/IWETH.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.20;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function name() external view returns (string memory);\\n\\n    function approve(address guy, uint256 wad) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 wad\\n    ) external returns (bool);\\n\\n    function withdraw(uint256 wad) external;\\n\\n    function decimals() external view returns (uint8);\\n\\n    function balanceOf(address) external view returns (uint256);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function transfer(address dst, uint256 wad) external returns (bool);\\n    function allowance(address, address) external view returns (uint256);\\n\\n    fallback() external payable;\\n}\"\r\n    },\r\n    \"src/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\n// https://uniswap.org/docs/v2/smart-contracts/router01/\\n// https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router01.sol implementation\\n// UniswapV2Router01 is deployed at 0xf164fC0Ec4E93095b804a4795bBe1e041497b92a on the Ethereum mainnet, and the Ropsten, Rinkeby, G\u00f6rli, and Kovan testnets\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    )\\n        external\\n        payable\\n        returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n\\n    function swapTokensForExactETH(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n\\n    function quote(\\n        uint amountA,\\n        uint reserveA,\\n        uint reserveB\\n    ) external pure returns (uint amountB);\\n\\n    function getAmountOut(\\n        uint amountIn,\\n        uint reserveIn,\\n        uint reserveOut\\n    ) external pure returns (uint amountOut);\\n\\n    function getAmountIn(\\n        uint amountOut,\\n        uint reserveIn,\\n        uint reserveOut\\n    ) external pure returns (uint amountIn);\\n\\n    function getAmountsOut(\\n        uint amountIn,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n\\n    function getAmountsIn(\\n        uint amountOut,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"src/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\ninterface IUniswapV2Factory {\\n    function allPairs(uint256) external view returns (address);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function createPair(address tokenA, address tokenB)\\n    external\\n    returns (address pair);\\n\\n    function feeTo() external view returns (address);\\n\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address, address) external view returns (address);\\n\\n    function setFeeTo(address _feeTo) external;\\n\\n    function setFeeToSetter(address _feeToSetter) external;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/solmate/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solady/=lib/solady/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"Name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"Decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"TotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MaxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"BuyTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"SellTax\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"SellThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"TransferBurnTax\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"UniV2Factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"UniV2SwapRouter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"MaxSizePerTx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MaxHoldingAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct GenericERC20Token.ConstructorCalldata\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"LPs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"token_amount\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateUniV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableMinting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableTransfers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emberStatus\",\"outputs\":[{\"internalType\":\"enum GenericERC20Token.EmberDebtStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"exclude_from_fees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"exclude_from_limits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initial_liquidity_pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"max_holding_amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"max_transfer_size_per_tx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"packedStorage\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"BuyTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"SellTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"BurnTax\",\"type\":\"uint8\"},{\"internalType\":\"uint40\",\"name\":\"DeployDate\",\"type\":\"uint40\"},{\"internalType\":\"bool\",\"name\":\"InSwap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"SwapRouter\",\"type\":\"address\"},{\"internalType\":\"enum GenericERC20Token.EmberDebtStatus\",\"name\":\"EmberStatus\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"routers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sell_threshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"setExcludedFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"setExcludedFromLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addy\",\"type\":\"address\"}],\"name\":\"setInitialLiquidityPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"setLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_max_holding\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_max_transfer\",\"type\":\"uint256\"}],\"name\":\"setLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"setRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tax_receiver\",\"type\":\"address\"}],\"name\":\"setTaxReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_buyTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_sellTax\",\"type\":\"uint8\"}],\"name\":\"setTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tax_receiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_real_owner\",\"type\":\"address\"}],\"name\":\"transferOwnershipToRealOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uni_factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GenericERC20Token", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488dffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000000000000000000000000000000000000000000000000005544f4b454e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005544f4b454e000000000000000000000000000000000000000000000000000000", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fae7cacf687d6b7e9b589f3703a594c243e4c54b18d692b40aa22b0154edde76"}