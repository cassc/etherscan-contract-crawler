{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/modules/common/IModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title IModule\\n * @notice Interface for a Module.\\n */\\ninterface IModule {\\n\\n    /**\\t\\n     * @notice Adds a module to a vault. Cannot execute when vault is locked (or under recovery)\\t\\n     * @param _vault The target vault.\\t\\n     * @param _module The modules to authorise.\\t\\n     */\\t\\n    function addModule(address _vault, address _module, bytes memory _initData) external;\\n\\n    /**\\n     * @notice Inits a Module for a vault by e.g. setting some vault specific parameters in storage.\\n     * @param _vault The target vault.\\n     * @param _initData - Data to be initialised specific to a module when it is authorized.\\n     */\\n    function init(address _vault, bytes calldata _initData) external;\\n\\n\\n    /**\\n     * @notice Returns whether the module implements a callback for a given static call method.\\n     * @param _methodId The method id.\\n     */\\n    function supportsStaticCall(bytes4 _methodId) external view returns (bool _isSupported);\\n}\"\r\n    },\r\n    \"contracts/vault/BaseVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"../modules/common/IModule.sol\\\";\\nimport \\\"./IVault.sol\\\";\\n// import \\\"hardhat/console.sol\\\";\\n\\n/**\\n * @title BaseVault\\n * @notice Simple modular vault that authorises modules to call its invoke() method.\\n */\\ncontract BaseVault is IVault {\\n\\n    // Zero address\\n    address constant internal ZERO_ADDRESS = address(0);\\n    // The owner\\n    address public owner;\\n    // The authorised modules\\n    mapping (address => bool) public authorised;\\n    // module executing static calls\\n    address public staticCallExecutor;\\n    // The number of modules\\n    uint256 public modules;\\n\\n    event AuthorisedModule(address indexed module, bool value);\\n    event Invoked(address indexed module, address indexed target, uint256 indexed value, bytes data);\\n    event Received(uint256 indexed value, address indexed sender, bytes data);\\n    event StaticCallEnabled(address indexed module);\\n\\n    /**\\n     * @notice Throws if the sender is not an authorised module.\\n     */\\n    modifier moduleOnly {\\n        require(authorised[msg.sender], \\\"BV: sender not authorized\\\");\\n        _;\\n    }\\n\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    /**\\n     * @notice Inits the vault by setting the owner and authorising a list of modules.\\n     * @param _owner The owner.\\n     * @param _initData bytes32 initialization data specific to the module.\\n     * @param _modules The modules to authorise.\\n     */\\n    function init(address _owner, address[] calldata _modules, bytes[] calldata _initData) external {\\n        uint256 len = _modules.length;\\n        require(owner == ZERO_ADDRESS, \\\"BV: vault already initialised\\\");\\n        require(_owner != ZERO_ADDRESS, \\\"BV: Invalid address\\\");\\n        require(len > 0, \\\"BV: empty modules\\\");\\n        require(_initData.length == len, \\\"BV: inconsistent lengths\\\");\\n        owner = _owner;\\n        modules = len;\\n        for (uint256 i = 0; i < len; i++) {\\n            require(_modules[i] != ZERO_ADDRESS, \\\"BV: Invalid address\\\");\\n            require(!authorised[_modules[i]], \\\"BV: Invalid module\\\");\\n            authorised[_modules[i]] = true;\\n            IModule(_modules[i]).init(address(this), _initData[i]);\\n            emit AuthorisedModule(_modules[i], true);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IVault\\n     */\\n    function authoriseModule(\\n        address _module,\\n        bool _value,\\n        bytes memory _initData\\n    ) \\n        external\\n        moduleOnly\\n    {\\n        if (authorised[_module] != _value) {\\n            emit AuthorisedModule(_module, _value);\\n            if (_value) {\\n                modules += 1;\\n                authorised[_module] = true;\\n                IModule(_module).init(address(this), _initData);\\n            } else {\\n                modules -= 1;\\n                require(modules > 0, \\\"BV: cannot remove last module\\\");\\n                delete authorised[_module];\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @inheritdoc IVault\\n    */\\n    function enabled(bytes4 _sig) public view returns (address) {\\n        address executor = staticCallExecutor;\\n        if(executor != ZERO_ADDRESS && IModule(executor).supportsStaticCall(_sig)) {\\n            return executor;\\n        }\\n        return ZERO_ADDRESS;\\n    }\\n\\n    /**\\n    * @inheritdoc IVault\\n    */\\n    function enableStaticCall(address _module) external moduleOnly {\\n        if(staticCallExecutor != _module) {\\n            require(authorised[_module], \\\"BV: unauthorized executor\\\");\\n            staticCallExecutor = _module;\\n            emit StaticCallEnabled(_module);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IVault\\n     */\\n    function setOwner(address _newOwner) external moduleOnly {\\n        require(_newOwner != ZERO_ADDRESS, \\\"BV: address cannot be null\\\");\\n        owner = _newOwner;\\n    }\\n\\n    /**\\n     * @notice Performs a generic transaction.\\n     * @param _target The address for the transaction.\\n     * @param _value The value of the transaction.\\n     * @param _data The data of the transaction.\\n     * @return _result The bytes result after call.\\n     */\\n    function invoke(\\n        address _target,\\n        uint256 _value,\\n        bytes calldata _data\\n    ) \\n        external \\n        moduleOnly \\n        returns(bytes memory _result) \\n    {\\n        bool success;\\n        require(address(this).balance >= _value, \\\"BV: Insufficient balance\\\");\\n        emit Invoked(msg.sender, _target, _value, _data);\\n        (success, _result) = _target.call{value: _value}(_data);\\n        if (!success) {\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice This method delegates the static call to a target contract if the data corresponds\\n     * to an enabled module, or logs the call otherwise.\\n     */\\n    fallback() external payable {\\n        address module = enabled(msg.sig);\\n        if (module == ZERO_ADDRESS) {\\n            emit Received(msg.value, msg.sender, msg.data);\\n        } else {\\n            require(authorised[module], \\\"BV: unauthorised module\\\");\\n\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                calldatacopy(0, 0, calldatasize())\\n                let result := staticcall(gas(), module, 0, calldatasize(), 0, 0)\\n                returndatacopy(0, 0, returndatasize())\\n                switch result\\n                case 0 {revert(0, returndatasize())}\\n                default {return (0, returndatasize())}\\n            }\\n        }\\n    }\\n\\n    receive() external payable {\\n        emit Received(msg.value, msg.sender, \\\"\\\");\\n    }\\n}\"\r\n    },\r\n    \"contracts/vault/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title IVault\\n * @notice Interface for the BaseVault\\n */\\ninterface IVault {\\n\\n    /**\\n     * @notice Enables/Disables a module.\\n     * @param _module The target module.\\n     * @param _value Set to `true` to authorise the module.\\n     */\\n    function authoriseModule(address _module, bool _value, bytes memory _initData) external;\\n\\n    /**\\n     * @notice Enables a static method by specifying the target module to which the call must be delegated.\\n     * @param _module The target module.\\n     */\\n    function enableStaticCall(address _module) external;\\n\\n\\n    /**\\n     * @notice Inits the vault by setting the owner and authorising a list of modules.\\n     * @param _owner The owner.\\n     * @param _initData bytes32 initialization data specific to the module.\\n     * @param _modules The modules to authorise.\\n     */\\n    function init(address _owner, address[] calldata _modules, bytes[] calldata _initData) external;\\n\\n    /**\\n     * @notice Sets a new owner for the vault.\\n     * @param _newOwner The new owner.\\n     */\\n    function setOwner(address _newOwner) external;\\n\\n    /**\\n     * @notice Returns the vault owner.\\n     * @return The vault owner address.\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice Returns the number of authorised modules.\\n     * @return The number of authorised modules.\\n     */\\n    function modules() external view returns (uint256);\\n\\n    /**\\n     * @notice Checks if a module is authorised on the vault.\\n     * @param _module The module address to check.\\n     * @return `true` if the module is authorised, otherwise `false`.\\n     */\\n    function authorised(address _module) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the module responsible, if static call is enabled for `_sig`, otherwise return zero address.\\n     * @param _sig The signature of the static call.\\n     * @return the module doing the redirection or zero address\\n     */\\n    function enabled(bytes4 _sig) external view returns (address);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"AuthorisedModule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Invoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"StaticCallEnabled\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"_initData\",\"type\":\"bytes\"}],\"name\":\"authoriseModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorised\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"}],\"name\":\"enableStaticCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_sig\",\"type\":\"bytes4\"}],\"name\":\"enabled\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_modules\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_initData\",\"type\":\"bytes[]\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"invoke\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"_result\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"modules\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staticCallExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BaseVault", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}