{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/InverseBondingCurveRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.18;\\n\\nimport \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\nimport \\\"openzeppelin/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"openzeppelin/utils/Address.sol\\\";\\nimport \\\"./Enums.sol\\\";\\nimport \\\"./Errors.sol\\\";\\nimport \\\"./interface/IWETH9.sol\\\";\\nimport \\\"./interface/IInverseBondingCurve.sol\\\";\\n\\ncontract InverseBondingCurveRouter {\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n    using Address for address payable;\\n\\n    IWETH9 private _weth;\\n\\n    constructor(address wethAddress) {\\n        _weth = IWETH9(wethAddress);\\n    }\\n\\n    /**\\n     * @notice  Execute curve function with wrap/unwrap\\n     * @dev     \\n     * @param   recipient : Recipient to receive token\\n     * @param   curve : Curve contract to execute function\\n     * @param   useNative : Whether using native token(ETH)\\n     * @param   command : Action command to execute\\n     * @param   data : Call data of the function call\\n     */\\n    function execute(address recipient, address curve, bool useNative, CommandType command, bytes memory data) external payable {\\n        IInverseBondingCurve curveContract = IInverseBondingCurve(curve);\\n        IERC20 reserveToken = IERC20(curveContract.reserveTokenAddress());\\n        IERC20 inverseToken = IERC20(curveContract.inverseTokenAddress());\\n        // Send back ether if not using ETH for input token\\n        if (msg.value > 0) {\\n            if (useNative && address(reserveToken) == address(_weth)) {\\n                _weth.deposit{value: msg.value}();\\n                IERC20(_weth).safeTransfer(curve, msg.value);\\n            } else {\\n                revert EtherNotAccept();\\n            }\\n        }\\n\\n        uint256 reserveBalanceBefore = reserveToken.balanceOf(address(this));\\n        uint256 inverseBalanceBefore = inverseToken.balanceOf(address(this));\\n        _payAndExecute(recipient, curve, useNative, command, reserveToken, inverseToken, data);\\n        uint256 reserveBalanceAfter = reserveToken.balanceOf(address(this));\\n        uint256 inverseBalanceAfter = inverseToken.balanceOf(address(this));\\n\\n        if (inverseBalanceAfter > inverseBalanceBefore) {\\n            inverseToken.safeTransfer(recipient, inverseBalanceAfter - inverseBalanceBefore);\\n        }\\n\\n        if (reserveBalanceAfter > reserveBalanceBefore) {\\n            uint256 amountToUser = reserveBalanceAfter - reserveBalanceBefore;\\n            if (useNative && address(reserveToken) == address(_weth)) {\\n                _weth.withdraw(amountToUser);\\n                payable(recipient).sendValue(amountToUser);\\n            } else {\\n                reserveToken.safeTransfer(recipient, amountToUser);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice  Pay curve contract and execute action\\n     * @dev     \\n     * @param   recipient : Recipient to receive token\\n     * @param   curve : Curve contract to execute function\\n     * @param   useNative : Whether using native token(ETH)\\n     * @param   command : Action command to execute\\n     * @param   reserveToken : Reserve token contract address\\n     * @param   inverseToken : Inverse token contract address\\n     * @param   data : Call data of the function call\\n     */\\n    function _payAndExecute(\\n        address recipient,\\n        address curve,\\n        bool useNative,\\n        CommandType command,\\n        IERC20 reserveToken,\\n        IERC20 inverseToken,\\n        bytes memory data\\n    ) private {\\n        (uint256 reserveTokenAmount, uint256 inverseTokenAmount, bytes memory curveCallData) = _getInputAndCallData(command, data);\\n\\n        if (reserveTokenAmount > 0) {\\n            if (!useNative) {\\n                reserveToken.safeTransferFrom(recipient, curve, reserveTokenAmount);\\n            }\\n        }\\n        if (inverseTokenAmount > 0) {\\n            inverseToken.safeTransferFrom(recipient, curve, inverseTokenAmount);\\n        }\\n\\n        curve.functionCall(curveCallData);\\n    }\\n\\n    /**\\n     * @notice  Get token input amount and calldata to curve contract\\n     * @dev     \\n     * @param   command : Action command to execute\\n     * @param   data : Function call data parameters\\n     * @return  reserveTokenAmount : Reserve token amount need to transfer to curve contract\\n     * @return  inverseTokenAmount : Inverse token amount need to transfer to curve contract\\n     * @return  curveCallData : Call data of the function call\\n     */\\n    function _getInputAndCallData(CommandType command, bytes memory data)\\n        private\\n        view\\n        returns (uint256 reserveTokenAmount, uint256 inverseTokenAmount, bytes memory curveCallData)\\n    {\\n        if (command == CommandType.ADD_LIQUIDITY) {\\n            (address recipient, uint256 reserveIn, uint256[2] memory priceLimits) =\\n                abi.decode(data, (address, uint256, uint256[2]));\\n            reserveTokenAmount = reserveIn;\\n            curveCallData = abi.encodeWithSignature(\\\"addLiquidity(address,uint256,uint256[2])\\\", recipient, reserveIn, priceLimits);\\n        } else if (command == CommandType.REMOVE_LIQUIDITY) {\\n            (, uint256 inverseTokenIn, uint256[2] memory priceLimits) = abi.decode(data, (address, uint256, uint256[2]));\\n            inverseTokenAmount = inverseTokenIn;\\n            curveCallData =\\n                abi.encodeWithSignature(\\\"removeLiquidity(address,uint256,uint256[2])\\\", msg.sender, inverseTokenIn, priceLimits);\\n        } else if (command == CommandType.BUY_TOKEN) {\\n            (, uint256 reserveIn, uint256 exactAmountOut, uint256[2] memory priceLimits, uint256[2] memory reserveLimits) =\\n                abi.decode(data, (address, uint256, uint256, uint256[2], uint256[2]));\\n            reserveTokenAmount = reserveIn;\\n            curveCallData = abi.encodeWithSignature(\\\"buyTokens(address,uint256,uint256,uint256[2],uint256[2])\\\",\\n                msg.sender, reserveIn, exactAmountOut, priceLimits, reserveLimits);\\n        } else if (command == CommandType.SELL_TOKEN) {\\n            (, uint256 inverseTokenIn, uint256[2] memory priceLimits, uint256[2] memory reserveLimits) =\\n                abi.decode(data, (address, uint256, uint256[2], uint256[2]));\\n            inverseTokenAmount = inverseTokenIn;\\n            curveCallData = abi.encodeWithSignature(\\n                \\\"sellTokens(address,uint256,uint256[2],uint256[2])\\\", msg.sender, inverseTokenIn, priceLimits, reserveLimits\\n            );\\n        } else if (command == CommandType.CLAIM_REWARD) {\\n            curveCallData = abi.encodeWithSignature(\\\"claimReward(address)\\\", msg.sender);\\n        } else if (command == CommandType.STAKE) {\\n            (, uint256 amount) = abi.decode(data, (address, uint256));\\n            inverseTokenAmount = amount;\\n            curveCallData = abi.encodeWithSignature(\\\"stake(address,uint256)\\\", msg.sender, amount);\\n        } else if (command == CommandType.UNSTAKE) {\\n            (, uint256 amount) = abi.decode(data, (address, uint256));\\n            curveCallData = abi.encodeWithSignature(\\\"unstake(address,uint256)\\\", msg.sender, amount);\\n        } else {\\n            revert CommandUnsupport();\\n        }\\n    }\\n\\n    receive() external payable {\\n        if(msg.sender != address(_weth)){\\n            revert DepositNotAllowed();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Enums.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.18;\\n\\nenum RewardType {\\n    LP, // 0\\n    STAKING, // 1\\n    PROTOCOL // 2\\n}\\n\\nenum ActionType {\\n    BUY_TOKEN,\\n    SELL_TOKEN,\\n    ADD_LIQUIDITY,\\n    REMOVE_LIQUIDITY\\n}\\n\\nenum FeeType {\\n    IBC_FROM_TRADE,\\n    IBC_FROM_LP, // Fee reward from LP removal(only when mint token to LP)\\n    RESERVE\\n}\\n\\nenum CommandType {\\n    BUY_TOKEN,\\n    SELL_TOKEN,\\n    ADD_LIQUIDITY,\\n    REMOVE_LIQUIDITY,\\n    CLAIM_REWARD,\\n    STAKE,\\n    UNSTAKE\\n}\\n\"\r\n    },\r\n    \"src/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.18;\\n\\nerror InputAmountTooSmall(uint256 amount);\\nerror InputAmountTooLarge(uint256 amount);\\nerror ParameterZeroNotAllowed();\\nerror PriceOutOfLimit(uint256 price, uint256[2] priceLimit);\\nerror ReserveOutOfLimit(uint256 reserve, uint256[2] reserveLimit);\\nerror UtilizationInvalid(uint256 parameterUtilization);\\nerror InsufficientBalance();\\nerror EmptyAddress();\\nerror FeePercentOutOfRange();\\nerror FailToSend(address recipient);\\nerror FailToExecute(address pool, bytes data);\\nerror InvalidInput();\\nerror Unauthorized();\\nerror InvariantChanged(uint256 invariant, uint256 newInvariant);\\nerror UtilizationChanged(uint256 newUtilization);\\nerror LpAlreadyExist();\\nerror LpNotExist();\\nerror PoolAlreadyExist();\\nerror CommandUnsupport();\\nerror EtherNotAccept();\\nerror DepositNotAllowed();\\nerror InputBalanceNotMatch();\\n\"\r\n    },\r\n    \"src/interface/IWETH9.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.4;\\n\\nimport \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\n/// @title Interface for WETH9\\ninterface IWETH9 is IERC20 {\\n    /// @notice Deposit ether to get wrapped ether\\n    function deposit() external payable;\\n\\n    /// @notice Withdraw wrapped ether to get ether\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"src/interface/IInverseBondingCurve.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.18;\\n\\nimport \\\"../CurveParameter.sol\\\";\\nimport \\\"../Enums.sol\\\";\\nimport \\\"../Constants.sol\\\";\\n\\n/**\\n * @title   : Inverse bonding curve contract interface\\n * @dev\\n * @notice\\n */\\n\\ninterface IInverseBondingCurve {\\n    /// EVENTS ///\\n    /**\\n     * @notice  Emitted when curve is initialized\\n     * @dev     Curve is initialized by deployer contract and initial parameters\\n     * @param   from : Which account initialized curve contract\\n     * @param   reserve : Initial reserve\\n     * @param   supply : Initial supply credit to fee owner\\n     * @param   initialPrice : Initial IBC token price\\n     * @param   parameterInvariant : Parameter invariant which won't change during buy/sell: Reserve/ (Supply ** utilization)\\n     */\\n    event CurveInitialized(\\n        address indexed from,\\n        address indexed reserveTokenAddress,\\n        uint256 reserve,\\n        uint256 supply,\\n        uint256 initialPrice,\\n        uint256 parameterInvariant\\n    );\\n\\n    /**\\n     * @notice  Emitted when new LP position added\\n     * @dev     Virtual credited IBC token is assigned to LP\\n     * @param   from : Account to create LP position\\n     * @param   recipient : Account to receive LP position and LP reward\\n     * @param   amountIn : Reserve amount\\n     * @param   amountOut : LP token amount\\n     * @param   newParameterInvariant : New parameter invariant after LP added\\n     */\\n    event LiquidityAdded(\\n        address indexed from, address indexed recipient, uint256 amountIn, uint256 amountOut, uint256 newParameterInvariant\\n    );\\n\\n    /**\\n     * @notice  Emitted when LP position removed\\n     * @dev     Mint IBC to LP if inverseTokenCredit > inverseTokenBurned, otherwise burn IBC from LP\\n     * @param   from : The account to burn LP\\n     * @param   recipient : The account to receive reserve\\n     * @param   amountIn : The LP token amount burned\\n     * @param   reserveAmountOut : Reserve send to recipient\\n     * @param   inverseTokenCredit : IBC token credit\\n     * @param   inverseTokenBurned : IBC token debt which need to burn\\n     * @param   newParameterInvariant : New parameter invariant after LP removed\\n     */\\n    event LiquidityRemoved(\\n        address indexed from,\\n        address indexed recipient,\\n        uint256 amountIn,\\n        uint256 reserveAmountOut,\\n        uint256 inverseTokenCredit,\\n        uint256 inverseTokenBurned,\\n        uint256 newParameterInvariant\\n    );\\n\\n    /**\\n     * @notice  Emitted when token staked\\n     * @dev\\n     * @param   from : Staked from account\\n     * @param   recipient : Account to stake for, the staked token holder will be changed to recipient\\n     * @param   amount : Staked token amount\\n     */\\n    event TokenStaked(address indexed from, address indexed recipient, uint256 amount);\\n\\n    /**\\n     * @notice  Emitted when token unstaked\\n     * @dev\\n     * @param   from : Unstaked from account\\n     * @param   recipient : Account to receive the unstaked IBC token\\n     * @param   amount : Unstaked token amount\\n     */\\n    event TokenUnstaked(address indexed from, address indexed recipient, uint256 amount);\\n\\n    /**\\n     * @notice  Emitted when token bought by user\\n     * @dev\\n     * @param   from : Buy from account\\n     * @param   recipient : Account to receive IBC token\\n     * @param   amountIn : Reserve amount provided\\n     * @param   amountOut : IBC token bought\\n     */\\n    event TokenBought(address indexed from, address indexed recipient, uint256 amountIn, uint256 amountOut);\\n\\n    /**\\n     * @notice  Emitted when token sold by user\\n     * @dev\\n     * @param   from : Sell from account\\n     * @param   recipient : Account to receive reserve\\n     * @param   amountIn : IBC amount provided\\n     * @param   amountOut : Reserve amount received\\n     */\\n    event TokenSold(address indexed from, address indexed recipient, uint256 amountIn, uint256 amountOut);\\n\\n    /**\\n     * @notice  Emitted when reward claimed\\n     * @dev\\n     * @param   from : Claim from account\\n     * @param   recipient : Account to recieve reward\\n     * @param   inverseTokenAmount : IBC token amount of reward\\n     * @param   reserveAmount : Reserve amount of reward\\n     */\\n    event RewardClaimed(address indexed from, address indexed recipient, uint256 inverseTokenAmount, uint256 reserveAmount);\\n\\n    /**\\n     * @notice  Add reserve liquidity to inverse bonding curve\\n     * @dev     LP will get virtual LP token(non-transferable), and one account can only hold one LP position(Need to close and reopen if user want to change)\\n     * @param   recipient : Account to receive LP token\\n     * @param   priceLimits : [minPriceLimit, maxPriceLimit], if maxPriceLimit = 0, then no limitation for max price\\n     */\\n    function addLiquidity(address recipient, uint256 reserveIn, uint256[2] memory priceLimits) external;\\n\\n    /**\\n     * @notice  Remove reserve liquidity from inverse bonding curve\\n     * @dev     IBC token may needed to burn LP\\n     * @param   recipient : Account to receive reserve\\n     * @param   priceLimits :[minPriceLimit, maxPriceLimit], if maxPriceLimit = 0, then no limitation for max price\\n     */\\n    function removeLiquidity(address recipient, uint256 inverseTokenIn, uint256[2] memory priceLimits) external;\\n\\n    /**\\n     * @notice  Buy IBC token with reserve\\n     * @dev     If exactAmountOut greater than zero, then it will mint exact token to recipient\\n     * @param   recipient : Account to receive IBC token\\n     * @param   exactAmountOut : Exact amount IBC token to mint to user\\n     * @param   priceLimits : [minPriceLimit, maxPriceLimit], if maxPriceLimit = 0, then no limitation for max price\\n     * @param   reserveLimits : [minReserveLimit, maxReserveLimit], if maxReserveLimit = 0, then no limitation for max reserve\\n     */\\n    function buyTokens(\\n        address recipient,\\n        uint256 reserveIn,\\n        uint256 exactAmountOut,\\n        uint256[2] memory priceLimits,\\n        uint256[2] memory reserveLimits\\n    ) external;\\n\\n    /**\\n     * @notice  Sell IBC token to get reserve back\\n     * @dev\\n     * @param   recipient : Account to receive reserve\\n     * @param   inverseTokenIn : IBC token amount to sell\\n     * @param   priceLimits : [minPriceLimit, maxPriceLimit], if maxPriceLimit = 0, then no limitation for max price\\n     * @param   reserveLimits : [minReserveLimit, maxReserveLimit], if maxReserveLimit = 0, then no limitation for max reserve\\n     */\\n    function sellTokens(address recipient, uint256 inverseTokenIn, uint256[2] memory priceLimits, uint256[2] memory reserveLimits)\\n        external;\\n\\n    /**\\n     * @notice  Stake IBC token to get fee reward\\n     * @dev\\n     * @param   amount : Token amount to stake\\n     */\\n    function stake(address recipient, uint256 amount) external;\\n\\n    /**\\n     * @notice  Unstake staked IBC token\\n     * @dev\\n     * @param   amount : Token amount to unstake\\n     */\\n    function unstake(address recipient, uint256 amount) external;\\n\\n    /**\\n     * @notice  Claim fee reward\\n     * @dev\\n     * @param   recipient : Account to receive fee reward\\n     */\\n    function claimReward(address recipient) external;\\n\\n    /**\\n     * @notice  Query LP position\\n     * @dev\\n     * @param   account : Account to query position\\n     * @return  lpTokenAmount : LP virtual token amount\\n     * @return  inverseTokenCredit : IBC token credited(Virtual, not able to sell/stake/transfer)\\n     */\\n    function liquidityPositionOf(address account) external view returns (uint256 lpTokenAmount, uint256 inverseTokenCredit);\\n\\n    /**\\n     * @notice  Query staking balance\\n     * @dev\\n     * @param   account : Account address to query\\n     * @return  uint256 : Staking balance\\n     */\\n    function stakingBalanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @notice  Get IBC token contract address\\n     * @dev\\n     * @return  address : IBC token contract address\\n     */\\n    function inverseTokenAddress() external view returns (address);\\n\\n    /**\\n     * @notice  Query reserve token contract address\\n     * @dev     \\n     * @return  address : Reserve token address of curve\\n     */\\n    function reserveTokenAddress() external view returns (address);\\n\\n    /**\\n     * @notice  Query current inverse bonding curve parameter\\n     * @dev\\n     * @return  parameters : See CurveParameter for detail\\n     */\\n    function curveParameters() external view returns (CurveParameter memory parameters);\\n\\n    /**\\n     * @notice  Query reward of account\\n     * @dev\\n     * @param   recipient : Account to query\\n     * @return  inverseTokenForLp : IBC token reward for account as LP\\n     * @return  inverseTokenForStaking : IBC token reward for account as Staker\\n     * @return  reserveForLp : Reserve reward for account as LP\\n     * @return  reserveForStaking : Reserve reward for account as Staker\\n     */\\n    function rewardOf(address recipient)\\n        external\\n        view\\n        returns (uint256 inverseTokenForLp, uint256 inverseTokenForStaking, uint256 reserveForLp, uint256 reserveForStaking);\\n\\n    /**\\n     * @notice  Query total staked IBC token amount\\n     * @dev\\n     * @return  uint256 : Total staked amount\\n     */\\n    function totalStaked() external view returns (uint256);\\n\\n    /**\\n     * @notice  Query EMA(exponential moving average) reward per second\\n     * @dev\\n     * @param   rewardType : Reward type: LP or staking\\n     * @return  inverseTokenReward : EMA IBC token reward per second\\n     * @return  reserveReward : EMA reserve reward per second\\n     */\\n    function rewardEMAPerSecond(RewardType rewardType) external view returns (uint256 inverseTokenReward, uint256 reserveReward);\\n\\n    /**\\n     * @notice  Query fee state\\n     * @dev     Each array contains value for IBC, IBC from LP removal, Reserve, and each sub array for LP/Staker/Protocol\\n     * @return  totalReward : Total IBC token reward\\n     * @return  totalPendingReward : IBC token reward not claimed\\n     */\\n    function rewardState()\\n        external\\n        view\\n        returns (\\n            uint256[MAX_FEE_TYPE_COUNT][MAX_FEE_STATE_COUNT] memory totalReward,\\n            uint256[MAX_FEE_TYPE_COUNT][MAX_FEE_STATE_COUNT] memory totalPendingReward\\n        );\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"src/CurveParameter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.18;\\n\\nstruct CurveParameter {\\n    uint256 reserve;\\n    uint256 supply;\\n    uint256 lpSupply;\\n    uint256 price;\\n    uint256 parameterInvariant;\\n}\\n\"\r\n    },\r\n    \"src/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.18;\\n\\nuint256 constant MIN_INPUT_AMOUNT = 1e14; // 0.0001\\nuint256 constant MAX_INPUT_AMOUNT = 1e33;\\nuint256 constant MIN_RESERVE_DEDUCTION = 1e3;\\nuint256 constant INITIAL_RESERVE_DEDUCTION_DIVIDER = 1e4;\\nuint256 constant DEFAULT_DECIMALS = 18;\\nuint256 constant UINT_ONE = 1e18;\\nuint256 constant UINT_TWO = 2e18;\\nuint256 constant UINT_FOUR = 4e18;\\nuint256 constant LP_FEE_PERCENT = 25e14;\\nuint256 constant STAKE_FEE_PERCENT = 25e14;\\nuint256 constant PROTOCOL_FEE_PERCENT = 5e15;\\nuint256 constant MAX_FEE_PERCENT = 1e17;\\nuint256 constant MAX_INVARIANT_CHANGE = 1e12; //Max allowed change percent: 0.000001 -> 0.0001%\\nuint256 constant MAX_UTIL_CHANGE = 1e12; //Max allowed change percent: 0.000001 -> 0.0001%\\n\\nuint256 constant SECONDS_PER_DAY = 864e20;\\n\\nuint8 constant MAX_ACTION_COUNT = 4;\\nuint8 constant MAX_FEE_TYPE_COUNT = 3;\\nuint8 constant MAX_FEE_STATE_FOR_USER_COUNT = 2;\\nuint8 constant MAX_FEE_STATE_COUNT = 3;\\nuint8 constant MAX_EMA_STATE_COUNT = 2;\\n\\nuint8 constant PREVIOUS_EMA_INDEX = 0;\\nuint8 constant CURRENT_EMA_INDEX = 1;\\n\\nuint256 constant UTILIZATION = 5e17; // 0.5\\nuint256 constant UTILIZATION_RECIPROCAL = 2e18;\\n\\naddress constant DEAD_ADDRESS = 0x000000000000000000000000000000000000dEaD;\\n\\n//Value map to enum RewardType\\nuint256 constant REWARD_LP = 0;\\nuint256 constant REWARD_STAKE = 1;\\nuint256 constant REWARD_PROTOCOL = 2;\\n\\n// Value map to enum FeeType\\nuint256 constant FEE_IBC_FROM_TRADE = 0;\\nuint256 constant FEE_IBC_FROM_LP = 1;\\nuint256 constant FEE_RESERVE = 2;\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"oz-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wethAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CommandUnsupport\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DepositNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EtherNotAccept\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"curve\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"useNative\",\"type\":\"bool\"},{\"internalType\":\"enum CommandType\",\"name\":\"command\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "InverseBondingCurveRouter", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}