{"SourceCode": "// File: solady/src/utils/ECDSA.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @notice Gas optimized ECDSA wrapper.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\r\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)\r\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\r\n///\r\n/// @dev Note:\r\n/// - The recovery functions use the ecrecover precompile (0x1).\r\n///\r\n/// WARNING! Do NOT use signatures as unique identifiers.\r\n/// Please use EIP712 with a nonce included in the digest to prevent replay attacks.\r\n/// This implementation does NOT check if a signature is non-malleable.\r\nlibrary ECDSA {\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                        CUSTOM ERRORS                       */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The signature is invalid.\r\n    error InvalidSignature();\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                    RECOVERY OPERATIONS                     */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    // Note: as of Solady version 0.0.68, these functions will\r\n    // revert upon recovery failure for more safety by default.\r\n\r\n    /// @dev Recovers the signer's address from a message digest `hash`,\r\n    /// and the `signature`.\r\n    ///\r\n    /// This function does NOT accept EIP-2098 short form signatures.\r\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\r\n    /// short form signatures instead.\r\n    function recover(bytes32 hash, bytes memory signature) internal view returns (address result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40) // Cache the free memory pointer.\r\n            let signatureLength := mload(signature)\r\n            mstore(0x00, hash)\r\n            mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\r\n            mstore(0x40, mload(add(signature, 0x20))) // `r`.\r\n            mstore(0x60, mload(add(signature, 0x40))) // `s`.\r\n            result :=\r\n                mload(\r\n                    staticcall(\r\n                        gas(), // Amount of gas left for the transaction.\r\n                        eq(signatureLength, 65), // Address of `ecrecover`.\r\n                        0x00, // Start of input.\r\n                        0x80, // Size of input.\r\n                        0x01, // Start of output.\r\n                        0x20 // Size of output.\r\n                    )\r\n                )\r\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\r\n            if iszero(returndatasize()) {\r\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x60, 0) // Restore the zero slot.\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Recovers the signer's address from a message digest `hash`,\r\n    /// and the `signature`.\r\n    ///\r\n    /// This function does NOT accept EIP-2098 short form signatures.\r\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\r\n    /// short form signatures instead.\r\n    function recoverCalldata(bytes32 hash, bytes calldata signature)\r\n        internal\r\n        view\r\n        returns (address result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40) // Cache the free memory pointer.\r\n            mstore(0x00, hash)\r\n            mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\r\n            calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\r\n            result :=\r\n                mload(\r\n                    staticcall(\r\n                        gas(), // Amount of gas left for the transaction.\r\n                        eq(signature.length, 65), // Address of `ecrecover`.\r\n                        0x00, // Start of input.\r\n                        0x80, // Size of input.\r\n                        0x01, // Start of output.\r\n                        0x20 // Size of output.\r\n                    )\r\n                )\r\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\r\n            if iszero(returndatasize()) {\r\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x60, 0) // Restore the zero slot.\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Recovers the signer's address from a message digest `hash`,\r\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\r\n    ///\r\n    /// This function only accepts EIP-2098 short form signatures.\r\n    /// See: https://eips.ethereum.org/EIPS/eip-2098\r\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40) // Cache the free memory pointer.\r\n            mstore(0x00, hash)\r\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\r\n            mstore(0x40, r)\r\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\r\n            result :=\r\n                mload(\r\n                    staticcall(\r\n                        gas(), // Amount of gas left for the transaction.\r\n                        1, // Address of `ecrecover`.\r\n                        0x00, // Start of input.\r\n                        0x80, // Size of input.\r\n                        0x01, // Start of output.\r\n                        0x20 // Size of output.\r\n                    )\r\n                )\r\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\r\n            if iszero(returndatasize()) {\r\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x60, 0) // Restore the zero slot.\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Recovers the signer's address from a message digest `hash`,\r\n    /// and the signature defined by `v`, `r`, `s`.\r\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\r\n        internal\r\n        view\r\n        returns (address result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40) // Cache the free memory pointer.\r\n            mstore(0x00, hash)\r\n            mstore(0x20, and(v, 0xff))\r\n            mstore(0x40, r)\r\n            mstore(0x60, s)\r\n            result :=\r\n                mload(\r\n                    staticcall(\r\n                        gas(), // Amount of gas left for the transaction.\r\n                        1, // Address of `ecrecover`.\r\n                        0x00, // Start of input.\r\n                        0x80, // Size of input.\r\n                        0x01, // Start of output.\r\n                        0x20 // Size of output.\r\n                    )\r\n                )\r\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\r\n            if iszero(returndatasize()) {\r\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x60, 0) // Restore the zero slot.\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                   TRY-RECOVER OPERATIONS                   */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    // WARNING!\r\n    // These functions will NOT revert upon recovery failure.\r\n    // Instead, they will return the zero address upon recovery failure.\r\n    // It is critical that the returned address is NEVER compared against\r\n    // a zero address (e.g. an uninitialized address variable).\r\n\r\n    /// @dev Recovers the signer's address from a message digest `hash`,\r\n    /// and the `signature`.\r\n    ///\r\n    /// This function does NOT accept EIP-2098 short form signatures.\r\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\r\n    /// short form signatures instead.\r\n    function tryRecover(bytes32 hash, bytes memory signature)\r\n        internal\r\n        view\r\n        returns (address result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40) // Cache the free memory pointer.\r\n            let signatureLength := mload(signature)\r\n            mstore(0x00, hash)\r\n            mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\r\n            mstore(0x40, mload(add(signature, 0x20))) // `r`.\r\n            mstore(0x60, mload(add(signature, 0x40))) // `s`.\r\n            pop(\r\n                staticcall(\r\n                    gas(), // Amount of gas left for the transaction.\r\n                    eq(signatureLength, 65), // Address of `ecrecover`.\r\n                    0x00, // Start of input.\r\n                    0x80, // Size of input.\r\n                    0x40, // Start of output.\r\n                    0x20 // Size of output.\r\n                )\r\n            )\r\n            mstore(0x60, 0) // Restore the zero slot.\r\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\r\n            result := mload(xor(0x60, returndatasize()))\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Recovers the signer's address from a message digest `hash`,\r\n    /// and the `signature`.\r\n    ///\r\n    /// This function does NOT accept EIP-2098 short form signatures.\r\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\r\n    /// short form signatures instead.\r\n    function tryRecoverCalldata(bytes32 hash, bytes calldata signature)\r\n        internal\r\n        view\r\n        returns (address result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40) // Cache the free memory pointer.\r\n            mstore(0x00, hash)\r\n            mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\r\n            calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\r\n            pop(\r\n                staticcall(\r\n                    gas(), // Amount of gas left for the transaction.\r\n                    eq(signature.length, 65), // Address of `ecrecover`.\r\n                    0x00, // Start of input.\r\n                    0x80, // Size of input.\r\n                    0x40, // Start of output.\r\n                    0x20 // Size of output.\r\n                )\r\n            )\r\n            mstore(0x60, 0) // Restore the zero slot.\r\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\r\n            result := mload(xor(0x60, returndatasize()))\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Recovers the signer's address from a message digest `hash`,\r\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\r\n    ///\r\n    /// This function only accepts EIP-2098 short form signatures.\r\n    /// See: https://eips.ethereum.org/EIPS/eip-2098\r\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\r\n        internal\r\n        view\r\n        returns (address result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40) // Cache the free memory pointer.\r\n            mstore(0x00, hash)\r\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\r\n            mstore(0x40, r)\r\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\r\n            pop(\r\n                staticcall(\r\n                    gas(), // Amount of gas left for the transaction.\r\n                    1, // Address of `ecrecover`.\r\n                    0x00, // Start of input.\r\n                    0x80, // Size of input.\r\n                    0x40, // Start of output.\r\n                    0x20 // Size of output.\r\n                )\r\n            )\r\n            mstore(0x60, 0) // Restore the zero slot.\r\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\r\n            result := mload(xor(0x60, returndatasize()))\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Recovers the signer's address from a message digest `hash`,\r\n    /// and the signature defined by `v`, `r`, `s`.\r\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\r\n        internal\r\n        view\r\n        returns (address result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40) // Cache the free memory pointer.\r\n            mstore(0x00, hash)\r\n            mstore(0x20, and(v, 0xff))\r\n            mstore(0x40, r)\r\n            mstore(0x60, s)\r\n            pop(\r\n                staticcall(\r\n                    gas(), // Amount of gas left for the transaction.\r\n                    1, // Address of `ecrecover`.\r\n                    0x00, // Start of input.\r\n                    0x80, // Size of input.\r\n                    0x40, // Start of output.\r\n                    0x20 // Size of output.\r\n                )\r\n            )\r\n            mstore(0x60, 0) // Restore the zero slot.\r\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\r\n            result := mload(xor(0x60, returndatasize()))\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                     HASHING OPERATIONS                     */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\r\n    /// This produces a hash corresponding to the one signed with the\r\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\r\n    /// JSON-RPC method as part of EIP-191.\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x20, hash) // Store into scratch space for keccak256.\r\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\") // 28 bytes.\r\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\r\n    /// This produces a hash corresponding to the one signed with the\r\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\r\n    /// JSON-RPC method as part of EIP-191.\r\n    /// Note: Supports lengths of `s` up to 999999 bytes.\r\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let sLength := mload(s)\r\n            let o := 0x20\r\n            mstore(o, \"\\x19Ethereum Signed Message:\\n\") // 26 bytes, zero-right-padded.\r\n            mstore(0x00, 0x00)\r\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\r\n            for { let temp := sLength } 1 {} {\r\n                o := sub(o, 1)\r\n                mstore8(o, add(48, mod(temp, 10)))\r\n                temp := div(temp, 10)\r\n                if iszero(temp) { break }\r\n            }\r\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\r\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\r\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\r\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\r\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\r\n            mstore(s, sLength) // Restore the length.\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                   EMPTY CALLDATA HELPERS                   */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns an empty calldata bytes.\r\n    function emptySignature() internal pure returns (bytes calldata signature) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            signature.length := 0\r\n        }\r\n    }\r\n}\r\n\r\n// File: Pepescriptions.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\ncontract Pepescriptions {\r\n\r\n    enum MintState {\r\n        CLOSED,\r\n        WHITELIST,\r\n        LIVE\r\n    }\r\n\r\n    error MaxSupplyReached();\r\n    error InvalidValue();\r\n    error RequestingTooMany();\r\n    error TransferFailed();\r\n    error OnlyOwner();\r\n    error InvalidSnapshotProof();\r\n    error MintIsNotLive();\r\n\r\n    event Mint(address indexed minter, uint256 indexed amount, uint256 startID);\r\n\r\n    uint256 public TOTAL_SUPPLY = 0;\r\n    uint256 public PRICE = 0.0045 * 1 ether;\r\n    uint256 public immutable MAX_SUPPLY = 8750;\r\n    uint256 public immutable MAX_PER_TXN = 100;\r\n    uint256 public immutable MAX_HOLDER_MINTS = 4;\r\n\r\n    MintState public mintState = MintState.CLOSED;\r\n\r\n    mapping (address => uint256) wlMints;\r\n\r\n    address OWNER;\r\n    address SIGNER;\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender != OWNER) {\r\n            revert OnlyOwner();\r\n        }\r\n        _;\r\n    }\r\n\r\n    constructor (address signer) {\r\n        OWNER = msg.sender;\r\n        SIGNER = signer;\r\n    }\r\n\r\n    function setPrice(uint256 _PRICE) external onlyOwner {\r\n        PRICE = _PRICE;\r\n    }\r\n\r\n    function wlMint(uint256 amount, bytes calldata signature) external payable {\r\n        if (mintState != MintState.WHITELIST) {\r\n            revert MintIsNotLive();\r\n        }\r\n        if ((TOTAL_SUPPLY + amount) > MAX_SUPPLY) { revert RequestingTooMany(); }\r\n        if (amount > MAX_HOLDER_MINTS || (wlMints[msg.sender] + amount) > MAX_HOLDER_MINTS) {\r\n            revert RequestingTooMany();\r\n        }\r\n        if (amount * PRICE != msg.value) {\r\n            revert InvalidValue();\r\n        }\r\n\r\n        bytes32 message = keccak256(\r\n            abi.encode(msg.sender, 1)\r\n        );\r\n        if (\r\n            ECDSA.recover(\r\n                ECDSA.toEthSignedMessageHash(message),\r\n                signature\r\n            ) != SIGNER\r\n        ) {\r\n            revert InvalidSnapshotProof();\r\n        }\r\n\r\n        (bool success,) = address(OWNER).call{value: msg.value}(\"\");\r\n        if (!success) {\r\n            revert TransferFailed();\r\n        }\r\n\r\n        emit Mint(msg.sender, amount, TOTAL_SUPPLY);\r\n\r\n        unchecked {\r\n            TOTAL_SUPPLY += amount;\r\n            wlMints[msg.sender] += amount;\r\n        }\r\n    }\r\n\r\n    function mint(uint256 amount) external payable {\r\n        if (mintState != MintState.LIVE) {\r\n            revert MintIsNotLive();\r\n        }\r\n        if (TOTAL_SUPPLY == MAX_SUPPLY) { revert MaxSupplyReached(); }\r\n        if ((TOTAL_SUPPLY + amount) > MAX_SUPPLY) { revert RequestingTooMany(); }\r\n        if ((PRICE * amount) != msg.value) { revert InvalidValue(); }\r\n        if (amount > MAX_PER_TXN) { revert RequestingTooMany(); }\r\n        \r\n\r\n        (bool success,) = address(OWNER).call{value: msg.value}(\"\");\r\n        if (!success) {\r\n            revert TransferFailed();\r\n        }\r\n\r\n        emit Mint(msg.sender, amount, TOTAL_SUPPLY);\r\n        \r\n        unchecked {\r\n            TOTAL_SUPPLY += amount;\r\n        }\r\n    }\r\n\r\n    function setState(MintState state) external onlyOwner {\r\n        mintState = state;\r\n    }\r\n\r\n    function setSigner(address signer) external onlyOwner {\r\n        SIGNER = signer;\r\n    }\r\n\r\n    function withdraw() external onlyOwner {\r\n        (bool success,) = address(OWNER).call{value: address(this).balance}(\"\");\r\n        if (!success) {\r\n            revert TransferFailed();\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidSnapshotProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxSupplyReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintIsNotLive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RequestingTooMany\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startID\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_HOLDER_MINTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PER_TXN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintState\",\"outputs\":[{\"internalType\":\"enum Pepescriptions.MintState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_PRICE\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"setSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum Pepescriptions.MintState\",\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"setState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"wlMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "Pepescriptions", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000dca42a722f88f62d70cf4e13bf8d391004265bad", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8c771c1ee208953a866f37a8b1b6d9ae2ec3f841e8bd938039a0eef19c7a9619"}