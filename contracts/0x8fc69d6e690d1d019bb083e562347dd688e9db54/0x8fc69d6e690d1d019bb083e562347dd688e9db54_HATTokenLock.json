{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/tokenlock/HATTokenLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"./TokenLock.sol\\\";\\nimport \\\"../HATToken.sol\\\";\\n\\n\\ncontract HATTokenLock is TokenLock {\\n\\n    bool public canDelegate;\\n\\n    // Initializer\\n    function initialize(\\n        address _tokenLockOwner,\\n        address _beneficiary,\\n        HATToken _token,\\n        uint256 _managedAmount,\\n        uint256 _startTime,\\n        uint256 _endTime,\\n        uint256 _periods,\\n        uint256 _releaseStartTime,\\n        uint256 _vestingCliffTime,\\n        Revocability _revocable,\\n        bool _canDelegate\\n    ) external {\\n        _initialize(\\n            _tokenLockOwner,\\n            _beneficiary,\\n            address(_token),\\n            _managedAmount,\\n            _startTime,\\n            _endTime,\\n            _periods,\\n            _releaseStartTime,\\n            _vestingCliffTime,\\n            _revocable\\n        );\\n        if (_canDelegate) {\\n            _token.delegate(_beneficiary);\\n        }\\n        canDelegate = _canDelegate;\\n    }\\n\\n    /// @dev delegate voting power\\n    /// @param _delegatee Address of delegatee\\n    function delegate(address _delegatee)\\n        external\\n        onlyBeneficiary\\n    {\\n        require(canDelegate, \\\"delegate is disable\\\");\\n        HATToken(address(token)).delegate(_delegatee);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokenlock/TokenLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\nimport \\\"openzeppelin-solidity/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport \\\"./OwnableInitializable.sol\\\";\\nimport \\\"./MathUtils.sol\\\";\\nimport \\\"./ITokenLock.sol\\\";\\n\\n// this contract is based on GraphTokenLock\\n// see https://github.com/graphprotocol/token-distribution/blob/main/contracts/GraphTokenLock.sol\\n\\n/**\\n * @title HatTokenLock\\n * @notice Contract that manages an unlocking schedule of tokens.\\n * @dev The contract lock manage a number of tokens deposited into the contract to ensure that\\n * they can only be released under certain time conditions.\\n *\\n * This contract implements a release scheduled based on periods and tokens are released in steps\\n * after each period ends. It can be configured with one period in which case it is like a plain TimeLock.\\n * It also supports revocation to be used for vesting schedules.\\n *\\n * The contract supports receiving extra funds than the managed tokens ones that can be\\n * withdrawn by the beneficiary at any time.\\n *\\n * A releaseStartTime parameter is included to override the default release schedule and\\n * perform the first release on the configured time. After that it will continue with the\\n * default schedule.\\n */\\n// solhint-disable-next-line indent\\nabstract contract TokenLock is OwnableInitializable, ITokenLock {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    uint256 private constant MIN_PERIOD = 1;\\n\\n    // -- State --\\n\\n    IERC20 public token;\\n    address public beneficiary;\\n\\n    // Configuration\\n\\n    // Amount of tokens managed by the contract schedule\\n    uint256 public managedAmount;\\n\\n    uint256 public startTime; // Start datetime (in unixtimestamp)\\n    uint256 public endTime; // Datetime after all funds are fully vested/unlocked (in unixtimestamp)\\n    uint256 public periods; // Number of vesting/release periods\\n\\n    // First release date for tokens (in unixtimestamp)\\n    // If set, no tokens will be released before releaseStartTime ignoring\\n    // the amount to release each period\\n    uint256 public releaseStartTime;\\n    // A cliff set a date to which a beneficiary needs to get to vest\\n    // all preceding periods\\n    uint256 public vestingCliffTime;\\n    Revocability public revocable; // Whether to use vesting for locked funds\\n\\n    // State\\n\\n    bool public isRevoked;\\n    bool public isInitialized;\\n    bool public isAccepted;\\n    uint256 public releasedAmount;\\n\\n    // -- Events --\\n\\n    event TokensReleased(address indexed beneficiary, uint256 amount);\\n    event TokensWithdrawn(address indexed beneficiary, uint256 amount);\\n    event TokensRevoked(address indexed beneficiary, uint256 amount);\\n    event BeneficiaryChanged(address newBeneficiary);\\n    event LockAccepted();\\n    event LockCanceled();\\n\\n    /**\\n     * @dev Only allow calls from the beneficiary of the contract\\n     */\\n    modifier onlyBeneficiary() {\\n        require(msg.sender == beneficiary, \\\"!auth\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Initializes the contract\\n     * @param _tokenLockOwner Address of the contract owner\\n     * @param _beneficiary Address of the beneficiary of locked tokens\\n     * @param _managedAmount Amount of tokens to be managed by the lock contract\\n     * @param _startTime Start time of the release schedule\\n     * @param _endTime End time of the release schedule\\n     * @param _periods Number of periods between start time and end time\\n     * @param _releaseStartTime Override time for when the releases start\\n     * @param _vestingCliffTime Override time for when the vesting start\\n     * @param _revocable Whether the contract is revocable\\n     */\\n    function _initialize(\\n        address _tokenLockOwner,\\n        address _beneficiary,\\n        address _token,\\n        uint256 _managedAmount,\\n        uint256 _startTime,\\n        uint256 _endTime,\\n        uint256 _periods,\\n        uint256 _releaseStartTime,\\n        uint256 _vestingCliffTime,\\n        Revocability _revocable\\n    ) internal {\\n        require(!isInitialized, \\\"Already initialized\\\");\\n        require(_tokenLockOwner != address(0), \\\"Owner cannot be zero\\\");\\n        require(_beneficiary != address(0), \\\"Beneficiary cannot be zero\\\");\\n        require(_token != address(0), \\\"Token cannot be zero\\\");\\n        require(_managedAmount > 0, \\\"Managed tokens cannot be zero\\\");\\n        require(_startTime != 0, \\\"Start time must be set\\\");\\n        require(_startTime < _endTime, \\\"Start time > end time\\\");\\n        require(_periods >= MIN_PERIOD, \\\"Periods cannot be below minimum\\\");\\n        require(_revocable != Revocability.NotSet, \\\"Must set a revocability option\\\");\\n        require(_releaseStartTime < _endTime, \\\"Release start time must be before end time\\\");\\n        require(_vestingCliffTime < _endTime, \\\"Cliff time must be before end time\\\");\\n\\n        isInitialized = true;\\n\\n        OwnableInitializable.initialize(_tokenLockOwner);\\n        beneficiary = _beneficiary;\\n        token = IERC20(_token);\\n\\n        managedAmount = _managedAmount;\\n\\n        startTime = _startTime;\\n        endTime = _endTime;\\n        periods = _periods;\\n\\n        // Optionals\\n        releaseStartTime = _releaseStartTime;\\n        vestingCliffTime = _vestingCliffTime;\\n        revocable = _revocable;\\n    }\\n\\n    /**\\n     * @notice Change the beneficiary of funds managed by the contract\\n     * @dev Can only be called by the beneficiary\\n     * @param _newBeneficiary Address of the new beneficiary address\\n     */\\n    function changeBeneficiary(address _newBeneficiary) external onlyBeneficiary {\\n        require(_newBeneficiary != address(0), \\\"Empty beneficiary\\\");\\n        beneficiary = _newBeneficiary;\\n        emit BeneficiaryChanged(_newBeneficiary);\\n    }\\n\\n    /**\\n     * @notice Beneficiary accepts the lock, the owner cannot retrieve back the tokens\\n     * @dev Can only be called by the beneficiary\\n     */\\n    function acceptLock() external onlyBeneficiary {\\n        isAccepted = true;\\n        emit LockAccepted();\\n    }\\n\\n    /**\\n     * @notice Owner cancel the lock and return the balance in the contract\\n     * @dev Can only be called by the owner\\n     */\\n    function cancelLock() external onlyOwner {\\n        require(isAccepted == false, \\\"Cannot cancel accepted contract\\\");\\n\\n        token.safeTransfer(owner(), currentBalance());\\n\\n        emit LockCanceled();\\n    }\\n\\n    // -- Balances --\\n\\n    /**\\n     * @notice Returns the amount of tokens currently held by the contract\\n     * @return Tokens held in the contract\\n     */\\n    function currentBalance() public override view returns (uint256) {\\n        return token.balanceOf(address(this));\\n    }\\n\\n    // -- Time & Periods --\\n\\n    /**\\n     * @notice Returns the current block timestamp\\n     * @return Current block timestamp\\n     */\\n    function currentTime() public override view returns (uint256) {\\n        // solhint-disable-next-line not-rely-on-time\\n        return block.timestamp;\\n    }\\n\\n    /**\\n     * @notice Gets duration of contract from start to end in seconds\\n     * @return Amount of seconds from contract startTime to endTime\\n     */\\n    function duration() public override view returns (uint256) {\\n        return endTime.sub(startTime);\\n    }\\n\\n    /**\\n     * @notice Gets time elapsed since the start of the contract\\n     * @dev Returns zero if called before conctract starTime\\n     * @return Seconds elapsed from contract startTime\\n     */\\n    function sinceStartTime() public override view returns (uint256) {\\n        uint256 current = currentTime();\\n        if (current <= startTime) {\\n            return 0;\\n        }\\n        return current.sub(startTime);\\n    }\\n\\n    /**\\n     * @notice Returns amount available to be released after each period according to schedule\\n     * @return Amount of tokens available after each period\\n     */\\n    function amountPerPeriod() public override view returns (uint256) {\\n        return managedAmount.div(periods);\\n    }\\n\\n    /**\\n     * @notice Returns the duration of each period in seconds\\n     * @return Duration of each period in seconds\\n     */\\n    function periodDuration() public override view returns (uint256) {\\n        return duration().div(periods);\\n    }\\n\\n    /**\\n     * @notice Gets the current period based on the schedule\\n     * @return A number that represents the current period\\n     */\\n    function currentPeriod() public override view returns (uint256) {\\n        return sinceStartTime().div(periodDuration()).add(MIN_PERIOD);\\n    }\\n\\n    /**\\n     * @notice Gets the number of periods that passed since the first period\\n     * @return A number of periods that passed since the schedule started\\n     */\\n    function passedPeriods() public override view returns (uint256) {\\n        return currentPeriod().sub(MIN_PERIOD);\\n    }\\n\\n    // -- Locking & Release Schedule --\\n\\n    /**\\n     * @notice Gets the currently available token according to the schedule\\n     * @dev Implements the step-by-step schedule based on periods for available tokens\\n     * @return Amount of tokens available according to the schedule\\n     */\\n    function availableAmount() public override view returns (uint256) {\\n        uint256 current = currentTime();\\n\\n        // Before contract start no funds are available\\n        if (current < startTime) {\\n            return 0;\\n        }\\n\\n        // After contract ended all funds are available\\n        if (current > endTime) {\\n            return managedAmount;\\n        }\\n\\n        // Get available amount based on period\\n        return passedPeriods().mul(amountPerPeriod());\\n    }\\n\\n    /**\\n     * @notice Gets the amount of currently vested tokens\\n     * @dev Similar to available amount, but is fully vested when contract is non-revocable\\n     * @return Amount of tokens already vested\\n     */\\n    function vestedAmount() public override view returns (uint256) {\\n        // If non-revocable it is fully vested\\n        if (revocable == Revocability.Disabled) {\\n            return managedAmount;\\n        }\\n\\n        // Vesting cliff is activated and it has not passed means nothing is vested yet\\n        if (vestingCliffTime > 0 && currentTime() < vestingCliffTime) {\\n            return 0;\\n        }\\n\\n        return availableAmount();\\n    }\\n\\n    /**\\n     * @notice Gets tokens currently available for release\\n     * @dev Considers the schedule and takes into account already released tokens\\n     * @return Amount of tokens ready to be released\\n     */\\n    function releasableAmount() public override view returns (uint256) {\\n        // If a release start time is set no tokens are available for release before this date\\n        // If not set it follows the default schedule and tokens are available on\\n        // the first period passed\\n        if (releaseStartTime > 0 && currentTime() < releaseStartTime) {\\n            return 0;\\n        }\\n\\n        // Vesting cliff is activated and it has not passed means nothing is vested yet\\n        // so funds cannot be released\\n        if (revocable == Revocability.Enabled && vestingCliffTime > 0 && currentTime() < vestingCliffTime) {\\n            return 0;\\n        }\\n\\n        // A beneficiary can never have more releasable tokens than the contract balance\\n        uint256 releasable = availableAmount().sub(releasedAmount);\\n        return MathUtils.min(currentBalance(), releasable);\\n    }\\n\\n    /**\\n     * @notice Gets the outstanding amount yet to be released based on the whole contract lifetime\\n     * @dev Does not consider schedule but just global amounts tracked\\n     * @return Amount of outstanding tokens for the lifetime of the contract\\n     */\\n    function totalOutstandingAmount() public override view returns (uint256) {\\n        return managedAmount.sub(releasedAmount);\\n    }\\n\\n    /**\\n     * @notice Gets surplus amount in the contract based on outstanding amount to release\\n     * @dev All funds over outstanding amount is considered surplus that can be withdrawn by beneficiary\\n     * @return Amount of tokens considered as surplus\\n     */\\n    function surplusAmount() public override view returns (uint256) {\\n        uint256 balance = currentBalance();\\n        uint256 outstandingAmount = totalOutstandingAmount();\\n        if (balance > outstandingAmount) {\\n            return balance.sub(outstandingAmount);\\n        }\\n        return 0;\\n    }\\n\\n    // -- Value Transfer --\\n\\n    /**\\n     * @notice Releases tokens based on the configured schedule\\n     * @dev All available releasable tokens are transferred to beneficiary\\n     */\\n    function release() external override onlyBeneficiary {\\n        uint256 amountToRelease = releasableAmount();\\n        require(amountToRelease > 0, \\\"No available releasable amount\\\");\\n\\n        releasedAmount = releasedAmount.add(amountToRelease);\\n\\n        token.safeTransfer(beneficiary, amountToRelease);\\n\\n        emit TokensReleased(beneficiary, amountToRelease);\\n    }\\n\\n    /**\\n     * @notice Withdraws surplus, unmanaged tokens from the contract\\n     * @dev Tokens in the contract over outstanding amount are considered as surplus\\n     * @param _amount Amount of tokens to withdraw\\n     */\\n    function withdrawSurplus(uint256 _amount) external override onlyBeneficiary {\\n        require(_amount > 0, \\\"Amount cannot be zero\\\");\\n        require(surplusAmount() >= _amount, \\\"Amount requested > surplus available\\\");\\n\\n        token.safeTransfer(beneficiary, _amount);\\n\\n        emit TokensWithdrawn(beneficiary, _amount);\\n    }\\n\\n    /**\\n     * @notice Revokes a vesting schedule and return the unvested tokens to the owner\\n     * @dev Vesting schedule is always calculated based on managed tokens\\n     */\\n    function revoke() external override onlyOwner {\\n        require(revocable == Revocability.Enabled, \\\"Contract is non-revocable\\\");\\n        require(isRevoked == false, \\\"Already revoked\\\");\\n\\n        uint256 unvestedAmount = managedAmount.sub(vestedAmount());\\n        require(unvestedAmount > 0, \\\"No available unvested amount\\\");\\n\\n        isRevoked = true;\\n\\n        token.safeTransfer(owner(), unvestedAmount);\\n\\n        emit TokensRevoked(beneficiary, unvestedAmount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/HATToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\nimport \\\"openzeppelin-solidity/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\n\\n\\ncontract HATToken is IERC20 {\\n\\n    struct PendingMinter {\\n        uint256 seedAmount;\\n        uint256 setMinterPendingAt;\\n    }\\n\\n    /// @notice A checkpoint for marking number of votes from a given block\\n    struct Checkpoint {\\n        uint32 fromBlock;\\n        uint96 votes;\\n    }\\n\\n    /// @notice EIP-20 token name for this token\\n    // solhint-disable-next-line const-name-snakecase\\n    string public constant name = \\\"hats.finance\\\";\\n\\n    /// @notice EIP-20 token symbol for this token\\n    // solhint-disable-next-line const-name-snakecase\\n    string public constant symbol = \\\"HAT\\\";\\n\\n    /// @notice EIP-20 token decimals for this token\\n    // solhint-disable-next-line const-name-snakecase\\n    uint8 public constant decimals = 18;\\n\\n    /// @notice Total number of tokens in circulation\\n    uint public override totalSupply;\\n\\n    address public governance;\\n    address public governancePending;\\n    uint256 public setGovernancePendingAt;\\n    uint256 public immutable timeLockDelay;\\n    uint256 public constant CAP = 10000000e18;\\n\\n    /// @notice Address which may mint new tokens\\n    /// minter -> minting seedAmount\\n    mapping (address => uint256) public minters;\\n\\n    /// @notice Address which may mint new tokens\\n    /// minter -> minting seedAmount\\n    mapping (address => PendingMinter) public pendingMinters;\\n\\n    // @notice Allowance amounts on behalf of others\\n    mapping (address => mapping (address => uint96)) internal allowances;\\n\\n    // @notice Official record of token balances for each account\\n    mapping (address => uint96) internal balances;\\n\\n    /// @notice A record of each accounts delegate\\n    mapping (address => address) public delegates;\\n\\n    /// @notice A record of votes checkpoints for each account, by index\\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\\n\\n    /// @notice The number of checkpoints for each account\\n    mapping (address => uint32) public numCheckpoints;\\n\\n    /// @notice A record of states for signing / validating signatures\\n    mapping (address => uint) public nonces;\\n\\n    /// @notice The EIP-712 typehash for the contract's domain\\n    bytes32 public constant DOMAIN_TYPEHASH =\\n    keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\\n    bytes32 public constant DELEGATION_TYPEHASH =\\n    keccak256(\\\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\\\");\\n\\n    /// @notice The EIP-712 typehash for the permit struct used by the contract\\n    bytes32 public constant PERMIT_TYPEHASH =\\n    keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    /// @notice An event thats emitted when a new minter address is pending\\n    event MinterPending(address indexed minter, uint256 seedAmount, uint256 at);\\n    /// @notice An event thats emitted when the minter address is changed\\n    event MinterChanged(address indexed minter, uint256 seedAmount);\\n    /// @notice An event thats emitted when a new governance address is pending\\n    event GovernancePending(address indexed oldGovernance, address indexed newGovernance, uint256 at);\\n    /// @notice An event thats emitted when a new governance address is set\\n    event GovernanceChanged(address indexed oldGovernance, address indexed newGovernance);\\n    /// @notice An event thats emitted when an account changes its delegate\\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\\n    /// @notice An event thats emitted when a delegate account's vote balance changes\\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\\n\\n    /**\\n     * @notice Construct a new HAT token\\n     */\\n    // solhint-disable-next-line func-visibility\\n    constructor(address _governance, uint256 _timeLockDelay) {\\n        governance = _governance;\\n        timeLockDelay = _timeLockDelay;\\n    }\\n\\n    function setPendingGovernance(address _governance) external {\\n        require(msg.sender == governance, \\\"HAT:!governance\\\");\\n        require(_governance != address(0), \\\"HAT:!_governance\\\");\\n        governancePending = _governance;\\n        // solhint-disable-next-line not-rely-on-time\\n        setGovernancePendingAt = block.timestamp;\\n        emit GovernancePending(governance, _governance, setGovernancePendingAt);\\n    }\\n\\n    function confirmGovernance() external {\\n        require(msg.sender == governance, \\\"HAT:!governance\\\");\\n        require(setGovernancePendingAt > 0, \\\"HAT:!governancePending\\\");\\n        // solhint-disable-next-line not-rely-on-time\\n        require(block.timestamp - setGovernancePendingAt > timeLockDelay,\\n        \\\"HAT: cannot confirm governance at this time\\\");\\n        emit GovernanceChanged(governance, governancePending);\\n        governance = governancePending;\\n        setGovernancePendingAt = 0;\\n    }\\n\\n    function setPendingMinter(address _minter, uint256 _cap) external {\\n        require(msg.sender == governance, \\\"HAT::!governance\\\");\\n        pendingMinters[_minter].seedAmount = _cap;\\n        // solhint-disable-next-line not-rely-on-time\\n        pendingMinters[_minter].setMinterPendingAt = block.timestamp;\\n        emit MinterPending(_minter, _cap, pendingMinters[_minter].setMinterPendingAt);\\n    }\\n\\n    function confirmMinter(address _minter) external {\\n        require(msg.sender == governance, \\\"HAT::mint: only the governance can confirm minter\\\");\\n        require(pendingMinters[_minter].setMinterPendingAt > 0, \\\"HAT:: no pending minter was set\\\");\\n        // solhint-disable-next-line not-rely-on-time\\n        require(block.timestamp - pendingMinters[_minter].setMinterPendingAt > timeLockDelay,\\n        \\\"HATToken: cannot confirm at this time\\\");\\n        minters[_minter] = pendingMinters[_minter].seedAmount;\\n        pendingMinters[_minter].setMinterPendingAt = 0;\\n        emit MinterChanged(_minter, pendingMinters[_minter].seedAmount);\\n    }\\n\\n    function burn(uint256 _amount) external {\\n        return _burn(msg.sender, _amount);\\n    }\\n\\n    function mint(address _account, uint _amount) external {\\n        require(minters[msg.sender] >= _amount, \\\"HATToken: amount greater than limitation\\\");\\n        minters[msg.sender] = SafeMath.sub(minters[msg.sender], _amount);\\n        _mint(_account, _amount);\\n    }\\n\\n    /**\\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\\n     * @param account The address of the account holding the funds\\n     * @param spender The address of the account spending the funds\\n     * @return The number of tokens approved\\n     */\\n    function allowance(address account, address spender) external override view returns (uint) {\\n        return allowances[account][spender];\\n    }\\n\\n    /**\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\n     * @dev This will overwrite the approval amount for `spender`\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n     * @param spender The address of the account which may transfer tokens\\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\\n     * @return Whether or not the approval succeeded\\n     */\\n    function approve(address spender, uint rawAmount) external override returns (bool) {\\n        uint96 amount;\\n        if (rawAmount == type(uint256).max) {\\n            amount = type(uint96).max;\\n        } else {\\n            amount = safe96(rawAmount, \\\"HAT::approve: amount exceeds 96 bits\\\");\\n        }\\n\\n        allowances[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint addedValue) external virtual returns (bool) {\\n        require(spender != address(0), \\\"HAT: increaseAllowance to the zero address\\\");\\n        uint96 valueToAdd = safe96(addedValue, \\\"HAT::increaseAllowance: addedValue exceeds 96 bits\\\");\\n        allowances[msg.sender][spender] =\\n        add96(allowances[msg.sender][spender], valueToAdd, \\\"HAT::increaseAllowance: overflows\\\");\\n        emit Approval(msg.sender, spender, allowances[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint subtractedValue) external virtual returns (bool) {\\n        require(spender != address(0), \\\"HAT: decreaseAllowance to the zero address\\\");\\n        uint96 valueTosubtract = safe96(subtractedValue, \\\"HAT::decreaseAllowance: subtractedValue exceeds 96 bits\\\");\\n        allowances[msg.sender][spender] = sub96(allowances[msg.sender][spender], valueTosubtract,\\n        \\\"HAT::decreaseAllowance: spender allowance is less than subtractedValue\\\");\\n        emit Approval(msg.sender, spender, allowances[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Triggers an approval from owner to spends\\n     * @param owner The address to approve from\\n     * @param spender The address to be approved\\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\\n     * @param deadline The time at which to expire the signature\\n     * @param v The recovery byte of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function permit(address owner, address spender, uint rawAmount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\\n        uint96 amount;\\n        if (rawAmount == type(uint256).max) {\\n            amount = type(uint96).max;\\n        } else {\\n            amount = safe96(rawAmount, \\\"HAT::permit: amount exceeds 96 bits\\\");\\n        }\\n\\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, rawAmount, nonces[owner]++, deadline));\\n        bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n        address signatory = ecrecover(digest, v, r, s);\\n        require(signatory != address(0), \\\"HAT::permit: invalid signature\\\");\\n        require(signatory == owner, \\\"HAT::permit: unauthorized\\\");\\n        // solhint-disable-next-line not-rely-on-time\\n        require(block.timestamp <= deadline, \\\"HAT::permit: signature expired\\\");\\n\\n        allowances[owner][spender] = amount;\\n\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @notice Get the number of tokens held by the `account`\\n     * @param account The address of the account to get the balance of\\n     * @return The number of tokens held\\n     */\\n    function balanceOf(address account) external view override returns (uint) {\\n        return balances[account];\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n     * @param dst The address of the destination account\\n     * @param rawAmount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transfer(address dst, uint rawAmount) external override returns (bool) {\\n        uint96 amount = safe96(rawAmount, \\\"HAT::transfer: amount exceeds 96 bits\\\");\\n        _transferTokens(msg.sender, dst, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param rawAmount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transferFrom(address src, address dst, uint rawAmount) external override returns (bool) {\\n        address spender = msg.sender;\\n        uint96 spenderAllowance = allowances[src][spender];\\n        uint96 amount = safe96(rawAmount, \\\"HAT::approve: amount exceeds 96 bits\\\");\\n\\n        if (spender != src && spenderAllowance != type(uint96).max) {\\n            uint96 newAllowance = sub96(spenderAllowance, amount,\\n            \\\"HAT::transferFrom: transfer amount exceeds spender allowance\\\");\\n            allowances[src][spender] = newAllowance;\\n\\n            emit Approval(src, spender, newAllowance);\\n        }\\n\\n        _transferTokens(src, dst, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Delegate votes from `msg.sender` to `delegatee`\\n     * @param delegatee The address to delegate votes to\\n     */\\n    function delegate(address delegatee) external {\\n        return _delegate(msg.sender, delegatee);\\n    }\\n\\n    /**\\n     * @notice Delegates votes from signatory to `delegatee`\\n     * @param delegatee The address to delegate votes to\\n     * @param nonce The contract state required to match the signature\\n     * @param expiry The time at which to expire the signature\\n     * @param v The recovery byte of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) external {\\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\\n        bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n        address signatory = ecrecover(digest, v, r, s);\\n        require(signatory != address(0), \\\"HAT::delegateBySig: invalid signature\\\");\\n        require(nonce == nonces[signatory]++, \\\"HAT::delegateBySig: invalid nonce\\\");\\n        // solhint-disable-next-line not-rely-on-time\\n        require(block.timestamp <= expiry, \\\"HAT::delegateBySig: signature expired\\\");\\n        return _delegate(signatory, delegatee);\\n    }\\n\\n    /**\\n     * @notice Gets the current votes balance for `account`\\n     * @param account The address to get votes balance\\n     * @return The number of current votes for `account`\\n     */\\n    function getCurrentVotes(address account) external view returns (uint96) {\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\n    }\\n\\n    /**\\n     * @notice Determine the prior number of votes for an account as of a block number\\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n     * @param account The address of the account to check\\n     * @param blockNumber The block number to get the vote balance at\\n     * @return The number of votes the account had as of the given block\\n     */\\n    function getPriorVotes(address account, uint blockNumber) external view returns (uint96) {\\n        require(blockNumber < block.number, \\\"HAT::getPriorVotes: not yet determined\\\");\\n\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\\n            return checkpoints[account][nCheckpoints - 1].votes;\\n        }\\n\\n        // Next check implicit zero balance\\n        if (checkpoints[account][0].fromBlock > blockNumber) {\\n            return 0;\\n        }\\n\\n        uint32 lower = 0;\\n        uint32 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            Checkpoint memory cp = checkpoints[account][center];\\n            if (cp.fromBlock == blockNumber) {\\n                return cp.votes;\\n            } else if (cp.fromBlock < blockNumber) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return checkpoints[account][lower].votes;\\n    }\\n\\n    /**\\n     * @notice Mint new tokens\\n     * @param dst The address of the destination account\\n     * @param rawAmount The number of tokens to be minted\\n     */\\n    function _mint(address dst, uint rawAmount) internal {\\n        require(dst != address(0), \\\"HAT::mint: cannot transfer to the zero address\\\");\\n        require(SafeMath.add(totalSupply, rawAmount) <= CAP, \\\"ERC20Capped: CAP exceeded\\\");\\n\\n        // mint the amount\\n        uint96 amount = safe96(rawAmount, \\\"HAT::mint: amount exceeds 96 bits\\\");\\n        totalSupply = safe96(SafeMath.add(totalSupply, amount), \\\"HAT::mint: totalSupply exceeds 96 bits\\\");\\n\\n        // transfer the amount to the recipient\\n        balances[dst] = add96(balances[dst], amount, \\\"HAT::mint: transfer amount overflows\\\");\\n        emit Transfer(address(0), dst, amount);\\n\\n        // move delegates\\n        _moveDelegates(address(0), delegates[dst], amount);\\n    }\\n\\n    /**\\n     * Burn tokens\\n     * @param src The address of the source account\\n     * @param rawAmount The number of tokens to be burned\\n     */\\n    function _burn(address src, uint rawAmount) internal {\\n        require(src != address(0), \\\"HAT::burn: cannot burn to the zero address\\\");\\n\\n        // burn the amount\\n        uint96 amount = safe96(rawAmount, \\\"HAT::burn: amount exceeds 96 bits\\\");\\n        totalSupply = safe96(SafeMath.sub(totalSupply, amount), \\\"HAT::mint: totalSupply exceeds 96 bits\\\");\\n\\n        // reduce the amount from src address\\n        balances[src] = sub96(balances[src], amount, \\\"HAT::burn: burn amount exceeds balance\\\");\\n        emit Transfer(src, address(0), amount);\\n\\n        // move delegates\\n        _moveDelegates(delegates[src], address(0), amount);\\n    }\\n\\n    function _delegate(address delegator, address delegatee) internal {\\n        address currentDelegate = delegates[delegator];\\n        uint96 delegatorBalance = balances[delegator];\\n        delegates[delegator] = delegatee;\\n\\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\\n\\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\\n    }\\n\\n    function _transferTokens(address src, address dst, uint96 amount) internal {\\n        require(src != address(0), \\\"HAT::_transferTokens: cannot transfer from the zero address\\\");\\n        require(dst != address(0), \\\"HAT::_transferTokens: cannot transfer to the zero address\\\");\\n\\n        balances[src] = sub96(balances[src], amount, \\\"HAT::_transferTokens: transfer amount exceeds balance\\\");\\n        balances[dst] = add96(balances[dst], amount, \\\"HAT::_transferTokens: transfer amount overflows\\\");\\n        emit Transfer(src, dst, amount);\\n\\n        _moveDelegates(delegates[src], delegates[dst], amount);\\n    }\\n\\n    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\\n        if (srcRep != dstRep && amount > 0) {\\n            if (srcRep != address(0)) {\\n                uint32 srcRepNum = numCheckpoints[srcRep];\\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\\n                uint96 srcRepNew = sub96(srcRepOld, amount, \\\"HAT::_moveVotes: vote amount underflows\\\");\\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\\n            }\\n\\n            if (dstRep != address(0)) {\\n                uint32 dstRepNum = numCheckpoints[dstRep];\\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\\n                uint96 dstRepNew = add96(dstRepOld, amount, \\\"HAT::_moveVotes: vote amount overflows\\\");\\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\\n            }\\n        }\\n    }\\n\\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\\n        uint32 blockNumber = safe32(block.number, \\\"HAT::_writeCheckpoint: block number exceeds 32 bits\\\");\\n\\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\\n        } else {\\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\\n            numCheckpoints[delegatee] = nCheckpoints + 1;\\n        }\\n\\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\\n    }\\n\\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\\n        require(n < 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\\n        require(n < 2**96, errorMessage);\\n        return uint96(n);\\n    }\\n\\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\\n        uint96 c = a + b;\\n        require(c >= a, errorMessage);\\n        return c;\\n    }\\n\\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    function getChainId() internal view returns (uint) {\\n        uint256 chainId;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { chainId := chainid() }\\n        return chainId;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokenlock/OwnableInitializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The owner account will be passed on initialization of the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract OwnableInitializable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() external virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) external virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function initialize(address initialOwner) internal {\\n        _owner = initialOwner;\\n        emit OwnershipTransferred(address(0), initialOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokenlock/MathUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\nlibrary MathUtils {\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokenlock/ITokenLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface ITokenLock {\\n    enum Revocability { NotSet, Enabled, Disabled }\\n\\n    // -- Balances --\\n\\n    function currentBalance() external view returns (uint256);\\n\\n    // -- Time & Periods --\\n\\n    function currentTime() external view returns (uint256);\\n\\n    function duration() external view returns (uint256);\\n\\n    function sinceStartTime() external view returns (uint256);\\n\\n    function amountPerPeriod() external view returns (uint256);\\n\\n    function periodDuration() external view returns (uint256);\\n\\n    function currentPeriod() external view returns (uint256);\\n\\n    function passedPeriods() external view returns (uint256);\\n\\n    // -- Locking & Release Schedule --\\n\\n    function availableAmount() external view returns (uint256);\\n\\n    function vestedAmount() external view returns (uint256);\\n\\n    function releasableAmount() external view returns (uint256);\\n\\n    function totalOutstandingAmount() external view returns (uint256);\\n\\n    function surplusAmount() external view returns (uint256);\\n\\n    // -- Value Transfer --\\n\\n    function release() external;\\n\\n    function withdrawSurplus(uint256 _amount) external;\\n\\n    function revoke() external;\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newBeneficiary\",\"type\":\"address\"}],\"name\":\"BeneficiaryChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LockAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LockCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensWithdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountPerPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canDelegate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newBeneficiary\",\"type\":\"address\"}],\"name\":\"changeBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_delegatee\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenLockOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"contract HATToken\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_managedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_periods\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_releaseStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_vestingCliffTime\",\"type\":\"uint256\"},{\"internalType\":\"enum ITokenLock.Revocability\",\"name\":\"_revocable\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"_canDelegate\",\"type\":\"bool\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAccepted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRevoked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"passedPeriods\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periods\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releasableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releasedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revocable\",\"outputs\":[{\"internalType\":\"enum ITokenLock.Revocability\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sinceStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"surplusAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalOutstandingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingCliffTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawSurplus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "HATTokenLock", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}