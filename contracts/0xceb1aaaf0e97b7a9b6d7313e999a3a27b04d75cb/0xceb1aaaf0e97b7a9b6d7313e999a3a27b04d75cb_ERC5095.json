{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/errors/Exception.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\n/// @dev A single custom error capable of indicating a wide range of detected errors by providing\\n/// an error code value whose string representation is documented in errors.txt, and any possible other values\\n/// that are pertinent to the error.\\nerror Exception(uint8, uint256, uint256, address, address);\\n\"\r\n    },\r\n    \"src/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Returns the number of decimals the token uses - e.g. 8, means to\\n     * divide the token amount by 100000000 to get its user representation.\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\nimport 'src/interfaces/IERC20.sol';\\n\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC2612.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\nimport 'src/interfaces/IERC20Metadata.sol';\\n\\n/**\\n * @dev Interface of the ERC2612 standard as defined in the EIP.\\n *\\n * Adds the {permit} method, which can be used to change one's\\n * {IERC20-allowance} without having to send a transaction, by signing a\\n * message. This allows users to spend tokens without having to hold Ether.\\n *\\n * See https://eips.ethereum.org/EIPS/eip-2612.\\n */\\ninterface IERC2612 is IERC20Metadata {\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC5095.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\nimport 'src/interfaces/IERC2612.sol';\\n\\ninterface IERC5095 is IERC2612 {\\n    function maturity() external view returns (uint256);\\n\\n    function underlying() external view returns (address);\\n\\n    function convertToUnderlying(uint256) external view returns (uint256);\\n\\n    function convertToShares(uint256) external view returns (uint256);\\n\\n    function maxRedeem(address) external view returns (uint256);\\n\\n    function previewRedeem(uint256) external view returns (uint256);\\n\\n    function maxWithdraw(address) external view returns (uint256);\\n\\n    function previewWithdraw(uint256) external view returns (uint256);\\n\\n    function previewDeposit(uint256) external view returns (uint256);\\n\\n    function withdraw(\\n        uint256,\\n        address,\\n        address\\n    ) external returns (uint256);\\n\\n    function redeem(\\n        uint256,\\n        address,\\n        address\\n    ) external returns (uint256);\\n\\n    function deposit(uint256, address) external returns (uint256);\\n\\n    function mint(uint256, address) external returns (uint256);\\n\\n    function authMint(address, uint256) external returns (bool);\\n\\n    function authBurn(address, uint256) external returns (bool);\\n\\n    function authApprove(\\n        address,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMarketPlace.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\ninterface IMarketPlace {\\n    function markets(\\n        address,\\n        uint256,\\n        uint256\\n    ) external returns (address);\\n\\n    function pools(address, uint256) external view returns (address);\\n\\n    function sellPrincipalToken(\\n        address,\\n        uint256,\\n        uint128,\\n        uint128\\n    ) external returns (uint128);\\n\\n    function buyPrincipalToken(\\n        address,\\n        uint256,\\n        uint128,\\n        uint128\\n    ) external returns (uint128);\\n\\n    function sellUnderlying(\\n        address,\\n        uint256,\\n        uint128,\\n        uint128\\n    ) external returns (uint128);\\n\\n    function buyUnderlying(\\n        address,\\n        uint256,\\n        uint128,\\n        uint128\\n    ) external returns (uint128);\\n\\n    function redeemer() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IRedeemer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.16;\\n\\ninterface IRedeemer {\\n    function authRedeem(\\n        address underlying,\\n        uint256 maturity,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (uint256);\\n\\n    function approve(address p) external;\\n\\n    function holdings(address u, uint256 m) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IYield.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.16;\\n\\nimport 'src/interfaces/IERC20.sol';\\n\\ninterface IYield {\\n    function maturity() external view returns (uint32);\\n\\n    function base() external view returns (IERC20);\\n\\n    function sellBase(address, uint128) external returns (uint128);\\n\\n    function sellBasePreview(uint128) external view returns (uint128);\\n\\n    function fyToken() external returns (address);\\n\\n    function sellFYToken(address, uint128) external returns (uint128);\\n\\n    function sellFYTokenPreview(uint128) external view returns (uint128);\\n\\n    function buyBase(\\n        address,\\n        uint128,\\n        uint128\\n    ) external returns (uint128);\\n\\n    function buyBasePreview(uint128) external view returns (uint128);\\n\\n    function buyFYToken(\\n        address,\\n        uint128,\\n        uint128\\n    ) external returns (uint128);\\n\\n    function buyFYTokenPreview(uint128) external view returns (uint128);\\n}\\n\"\r\n    },\r\n    \"src/lib/Cast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.13;\\n\\nlibrary Cast {\\n    /// @dev Safely cast an uint256 to an uint128\\n    /// @param n the u256 to cast to u128\\n    function u128(uint256 n) internal pure returns (uint128) {\\n        if (n > type(uint128).max) {\\n            revert();\\n        }\\n        return uint128(n);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/Safe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Adapted from: https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol\\n\\npragma solidity ^0.8.13;\\n\\nimport 'src/interfaces/IERC20.sol';\\n\\n/**\\n  @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n  @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\\n  @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n*/\\n\\nlibrary Safe {\\n    /// @param e Erc20 token to execute the call with\\n    /// @param t To address\\n    /// @param a Amount being transferred\\n    function transfer(\\n        IERC20 e,\\n        address t,\\n        uint256 a\\n    ) internal {\\n        bool result;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let pointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(\\n                pointer,\\n                0xa9059cbb00000000000000000000000000000000000000000000000000000000\\n            ) // Begin with the function selector.\\n            mstore(\\n                add(pointer, 4),\\n                and(t, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(pointer, 36), a) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            result := call(gas(), e, 0, pointer, 68, 0, 0)\\n        }\\n\\n        require(success(result), 'transfer failed');\\n    }\\n\\n    /// @param e Erc20 token to execute the call with\\n    /// @param f From address\\n    /// @param t To address\\n    /// @param a Amount being transferred\\n    function transferFrom(\\n        IERC20 e,\\n        address f,\\n        address t,\\n        uint256 a\\n    ) internal {\\n        bool result;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let pointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(\\n                pointer,\\n                0x23b872dd00000000000000000000000000000000000000000000000000000000\\n            ) // Begin with the function selector.\\n            mstore(\\n                add(pointer, 4),\\n                and(f, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Mask and append the \\\"from\\\" argument.\\n            mstore(\\n                add(pointer, 36),\\n                and(t, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(pointer, 68), a) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 100 because the calldata length is 4 + 32 * 3.\\n            result := call(gas(), e, 0, pointer, 100, 0, 0)\\n        }\\n\\n        require(success(result), 'transfer from failed');\\n    }\\n\\n    /// @notice normalize the acceptable values of true or null vs the unacceptable value of false (or something malformed)\\n    /// @param r Return value from the assembly `call()` to Erc20['selector']\\n    function success(bool r) private pure returns (bool) {\\n        bool result;\\n\\n        assembly {\\n            // Get how many bytes the call returned.\\n            let returnDataSize := returndatasize()\\n\\n            // If the call reverted:\\n            if iszero(r) {\\n                // Copy the revert message into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Revert with the same message.\\n                revert(0, returnDataSize)\\n            }\\n\\n            switch returnDataSize\\n            case 32 {\\n                // Copy the return data into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Set success to whether it returned true.\\n                result := iszero(iszero(mload(0)))\\n            }\\n            case 0 {\\n                // There was no return data.\\n                result := 1\\n            }\\n            default {\\n                // It returned some malformed input.\\n                result := 0\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    function approve(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(\\n                freeMemoryPointer,\\n                0x095ea7b300000000000000000000000000000000000000000000000000000000\\n            ) // Begin with the function selector.\\n            mstore(\\n                add(freeMemoryPointer, 4),\\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\\n            ) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), 'APPROVE_FAILED');\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function didLastOptionalReturnCallSucceed(bool callStatus)\\n        private\\n        pure\\n        returns (bool)\\n    {\\n        bool result;\\n        assembly {\\n            // Get how many bytes the call returned.\\n            let returnDataSize := returndatasize()\\n\\n            // If the call reverted:\\n            if iszero(callStatus) {\\n                // Copy the revert message into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Revert with the same message.\\n                revert(0, returnDataSize)\\n            }\\n\\n            switch returnDataSize\\n            case 32 {\\n                // Copy the return data into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Set success to whether it returned true.\\n                result := iszero(iszero(mload(0)))\\n            }\\n            case 0 {\\n                // There was no return data.\\n                result := 1\\n            }\\n            default {\\n                // It returned some malformed input.\\n                result := 0\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Inspired on token.sol from DappHub. Natspec adpated from OpenZeppelin.\\npragma solidity 0.8.16;\\n\\nimport 'src/interfaces/IERC20Metadata.sol';\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Calls to {transferFrom} do not check for allowance if the caller is the owner\\n * of the funds. This allows to reduce the number of approvals that are necessary.\\n *\\n * Finally, {transferFrom} does not decrease the allowance if it is set to\\n * type(uint256).max. This reduces the gas costs without any likely impact.\\n */\\ncontract ERC20 is IERC20Metadata {\\n    uint256 internal _totalSupply;\\n    mapping(address => uint256) internal _balanceOf;\\n    mapping(address => mapping(address => uint256)) internal _allowance;\\n    string public override name = '???';\\n    string public override symbol = '???';\\n    uint8 public override decimals = 18;\\n\\n    /**\\n     *  @dev Sets the values for {name}, {symbol} and {decimals}.\\n     */\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_\\n    ) {\\n        name = name_;\\n        symbol = symbol_;\\n        decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() external view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address guy)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        return _balanceOf[guy];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        return _allowance[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     */\\n    function approve(address spender, uint256 wad)\\n        external\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return _setAllowance(msg.sender, spender, wad);\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have a balance of at least `wad`.\\n     */\\n    function transfer(address dst, uint256 wad)\\n        external\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return _transfer(msg.sender, dst, wad);\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `src` must have a balance of at least `wad`.\\n     * - the caller is not `src`, it must have allowance for ``src``'s tokens of at least\\n     * `wad`.\\n     */\\n    /// if_succeeds {:msg \\\"TransferFrom - decrease allowance\\\"} msg.sender != src ==> old(_allowance[src][msg.sender]) >= wad;\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 wad\\n    ) external virtual override returns (bool) {\\n        _decreaseAllowance(src, wad);\\n\\n        return _transfer(src, dst, wad);\\n    }\\n\\n    /**\\n     * @dev Moves tokens `wad` from `src` to `dst`.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `src` must have a balance of at least `amount`.\\n     */\\n    /// if_succeeds {:msg \\\"Transfer - src decrease\\\"} old(_balanceOf[src]) >= _balanceOf[src];\\n    /// if_succeeds {:msg \\\"Transfer - dst increase\\\"} _balanceOf[dst] >= old(_balanceOf[dst]);\\n    /// if_succeeds {:msg \\\"Transfer - supply\\\"} old(_balanceOf[src]) + old(_balanceOf[dst]) == _balanceOf[src] + _balanceOf[dst];\\n    function _transfer(\\n        address src,\\n        address dst,\\n        uint256 wad\\n    ) internal virtual returns (bool) {\\n        require(_balanceOf[src] >= wad, 'ERC20: Insufficient balance');\\n        unchecked {\\n            _balanceOf[src] = _balanceOf[src] - wad;\\n        }\\n        _balanceOf[dst] = _balanceOf[dst] + wad;\\n\\n        emit Transfer(src, dst, wad);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Sets the allowance granted to `spender` by `owner`.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     */\\n    function _setAllowance(\\n        address owner,\\n        address spender,\\n        uint256 wad\\n    ) internal virtual returns (bool) {\\n        _allowance[owner][spender] = wad;\\n        emit Approval(owner, spender, wad);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Decreases the allowance granted to the caller by `src`, unless src == msg.sender or _allowance[src][msg.sender] == MAX\\n     *\\n     * Emits an {Approval} event indicating the updated allowance, if the allowance is updated.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` must have allowance for the caller of at least\\n     * `wad`, unless src == msg.sender\\n     */\\n    /// if_succeeds {:msg \\\"Decrease allowance - underflow\\\"} old(_allowance[src][msg.sender]) <= _allowance[src][msg.sender];\\n    function _decreaseAllowance(address src, uint256 wad)\\n        internal\\n        virtual\\n        returns (bool)\\n    {\\n        if (src != msg.sender) {\\n            uint256 allowed = _allowance[src][msg.sender];\\n            if (allowed != type(uint256).max) {\\n                require(allowed >= wad, 'ERC20: Insufficient approval');\\n                unchecked {\\n                    _setAllowance(src, msg.sender, allowed - wad);\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /** @dev Creates `wad` tokens and assigns them to `dst`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     */\\n    /// if_succeeds {:msg \\\"Mint - balance overflow\\\"} old(_balanceOf[dst]) >= _balanceOf[dst];\\n    /// if_succeeds {:msg \\\"Mint - supply overflow\\\"} old(_totalSupply) >= _totalSupply;\\n    function _mint(address dst, uint256 wad) internal virtual returns (bool) {\\n        _balanceOf[dst] = _balanceOf[dst] + wad;\\n        _totalSupply = _totalSupply + wad;\\n        emit Transfer(address(0), dst, wad);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Destroys `wad` tokens from `src`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `src` must have at least `wad` tokens.\\n     */\\n    /// if_succeeds {:msg \\\"Burn - balance underflow\\\"} old(_balanceOf[src]) <= _balanceOf[src];\\n    /// if_succeeds {:msg \\\"Burn - supply underflow\\\"} old(_totalSupply) <= _totalSupply;\\n    function _burn(address src, uint256 wad) internal virtual returns (bool) {\\n        unchecked {\\n            require(_balanceOf[src] >= wad, 'ERC20: Insufficient balance');\\n            _balanceOf[src] = _balanceOf[src] - wad;\\n            _totalSupply = _totalSupply - wad;\\n            emit Transfer(src, address(0), wad);\\n        }\\n\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tokens/ERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol\\npragma solidity 0.8.16;\\n\\nimport 'src/tokens/ERC20.sol';\\nimport 'src/interfaces/IERC2612.sol';\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to use their tokens\\n * without sending any transactions by setting {IERC20-allowance} with a\\n * signature using the {permit} method, and then spend them via\\n * {IERC20-transferFrom}.\\n *\\n * The {permit} signature mechanism conforms to the {IERC2612} interface.\\n */\\nabstract contract ERC20Permit is ERC20, IERC2612 {\\n    mapping(address => uint256) public override nonces;\\n\\n    bytes32 public immutable PERMIT_TYPEHASH =\\n        keccak256(\\n            'Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)'\\n        );\\n    bytes32 private immutable _DOMAIN_SEPARATOR;\\n    uint256 public immutable deploymentChainId;\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_\\n    ) ERC20(name_, symbol_, decimals_) {\\n        deploymentChainId = block.chainid;\\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(block.chainid);\\n    }\\n\\n    /// @dev Calculate the DOMAIN_SEPARATOR.\\n    function _calculateDomainSeparator(uint256 chainId)\\n        private\\n        view\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\n                        'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\\n                    ),\\n                    keccak256(bytes(name)),\\n                    keccak256(bytes(version())),\\n                    chainId,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /// @dev Return the DOMAIN_SEPARATOR.\\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\\n        return\\n            block.chainid == deploymentChainId\\n                ? _DOMAIN_SEPARATOR\\n                : _calculateDomainSeparator(block.chainid);\\n    }\\n\\n    /// @dev Setting the version as a function so that it can be overriden\\n    function version() public pure virtual returns (string memory) {\\n        return '1';\\n    }\\n\\n    /**\\n     * @dev See {IERC2612-permit}.\\n     *\\n     * In cases where the free option is not a concern, deadline can simply be\\n     * set to uint(-1), so it should be seen as an optional parameter\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external virtual override {\\n        require(deadline >= block.timestamp, 'ERC20Permit: expired deadline');\\n\\n        bytes32 hashStruct = keccak256(\\n            abi.encode(\\n                PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                amount,\\n                nonces[owner]++,\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = keccak256(\\n            abi.encodePacked(\\n                '\\\\x19\\\\x01',\\n                block.chainid == deploymentChainId\\n                    ? _DOMAIN_SEPARATOR\\n                    : _calculateDomainSeparator(block.chainid),\\n                hashStruct\\n            )\\n        );\\n\\n        address signer = ecrecover(hash, v, r, s);\\n        require(\\n            signer != address(0) && signer == owner,\\n            'ERC20Permit: invalid signature'\\n        );\\n\\n        _setAllowance(owner, spender, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/tokens/ERC5095.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport 'src/tokens/ERC20Permit.sol';\\nimport 'src/interfaces/IERC5095.sol';\\nimport 'src/interfaces/IRedeemer.sol';\\nimport 'src/interfaces/IMarketPlace.sol';\\nimport 'src/interfaces/IYield.sol';\\nimport 'src/errors/Exception.sol';\\n\\nimport 'src/lib/Cast.sol';\\nimport 'src/lib/Safe.sol';\\n\\ncontract ERC5095 is ERC20Permit, IERC5095 {\\n    /// @dev unix timestamp when the ERC5095 token can be redeemed\\n    uint256 public immutable override maturity;\\n    /// @dev address of the ERC20 token that is returned on ERC5095 redemption\\n    address public immutable override underlying;\\n    /// @dev address of the minting authority\\n    address public immutable lender;\\n    /// @dev address of the \\\"marketplace\\\" YieldSpace AMM router\\n    address public immutable marketplace;\\n    ///@dev Interface to interact with the pool\\n    address public pool;\\n\\n    /// @dev address and interface for an external custody contract (necessary for some project's backwards compatability)\\n    address public immutable redeemer;\\n\\n    /// @notice ensures that only a certain address can call the function\\n    /// @param a address that msg.sender must be to be authorized\\n    modifier authorized(address a) {\\n        if (msg.sender != a) {\\n            revert Exception(0, 0, 0, msg.sender, a);\\n        }\\n        _;\\n    }\\n\\n    constructor(\\n        address _underlying,\\n        uint256 _maturity,\\n        address _redeemer,\\n        address _lender,\\n        address _marketplace,\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_\\n    ) ERC20Permit(name_, symbol_, decimals_) {\\n        underlying = _underlying;\\n        maturity = _maturity;\\n        redeemer = _redeemer;\\n        lender = _lender;\\n        marketplace = _marketplace;\\n        pool = address(0);\\n    }\\n\\n    /// @notice Allows the marketplace to set the pool\\n    /// @param p Address of the pool\\n    /// @return bool True if successful\\n    function setPool(address p)\\n        external\\n        authorized(marketplace)\\n        returns (bool)\\n    {\\n        pool = p;\\n        return true;\\n    }\\n\\n    /// @notice Allows the marketplace to spend underlying, principal tokens held by the token\\n    /// @dev This is necessary when MarketPlace calls pool methods to swap tokens\\n    /// @return True if successful\\n    function approveMarketPlace()\\n        external\\n        authorized(marketplace)\\n        returns (bool)\\n    {\\n        // Approve the marketplace to spend the token's underlying\\n        Safe.approve(IERC20(underlying), marketplace, type(uint256).max);\\n\\n        // Approve the marketplace to spend illuminate PTs\\n        Safe.approve(IERC20(address(this)), marketplace, type(uint256).max);\\n\\n        return true;\\n    }\\n\\n    /// @notice Post or at maturity, converts an amount of principal tokens to an amount of underlying that would be returned.\\n    /// @param s The amount of principal tokens to convert\\n    /// @return uint256 The amount of underlying tokens returned by the conversion\\n    function convertToUnderlying(uint256 s)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        if (block.timestamp < maturity) {\\n            return previewRedeem(s);\\n        }\\n        return s;\\n    }\\n\\n    /// @notice Post or at maturity, converts a desired amount of underlying tokens returned to principal tokens needed.\\n    /// @param a The amount of underlying tokens to convert\\n    /// @return uint256 The amount of principal tokens returned by the conversion\\n    function convertToShares(uint256 a)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        if (block.timestamp < maturity) {\\n            return previewWithdraw(a);\\n        }\\n        return a;\\n    }\\n\\n    /// @notice Returns user's PT balance\\n    /// @param o The address of the owner for which redemption is calculated\\n    /// @return uint256 The maximum amount of principal tokens that `owner` can redeem.\\n    function maxRedeem(address o) external view override returns (uint256) {\\n        return _balanceOf[o];\\n    }\\n\\n    /// @notice Post or at maturity, returns user's PT balance. Prior to maturity, returns a previewRedeem for owner's PT balance.\\n    /// @param  o The address of the owner for which withdrawal is calculated\\n    /// @return uint256 maximum amount of underlying tokens that `owner` can withdraw.\\n    function maxWithdraw(address o) external view override returns (uint256) {\\n        if (block.timestamp < maturity) {\\n            return previewRedeem(_balanceOf[o]);\\n        }\\n        return _balanceOf[o];\\n    }\\n\\n    /// @notice After maturity, returns 0. Prior to maturity, returns the amount of `shares` when spending `a` in underlying on a YieldSpace AMM.\\n    /// @param a The amount of underlying spent\\n    /// @return uint256 The amount of PT purchased by spending `a` of underlying\\n    function previewDeposit(uint256 a) public view returns (uint256) {\\n        if (block.timestamp < maturity) {\\n            return IYield(pool).sellBasePreview(Cast.u128(a));\\n        }\\n        return 0;\\n    }\\n\\n    /// @notice After maturity, returns 0. Prior to maturity, returns the amount of `assets` in underlying spent on a purchase of `s` in PT on a YieldSpace AMM.\\n    /// @param s The amount of principal tokens bought in the simulation\\n    /// @return uint256 The amount of underlying required to purchase `s` of PT\\n    function previewMint(uint256 s) public view returns (uint256) {\\n        if (block.timestamp < maturity) {\\n            return IYield(pool).buyFYTokenPreview(Cast.u128(s));\\n        }\\n        return 0;\\n    }\\n\\n    /// @notice Post or at maturity, simulates the effects of redemption. Prior to maturity, returns the amount of `assets` from a sale of `s` PTs on a YieldSpace AMM.\\n    /// @param s The amount of principal tokens redeemed in the simulation\\n    /// @return uint256 The amount of underlying returned by `s` of PT redemption\\n    function previewRedeem(uint256 s) public view override returns (uint256) {\\n        if (block.timestamp >= maturity) {\\n            // After maturity, the amount redeemed is based on the Redeemer contract's holdings of the underlying\\n            return\\n                Cast.u128(\\n                    s *\\n                        Cast.u128(\\n                            IRedeemer(redeemer).holdings(underlying, maturity)\\n                        )\\n                ) / _totalSupply;\\n        }\\n\\n        // Prior to maturity, return a a preview of a swap on the pool\\n        return IYield(pool).sellFYTokenPreview(Cast.u128(s));\\n    }\\n\\n    /// @notice Post or at maturity, simulates the effects of withdrawal at the current block. Prior to maturity, simulates the amount of PTs necessary to receive `a` in underlying from the sale of PTs on a YieldSpace AMM.\\n    /// @param a The amount of underlying tokens withdrawn in the simulation\\n    /// @return uint256 The amount of principal tokens required for the withdrawal of `a`\\n    function previewWithdraw(uint256 a) public view override returns (uint256) {\\n        if (block.timestamp >= maturity) {\\n            // After maturity, the amount redeemed is based on the Redeemer contract's holdings of the underlying\\n            return\\n                (a * _totalSupply) /\\n                IRedeemer(redeemer).holdings(underlying, maturity);\\n        }\\n\\n        // Prior to maturity, return a a preview of a swap on the pool\\n        return IYield(pool).buyBasePreview(Cast.u128(a));\\n    }\\n\\n    /// @notice Before maturity spends `a` of underlying, and sends PTs to `r`. Post or at maturity, reverts.\\n    /// @param a The amount of underlying tokens deposited\\n    /// @param r The receiver of the principal tokens\\n    /// @param m Minimum number of shares that the user will receive\\n    /// @return uint256 The amount of principal tokens purchased\\n    function deposit(\\n        uint256 a,\\n        address r,\\n        uint256 m\\n    ) external returns (uint256) {\\n        // Execute the deposit\\n        return _deposit(r, a, m);\\n    }\\n\\n    /// @notice Before maturity spends `assets` of underlying, and sends `shares` of PTs to `receiver`. Post or at maturity, reverts.\\n    /// @param a The amount of underlying tokens deposited\\n    /// @param r The receiver of the principal tokens\\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\\n    function deposit(uint256 a, address r) external override returns (uint256) {\\n        // Execute the deposit\\n        return _deposit(r, a, 0);\\n    }\\n\\n    /// @notice Before maturity mints `s` of PTs to `r` by spending underlying. Post or at maturity, reverts.\\n    /// @param s The amount of shares being minted\\n    /// @param r The receiver of the underlying tokens being withdrawn\\n    /// @param m Maximum amount of underlying that the user will spend\\n    /// @return uint256 The amount of principal tokens purchased\\n    function mint(\\n        uint256 s,\\n        address r,\\n        uint256 m\\n    ) external returns (uint256) {\\n        // Execute the mint\\n        return _mint(r, s, m);\\n    }\\n\\n    /// @notice Before maturity mints `shares` of PTs to `receiver` by spending underlying. Post or at maturity, reverts.\\n    /// @param s The amount of shares being minted\\n    /// @param r The receiver of the underlying tokens being withdrawn\\n    /// @return uint256 The amount of principal tokens purchased\\n    function mint(uint256 s, address r) external override returns (uint256) {\\n        // Execute the mint\\n        return _mint(r, s, type(uint128).max);\\n    }\\n\\n    /// @notice At or after maturity, burns PTs from owner and sends `a` underlying to `r`. Before maturity, sends `a` by selling shares of PT on a YieldSpace AMM.\\n    /// @param a The amount of underlying tokens withdrawn\\n    /// @param r The receiver of the underlying tokens being withdrawn\\n    /// @param o The owner of the underlying tokens\\n    /// @param m Maximum amount of PTs to be sold\\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\\n    function withdraw(\\n        uint256 a,\\n        address r,\\n        address o,\\n        uint256 m\\n    ) external returns (uint256) {\\n        // Execute the withdrawal\\n        return _withdraw(a, r, o, m);\\n    }\\n\\n    /// @notice At or after maturity, burns PTs from owner and sends `a` underlying to `r`. Before maturity, sends `a` by selling shares of PT on a YieldSpace AMM.\\n    /// @param a The amount of underlying tokens withdrawn\\n    /// @param r The receiver of the underlying tokens being withdrawn\\n    /// @param o The owner of the underlying tokens\\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\\n    function withdraw(\\n        uint256 a,\\n        address r,\\n        address o\\n    ) external override returns (uint256) {\\n        // Execute the withdrawal\\n        return _withdraw(a, r, o, type(uint128).max);\\n    }\\n\\n    /// @notice At or after maturity, burns exactly `s` of Principal Tokens from `o` and sends underlying tokens to `r`. Before maturity, sends underlying by selling `s` of PT on a YieldSpace AMM.\\n    /// @param s The number of shares to be burned in exchange for the underlying asset\\n    /// @param r The receiver of the underlying tokens being withdrawn\\n    /// @param o Address of the owner of the shares being burned\\n    /// @param m Minimum amount of underlying that must be received\\n    /// @return uint256 The amount of underlying tokens distributed by the redemption\\n    function redeem(\\n        uint256 s,\\n        address r,\\n        address o,\\n        uint256 m\\n    ) external returns (uint256) {\\n        // Execute the redemption\\n        return _redeem(s, r, o, m);\\n    }\\n\\n    /// @notice At or after maturity, burns exactly `shares` of Principal Tokens from `owner` and sends `assets` of underlying tokens to `receiver`. Before maturity, sells `s` of PT on a YieldSpace AMM.\\n    /// @param s The number of shares to be burned in exchange for the underlying asset\\n    /// @param r The receiver of the underlying tokens being withdrawn\\n    /// @param o Address of the owner of the shares being burned\\n    /// @return uint256 The amount of underlying tokens distributed by the redemption\\n    function redeem(\\n        uint256 s,\\n        address r,\\n        address o\\n    ) external override returns (uint256) {\\n        // Execute the redemption\\n        return _redeem(s, r, o, 0);\\n    }\\n\\n    /// @param f Address to burn from\\n    /// @param a Amount to burn\\n    /// @return bool true if successful\\n    function authBurn(address f, uint256 a)\\n        external\\n        authorized(redeemer)\\n        returns (bool)\\n    {\\n        _burn(f, a);\\n        return true;\\n    }\\n\\n    /// @param t Address recieving the minted amount\\n    /// @param a The amount to mint\\n    /// @return bool True if successful\\n    function authMint(address t, uint256 a)\\n        external\\n        authorized(lender)\\n        returns (bool)\\n    {\\n        _mint(t, a);\\n        return true;\\n    }\\n\\n    /// @param o Address of the owner of the tokens\\n    /// @param s Address of the spender\\n    /// @param a Amount to be approved\\n    function authApprove(\\n        address o,\\n        address s,\\n        uint256 a\\n    ) external authorized(redeemer) returns (bool) {\\n        _allowance[o][s] = a;\\n        return true;\\n    }\\n\\n    function _deposit(\\n        address r,\\n        uint256 a,\\n        uint256 m\\n    ) internal returns (uint256) {\\n        // Revert if called at or after maturity\\n        if (block.timestamp >= maturity) {\\n            revert Exception(\\n                21,\\n                block.timestamp,\\n                maturity,\\n                address(0),\\n                address(0)\\n            );\\n        }\\n\\n        // Receive the funds from the sender\\n        Safe.transferFrom(IERC20(underlying), msg.sender, address(this), a);\\n\\n        // Sell the underlying assets for PTs\\n        uint128 returned = IMarketPlace(marketplace).sellUnderlying(\\n            underlying,\\n            maturity,\\n            Cast.u128(a),\\n            Cast.u128(m)\\n        );\\n\\n        // Pass the received shares onto the intended receiver\\n        _transfer(address(this), r, returned);\\n\\n        return returned;\\n    }\\n\\n    function _mint(\\n        address r,\\n        uint256 s,\\n        uint256 m\\n    ) internal returns (uint256) {\\n        // Revert if called at or after maturity\\n        if (block.timestamp >= maturity) {\\n            revert Exception(\\n                21,\\n                block.timestamp,\\n                maturity,\\n                address(0),\\n                address(0)\\n            );\\n        }\\n\\n        // Determine how many underlying tokens are needed to mint the shares\\n        uint256 required = IYield(pool).buyFYTokenPreview(Cast.u128(s));\\n\\n        // Transfer the underlying to the token\\n        Safe.transferFrom(\\n            IERC20(underlying),\\n            msg.sender,\\n            address(this),\\n            required\\n        );\\n\\n        // Swap the underlying for principal tokens via the pool\\n        uint128 sold = IMarketPlace(marketplace).buyPrincipalToken(\\n            underlying,\\n            maturity,\\n            Cast.u128(s),\\n            Cast.u128(m)\\n        );\\n\\n        // Transfer the principal tokens to the desired receiver\\n        _transfer(address(this), r, s);\\n\\n        return sold;\\n    }\\n\\n    function _withdraw(\\n        uint256 a,\\n        address r,\\n        address o,\\n        uint256 m\\n    ) internal returns (uint256) {\\n        // Determine how many principal tokens are needed to purchase the underlying\\n        uint256 needed = previewWithdraw(a);\\n\\n        // Pre maturity\\n        if (block.timestamp < maturity) {\\n            // Receive the shares from the caller\\n            _transfer(o, address(this), needed);\\n\\n            // If owner is the sender, sell PT without allowance check\\n            if (o == msg.sender) {\\n                uint128 returned = IMarketPlace(marketplace).buyUnderlying(\\n                    underlying,\\n                    maturity,\\n                    Cast.u128(a),\\n                    Cast.u128(m)\\n                );\\n\\n                // Transfer the underlying to the desired receiver\\n                Safe.transfer(IERC20(underlying), r, a);\\n\\n                return returned;\\n            } else {\\n                // Else, sell PT with allowance check\\n                // Get the allowance of the user spending the tokens\\n                uint256 allowance = _allowance[o][msg.sender];\\n\\n                // Check for sufficient allowance\\n                if (allowance < needed) {\\n                    revert Exception(20, allowance, a, address(0), address(0));\\n                }\\n\\n                // Update the caller's allowance\\n                _allowance[o][msg.sender] = allowance - needed;\\n\\n                // Sell the principal tokens for underlying\\n                uint128 returned = IMarketPlace(marketplace).buyUnderlying(\\n                    underlying,\\n                    maturity,\\n                    Cast.u128(a),\\n                    Cast.u128(m)\\n                );\\n\\n                // Transfer the underlying to the desired receiver\\n                Safe.transfer(IERC20(underlying), r, returned);\\n\\n                return returned;\\n            }\\n        }\\n        // Post maturity\\n        else {\\n            // If owner is the sender, redeem PT without allowance check\\n            if (o == msg.sender) {\\n                // Execute the redemption to the desired receiver\\n                return\\n                    IRedeemer(redeemer).authRedeem(\\n                        underlying,\\n                        maturity,\\n                        msg.sender,\\n                        r,\\n                        needed\\n                    );\\n            } else {\\n                // Get the allowance of the user spending the tokens\\n                uint256 allowance = _allowance[o][msg.sender];\\n\\n                // Check for sufficient allowance\\n                if (allowance < needed) {\\n                    revert Exception(\\n                        20,\\n                        allowance,\\n                        needed,\\n                        address(0),\\n                        address(0)\\n                    );\\n                }\\n\\n                // Update the callers's allowance\\n                _allowance[o][msg.sender] = allowance - needed;\\n\\n                // Execute the redemption to the desired receiver\\n                return\\n                    IRedeemer(redeemer).authRedeem(\\n                        underlying,\\n                        maturity,\\n                        o,\\n                        r,\\n                        needed\\n                    );\\n            }\\n        }\\n    }\\n\\n    function _redeem(\\n        uint256 s,\\n        address r,\\n        address o,\\n        uint256 m\\n    ) internal returns (uint256) {\\n        // Pre-maturity\\n        if (block.timestamp < maturity) {\\n            // Receive the funds from the user\\n            _transfer(o, address(this), s);\\n\\n            // If owner is the sender, sell PT without allowance check\\n            if (o == msg.sender) {\\n                // Swap principal tokens for the underlying asset\\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\\n                    underlying,\\n                    maturity,\\n                    Cast.u128(s),\\n                    Cast.u128(m)\\n                );\\n\\n                // Transfer underlying to the desired receiver\\n                Safe.transfer(IERC20(underlying), r, returned);\\n                return returned;\\n                // Else, sell PT with allowance check\\n            } else {\\n                // Get the allowance of the user spending the tokens\\n                uint256 allowance = _allowance[o][msg.sender];\\n\\n                // Check for sufficient allowance\\n                if (allowance < s) {\\n                    revert Exception(20, allowance, s, address(0), address(0));\\n                }\\n\\n                // Update the caller's allowance\\n                _allowance[o][msg.sender] = allowance - s;\\n\\n                // Sell the principal tokens for the underlying\\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\\n                    underlying,\\n                    maturity,\\n                    Cast.u128(s),\\n                    Cast.u128(m)\\n                );\\n\\n                // Transfer the underlying to the desired receiver\\n                Safe.transfer(IERC20(underlying), r, returned);\\n                return returned;\\n            }\\n            // Post-maturity\\n        } else {\\n            // If owner is the sender, redeem PT without allowance check\\n            if (o == msg.sender) {\\n                // Execute the redemption to the desired receiver\\n                return\\n                    IRedeemer(redeemer).authRedeem(\\n                        underlying,\\n                        maturity,\\n                        msg.sender,\\n                        r,\\n                        s\\n                    );\\n            } else {\\n                // Get the allowance of the user spending the tokens\\n                uint256 allowance = _allowance[o][msg.sender];\\n\\n                // Check for sufficient allowance\\n                if (allowance < s) {\\n                    revert Exception(20, allowance, s, address(0), address(0));\\n                }\\n\\n                // Update the caller's allowance\\n                _allowance[o][msg.sender] = allowance - s;\\n\\n                // Execute the redemption to the desired receiver\\n                return\\n                    IRedeemer(redeemer).authRedeem(\\n                        underlying,\\n                        maturity,\\n                        o,\\n                        r,\\n                        s\\n                    );\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_underlying\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maturity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_redeemer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketplace\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Exception\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approveMarketPlace\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"o\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"s\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"authApprove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"f\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"authBurn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"authMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"convertToShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"}],\"name\":\"convertToUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deploymentChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"r\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"r\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketplace\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maturity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"o\",\"type\":\"address\"}],\"name\":\"maxRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"o\",\"type\":\"address\"}],\"name\":\"maxWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"r\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"r\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"previewDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"}],\"name\":\"previewMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"}],\"name\":\"previewRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"previewWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"r\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"o\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"r\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"o\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"p\",\"type\":\"address\"}],\"name\":\"setPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"r\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"o\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"r\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"o\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ERC5095", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000000000000000000000000000000000000064a20f800000000000000000000000004ea57ef203e91ae8c7d9822aa09cc719a9c01ac6000000000000000000000000429b47c4aeadd42bbcb118651c8984086bfc4551000000000000000000000000cd1d02fda51cd24123e857ce94e4356d5c073b3f0000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000012697074555344432d313638383334323430300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d697074555344432d4a554e323300000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}