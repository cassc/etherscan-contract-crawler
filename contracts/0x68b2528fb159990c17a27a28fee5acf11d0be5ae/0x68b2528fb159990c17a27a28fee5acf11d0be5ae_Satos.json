{"SourceCode": "{\"ERC1967Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\nimport \\\"./proxy.sol\\\";\\r\\nimport \\\"./ERC1967Upgrade.sol\\\";\\r\\n\\r\\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\\r\\n    /**\\r\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\r\\n     *\\r\\n     * If `_data` is nonempty, it\\u0027s used as data in a delegate call to `_logic`. This will typically be an encoded\\r\\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\\r\\n     */\\r\\n    constructor(address _logic, bytes memory _data) payable {\\r\\n        _upgradeToAndCall(_logic, _data, false);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the current implementation address.\\r\\n     */\\r\\n    function _implementation() internal view virtual override returns (address impl) {\\r\\n        return ERC1967Upgrade._getImplementation();\\r\\n    }\\r\\n}\"},\"ERC1967Trans.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport \\\"./ERC1967Proxy.sol\\\";\\r\\n\\r\\ncontract Satos is ERC1967Proxy {\\r\\n    /**\\r\\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\\r\\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\\r\\n     */\\r\\n    constructor(address _logic) payable ERC1967Proxy(_logic, bytes(\\\"\\\")) {}\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the current implementation.\\r\\n     *\\r\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\\r\\n     *\\r\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\r\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\r\\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\\r\\n     */\\r\\n    function implementation() public view returns (address) {\\r\\n        return _implementation();\\r\\n    }\\r\\n}\"},\"ERC1967Upgrade.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nabstract contract ERC1967Upgrade {\\r\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\r\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\r\\n\\r\\n    /**\\r\\n     * @dev Storage slot with the address of the current implementation.\\r\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\r\\n     * validated in the constructor.\\r\\n     */\\r\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the implementation is upgraded.\\r\\n     */\\r\\n    event Upgraded(address indexed implementation);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the current implementation address.\\r\\n     */\\r\\n    function _getImplementation() internal view returns (address) {\\r\\n        return getAddressSlot(_IMPLEMENTATION_SLOT).value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\r\\n     */\\r\\n    function _setImplementation(address newImplementation) private {\\r\\n        // require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\r\\n        getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Perform implementation upgrade\\r\\n     *\\r\\n     * Emits an {Upgraded} event.\\r\\n     */\\r\\n    function _upgradeTo(address newImplementation) internal {\\r\\n        _setImplementation(newImplementation);\\r\\n        emit Upgraded(newImplementation);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Perform implementation upgrade with additional setup call.\\r\\n     *\\r\\n     * Emits an {Upgraded} event.\\r\\n     */\\r\\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\\r\\n        _upgradeTo(newImplementation);\\r\\n        // if (data.length \\u003e 0 || forceCall) {\\r\\n        //     functionDelegateCall(newImplementation, data, \\\"Address: low-level delegate call failed\\\");\\r\\n        // }\\r\\n    }\\r\\n\\r\\n    struct AddressSlot {\\r\\n        address value;\\r\\n    }\\r\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n}\"},\"proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT                                                                                                                                                                                                                                                       \\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nabstract contract Proxy {\\r\\n    /**\\r\\n     * @dev Delegates the current call to `implementation`.\\r\\n     *\\r\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\r\\n     */\\r\\n    function _delegate(address implementation) internal virtual {\\r\\n        assembly {\\r\\n            // Copy msg.data. We take full control of memory in this inline assembly\\r\\n            // block because it will not return to Solidity code. We overwrite the\\r\\n            // Solidity scratch pad at memory position 0.\\r\\n            calldatacopy(0, 0, calldatasize())\\r\\n\\r\\n            // Call the implementation.\\r\\n            // out and outsize are 0 because we don\\u0027t know the size yet.\\r\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\r\\n\\r\\n            // Copy the returned data.\\r\\n            returndatacopy(0, 0, returndatasize())\\r\\n\\r\\n            switch result\\r\\n            // delegatecall returns 0 on error.\\r\\n            case 0 {\\r\\n                revert(0, returndatasize())\\r\\n            }\\r\\n            default {\\r\\n                return(0, returndatasize())\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\r\\n     * and {_fallback} should delegate.\\r\\n     */\\r\\n    function _implementation() internal view virtual returns (address);\\r\\n\\r\\n    /**\\r\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\r\\n     *\\r\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\r\\n     */\\r\\n    function _fallback() internal virtual {\\r\\n        _delegate(_implementation());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\r\\n     * function in the contract matches the call data.\\r\\n     */\\r\\n    fallback() external payable virtual {\\r\\n        _fallback();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\r\\n     * is empty.\\r\\n     */\\r\\n    receive() external payable virtual {\\r\\n        _fallback();\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Satos", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000552e3b33fbfda2cdd1a03a5320826620a7d26916", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0x552e3b33fbfda2cdd1a03a5320826620a7d26916", "SwarmSource": "ipfs://852b7ecca623bef6bd2c0ac2bfea5887944acc94f405e7dfbb98706f4cd1d2cb"}