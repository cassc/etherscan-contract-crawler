{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/automation.sol\": {\r\n      \"content\": \"import \\\"./interface/IERC20.sol\\\";\\n\\ncontract automation{\\n    constructor(){}\\n\\n    receive() external payable{}\\n    fallback() external payable{}\\n    bytes32[40] private gap;\\n    address public owner;\\n    address public operator;\\n\\n    function initialize() external{\\n        address _owner = owner;\\n        require(_owner == address(0) || _owner == msg.sender, \\\"failed initialize\\\");\\n        if( _owner != msg.sender) _transferOwnership(msg.sender);\\n\\n    }\\n\\n    modifier onlyOwner(){\\n        require(owner == msg.sender, \\\"access denied. owner ONLY.\\\");\\n        _;\\n    }\\n\\n    function setOperator(address _operator) external onlyOwner{\\n        operator = _operator;\\n    }\\n\\n    function transferOwnership(address _to) external onlyOwner{\\n        _transferOwnership(_to);\\n    }\\n\\n    function performUpkeep(bytes calldata _performData) external payable{\\n        (address target, bytes memory payload, bool delegateCall) = abi.decode(_performData, (address, bytes, bool));\\n        bool success;\\n        bytes memory data;\\n        if( delegateCall == true ){\\n            require(operator == msg.sender || owner == msg.sender, \\\"operator or owner ONLY\\\");\\n            (success, data) = target.delegatecall(payload);\\n        }\\n        else{\\n            (success, data) = target.staticcall(abi.encodeWithSignature(\\\"owner()\\\"));\\n            require(success == true && abi.decode(data, (address)) == owner, \\\"owner contract ONLY\\\");\\n            (success, data) = target.call(payload);\\n        }\\n        if( success == false ){\\n            assembly{data:= add(data, 4)}\\n            revert(abi.decode(data, (string)));\\n        }\\n    }\\n\\n    function checkUpkeep(bytes calldata _checkData) external view returns(bool upKeepNeeded, bytes memory performData){\\n        (address target, bytes memory payload) = abi.decode(_checkData, (address, bytes));\\n        (bool success, bytes memory data) = target.staticcall(payload);\\n        require(success == true, \\\"failed to call function\\\");\\n        (upKeepNeeded, performData) = abi.decode(data, (bool, bytes));\\n    }\\n\\n    function sweep(IERC20[] memory tokens, uint256[] memory amounts) external{\\n        uint256 length = tokens.length;\\n        address _owner = owner;\\n        for(uint256 i=0; i<length; i++){tokens[i].transfer(_owner, amounts[i]);}\\n    }\\n\\n    function _transferOwnership(address _to) internal{\\n        owner = _to;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IERC20.sol\": {\r\n      \"content\": \"interface IERC20{\\n    function balanceOf(address) external view returns(uint256);\\n    function transfer(address, uint256) external;\\n    function transferFrom(address, address, uint256) external;\\n    function approve(address, uint256) external;\\n    function totalSupply() external view returns(uint256);\\n    function decimals() external view returns(uint256);\\n    function symbol() external view returns(string memory);\\n\\n    function withdraw(uint256) external;\\n    function deposit() external payable;\\n}\\n\\ninterface _IERC20 is IERC20{}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_checkData\",\"type\":\"bytes\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"upKeepNeeded\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_performData\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"sweep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "automation", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}