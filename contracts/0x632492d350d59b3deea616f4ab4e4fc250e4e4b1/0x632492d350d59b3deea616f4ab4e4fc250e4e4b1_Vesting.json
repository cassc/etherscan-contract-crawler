{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\ninterface IERC20 {\\n    function decimals() external view returns (uint256);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\ninterface IVesting {\\n\\n    event RegisterUser(uint256 totalTokens, address userAddress, uint8 choice);\\n    \\n    event ClaimedToken(\\n        address userAddress,\\n        uint256 claimedAmount,\\n        uint32 timestamp,\\n        uint8 claimCount,\\n        uint8 choice\\n    );\\n\\n    function registerUserByICO(\\n        uint256 _amount,\\n        uint8 _choice,\\n        address _to\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0x095ea7b3, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::safeApprove: approve failed\\\"\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0xa9059cbb, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::safeTransfer: transfer failed\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::transferFrom: transferFrom failed\\\"\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(\\n            success,\\n            \\\"TransferHelper::safeTransferETH: ETH transfer failed\\\"\\n        );\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\\n\\n\"\r\n    },\r\n    \"contracts/Vesting.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./utils/ReentrancyGuard.sol\\\";\\nimport \\\"./libraries/TransferHelper.sol\\\";\\nimport \\\"./interfaces/IVesting.sol\\\";\\n\\ncontract Vesting is Ownable, IVesting, ReentrancyGuard {\\n    uint256 public tokenPendingInICO;\\n    address public ICOAddress;\\n    address public receiverAddress = 0xDF155a928dBB5556C52DC0c51b81308d6F41925D;\\n\\n    address public ECOSYSTEM = 0x4C663c5aac163C3D4ed05BF56F5A7A678c39C5C3;\\n    address public TREASURY = 0x4fb7C4a2E7aa00bD1E0e12Cad888a017255E56fB;\\n    address public TEAM = 0x35ca63B94477e0f1bC75BBc96791c354f99E6311;\\n    address public MARKETING = 0x6ca65f2C2D4baD405951E783522fF42e047da87B;\\n    address public ADVERTISED = 0xdB8e6E648CBAC55286f6573124EC935470E1aAe7;\\n\\n    /**\\n     * User Data Structure for users info like:-\\n     * Users total amount for claim.\\n     * Users claimed amount that is till claimed.\\n     * Users claim for how many times user claims the amount.\\n     * The Categories are:-\\n     *      Refferal vesting = 0\\n     *      ICO phase 1 = 1\\n     *      ICO phase 2 = 2\\n     *      ICO phase 3 = 3\\n     *      ICO phase 4 = 4\\n     *      ECOSYSTEM = 5\\n     *      TREASURY = 6\\n     *      TEAM = 7\\n     *      MARKETING = 8\\n     *      ADVERTISED = 9\\n     */\\n    struct UserData {\\n        uint256 totalAmount;\\n        uint256 claimedAmount;\\n        uint8 claims;\\n    }\\n\\n    struct VestingPhase {\\n        uint256 percentage;\\n        uint32 time;\\n        uint8 claims;\\n    }\\n\\n    /* Users Mapping for Users Info. */\\n    mapping(address => mapping(uint8 => UserData)) public userMapping;\\n\\n    /*  Time Mapping for Vesting Category to Start.\\n     */\\n    mapping(uint8 => VestingPhase) internal vestingPhaseMapping;\\n\\n    IERC20 public token; /* Dregn token instance */\\n\\n    constructor(\\n        address _tokenAddress\\n    ) {\\n\\n        token = IERC20(_tokenAddress);\\n\\n        tokenPendingInICO = (24_000_100 * (10 ** token.decimals()));\\n\\n        /* Setting the Vesting Total Amount and Time of Categories */\\n        setVestingCategory(10000, 1698796800, 0, 1); //1 Nov 2023\\n        setVestingCategory(1666, 1714521600, 1, 6); //1 May 2024\\n        setVestingCategory(1666, 1709251200, 2, 6); //1 Mar 2024\\n        setVestingCategory(833, 1698796800, 3, 12); //1 Nov 2023\\n        setVestingCategory(10000, 1698796800, 4, 1); //1 Nov 2023\\n        setVestingCategory(416, 1698796800, 5, 24); //1 Nov 2023\\n        setVestingCategory(416, 1698796800, 6, 24); //1 Nov 2023\\n        setVestingCategory(416, 1722470400, 7, 24); //1 Aug 2024\\n        setVestingCategory(416, 1698796800, 8, 24); //1 Nov 2023\\n        setVestingCategory(10000, 1693526400, 9, 1); //1 sep 2023\\n\\n        /* setup the team vesting */\\n        registerUser((10_000_000 * (10 ** token.decimals())), 5, ECOSYSTEM);\\n        registerUser((5_000_000 * (10 ** token.decimals())), 6, TREASURY);\\n        registerUser((5_000_000 * (10 ** token.decimals())), 7, TEAM);\\n        registerUser((5_000_000 * (10 ** token.decimals())), 8, MARKETING);\\n        registerUser((999_900 * (10 ** token.decimals())), 9, ADVERTISED);\\n    }\\n\\n    /* Receive Function */\\n    receive() external payable {\\n        /* Sending deposited currency to the receiver address */\\n        TransferHelper.safeTransferETH(receiverAddress, msg.value);\\n    }\\n\\n    /* =============== Register The Address For Claiming ===============*/\\n    function setVestingCategory(\\n        uint256 _percentage,\\n        uint32 _time,\\n        uint8 _choice,\\n        uint8 _claims\\n    ) internal {\\n        VestingPhase storage phase = vestingPhaseMapping[_choice];\\n        phase.percentage = _percentage;\\n        phase.time = _time;\\n        phase.claims = _claims;\\n    }\\n\\n    /* =============== Register The Address For Claiming ===============*/\\n\\n    /**\\n     * Register User for Vesting\\n     * _amount for Total Claimable Amount\\n     * _choice for Vesting Category\\n     * _to for User's Address\\n     */\\n    function registerUser(\\n        uint256 _amount,\\n        uint8 _choice,\\n        address _to\\n    ) internal returns (bool) {\\n        UserData storage user = userMapping[_to][_choice];\\n\\n        user.totalAmount += _amount;\\n\\n        emit RegisterUser(_amount, _to, _choice);\\n\\n        return (true);\\n    }\\n\\n    function registerUserByICO(\\n        uint256 _amount,\\n        uint8 _choice,\\n        address _to\\n    ) external returns (bool) {\\n        require(ICOAddress == msg.sender, \\\"Access Denied.\\\");\\n        require(_choice < 5, \\\"You can only set ICO Phase Vesting.\\\");\\n        tokenPendingInICO -= _amount;\\n        return registerUser(_amount, _choice, _to);\\n    }\\n\\n    function updateICOAddress(address _ICOAddress) external onlyOwner {\\n        require(_ICOAddress != address(0), \\\"Zero address passed.\\\");\\n        ICOAddress = _ICOAddress;\\n    }\\n\\n    /* =============== Token Claiming Functions =============== */\\n    /**\\n     * User can claim the tokens with claimTokens function.\\n     * after start the vesting for that particular vesting category.\\n     */\\n    function claimTokens(uint8 _choice) external nonReentrant {\\n        address _msgSender = msg.sender; \\n        require(\\n            userMapping[_msgSender][_choice].totalAmount > 0,\\n            \\\"User is not registered with this vesting.\\\"\\n        );\\n\\n        (uint256 _amount, uint8 _claimCount) = tokensToBeClaimed(\\n            _msgSender,\\n            _choice\\n        );\\n\\n        require(_amount > 0, \\\"Nothing to claim right now.\\\");\\n\\n        UserData storage user = userMapping[_msgSender][_choice];\\n        user.claimedAmount += _amount;\\n        user.claims = _claimCount;\\n\\n        TransferHelper.safeTransfer(address(token), _msgSender, _amount);\\n\\n        uint8 claims = uint8(vestingPhaseMapping[_choice].claims);\\n        if (claims == _claimCount) {\\n            delete userMapping[_msgSender][_choice];\\n        }\\n\\n        emit ClaimedToken(\\n            _msgSender,\\n            _amount,\\n            uint32(block.timestamp),\\n            _claimCount,\\n            _choice\\n        );\\n    }\\n\\n    /* =============== Tokens to be claimed =============== */\\n    /**\\n     * tokensToBeClaimed function can be used for checking the claimable amount of the user.\\n     */\\n    function tokensToBeClaimed(\\n        address _to,\\n        uint8 _choice\\n    ) public view returns (uint256 _toBeTransfer, uint8 _claimCount) {\\n        UserData memory user = userMapping[_to][_choice];\\n        if (\\n            (block.timestamp < (vestingPhaseMapping[_choice].time)) ||\\n            (user.totalAmount == 0)\\n        ) {\\n            return (0, 0);\\n        }\\n\\n        if (user.totalAmount == user.claimedAmount) {\\n            return (0, 0);\\n        }\\n\\n        uint32 _time = uint32(\\n            block.timestamp - (vestingPhaseMapping[_choice].time)\\n        );\\n\\n        /* Claim in Ever Month 30 days for main net and 1 minutes for the test */\\n        _claimCount = uint8((_time / 30 days) + 1);\\n\\n        uint8 claims = uint8(vestingPhaseMapping[_choice].claims);\\n\\n        if (_claimCount > claims) {\\n            _claimCount = claims;\\n        }\\n\\n        if (_claimCount <= user.claims) {\\n            return (0, _claimCount);\\n        }\\n\\n        if (_claimCount == claims) {\\n            _toBeTransfer = user.totalAmount - user.claimedAmount;\\n        } else {\\n            _toBeTransfer = vestingCalulations(\\n                user.totalAmount,\\n                _claimCount,\\n                user.claims,\\n                _choice\\n            );\\n        }\\n        return (_toBeTransfer, _claimCount);\\n    }\\n\\n    /* =============== Vesting Calculations =============== */\\n    /**\\n     * vestingCalulations function is used for calculating the amount of token for claim\\n     */\\n    function vestingCalulations(\\n        uint256 _userTotalAmount,\\n        uint8 _claimCount,\\n        uint8 _userClaimCount,\\n        uint8 _choice\\n    ) internal view returns (uint256) {\\n        uint256 amount;\\n        uint8 claim = _claimCount - _userClaimCount;\\n        amount =\\n            (_userTotalAmount *\\n                (vestingPhaseMapping[_choice].percentage * claim)) /\\n            10000;\\n\\n        return amount;\\n    }\\n\\n    function sendLeftoverTokens() external onlyOwner {\\n        uint256 _balance = tokenPendingInICO;\\n        require(_balance > 0, \\\"No tokens left to send.\\\");\\n\\n        TransferHelper.safeTransfer(address(token), receiverAddress, _balance);\\n    }\\n\\n    /* ================ OTHER FUNCTIONS SECTION ================ */\\n    /* Updates Receiver Address */\\n    function updateReceiverAddress(\\n        address _receiverAddress\\n    ) external onlyOwner {\\n        require(_receiverAddress != address(0), \\\"Zero address passed.\\\");\\n        receiverAddress = _receiverAddress;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"claimCount\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"choice\",\"type\":\"uint8\"}],\"name\":\"ClaimedToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"choice\",\"type\":\"uint8\"}],\"name\":\"RegisterUser\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADVERTISED\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ECOSYSTEM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ICOAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MARKETING\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TEAM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TREASURY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_choice\",\"type\":\"uint8\"}],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receiverAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_choice\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"registerUserByICO\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sendLeftoverTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPendingInICO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_choice\",\"type\":\"uint8\"}],\"name\":\"tokensToBeClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_toBeTransfer\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_claimCount\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ICOAddress\",\"type\":\"address\"}],\"name\":\"updateICOAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiverAddress\",\"type\":\"address\"}],\"name\":\"updateReceiverAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"userMapping\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"claims\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Vesting", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000878c5213cce6fd8f63e10772969b7d49b36cabf4", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}