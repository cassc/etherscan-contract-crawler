// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;

import "./interfaces/IMinterPro.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "./interfaces/ICharacter.sol";
import "./interfaces/IBag.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/introspection/ERC165.sol";

import "./helpers/Errors.sol";
import "./helpers/Permissions.sol";

/**
 * @dev ASM The Next Legends - Minter Pro contract
 * @notice
 */
contract MinterPro is IMinterPro, Errors, AccessControl, ReentrancyGuard, Pausable {
    using ECDSA for bytes32;

    address private _signer;
    address private _manager; // ASM Owned multisig contract, used for maintenance
    address private _multisig; // another ASM Owned multisig contract, used for withdrawing ETHs

    ICharacter public char_;
    IBag public bag_;

    uint256 constant proMaxSupply = 5661;
    uint256 public mintingEthCost;

    event Minted(address indexed to, bytes32 hashId, uint256 charId, uint256 bagId);
    event ContractUpgraded(uint256 timestamp, string indexed contractName, address oldAddress, address newAddress);
    event SignerUpdated(address indexed manager, address newSigner);
    event Withdraw(address indexed manager, address to, uint256 amount);

    constructor(
        address manager,
        address multisig,
        address signer,
        address character,
        address bag
    ) {
        if (manager == address(0)) revert InvalidInput(INVALID_MANAGER);
        if (multisig == address(0)) revert InvalidInput(INVALID_MULTISIG);
        if (signer == address(0)) revert InvalidInput(INVALID_SIGNER);
        if (character == address(0)) revert InvalidInput(WRONG_CHARACTER_CONTRACT);

        _manager = manager;
        _multisig = multisig;
        _signer = signer;

        _grantRole(MANAGER_ROLE, manager);
        _grantRole(MULTISIG_ROLE, multisig);

        char_ = ICharacter(character);
        bag_ = IBag(bag);

        if (!char_.supportsInterface(type(ICharacter).interfaceId)) revert UpgradeError(WRONG_CHARACTER_CONTRACT);
        if (!bag_.supportsInterface(type(IBag).interfaceId)) revert UpgradeError(WRONG_BAG_CONTRACT);

        _pause();
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(IMinterPro, AccessControl)
        returns (bool)
    {
        return
            interfaceId == type(IMinterPro).interfaceId ||
            interfaceId == type(IERC165).interfaceId ||
            interfaceId == type(AccessControl).interfaceId;
    }

    /** ----------------------------------
     * ! Minting functions
     * ----------------------------------- */

    /**
     * @notice Minting a new character or asset
     * @dev This function can only be called inside the contract
     * @param to to which address to mint a new token
     * @param expiry timestamp (in seconds) when token expires (user can mint before that time only)
     * @param hashId user identificator, used to match user's allowance to mint with minted token.
     * @param signature Signed hash to prove the right to mint. Generated by ASM, stored in DDB, returned from Dapp. Can only be used once.
     */
    function mintPro(
        address to,
        bytes calldata signature,
        bytes32 hashId,
        uint256 expiry
    ) external payable whenPaid(msg.value) whenNotExpired(expiry) nonZeroAddress(to) whenNotPaused {
        // this check assumes that Pro Chars minted before normal characters,
        // and thus first 5661 of chars will be Pros.
        if ((char_.totalSupply() + 1) > proMaxSupply) revert MintingError(TOTAL_SUPPLY_EXCEEDED, 0);

        if (!validateSignature(to, hashId, expiry, signature)) revert InvalidInput(INVALID_SIGNATURE);

        uint256 charId = char_.mint(to, hashId);
        uint256 bagId = bag_.mint(to);

        emit Minted(to, hashId, charId, bagId);
    }

    /** ----------------------------------
     * ! Signature validating functions
     * ----------------------------------- */

    /**
     * @notice To validate the `signature` is signed by the _signer
     * @param addr User wallet address
     * @param nonce Character hashId
     * @param expiry timestamp when token expires (user can mint before that time only)
     * @param signature The signature passed from the caller
     * @return Validation result
     */
    function validateSignature(
        address addr,
        bytes32 nonce,
        uint256 expiry,
        bytes calldata signature
    ) public view returns (bool) {
        bytes32 messageHash = _hash(addr, nonce, expiry);
        bytes32 ethSignedMessageHash = _getEthSignedMessageHash(messageHash);
        return _verify(ethSignedMessageHash, signature);
    }

    /**
     * @notice Encode arguments to generate a hash, which will be used for validating signatures
     * @dev This function can only be called inside the contract
     * @param addr The user wallet address, to verify the signature can only be used by the wallet
     * @param nonce Character hashId
     * @param expiry timestamp when token expires
     * @return Encoded hash
     */
    function _hash(
        address addr,
        bytes32 nonce,
        uint256 expiry
    ) internal pure returns (bytes32) {
        return keccak256(abi.encode(addr, Strings.toHexString(uint256(nonce), 32), expiry));
    }

    /**
     * @notice Prefixing a hash with "\x19Ethereum Signed Message\n", which required for recovering signer
     * @dev This function can only be called inside the contract
     * @param _messageHash hash that need to be prefixed
     * @return Prefixed hash
     */
    function _getEthSignedMessageHash(bytes32 _messageHash) private pure returns (bytes32) {
        /*
        Signature is produced by signing a keccak256 hash with the following format:
        "\x19Ethereum Signed Message\n" + len(msg) + msg
        */
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", _messageHash));
    }

    /**
     * @notice To verify the `token` is signed by the _signer
     * @dev This function can only be called inside the contract
     * @param ethSignedMessageHash The encoded hash used for signature
     * @param signature The signature passed from the caller
     * @return Verification result
     */
    function _verify(bytes32 ethSignedMessageHash, bytes memory signature) internal view returns (bool) {
        address signer_ = _recoverSigner(ethSignedMessageHash, signature);
        return (signer_ == _signer && signer_ != address(0));
    }

    /**
     * @notice Returns the address that signed a hashed message (`hash`) with
     * `signature`. This address can then be used for verification purposes.
     * @dev This function can only be called inside the contract
     * @param ethSignedMessageHash The encoded hash used for signature
     * @param signature The signature passed from the caller
     * @return The recovered address
     */
    function _recoverSigner(bytes32 ethSignedMessageHash, bytes memory signature) private pure returns (address) {
        (bytes32 r, bytes32 s, uint8 v) = _splitSignature(signature);
        return ecrecover(ethSignedMessageHash, v, r, s);
    }

    /**
     * @notice Extracting R, S, V components from the signature
     * @dev This function can only be called inside the contract
     * @param sig The signature to extract r,s,v from
     */
    function _splitSignature(bytes memory sig)
        private
        pure
        returns (
            bytes32 r,
            bytes32 s,
            uint8 v
        )
    {
        require(sig.length == 65, "invalid signature length");

        assembly {
            /*
            First 32 bytes stores the length of the signature

            add(sig, 32) = pointer of sig + 32
            effectively, skips first 32 bytes of signature

            mload(p) loads next 32 bytes starting at the memory address p into memory
            */

            // first 32 bytes, after the length prefix
            r := mload(add(sig, 32))
            // second 32 bytes
            s := mload(add(sig, 64))
            // final byte (first byte of the next 32 bytes)
            v := byte(0, mload(add(sig, 96)))
        }
        // implicitly return (r, s, v)
    }

    /** ----------------------------------
     * ! Manager functions      | UPGRADES
     * ----------------------------------- */

    /**
     * @notice Upgrade Unpacker contract address
     * @dev This function can only be called from contracts or wallets with MANAGER_ROLE
     * @param newContract Address of the new contract
     */
    function upgradeCharacterContract(address newContract) external onlyRole(MANAGER_ROLE) {
        if (newContract == address(0)) revert InvalidInput(INVALID_ADDRESS);

        address oldContract = address(char_);
        char_ = ICharacter(newContract);
        if (!char_.supportsInterface(type(ICharacter).interfaceId)) revert UpgradeError(WRONG_CHARACTER_CONTRACT);

        emit ContractUpgraded(block.timestamp, "Character.sol", oldContract, newContract);
    }

    /**
     * @notice Upgrade Bag contract address
     * @dev This function can only be called from contracts or wallets with MANAGER_ROLE
     * @param newContract Address of the new contract
     */
    function upgradeBagContract(address newContract) external onlyRole(MANAGER_ROLE) {
        if (newContract == address(0)) revert InvalidInput(INVALID_ADDRESS);

        address oldContract = address(bag_);
        bag_ = IBag(newContract);
        if (!bag_.supportsInterface(type(IBag).interfaceId)) revert UpgradeError(WRONG_BAG_CONTRACT);

        emit ContractUpgraded(block.timestamp, "Bag.sol", oldContract, newContract);
    }

    /** ----------------------------------
     * ! Admin functions
     * ----------------------------------- */

    /**
     * @notice Set manager address (contract or wallet) to manage this contract
     * @dev This function can only to called from contracts or wallets with MANAGER_ROLE
     * @dev The old manager will be removed
     * @param newManager The new manager address to be granted
     */
    function setManager(address newManager) external onlyRole(MANAGER_ROLE) {
        if (newManager == address(0)) revert InvalidInput(INVALID_ADDRESS);
        _revokeRole(MANAGER_ROLE, _manager);
        _grantRole(MANAGER_ROLE, newManager);
        _manager = newManager;
    }

    /**
     * @notice Set Multisig address (multisig wallet) to perform withdraw
     * @dev This function can only to called from contracts with MULTISIG_ROLE
     * @dev The old manager will be removed
     * @param _newMultisig The new manager address to be granted
     */
    function setMultisig(address _newMultisig) external onlyRole(MULTISIG_ROLE) {
        if (_newMultisig == address(0)) revert InvalidInput(INVALID_ADDRESS);
        _revokeRole(MULTISIG_ROLE, _multisig);
        _grantRole(MULTISIG_ROLE, _newMultisig);
        _multisig = _newMultisig;
    }

    /**
     * @notice Update signer
     * @dev This function can only to called from contracts or wallets with MANAGER_ROLE
     * @param newSigner The new signer address to update
     */
    function setSigner(address newSigner) external onlyRole(MANAGER_ROLE) {
        if (newSigner == address(0)) revert InvalidInput(INVALID_SIGNER);
        _signer = newSigner;
        emit SignerUpdated(msg.sender, newSigner);
    }

    function getSigner() public view returns (address) {
        return _signer;
    }

    /**
     * @notice Set the price to mint
     * @dev only MANAGER_ROLE can call this function
     * @param cost New price
     */
    function setMintingEthCost(uint256 cost) external onlyRole(MANAGER_ROLE) {
        mintingEthCost = cost;
    }

    /**
     * @notice Pause the minting process
     */
    function pause() external onlyRole(MANAGER_ROLE) {
        _pause();
    }

    /**
     * @notice Pause the minting process
     */
    function unpause() external onlyRole(MANAGER_ROLE) {
        _unpause();
    }

    /**
     * @notice Withdraw ETH from the contract to specified address
     * @dev only MULTISIG_ROLE can call this function
     * @param amount Token amount to withdraw
     * @param to recipient of the transfer
     */
    function withdrawEth(uint256 amount, address payable to) external onlyRole(MULTISIG_ROLE) {
        if (amount == 0) revert InvalidInput(INVALID_AMOUNT);
        if (to == address(0)) revert InvalidInput(INVALID_ADDRESS);
        (bool sent, ) = to.call{value: amount}("");
        if (!sent) revert ManagementError(CANT_SEND);
    }

    /** ----------------------------------
     * ! Modifiers
     * ----------------------------------- */

    modifier whenPaid(uint256 receivedAmount) {
        uint256 requiredAmount = mintingEthCost;
        if (receivedAmount < requiredAmount) revert PaymentError(NO_PAYMENT_RECEIVED, requiredAmount, receivedAmount);
        else _;
    }

    modifier whenNotExpired(uint256 expiry) {
        if (block.timestamp > expiry) revert MintingError(MINT_EXPIRED, expiry);
        else _;
    }

    modifier nonZeroAddress(address addr) {
        if (addr == address(0)) revert InvalidInput(INVALID_ADDRESS);
        else _;
    }
}