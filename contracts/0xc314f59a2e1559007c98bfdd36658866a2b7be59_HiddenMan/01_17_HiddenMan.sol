// SPDX-License-Identifier: MIT
//
//
//
//
//                                      `-:/osyhhdddddddhyso+:-`
//                                 ./ohmNNMMMMMMMMMMMMMMMMMMMMNNmho/-
//                             ./ymNMMMMMMMMNmdhhyyyyyyhhdmNMMMMMMMMNmy+-
//                          -odNMMMMMMmhso+++osyyh/..:hhysoo++oshmMMMMMMNdo-
//                       .+dNMMMMMdy++oydmNNMMMMMs-mm:oMMMMMMNmdyo++sdNMMMMNd+.
//                     -smMMMMNho/ohmNMMMMMMMMMM+:mMMN//NMMMMMMMMMNmho/ohNMMMMNs-
//                   .sNMMMMmo/odNMMMMMMMMMMMMN//NMMMMN+:NMMMMMMMMMMMMNdo/odMMMMNy-
//                 `oNMMMMd+../oydNMMMMMMMMMMN:+NMMMMMMMo-mMMMMMMMMMMNdhs/..+hMMMMNs.
//                :mMMMMd//h+:mdys++oydmNMMMm-oMMMMMMMMMMs-dMMMNmdyo++oydm+:d//dMMMMm/
//              `sNMMMNo:hMMd`NMMMMNmhso+osy.oMMMMMMMMMMMMy.yso+oshmNMMMMM.yMMh/+NMMMMs`
//             .hMMMMd:oNMMMM.yMMMMMMMMMMm+`+++oydmNMmdys+++./mNMMMMMMMMMh`NMMMNs:hMMMMd.
//            .dMMMMs-hMMMMMM+:MMMMMMMMMMy-dMMNhs:.//-:ohNMMm-sMMMMMMMMMM+/MMMMMMd-oMMMMm.
//           `dMMMMo-mMMMMMMMd`NMMMMMMMMo-dmhs++oshmmhso++shmd:+NMMMMMMMN`hMMMMMMMN:+MMMMm.
//          `hMMMMo-NMMMMMMMMM.yMMMMNNd+`/+oydmMMMMMMMMMMNdyo+/`/dmNMMMMh`NMMMMMMMMN:+MMMMd`
//          oMMMMy.mMMMMMMMMMMo:mhso+/`/dNMMMMMMMMMMMMMMMMMMMMNm+ /++shm//MMMMMMMMMMN-sMMMMs
//         .NMMMm`hMMMMMMMNmhs/ /shmm:+MMMMMMMMMMMMMMMMMMMMMMMMMMs-mmds+ :oymNNMMMMMMm`dMMMM-
//         yMMMM//MMNNdyo/+oydN-sMMm-sMMMMMMMMMMMMMMMMMMMMMMMMMMMMy.dMMy.Ndyo+/+ydNNMMo-MMMMh
//        `MMMMm ss+/+shmMMMMMMs-Md.yMMMMMMMMMNNdhyyyyhdNNMMMMMMMMMh.hM/+MMMMMMmhs+/+sy hMMMM.
//        +MMMMo +dNMMMMMMMMMMMm s.dMMMMMMMNy+-`:ohhhhs:`./smMMMMMMMd.s`dMMMMMMMMMMMNdo /MMMMo
//        yMMMM-/.hMMMMMMMMMMMMM..mMMMMMMd/:y/-dMMMd/ohMm::y//hMMMMMMm-`MMMMMMMMMMMMMd./.MMMMh
//        dMMMM`hd.yMMMMMMMMMMMo`-MMMMMN/:dMs.NMMMMM/  :NM-oMm/:mMMMMM:`/MMMMMMMMMMMh.dm NMMMm
//        dMMMN`dMm-oMMMMMMMMM/:m mMMMM-/MMM/+Md/yho`   hMs-MMM+.NMMMN d/:NMMMMMMMMs.mMN mMMMN
//        dMMMM`hMMN:/MMMMMMN:+MM:oMMMMm:/mMs-MM:      -NM:oMm+:mMMMMs.MMo-mMMMMMMo-NMMm NMMMm
//        yMMMM-sMMMM/:NMMMm-oMMMy.MMMMMMh//y/:mMh+//+hMm/:y/:yMMMMMM:oMMMy.dMMMM/:NMMMy.MMMMh
//        +MMMM+:MMMMMo-mMd.yMMMMN dMMMMMMMms/.`:shddhs/`./smMMMMMMMN mMMMMh.hMN:+MMMMM+/MMMMo
//        .MMMMd`mMMMMMs.s.hMMMMMM:+MMMMMMMMMMNmhyssssyhmNMMMMMMMMMMs-MMMMMMd.s-oMMMMMN`hMMMM-
//         yMMMM:+MMMMMM/ sMMMMMMMy.MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM-sMMMMMMMy :MMMMMMo-MMMMd
//         -MMMMm`dMMMMo-y.yMMMMMMN`dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMm mMMMMMMh.y:+MMMMm`dMMMM:
//          oMMMMy.NMM+:NMm-sMMMMMM/+MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMo-MMMMMMy-dMN//NMN-oMMMMy
//          `dMMMMo:m//NMMMm:+MMMMMh`MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM-sMMMMMo-mMMMN+:m//MMMMm`
//           .mMMMMo.`ossssso`/ossso +sssssssssssssssssssssssssssso +ssso/`+ssssso.`/NMMMm.
//            .mMMMMs.smmmmmmm+.hmmm/:mmmmmmmmmmmmmmmmmmmmmmmmmmmm/:mmmd-/dmmmmmmy.oNMMMm-
//             .hMMMMh:sNMMMMMMo-mMMh`NMMMMMMMMMMMMMMMMMMMMMMMMMMM.yMMm:+NMMMMMMy-yMMMMd.
//              `sMMMMN+:hMMMMMMy-dMM.hMMMMMMMMMMMMMMMMMMMMMMMMMMd`NMm-sMMMMMMd/+mMMMMy`
//                /mMMMMd//dMMMMMh-hM+/MMMMMMMMMMMMMMMMMMMMMMMMMM+:Md-yMMMMMd+/hMMMMm/
//                 .sNMMMMh//hNMMMd-yh`NMMMMMMMMMMMMMMMMMMMMMMMMM.yy-hMMMNh+/hMMMMNy.
//                   -yNMMMMdo/odNMm-o`yMMMMMMMMMMMMMMMMMMMMMMMMd`o-dMNds/odMMMMNy-
//                     -yNMMMMNh+/ohd:`:MMMMMMMMMMMMMMMMMMMMMMMM+ -hho/+hNMMMMNy-
//                       .+dNMMMMNds+/``dmNMMMMMMMMMMMMMMMMMMNmd.`/+sdNMMMMNmo.
//                          -odNMMMMMNdyo+++osyyhddddddhyyso+++oydNMMMMMNms:`
//                             -+ymNMMMMMMMNmdhhyyssssyyhhdmNMMMMMMMNmh+-
//                                `-/shmNNMMMMMMMMMMMMMMMMMMMMNNNds/-`
//                                      .-/+oyhddmmmmmmddhys+/:.
//
//
//
//
//                                            HIDDEN ONES
//
//                                    10,151 HIDDEN MAN Cryptids
//                        Based on the Genesis film "He Who Lives In Hidden Lakes"
//
//                                       https://hiddenones.io
//                                 https://twitter.com/hiddenonesdao
//                                   https://whoisthehiddenman.com
//
pragma solidity ^0.8.2;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";

contract HiddenMan is
  ERC721,
  ERC721Enumerable,
  Ownable,
  Pausable,
  VRFConsumerBase
{
  using Strings for uint256;
  uint16[16] internal sold;
  uint256 public supply;
  uint16[16] internal groupKeys;
  string internal _customBaseURI;
  uint256 public startBlock =
    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
  uint256 internal randomizationKey;
  // constructor set
  uint256 public price = 0.08 ether;
  address public DAO;
  address public ELEUSINIAN;
  bytes32 private s_keyHash;
  uint256 private s_fee;
  // constants
  uint16 public constant MAX_TOKENS = 10151;
  uint16 public constant NUM_RESERVED_TOKENS = 151;

  constructor(
    string memory _uri,
    address _dao,
    address _eleusinian,
    address vrfCoordinator,
    address link,
    bytes32 keyHash,
    uint256 fee
  ) VRFConsumerBase(vrfCoordinator, link) ERC721("Hidden Ones", "HIDDENONES") {
    _customBaseURI = _uri;
    DAO = _dao;
    ELEUSINIAN = _eleusinian;
    s_keyHash = keyHash;
    s_fee = fee;
  }

  // modifiers
  function isSaleActive() public view returns (bool) {
    return block.number >= startBlock;
  }

  modifier whenSaleIsActive() {
    require(isSaleActive(), "The cryptids slumber");
    _;
  }

  function _baseURI() internal view override returns (string memory) {
    return _customBaseURI;
  }

  modifier beforeStarted() {
    require(
      startBlock ==
        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff,
      "It's too late to do that"
    );
    _;
  }

  function mint(uint256 _numToMint)
    public
    payable
    whenNotPaused
    whenSaleIsActive
  {
    require(_numToMint <= 20, "Cryptids travel in groups no larger than 20");
    require(
      totalSupply() + _numToMint <= supply,
      "No Cryptids remain in hiding, all have been summoned"
    );
    require(
      msg.value >= price * _numToMint,
      "The Ether amount sent does not please the Cryptids"
    );
    for (uint256 i; i < _numToMint; i++) {
      uint256 mintIndex = totalSupply();
      if (totalSupply() < supply) {
        _safeMint(msg.sender, mintIndex);
      }
    }
  }

  function encodeAddressArray(bytes32[] calldata _arr)
    internal
    pure
    returns (bytes memory data)
  {
    for (uint256 i = 0; i < _arr.length; i++) {
      data = abi.encodePacked(data, _arr[i]);
    }
  }

  function _getRandomizedHash(
    uint256 x,
    uint256 _randomizationKey,
    uint256 _maxTokens
  ) internal pure returns (uint256) {
    uint256 randKey1 = _randomizationKey & 0xffffffffffffffff0000000000000000;
    uint256 randKey2 = _randomizationKey & 0x0000000000000000ffffffffffffffff;
    uint256 randHash = ((x * randKey1) + randKey2) % _maxTokens;
    return randHash;
  }

  function _getGroupHash(
    uint256 tokenId,
    uint256 _randomizationKey,
    uint256 _groupKey,
    uint256 _maxTokens
  ) internal pure returns (uint256) {
    uint256 randKey1 = uint256(
      keccak256(abi.encode(_randomizationKey, _groupKey))
    ) & 0xffffffffffffffff0000000000000000;
    return (tokenId + randKey1) % _maxTokens;
  }

  // get tokenuri
  function _getSequenceId(uint256 tokenId)
    internal
    view
    returns (string memory)
  {
    uint256 _groupKey;
    uint256 _randomizationKey;
    // get current phase
    uint256 phase = 16;
    uint256 currSold;
    for (uint256 currPhase; currPhase < 16; currPhase++) {
      currSold = sold[currPhase];
      if (currSold == 0) {
        break;
      }
      if (tokenId < currSold) {
        phase = currPhase;
        break;
      }
    }
    // check that sequence_id has been revealed
    if (
      phase == 16 ||
      (_groupKey = groupKeys[phase]) == 0 ||
      (_randomizationKey = randomizationKey) == 0
    ) {
      return "-1"; // this sequence id is not yet revealed
    }
    // do math
    uint256 prevSum = phase > 0 ? sold[phase - 1] : 0;
    uint256 groupHash = _getGroupHash(
      tokenId,
      _randomizationKey,
      _groupKey,
      currSold - prevSum
    );
    uint256 seqId = _getRandomizedHash(
      groupHash + prevSum,
      _randomizationKey,
      MAX_TOKENS
    );
    return (seqId + 1).toString();
  }

  function tokenURI(uint256 tokenId)
    public
    view
    override(ERC721)
    returns (string memory)
  {
    require(
      _exists(tokenId),
      "ERC721Metadata: URI query for nonexistent token"
    );
    string memory baseURI = _baseURI();
    if (bytes(baseURI).length > 0) {
      string memory sequenceId = _getSequenceId(tokenId);
      return string(abi.encodePacked(baseURI, sequenceId));
    }
    return "";
  }

  // ONLY OWNER SECTION
  function reserve() external onlyOwner beforeStarted {
    require(totalSupply() == 0, "Exceeded reserved supply");
    uint256 _supply = totalSupply();
    uint256 i;
    for (i = 0; i < NUM_RESERVED_TOKENS; i++) {
      _safeMint(ELEUSINIAN, _supply + i);
    }
  }

  function withdraw() external onlyOwner {
    uint256 _each = address(this).balance / 2;
    (bool success, ) = DAO.call{ value: _each }("");
    require(success, "Transfer failed.");
    (bool success2, ) = ELEUSINIAN.call{ value: _each }("");
    require(success2, "Transfer failed.");
    uint256 _link = LINK.balanceOf(address(this));
    LINK.transfer(ELEUSINIAN, _link);
  }

  function setPrice(uint256 _price) external onlyOwner {
    require(!isSaleActive(), "Price cannot be changed during a sale");
    price = _price;
  }

  function setPresaleSupply(uint256 _supply) external onlyOwner {
    supply = _supply + NUM_RESERVED_TOKENS;
  }

  function startCountdown(uint256 _newStartBlock)
    external
    onlyOwner
    beforeStarted
  {
    require(
      _newStartBlock !=
        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff,
      "start block cannot be init"
    );
    require(
      LINK.balanceOf(address(this)) >= s_fee,
      "Not enough LINK to pay fee"
    );
    require(supply > NUM_RESERVED_TOKENS, "Didn't set presale supply");
    requestRandomness(s_keyHash, s_fee);
    startBlock = _newStartBlock;
  }

  function stopRunningPhase(uint256 _nextStartBlock, uint16 _nextPhaseSupply)
    external
    onlyOwner
    whenSaleIsActive
  {
    require(
      (totalSupply() >= supply) || paused(),
      "Cannot stop the phase unless it is either sold out or paused"
    );
    require(
      LINK.balanceOf(address(this)) >= s_fee,
      "Not enough LINK to pay fee"
    );
    require(
      _nextStartBlock !=
        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff,
      "start block cannot be init"
    );
    startBlock = _nextStartBlock;
    for (uint256 i; i < 16; i++) {
      if (sold[i] == 0) {
        sold[i] = uint16(totalSupply());
        break;
      }
    }
    supply = _nextPhaseSupply;
    requestRandomness(s_keyHash, s_fee);
    if (paused()) {
      unpause();
    }
  }

  function fulfillRandomness(bytes32 requestId, uint256 randomness)
    internal
    override
  {
    if (randomizationKey == 0) {
      randomizationKey = randomness;
    } else {
      for (uint256 i; i < 16; i++) {
        if (groupKeys[i] == 0) {
          groupKeys[i] = uint16(randomness);
          break;
        }
      }
    }
  }

  //////////////////////////////////////////////////////////
  function pause() public onlyOwner {
    _pause();
  }

  function unpause() public onlyOwner {
    _unpause();
  }

  function safeMint(address to, uint256 tokenId) public onlyOwner {
    _safeMint(to, tokenId);
  }

  function _beforeTokenTransfer(
    address from,
    address to,
    uint256 tokenId
  ) internal override(ERC721, ERC721Enumerable) whenNotPaused {
    super._beforeTokenTransfer(from, to, tokenId);
  }

  function supportsInterface(bytes4 interfaceId)
    public
    view
    override(ERC721, ERC721Enumerable)
    returns (bool)
  {
    return super.supportsInterface(interfaceId);
  }
}