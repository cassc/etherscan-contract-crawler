{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/UnitLondonMarketplace.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./utils/Proxy.sol\\\";\\nimport \\\"./utils/RoyaltySplitter.sol\\\";\\nimport \\\"./utils/Vault.sol\\\";\\nimport \\\"./utils/IOwnable.sol\\\";\\n\\ninterface INFT {\\n  function mint(uint256 tokenId, string calldata metadata, address user) external;\\n\\n  function mint(uint256 tokenId, uint256 amount, string calldata metadata, address user) external;\\n\\n  function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n  function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes memory data) external;\\n\\n  function ownerOf(uint256 tokenId) external view returns (address);\\n\\n  function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n  function initialize(string calldata _name, string calldata _symbol) external;\\n\\n  function transferOwnership(address newOwner) external;\\n}\\n\\ncontract UnitLondonMarketplace is Vault, IOwnable {\\n  struct CollectionData {\\n    address artist;\\n    address splitter;\\n    uint32 mintFeePlatform;\\n    uint32 royaltyCollection;\\n    uint32 royaltyPlatform;\\n    uint32 logicIndex;\\n    string contractURI;\\n  }\\n\\n  struct TokenData {\\n    uint256 price;\\n    uint256 amount;\\n    uint256 startDate;\\n    string metadata;\\n  }\\n\\n  event PlatformUpdated(address oldPlatform, address newPlatform);\\n  event CollectionRegistered(address collection, CollectionData data);\\n  event TokenUpdated(address collection, uint256 tokenId, TokenData data);\\n  event TokenSold(address collection, uint256 tokenId, uint256 amount, uint256 value);\\n  event TokenAirdropped(address collection, uint256 tokenId, address[] redeemers);\\n  event TokenRedeemed(address collection, uint256 tokenId, address[] redeemers, uint256[] prices);\\n\\n  uint256 constant RATIO = 10000;\\n\\n  address implementation_;\\n  address public override owner;\\n  bool public initialized;\\n\\n  address[2] public logics;\\n\\n  uint32 public mintFeePlatform;\\n  uint32 public royaltyPlatform;\\n\\n  mapping(address => bool) public artists;\\n\\n  mapping(address => CollectionData) public collections;\\n  mapping(address => mapping(uint256 => TokenData)) public tokens;\\n\\n  address public platform;\\n  address public trdparty;\\n\\n  function onlyOwner() internal view returns (bool) {\\n    return msg.sender == owner;\\n  }\\n\\n  function onlyTrdparty() internal view returns (bool) {\\n    return msg.sender == owner || msg.sender == trdparty;\\n  }\\n\\n  function onlyGrant() internal view returns (bool) {\\n    return msg.sender == owner || msg.sender == platform;\\n  }\\n\\n  function initialize(address[2] memory _logics) external {\\n    require(!initialized && onlyOwner());\\n    initialized = true;\\n\\n    logics = _logics;\\n    mintFeePlatform = 3000; // 30.00%\\n    royaltyPlatform = 200; // 2.00%\\n\\n    emit OwnershipTransferred(address(0), msg.sender);\\n  }\\n\\n  function setPlatform(address newPlatform) external {\\n    if (platform == address(0)) {\\n      require(onlyOwner());\\n    } else {\\n      require(onlyGrant());\\n    }\\n\\n    emit PlatformUpdated(platform, newPlatform);\\n    platform = newPlatform;\\n  }\\n\\n  function setTrdparty(address newTrdparty) external {\\n    require(onlyOwner());\\n\\n    trdparty = newTrdparty;\\n  }\\n\\n  function setMintFeePlatform(uint32 newMintFeePlatform) external {\\n    require(onlyGrant());\\n    mintFeePlatform = newMintFeePlatform;\\n  }\\n\\n  function setRoyaltyPlatform(uint32 newRoyaltyPlatform) external {\\n    require(onlyGrant());\\n    royaltyPlatform = newRoyaltyPlatform;\\n  }\\n\\n  function setArtists(address[] calldata _artists) external {\\n    require(onlyGrant());\\n    for (uint256 i = 0; i < _artists.length; i++) {\\n      artists[_artists[i]] = true;\\n    }\\n  }\\n\\n  function removeArtist(address artist) external {\\n    require(onlyGrant());\\n    delete artists[artist];\\n  }\\n\\n  function withdraw() external {\\n    require(onlyGrant());\\n    payable(platform).transfer(address(this).balance);\\n  }\\n\\n  function onlyArtist(address artist) internal view returns (bool) {\\n    require(artists[artist], \\\"Invalid artist\\\");\\n    return onlyGrant() || msg.sender == artist;\\n  }\\n\\n  function registerCollection(\\n    uint32 logicIndex,\\n    string calldata name,\\n    string calldata symbol,\\n    address artist,\\n    uint32 royaltyArtist,\\n    string calldata contractURI\\n  ) external {\\n    require(onlyArtist(artist), \\\"Invalid permission\\\");\\n    Proxy proxy = new Proxy();\\n    proxy.setImplementation(logics[logicIndex]);\\n\\n    address collection = address(proxy);\\n    CollectionData storage data = collections[collection];\\n    data.artist = artist;\\n    data.splitter = address(new RoyaltySplitter());\\n    data.mintFeePlatform = mintFeePlatform;\\n    data.royaltyCollection = royaltyArtist + royaltyPlatform;\\n    data.royaltyPlatform = royaltyPlatform;\\n    data.logicIndex = logicIndex;\\n    data.contractURI = contractURI;\\n\\n    INFT(collection).initialize(name, symbol);\\n    INFT(collection).transferOwnership(artist);\\n\\n    emit CollectionRegistered(collection, data);\\n  }\\n\\n  function collectionURI(address collection) external view returns (string memory) {\\n    return collections[collection].contractURI;\\n  }\\n\\n  function syncLogic(Proxy collection) external {\\n    collection.setImplementation(logics[collections[address(collection)].logicIndex]);\\n  }\\n\\n  function registerManifold(uint32 logicIndex, address manifold, address artist, string calldata contractURI) external {\\n    require(onlyArtist(artist), \\\"Invalid permission\\\");\\n\\n    CollectionData storage data = collections[manifold];\\n    require(data.artist == address(0), \\\"Invalid collection\\\");\\n    data.artist = artist;\\n    data.logicIndex = logicIndex;\\n    data.mintFeePlatform = mintFeePlatform;\\n    data.contractURI = contractURI;\\n\\n    emit CollectionRegistered(manifold, data);\\n  }\\n\\n  function updateCollectionMintFeePlatform(address collection, uint32 newMintFeePlatform) external {\\n    CollectionData storage data = collections[collection];\\n\\n    require(onlyGrant(), \\\"Invalid permission\\\");\\n    data.mintFeePlatform = newMintFeePlatform;\\n    emit CollectionRegistered(collection, data);\\n  }\\n\\n  function updateCollectionRoyaltyArtist(address collection, uint32 royaltyArtist) external {\\n    CollectionData storage data = collections[collection];\\n\\n    require(onlyGrant(), \\\"Invalid permission\\\");\\n    data.royaltyCollection = royaltyArtist + royaltyPlatform;\\n    emit CollectionRegistered(collection, data);\\n  }\\n\\n  function updateCollectionURI(address collection, string calldata contractURI) external {\\n    CollectionData storage data = collections[collection];\\n\\n    require(onlyGrant(), \\\"Invalid permission\\\");\\n    data.contractURI = contractURI;\\n    emit CollectionRegistered(collection, data);\\n  }\\n\\n  function emitCollectionRegistered(address[] calldata registers) external {\\n    require(onlyGrant(), \\\"Invalid permission\\\");\\n\\n    for (uint256 i = 0; i < registers.length; i++) {\\n      address collection = registers[i];\\n      emit CollectionRegistered(collection, collections[collection]);\\n    }\\n  }\\n\\n  function addToken(\\n    address collection,\\n    uint256 tokenId,\\n    uint256 tokenLogic, // amount - 0 for 721, N for 1155\\n    uint256 price,\\n    uint256 startDate,\\n    string calldata metadata\\n  ) external {\\n    require(onlyGrant() || collections[collection].artist == msg.sender, \\\"Invalid artist\\\");\\n    TokenData storage data = tokens[collection][tokenId];\\n    require(data.price == 0, \\\"Invalid token\\\");\\n\\n    if (collections[collection].splitter == address(0)) {\\n      // Manifolds\\n      if (tokenLogic == 0) {\\n        // ERC721\\n        require(INFT(collection).ownerOf(tokenId) == address(this), \\\"Invalid owner\\\");\\n      } else {\\n        // ERC1155\\n        require(INFT(collection).balanceOf(address(this), tokenId) == tokenLogic, \\\"Invalid owner\\\");\\n      }\\n    } else {\\n      data.metadata = metadata;\\n    }\\n\\n    data.amount = tokenLogic;\\n    data.price = price;\\n    data.startDate = startDate;\\n\\n    emit TokenUpdated(collection, tokenId, data);\\n  }\\n\\n  function updateTokenPrice(address collection, uint256 tokenId, uint256 price) external {\\n    require(onlyGrant() || collections[collection].artist == msg.sender, \\\"Invalid artist\\\");\\n    TokenData storage data = tokens[collection][tokenId];\\n    // require(data.price > 0, \\\"Invalid token\\\");\\n\\n    data.price = price;\\n\\n    emit TokenUpdated(collection, tokenId, data);\\n  }\\n\\n  function updateTokenStartDate(address collection, uint256 tokenId, uint256 startDate) external {\\n    require(onlyGrant() || collections[collection].artist == msg.sender, \\\"Invalid artist\\\");\\n    TokenData storage data = tokens[collection][tokenId];\\n    require(data.startDate > 0, \\\"Invalid token\\\");\\n\\n    data.startDate = startDate;\\n\\n    emit TokenUpdated(collection, tokenId, data);\\n  }\\n\\n  function updateTokenMetadata(address collection, uint256 tokenId, string calldata metadata) external {\\n    require(onlyGrant() || collections[collection].artist == msg.sender, \\\"Invalid artist\\\");\\n    TokenData storage data = tokens[collection][tokenId];\\n\\n    data.metadata = metadata;\\n\\n    emit TokenUpdated(collection, tokenId, data);\\n  }\\n\\n  function buy(\\n    address collection,\\n    uint256 tokenId,\\n    uint256 tokenLogic // amount - 0 for 721, N for 1155\\n  ) external virtual payable {\\n    address user = msg.sender;\\n    uint256 value = msg.value;\\n    TokenData storage tokenData = tokens[collection][tokenId];\\n\\n    CollectionData memory collectionData = collections[collection];\\n    uint256 fee = (value * collectionData.mintFeePlatform) / RATIO;\\n    payable(platform).transfer(fee);\\n    payable(collectionData.artist).transfer(value - fee);\\n\\n    // require(tokenData.price > 0, \\\"Invalid token\\\");\\n    require(tokenData.startDate < block.timestamp, \\\"Invalid sale\\\");\\n    if (tokenLogic == 0) {\\n      // ERC721\\n      require(tokenData.price == value, \\\"Invalid price\\\");\\n\\n      if (collections[collection].splitter == address(0)) {\\n        // Manifolds\\n        INFT(collection).transferFrom(address(this), user, tokenId);\\n      } else {\\n        INFT(collection).mint(tokenId, tokenData.metadata, user);\\n      }\\n      tokenLogic = 1;\\n    } else {\\n      // ERC1155\\n      require(tokenData.price * tokenLogic == value, \\\"Invalid price\\\");\\n\\n      if (collections[collection].splitter == address(0)) {\\n        // Manifolds\\n        INFT(collection).safeTransferFrom(address(this), user, tokenId, tokenLogic, \\\"\\\");\\n      } else {\\n        tokenData.amount = tokenData.amount - tokenLogic;\\n        INFT(collection).mint(tokenId, tokenLogic, tokenData.metadata, user);\\n      }\\n    }\\n    emit TokenSold(collection, tokenId, tokenLogic, value);\\n  }\\n\\n  function airdrop(address collection, uint256 tokenId, address[] calldata redeemers) external virtual {\\n    require(onlyGrant(), \\\"Invalid permission\\\");\\n    TokenData storage data = tokens[collection][tokenId];\\n    // require(data.price > 0, \\\"Invalid token\\\");\\n\\n    if (collections[collection].splitter == address(0)) {\\n      // Manifolds\\n      if (collections[collection].logicIndex > 0) {\\n        // ERC1155\\n        uint256 tokenLogic = redeemers.length;\\n        for (uint256 i = 0; i < tokenLogic; i++) {\\n          INFT(collection).safeTransferFrom(address(this), redeemers[i], tokenId, 1, \\\"\\\");\\n        }\\n      } else {\\n        // ERC721\\n        INFT(collection).transferFrom(address(this), redeemers[0], tokenId);\\n      }\\n    } else {\\n      if (collections[collection].logicIndex > 0) {\\n        // ERC1155\\n        uint256 tokenLogic = redeemers.length;\\n        data.amount = data.amount - tokenLogic;\\n        for (uint256 i = 0; i < tokenLogic; i++) {\\n          INFT(collection).mint(tokenId, 1, data.metadata, redeemers[i]);\\n        }\\n      } else {\\n        // ERC721\\n        INFT(collection).mint(tokenId, data.metadata, redeemers[0]);\\n      }\\n    }\\n    emit TokenAirdropped(collection, tokenId, redeemers);\\n  }\\n\\n  function redeem(\\n    address collection,\\n    uint256 tokenId,\\n    address[] calldata redeemers,\\n    uint256[] calldata prices\\n  ) external virtual {\\n    require(onlyTrdparty());\\n    TokenData storage data = tokens[collection][tokenId];\\n    // require(data.price > 0, \\\"Invalid token\\\");\\n\\n    if (collections[collection].splitter == address(0)) {\\n      // Manifolds\\n      if (collections[collection].logicIndex > 0) {\\n        // ERC1155\\n        uint256 tokenLogic = redeemers.length;\\n        for (uint256 i = 0; i < tokenLogic; i++) {\\n          INFT(collection).safeTransferFrom(address(this), redeemers[i], tokenId, 1, \\\"\\\");\\n        }\\n      } else {\\n        // ERC721\\n        INFT(collection).transferFrom(address(this), redeemers[0], tokenId);\\n      }\\n    } else {\\n      if (collections[collection].logicIndex > 0) {\\n        // ERC1155\\n        uint256 tokenLogic = redeemers.length;\\n        data.amount = data.amount - tokenLogic;\\n        for (uint256 i = 0; i < tokenLogic; i++) {\\n          INFT(collection).mint(tokenId, 1, data.metadata, redeemers[i]);\\n        }\\n      } else {\\n        // ERC721\\n        INFT(collection).mint(tokenId, data.metadata, redeemers[0]);\\n      }\\n    }\\n    emit TokenRedeemed(collection, tokenId, redeemers, prices);\\n  }\\n\\n  function royaltyInfo(address collection, uint256, uint256 value) external view returns (address, uint256) {\\n    CollectionData memory data = collections[collection];\\n    return (data.splitter, (value * data.royaltyCollection) / RATIO);\\n  }\\n\\n  function collectRoyalties(address collection, ICoin[] calldata coins) external {\\n    address artist = msg.sender;\\n    CollectionData memory data = collections[collection];\\n    require(data.artist == artist, \\\"Invalid artist\\\");\\n    (uint256 balance, uint256[] memory coinBalances) = RoyaltySplitter(payable(data.splitter)).claim(coins);\\n\\n    uint256 royalties = balance;\\n    uint256 feePlatform = (royalties * data.royaltyPlatform) / data.royaltyCollection;\\n    payable(platform).transfer(feePlatform);\\n    payable(artist).transfer(royalties - feePlatform);\\n\\n    for (uint256 i = 0; i < coinBalances.length; i++) {\\n      royalties = coinBalances[i];\\n      feePlatform = (royalties * data.royaltyPlatform) / data.royaltyCollection;\\n      coins[i].transfer(platform, feePlatform);\\n      coins[i].transfer(artist, royalties - feePlatform);\\n    }\\n  }\\n\\n  function transferOwnership(address newOwner) public virtual override {\\n    require(msg.sender == owner);\\n    owner = newOwner;\\n    emit OwnershipTransferred(msg.sender, newOwner);\\n  }\\n\\n  function setLogic(uint256 index, address newLogic) external {\\n    require(onlyOwner());\\n    logics[index] = newLogic;\\n  }\\n\\n  function escapeTokens(address token, uint256 amount) external {\\n    require(onlyGrant());\\n    INFT(token).transferFrom(address(this), msg.sender, amount);\\n  }\\n\\n  function escapeSafeTokens(address token, uint256 id, uint256 amount) external {\\n    require(onlyGrant());\\n    INFT(token).safeTransferFrom(address(this), msg.sender, id, amount, \\\"\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/UnitLondonMarketplaceV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./utils/Proxy.sol\\\";\\nimport \\\"./utils/RoyaltySplitter.sol\\\";\\nimport \\\"./UnitLondonMarketplace.sol\\\";\\n\\ninterface INFTV2 {\\n  function mint(uint256 tokenId, address user) external;\\n\\n  function mint(uint256 tokenId, uint256 amount, address user) external;\\n\\n  function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n  function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes memory data) external;\\n\\n  function ownerOf(uint256 tokenId) external view returns (address);\\n\\n  function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n  function initialize(string calldata _name, string calldata _symbol) external;\\n\\n  function transferOwnership(address newOwner) external;\\n}\\n\\ninterface IMetadata {\\n  function metadata() external view returns (string memory);\\n}\\n\\ninterface IProxy {\\n  function implementation() external view returns (address);\\n}\\n\\ncontract UnitLondonMarketplaceV2 is UnitLondonMarketplace {\\n  mapping(address => mapping(uint256 => address)) onChainMetadatas;\\n\\n  address constant logic0V1 = 0xB6330B44CCC567D3252cF8987b4E1ed1d8ED744F;\\n  address constant logic1V1 = 0x402FEEB4b633D97Df94A53e232B5d7F12fb2976F;\\n\\n  function addOnChain(\\n    address collection,\\n    uint256 tokenId,\\n    uint256 tokenLogic, // amount - 0 for 721, N for 1155\\n    uint256 price,\\n    uint256 startDate,\\n    address metadata\\n  ) external {\\n    require(onlyGrant() || collections[collection].artist == msg.sender, \\\"Invalid artist\\\");\\n    TokenData storage data = tokens[collection][tokenId];\\n    require(data.price == 0, \\\"Invalid token\\\");\\n\\n    require(collections[collection].splitter != address(0), \\\"Invalid on-chain\\\");\\n    onChainMetadatas[collection][tokenId] = metadata;\\n\\n    data.amount = tokenLogic;\\n    data.price = price;\\n    data.startDate = startDate;\\n\\n    emit TokenUpdated(collection, tokenId, data);\\n  }\\n\\n  function updateOnChainMetadata(address collection, uint256 tokenId, address metadata) external {\\n    require(onlyGrant() || collections[collection].artist == msg.sender, \\\"Invalid artist\\\");\\n    TokenData memory data = tokens[collection][tokenId];\\n\\n    require(onChainMetadatas[collection][tokenId] != address(0), \\\"Invalid on-chain\\\");\\n    onChainMetadatas[collection][tokenId] = metadata;\\n\\n    emit TokenUpdated(collection, tokenId, data);\\n  }\\n\\n  function buy(\\n    address collection,\\n    uint256 tokenId,\\n    uint256 tokenLogic // amount - 0 for 721, N for 1155\\n  ) external payable override {\\n    address user = msg.sender;\\n    uint256 value = msg.value;\\n    TokenData storage tokenData = tokens[collection][tokenId];\\n\\n    CollectionData memory collectionData = collections[collection];\\n    uint256 fee = (value * collectionData.mintFeePlatform) / RATIO;\\n    payable(platform).transfer(fee);\\n    payable(collectionData.artist).transfer(value - fee);\\n\\n    // require(tokenData.price > 0, \\\"Invalid token\\\");\\n    require(tokenData.startDate < block.timestamp, \\\"Invalid sale\\\");\\n    if (tokenLogic == 0) {\\n      // ERC721\\n      require(tokenData.price == value, \\\"Invalid price\\\");\\n\\n      if (collections[collection].splitter == address(0)) {\\n        // Manifolds\\n        INFTV2(collection).transferFrom(address(this), user, tokenId);\\n      } else {\\n        if (IProxy(collection).implementation() == logic0V1) {\\n          INFT(collection).mint(tokenId, tokenData.metadata, user);\\n        } else {\\n          INFTV2(collection).mint(tokenId, user);\\n        }\\n      }\\n      tokenLogic = 1;\\n    } else {\\n      // ERC1155\\n      require(tokenData.price * tokenLogic == value, \\\"Invalid price\\\");\\n\\n      if (collections[collection].splitter == address(0)) {\\n        // Manifolds\\n        INFTV2(collection).safeTransferFrom(address(this), user, tokenId, tokenLogic, \\\"\\\");\\n      } else {\\n        tokenData.amount = tokenData.amount - tokenLogic;\\n        if (IProxy(collection).implementation() == logic1V1) {\\n          INFT(collection).mint(tokenId, tokenLogic, tokenData.metadata, user);\\n        } else {\\n          INFTV2(collection).mint(tokenId, tokenLogic, user);\\n        }\\n      }\\n    }\\n    emit TokenSold(collection, tokenId, tokenLogic, value);\\n  }\\n\\n  function airdrop(address collection, uint256 tokenId, address[] calldata redeemers) external override {\\n    require(onlyGrant(), \\\"Invalid permission\\\");\\n    TokenData storage data = tokens[collection][tokenId];\\n    // require(data.price > 0, \\\"Invalid token\\\");\\n\\n    if (collections[collection].splitter == address(0)) {\\n      // Manifolds\\n      if (collections[collection].logicIndex > 0) {\\n        // ERC1155\\n        uint256 tokenLogic = redeemers.length;\\n        for (uint256 i = 0; i < tokenLogic; i++) {\\n          INFTV2(collection).safeTransferFrom(address(this), redeemers[i], tokenId, 1, \\\"\\\");\\n        }\\n      } else {\\n        // ERC721\\n        INFTV2(collection).transferFrom(address(this), redeemers[0], tokenId);\\n      }\\n    } else {\\n      if (collections[collection].logicIndex > 0) {\\n        // ERC1155\\n        uint256 tokenLogic = redeemers.length;\\n        data.amount = data.amount - tokenLogic;\\n        for (uint256 i = 0; i < tokenLogic; i++) {\\n          if (IProxy(collection).implementation() == logic1V1) {\\n            INFT(collection).mint(tokenId, 1, data.metadata, redeemers[i]);\\n          } else {\\n            INFTV2(collection).mint(tokenId, 1, redeemers[i]);\\n          }\\n        }\\n      } else {\\n        // ERC721\\n        if (IProxy(collection).implementation() == logic0V1) {\\n          INFT(collection).mint(tokenId, data.metadata, redeemers[0]);\\n        } else {\\n          INFTV2(collection).mint(tokenId, redeemers[0]);\\n        }\\n      }\\n    }\\n    emit TokenAirdropped(collection, tokenId, redeemers);\\n  }\\n\\n  function redeem(\\n    address collection,\\n    uint256 tokenId,\\n    address[] calldata redeemers,\\n    uint256[] calldata prices\\n  ) external override {\\n    require(onlyTrdparty());\\n    TokenData storage data = tokens[collection][tokenId];\\n    // require(data.price > 0, \\\"Invalid token\\\");\\n\\n    if (collections[collection].splitter == address(0)) {\\n      // Manifolds\\n      if (collections[collection].logicIndex > 0) {\\n        // ERC1155\\n        uint256 tokenLogic = redeemers.length;\\n        for (uint256 i = 0; i < tokenLogic; i++) {\\n          INFTV2(collection).safeTransferFrom(address(this), redeemers[i], tokenId, 1, \\\"\\\");\\n        }\\n      } else {\\n        // ERC721\\n        INFTV2(collection).transferFrom(address(this), redeemers[0], tokenId);\\n      }\\n    } else {\\n      if (collections[collection].logicIndex > 0) {\\n        // ERC1155\\n        uint256 tokenLogic = redeemers.length;\\n        data.amount = data.amount - tokenLogic;\\n        for (uint256 i = 0; i < tokenLogic; i++) {\\n          if (IProxy(collection).implementation() == logic1V1) {\\n            INFT(collection).mint(tokenId, 1, data.metadata, redeemers[i]);\\n          } else {\\n            INFTV2(collection).mint(tokenId, 1, redeemers[i]);\\n          }\\n        }\\n      } else {\\n        // ERC721\\n        if (IProxy(collection).implementation() == logic0V1) {\\n          INFT(collection).mint(tokenId, data.metadata, redeemers[0]);\\n        } else {\\n          INFTV2(collection).mint(tokenId, redeemers[0]);\\n        }\\n      }\\n    }\\n    emit TokenRedeemed(collection, tokenId, redeemers, prices);\\n  }\\n\\n  function tokenURI(address collection, uint256 tokenId) external view returns (string memory) {\\n    if (onChainMetadatas[collection][tokenId] == address(0)) {\\n      return tokens[collection][tokenId].metadata;\\n    } else {\\n      return IMetadata(onChainMetadatas[collection][tokenId]).metadata();\\n    }\\n  }\\n\\n  event ArtistUpdated(address artist, string metadata);\\n  function setArtist(address artist, string memory metadata) external {\\n    require(onlyGrant());\\n    artists[artist] = true;\\n\\n    emit ArtistUpdated(artist, metadata);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOwnable {\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  function owner() external view returns (address);\\n\\n  function transferOwnership(address newOwner) external;\\n\\n  // function renounceOwnership() external;\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ProxyData.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\ncontract Proxy is ProxyData {\\n  receive() external payable {}\\n\\n  function setImplementation(address newImpl) public {\\n    require(msg.sender == admin);\\n    implementation_ = newImpl;\\n  }\\n\\n  function implementation() public view returns (address impl) {\\n    impl = implementation_;\\n  }\\n\\n  /**\\n   * @dev Delegates the current call to `implementation`.\\n   *\\n   * This function does not return to its internall call site, it will return directly to the external caller.\\n   */\\n  function _delegate(address implementation__) internal virtual {\\n    assembly {\\n      // Copy msg.data. We take full control of memory in this inline assembly\\n      // block because it will not return to Solidity code. We overwrite the\\n      // Solidity scratch pad at memory position 0.\\n      calldatacopy(0, 0, calldatasize())\\n\\n      // Call the implementation.\\n      // out and outsize are 0 because we don't know the size yet.\\n      let result := delegatecall(gas(), implementation__, 0, calldatasize(), 0, 0)\\n\\n      // Copy the returned data.\\n      returndatacopy(0, 0, returndatasize())\\n\\n      switch result\\n      // delegatecall returns 0 on error.\\n      case 0 {\\n        revert(0, returndatasize())\\n      }\\n      default {\\n        return(0, returndatasize())\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n   * and {_fallback} should delegate.\\n   */\\n  function _implementation() internal view returns (address) {\\n    return implementation_;\\n  }\\n\\n  /**\\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n   * function in the contract matches the call data.\\n   */\\n  fallback() external payable virtual {\\n    _delegate(_implementation());\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ProxyData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract ProxyData {\\n  address implementation_;\\n  address public admin;\\n\\n  constructor() {\\n    admin = msg.sender;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/RoyaltySplitter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ICoin {\\n  function balanceOf(address) external view returns (uint256);\\n\\n  function transfer(address, uint256) external returns (bool);\\n}\\n\\ncontract RoyaltySplitter {\\n  address owner;\\n\\n  constructor() {\\n    owner = msg.sender;\\n  }\\n\\n  function claim(ICoin[] calldata coins) external returns (uint256 balance, uint256[] memory coinBalances) {\\n    require(owner == msg.sender);\\n\\n    balance = address(this).balance;\\n    payable(owner).transfer(balance);\\n\\n    uint256 coinCount = coins.length;\\n    coinBalances = new uint256[](coinCount);\\n\\n    for (uint256 i = 0; i < coinCount; i++) {\\n      coinBalances[i] = coins[i].balanceOf(address(this));\\n      coins[i].transfer(owner, coinBalances[i]);\\n    }\\n  }\\n\\n  fallback() external payable {}\\n\\n  receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Vault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract Vault {\\n  function onERC1155Received(\\n    address,\\n    address,\\n    uint256,\\n    uint256,\\n    bytes calldata\\n  ) public virtual returns (bytes4) {\\n    return this.onERC1155Received.selector;\\n  }\\n\\n  function onERC1155BatchReceived(\\n    address,\\n    address,\\n    uint256[] calldata,\\n    uint256[] calldata,\\n    bytes calldata\\n  ) public virtual returns (bytes4) {\\n    return this.onERC1155BatchReceived.selector;\\n  }\\n\\n  function onERC721Received(\\n    address,\\n    address,\\n    uint256,\\n    bytes calldata\\n  ) external virtual returns (bytes4) {\\n    return 0x150b7a02;\\n  }\\n\\n  // Used by ERC721BasicToken.sol\\n  function onERC721Received(\\n    address,\\n    uint256,\\n    bytes calldata\\n  ) external virtual returns (bytes4) {\\n    return 0xf0b9e5ba;\\n  }\\n\\n  receive() external payable {}\\n}\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"artist\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"name\":\"ArtistUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"artist\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"splitter\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"mintFeePlatform\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"royaltyCollection\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"royaltyPlatform\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"logicIndex\",\"type\":\"uint32\"},{\"internalType\":\"string\",\"name\":\"contractURI\",\"type\":\"string\"}],\"indexed\":false,\"internalType\":\"struct UnitLondonMarketplace.CollectionData\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"CollectionRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPlatform\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPlatform\",\"type\":\"address\"}],\"name\":\"PlatformUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"redeemers\",\"type\":\"address[]\"}],\"name\":\"TokenAirdropped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"redeemers\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"}],\"name\":\"TokenRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TokenSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"indexed\":false,\"internalType\":\"struct UnitLondonMarketplace.TokenData\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"TokenUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenLogic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"metadata\",\"type\":\"address\"}],\"name\":\"addOnChain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenLogic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"name\":\"addToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"redeemers\",\"type\":\"address[]\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"artists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenLogic\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"contract ICoin[]\",\"name\":\"coins\",\"type\":\"address[]\"}],\"name\":\"collectRoyalties\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"collectionURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"collections\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"artist\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"splitter\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"mintFeePlatform\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"royaltyCollection\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"royaltyPlatform\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"logicIndex\",\"type\":\"uint32\"},{\"internalType\":\"string\",\"name\":\"contractURI\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"registers\",\"type\":\"address[]\"}],\"name\":\"emitCollectionRegistered\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"escapeSafeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"escapeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[2]\",\"name\":\"_logics\",\"type\":\"address[2]\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"logics\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintFeePlatform\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platform\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"redeemers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"logicIndex\",\"type\":\"uint32\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"artist\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"royaltyArtist\",\"type\":\"uint32\"},{\"internalType\":\"string\",\"name\":\"contractURI\",\"type\":\"string\"}],\"name\":\"registerCollection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"logicIndex\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"manifold\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"artist\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"contractURI\",\"type\":\"string\"}],\"name\":\"registerManifold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"artist\",\"type\":\"address\"}],\"name\":\"removeArtist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyPlatform\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"artist\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"name\":\"setArtist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_artists\",\"type\":\"address[]\"}],\"name\":\"setArtists\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newLogic\",\"type\":\"address\"}],\"name\":\"setLogic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"newMintFeePlatform\",\"type\":\"uint32\"}],\"name\":\"setMintFeePlatform\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPlatform\",\"type\":\"address\"}],\"name\":\"setPlatform\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"newRoyaltyPlatform\",\"type\":\"uint32\"}],\"name\":\"setRoyaltyPlatform\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTrdparty\",\"type\":\"address\"}],\"name\":\"setTrdparty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Proxy\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"syncLogic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trdparty\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"newMintFeePlatform\",\"type\":\"uint32\"}],\"name\":\"updateCollectionMintFeePlatform\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"royaltyArtist\",\"type\":\"uint32\"}],\"name\":\"updateCollectionRoyaltyArtist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"contractURI\",\"type\":\"string\"}],\"name\":\"updateCollectionURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"metadata\",\"type\":\"address\"}],\"name\":\"updateOnChainMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"name\":\"updateTokenMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"updateTokenPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"}],\"name\":\"updateTokenStartDate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "UnitLondonMarketplaceV2", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}