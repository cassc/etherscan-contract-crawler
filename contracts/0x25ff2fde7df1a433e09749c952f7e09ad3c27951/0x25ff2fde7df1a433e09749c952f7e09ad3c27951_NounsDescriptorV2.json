{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/NounsDescriptorV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title The Nouns NFT descriptor\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { Ownable } from '@openzeppelin/contracts/access/Ownable.sol';\\nimport { Strings } from '@openzeppelin/contracts/utils/Strings.sol';\\nimport { INounsDescriptorV2 } from './interfaces/INounsDescriptorV2.sol';\\nimport { INounsSeeder } from './interfaces/INounsSeeder.sol';\\nimport { NFTDescriptorV2 } from './libs/NFTDescriptorV2.sol';\\nimport { ISVGRenderer } from './interfaces/ISVGRenderer.sol';\\nimport { INounsArt } from './interfaces/INounsArt.sol';\\nimport { IInflator } from './interfaces/IInflator.sol';\\n\\ncontract NounsDescriptorV2 is INounsDescriptorV2, Ownable {\\n    using Strings for uint256;\\n\\n    // prettier-ignore\\n    // https://creativecommons.org/publicdomain/zero/1.0/legalcode.txt\\n    bytes32 constant COPYRIGHT_CC0_1_0_UNIVERSAL_LICENSE = 0xa2010f343487d3f7618affe54f789f5487602331c0a8d03f49e9a7c547cf0499;\\n\\n    /// @notice The contract responsible for holding compressed Noun art\\n    INounsArt public art;\\n\\n    /// @notice The contract responsible for constructing SVGs\\n    ISVGRenderer public renderer;\\n\\n    /// @notice Whether or not new Noun parts can be added\\n    bool public override arePartsLocked;\\n\\n    /// @notice Whether or not `tokenURI` should be returned as a data URI (Default: true)\\n    bool public override isDataURIEnabled = true;\\n\\n    /// @notice Base URI, used when isDataURIEnabled is false\\n    string public override baseURI;\\n\\n    /**\\n     * @notice Require that the parts have not been locked.\\n     */\\n    modifier whenPartsNotLocked() {\\n        require(!arePartsLocked, 'Parts are locked');\\n        _;\\n    }\\n\\n    constructor(INounsArt _art, ISVGRenderer _renderer) {\\n        art = _art;\\n        renderer = _renderer;\\n    }\\n\\n    /**\\n     * @notice Set the Noun's art contract.\\n     * @dev Only callable by the owner when not locked.\\n     */\\n    function setArt(INounsArt _art) external onlyOwner whenPartsNotLocked {\\n        art = _art;\\n\\n        emit ArtUpdated(_art);\\n    }\\n\\n    /**\\n     * @notice Set the SVG renderer.\\n     * @dev Only callable by the owner.\\n     */\\n    function setRenderer(ISVGRenderer _renderer) external onlyOwner {\\n        renderer = _renderer;\\n\\n        emit RendererUpdated(_renderer);\\n    }\\n\\n    /**\\n     * @notice Set the art contract's `descriptor`.\\n     * @param descriptor the address to set.\\n     * @dev Only callable by the owner.\\n     */\\n    function setArtDescriptor(address descriptor) external onlyOwner {\\n        art.setDescriptor(descriptor);\\n    }\\n\\n    /**\\n     * @notice Set the art contract's `inflator`.\\n     * @param inflator the address to set.\\n     * @dev Only callable by the owner.\\n     */\\n    function setArtInflator(IInflator inflator) external onlyOwner {\\n        art.setInflator(inflator);\\n    }\\n\\n    /**\\n     * @notice Get the number of available Noun `backgrounds`.\\n     */\\n    function backgroundCount() external view override returns (uint256) {\\n        return art.backgroundCount();\\n    }\\n\\n    /**\\n     * @notice Get the number of available Noun `bodies`.\\n     */\\n    function bodyCount() external view override returns (uint256) {\\n        return art.bodyCount();\\n    }\\n\\n    /**\\n     * @notice Get the number of available Noun `accessories`.\\n     */\\n    function accessoryCount() external view override returns (uint256) {\\n        return art.accessoryCount();\\n    }\\n\\n    /**\\n     * @notice Get the number of available Noun `heads`.\\n     */\\n    function headCount() external view override returns (uint256) {\\n        return art.headCount();\\n    }\\n\\n    /**\\n     * @notice Get the number of available Noun `glasses`.\\n     */\\n    function glassesCount() external view override returns (uint256) {\\n        return art.glassesCount();\\n    }\\n\\n    /**\\n     * @notice Batch add Noun backgrounds.\\n     * @dev This function can only be called by the owner when not locked.\\n     */\\n    function addManyBackgrounds(string[] calldata _backgrounds) external override onlyOwner whenPartsNotLocked {\\n        art.addManyBackgrounds(_backgrounds);\\n    }\\n\\n    /**\\n     * @notice Add a Noun background.\\n     * @dev This function can only be called by the owner when not locked.\\n     */\\n    function addBackground(string calldata _background) external override onlyOwner whenPartsNotLocked {\\n        art.addBackground(_background);\\n    }\\n\\n    /**\\n     * @notice Update a single color palette. This function can be used to\\n     * add a new color palette or update an existing palette.\\n     * @param paletteIndex the identifier of this palette\\n     * @param palette byte array of colors. every 3 bytes represent an RGB color. max length: 256 * 3 = 768\\n     * @dev This function can only be called by the owner when not locked.\\n     */\\n    function setPalette(uint8 paletteIndex, bytes calldata palette) external override onlyOwner whenPartsNotLocked {\\n        art.setPalette(paletteIndex, palette);\\n    }\\n\\n    /**\\n     * @notice Add a batch of body images.\\n     * @param encodedCompressed bytes created by taking a string array of RLE-encoded images, abi encoding it as a bytes array,\\n     * and finally compressing it using deflate.\\n     * @param decompressedLength the size in bytes the images bytes were prior to compression; required input for Inflate.\\n     * @param imageCount the number of images in this batch; used when searching for images among batches.\\n     * @dev This function can only be called by the owner when not locked.\\n     */\\n    function addBodies(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addBodies(encodedCompressed, decompressedLength, imageCount);\\n    }\\n\\n    /**\\n     * @notice Add a batch of accessory images.\\n     * @param encodedCompressed bytes created by taking a string array of RLE-encoded images, abi encoding it as a bytes array,\\n     * and finally compressing it using deflate.\\n     * @param decompressedLength the size in bytes the images bytes were prior to compression; required input for Inflate.\\n     * @param imageCount the number of images in this batch; used when searching for images among batches.\\n     * @dev This function can only be called by the owner when not locked.\\n     */\\n    function addAccessories(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addAccessories(encodedCompressed, decompressedLength, imageCount);\\n    }\\n\\n    /**\\n     * @notice Add a batch of head images.\\n     * @param encodedCompressed bytes created by taking a string array of RLE-encoded images, abi encoding it as a bytes array,\\n     * and finally compressing it using deflate.\\n     * @param decompressedLength the size in bytes the images bytes were prior to compression; required input for Inflate.\\n     * @param imageCount the number of images in this batch; used when searching for images among batches.\\n     * @dev This function can only be called by the owner when not locked.\\n     */\\n    function addHeads(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addHeads(encodedCompressed, decompressedLength, imageCount);\\n    }\\n\\n    /**\\n     * @notice Add a batch of glasses images.\\n     * @param encodedCompressed bytes created by taking a string array of RLE-encoded images, abi encoding it as a bytes array,\\n     * and finally compressing it using deflate.\\n     * @param decompressedLength the size in bytes the images bytes were prior to compression; required input for Inflate.\\n     * @param imageCount the number of images in this batch; used when searching for images among batches.\\n     * @dev This function can only be called by the owner when not locked.\\n     */\\n    function addGlasses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addGlasses(encodedCompressed, decompressedLength, imageCount);\\n    }\\n\\n    /**\\n     * @notice Update a single color palette. This function can be used to\\n     * add a new color palette or update an existing palette. This function does not check for data length validity\\n     * (len <= 768, len % 3 == 0).\\n     * @param paletteIndex the identifier of this palette\\n     * @param pointer the address of the contract holding the palette bytes. every 3 bytes represent an RGB color.\\n     * max length: 256 * 3 = 768.\\n     * @dev This function can only be called by the owner when not locked.\\n     */\\n    function setPalettePointer(uint8 paletteIndex, address pointer) external override onlyOwner whenPartsNotLocked {\\n        art.setPalettePointer(paletteIndex, pointer);\\n    }\\n\\n    /**\\n     * @notice Add a batch of body images from an existing storage contract.\\n     * @param pointer the address of a contract where the image batch was stored using SSTORE2. The data\\n     * format is expected to be like {encodedCompressed}: bytes created by taking a string array of\\n     * RLE-encoded images, abi encoding it as a bytes array, and finally compressing it using deflate.\\n     * @param decompressedLength the size in bytes the images bytes were prior to compression; required input for Inflate.\\n     * @param imageCount the number of images in this batch; used when searching for images among batches.\\n     * @dev This function can only be called by the owner when not locked.\\n     */\\n    function addBodiesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addBodiesFromPointer(pointer, decompressedLength, imageCount);\\n    }\\n\\n    /**\\n     * @notice Add a batch of accessory images from an existing storage contract.\\n     * @param pointer the address of a contract where the image batch was stored using SSTORE2. The data\\n     * format is expected to be like {encodedCompressed}: bytes created by taking a string array of\\n     * RLE-encoded images, abi encoding it as a bytes array, and finally compressing it using deflate.\\n     * @param decompressedLength the size in bytes the images bytes were prior to compression; required input for Inflate.\\n     * @param imageCount the number of images in this batch; used when searching for images among batches.\\n     * @dev This function can only be called by the owner when not locked.\\n     */\\n    function addAccessoriesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addAccessoriesFromPointer(pointer, decompressedLength, imageCount);\\n    }\\n\\n    /**\\n     * @notice Add a batch of head images from an existing storage contract.\\n     * @param pointer the address of a contract where the image batch was stored using SSTORE2. The data\\n     * format is expected to be like {encodedCompressed}: bytes created by taking a string array of\\n     * RLE-encoded images, abi encoding it as a bytes array, and finally compressing it using deflate.\\n     * @param decompressedLength the size in bytes the images bytes were prior to compression; required input for Inflate.\\n     * @param imageCount the number of images in this batch; used when searching for images among batches.\\n     * @dev This function can only be called by the owner when not locked.\\n     */\\n    function addHeadsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addHeadsFromPointer(pointer, decompressedLength, imageCount);\\n    }\\n\\n    /**\\n     * @notice Add a batch of glasses images from an existing storage contract.\\n     * @param pointer the address of a contract where the image batch was stored using SSTORE2. The data\\n     * format is expected to be like {encodedCompressed}: bytes created by taking a string array of\\n     * RLE-encoded images, abi encoding it as a bytes array, and finally compressing it using deflate.\\n     * @param decompressedLength the size in bytes the images bytes were prior to compression; required input for Inflate.\\n     * @param imageCount the number of images in this batch; used when searching for images among batches.\\n     * @dev This function can only be called by the owner when not locked.\\n     */\\n    function addGlassesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyOwner whenPartsNotLocked {\\n        art.addGlassesFromPointer(pointer, decompressedLength, imageCount);\\n    }\\n\\n    /**\\n     * @notice Get a background color by ID.\\n     * @param index the index of the background.\\n     * @return string the RGB hex value of the background.\\n     */\\n    function backgrounds(uint256 index) public view override returns (string memory) {\\n        return art.backgrounds(index);\\n    }\\n\\n    /**\\n     * @notice Get a head image by ID.\\n     * @param index the index of the head.\\n     * @return bytes the RLE-encoded bytes of the image.\\n     */\\n    function heads(uint256 index) public view override returns (bytes memory) {\\n        return art.heads(index);\\n    }\\n\\n    /**\\n     * @notice Get a body image by ID.\\n     * @param index the index of the body.\\n     * @return bytes the RLE-encoded bytes of the image.\\n     */\\n    function bodies(uint256 index) public view override returns (bytes memory) {\\n        return art.bodies(index);\\n    }\\n\\n    /**\\n     * @notice Get an accessory image by ID.\\n     * @param index the index of the accessory.\\n     * @return bytes the RLE-encoded bytes of the image.\\n     */\\n    function accessories(uint256 index) public view override returns (bytes memory) {\\n        return art.accessories(index);\\n    }\\n\\n    /**\\n     * @notice Get a glasses image by ID.\\n     * @param index the index of the glasses.\\n     * @return bytes the RLE-encoded bytes of the image.\\n     */\\n    function glasses(uint256 index) public view override returns (bytes memory) {\\n        return art.glasses(index);\\n    }\\n\\n    /**\\n     * @notice Get a color palette by ID.\\n     * @param index the index of the palette.\\n     * @return bytes the palette bytes, where every 3 consecutive bytes represent a color in RGB format.\\n     */\\n    function palettes(uint8 index) public view override returns (bytes memory) {\\n        return art.palettes(index);\\n    }\\n\\n    /**\\n     * @notice Lock all Noun parts.\\n     * @dev This cannot be reversed and can only be called by the owner when not locked.\\n     */\\n    function lockParts() external override onlyOwner whenPartsNotLocked {\\n        arePartsLocked = true;\\n\\n        emit PartsLocked();\\n    }\\n\\n    /**\\n     * @notice Toggle a boolean value which determines if `tokenURI` returns a data URI\\n     * or an HTTP URL.\\n     * @dev This can only be called by the owner.\\n     */\\n    function toggleDataURIEnabled() external override onlyOwner {\\n        bool enabled = !isDataURIEnabled;\\n\\n        isDataURIEnabled = enabled;\\n        emit DataURIToggled(enabled);\\n    }\\n\\n    /**\\n     * @notice Set the base URI for all token IDs. It is automatically\\n     * added as a prefix to the value returned in {tokenURI}, or to the\\n     * token ID if {tokenURI} is empty.\\n     * @dev This can only be called by the owner.\\n     */\\n    function setBaseURI(string calldata _baseURI) external override onlyOwner {\\n        baseURI = _baseURI;\\n\\n        emit BaseURIUpdated(_baseURI);\\n    }\\n\\n    /**\\n     * @notice Given a token ID and seed, construct a token URI for an official Nouns DAO noun.\\n     * @dev The returned value may be a base64 encoded data URI or an API URL.\\n     */\\n    function tokenURI(uint256 tokenId, INounsSeeder.Seed memory seed) external view override returns (string memory) {\\n        if (isDataURIEnabled) {\\n            return dataURI(tokenId, seed);\\n        }\\n        return string(abi.encodePacked(baseURI, tokenId.toString()));\\n    }\\n\\n    /**\\n     * @notice Given a token ID and seed, construct a base64 encoded data URI for an official Nouns DAO noun.\\n     */\\n    function dataURI(uint256 tokenId, INounsSeeder.Seed memory seed) public view override returns (string memory) {\\n        string memory nounId = tokenId.toString();\\n        string memory name = string(abi.encodePacked('Noun ', nounId));\\n        string memory description = string(abi.encodePacked('Noun ', nounId, ' is a member of the Nouns DAO'));\\n\\n        return genericDataURI(name, description, seed);\\n    }\\n\\n    /**\\n     * @notice Given a name, description, and seed, construct a base64 encoded data URI.\\n     */\\n    function genericDataURI(\\n        string memory name,\\n        string memory description,\\n        INounsSeeder.Seed memory seed\\n    ) public view override returns (string memory) {\\n        NFTDescriptorV2.TokenURIParams memory params = NFTDescriptorV2.TokenURIParams({\\n            name: name,\\n            description: description,\\n            parts: getPartsForSeed(seed),\\n            background: art.backgrounds(seed.background)\\n        });\\n        return NFTDescriptorV2.constructTokenURI(renderer, params);\\n    }\\n\\n    /**\\n     * @notice Given a seed, construct a base64 encoded SVG image.\\n     */\\n    function generateSVGImage(INounsSeeder.Seed memory seed) external view override returns (string memory) {\\n        ISVGRenderer.SVGParams memory params = ISVGRenderer.SVGParams({\\n            parts: getPartsForSeed(seed),\\n            background: art.backgrounds(seed.background)\\n        });\\n        return NFTDescriptorV2.generateSVGImage(renderer, params);\\n    }\\n\\n    /**\\n     * @notice Get all Noun parts for the passed `seed`.\\n     */\\n    function getPartsForSeed(INounsSeeder.Seed memory seed) public view returns (ISVGRenderer.Part[] memory) {\\n        bytes memory body = art.bodies(seed.body);\\n        bytes memory accessory = art.accessories(seed.accessory);\\n        bytes memory head = art.heads(seed.head);\\n        bytes memory glasses_ = art.glasses(seed.glasses);\\n\\n        ISVGRenderer.Part[] memory parts = new ISVGRenderer.Part[](4);\\n        parts[0] = ISVGRenderer.Part({ image: body, palette: _getPalette(body) });\\n        parts[1] = ISVGRenderer.Part({ image: accessory, palette: _getPalette(accessory) });\\n        parts[2] = ISVGRenderer.Part({ image: head, palette: _getPalette(head) });\\n        parts[3] = ISVGRenderer.Part({ image: glasses_, palette: _getPalette(glasses_) });\\n        return parts;\\n    }\\n\\n    /**\\n     * @notice Get the color palette pointer for the passed part.\\n     */\\n    function _getPalette(bytes memory part) private view returns (bytes memory) {\\n        return art.palettes(uint8(part[0]));\\n    }\\n}\\n\"\r\n    },\r\n    \"../../node_modules/@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"../../node_modules/@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INounsDescriptorV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Interface for NounsDescriptorV2\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { INounsSeeder } from './INounsSeeder.sol';\\nimport { ISVGRenderer } from './ISVGRenderer.sol';\\nimport { INounsArt } from './INounsArt.sol';\\nimport { INounsDescriptorMinimal } from './INounsDescriptorMinimal.sol';\\n\\ninterface INounsDescriptorV2 is INounsDescriptorMinimal {\\n    event PartsLocked();\\n\\n    event DataURIToggled(bool enabled);\\n\\n    event BaseURIUpdated(string baseURI);\\n\\n    event ArtUpdated(INounsArt art);\\n\\n    event RendererUpdated(ISVGRenderer renderer);\\n\\n    error EmptyPalette();\\n    error BadPaletteLength();\\n    error IndexNotFound();\\n\\n    function arePartsLocked() external returns (bool);\\n\\n    function isDataURIEnabled() external returns (bool);\\n\\n    function baseURI() external returns (string memory);\\n\\n    function palettes(uint8 paletteIndex) external view returns (bytes memory);\\n\\n    function backgrounds(uint256 index) external view returns (string memory);\\n\\n    function bodies(uint256 index) external view returns (bytes memory);\\n\\n    function accessories(uint256 index) external view returns (bytes memory);\\n\\n    function heads(uint256 index) external view returns (bytes memory);\\n\\n    function glasses(uint256 index) external view returns (bytes memory);\\n\\n    function backgroundCount() external view override returns (uint256);\\n\\n    function bodyCount() external view override returns (uint256);\\n\\n    function accessoryCount() external view override returns (uint256);\\n\\n    function headCount() external view override returns (uint256);\\n\\n    function glassesCount() external view override returns (uint256);\\n\\n    function addManyBackgrounds(string[] calldata backgrounds) external;\\n\\n    function addBackground(string calldata background) external;\\n\\n    function setPalette(uint8 paletteIndex, bytes calldata palette) external;\\n\\n    function addBodies(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function addAccessories(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function addHeads(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function addGlasses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function setPalettePointer(uint8 paletteIndex, address pointer) external;\\n\\n    function addBodiesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function addAccessoriesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function addHeadsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function addGlassesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function lockParts() external;\\n\\n    function toggleDataURIEnabled() external;\\n\\n    function setBaseURI(string calldata baseURI) external;\\n\\n    function tokenURI(uint256 tokenId, INounsSeeder.Seed memory seed) external view override returns (string memory);\\n\\n    function dataURI(uint256 tokenId, INounsSeeder.Seed memory seed) external view override returns (string memory);\\n\\n    function genericDataURI(\\n        string calldata name,\\n        string calldata description,\\n        INounsSeeder.Seed memory seed\\n    ) external view returns (string memory);\\n\\n    function generateSVGImage(INounsSeeder.Seed memory seed) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INounsSeeder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Interface for NounsSeeder\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { INounsDescriptorMinimal } from './INounsDescriptorMinimal.sol';\\n\\ninterface INounsSeeder {\\n    struct Seed {\\n        uint48 background;\\n        uint48 body;\\n        uint48 accessory;\\n        uint48 head;\\n        uint48 glasses;\\n    }\\n\\n    function generateSeed(uint256 nounId, INounsDescriptorMinimal descriptor) external view returns (Seed memory);\\n}\\n\"\r\n    },\r\n    \"contracts/libs/NFTDescriptorV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title A library used to construct ERC721 token URIs and SVG images\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { Base64 } from 'base64-sol/base64.sol';\\nimport { ISVGRenderer } from '../interfaces/ISVGRenderer.sol';\\n\\nlibrary NFTDescriptorV2 {\\n    struct TokenURIParams {\\n        string name;\\n        string description;\\n        string background;\\n        ISVGRenderer.Part[] parts;\\n    }\\n\\n    /**\\n     * @notice Construct an ERC721 token URI.\\n     */\\n    function constructTokenURI(ISVGRenderer renderer, TokenURIParams memory params)\\n        public\\n        view\\n        returns (string memory)\\n    {\\n        string memory image = generateSVGImage(\\n            renderer,\\n            ISVGRenderer.SVGParams({ parts: params.parts, background: params.background })\\n        );\\n\\n        // prettier-ignore\\n        return string(\\n            abi.encodePacked(\\n                'data:application/json;base64,',\\n                Base64.encode(\\n                    bytes(\\n                        abi.encodePacked('{\\\"name\\\":\\\"', params.name, '\\\", \\\"description\\\":\\\"', params.description, '\\\", \\\"image\\\": \\\"', 'data:image/svg+xml;base64,', image, '\\\"}')\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Generate an SVG image for use in the ERC721 token URI.\\n     */\\n    function generateSVGImage(ISVGRenderer renderer, ISVGRenderer.SVGParams memory params)\\n        public\\n        view\\n        returns (string memory svg)\\n    {\\n        return Base64.encode(bytes(renderer.generateSVG(params)));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISVGRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Interface for SVGRenderer\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\ninterface ISVGRenderer {\\n    struct Part {\\n        bytes image;\\n        bytes palette;\\n    }\\n\\n    struct SVGParams {\\n        Part[] parts;\\n        string background;\\n    }\\n\\n    function generateSVG(SVGParams memory params) external view returns (string memory svg);\\n\\n    function generateSVGPart(Part memory part) external view returns (string memory partialSVG);\\n\\n    function generateSVGParts(Part[] memory parts) external view returns (string memory partialSVG);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INounsArt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Interface for NounsArt\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { IInflator } from './IInflator.sol';\\n\\ninterface INounsArt {\\n    error SenderIsNotDescriptor();\\n\\n    error EmptyPalette();\\n\\n    error BadPaletteLength();\\n\\n    error EmptyBytes();\\n\\n    error BadDecompressedLength();\\n\\n    error BadImageCount();\\n\\n    error ImageNotFound();\\n\\n    error PaletteNotFound();\\n\\n    event DescriptorUpdated(address oldDescriptor, address newDescriptor);\\n\\n    event InflatorUpdated(address oldInflator, address newInflator);\\n\\n    event BackgroundsAdded(uint256 count);\\n\\n    event PaletteSet(uint8 paletteIndex);\\n\\n    event BodiesAdded(uint16 count);\\n\\n    event AccessoriesAdded(uint16 count);\\n\\n    event HeadsAdded(uint16 count);\\n\\n    event GlassesAdded(uint16 count);\\n\\n    struct NounArtStoragePage {\\n        uint16 imageCount;\\n        uint80 decompressedLength;\\n        address pointer;\\n    }\\n\\n    struct Trait {\\n        NounArtStoragePage[] storagePages;\\n        uint256 storedImagesCount;\\n    }\\n\\n    function descriptor() external view returns (address);\\n\\n    function inflator() external view returns (IInflator);\\n\\n    function setDescriptor(address descriptor) external;\\n\\n    function setInflator(IInflator inflator) external;\\n\\n    function addManyBackgrounds(string[] calldata _backgrounds) external;\\n\\n    function addBackground(string calldata _background) external;\\n\\n    function palettes(uint8 paletteIndex) external view returns (bytes memory);\\n\\n    function setPalette(uint8 paletteIndex, bytes calldata palette) external;\\n\\n    function addBodies(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function addAccessories(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function addHeads(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function addGlasses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function addBodiesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function setPalettePointer(uint8 paletteIndex, address pointer) external;\\n\\n    function addAccessoriesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function addHeadsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function addGlassesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function backgroundCount() external view returns (uint256);\\n\\n    function bodyCount() external view returns (uint256);\\n\\n    function accessoryCount() external view returns (uint256);\\n\\n    function headCount() external view returns (uint256);\\n\\n    function glassesCount() external view returns (uint256);\\n\\n    function backgrounds(uint256 index) external view returns (string memory);\\n\\n    function heads(uint256 index) external view returns (bytes memory);\\n\\n    function bodies(uint256 index) external view returns (bytes memory);\\n\\n    function accessories(uint256 index) external view returns (bytes memory);\\n\\n    function glasses(uint256 index) external view returns (bytes memory);\\n\\n    function getBodiesTrait() external view returns (Trait memory);\\n\\n    function getAccessoriesTrait() external view returns (Trait memory);\\n\\n    function getHeadsTrait() external view returns (Trait memory);\\n\\n    function getGlassesTrait() external view returns (Trait memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IInflator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Interface for Inflator\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { Inflate } from '../libs/Inflate.sol';\\n\\ninterface IInflator {\\n    function puff(bytes memory source, uint256 destlen) external pure returns (Inflate.ErrorCode, bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INounsDescriptorMinimal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Common interface for NounsDescriptor versions, as used by NounsToken and NounsSeeder.\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { INounsSeeder } from './INounsSeeder.sol';\\n\\ninterface INounsDescriptorMinimal {\\n    ///\\n    /// USED BY TOKEN\\n    ///\\n\\n    function tokenURI(uint256 tokenId, INounsSeeder.Seed memory seed) external view returns (string memory);\\n\\n    function dataURI(uint256 tokenId, INounsSeeder.Seed memory seed) external view returns (string memory);\\n\\n    ///\\n    /// USED BY SEEDER\\n    ///\\n\\n    function backgroundCount() external view returns (uint256);\\n\\n    function bodyCount() external view returns (uint256);\\n\\n    function accessoryCount() external view returns (uint256);\\n\\n    function headCount() external view returns (uint256);\\n\\n    function glassesCount() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"../../node_modules/base64-sol/base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides functions for encoding/decoding base64\\nlibrary Base64 {\\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n    bytes  internal constant TABLE_DECODE = hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\"\\n                                            hex\\\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\\\"\\n                                            hex\\\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\\\"\\n                                            hex\\\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n\\n        // load the table into memory\\n        string memory table = TABLE_ENCODE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n                // read 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // write 4 characters\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n\\n        return result;\\n    }\\n\\n    function decode(string memory _data) internal pure returns (bytes memory) {\\n        bytes memory data = bytes(_data);\\n\\n        if (data.length == 0) return new bytes(0);\\n        require(data.length % 4 == 0, \\\"invalid base64 decoder input\\\");\\n\\n        // load the table into memory\\n        bytes memory table = TABLE_DECODE;\\n\\n        // every 4 characters represent 3 bytes\\n        uint256 decodedLen = (data.length / 4) * 3;\\n\\n        // add some extra buffer at the end required for the writing\\n        bytes memory result = new bytes(decodedLen + 32);\\n\\n        assembly {\\n            // padding with '='\\n            let lastBytes := mload(add(data, mload(data)))\\n            if eq(and(lastBytes, 0xFF), 0x3d) {\\n                decodedLen := sub(decodedLen, 1)\\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\\n                    decodedLen := sub(decodedLen, 1)\\n                }\\n            }\\n\\n            // set the actual output length\\n            mstore(result, decodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 4 characters at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n               // read 4 characters\\n               dataPtr := add(dataPtr, 4)\\n               let input := mload(dataPtr)\\n\\n               // write 3 bytes\\n               let output := add(\\n                   add(\\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\\n                   add(\\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\\n                    )\\n                )\\n                mstore(resultPtr, shl(232, output))\\n                resultPtr := add(resultPtr, 3)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/Inflate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/// @notice Based on https://github.com/madler/zlib/blob/master/contrib/puff\\n/// @dev Modified the original code for gas optimizations\\n/// 1. Disable overflow/underflow checks\\n/// 2. Chunk some loop iterations\\nlibrary Inflate {\\n    // Maximum bits in a code\\n    uint256 constant MAXBITS = 15;\\n    // Maximum number of literal/length codes\\n    uint256 constant MAXLCODES = 286;\\n    // Maximum number of distance codes\\n    uint256 constant MAXDCODES = 30;\\n    // Maximum codes lengths to read\\n    uint256 constant MAXCODES = (MAXLCODES + MAXDCODES);\\n    // Number of fixed literal/length codes\\n    uint256 constant FIXLCODES = 288;\\n\\n    // Error codes\\n    enum ErrorCode {\\n        ERR_NONE, // 0 successful inflate\\n        ERR_NOT_TERMINATED, // 1 available inflate data did not terminate\\n        ERR_OUTPUT_EXHAUSTED, // 2 output space exhausted before completing inflate\\n        ERR_INVALID_BLOCK_TYPE, // 3 invalid block type (type == 3)\\n        ERR_STORED_LENGTH_NO_MATCH, // 4 stored block length did not match one's complement\\n        ERR_TOO_MANY_LENGTH_OR_DISTANCE_CODES, // 5 dynamic block code description: too many length or distance codes\\n        ERR_CODE_LENGTHS_CODES_INCOMPLETE, // 6 dynamic block code description: code lengths codes incomplete\\n        ERR_REPEAT_NO_FIRST_LENGTH, // 7 dynamic block code description: repeat lengths with no first length\\n        ERR_REPEAT_MORE, // 8 dynamic block code description: repeat more than specified lengths\\n        ERR_INVALID_LITERAL_LENGTH_CODE_LENGTHS, // 9 dynamic block code description: invalid literal/length code lengths\\n        ERR_INVALID_DISTANCE_CODE_LENGTHS, // 10 dynamic block code description: invalid distance code lengths\\n        ERR_MISSING_END_OF_BLOCK, // 11 dynamic block code description: missing end-of-block code\\n        ERR_INVALID_LENGTH_OR_DISTANCE_CODE, // 12 invalid literal/length or distance code in fixed or dynamic block\\n        ERR_DISTANCE_TOO_FAR, // 13 distance is too far back in fixed or dynamic block\\n        ERR_CONSTRUCT // 14 internal: error in construct()\\n    }\\n\\n    // Input and output state\\n    struct State {\\n        //////////////////\\n        // Output state //\\n        //////////////////\\n        // Output buffer\\n        bytes output;\\n        // Bytes written to out so far\\n        uint256 outcnt;\\n        /////////////////\\n        // Input state //\\n        /////////////////\\n        // Input buffer\\n        bytes input;\\n        // Bytes read so far\\n        uint256 incnt;\\n        ////////////////\\n        // Temp state //\\n        ////////////////\\n        // Bit buffer\\n        uint256 bitbuf;\\n        // Number of bits in bit buffer\\n        uint256 bitcnt;\\n        //////////////////////////\\n        // Static Huffman codes //\\n        //////////////////////////\\n        Huffman lencode;\\n        Huffman distcode;\\n    }\\n\\n    // Huffman code decoding tables\\n    struct Huffman {\\n        uint256[] counts;\\n        uint256[] symbols;\\n    }\\n\\n    function bits(State memory s, uint256 need) private pure returns (ErrorCode, uint256) {\\n        unchecked {\\n            // Bit accumulator (can use up to 20 bits)\\n            uint256 val;\\n\\n            // Load at least need bits into val\\n            val = s.bitbuf;\\n            while (s.bitcnt < need) {\\n                if (s.incnt == s.input.length) {\\n                    // Out of input\\n                    return (ErrorCode.ERR_NOT_TERMINATED, 0);\\n                }\\n\\n                // Load eight bits\\n                val |= uint256(uint8(s.input[s.incnt++])) << s.bitcnt;\\n                s.bitcnt += 8;\\n            }\\n\\n            // Drop need bits and update buffer, always zero to seven bits left\\n            s.bitbuf = val >> need;\\n            s.bitcnt -= need;\\n\\n            // Return need bits, zeroing the bits above that\\n            uint256 ret = (val & ((1 << need) - 1));\\n            return (ErrorCode.ERR_NONE, ret);\\n        }\\n    }\\n\\n    function _stored(State memory s) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Length of stored block\\n            uint256 len;\\n\\n            // Discard leftover bits from current byte (assumes s.bitcnt < 8)\\n            s.bitbuf = 0;\\n            s.bitcnt = 0;\\n\\n            // Get length and check against its one's complement\\n            if (s.incnt + 4 > s.input.length) {\\n                // Not enough input\\n                return ErrorCode.ERR_NOT_TERMINATED;\\n            }\\n            len = uint256(uint8(s.input[s.incnt++]));\\n            len |= uint256(uint8(s.input[s.incnt++])) << 8;\\n\\n            if (uint8(s.input[s.incnt++]) != (~len & 0xFF) || uint8(s.input[s.incnt++]) != ((~len >> 8) & 0xFF)) {\\n                // Didn't match complement!\\n                return ErrorCode.ERR_STORED_LENGTH_NO_MATCH;\\n            }\\n\\n            // Copy len bytes from in to out\\n            if (s.incnt + len > s.input.length) {\\n                // Not enough input\\n                return ErrorCode.ERR_NOT_TERMINATED;\\n            }\\n            if (s.outcnt + len > s.output.length) {\\n                // Not enough output space\\n                return ErrorCode.ERR_OUTPUT_EXHAUSTED;\\n            }\\n            while (len != 0) {\\n                // Note: Solidity reverts on underflow, so we decrement here\\n                len -= 1;\\n                s.output[s.outcnt++] = s.input[s.incnt++];\\n            }\\n\\n            // Done with a valid stored block\\n            return ErrorCode.ERR_NONE;\\n        }\\n    }\\n\\n    function _decode(State memory s, Huffman memory h) private pure returns (ErrorCode, uint256) {\\n        unchecked {\\n            // Current number of bits in code\\n            uint256 len;\\n            // Len bits being decoded\\n            uint256 code = 0;\\n            // First code of length len\\n            uint256 first = 0;\\n            // Number of codes of length len\\n            uint256 count;\\n            // Index of first code of length len in symbol table\\n            uint256 index = 0;\\n            // Error code\\n            ErrorCode err;\\n\\n            uint256 tempCode;\\n            for (len = 1; len <= MAXBITS; len += 5) {\\n                // Get next bit\\n                (err, tempCode) = bits(s, 1);\\n                if (err != ErrorCode.ERR_NONE) {\\n                    return (err, 0);\\n                }\\n                code |= tempCode;\\n                count = h.counts[len];\\n\\n                // If length len, return symbol\\n                if (code < first + count) {\\n                    return (ErrorCode.ERR_NONE, h.symbols[index + (code - first)]);\\n                }\\n                // Else update for next length\\n                index += count;\\n                first += count;\\n                first <<= 1;\\n                code <<= 1;\\n\\n                // Get next bit\\n                (err, tempCode) = bits(s, 1);\\n                if (err != ErrorCode.ERR_NONE) {\\n                    return (err, 0);\\n                }\\n                code |= tempCode;\\n                count = h.counts[len + 1];\\n\\n                // If length len, return symbol\\n                if (code < first + count) {\\n                    return (ErrorCode.ERR_NONE, h.symbols[index + (code - first)]);\\n                }\\n                // Else update for next length\\n                index += count;\\n                first += count;\\n                first <<= 1;\\n                code <<= 1;\\n\\n                // Get next bit\\n                (err, tempCode) = bits(s, 1);\\n                if (err != ErrorCode.ERR_NONE) {\\n                    return (err, 0);\\n                }\\n                code |= tempCode;\\n                count = h.counts[len + 2];\\n\\n                // If length len, return symbol\\n                if (code < first + count) {\\n                    return (ErrorCode.ERR_NONE, h.symbols[index + (code - first)]);\\n                }\\n                // Else update for next length\\n                index += count;\\n                first += count;\\n                first <<= 1;\\n                code <<= 1;\\n\\n                // Get next bit\\n                (err, tempCode) = bits(s, 1);\\n                if (err != ErrorCode.ERR_NONE) {\\n                    return (err, 0);\\n                }\\n                code |= tempCode;\\n                count = h.counts[len + 3];\\n\\n                // If length len, return symbol\\n                if (code < first + count) {\\n                    return (ErrorCode.ERR_NONE, h.symbols[index + (code - first)]);\\n                }\\n                // Else update for next length\\n                index += count;\\n                first += count;\\n                first <<= 1;\\n                code <<= 1;\\n\\n                // Get next bit\\n                (err, tempCode) = bits(s, 1);\\n                if (err != ErrorCode.ERR_NONE) {\\n                    return (err, 0);\\n                }\\n                code |= tempCode;\\n                count = h.counts[len + 4];\\n\\n                // If length len, return symbol\\n                if (code < first + count) {\\n                    return (ErrorCode.ERR_NONE, h.symbols[index + (code - first)]);\\n                }\\n                // Else update for next length\\n                index += count;\\n                first += count;\\n                first <<= 1;\\n                code <<= 1;\\n            }\\n\\n            // Ran out of codes\\n            return (ErrorCode.ERR_INVALID_LENGTH_OR_DISTANCE_CODE, 0);\\n        }\\n    }\\n\\n    function _construct(\\n        Huffman memory h,\\n        uint256[] memory lengths,\\n        uint256 n,\\n        uint256 start\\n    ) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Current symbol when stepping through lengths[]\\n            uint256 symbol;\\n            // Current length when stepping through h.counts[]\\n            uint256 len;\\n            // Number of possible codes left of current length\\n            uint256 left;\\n            // Offsets in symbol table for each length\\n            uint256[MAXBITS + 1] memory offs;\\n\\n            // Count number of codes of each length\\n            for (len = 0; len <= MAXBITS; ++len) {\\n                h.counts[len] = 0;\\n            }\\n            for (symbol = 0; symbol < n; ++symbol) {\\n                // Assumes lengths are within bounds\\n                ++h.counts[lengths[start + symbol]];\\n            }\\n            // No codes!\\n            if (h.counts[0] == n) {\\n                // Complete, but decode() will fail\\n                return (ErrorCode.ERR_NONE);\\n            }\\n\\n            // Check for an over-subscribed or incomplete set of lengths\\n\\n            // One possible code of zero length\\n            left = 1;\\n\\n            for (len = 1; len <= MAXBITS; len += 5) {\\n                // One more bit, double codes left\\n                left <<= 1;\\n                if (left < h.counts[len]) {\\n                    // Over-subscribed--return error\\n                    return ErrorCode.ERR_CONSTRUCT;\\n                }\\n                // Deduct count from possible codes\\n                left -= h.counts[len];\\n\\n                // One more bit, double codes left\\n                left <<= 1;\\n                if (left < h.counts[len + 1]) {\\n                    // Over-subscribed--return error\\n                    return ErrorCode.ERR_CONSTRUCT;\\n                }\\n                // Deduct count from possible codes\\n                left -= h.counts[len + 1];\\n\\n                // One more bit, double codes left\\n                left <<= 1;\\n                if (left < h.counts[len + 2]) {\\n                    // Over-subscribed--return error\\n                    return ErrorCode.ERR_CONSTRUCT;\\n                }\\n                // Deduct count from possible codes\\n                left -= h.counts[len + 2];\\n\\n                // One more bit, double codes left\\n                left <<= 1;\\n                if (left < h.counts[len + 3]) {\\n                    // Over-subscribed--return error\\n                    return ErrorCode.ERR_CONSTRUCT;\\n                }\\n                // Deduct count from possible codes\\n                left -= h.counts[len + 3];\\n\\n                // One more bit, double codes left\\n                left <<= 1;\\n                if (left < h.counts[len + 4]) {\\n                    // Over-subscribed--return error\\n                    return ErrorCode.ERR_CONSTRUCT;\\n                }\\n                // Deduct count from possible codes\\n                left -= h.counts[len + 4];\\n            }\\n\\n            // Generate offsets into symbol table for each length for sorting\\n            offs[1] = 0;\\n            for (len = 1; len < MAXBITS; ++len) {\\n                offs[len + 1] = offs[len] + h.counts[len];\\n            }\\n\\n            // Put symbols in table sorted by length, by symbol order within each length\\n            for (symbol = 0; symbol < n; ++symbol) {\\n                if (lengths[start + symbol] != 0) {\\n                    h.symbols[offs[lengths[start + symbol]]++] = symbol;\\n                }\\n            }\\n\\n            // Left > 0 means incomplete\\n            return left > 0 ? ErrorCode.ERR_CONSTRUCT : ErrorCode.ERR_NONE;\\n        }\\n    }\\n\\n    function _codes(\\n        State memory s,\\n        Huffman memory lencode,\\n        Huffman memory distcode\\n    ) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Decoded symbol\\n            uint256 symbol;\\n            // Length for copy\\n            uint256 len;\\n            // Distance for copy\\n            uint256 dist;\\n            // TODO Solidity doesn't support constant arrays, but these are fixed at compile-time\\n            // Size base for length codes 257..285\\n            uint16[29] memory lens = [\\n                3,\\n                4,\\n                5,\\n                6,\\n                7,\\n                8,\\n                9,\\n                10,\\n                11,\\n                13,\\n                15,\\n                17,\\n                19,\\n                23,\\n                27,\\n                31,\\n                35,\\n                43,\\n                51,\\n                59,\\n                67,\\n                83,\\n                99,\\n                115,\\n                131,\\n                163,\\n                195,\\n                227,\\n                258\\n            ];\\n            // Extra bits for length codes 257..285\\n            uint8[29] memory lext = [\\n                0,\\n                0,\\n                0,\\n                0,\\n                0,\\n                0,\\n                0,\\n                0,\\n                1,\\n                1,\\n                1,\\n                1,\\n                2,\\n                2,\\n                2,\\n                2,\\n                3,\\n                3,\\n                3,\\n                3,\\n                4,\\n                4,\\n                4,\\n                4,\\n                5,\\n                5,\\n                5,\\n                5,\\n                0\\n            ];\\n            // Offset base for distance codes 0..29\\n            uint16[30] memory dists = [\\n                1,\\n                2,\\n                3,\\n                4,\\n                5,\\n                7,\\n                9,\\n                13,\\n                17,\\n                25,\\n                33,\\n                49,\\n                65,\\n                97,\\n                129,\\n                193,\\n                257,\\n                385,\\n                513,\\n                769,\\n                1025,\\n                1537,\\n                2049,\\n                3073,\\n                4097,\\n                6145,\\n                8193,\\n                12289,\\n                16385,\\n                24577\\n            ];\\n            // Extra bits for distance codes 0..29\\n            uint8[30] memory dext = [\\n                0,\\n                0,\\n                0,\\n                0,\\n                1,\\n                1,\\n                2,\\n                2,\\n                3,\\n                3,\\n                4,\\n                4,\\n                5,\\n                5,\\n                6,\\n                6,\\n                7,\\n                7,\\n                8,\\n                8,\\n                9,\\n                9,\\n                10,\\n                10,\\n                11,\\n                11,\\n                12,\\n                12,\\n                13,\\n                13\\n            ];\\n            // Error code\\n            ErrorCode err;\\n\\n            // Decode literals and length/distance pairs\\n            while (symbol != 256) {\\n                (err, symbol) = _decode(s, lencode);\\n                if (err != ErrorCode.ERR_NONE) {\\n                    // Invalid symbol\\n                    return err;\\n                }\\n\\n                if (symbol < 256) {\\n                    // Literal: symbol is the byte\\n                    // Write out the literal\\n                    if (s.outcnt == s.output.length) {\\n                        return ErrorCode.ERR_OUTPUT_EXHAUSTED;\\n                    }\\n                    s.output[s.outcnt] = bytes1(uint8(symbol));\\n                    ++s.outcnt;\\n                } else if (symbol > 256) {\\n                    uint256 tempBits;\\n                    // Length\\n                    // Get and compute length\\n                    symbol -= 257;\\n                    if (symbol >= 29) {\\n                        // Invalid fixed code\\n                        return ErrorCode.ERR_INVALID_LENGTH_OR_DISTANCE_CODE;\\n                    }\\n\\n                    (err, tempBits) = bits(s, lext[symbol]);\\n                    if (err != ErrorCode.ERR_NONE) {\\n                        return err;\\n                    }\\n                    len = lens[symbol] + tempBits;\\n\\n                    // Get and check distance\\n                    (err, symbol) = _decode(s, distcode);\\n                    if (err != ErrorCode.ERR_NONE) {\\n                        // Invalid symbol\\n                        return err;\\n                    }\\n                    (err, tempBits) = bits(s, dext[symbol]);\\n                    if (err != ErrorCode.ERR_NONE) {\\n                        return err;\\n                    }\\n                    dist = dists[symbol] + tempBits;\\n                    if (dist > s.outcnt) {\\n                        // Distance too far back\\n                        return ErrorCode.ERR_DISTANCE_TOO_FAR;\\n                    }\\n\\n                    // Copy length bytes from distance bytes back\\n                    if (s.outcnt + len > s.output.length) {\\n                        return ErrorCode.ERR_OUTPUT_EXHAUSTED;\\n                    }\\n                    while (len != 0) {\\n                        // Note: Solidity reverts on underflow, so we decrement here\\n                        len -= 1;\\n                        s.output[s.outcnt] = s.output[s.outcnt - dist];\\n                        ++s.outcnt;\\n                    }\\n                } else {\\n                    s.outcnt += len;\\n                }\\n            }\\n\\n            // Done with a valid fixed or dynamic block\\n            return ErrorCode.ERR_NONE;\\n        }\\n    }\\n\\n    function _build_fixed(State memory s) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Build fixed Huffman tables\\n            // TODO this is all a compile-time constant\\n            uint256 symbol;\\n            uint256[] memory lengths = new uint256[](FIXLCODES);\\n\\n            // Literal/length table\\n            for (symbol = 0; symbol < 144; ++symbol) {\\n                lengths[symbol] = 8;\\n            }\\n            for (; symbol < 256; ++symbol) {\\n                lengths[symbol] = 9;\\n            }\\n            for (; symbol < 280; ++symbol) {\\n                lengths[symbol] = 7;\\n            }\\n            for (; symbol < FIXLCODES; ++symbol) {\\n                lengths[symbol] = 8;\\n            }\\n\\n            _construct(s.lencode, lengths, FIXLCODES, 0);\\n\\n            // Distance table\\n            for (symbol = 0; symbol < MAXDCODES; ++symbol) {\\n                lengths[symbol] = 5;\\n            }\\n\\n            _construct(s.distcode, lengths, MAXDCODES, 0);\\n\\n            return ErrorCode.ERR_NONE;\\n        }\\n    }\\n\\n    function _fixed(State memory s) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Decode data until end-of-block code\\n            return _codes(s, s.lencode, s.distcode);\\n        }\\n    }\\n\\n    function _build_dynamic_lengths(State memory s) private pure returns (ErrorCode, uint256[] memory) {\\n        unchecked {\\n            uint256 ncode;\\n            // Index of lengths[]\\n            uint256 index;\\n            // Descriptor code lengths\\n            uint256[] memory lengths = new uint256[](MAXCODES);\\n            // Error code\\n            ErrorCode err;\\n            // Permutation of code length codes\\n            uint8[19] memory order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\\n\\n            (err, ncode) = bits(s, 4);\\n            if (err != ErrorCode.ERR_NONE) {\\n                return (err, lengths);\\n            }\\n            ncode += 4;\\n\\n            // Read code length code lengths (really), missing lengths are zero\\n            for (index = 0; index < ncode; ++index) {\\n                (err, lengths[order[index]]) = bits(s, 3);\\n                if (err != ErrorCode.ERR_NONE) {\\n                    return (err, lengths);\\n                }\\n            }\\n            for (; index < 19; ++index) {\\n                lengths[order[index]] = 0;\\n            }\\n\\n            return (ErrorCode.ERR_NONE, lengths);\\n        }\\n    }\\n\\n    function _build_dynamic(State memory s)\\n        private\\n        pure\\n        returns (\\n            ErrorCode,\\n            Huffman memory,\\n            Huffman memory\\n        )\\n    {\\n        unchecked {\\n            // Number of lengths in descriptor\\n            uint256 nlen;\\n            uint256 ndist;\\n            // Index of lengths[]\\n            uint256 index;\\n            // Error code\\n            ErrorCode err;\\n            // Descriptor code lengths\\n            uint256[] memory lengths = new uint256[](MAXCODES);\\n            // Length and distance codes\\n            Huffman memory lencode = Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXLCODES));\\n            Huffman memory distcode = Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXDCODES));\\n            uint256 tempBits;\\n\\n            // Get number of lengths in each table, check lengths\\n            (err, nlen) = bits(s, 5);\\n            if (err != ErrorCode.ERR_NONE) {\\n                return (err, lencode, distcode);\\n            }\\n            nlen += 257;\\n            (err, ndist) = bits(s, 5);\\n            if (err != ErrorCode.ERR_NONE) {\\n                return (err, lencode, distcode);\\n            }\\n            ndist += 1;\\n\\n            if (nlen > MAXLCODES || ndist > MAXDCODES) {\\n                // Bad counts\\n                return (ErrorCode.ERR_TOO_MANY_LENGTH_OR_DISTANCE_CODES, lencode, distcode);\\n            }\\n\\n            (err, lengths) = _build_dynamic_lengths(s);\\n            if (err != ErrorCode.ERR_NONE) {\\n                return (err, lencode, distcode);\\n            }\\n\\n            // Build huffman table for code lengths codes (use lencode temporarily)\\n            err = _construct(lencode, lengths, 19, 0);\\n            if (err != ErrorCode.ERR_NONE) {\\n                // Require complete code set here\\n                return (ErrorCode.ERR_CODE_LENGTHS_CODES_INCOMPLETE, lencode, distcode);\\n            }\\n\\n            // Read length/literal and distance code length tables\\n            index = 0;\\n            while (index < nlen + ndist) {\\n                // Decoded value\\n                uint256 symbol;\\n                // Last length to repeat\\n                uint256 len;\\n\\n                (err, symbol) = _decode(s, lencode);\\n                if (err != ErrorCode.ERR_NONE) {\\n                    // Invalid symbol\\n                    return (err, lencode, distcode);\\n                }\\n\\n                if (symbol < 16) {\\n                    // Length in 0..15\\n                    lengths[index++] = symbol;\\n                } else {\\n                    // Repeat instruction\\n                    // Assume repeating zeros\\n                    len = 0;\\n                    if (symbol == 16) {\\n                        // Repeat last length 3..6 times\\n                        if (index == 0) {\\n                            // No last length!\\n                            return (ErrorCode.ERR_REPEAT_NO_FIRST_LENGTH, lencode, distcode);\\n                        }\\n                        // Last length\\n                        len = lengths[index - 1];\\n                        (err, tempBits) = bits(s, 2);\\n                        if (err != ErrorCode.ERR_NONE) {\\n                            return (err, lencode, distcode);\\n                        }\\n                        symbol = 3 + tempBits;\\n                    } else if (symbol == 17) {\\n                        // Repeat zero 3..10 times\\n                        (err, tempBits) = bits(s, 3);\\n                        if (err != ErrorCode.ERR_NONE) {\\n                            return (err, lencode, distcode);\\n                        }\\n                        symbol = 3 + tempBits;\\n                    } else {\\n                        // == 18, repeat zero 11..138 times\\n                        (err, tempBits) = bits(s, 7);\\n                        if (err != ErrorCode.ERR_NONE) {\\n                            return (err, lencode, distcode);\\n                        }\\n                        symbol = 11 + tempBits;\\n                    }\\n\\n                    if (index + symbol > nlen + ndist) {\\n                        // Too many lengths!\\n                        return (ErrorCode.ERR_REPEAT_MORE, lencode, distcode);\\n                    }\\n                    while (symbol != 0) {\\n                        // Note: Solidity reverts on underflow, so we decrement here\\n                        symbol -= 1;\\n\\n                        // Repeat last or zero symbol times\\n                        lengths[index++] = len;\\n                    }\\n                }\\n            }\\n\\n            // Check for end-of-block code -- there better be one!\\n            if (lengths[256] == 0) {\\n                return (ErrorCode.ERR_MISSING_END_OF_BLOCK, lencode, distcode);\\n            }\\n\\n            // Build huffman table for literal/length codes\\n            err = _construct(lencode, lengths, nlen, 0);\\n            if (\\n                err != ErrorCode.ERR_NONE &&\\n                (err == ErrorCode.ERR_NOT_TERMINATED ||\\n                    err == ErrorCode.ERR_OUTPUT_EXHAUSTED ||\\n                    nlen != lencode.counts[0] + lencode.counts[1])\\n            ) {\\n                // Incomplete code ok only for single length 1 code\\n                return (ErrorCode.ERR_INVALID_LITERAL_LENGTH_CODE_LENGTHS, lencode, distcode);\\n            }\\n\\n            // Build huffman table for distance codes\\n            err = _construct(distcode, lengths, ndist, nlen);\\n            if (\\n                err != ErrorCode.ERR_NONE &&\\n                (err == ErrorCode.ERR_NOT_TERMINATED ||\\n                    err == ErrorCode.ERR_OUTPUT_EXHAUSTED ||\\n                    ndist != distcode.counts[0] + distcode.counts[1])\\n            ) {\\n                // Incomplete code ok only for single length 1 code\\n                return (ErrorCode.ERR_INVALID_DISTANCE_CODE_LENGTHS, lencode, distcode);\\n            }\\n\\n            return (ErrorCode.ERR_NONE, lencode, distcode);\\n        }\\n    }\\n\\n    function _dynamic(State memory s) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Length and distance codes\\n            Huffman memory lencode;\\n            Huffman memory distcode;\\n            // Error code\\n            ErrorCode err;\\n\\n            (err, lencode, distcode) = _build_dynamic(s);\\n            if (err != ErrorCode.ERR_NONE) {\\n                return err;\\n            }\\n\\n            // Decode data until end-of-block code\\n            return _codes(s, lencode, distcode);\\n        }\\n    }\\n\\n    function puff(bytes memory source, uint256 destlen) internal pure returns (ErrorCode, bytes memory) {\\n        unchecked {\\n            // Input/output state\\n            State memory s = State(\\n                new bytes(destlen),\\n                0,\\n                source,\\n                0,\\n                0,\\n                0,\\n                Huffman(new uint256[](MAXBITS + 1), new uint256[](FIXLCODES)),\\n                Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXDCODES))\\n            );\\n            // Temp: last bit\\n            uint256 last;\\n            // Temp: block type bit\\n            uint256 t;\\n            // Error code\\n            ErrorCode err;\\n\\n            // Build fixed Huffman tables\\n            err = _build_fixed(s);\\n            if (err != ErrorCode.ERR_NONE) {\\n                return (err, s.output);\\n            }\\n\\n            // Process blocks until last block or error\\n            while (last == 0) {\\n                // One if last block\\n                (err, last) = bits(s, 1);\\n                if (err != ErrorCode.ERR_NONE) {\\n                    return (err, s.output);\\n                }\\n\\n                // Block type 0..3\\n                (err, t) = bits(s, 2);\\n                if (err != ErrorCode.ERR_NONE) {\\n                    return (err, s.output);\\n                }\\n\\n                err = (\\n                    t == 0\\n                        ? _stored(s)\\n                        : (t == 1 ? _fixed(s) : (t == 2 ? _dynamic(s) : ErrorCode.ERR_INVALID_BLOCK_TYPE))\\n                );\\n                // type == 3, invalid\\n\\n                if (err != ErrorCode.ERR_NONE) {\\n                    // Return with error\\n                    break;\\n                }\\n            }\\n\\n            return (err, s.output);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@ensdomains/=../../node_modules/@ensdomains/\",\r\n      \"@openzeppelin/=../../node_modules/@openzeppelin/\",\r\n      \"base64-sol/=../../node_modules/base64-sol/\",\r\n      \"eth-gas-reporter/=../../node_modules/eth-gas-reporter/\",\r\n      \"hardhat/=../../node_modules/hardhat/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {\r\n      \"contracts/libs/NFTDescriptorV2.sol\": {\r\n        \"NFTDescriptorV2\": \"0x77a537bd9aCFe57dd64abb4076ed7257Aa3C6F4e\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract INounsArt\",\"name\":\"_art\",\"type\":\"address\"},{\"internalType\":\"contract ISVGRenderer\",\"name\":\"_renderer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BadPaletteLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyPalette\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IndexNotFound\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract INounsArt\",\"name\":\"art\",\"type\":\"address\"}],\"name\":\"ArtUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"BaseURIUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"DataURIToggled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PartsLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ISVGRenderer\",\"name\":\"renderer\",\"type\":\"address\"}],\"name\":\"RendererUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"accessories\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accessoryCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addAccessories\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addAccessoriesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_background\",\"type\":\"string\"}],\"name\":\"addBackground\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addBodies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addBodiesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addGlasses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addGlassesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addHeads\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addHeadsFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_backgrounds\",\"type\":\"string[]\"}],\"name\":\"addManyBackgrounds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"arePartsLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"art\",\"outputs\":[{\"internalType\":\"contract INounsArt\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"backgroundCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"backgrounds\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"bodies\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bodyCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"background\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"body\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"accessory\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"head\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"glasses\",\"type\":\"uint48\"}],\"internalType\":\"struct INounsSeeder.Seed\",\"name\":\"seed\",\"type\":\"tuple\"}],\"name\":\"dataURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"background\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"body\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"accessory\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"head\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"glasses\",\"type\":\"uint48\"}],\"internalType\":\"struct INounsSeeder.Seed\",\"name\":\"seed\",\"type\":\"tuple\"}],\"name\":\"generateSVGImage\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"background\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"body\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"accessory\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"head\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"glasses\",\"type\":\"uint48\"}],\"internalType\":\"struct INounsSeeder.Seed\",\"name\":\"seed\",\"type\":\"tuple\"}],\"name\":\"genericDataURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"background\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"body\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"accessory\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"head\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"glasses\",\"type\":\"uint48\"}],\"internalType\":\"struct INounsSeeder.Seed\",\"name\":\"seed\",\"type\":\"tuple\"}],\"name\":\"getPartsForSeed\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"image\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"palette\",\"type\":\"bytes\"}],\"internalType\":\"struct ISVGRenderer.Part[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"glasses\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"glassesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"headCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"heads\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isDataURIEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockParts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"palettes\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renderer\",\"outputs\":[{\"internalType\":\"contract ISVGRenderer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract INounsArt\",\"name\":\"_art\",\"type\":\"address\"}],\"name\":\"setArt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"descriptor\",\"type\":\"address\"}],\"name\":\"setArtDescriptor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IInflator\",\"name\":\"inflator\",\"type\":\"address\"}],\"name\":\"setArtInflator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"palette\",\"type\":\"bytes\"}],\"name\":\"setPalette\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"name\":\"setPalettePointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISVGRenderer\",\"name\":\"_renderer\",\"type\":\"address\"}],\"name\":\"setRenderer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleDataURIEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"background\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"body\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"accessory\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"head\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"glasses\",\"type\":\"uint48\"}],\"internalType\":\"struct INounsSeeder.Seed\",\"name\":\"seed\",\"type\":\"tuple\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NounsDescriptorV2", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000921687c7a40a7f209100db16aa95f787f6b4e67700000000000000000000000081d94554a4b072bfcd850205f0c79e97c92aab56", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}