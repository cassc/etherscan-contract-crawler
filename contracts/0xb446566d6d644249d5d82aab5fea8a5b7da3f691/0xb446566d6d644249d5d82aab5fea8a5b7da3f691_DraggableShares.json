{"SourceCode": "{\"DraggableShares.sol\":{\"content\":\"/**\\r\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\r\\n*\\r\\n* MIT License with Automated License Fee Payments\\r\\n*\\r\\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\\r\\n*\\r\\n* Permission is hereby granted to any person obtaining a copy of this software\\r\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\r\\n* without restriction, including without limitation the rights to use, copy,\\r\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\r\\n* Software, and to permit persons to whom the Software is furnished to do so,\\r\\n* subject to the following conditions:\\r\\n*\\r\\n* - The above copyright notice and this permission notice shall be included in\\r\\n*   all copies or substantial portions of the Software.\\r\\n* - All automated license fee payments integrated into this and related Software\\r\\n*   are preserved.\\r\\n*\\r\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\r\\n* SOFTWARE.\\r\\n*/\\r\\npragma solidity \\u003e=0.8;\\r\\n\\r\\nimport \\\"./ERC20Recoverable.sol\\\";\\r\\nimport \\\"./ERC20Draggable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Draggable CompanyName AG Shares\\r\\n * @author Luzius Meisser, luzius@aktionariat.com\\r\\n *\\r\\n * This is an ERC-20 token representing shares of CompanyName AG that are bound to\\r\\n * a shareholder agreement that can be found at the URL defined in the constant \\u0027terms\\u0027.\\r\\n * The shareholder agreement is partially enforced through this smart contract. The agreement\\r\\n * is designed to facilitate a complete acquisition of the firm even if a minority of shareholders\\r\\n * disagree with the acquisition, to protect the interest of the minority shareholders by requiring\\r\\n * the acquirer to offer the same conditions to everyone when acquiring the company, and to\\r\\n * facilitate an update of the shareholder agreement even if a minority of the shareholders that\\r\\n * are bound to this agreement disagree. The name \\\"draggable\\\" stems from the convention of calling\\r\\n * the right to drag a minority along with a sale of the company \\\"drag-along\\\" rights. The name is\\r\\n * chosen to ensure that token holders are aware that they are bound to such an agreement.\\r\\n *\\r\\n * The percentage of token holders that must agree with an update of the terms is defined by the\\r\\n * constant UPDATE_QUORUM. The percentage of yes-votes that is needed to successfully complete an\\r\\n * acquisition is defined in the constant ACQUISITION_QUORUM. Note that the update quorum is based\\r\\n * on the total number of tokens in circulation. In contrast, the acquisition quorum is based on the\\r\\n * number of votes cast during the voting period, not taking into account those who did not bother\\r\\n * to vote.\\r\\n */\\r\\n\\r\\ncontract DraggableShares is ERC20Recoverable, ERC20Draggable {\\r\\n\\r\\n    string public terms;\\r\\n\\r\\n    constructor(string memory _terms, address wrappedToken, uint256 quorumBps, uint256 votePeriodSeconds)\\r\\n        ERC20Draggable(wrappedToken, quorumBps, votePeriodSeconds) ERC20(0) {\\r\\n        terms = _terms; // to update the terms, migrate to a new contract. That way it is ensured that the terms can only be updated when the quorom agrees.\\r\\n    }\\r\\n\\r\\n    function name() public override view returns (string memory){\\r\\n        if (isBinding()){\\r\\n            return string(abi.encodePacked(wrapped.name(), \\\" SHA\\\"));\\r\\n        } else {\\r\\n            return string(abi.encodePacked(wrapped.name(), \\\" (Wrapped)\\\"));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function symbol() public override view returns (string memory){\\r\\n        // ticker should be less dynamic than name\\r\\n        return string(abi.encodePacked(wrapped.symbol(), \\\"S\\\"));\\r\\n    }\\r\\n\\r\\n    function transfer(address to, uint256 value) virtual override(ERC20Recoverable, ERC20) public returns (bool) {\\r\\n        return super.transfer(to, value);\\r\\n    }\\r\\n\\r\\n    function getClaimDeleter() public view override returns (address) {\\r\\n        return IRecoverable(address(wrapped)).getClaimDeleter();\\r\\n    }\\r\\n\\r\\n    function getCollateralRate(address collateralType) public view override returns (uint256) {\\r\\n        uint256 rate = super.getCollateralRate(collateralType);\\r\\n        if (rate \\u003e 0) {\\r\\n            return rate;\\r\\n        } else if (collateralType == address(wrapped)) {\\r\\n            return unwrapConversionFactor;\\r\\n        } else {\\r\\n            // If the wrapped contract allows for a specific collateral, we should too.\\r\\n            // If the wrapped contract is not IRecoverable, we will fail here, but would fail anyway.\\r\\n            return IRecoverable(address(wrapped)).getCollateralRate(collateralType) * unwrapConversionFactor;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) virtual override(ERC20Draggable, ERC20) internal {\\r\\n        super._beforeTokenTransfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\nabstract contract IRecoverable {\\r\\n    function getCollateralRate(address) public virtual view returns (uint256);\\r\\n    function getClaimDeleter() public virtual view returns (address);\\r\\n}\\r\\n\"},\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// Copied and adjusted from OpenZeppelin\\r\\n// Adjustments:\\r\\n// - modifications to support ERC-677\\r\\n// - removed require messages to save space\\r\\n// - removed unnecessary require statements\\r\\n// - removed GSN Context\\r\\n// - upgraded to 0.8 to drop SafeMath\\r\\n// - let name() and symbol() be implemented by subclass\\r\\n// - infinite allowance support, with 2^255 and above considered infinite\\r\\n\\r\\npragma solidity \\u003e=0.8;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./IERC677Receiver.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the `IERC20` interface.\\r\\n *\\r\\n * This implementation is agnostic to the way tokens are created. This means\\r\\n * that a supply mechanism has to be added in a derived contract using `_mint`.\\r\\n * For a generic mechanism see `ERC20Mintable`.\\r\\n *\\r\\n * *For a detailed writeup see our guide [How to implement supply\\r\\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\\r\\n *\\r\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\r\\n * of returning `false` on failure. This behavior is nonetheless conventional\\r\\n * and does not conflict with the expectations of ERC20 applications.\\r\\n *\\r\\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\\r\\n * This allows applications to reconstruct the allowance for all accounts just\\r\\n * by listening to said events. Other implementations of the EIP may not emit\\r\\n * these events, as it isn\\u0027t required by the specification.\\r\\n *\\r\\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\\r\\n * functions have been added to mitigate the well-known issues around setting\\r\\n * allowances. See `IERC20.approve`.\\r\\n */\\r\\n\\r\\nabstract contract ERC20 is IERC20 {\\r\\n\\r\\n    mapping (address =\\u003e uint256) private _balances;\\r\\n\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    uint8 public override decimals;\\r\\n\\r\\n    constructor(uint8 _decimals) {\\r\\n        decimals = _decimals;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.totalSupply`.\\r\\n     */\\r\\n    function totalSupply() public view override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.balanceOf`.\\r\\n     */\\r\\n    function balanceOf(address account) public view override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.transfer`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.allowance`.\\r\\n     */\\r\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.approve`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 value) public override returns (bool) {\\r\\n        _approve(msg.sender, spender, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See `IERC20.transferFrom`.\\r\\n     *\\r\\n     * Emits an `Approval` event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of `ERC20`;\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - `sender` and `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `value`.\\r\\n     * - the caller must have allowance for `sender`\\u0027s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        uint256 currentAllowance = _allowances[sender][msg.sender];\\r\\n        if (currentAllowance \\u003c (1 \\u003c\\u003c 255)){\\r\\n            // Only decrease the allowance if it was not set to \\u0027infinite\\u0027\\r\\n            // Documented in /doc/infiniteallowance.md\\r\\n            _approve(sender, msg.sender, currentAllowance - amount);\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n     *\\r\\n     * This is internal function is equivalent to `transfer`, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a `Transfer` event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` cannot be the zero address.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\r\\n        require(recipient != address(0));\\r\\n\\r\\n        _beforeTokenTransfer(sender, recipient, amount);\\r\\n\\r\\n        _balances[sender] -= amount;\\r\\n        _balances[recipient] += amount;\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    // ERC-677 functionality, can be useful for swapping and wrapping tokens\\r\\n    function transferAndCall(address recipient, uint amount, bytes calldata data) public returns (bool) {\\r\\n        bool success = transfer(recipient, amount);\\r\\n        if (success){\\r\\n            success = IERC677Receiver(recipient).onTokenTransfer(msg.sender, amount, data);\\r\\n        }\\r\\n        return success;\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a `Transfer` event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address recipient, uint256 amount) internal virtual {\\r\\n        require(recipient != address(0));\\r\\n\\r\\n        _beforeTokenTransfer(address(0), recipient, amount);\\r\\n\\r\\n        _totalSupply += amount;\\r\\n        _balances[recipient] += amount;\\r\\n        emit Transfer(address(0), recipient, amount);\\r\\n    }\\r\\n\\r\\n     /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a `Transfer` event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        _totalSupply -= amount;\\r\\n        _balances[account] -= amount;\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\r\\n     *\\r\\n     * This is internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an `Approval` event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(address owner, address spender, uint256 value) internal {\\r\\n        _allowances[owner][spender] = value;\\r\\n        emit Approval(owner, spender, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\\u0027s tokens\\r\\n     * will be to transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``\\u0027s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) virtual internal {\\r\\n    }\\r\\n}\"},\"ERC20Draggable.sol\":{\"content\":\"/**\\r\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\r\\n*\\r\\n* MIT License with Automated License Fee Payments\\r\\n*\\r\\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\\r\\n*\\r\\n* Permission is hereby granted to any person obtaining a copy of this software\\r\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\r\\n* without restriction, including without limitation the rights to use, copy,\\r\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\r\\n* Software, and to permit persons to whom the Software is furnished to do so,\\r\\n* subject to the following conditions:\\r\\n*\\r\\n* - The above copyright notice and this permission notice shall be included in\\r\\n*   all copies or substantial portions of the Software.\\r\\n* - All automated license fee payments integrated into this and related Software\\r\\n*   are preserved.\\r\\n*\\r\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\r\\n* SOFTWARE.\\r\\n*/\\r\\npragma solidity \\u003e=0.8;\\r\\n\\r\\n/**\\r\\n * @title CompanyName Shareholder Agreement\\r\\n * @author Luzius Meisser, luzius@aktionariat.com\\r\\n * @dev These tokens are based on the ERC20 standard and the open-zeppelin library.\\r\\n *\\r\\n * This is an ERC-20 token representing shares of CompanyName AG that are bound to\\r\\n * a shareholder agreement that can be found at the URL defined in the constant \\u0027terms\\u0027\\r\\n * of the \\u0027DraggableCompanyNameShares\\u0027 contract. The agreement is partially enforced\\r\\n * through the Swiss legal system, and partially enforced through this smart contract.\\r\\n * In particular, this smart contract implements a drag-along clause which allows the\\r\\n * majority of token holders to force the minority sell their shares along with them in\\r\\n * case of an acquisition. That\\u0027s why the tokens are called \\\"Draggable CompanyName AG Shares.\\\"\\r\\n */\\r\\n\\r\\nimport \\\"./ERC20.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./IERC677Receiver.sol\\\";\\r\\n\\r\\nabstract contract ERC20Draggable is ERC20, IERC677Receiver {\\r\\n\\r\\n    IERC20 public wrapped;                              // The wrapped contract\\r\\n    IOfferFactory public constant factory = IOfferFactory(0xf9f92751F272f0872e2EDb6a280b0990F3e2b8A3);\\r\\n\\r\\n    uint256 private constant MIGRATION_QUORUM = 7500;\\r\\n\\r\\n    // If the wrapped tokens got replaced in an acquisition, unwrapping might yield many currency tokens\\r\\n    uint256 public unwrapConversionFactor = 0;\\r\\n\\r\\n    // The current acquisition attempt, if any. See initiateAcquisition to see the requirements to make a public offer.\\r\\n    IOffer public offer;\\r\\n\\r\\n    uint256 public quorum; // BPS (out of 10\\u0027000)\\r\\n    uint256 public votePeriod; // Seconds\\r\\n\\r\\n    event MigrationSucceeded(address newContractAddress);\\r\\n\\r\\n    constructor(\\r\\n        address wrappedToken,\\r\\n        uint256 quorum_,\\r\\n        uint256 votePeriod_\\r\\n    ) {\\r\\n        wrapped = IERC20(wrappedToken);\\r\\n        quorum = quorum_;\\r\\n        votePeriod = votePeriod_;\\r\\n    }\\r\\n\\r\\n    function disableRecovery() public {\\r\\n        IRecoveryDisabler(address(wrapped)).setRecoverable(false);\\r\\n    }\\r\\n\\r\\n    function onTokenTransfer(address from, uint256 amount, bytes calldata) override public returns (bool) {\\r\\n        require(msg.sender == address(wrapped));\\r\\n        _mint(from, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /** Increases the number of drag-along tokens. Requires minter to deposit an equal amount of share tokens */\\r\\n    function wrap(address shareholder, uint256 amount) public {\\r\\n        require(wrapped.transferFrom(msg.sender, address(this), amount));\\r\\n        _mint(shareholder, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Indicates that the token holders are bound to the token terms and that:\\r\\n     * - Conversions back to the wrapped token (unwrap) are not allowed\\r\\n     * - The drag-along can be performed by making an according offer\\r\\n     * - They can be migrated to a new version of this contract in accordance with the terms\\r\\n     */\\r\\n    function isBinding() public view returns (bool) {\\r\\n        return unwrapConversionFactor == 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Deactivates the drag-along mechanism and enables the unwrap function.\\r\\n     */\\r\\n    function deactivate(uint256 factor) internal {\\r\\n        require(factor \\u003e= 1, \\\"factor\\\");\\r\\n        unwrapConversionFactor = factor;\\r\\n    }\\r\\n\\r\\n    /** Decrease the number of drag-along tokens. The user gets back their shares in return */\\r\\n    function unwrap(uint256 amount) public {\\r\\n        require(!isBinding());\\r\\n        unwrap(msg.sender, amount, unwrapConversionFactor);\\r\\n    }\\r\\n    \\r\\n    function unwrap(address owner, uint256 amount, uint256 factor) internal {\\r\\n        _burn(owner, amount);\\r\\n        require(wrapped.transfer(owner, amount * factor));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Burns both the token itself as well as the wrapped token!\\r\\n     * If you want to get out of the shareholder agreement, use unwrap after it has been\\r\\n     * deactivated by a majority vote or acquisition.\\r\\n     *\\r\\n     * Burning only works if wrapped token supports burning. Also, the exact meaning of this\\r\\n     * operation might depend on the circumstances. Burning and reussing the wrapped token\\r\\n     * does not free the sender from the legal obligations of the shareholder agreement.\\r\\n     */\\r\\n    function burn(uint256 amount) public {\\r\\n        _burn(msg.sender, amount);\\r\\n        uint256 factor = isBinding() ? 1 : unwrapConversionFactor;\\r\\n        IBurnable(address(wrapped)).burn(amount * factor);\\r\\n    }\\r\\n\\r\\n    event TimeStamp(uint256 time); // TEMP\\r\\n\\r\\n    function makeAcquisitionOffer(bytes32 salt, uint256 pricePerShare, address currency) public payable {\\r\\n        require(isBinding());\\r\\n        emit TimeStamp(block.timestamp);\\r\\n        address newOffer = factory.create{value: msg.value}(salt, msg.sender, pricePerShare, currency, quorum, votePeriod);\\r\\n        if (offerExists()) {\\r\\n            require(IOffer(newOffer).isWellFunded());\\r\\n            offer.contest(newOffer);\\r\\n        }\\r\\n        offer = IOffer(newOffer);\\r\\n    }\\r\\n\\r\\n    function drag(address buyer, address currency) public {\\r\\n        require(msg.sender == address(offer));\\r\\n        unwrap(buyer, balanceOf(buyer), 1);\\r\\n        replaceWrapped(currency, buyer);\\r\\n    }\\r\\n\\r\\n    function notifyOfferEnded() public {\\r\\n        if (msg.sender == address(offer)){\\r\\n            offer = IOffer(address(0));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function replaceWrapped(address newWrapped, address oldWrappedDestination) internal {\\r\\n        require(isBinding());\\r\\n        // Free all old wrapped tokens we have\\r\\n        require(wrapped.transfer(oldWrappedDestination, wrapped.balanceOf(address(this))));\\r\\n        // Count the new wrapped tokens\\r\\n        wrapped = IERC20(newWrapped);\\r\\n        deactivate(wrapped.balanceOf(address(this)) / totalSupply());\\r\\n    }\\r\\n\\r\\n    function migrate() public {\\r\\n        address successor = msg.sender;\\r\\n        require(!offerExists()); // if you have 75%, you can easily cancel the offer first if necessary\\r\\n        require(balanceOf(successor) * 10000 \\u003e= totalSupply() * MIGRATION_QUORUM, \\\"quorum\\\");\\r\\n        replaceWrapped(successor, successor);\\r\\n        emit MigrationSucceeded(successor);\\r\\n    }\\r\\n\\r\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) virtual override internal {\\r\\n        if (offerExists()) {\\r\\n            offer.notifyMoved(from, to, amount);\\r\\n        }\\r\\n        super._beforeTokenTransfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    function offerExists() internal view returns (bool) {\\r\\n        return address(offer) != address(0);\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\nabstract contract IRecoveryDisabler {\\r\\n    function setRecoverable(bool enabled) public virtual;\\r\\n}\\r\\n\\r\\nabstract contract IBurnable {\\r\\n    function burn(uint256) virtual public;\\r\\n}\\r\\n\\r\\nabstract contract IOffer {\\r\\n    function isWellFunded() virtual public returns (bool);\\r\\n    function contest(address newOffer) virtual public;\\r\\n    function notifyMoved(address from, address to, uint256 value) virtual public;\\r\\n}\\r\\n\\r\\nabstract contract IOfferFactory {\\r\\n    function create(bytes32 salt, address buyer, uint256 pricePerShare, address currency, uint256 quorum, uint256 votePeriod) virtual public payable returns (address);\\r\\n}\"},\"ERC20Recoverable.sol\":{\"content\":\"/**\\r\\n* SPDX-License-Identifier: LicenseRef-Aktionariat\\r\\n*\\r\\n* MIT License with Automated License Fee Payments\\r\\n*\\r\\n* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\\r\\n*\\r\\n* Permission is hereby granted to any person obtaining a copy of this software\\r\\n* and associated documentation files (the \\\"Software\\\"), to deal in the Software\\r\\n* without restriction, including without limitation the rights to use, copy,\\r\\n* modify, merge, publish, distribute, sublicense, and/or sell copies of the\\r\\n* Software, and to permit persons to whom the Software is furnished to do so,\\r\\n* subject to the following conditions:\\r\\n*\\r\\n* - The above copyright notice and this permission notice shall be included in\\r\\n*   all copies or substantial portions of the Software.\\r\\n* - All automated license fee payments integrated into this and related Software\\r\\n*   are preserved.\\r\\n*\\r\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\r\\n* SOFTWARE.\\r\\n*/\\r\\npragma solidity \\u003e=0.8;\\r\\n\\r\\nimport \\\"./ERC20.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Recoverable\\r\\n * In case of tokens that represent real-world assets such as shares of a company, one needs a way\\r\\n * to handle lost private keys. With physical certificates, courts can declare share certificates as\\r\\n * invalid so the company can issue replacements. Here, we want a solution that does not depend on\\r\\n * third parties to resolve such cases. Instead, when someone has lost a private key, he can use the\\r\\n * declareLost function to post a deposit and claim that the shares assigned to a specific address are\\r\\n * lost. To prevent front running, a commit reveal scheme is used. If he actually is the owner of the shares,\\r\\n * he needs to wait for a certain period and can then reclaim the lost shares as well as the deposit.\\r\\n * If he is an attacker trying to claim shares belonging to someone else, he risks losing the deposit\\r\\n * as it can be claimed at anytime by the rightful owner.\\r\\n * Furthermore, if \\\"getClaimDeleter\\\" is defined in the subclass, the returned address is allowed to\\r\\n * delete claims, returning the collateral. This can help to prevent obvious cases of abuse of the claim\\r\\n * function.\\r\\n */\\r\\n\\r\\nabstract contract ERC20Recoverable is ERC20 {\\r\\n\\r\\n    // A struct that represents a claim made\\r\\n    struct Claim {\\r\\n        address claimant; // the person who created the claim\\r\\n        uint256 collateral; // the amount of collateral deposited\\r\\n        uint256 timestamp;  // the timestamp of the block in which the claim was made\\r\\n        address currencyUsed; // The currency (XCHF) can be updated, we record the currency used for every request\\r\\n    }\\r\\n\\r\\n    uint256 public constant claimPeriod = 180 days;\\r\\n\\r\\n    mapping(address =\\u003e Claim) public claims; // there can be at most one claim per address, here address is claimed address\\r\\n    mapping(address =\\u003e bool) public recoveryDisabled; // disable claimability (e.g. for long term storage)\\r\\n\\r\\n    // ERC-20 token that can be used as collateral or 0x0 if disabled\\r\\n    address public customCollateralAddress;\\r\\n    uint256 public customCollateralRate;\\r\\n\\r\\n    /**\\r\\n     * Returns the collateral rate for the given collateral type and 0 if that type\\r\\n     * of collateral is not accepted. By default, only the token itself is accepted at\\r\\n     * a rate of 1:1.\\r\\n     *\\r\\n     * Subclasses should override this method if they want to add additional types of\\r\\n     * collateral.\\r\\n     */\\r\\n    function getCollateralRate(address collateralType) public virtual view returns (uint256) {\\r\\n        if (collateralType == address(this)) {\\r\\n            return 1;\\r\\n        } else if (collateralType == customCollateralAddress) {\\r\\n            return customCollateralRate;\\r\\n        } else {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Allows subclasses to set a custom collateral besides the token itself.\\r\\n     * The collateral must be an ERC-20 token that returns true on successful transfers and\\r\\n     * throws an exception or returns false on failure.\\r\\n     * Also, do not forget to multiply the rate in accordance with the number of decimals of the collateral.\\r\\n     * For example, rate should be 7*10**18 for 7 units of a collateral with 18 decimals.\\r\\n     */\\r\\n    function _setCustomClaimCollateral(address collateral, uint256 rate) internal {\\r\\n        customCollateralAddress = collateral;\\r\\n        if (customCollateralAddress == address(0)) {\\r\\n            customCollateralRate = 0; // disabled\\r\\n        } else {\\r\\n            require(rate \\u003e 0, \\\"zero\\\");\\r\\n            customCollateralRate = rate;\\r\\n        }\\r\\n        emit CustomClaimCollateralChanged(collateral, rate);\\r\\n    }\\r\\n\\r\\n    function getClaimDeleter() virtual public view returns (address);\\r\\n\\r\\n    function setRecoverable(bool enabled) public {\\r\\n        recoveryDisabled[msg.sender] = !enabled;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Some users might want to disable claims for their address completely.\\r\\n     * For example if they use a deep cold storage solution or paper wallet.\\r\\n     */\\r\\n    function isRecoveryEnabled(address target) public view returns (bool) {\\r\\n        return !recoveryDisabled[target];\\r\\n    }\\r\\n\\r\\n    event ClaimMade(address indexed lostAddress, address indexed claimant, uint256 balance);\\r\\n    event ClaimCleared(address indexed lostAddress, uint256 collateral);\\r\\n    event ClaimDeleted(address indexed lostAddress, address indexed claimant, uint256 collateral);\\r\\n    event ClaimResolved(address indexed lostAddress, address indexed claimant, uint256 collateral);\\r\\n    event CustomClaimCollateralChanged(address newCustomCollateralAddress, uint256 newCustomCollareralRate);\\r\\n\\r\\n  /** Anyone can declare that the private key to a certain address was lost by calling declareLost\\r\\n    * providing a deposit/collateral. There are three possibilities of what can happen with the claim:\\r\\n    * 1) The claim period expires and the claimant can get the deposit and the shares back by calling recover\\r\\n    * 2) The \\\"lost\\\" private key is used at any time to call clearClaim. In that case, the claim is deleted and\\r\\n    *    the deposit sent to the shareholder (the owner of the private key). It is recommended to call recover\\r\\n    *    whenever someone transfers funds to let claims be resolved automatically when the \\\"lost\\\" private key is\\r\\n    *    used again.\\r\\n    * 3) The owner deletes the claim and assigns the deposit to the claimant. This is intended to be used to resolve\\r\\n    *    disputes. Generally, using this function implies that you have to trust the issuer of the tokens to handle\\r\\n    *    the situation well. As a rule of thumb, the contract owner should assume the owner of the lost address to be the\\r\\n    *    rightful owner of the deposit.\\r\\n    * It is highly recommended that the owner observes the claims made and informs the owners of the claimed addresses\\r\\n    * whenever a claim is made for their address (this of course is only possible if they are known to the owner, e.g.\\r\\n    * through a shareholder register).\\r\\n    */\\r\\n    function declareLost(address collateralType, address lostAddress) public {\\r\\n        require(isRecoveryEnabled(lostAddress), \\\"disabled\\\");\\r\\n        uint256 collateralRate = getCollateralRate(collateralType);\\r\\n        require(collateralRate \\u003e 0, \\\"bad collateral\\\");\\r\\n        address claimant = msg.sender;\\r\\n        uint256 balance = balanceOf(lostAddress);\\r\\n        uint256 collateral = balance * collateralRate;\\r\\n        IERC20 currency = IERC20(collateralType);\\r\\n        require(balance \\u003e 0, \\\"empty\\\");\\r\\n        require(claims[lostAddress].collateral == 0, \\\"already claimed\\\");\\r\\n        require(currency.transferFrom(claimant, address(this), collateral));\\r\\n\\r\\n        claims[lostAddress] = Claim({\\r\\n            claimant: claimant,\\r\\n            collateral: collateral,\\r\\n            timestamp: block.timestamp,\\r\\n            currencyUsed: collateralType\\r\\n        });\\r\\n\\r\\n        emit ClaimMade(lostAddress, claimant, balance);\\r\\n    }\\r\\n\\r\\n    function getClaimant(address lostAddress) public view returns (address) {\\r\\n        return claims[lostAddress].claimant;\\r\\n    }\\r\\n\\r\\n    function getCollateral(address lostAddress) public view returns (uint256) {\\r\\n        return claims[lostAddress].collateral;\\r\\n    }\\r\\n\\r\\n    function getCollateralType(address lostAddress) public view returns (address) {\\r\\n        return claims[lostAddress].currencyUsed;\\r\\n    }\\r\\n\\r\\n    function getTimeStamp(address lostAddress) public view returns (uint256) {\\r\\n        return claims[lostAddress].timestamp;\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) override virtual public returns (bool) {\\r\\n        require(super.transfer(recipient, amount));\\r\\n        clearClaim();\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Clears a claim after the key has been found again and assigns the collateral to the \\\"lost\\\" address.\\r\\n     * This is the price an adverse claimer pays for filing a false claim and makes it risky to do so.\\r\\n     */\\r\\n    function clearClaim() public {\\r\\n        if (claims[msg.sender].collateral != 0) {\\r\\n            uint256 collateral = claims[msg.sender].collateral;\\r\\n            IERC20 currency = IERC20(claims[msg.sender].currencyUsed);\\r\\n            delete claims[msg.sender];\\r\\n            require(currency.transfer(msg.sender, collateral));\\r\\n            emit ClaimCleared(msg.sender, collateral);\\r\\n        }\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * After the claim period has passed, the claimant can call this function to send the\\r\\n    * tokens on the lost address as well as the collateral to himself.\\r\\n    */\\r\\n    function recover(address lostAddress) public {\\r\\n        Claim memory claim = claims[lostAddress];\\r\\n        uint256 collateral = claim.collateral;\\r\\n        IERC20 currency = IERC20(claim.currencyUsed);\\r\\n        require(collateral != 0, \\\"not found\\\");\\r\\n        require(claim.claimant == msg.sender, \\\"not claimant\\\");\\r\\n        require(claim.timestamp + claimPeriod \\u003c= block.timestamp, \\\"too early\\\");\\r\\n        address claimant = claim.claimant;\\r\\n        delete claims[lostAddress];\\r\\n        require(currency.transfer(claimant, collateral));\\r\\n        _transfer(lostAddress, claimant, balanceOf(lostAddress));\\r\\n        emit ClaimResolved(lostAddress, claimant, collateral);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * This function is to be executed by the claim deleter only in case a dispute needs to be resolved manually.\\r\\n     */\\r\\n    function deleteClaim(address lostAddress) public {\\r\\n        require(msg.sender == getClaimDeleter(), \\\"no access\\\");\\r\\n        Claim memory claim = claims[lostAddress];\\r\\n        IERC20 currency = IERC20(claim.currencyUsed);\\r\\n        require(claim.collateral != 0, \\\"not found\\\");\\r\\n        delete claims[lostAddress];\\r\\n        require(currency.transfer(claim.claimant, claim.collateral));\\r\\n        emit ClaimDeleted(lostAddress, claim.claimant, claim.collateral);\\r\\n    }\\r\\n\\r\\n}\"},\"IERC20.sol\":{\"content\":\"/**\\r\\n* SPDX-License-Identifier: MIT\\r\\n*\\r\\n* Copyright (c) 2016-2019 zOS Global Limited\\r\\n*\\r\\n*/\\r\\npragma solidity \\u003e=0.8;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\r\\n * the optional functions; to access them see `ERC20Detailed`.\\r\\n */\\r\\n\\r\\ninterface IERC20 {\\r\\n\\r\\n    // Optional functions\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a `Transfer` event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when `approve` or `transferFrom` are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * \\u003e Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an `Approval` event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a `Transfer` event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to `approve`. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"},\"IERC677Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.8;\\r\\n\\r\\ninterface IERC677Receiver {\\r\\n    \\r\\n    function onTokenTransfer(address from, uint256 amount, bytes calldata data) external returns (bool);\\r\\n\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_terms\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quorumBps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votePeriodSeconds\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"}],\"name\":\"ClaimCleared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"}],\"name\":\"ClaimDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"ClaimMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"}],\"name\":\"ClaimResolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newCustomCollateralAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCustomCollareralRate\",\"type\":\"uint256\"}],\"name\":\"CustomClaimCollateralChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newContractAddress\",\"type\":\"address\"}],\"name\":\"MigrationSucceeded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"TimeStamp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claims\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currencyUsed\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"customCollateralAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"customCollateralRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"declareLost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"deleteClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableRecovery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"drag\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract IOfferFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClaimDeleter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"getClaimant\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"getCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateralType\",\"type\":\"address\"}],\"name\":\"getCollateralRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"getCollateralType\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"getTimeStamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isBinding\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"isRecoveryEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"pricePerShare\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"}],\"name\":\"makeAcquisitionOffer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notifyOfferEnded\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offer\",\"outputs\":[{\"internalType\":\"contract IOffer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quorum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostAddress\",\"type\":\"address\"}],\"name\":\"recover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"recoveryDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setRecoverable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"terms\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unwrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unwrapConversionFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"shareholder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"wrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrapped\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DraggableShares", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000800000000000000000000000002e804bcbe5c62db26629b9c7c0664884e534fd9b0000000000000000000000000000000000000000000000000000000000001d4c00000000000000000000000000000000000000000000000000000000004f1a000000000000000000000000000000000000000000000000000000000000000016696e766573746f72732e74626f2e636c6f7468696e6700000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8e231b5659b35992a4ec63c3650ed1b0fcd59f99c90d62e1e969736b8d14d979"}