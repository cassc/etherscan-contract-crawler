{"SourceCode": "contract X3 {\r\n\r\n        struct Participant {\r\n                address etherAddress;\r\n                uint amount;\r\n        }\r\n\r\n        Participant[] public participants;\r\n\r\n        uint public payoutIdx = 0;\r\n        uint public collectedFees;\r\n        uint public balance = 0;\r\n\r\n        address public owner;\r\n\r\n        // simple single-sig function modifier\r\n        modifier onlyowner {\r\n                if (msg.sender == owner) _\r\n        }\r\n\r\n        // this function is executed at initialization and sets the owner of the contract\r\n        function X3() {\r\n                owner = msg.sender;\r\n        }\r\n\r\n        // fallback function - simple transactions trigger this\r\n        function() {\r\n                enter();\r\n        }\r\n\r\n        function enter() {\r\n                if (msg.value < 1 ether) {\r\n                        msg.sender.send(msg.value);\r\n                        return;\r\n                }\r\n\r\n                // add a new participant to array\r\n                uint idx = participants.length;\r\n                participants.length += 1;\r\n                participants[idx].etherAddress = msg.sender;\r\n                participants[idx].amount = msg.value;\r\n\r\n                // collect fees and update contract balance\r\n                if (idx != 0) {\r\n                        collectedFees += msg.value / 3;\r\n                        balance += msg.value;\r\n                } else {\r\n                        // first participant has no one above him,\r\n                        // so it goes all to fees\r\n                        collectedFees += msg.value;\r\n                }\r\n\r\n                // if there are enough ether on the balance X3 will payout three time your initial investement\r\n                if (balance > participants[payoutIdx].amount * 3) {\r\n                        uint transactionAmount = 3 * (participants[payoutIdx].amount - participants[payoutIdx].amount / 3);\r\n                        participants[payoutIdx].etherAddress.send(transactionAmount);\r\n\r\n                        balance -= participants[payoutIdx].amount * 3;\r\n                        payoutIdx += 1;\r\n                }\r\n        }\r\n\r\n        function collectFees() onlyowner {\r\n                if (collectedFees == 0) return;\r\n\r\n                owner.send(collectedFees);\r\n                collectedFees = 0;\r\n        }\r\n\r\n        function setOwner(address _owner) onlyowner {\r\n                owner = _owner;\r\n        }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"participants\",\"outputs\":[{\"name\":\"etherAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collectedFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payoutIdx\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collectFees\",\"outputs\":[],\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enter\",\"outputs\":[],\"type\":\"function\"},{\"inputs\":[],\"type\":\"constructor\"}]", "ContractName": "X3", "CompilerVersion": "v0.2.1-2016-01-30-91a6b35", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}