{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.18;\r\n\r\nlibrary CastMath {\r\n    function int256Cast(uint256 a) internal pure returns (int256) {\r\n        int256 b = int256(a);\r\n        require(b >= 0, \"unsafe int256 cast\");\r\n        return b;\r\n    }\r\n\r\n    function uint256Cast(int256 a) internal pure returns (uint256) {\r\n        require(a >= 0, \"unsafe uint256 cast\");\r\n        return uint256(a);\r\n    }\r\n}\r\n\r\ninterface UniSwap {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract DividendContract {\r\n\r\n    uint256 constant internal MAGNITUDE = 2**128;\r\n    uint256 internal magnifiedDividendPerShare;\r\n                                                                         \r\n    mapping(address => int256) internal magnifiedDividendCorrections;\r\n    mapping(address => uint256) internal withdrawnDividends;\r\n    mapping(address => uint256) public holderBalance;\r\n \r\n    uint256 public totalDividends;\r\n    uint256 public totalBloxDividendsDistributed;\r\n\r\n    event DividendsDistributed(address indexed from, uint256 amount);\r\n    event DividendWithdrawn(address indexed to, uint256 amount);\r\n\r\n    function withdrawnDividendOf(address user) external view returns(uint256) {\r\n        return withdrawnDividends[user];\r\n    }\r\n\r\n    function dividendOf(address user) public view returns(uint256) {\r\n        return accumulativeDividendOf(user) - withdrawnDividends[user];\r\n    }\r\n\r\n    function accumulativeDividendOf(address user) public view returns(uint256) {\r\n        int256 magnifiedBalance = CastMath.int256Cast(magnifiedDividendPerShare * holderBalance[user]);\r\n        uint256 correctedBalance = CastMath.uint256Cast(magnifiedBalance + magnifiedDividendCorrections[user]);\r\n        return correctedBalance / MAGNITUDE;\r\n    }\r\n\r\n    function _distributeDividends(uint amount) internal {\r\n        require(totalDividends > 0, \"Nobody to distribute to\");\r\n        magnifiedDividendPerShare += (amount * MAGNITUDE) / totalDividends;\r\n        emit DividendsDistributed(msg.sender, amount);\r\n        totalBloxDividendsDistributed += amount;\r\n    }\r\n\r\n    function _withdrawDividendOfUser(address payable user) internal  {\r\n        uint256 _withdrawableDividend = dividendOf(user);\r\n        if (_withdrawableDividend == 0) {return;} \r\n        withdrawnDividends[user] += _withdrawableDividend;\r\n        (bool success,) = user.call{value: _withdrawableDividend}(\"\");\r\n        if (!success) {\r\n            withdrawnDividends[user] -= _withdrawableDividend; //undo withdraw\r\n            return;\r\n        }\r\n        emit DividendWithdrawn(user, _withdrawableDividend);\r\n   } \r\n\r\n  function _updateBalance(address user, uint256 newBalance) internal {\r\n    uint256 currentBalance = holderBalance[user];\r\n    holderBalance[user] = newBalance;\r\n    if (newBalance > currentBalance) {\r\n        uint256 increaseAmount = newBalance - currentBalance;\r\n        magnifiedDividendCorrections[user] -= CastMath.int256Cast(magnifiedDividendPerShare * increaseAmount);\r\n        totalDividends += increaseAmount;\r\n    } else if (newBalance < currentBalance) {\r\n        uint256 reduceAmount = currentBalance - newBalance;\r\n        magnifiedDividendCorrections[user] += CastMath.int256Cast(magnifiedDividendPerShare * reduceAmount);\r\n        totalDividends -= reduceAmount;\r\n    }\r\n   }\r\n\r\n    function _updateAccountBalance(address payable user, uint256 newBalance) internal {\r\n        _updateBalance(user, newBalance);\r\n    \t_withdrawDividendOfUser(user); // auto-send dividends when balance changes (i.e. unstake)\r\n    }\r\n}\r\n\r\ncontract BloxStaking is DividendContract, ReentrancyGuard {\r\n\r\n    IERC20 public immutable bloxToken;\r\n    UniSwap private immutable dexRouter;\r\n\r\n    mapping (address => uint256) public holderUnlockTime;\r\n    mapping(address => uint256) internal stakeBlock;\r\n    uint256 public immutable lockDuration;\r\n\r\n    event Stake(address indexed user, uint256 amount);\r\n    event Unstake(address indexed user, uint256 amount);\r\n\r\n    constructor(address token, uint256 lockDays) { \r\n        bloxToken = IERC20(token);\r\n        lockDuration = lockDays * 1 days;\r\n        dexRouter = UniSwap(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n    }\r\n\r\n    receive() external payable {\r\n        revShare();\r\n    }\r\n\r\n    function stakeBlox(uint256 amount) external nonReentrant {\r\n        require(amount > 0, \"Amount cannot be 0\");\r\n        if(holderUnlockTime[msg.sender] == 0) {\r\n            holderUnlockTime[msg.sender] = block.timestamp + lockDuration;\r\n        }\r\n        stakeBlock[msg.sender] = block.timestamp;\r\n        uint256 userAmount = holderBalance[msg.sender];\r\n        uint256 balanceBefore = bloxToken.balanceOf(address(this));\r\n        bloxToken.transferFrom(address(msg.sender), address(this), amount);\r\n        uint256 bought = bloxToken.balanceOf(address(this)) - balanceBefore;\r\n        _updateAccountBalance(payable(msg.sender), userAmount + bought);\r\n        emit Stake(msg.sender, amount);\r\n    }\r\n\r\n    function revShare() public payable {\r\n        require(msg.value > 0, \"No ETH sent\");\r\n        _distributeDividends(msg.value);\r\n    }\r\n\r\n    function unstakeBlox(uint256 amount) public nonReentrant  {\r\n        require(amount > 0, \"Cannot withdraw 0 tokens\");\r\n        require(holderUnlockTime[msg.sender] <= block.timestamp, \"Cannot withdraw yet\");\r\n        require(stakeBlock[msg.sender] + 1 hours < block.timestamp, \"Attack block\");\r\n        uint256 userDividends = holderBalance[msg.sender];\r\n        require(amount <= userDividends, \"Not enough Blox tokens\");\r\n        _updateAccountBalance(payable(msg.sender), userDividends - amount);\r\n        // Everything unstaked = reset stamp to 0, else extend lock\r\n        holderUnlockTime[msg.sender] = userDividends == amount ? 0 : block.timestamp + lockDuration;\r\n        bool success = bloxToken.transfer(address(msg.sender), amount);\r\n        require(success, \"Transfer of Blox failed\");\r\n        emit Unstake(msg.sender, amount);\r\n    }\r\n\r\n    function unstakeAllBlox() external   { \r\n        uint256 totalTokens = holderBalance[msg.sender];\r\n        unstakeBlox(totalTokens);\r\n    }\r\n\r\n    function buyBloxTokens(uint256 weiAmount, uint256 minOut) internal returns(uint256) {\r\n        uint256 initialBalance = bloxToken.balanceOf(address(this));\r\n        address[] memory path = new address[](2);\r\n        path[0] = dexRouter.WETH();\r\n        path[1] = address(bloxToken);\r\n        dexRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: weiAmount}(\r\n            minOut,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        return bloxToken.balanceOf(address(this)) - initialBalance;\r\n    }\r\n\r\n    function claimRewards() external nonReentrant { \r\n        _withdrawDividendOfUser(payable(msg.sender));\r\n    }\r\n\r\n    function compoundBlox(uint256 minOutput) external nonReentrant {\r\n        // Check how much dividend ETH we have\r\n        uint256 accountBalance = holderBalance[msg.sender];\r\n        uint256 dividendETH = dividendOf(msg.sender);\r\n        require(dividendETH > 0, \"Nothing to compound\");\r\n        withdrawnDividends[msg.sender] += dividendETH; // We use the ETH for buyback\r\n        emit DividendWithdrawn(msg.sender, dividendETH);\r\n        // Use dividend ETH to buy Blox tokens\r\n        uint BloxBought = buyBloxTokens(dividendETH, minOutput); \r\n        // Update balance\r\n        _updateAccountBalance(payable(msg.sender), accountBalance + BloxBought);\r\n    }\r\n\r\n    function getCompoundTokensForWallet(address wallet) external view returns(uint256) {\r\n        uint256 dividendETH = dividendOf(wallet);\r\n        require(dividendETH > 0, \"Nothing to compound\");\r\n        address[] memory path = new address[](2);\r\n        path[0] = dexRouter.WETH();\r\n        path[1] = address(bloxToken);\r\n        // Get the tokens we can buy for the given ETH\r\n        return dexRouter.getAmountsOut(dividendETH, path)[1]; \r\n    }\r\n\r\n }", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockDays\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DividendWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DividendsDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"accumulativeDividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bloxToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minOutput\",\"type\":\"uint256\"}],\"name\":\"compoundBlox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"dividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getCompoundTokensForWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"holderBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"holderUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revShare\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeBlox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBloxDividendsDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeAllBlox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstakeBlox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"withdrawnDividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BloxStaking", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "999", "ConstructorArguments": "000000000000000000000000320ed4c7243e35a00f9ca30a1ae60929d15eae37000000000000000000000000000000000000000000000000000000000000000e", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c80c3f6ffb5d8c478d75356f3ddd0ea1978c5836ab796ad0f53f62ca9269ba57"}