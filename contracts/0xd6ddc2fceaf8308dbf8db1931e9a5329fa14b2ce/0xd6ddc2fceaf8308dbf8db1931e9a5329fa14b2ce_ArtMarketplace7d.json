{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"remappings\": []\r\n  },\r\n  \"sources\": {\r\n    \"marketplacev3/marketplace7d.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport \\\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.3/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"./libs/SafeTransferLib.sol\\\";\\nimport \\\"./libs/TopKHeap.sol\\\";\\n\\ncontract ArtMarketplace7d is Ownable {\\n  using TopKHeap for TopKHeap.Heap;\\n  uint256 private constant BPS = 10_000;\\n  uint256 private constant BID_INCREASE_THRESHOLD = 0.2 ether;\\n  uint256 private constant DEFAULT_SPLIT = 7_500;\\n  uint256 private constant EXTENSION_TIME = 10 minutes;\\n  uint256 private constant INIT_AUCTION_DURATION = 24 hours;\\n  uint256 private constant MIN_BID = 0.1 ether;\\n  uint256 private constant MIN_BID_INCREASE_PRE = 2_000;\\n  uint256 private constant MIN_BID_INCREASE_POST = 1_000;\\n  uint256 private constant SAFE_GAS_LIMIT = 30_000;\\n  uint256 private constant RANK_AUCTION_SIZE = 50;\\n  IERC721 private constant CONTRACT_AD = IERC721(0x9CF0aB1cc434dB83097B7E9c831a764481DEc747);\\n  IERC721 private constant CONTRACT_FPP = IERC721(0xA8A425864dB32fCBB459Bf527BdBb8128e6abF21);\\n  address public beneficiary;\\n  bool public paused;\\n  TopKHeap.Heap public leaderboard;\\n  mapping(address => uint16) public discountsCount;\\n  uint256[] public scheduled;\\n\\n  struct Auction {\\n    uint24 offsetFromEnd;\\n    uint72 amount;\\n    address bidder;\\n  }\\n\\n  struct AuctionConfig {\\n    address artist;\\n    uint16 split;\\n    uint80 preBidStartTime;\\n    uint80 auctionStartTime;\\n    uint88 reservePrice;\\n    uint88 preBidPrice;\\n  }\\n\\n  mapping(uint256 => AuctionConfig) public auctionConfig;\\n  mapping(uint256 => Auction) public auctionIdToAuction;\\n  \\n  event BidMade(\\n    uint256 indexed auctionId,\\n    address indexed collectionAddress,\\n    uint256 indexed tokenId,\\n    address bidder,\\n    uint256 amount,\\n    uint256 timestamp\\n  );\\n\\n  event Settled(\\n    uint256 indexed auctionId,\\n    address indexed collectionAddress,\\n    uint256 indexed tokenId,\\n    uint256 timestamp,\\n    uint256 price\\n  );\\n\\n  constructor() {\\n    leaderboard.initialize(RANK_AUCTION_SIZE);\\n  }\\n\\n  function bid(\\n    uint256 auctionId\\n  ) external payable {\\n    require(!paused, 'Bidding is paused');\\n\\n    if (auctionConfig[auctionId].auctionStartTime == type(uint80).max) {\\n      auctionConfig[auctionId].auctionStartTime = uint80(block.timestamp);\\n    }\\n\\n    uint256 preBidPrice = auctionConfig[auctionId].preBidPrice;\\n\\n    require(\\n      (\\n        (isAuctionActive(auctionId) && leaderboard.isInTopK(auctionId))\\n        || (\\n            block.timestamp < auctionConfig[auctionId].auctionStartTime\\n            && preBidPrice > 0 && msg.value >= preBidPrice\\n        )\\n      ) && block.timestamp >= auctionConfig[auctionId].preBidStartTime,\\n      'Auction Inactive'\\n    );\\n\\n    Auction memory highestBid = auctionIdToAuction[auctionId];\\n    uint256 bidIncrease = highestBid.amount >= BID_INCREASE_THRESHOLD\\n      ? MIN_BID_INCREASE_POST : MIN_BID_INCREASE_PRE;\\n\\n    require(\\n      msg.value >= (highestBid.amount * (BPS + bidIncrease) / BPS)\\n      && msg.value >= reservePrice(auctionId),\\n      'Bid not high enough'\\n    );\\n\\n    uint256 refundAmount;\\n    address refundBidder;\\n    uint256 offset = highestBid.offsetFromEnd;\\n    uint256 endTime = getAuctionEndTime(auctionId);\\n\\n    if (highestBid.amount > 0) {\\n      refundAmount = highestBid.amount;\\n      refundBidder = highestBid.bidder;\\n    }\\n\\n    if (endTime - block.timestamp < EXTENSION_TIME) {\\n      offset += block.timestamp + EXTENSION_TIME - endTime;\\n    }\\n\\n    auctionIdToAuction[auctionId] = Auction(uint24(offset), uint72(msg.value), msg.sender);\\n    if (!isAuctionActive(auctionId)) {\\n      leaderboard.insert(auctionId, msg.value);\\n    }\\n  \\n    emit BidMade(\\n      auctionId,\\n      getCollectionFromId(auctionId),\\n      getArtTokenIdFromId(auctionId),\\n      msg.sender,\\n      msg.value,\\n      block.timestamp\\n    );\\n\\n    if (refundAmount > 0) {\\n      SafeTransferLib.forceSafeTransferETH(refundBidder, refundAmount, SAFE_GAS_LIMIT);\\n    }\\n  }\\n\\n  function settleAuction(\\n    uint256 auctionId\\n  ) external payable {\\n    require(!paused, 'Settling is paused');\\n    require(leaderboard.isInTopK(auctionId), \\\"Auction not pre-selected.\\\");\\n    Auction memory highestBid = auctionIdToAuction[auctionId];\\n    AuctionConfig memory config = auctionConfig[auctionId];\\n    require(isAuctionOver(auctionId), 'Auction is still active');\\n\\n    uint256 amountToPay = highestBid.amount;\\n    if (amountToPay > 0) {\\n      _mint(highestBid.bidder, auctionId);\\n    } else {\\n      require(msg.value == reservePrice(auctionId), 'Incorrect funds sent for unclaimed');\\n      amountToPay = msg.value;\\n      _mint(owner(), auctionId);\\n    }\\n\\n    uint256 split = config.split;\\n    if (split == 0) {\\n      split = DEFAULT_SPLIT;\\n    }\\n\\n    uint256 tokensOwnedInContractAD = CONTRACT_AD.balanceOf(highestBid.bidder);\\n    uint256 tokensOwnedInContractFPP = CONTRACT_FPP.balanceOf(highestBid.bidder);\\n\\n    uint256 potentialDiscount = tokensOwnedInContractAD + tokensOwnedInContractFPP;\\n\\n    if (\\n      highestBid.bidder != address(0) && potentialDiscount > 0\\n      && potentialDiscount >= discountsCount[highestBid.bidder]\\n    ) {\\n      uint256 rebate =  amountToPay * 10 / 100;\\n      amountToPay = amountToPay - rebate;\\n      discountsCount[highestBid.bidder] += 1;\\n      SafeTransferLib.forceSafeTransferETH(highestBid.bidder, rebate, SAFE_GAS_LIMIT);\\n    }\\n    \\n    emit Settled(\\n      auctionId,\\n      getCollectionFromId(auctionId),\\n      getArtTokenIdFromId(auctionId),\\n      block.timestamp,\\n      amountToPay\\n    );\\n\\n    uint256 amountForArtist = amountToPay * split / 10_000;\\n    SafeTransferLib.forceSafeTransferETH(config.artist, amountForArtist, SAFE_GAS_LIMIT);\\n    SafeTransferLib.forceSafeTransferETH(beneficiary, amountToPay - amountForArtist, SAFE_GAS_LIMIT);\\n  }\\n\\n  function settleMultipleAuctions(\\n    uint256[] calldata auctionIds\\n  ) external payable {\\n    require(!paused, 'Settling is paused');\\n    uint256 unclaimedCost; uint256 amountForBene;\\n    for (uint256 i; i < auctionIds.length; ++i) {\\n      uint256 auctionId = auctionIds[i];\\n      require(leaderboard.isInTopK(auctionId), \\\"Auction not pre-selected.\\\");\\n      Auction memory highestBid = auctionIdToAuction[auctionId];\\n      require(isAuctionOver(auctionId), 'Auction is still active');\\n\\n      uint256 amountToPay = highestBid.amount;\\n      if (amountToPay > 0) {\\n        _mint(highestBid.bidder, auctionId);\\n      } else {\\n        amountToPay = reservePrice(auctionId);\\n        unclaimedCost += amountToPay;\\n        _mint(owner(), auctionId);\\n      }\\n\\n      emit Settled(\\n        auctionId,\\n        getCollectionFromId(auctionId),\\n        getArtTokenIdFromId(auctionId),\\n        block.timestamp,\\n        amountToPay\\n      );\\n\\n      AuctionConfig memory config = auctionConfig[auctionId];\\n      uint256 split = config.split;\\n      if (split == 0) {\\n        split = DEFAULT_SPLIT;\\n      }\\n      uint256 tokensOwnedInContractAD = CONTRACT_AD.balanceOf(highestBid.bidder);\\n      uint256 tokensOwnedInContractFPP = CONTRACT_FPP.balanceOf(highestBid.bidder);\\n      uint256 potentialDiscount = tokensOwnedInContractAD + tokensOwnedInContractFPP;\\n\\n      if (\\n        highestBid.bidder != address(0) && potentialDiscount > 0\\n        && potentialDiscount >= discountsCount[highestBid.bidder]\\n      ) {\\n        uint256 rebate =  amountToPay * 10 / 100;\\n        amountToPay = amountToPay - rebate;\\n        discountsCount[highestBid.bidder] += 1;\\n        SafeTransferLib.forceSafeTransferETH(highestBid.bidder, rebate, SAFE_GAS_LIMIT);\\n      }\\n      uint256 amountForArtist = amountToPay * split / 10_000;\\n      SafeTransferLib.forceSafeTransferETH(config.artist, amountForArtist, SAFE_GAS_LIMIT);\\n\\n      amountForBene += amountToPay - amountForArtist;\\n    }\\n\\n    require(msg.value == unclaimedCost, 'Incorrect funds sent for unclaimed');\\n    SafeTransferLib.forceSafeTransferETH(beneficiary, amountForBene, SAFE_GAS_LIMIT);\\n  }\\n\\n  function _mint(\\n    address to,\\n    uint256 auctionId\\n  ) internal {\\n    address collection = getCollectionFromId(auctionId);\\n    uint256 tokenId = getArtTokenIdFromId(auctionId);\\n    try INFT(collection).ownerOf(tokenId) returns (address _owner) {\\n      if (_owner == address(0)) {\\n        INFT(collection).mint(to, tokenId);\\n      } else {\\n        INFT(collection).transferFrom(_owner, to, tokenId);\\n      }\\n    } catch {\\n      INFT(collection).mint(to, tokenId);\\n    }\\n  }\\n\\n  // INTERNAL\\n  function _changePrices(\\n    address collectionAddress,\\n    uint256 tokenId,\\n    uint256 newReservePrice,\\n    uint256 newPreBidPrice\\n  ) internal {\\n    uint256 auctionId = artTokentoAuctionId(collectionAddress, tokenId);\\n    require(auctionConfig[auctionId].auctionStartTime > block.timestamp);\\n\\n    auctionConfig[auctionId].reservePrice = uint88(newReservePrice);\\n    auctionConfig[auctionId].preBidPrice = uint88(newPreBidPrice);\\n  }\\n\\n  function _changeSplit(\\n    address collectionAddress,\\n    uint256 tokenId,\\n    address artist,\\n    uint256 newSplit\\n  ) internal {\\n    uint256 auctionId = artTokentoAuctionId(collectionAddress, tokenId);\\n    if (artist != address(0)) {\\n      auctionConfig[auctionId].artist = artist;\\n    }\\n    auctionConfig[auctionId].split = uint16(newSplit);\\n  }\\n\\n  function _resetAuction(\\n    address collectionAddress,\\n    uint256 tokenId\\n  ) internal {\\n    uint256 auctionId = artTokentoAuctionId(collectionAddress, tokenId);\\n    if (!isAuctionOver(auctionId)) {\\n      Auction memory auctionData = auctionIdToAuction[auctionId];\\n      if (auctionData.amount > 0) {\\n        SafeTransferLib.forceSafeTransferETH(auctionData.bidder, auctionData.amount, SAFE_GAS_LIMIT);\\n      }\\n    }\\n    auctionConfig[auctionId] = AuctionConfig(address(0),0,0,0,0,0);\\n    auctionIdToAuction[auctionId] = Auction(0,0,address(0));\\n  }\\n\\n  function _reschedule(\\n    address collectionAddress,\\n    uint256 tokenId,\\n    uint256 newpreBidStartTime,\\n    uint256 newAuctionStartTime\\n  ) internal {\\n    uint256 auctionId = artTokentoAuctionId(collectionAddress, tokenId);\\n    require(auctionConfig[auctionId].auctionStartTime > block.timestamp);\\n    require(newpreBidStartTime <= newAuctionStartTime);\\n\\n    auctionConfig[auctionId].preBidStartTime = uint80(newpreBidStartTime);\\n    auctionConfig[auctionId].auctionStartTime = uint80(newAuctionStartTime);\\n  }\\n\\n  function _schedule(\\n    address collectionAddress,\\n    uint256 tokenId,\\n    uint256 preBidStartTime,\\n    uint256 auctionStartTime,\\n    address artist,\\n    uint256 split,\\n    uint256 reserve,\\n    uint256 preBidPrice\\n  ) internal {\\n    uint256 auctionId = artTokentoAuctionId(collectionAddress, tokenId);\\n    require(auctionConfig[auctionId].auctionStartTime == 0);\\n\\n    uint256 adjAucStartTime = auctionStartTime;\\n    if (adjAucStartTime == 0) {\\n      adjAucStartTime = type(uint80).max;\\n    }\\n    auctionConfig[auctionId] = AuctionConfig(\\n      artist,\\n      uint16(split),\\n      uint80(preBidStartTime),\\n      uint80(adjAucStartTime),\\n      uint88(reserve),\\n      uint88(preBidPrice)\\n    );\\n    scheduled.push(auctionId);\\n  }\\n\\n  // ONLY OWNER\\n\\n  function changePrices(\\n    address collectionAddress,\\n    uint256 tokenId,\\n    uint256 newReservePrice,\\n    uint256 newPreBidPrice\\n  ) external onlyOwner {\\n    _changePrices(collectionAddress, tokenId, newReservePrice, newPreBidPrice);\\n  }\\n\\n  function changePricesMultiple(\\n    address[] calldata collections,\\n    uint256[] calldata tokenIds,\\n    uint256[] calldata newReservePrices,\\n    uint256[] calldata newPreBidPrices\\n  ) external onlyOwner {\\n    require(\\n      collections.length == tokenIds.length && tokenIds.length == newReservePrices.length\\n      && newReservePrices.length == newPreBidPrices.length,\\n      'Array length mismatch'\\n    );\\n    for(uint256 i; i < collections.length; ++i) {\\n      _changePrices(collections[i], tokenIds[i], newReservePrices[i], newPreBidPrices[i]);\\n    }\\n  }\\n\\n  function changeSplit(\\n    address collectionAddress,\\n    uint256 tokenId,\\n    address artist,\\n    uint256 split\\n  ) external onlyOwner {\\n    _changeSplit(collectionAddress, tokenId, artist, split);\\n  }\\n\\n  function changeSplitMultiple(\\n    address[] calldata collections,\\n    uint256[] calldata tokenIds,\\n    address[] calldata artists,\\n    uint256[] calldata splits\\n  ) external onlyOwner {\\n    require(\\n      collections.length == tokenIds.length && tokenIds.length == artists.length\\n      && artists.length == splits.length,\\n      'Array length mismatch'\\n    );\\n    for(uint256 i; i < collections.length; ++i) {\\n      _changeSplit(collections[i], tokenIds[i], artists[i], splits[i]);\\n    }\\n  }\\n\\n  function reschedule(\\n    address collectionAddress,\\n    uint256 tokenId,\\n    uint256 newpreBidStartTime,\\n    uint256 newAuctionStartTime\\n  ) external onlyOwner {\\n    _reschedule(collectionAddress, tokenId, newpreBidStartTime, newAuctionStartTime);\\n  }\\n\\n  function resetAuction(\\n    address collectionAddress,\\n    uint256 tokenId\\n  ) external onlyOwner {\\n    _resetAuction(collectionAddress, tokenId);\\n  }\\n\\n  function resetMultiple(\\n    address[] calldata collections,\\n    uint256[] calldata tokenIds\\n  ) external onlyOwner {\\n    require(\\n      collections.length == tokenIds.length,\\n      'Array length mismatch'\\n    );\\n    for(uint256 i; i < collections.length; ++i) {\\n      _resetAuction(collections[i], tokenIds[i]);\\n    }\\n  }\\n\\n  function cancelUnselected() external onlyOwner {\\n    uint256[] memory rest = getAuctionsToCancel();\\n    for(uint256 i; i < rest.length; ++i) {\\n      _resetAuction(getCollectionFromId(rest[i]), getArtTokenIdFromId(rest[i]));\\n    }\\n  }\\n\\n  function rescheduleMultiple(\\n    address[] calldata collections,\\n    uint256[] calldata tokenIds,\\n    uint256[] calldata newpreBidStartTimes,\\n    uint256[] calldata newAuctionStartTimes\\n  ) external onlyOwner {\\n    require(\\n      collections.length == tokenIds.length && tokenIds.length == newpreBidStartTimes.length\\n      && newpreBidStartTimes.length == newAuctionStartTimes.length,\\n      'Array length mismatch'\\n    );\\n    for(uint256 i; i < collections.length; ++i) {\\n      _reschedule(collections[i], tokenIds[i], newpreBidStartTimes[i], newAuctionStartTimes[i]);\\n    }\\n  }\\n\\n  function schedule(\\n    address collectionAddress,\\n    uint256 tokenId,\\n    uint256 preBidStartTime,\\n    uint256 auctionStartTime,\\n    address artist,\\n    uint256 split,\\n    uint256 reserve,\\n    uint256 preBidPrice\\n  ) external onlyOwner {\\n    _schedule(\\n      collectionAddress,\\n      tokenId,\\n      preBidStartTime,\\n      auctionStartTime,\\n      artist,\\n      split,\\n      reserve,\\n      preBidPrice\\n    );\\n  }\\n\\n  function scheduleMultiple(\\n    address[] calldata collections,\\n    uint256[] calldata tokenIds,\\n    uint256[] calldata preBidStartTimes,\\n    uint256[] calldata auctionStartTimes,\\n    address[] calldata artists,\\n    uint256[] calldata splits,\\n    uint256[] calldata reservePrices,\\n    uint256[] calldata preBidPrices\\n  ) external onlyOwner {\\n    require(\\n      collections.length == tokenIds.length && tokenIds.length == preBidStartTimes.length &&\\n      preBidStartTimes.length == auctionStartTimes.length && auctionStartTimes.length == artists.length\\n      && artists.length == splits.length && splits.length == reservePrices.length && reservePrices.length == preBidPrices.length,\\n      'Array length mismatch'\\n    );\\n    for(uint256 i; i < collections.length; ++i) {\\n      _schedule(\\n        collections[i],\\n        tokenIds[i],\\n        preBidStartTimes[i],\\n        auctionStartTimes[i],\\n        artists[i],\\n        splits[i],\\n        reservePrices[i],\\n        preBidPrices[i]\\n      );\\n    }\\n  }\\n\\n  function scheduleMultipleLight(\\n    address collections,\\n    uint256[] calldata tokenIds,\\n    uint256 preBidStartTimes,\\n    uint256 auctionStartTimes,\\n    address artists,\\n    uint256 splits,\\n    uint256 reservePrices,\\n    uint256 preBidPrices\\n  ) external onlyOwner {\\n    for(uint256 i; i < tokenIds.length; ++i) {\\n      _schedule(\\n        collections,\\n        tokenIds[i],\\n        preBidStartTimes,\\n        auctionStartTimes,\\n        artists,\\n        splits,\\n        reservePrices,\\n        preBidPrices\\n      );\\n    }\\n  }\\n\\n  function setBeneficiary(\\n    address _beneficiary\\n  ) external onlyOwner {\\n    beneficiary = _beneficiary;\\n  }\\n\\n  function setPaused(\\n    bool _paused\\n  ) external onlyOwner {\\n    paused = _paused;\\n  }\\n\\n  // GETTERS\\n\\n  function artTokentoAuctionId(\\n    address collection,\\n    uint256 tokenId\\n  ) public pure returns (uint256) {\\n    return (uint256(uint160(collection)) << 96) | uint96(tokenId);\\n  }\\n\\n  function isAuctionActive(\\n    uint256 auctionId\\n  ) public view returns (bool) {\\n    uint256 startTime = auctionConfig[auctionId].auctionStartTime;\\n    uint256 endTime = getAuctionEndTime(auctionId);\\n    return (startTime > 0 && block.timestamp >= startTime && block.timestamp < endTime);\\n  }\\n\\n  function isAuctionOver(\\n    uint256 auctionId\\n  ) public view returns (bool) {\\n    uint256 startTime = auctionConfig[auctionId].auctionStartTime;\\n    uint256 endTime = getAuctionEndTime(auctionId);\\n    return (startTime > 0 && block.timestamp >= endTime);\\n  }\\n\\n  function getAuctionEndTime(\\n    uint256 auctionId\\n  ) public view returns (uint256) {\\n    return auctionConfig[auctionId].auctionStartTime + INIT_AUCTION_DURATION + auctionIdToAuction[auctionId].offsetFromEnd;\\n  }\\n\\n  function getAuctionStartTime(\\n    uint256 auctionId\\n  ) external view returns (uint256) {\\n    return auctionConfig[auctionId].auctionStartTime;\\n  }\\n\\n  function getCollectionFromId(\\n    uint256 id\\n  ) public pure returns (address) {\\n    return address(uint160(id >> 96));\\n  }\\n\\n  function getArtTokenIdFromId(\\n    uint256 id\\n  ) public pure returns (uint256) {\\n    return uint256(uint96(id));\\n  }\\n\\n  function getPreselectedAuctions() public view returns (uint256[] memory) {\\n    return leaderboard.getTopK();\\n  }\\n\\n  function getAuctionsToCancel() public view returns (uint256[] memory) {\\n    uint256 len = scheduled.length;\\n    if (len > RANK_AUCTION_SIZE) {\\n      uint256 listSize = len - RANK_AUCTION_SIZE;\\n      uint256[] memory list = new uint256[](listSize);\\n      uint256 j;\\n      for (uint256 i;i<len && j < listSize;i++){\\n        if(!leaderboard.isInTopK(scheduled[i])) {\\n          list[j] = scheduled[i];\\n          j++;\\n        }\\n      }\\n      return list;\\n    }\\n    uint256[] memory nil = new uint256[](0);\\n    return nil;\\n  }\\n\\n  function reservePrice(\\n    uint256 auctionId\\n  ) public view returns (uint256) {\\n    uint256 reserve = auctionConfig[auctionId].reservePrice;\\n    return reserve != 0 ? reserve : MIN_BID;\\n  }\\n}\\n\\ninterface INFT {\\n  function mint(address to, uint256 tokenId) external;\\n  function ownerOf(uint256 tokenId) external view returns (address);\\n  function transferFrom(address from, address to, uint256 tokenId) external;\\n}\"\r\n    },\r\n    \"marketplacev3/libs/TopKHeap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary TopKHeap {\\n    struct Heap {\\n        uint256[] scores;\\n        uint256[] ids;\\n        mapping(uint256 => uint256) indexMap;\\n        uint256 k;\\n    }\\n\\n    function initialize(Heap storage _heap, uint256 _k) internal {\\n        _heap.k = _k;\\n    }\\n\\n    function swap(Heap storage _heap, uint256 i, uint256 j) private {\\n        (_heap.scores[i], _heap.scores[j]) = (_heap.scores[j], _heap.scores[i]);\\n        (_heap.ids[i], _heap.ids[j]) = (_heap.ids[j], _heap.ids[i]);\\n        _heap.indexMap[_heap.ids[i]] = i;\\n        _heap.indexMap[_heap.ids[j]] = j;\\n    }\\n\\n    function insert(Heap storage _heap, uint256 _id, uint256 _score) internal {\\n        uint256 index = _heap.indexMap[_id];\\n\\n        if (index == 0) {\\n            if (_heap.scores.length < _heap.k) {\\n                _heap.scores.push(_score);\\n                _heap.ids.push(_id);\\n                index = _heap.scores.length - 1;\\n                _heap.indexMap[_id] = index;\\n            } else if (_score > _heap.scores[0]) {\\n                _heap.scores[0] = _score;\\n                _heap.ids[0] = _id;\\n                _heap.indexMap[_id] = 0;\\n            } else {\\n                return;\\n            }\\n        } else {\\n            _heap.scores[index] = _score;\\n        }\\n\\n        siftDown(_heap, index);\\n    }\\n\\n    function siftDown(Heap storage _heap, uint256 index) private {\\n        uint256 left = 2 * index + 1;\\n        uint256 right = 2 * index + 2;\\n        uint256 smallest = index;\\n\\n        if (left < _heap.scores.length && _heap.scores[left] < _heap.scores[smallest]) {\\n            smallest = left;\\n        }\\n        if (right < _heap.scores.length && _heap.scores[right] < _heap.scores[smallest]) {\\n            smallest = right;\\n        }\\n        if (smallest != index) {\\n            swap(_heap, index, smallest);\\n            siftDown(_heap, smallest);\\n        }\\n    }\\n\\n    function isInTopK(Heap storage _heap, uint256 _id) internal view returns (bool) {\\n        uint256 index = _heap.indexMap[_id];\\n        return index != 0 && index < _heap.k;\\n    }\\n\\n    function getTopK(Heap storage _heap) internal view returns (uint256[] memory) {\\n        uint256 len = _heap.scores.length < _heap.k ? _heap.scores.length : _heap.k;\\n        uint256[] memory topKAddresses = new uint256[](len);\\n        for (uint256 i = 0; i < len; ++i) {\\n            topKAddresses[i] = _heap.ids[i];\\n        }\\n        return topKAddresses;\\n    }\\n}\\n\"\r\n    },\r\n    \"marketplacev3/libs/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n///\\n/// @dev Note:\\n/// - For ETH transfers, please use `forceSafeTransferETH` for gas griefing protection.\\n/// - For ERC20s, this implementation won't check that a token has code,\\n/// responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH\\n    /// that disallows any storage writes.\\n    uint256 internal constant _GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    /// Multiply by a small constant (e.g. 2), if needed.\\n    uint256 internal constant _GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// Note: This implementation does NOT protect against gas griefing.\\n    /// Please use `forceSafeTransferETH` for gas griefing protection.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gasStipend, to, amount, 0, 0, 0, 0)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // To coerce gas estimation to provide enough gas for the `create` above.\\n                    if iszero(gt(gas(), 1000000)) { revert(0, 0) }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend\\n    /// equal to `_GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default\\n    /// for 99% of cases and can be overridden with the three-argument version of this\\n    /// function if necessary.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        // Manually inlined because the compiler doesn't inline functions with branches.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(_GAS_STIPEND_NO_GRIEF, to, amount, 0, 0, 0, 0)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // To coerce gas estimation to provide enough gas for the `create` above.\\n                    if iszero(gt(gas(), 1000000)) { revert(0, 0) }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.\\n    ///\\n    /// Note: Does NOT revert upon failure.\\n    /// Returns whether the transfer of ETH is successful instead.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            success := call(gasStipend, to, amount, 0, 0, 0, 0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have their entire balance approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            // Store the function selector of `balanceOf(address)`.\\n            mstore(0x0c, 0x70a08231000000000000000000000000)\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x00, 0x23b872dd)\\n            // The `amount` argument is already written to the memory word at 0x60.\\n            amount := mload(0x60)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            // Store the function selector of `transfer(address,uint256)`.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x14, to) // Store the `to` argument.\\n            // The `amount` argument is already written to the memory word at 0x34.\\n            amount := mload(0x34)\\n            // Store the function selector of `transfer(address,uint256)`.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            // Store the function selector of `approve(address,uint256)`.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `ApproveFailed()`.\\n                mstore(0x00, 0x3e3f8f73)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            // Store the function selector of `balanceOf(address)`.\\n            mstore(0x00, 0x70a08231000000000000000000000000)\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\\n     *   {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\\n     *   a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the address zero.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.3/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.3/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"BidMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Settled\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"artTokentoAuctionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctionConfig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"artist\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"split\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"preBidStartTime\",\"type\":\"uint80\"},{\"internalType\":\"uint80\",\"name\":\"auctionStartTime\",\"type\":\"uint80\"},{\"internalType\":\"uint88\",\"name\":\"reservePrice\",\"type\":\"uint88\"},{\"internalType\":\"uint88\",\"name\":\"preBidPrice\",\"type\":\"uint88\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctionIdToAuction\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"offsetFromEnd\",\"type\":\"uint24\"},{\"internalType\":\"uint72\",\"name\":\"amount\",\"type\":\"uint72\"},{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelUnselected\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newReservePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newPreBidPrice\",\"type\":\"uint256\"}],\"name\":\"changePrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"collections\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"newReservePrices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"newPreBidPrices\",\"type\":\"uint256[]\"}],\"name\":\"changePricesMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"artist\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"split\",\"type\":\"uint256\"}],\"name\":\"changeSplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"collections\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"artists\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"splits\",\"type\":\"uint256[]\"}],\"name\":\"changeSplitMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"discountsCount\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getArtTokenIdFromId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"getAuctionEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"getAuctionStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAuctionsToCancel\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getCollectionFromId\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPreselectedAuctions\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"isAuctionActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"isAuctionOver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leaderboard\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"k\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newpreBidStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newAuctionStartTime\",\"type\":\"uint256\"}],\"name\":\"reschedule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"collections\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"newpreBidStartTimes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"newAuctionStartTimes\",\"type\":\"uint256[]\"}],\"name\":\"rescheduleMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"reservePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"resetAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"collections\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"resetMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preBidStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionStartTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"artist\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"split\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preBidPrice\",\"type\":\"uint256\"}],\"name\":\"schedule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"collections\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"preBidStartTimes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"auctionStartTimes\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"artists\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"splits\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"reservePrices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"preBidPrices\",\"type\":\"uint256[]\"}],\"name\":\"scheduleMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collections\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"preBidStartTimes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionStartTimes\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"artists\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"splits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservePrices\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preBidPrices\",\"type\":\"uint256\"}],\"name\":\"scheduleMultipleLight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"scheduled\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"setBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"settleAuction\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"auctionIds\",\"type\":\"uint256[]\"}],\"name\":\"settleMultipleAuctions\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ArtMarketplace7d", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c3f1eb9c8543caa67ba98ca8b4eb7b0ff05f2bcccad35984afccd64a76879d13"}