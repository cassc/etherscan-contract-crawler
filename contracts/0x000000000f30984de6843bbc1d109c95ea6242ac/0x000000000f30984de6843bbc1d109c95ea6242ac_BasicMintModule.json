{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Create/contracts/v1/BasicMintModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport {IBasicMintModule, IConfigurable} from \\\"create/interfaces/v1/IBasicMintModule.sol\\\";\\nimport {IMintPayout} from \\\"create/interfaces/v1/IMintPayout.sol\\\";\\nimport {IMintContract} from \\\"create/interfaces/v1/IMintContract.sol\\\";\\nimport {BasicMintConfiguration} from \\\"create/interfaces/v1/BasicMintConfiguration.sol\\\";\\nimport {Version} from \\\"create/contracts/v1/Version.sol\\\";\\n\\ncontract BasicMintModule is IBasicMintModule, Version {\\n    IMintPayout public immutable mintPayout;\\n\\n    mapping(address => BasicMintConfiguration) private _configurations;\\n    mapping(address => mapping(address => uint256)) private _mintedByAddress;\\n    mapping(address => uint256) public mintedByContract;\\n\\n    /// @notice Emitted when quantity is zero.\\n    error InvalidQuantity();\\n    /// @notice Emitted if the collector is minting too many tokens per transaction.\\n    error TooManyTokensPerTransaction();\\n    /// @notice Emitted if the collector is minting too many tokens per wallet.\\n    error TooManyTokensPerCollector();\\n    /// @notice Emitted if the collector is minting more tokens than this module is allowed to mint.\\n    error TooManyTokensForModule();\\n    /// @notice Emitted if the mint has not started yet.\\n    error MintNotStarted();\\n    /// @notice Emitted if the mint has ended.\\n    error MintEnded();\\n    /// @notice Emitted when the value sent is incorrect.\\n    error IncorrectPayment();\\n    /// @notice Emitted when the max supply is reached.\\n    error MaxSupplyReached();\\n\\n    constructor(address _mintPayout) Version(1) {\\n        mintPayout = IMintPayout(_mintPayout);\\n    }\\n\\n    /// @inheritdoc IConfigurable\\n    function updateConfiguration(bytes calldata args) external override {\\n        BasicMintConfiguration memory _config = abi.decode(args, (BasicMintConfiguration));\\n\\n        _configurations[msg.sender] = _config;\\n        emit ConfigurationUpdated(msg.sender, _config);\\n    }\\n\\n    /// @inheritdoc IBasicMintModule\\n    function configuration(address _contract) external view returns (BasicMintConfiguration memory) {\\n        return _configurations[_contract];\\n    }\\n\\n    /// @inheritdoc IBasicMintModule\\n    function mint(address _contract, address _to, address _referrer, uint256 _quantity) external payable {\\n        _mint(_contract, _to, _referrer, _quantity);\\n    }\\n\\n    /// @inheritdoc IBasicMintModule\\n    function mint_efficient_7e80c46e(address _contract, address _to, address _referrer, uint256 _quantity)\\n        external\\n        payable\\n    {\\n        _mint(_contract, _to, _referrer, _quantity);\\n    }\\n\\n    /// @notice The implementation of the mint function.\\n    /// @dev This is implemented as an internal function to share the logic between the `mint` and `mint_efficient_7e80c46e` functions.\\n    /// See the documentation for those functions for information on the parameters.\\n    function _mint(address _contract, address _to, address _referrer, uint256 _quantity) internal {\\n        BasicMintConfiguration memory config = _configurations[_contract];\\n\\n        if (_quantity == 0) revert InvalidQuantity();\\n        if (config.maxPerTransaction > 0 && _quantity > config.maxPerTransaction) revert TooManyTokensPerTransaction();\\n\\n        if (config.maxPerWallet > 0) {\\n            if (_mintedByAddress[_contract][_to] + _quantity > config.maxPerWallet) {\\n                revert TooManyTokensPerCollector();\\n            }\\n        }\\n\\n        if (config.maxForModule > 0 && mintedByContract[_contract] + _quantity > config.maxForModule) {\\n            revert TooManyTokensForModule();\\n        }\\n\\n        if (block.timestamp < config.mintStart) revert MintNotStarted();\\n        if (config.mintEnd > 0 && block.timestamp > config.mintEnd) revert MintEnded();\\n\\n        uint256 protocolFee = mintPayout.protocolFee();\\n        if (msg.value != (config.price + protocolFee) * _quantity) revert IncorrectPayment();\\n\\n        if (config.maxSupply > 0 && IMintContract(_contract).totalMinted() + _quantity > config.maxSupply) {\\n            revert MaxSupplyReached();\\n        }\\n\\n        _mintedByAddress[_contract][_to] += _quantity;\\n        mintedByContract[_contract] += _quantity;\\n\\n        mintPayout.mintDeposit{value: msg.value}(_contract, msg.sender, _referrer, _quantity);\\n        IMintContract(_contract).mint(_to, _quantity);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Create/interfaces/v1/IBasicMintModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport {BasicMintConfiguration} from \\\"create/interfaces/v1/BasicMintConfiguration.sol\\\";\\nimport {IConfigurable} from \\\"create/interfaces/v1/IConfigurable.sol\\\";\\n\\ninterface IBasicMintModuleEvents {\\n    /// @notice Emitted when a contract's basic mint configuration is updated.\\n    /// @param _contract The address of the contract being configured.\\n    /// @param _config The new configuration.\\n    event ConfigurationUpdated(address indexed _contract, BasicMintConfiguration _config);\\n}\\n\\ninterface IBasicMintModule is IConfigurable, IBasicMintModuleEvents {\\n    /// @notice Retrieves the basic minting configuration for a contract.\\n    /// @param _contract The address of the contract.\\n    /// @return The current minting configuration.\\n    function configuration(address _contract) external view returns (BasicMintConfiguration memory);\\n\\n    /// @notice Mints tokens for a NFT contract to a recipient.\\n    /// @dev Reverts if the mint does not work in the current configuration.\\n    /// @param _contract The address of the contract to mint for.\\n    /// @param _to The recipient of the tokens.\\n    /// @param _referrer The referrer of this mint, or the zero address if none.\\n    /// @param _quantity The quantity of tokens to mint.\\n    function mint(address _contract, address _to, address _referrer, uint256 _quantity) external payable;\\n\\n    /// @notice Mints tokens for a NFT contract to a recipient.\\n    /// @dev Reverts if the mint does not work in the current configuration.\\n    /// This function is preferred over `mint` because the four byte signature is 0x00000000 which is cheaper to call.\\n    /// The implementation is identical to `mint`.\\n    /// @param _contract The address of the contract to mint for.\\n    /// @param _to The recipient of the tokens.\\n    /// @param _referrer The referrer of this mint, or the zero address if none.\\n    /// @param _quantity The quantity of tokens to mint.\\n    function mint_efficient_7e80c46e(address _contract, address _to, address _referrer, uint256 _quantity)\\n        external\\n        payable;\\n}\\n\"\r\n    },\r\n    \"src/Create/interfaces/v1/IMintPayout.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\ninterface IMintPayoutEvents {\\n    /// @notice Emitted when a deposit has been made.\\n    /// @param from The depositor's address.\\n    /// @param to The address receiving the deposit.\\n    /// @param reason The reason code for the deposit.\\n    /// @param amount The deposit amount.\\n    event Deposit(address from, address to, bytes4 reason, uint256 amount);\\n\\n    /// @notice Emitted when a withdrawal has been made.\\n    /// @param from The address withdrawing.\\n    /// @param to The address receiving the withdrawn funds.\\n    /// @param amount The withdrawal amount.\\n    event Withdraw(address from, address to, uint256 amount);\\n\\n    /// @notice Emitted during a mint deposit to provide additional context.\\n    /// @param depositedBy The address of the mint initiator.\\n    /// @param mintContract The mint contract address this mint deposit refers to.\\n    /// @param minter The address of the person minting.\\n    /// @param referrer The address of the referrer, or the zero address for no referrer.\\n    /// @param creator The address of the contract creator, or the protocol fee recipient if none.\\n    /// @param creatorPayout The amount being paid to the creator.\\n    /// @param referralPayout The amount being paid to the referrer.\\n    /// @param protocolPayout The amount being paid to the protocol.\\n    /// @param totalAmount The total deposit amount.\\n    /// @param quantity The number of tokens being minted.\\n    /// @param protocolFee The per-mint fee for the protocol.\\n    event MintDeposit(\\n        address depositedBy,\\n        address mintContract,\\n        address minter,\\n        address referrer,\\n        address creator,\\n        uint256 creatorPayout,\\n        uint256 referralPayout,\\n        uint256 protocolPayout,\\n        uint256 totalAmount,\\n        uint256 quantity,\\n        uint256 protocolFee\\n    );\\n\\n    /// @notice Emitted when the protocol fee is updated.\\n    /// @param fee The new protocol fee.\\n    event ProtocolFeeUpdated(uint256 fee);\\n}\\n\\ninterface IMintPayout is IMintPayoutEvents {\\n    function balanceOf(address owner) external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice The current protocol fee per-mint.\\n    function protocolFee() external view returns (uint256 fee);\\n\\n    /// @notice Sets the protocol fee per-mint.\\n    /// @dev Only callable by the owner.\\n    /// @param fee The new protocol fee.\\n    function setProtocolFee(uint256 fee) external;\\n\\n    /// @notice Magic value used to represent the fees belonging to the protocol.\\n    function protocolFeeRecipientAccount() external view returns (address);\\n\\n    /// @notice Withdraws from the protocol fee balance.\\n    /// @dev Only callable by the owner.\\n    /// @param to The address receiving the withdrawn funds.\\n    /// @param amount The withdrawal amount.\\n    function withdrawProtocolFee(address to, uint256 amount) external;\\n\\n    /// @notice Deposits ether for a mint.\\n    /// @dev Ensure that `quantity` is > 0. The `protocolFee` should be per-mint, not the total taken.\\n    /// Will trigger a `MintDeposit` event, followed by `Deposit` events for:\\n    /// creator payout, protocol payout, and referrer payout (if a referrer is specified).\\n    /// @param mintContract The mint contract address this mint deposit refers to.\\n    /// @param minter The address of the minter.\\n    /// @param referrer The address of the referrer, or the zero address for no referrer.\\n    /// @param quantity The amount being minted.\\n    function mintDeposit(address mintContract, address minter, address referrer, uint256 quantity) external payable;\\n\\n    /// @notice Deposits ether to an address.\\n    /// @param to The address receiving the deposit.\\n    /// @param reason The reason code for the deposit.\\n    function deposit(address to, bytes4 reason) external payable;\\n\\n    /// @notice Deposits ether to multiple addresses.\\n    /// @dev The length of `recipients`, `amounts`, and `reasons` must be the same.\\n    /// @param recipients List of addresses receiving the deposits.\\n    /// @param amounts List of deposit amounts.\\n    /// @param reasons List of reason codes for the deposits.\\n    function depositBatch(address[] calldata recipients, uint256[] calldata amounts, bytes4[] calldata reasons)\\n        external\\n        payable;\\n\\n    /// @notice Withdraws ether from the `msg.sender`'s account to a specified address.\\n    /// @param to The address receiving the withdrawn funds.\\n    /// @param amount The withdrawal amount.\\n    function withdraw(address to, uint256 amount) external;\\n\\n    /// @notice Withdraws all ether from the `msg.sender`'s account to a specified address.\\n    /// @param to The address receiving the withdrawn funds.\\n    function withdrawAll(address to) external;\\n}\\n\"\r\n    },\r\n    \"src/Create/interfaces/v1/IMintContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport {IMetadataRenderer} from \\\"create/interfaces/v1/IMetadataRenderer.sol\\\";\\n\\ninterface IMintContractEvents {\\n    /// @notice Emitted when the royalty is updated.\\n    event RoyaltyUpdated(uint256 bps);\\n    /// @notice Emitted when a new mint module is added.\\n    event ModuleAdded(address module);\\n    /// @notice Emitted when a mint module is removed.\\n    event ModuleRemoved(address module);\\n    /// @notice Emitted when the metadata renderer is updated.\\n    event MetadataRendererUpdated(address renderer);\\n}\\n\\ninterface IMintContract is IMintContractEvents {\\n    /// @notice Mints tokens using approved mint modules.\\n    /// @param to The address receiving the minted tokens.\\n    /// @param quantity The quantity of tokens to mint.\\n    function mint(address to, uint256 quantity) external;\\n\\n    /// @notice Mints tokens, callable only by the contract owner.\\n    /// @param to The address receiving the minted tokens.\\n    /// @param quantity The quantity of tokens to mint.\\n    function adminMint(address to, uint256 quantity) external;\\n\\n    /// @notice Retrieves the payout recipient address for this mint contract.\\n    /// @return recipient address of the payout recipient.\\n    function payoutRecipient() external view returns (address recipient);\\n\\n    /// @notice Returns the total number of tokens minted.\\n    /// @return total number of tokens minted.\\n    function totalMinted() external view returns (uint256 total);\\n\\n    /// @notice Adds a new mint module as an approved minter.\\n    /// @dev Can only be executed by the owner of the contract.\\n    /// Must be approved in the MintModuleRegistry.\\n    /// @param mintModule The contract address of the mint module.\\n    function addMintModule(address mintModule) external;\\n\\n    /// @notice Removes a mint module as an approved minter.\\n    /// @dev Can only be executed by the owner of the contract.\\n    /// @param mintModule The contract address of the mint module.\\n    function removeMintModule(address mintModule) external;\\n\\n    /// @notice Returns whether a mint module is approved.\\n    /// @param mintModule The contract address of the mint module.\\n    /// @return isApproved Whether the mint module is approved.\\n    function isMintModuleApproved(address mintModule) external view returns (bool isApproved);\\n\\n    /// @notice Updates configuration located in an external contract.\\n    /// @dev Can only be executed by the owner of the contract.\\n    /// The cardinality of `configurables` and `configData` must be the same.\\n    /// @param configurables The contract addresses to configure.\\n    /// @param configData The configuration data for the contracts.\\n    function updateExternalConfiguration(address[] calldata configurables, bytes[] calldata configData) external;\\n\\n    /// @notice Sets the metadata renderer.\\n    /// @dev This will not request a metadata refresh. If needed, call `refreshMetadata`.\\n    /// @param renderer The new metadata renderer.\\n    function setMetadataRenderer(IMetadataRenderer renderer) external;\\n\\n    /// @notice Returns the metadata renderer for this contract.\\n    /// @return metadataRenderer The metadata renderer.\\n    function metadataRenderer() external returns (IMetadataRenderer metadataRenderer);\\n\\n    /// @notice Triggers a batch metadata update.\\n    function refreshMetadata() external;\\n\\n    /// @notice Updates the royalty for this contract.\\n    /// @dev Can only be called by the contract owner.\\n    /// Emits a `RoyaltyUpdated` event.\\n    /// @param bps The new royalty.\\n    function setRoyalty(uint256 bps) external;\\n\\n    /// @notice Returns the royalty for this contract.\\n    /// @return bps The royalty.\\n    function royaltyBps() external returns (uint256 bps);\\n}\\n\"\r\n    },\r\n    \"src/Create/interfaces/v1/BasicMintConfiguration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nstruct BasicMintConfiguration {\\n    /// @notice Purchase cost per token.\\n    uint256 price;\\n    /// @notice UNIX timestamp of mint start.\\n    uint64 mintStart;\\n    /// @notice UNIX timestamp of mint end, or zero if open-ended.\\n    uint64 mintEnd;\\n    /// @notice Maximum token purchase limit per wallet, or zero if no limit.\\n    uint32 maxPerWallet;\\n    /// @notice Maximum tokens mintable per transaction, or zero if no limit.\\n    uint32 maxPerTransaction;\\n    /// @notice Maximum tokens mintable by this module, or zero if no limit.\\n    uint32 maxForModule;\\n    /// @notice Maximum tokens that can be minted in total, or zero if no max.\\n    uint32 maxSupply;\\n}\\n\"\r\n    },\r\n    \"src/Create/contracts/v1/Version.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nabstract contract Version {\\n    /// @notice The version of the contract.\\n    uint32 public immutable contractVersion;\\n\\n    constructor(uint32 _contractVersion) {\\n        contractVersion = _contractVersion;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Create/interfaces/v1/IConfigurable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\ninterface IConfigurable {\\n    /// @notice Updates the configuration for the calling contract.\\n    /// @param data The configuration data.\\n    function updateConfiguration(bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"src/Create/interfaces/v1/IMetadataRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\ninterface IMetadataRenderer {\\n    /// @notice Retrieves the token URI for the specified token ID.\\n    /// @param tokenId The ID of the token.\\n    /// @return uri The URI of the token.\\n    function tokenURI(uint256 tokenId) external view returns (string memory uri);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ERC721A/=lib/ERC721A/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"fundrop/=src/Fundrop/\",\r\n      \"operator-filter-registry/=lib/operator-filter-registry/src/\",\r\n      \"base64/=lib/base64/\",\r\n      \"create/=src/Create/\",\r\n      \"erc4626-tests/=lib/operator-filter-registry/lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"erc721a-upgradeable/=lib/erc721a-upgradeable/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/operator-filter-registry/lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 250000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mintPayout\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"IncorrectPayment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidQuantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxSupplyReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintEnded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintNotStarted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooManyTokensForModule\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooManyTokensPerCollector\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooManyTokensPerTransaction\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"mintStart\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"mintEnd\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"maxPerWallet\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxPerTransaction\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxForModule\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxSupply\",\"type\":\"uint32\"}],\"indexed\":false,\"internalType\":\"struct BasicMintConfiguration\",\"name\":\"_config\",\"type\":\"tuple\"}],\"name\":\"ConfigurationUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"configuration\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"mintStart\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"mintEnd\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"maxPerWallet\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxPerTransaction\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxForModule\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxSupply\",\"type\":\"uint32\"}],\"internalType\":\"struct BasicMintConfiguration\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractVersion\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPayout\",\"outputs\":[{\"internalType\":\"contract IMintPayout\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"mint_efficient_7e80c46e\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mintedByContract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"args\",\"type\":\"bytes\"}],\"name\":\"updateConfiguration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BasicMintModule", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "250000", "ConstructorArguments": "00000000000000000000000000528e0000006f0000dcbe2f0065011d1fcd411a", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}