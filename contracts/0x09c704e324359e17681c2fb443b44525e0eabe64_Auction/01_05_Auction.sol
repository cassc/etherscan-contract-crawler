//SPDX-License-Identifier: MIT
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @title Auction
 * @author @brougkr
 * @notice A Smart Contract To Facilitate Ascending Rebate Auctions (With Ascending Rebate Reserve Floor) For Multiple NFTs (Or Whatever Else You Want To Sell) 
 */
pragma solidity 0.8.19;
import { DelegateCashEnabled } from "./DelegateCashEnabled.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
contract Auction is DelegateCashEnabled, ReentrancyGuard, Ownable
{
    struct Bid
    {
        uint _OGBidIndex; // [0] -> Original Bid Index
        uint _ETHValue;   // [1] -> ETH Value Of Bid
        uint _Timestamp;  // [2] -> Unix Timestamp Of Bid Confirmation
        address _Bidder;  // [3] -> Wallet Address Of Bidder
        address _Vault;   // [4] -> Wallet Address Of Vault (optional `delegate.cash` support)
        bool _Rebated;    // [5] -> If Bidder Rebated ETH From Bid
        bool _Winner;     // [6] -> If Bidder Is A Winner (Top Placing) In The Auction
        bool _NFTSent;    // [7] -> If Bidder Has Received Their NFT
    }

    struct Params
    {
        string _Name;                // [0] -> Name Of Auction
        bool _KickbackEnabled;       // [1] -> If Next Bidder Rebate Previous Bidder
        bool _ClearingEnabled;       // [2] -> If Rebate Last Price Is Enabled (Everyone Pays Lowest Leaderboard Price)
        bool _UserSettlementEnabled; // [3] -> If Self-Service User Settlement Is Enabled (Bidders Can Settle Their Own Bids ETH & NFTs)
        uint _LeaderboardSize;       // [4] -> The Bid Threshold For NewMinimumBid (eg. 50 Valid Bids)
        uint _UnixStartTime;         // [5] -> Unix Start Time Of Auction
        uint _UnixEndTime;           // [6] -> Unix End Time Of Auction
        uint _MinBIPSIncrease;       // [7] -> Minimum BIPS (%) Increase On Each Subsequent Bid After Configured LeaderboardSize 
        uint _SecondsExtension;      // [8] -> # Of Second(s) Of Extension For Auction (Input In Seconds)
        uint _SecondsThreshold;      // [9] -> # Of Seconds Within Auction End Time To Be Eligible For Auction Extension
        uint _InitialMinimumBid;     // [10] -> Initial Minimum Bid
        uint _ProjectIDMintPass;     // [11] -> The Factory MintPass ProjectID
        address _NFT;                // [12] -> Address Of NFT Contract
        address _Operator;           // [13] -> Wallet Holding NFTs To Disperse
    }

    struct State
    {
        bool _Active;           // [0] -> _Active
        bool _NFTsDispersed;    // [1] -> _NFTsDispersed
        uint _LastMinBid;       // [2] -> _LastMinBid
        uint _GlobalUniqueBids; // [3] -> _GlobalUniqueBids
    }

    struct AllAuctionParams
    {
        string _Name;            // [0] -> Name Of Auction
        bool _Active;            // [1] -> If Sale Is Active
        bool _NFTsDispersed;     // [2] -> If NFTs Have Been Dispersed
        bool _KickbackEnabled;   // [3] -> If Next Bidder Rebate Previous Bidder
        bool _ClearingEnabled;   // [4] -> If Rebate Last Price Is Enabled (Everyone Pays Lowest Leaderboard Price)
        uint _LeaderboardSize;   // [5] -> The Bid Threshold For NewMinimumBid (eg. 50 Valid Bids)
        uint _UnixStartTime;     // [6] -> Unix Start Time Of Auction
        uint _UnixEndTime;       // [7] -> Unix End Time Of Auction
        uint _MinBIPSIncrease;   // [8] -> Minimum BIPS (%) Increase On Each Subsequent Bid After 50 Unique Bids 
        uint _SecondsExtension;  // [9] -> # Of Seconds(s) Of Extension For Auction (Input In # Of Seconds)
        uint _SecondsThreshold;  // [10] -> # Of Seconds Within Auction End Time To Be Eligible For Auction Extension
        uint _LastMinBid;        // [11] -> Value Of The Last Minimum Bid
        uint _GlobalUniqueBids;  // [12] -> # Of Global Unique Bids
        uint _ProjectIDMintPass; // [13] -> The Factory MintPass ProjectID
        address _NFT;            // [14] -> Address Of NFT Contract
    }

    /*-----------------------------
     * STATE VARIABLES & MAPPINGS *
    ------------------------------*/

    Params public AuctionParams;
    State public SaleState;
    mapping(uint=>Bid) public Bids;
    mapping(uint=>uint) public Leaderboard;
    mapping(address=>uint[]) public UserBidIndexes;
    mapping(address=>bool) public Admin;
    mapping(uint=>bool) public NFTTokenIDHasBeenSent;
    address private constant _BRT_MULTISIG = 0x0BC56e3c1397e4570069e89C07936A5c6020e3BE;

    /*---------
     * EVENTS *
    ----------*/

    /**
     * @dev Emitted When A New Bid Is Submitted
     */
    event NewBidComplete(uint BidIndex, address Bidder, uint MessageValue, uint Unixtimestamp, address Vault);

    /**
     * @dev Emitted When A Bid Is Topped Up
     */
    event BidToppedUp(uint BidIndex, uint ETHForBid, uint Unixtimestamp, address Bidder);

    /**
     * @dev Emitted When A Bid Reclaim Fails
     */
    event BidReclaimFailed(uint BidIndex);

    /**
     * @dev Emitted When A Bid Reclaim Succeeds
     */
    event BidReclaimSuccess(uint BidIndex);

    /**
     * @dev Emitted When A Bidder's ETH Is Rebated (The Bid They Are Trying To Top Up Was Frontran)
     */
    event BidTopupRefunded(uint Rebate);

    /**
     * @dev Emitted When The Auction End Time Is Extended
     */
    event AuctionExtended();

    /**
     * @dev Emitted When A Bid Is Refunded (Kicked Back To Losing Bidder)
     */
    event BidRefunded(uint BidIndex);

    /*--------------
     * CONSTRUCTOR *
    ---------------*/

    constructor() 
    {
        Admin[msg.sender] = true; // sets owner as admin
        SaleState._Active = true; // activates auction
        SaleState._LastMinBid = 2.5 ether; // starts auction specified ETH value
        AuctionParams._Name = 'Hashmarks'; // sets auction name
        AuctionParams._KickbackEnabled = true; // enables kickback
        // AuctionParams._ClearingEnabled = false; // enables rebate last price
        // AuctionParams._UserSettlementEnabled = false; // enables self-service user auction settlement
        AuctionParams._LeaderboardSize = 50; // (max # of bids on leaderboard)
        AuctionParams._UnixStartTime = 1695052800; // sets auction start time
        AuctionParams._UnixEndTime = 1695225600; // sets auction end time
        AuctionParams._MinBIPSIncrease = 105; // 5% Increase On Each Subsequent Bid After 50 Unique Bids
        AuctionParams._SecondsExtension = 600 seconds; // # Of Seconds Of Extension
        AuctionParams._SecondsThreshold = 600 seconds; // # Of Seconds Within Auction End Time Where Auction Extension Is Enabled
        AuctionParams._NFT = 0x37fa4aCa3125660d4B8f4A6b1d0Ab8AF6a6C1f13; // Hashmarks Mint Pass
    }

    /*-----------------
     * USER FUNCTIONS *
    ------------------*/
    
    /**
     * @dev Submits A New Bid To The Auction
     * @param Vault Optional delegate.xyz Integration Input ('0x0000000000000000000000000000000000000000') If No Delegate
     */
    function NewBid(address Vault) external payable nonReentrant
    {
        require(tx.origin == msg.sender, "Auction: EOA Only, Use `delegate.cash` For Wallet Delegation"); // Requires `msg.sender` Is A Valid EOA
        require(SaleState._Active, "Auction: Auction Has Ended"); // Requires The Auction Is Active
        require(block.timestamp >= AuctionParams._UnixStartTime, "Auction: Auction Has Not Started"); // Requires The Auction Has Started
        require(block.timestamp < AuctionParams._UnixEndTime, "Auction: Auction Has Concluded"); // Requires The Auction Has Not Ended
        if(Vault != address(0)) { if(!DelegateCash.checkDelegateForAll(msg.sender, Vault)) { Vault = address(0); } } // `delegate.cash` Integration
        __FinalizeNewBid(msg.value); // Auto-Calculates The Required Reserve Price For The Bid (+5%)
        __CheckAndSeedAuctionEndTime(); // Checks If Auction End Time Should Be Extended And Extends If Necessary
        uint CurrentBidIndex = SaleState._GlobalUniqueBids; 
        Bids[CurrentBidIndex] = Bid(CurrentBidIndex, msg.value, block.timestamp, msg.sender, Vault, false, false, false); // Registers New Bid
        UserBidIndexes[msg.sender].push(CurrentBidIndex); // Appends Bid Index To User's Bid Indexes
        SaleState._GlobalUniqueBids = CurrentBidIndex + 1; // Increments Global Unique Bids
        emit NewBidComplete(CurrentBidIndex, msg.sender, msg.value, block.timestamp, Vault); // Emits Bid Event
    }

    /**
     * @dev Tops Up Bid(s) With Additional ETH
     * @param BidIndexes The Bid Indexes To Top Up
     * @param Amounts The Amounts (In WEI) To Top Up The Corresponding Bid Indexes By
     */
    function IncreaseBid(uint[] calldata BidIndexes, uint[] calldata Amounts) external payable nonReentrant
    {
        require(tx.origin == msg.sender, "Auction: EOA Only, Use `delegate.cash` For Wallet Delegation"); // Requires `msg.sender` Is A Valid EOA
        require(SaleState._Active, "Auction: Auction Has Ended"); // Requires The Auction Is Active
        require(block.timestamp >= AuctionParams._UnixStartTime, "Auction: Auction Has Not Started"); // Requires The Auction Has Started
        require(block.timestamp < AuctionParams._UnixEndTime, "Auction: Auction Has Concluded"); // Requires The Auction Has Not Ended
        require(BidIndexes.length == Amounts.length, "Auction: BidIndexes And Amounts Array Length Mismatch"); // Requires BidIndexes And Amounts Length Match
        require(BidIndexes.length > 0, "Auction: User Has Input No Bids To Top Up"); // Requires User Has Bids To Top Up
        require(AuctionParams._KickbackEnabled, "Auction: Cannot Top Up, Kickback Must Be Enabled For Entire Auction"); // Requires Kickback Is Enabled
        if(!AuctionParams._ClearingEnabled) { __CheckAndSeedAuctionEndTime(); } // Checks If Auction End Time Should Be Extended And Extends If Necessary
        Bid memory _Bid;
        uint Total;
        uint BidValue;
        for(uint x; x < BidIndexes.length; x++)
        { 
            _Bid = Bids[BidIndexes[x]];
            BidValue = _Bid._ETHValue;
            if(!_Bid._Rebated && !_Bid._Winner)
            {
                require(msg.sender == _Bid._Bidder, "Auction: `msg.sender` Is Not The Bidder Of Desired Bid Index");
                require(BidValue + Amounts[x] >= (BidValue * AuctionParams._MinBIPSIncrease) / 100, "Auction: Bid Amount Topup Requires >= 5% Increase");
                Bids[BidIndexes[x]]._ETHValue += Amounts[x];
                Bids[BidIndexes[x]]._Timestamp = block.timestamp;
                Total += Amounts[x];
                emit BidToppedUp(BidIndexes[x], Amounts[x], block.timestamp, msg.sender);
            }
        }
        uint Rebate = msg.value - Total;
        if(Rebate > 0)
        {
            (bool Success, ) = msg.sender.call { value: Rebate }("");
            require(Success, "Auction: Failed To Rebate Excess ETH To Bidder, Use Failsafe Withdraw");
            emit BidTopupRefunded(Rebate);
        }
    }

    /**
     * @dev Rebates ETH From Bid(s) If Bidder Is Not A Winner & Disperses NFTs If Winner
     */
    function UserSettleAuction() external nonReentrant
    {
        require(tx.origin == msg.sender, "Auction: EOA Only, Use `delegate.cash` For Wallet Delegation"); // Requires `msg.sender` Is A Valid EOA
        require(!SaleState._NFTsDispersed, "Auction: NFTs Have Been Dispersed");
        require(AuctionParams._KickbackEnabled, "Auction: Cannot Finalize, Kickback Must Be Enabled For Entire Auction");
        require(AuctionParams._UserSettlementEnabled, "Auction: User Settlement Is Not Enabled");
        require(UserBidIndexes[msg.sender].length > 0, "Auction: User Has No Bids To Settle");
        require(block.timestamp > AuctionParams._UnixEndTime, "Auction: Cannot Finalize, Auction Is Still Active");
        address Bidder = msg.sender;
        __UserDisperseETH(Bidder);
        __UserDisperseNFT(Bidder);
    }

    /*------------------
     * ADMIN FUNCTIONS *
    -------------------*/

    /**
     * @dev Starts Auction
     */
    function __StartAuction(Params memory AuctionInfo) external onlyAdmin 
    { 
        require(AuctionInfo._UnixStartTime > block.timestamp, "Auction: Start Time Must Be In The Future");
        if(AuctionInfo._UserSettlementEnabled) { require(AuctionInfo._KickbackEnabled, "Auction: Kickback & User Settlement Must Both Be Active"); }
        AuctionParams = AuctionInfo; 
        SaleState._LastMinBid = AuctionParams._InitialMinimumBid;
    }

    /**
     * @dev Changes The MintPass ProjectID
     */
    function ___ChangeMintPassProjectID(uint MintPassProjectID) external onlyAdmin { AuctionParams._ProjectIDMintPass = MintPassProjectID;}

    /**
     * @dev Changes The Auction Pause State
     */
    function ___ChangeActiveState() external onlyAdmin { SaleState._Active = !SaleState._Active; }

    /**
     * @dev Changes If The Lowest Valid Leaderboard Bid Gets Sent/Kicked Back Their ETH If Removed From Leaderboard
     */
    function ___ChangeKickbackEnabled(bool NewState) external onlyAdmin { AuctionParams._KickbackEnabled = NewState; }

    /**
     * @dev Changes Min Bid
     */
    function ___ChangeMinBid(uint NewMinBid) external onlyAdmin { SaleState._LastMinBid = NewMinBid; }
    
    /**
     * @dev Changes If The Lowest Valid Leaderboard Bid Is What Everyone 
     */
    function ___ChangeClearingEnabled(bool NewState) external onlyAdmin { AuctionParams._ClearingEnabled = NewState; }
    
    /**
     * @dev Changes The Bid Threshold (Controls The Leaderboard Size)
     */
    function ___ChangeLeaderboardSize(uint NewLeaderboardSize) external onlyAdmin { AuctionParams._LeaderboardSize = NewLeaderboardSize; }

    /**
     * @dev Changes The Unix Start Time
     */
    function ___ChangeUnixStartTime(uint NewUnixStartTime) external onlyAdmin { AuctionParams._UnixStartTime = NewUnixStartTime; }

    /**
     * @dev Changes The Unix End Time
     */
    function ___ChangeUnixEndTime(uint NewUnixEndTime) external onlyAdmin { AuctionParams._UnixEndTime = NewUnixEndTime; }

    /**
     * @dev Changes The Minimum BIPs Increase
     */
    function ___ChangeMinBIPSIncrease(uint NewMinBIPSIncrease) external onlyAdmin { AuctionParams._MinBIPSIncrease = NewMinBIPSIncrease; }

    /**
     * @dev Changes The # Of Seconds The Auction Is Extended By If Auction End Time Is Within `AuctionParams._SecondsThreshold`
     */
    function ___ChangeSecondsExtension(uint Seconds) external onlyAdmin { AuctionParams._SecondsExtension = Seconds; }

    /**
     * @dev Changes The # Of Seconsd Within Auction End Time To Be Eligible For Auction Extension
     */
    function ___ChangeSecondsThreshold(uint Seconds) external onlyAdmin { AuctionParams._SecondsThreshold = Seconds; }

    /**
     * @dev Changes The Current NFT Address
     */
    function ___ChangeNFTAddress(address NewAddress) external onlyAdmin { AuctionParams._NFT = NewAddress; }

    /**
     * @dev Changes The Current Operator Address (Address That Holds NFTs To Disperse)
     */
    function ___ChangeOperator(address Operator) external onlyAdmin { AuctionParams._Operator = Operator; }

    /**
     * @dev Rebate All Unclaimed Bids & Sends Remaining ETH To Multisig
     */
    function ___InitiateRebateAndProceeds() external onlyAdmin 
    { 
        SaleState._Active = false; // Ends Auction
        __AdminInitiateProceeds(); // Initiates Admin Withdraw Of Proceeds (MUST BE CALLED FIRST)
        __AdminInitiateRebate();   // Initiates Admin Withdraw Of Rebates (MUST BE CALLED SECOND)
    }

    /**
     * @dev Initiates Withdrawl Proceeds & Disperses NFTs To The Top Bidders On The Leaderboard (First-Come-First-Serve) (When TokenID Is Ambiguous)
     */
    function ___ProcessETHAndNFTsTokenIDsAmbiguous() external onlyAdmin
    {
        SaleState._Active = false;       // Ends Auction
        __AdminInitiateProceeds();       // Initiates Admin Withdraw Of Proceeds (MUST BE CALLED FIRST)
        __AdminInitiateRebate();         // Initiates Admin Withdraw Of Rebates (MUST BE CALLED SECOND)
        __DisperseNFTsByFCFSAmbiguous(); // Initiates Admin Disperse Of NFTs (MUST BE CALLED LAST)
    }

    /**
     * @dev Initiates Withdrawl Proceeds & Disperses NFTs To The Top Bidders On The Leaderboard (Ascending Ranking) (When TokenID Matters)
     */
    function ___ProcessETHAndNFTsTokenIDsDistinct() external onlyAdmin
    {
        SaleState._Active = false;       // Ends Auction
        __AdminInitiateProceeds();       // Initiates Admin Withdraw Of Proceeds (MUST BE CALLED FIRST)
        __AdminInitiateRebate();         // Initiates Admin Withdraw Of Rebates (MUST BE CALLED SECOND)
        __DisperseNFTsByAscendingRank(); // Initiates Admin Disperse Of NFTs (MUST BE CALLED LAST)
    }

    /**
     * @dev Initiates Withdrawl Proceeds & Disperses NFTs To The Top Bidders On The Leaderboard With Specific TokenIDs (No Ranking)
     */
    function ___ProcessETHAndNFTsTokenIDsSpecific(uint[] calldata TokenIDs) external onlyAdmin
    {
        SaleState._Active = false;                // Ends Auction
        __AdminInitiateProceeds();                // Initiates Admin Withdraw Of Proceeds (MUST BE CALLED FIRST)
        __AdminInitiateRebate();                  // Initiates Admin Withdraw Of Rebates (MUST BE CALLED SECOND)
        __DisperseNFTsByUniqueTokenIDs(TokenIDs); // Initiates Admin Disperse Of NFTs (MUST BE CALLED LAST)
    }

    /**
     * @dev Initiates Withdrawl Proceeds & Disperses NFTs To The Top Bidders On The Leaderboard With Specific TokenIDs (Ascending Ranking)
     */
    function ___ProcessETHAndNFTsTokenIDsSpecificAscending(uint[] calldata TokenIDs) external onlyAdmin
    {
        SaleState._Active = false;                         // Ends Auction
        __AdminInitiateProceeds();                         // Initiates Admin Withdraw Of Proceeds (MUST BE CALLED FIRST)
        __AdminInitiateRebate();                           // Initiates Admin Withdraw Of Rebates (MUST BE CALLED SECOND)
        __DisperseNFTsByUniqueTokenIDsAscending(TokenIDs); // Initiates Admin Disperse Of NFTs (MUST BE CALLED LAST)
    }

    /*------------------
     * OWNER FUNCTIONS *
    -------------------*/

    /**
     * @dev Adds An Admin
     */
    function ____NewAdmin(address Wallet) external onlyOwner { Admin[Wallet] = true; }

    /**
     * @dev Removes An Admin
     */
    function ____AdminRemove(address Wallet) external onlyOwner { Admin[Wallet] = false; }

    /**
     * @dev Initiates Withdrawl Proceeds For The Leaderboard
     */
    function ____InitiateOnlyProceeds() external onlyOwner { __AdminInitiateProceeds(); }

    /**
     * @dev Initiates Rebate Processing For All Unclaimed Bids
     */
    function ____InitiateOnlyRebates() external onlyOwner { __AdminInitiateRebate(); }

    /**
     * @dev Withdraws All Ether From The Contract
     */
    function ____WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }

    /**
     * @dev Withdraws Ether From Contract To Address With An Amount
     */
    function ____WithdrawEtherToAddress(address payable Recipient, uint Amount) external onlyOwner
    {
        require(Amount > 0 && Amount <= address(this).balance, "Invalid Amount");
        (bool Success, ) = Recipient.call{value: Amount}("");
        require(Success, "Unable to Withdraw, Recipient May Have Reverted");
    }

    /*---------------------
     * INTERNAL FUNCTIONS *
    ----------------------*/

    /**
     * @dev Calculates The Minimum Valid Bid And Seeds The Leaderboard
     */
    function __FinalizeNewBid(uint MsgValue) internal
    {
        (uint MinBid, uint LeaderboardIndex) = _ViewMinimumValidBidAndIndex();
        require(MsgValue >= MinBid, "Auction: Bid Amount Must Be >= 1.05% * Current Leaderboard Floor"); // Requires Min Bid
        bool Valid = (SaleState._GlobalUniqueBids >= AuctionParams._LeaderboardSize);
        if(AuctionParams._KickbackEnabled && Valid) { __KickbackETH(LeaderboardIndex); } // Rebate ETH To Previous Bidder
        if(Valid) { SaleState._LastMinBid = MinBid; }
        Leaderboard[LeaderboardIndex] = SaleState._GlobalUniqueBids; // Kicks Old Bid Index Out Of Leaderboard
    }

    /**
     * @dev Kicks Losing Bidder ETH Back To Them
     */
    function __KickbackETH(uint LeaderboardIndex) internal 
    {
        if(!Bids[Leaderboard[LeaderboardIndex]]._Rebated)
        {
            Bids[Leaderboard[LeaderboardIndex]]._Rebated = true;
            (bool Success,) = Bids[Leaderboard[LeaderboardIndex]]._Bidder.call { value: Bids[Leaderboard[LeaderboardIndex]]._ETHValue }("");
            require(Success, "Auction: Kickback Failed");
            emit BidRefunded(Leaderboard[LeaderboardIndex]);
        } 
    }

    /**
     * @dev Finalizes ETH From User's Pending Bid(s)
     */
    function __UserDisperseETH(address Bidder) internal
    {
        uint[] memory _UserBidIndexes = UserBidIndexes[Bidder];
        uint LLB = _ViewLowestLeaderboardBid();
        uint TotalRebate;
        uint TotalPaid;
        uint CurrentRebate;
        uint CurrentPaid;
        for(uint x; x < UserBidIndexes[Bidder].length; x++) 
        { 
            if(!Bids[_UserBidIndexes[x]]._Winner && !Bids[_UserBidIndexes[x]]._Rebated && Bids[_UserBidIndexes[x]]._ETHValue >= LLB)
            {
                Bids[UserBidIndexes[Bidder][x]]._Winner = true; 
                if(AuctionParams._ClearingEnabled) 
                { 
                    Bids[_UserBidIndexes[x]]._Rebated = true; 
                    CurrentRebate = Bids[_UserBidIndexes[x]]._ETHValue - LLB;
                    CurrentPaid = Bids[_UserBidIndexes[x]]._ETHValue - CurrentRebate;
                    TotalRebate += CurrentRebate;
                    TotalPaid += CurrentPaid;
                }
                else { TotalPaid += Bids[_UserBidIndexes[x]]._ETHValue; }
            }
        }
        (bool MultisigWithdraw, ) = _BRT_MULTISIG.call { value: TotalPaid }("");
        require(MultisigWithdraw, "Auction: Multisig Withdraw Failed");

        (bool UserWithdraw, ) = Bidder.call { value: TotalRebate }("");
        require(UserWithdraw, "Auction: User Withdraw Failed");
    }

    /**
     * @dev Disperses NFTs
     */
    function __UserDisperseNFT(address Bidder) internal
    {
        IERC721 _NFT = IERC721(AuctionParams._NFT);
        for(uint x; x < UserBidIndexes[Bidder].length; x++) 
        { 
            if(Bids[UserBidIndexes[Bidder][x]]._Winner && !Bids[UserBidIndexes[Bidder][x]]._NFTSent)
            {
                Bids[UserBidIndexes[Bidder][x]]._NFTSent = true;
                _NFT._MintToFactory(Bidder, 1); 
            }
        }
    }

    /**
     * @dev Initiates Proceeds From The Leaderboard
     */
    function __AdminInitiateProceeds() internal
    {
        uint TotalProceeds;
        uint LLB = _ViewLowestLeaderboardBid();
        uint RebateAmount;
        for(uint x; x < AuctionParams._LeaderboardSize; x++)
        {
            if(!Bids[Leaderboard[x]]._Rebated && !Bids[Leaderboard[x]]._Winner && Bids[Leaderboard[x]]._ETHValue >= LLB)
            {
                Bids[Leaderboard[x]]._Winner = true;
                if(AuctionParams._ClearingEnabled)
                {
                    Bids[Leaderboard[x]]._Rebated = true;
                    RebateAmount = Bids[Leaderboard[x]]._ETHValue - LLB;
                    if(RebateAmount > 0)
                    {
                        (bool Rebate, ) = Bids[Leaderboard[x]]._Bidder.call { value: RebateAmount }("");                    
                        require(Rebate, "Auction: Failed To Rebate ETH To Bidder, Use Failsafe Withdraw");
                    }
                }
                TotalProceeds += (Bids[Leaderboard[x]]._ETHValue - RebateAmount);
            }
        }
        if(TotalProceeds > 0)
        {
            (bool MultisigWithdraw, ) = _BRT_MULTISIG.call{ value: TotalProceeds }("");
            require(MultisigWithdraw, "Auction: Admin Failed To Withdraw ETH To Multisig, Use Failsafe Withdraw");
        }
    }

    /**
     * @dev Validates The Auction End Time & Extends If Necessary
     */
    function __CheckAndSeedAuctionEndTime() internal 
    {
        // Extends Auction If Rebate Last Price (Clearing Price) Is Not Enabled (For Sales Where Leaderboard Placement Matters)
        if((AuctionParams._UnixEndTime - block.timestamp) < AuctionParams._SecondsThreshold) // If Bid Placed In Last 5 Minutes
        { 
            AuctionParams._UnixEndTime = block.timestamp + AuctionParams._SecondsExtension; // Extends Auction By The # Of Configured Seconds 
            emit AuctionExtended();
        }
    }

    /**
     * @dev Initiates Rebates For All Unclaimed Bids
     */
    function __AdminInitiateRebate() internal
    {
        for(uint x; x < SaleState._GlobalUniqueBids; x++)
        {
            if(!Bids[x]._Rebated && !Bids[x]._Winner) // If Bid Is Not Rebated & Is Not A Winning Bid, Rebate ETH
            {
                Bids[x]._Rebated = true;
                (bool Rebate, ) = Bids[x]._Bidder.call { value: Bids[x]._ETHValue }("");
                if(!Rebate) { emit BidReclaimFailed(x); }
            }
        }
    }

    /**
     * @dev Disperses NFTs With Unique TokenIDs
     * @param TokenIDs Array Of TokenIDs To Be Dispersed
     */
    function __DisperseNFTsByUniqueTokenIDs(uint[] calldata TokenIDs) internal
    {
        require(!SaleState._Active, "Auction: Auction Is Still Active, Must Disperse Funds & Finalize Auction First");
        require(!SaleState._NFTsDispersed, "Auction: NFTs Already Dispersed");
        require(TokenIDs.length == AuctionParams._LeaderboardSize, "Auction: TokenIDs Array Length Must Match Leaderboard Size");
        address _Op = AuctionParams._Operator;
        IERC721 _NFT = IERC721(AuctionParams._NFT);
        for(uint x; x < TokenIDs.length; x++)
        {
            require(!NFTTokenIDHasBeenSent[TokenIDs[x]], "Auction: TokenID Already Sent");
            NFTTokenIDHasBeenSent[TokenIDs[x]] = true;
            _NFT.transferFrom(_Op, Bids[Leaderboard[x]]._Bidder, TokenIDs[x]);
        }
    }

    /**
     * @dev Disperses NFTs With Unique TokenIDs
     * @param TokenIDs Array Of TokenIDs To Be Dispersed
     */
    function __DisperseNFTsByUniqueTokenIDsAscending(uint[] calldata TokenIDs) internal
    {
        require(!SaleState._Active, "Auction: Auction Is Still Active, Must Disperse Funds & Finalize Auction First");
        require(!SaleState._NFTsDispersed, "Auction: NFTs Already Dispersed");
        require(TokenIDs.length == AuctionParams._LeaderboardSize, "Auction: TokenIDs Array Length Must Match Leaderboard Size");
        uint[] memory _Ind = _ViewSortedLeaderboardBidIndexes();
        address _Op = AuctionParams._Operator;
        IERC721 _NFT = IERC721(AuctionParams._NFT);
        for(uint x; x < TokenIDs.length; x++)
        {
            require(!NFTTokenIDHasBeenSent[TokenIDs[x]], "Auction: TokenID Already Sent");
            NFTTokenIDHasBeenSent[TokenIDs[x]] = true;
            _NFT.transferFrom(_Op, Bids[_Ind[x]]._Bidder, TokenIDs[x]);
        }
    }

    /**
     * @dev Disperses NFTs To The Top Bidders On The Leaderboard (First-Come-First-Serve) (Use When TokenID Is Ambiguous)
     */
    function __DisperseNFTsByFCFSAmbiguous() internal
    {
        require(!SaleState._Active, "Auction: Auction Is Still Active, Must Disperse Funds & Finalize Auction First");
        require(!SaleState._NFTsDispersed, "Auction: NFTs Already Dispersed");
        SaleState._NFTsDispersed = true;
        IERC721 _NFT = IERC721(AuctionParams._NFT);
        for(uint x; x < AuctionParams._LeaderboardSize; x++) 
        { 
            if(Bids[Leaderboard[x]]._Winner && !Bids[Leaderboard[x]]._NFTSent)
            {
                Bids[Leaderboard[x]]._NFTSent = true;
                _NFT._MintToFactory(Bids[Leaderboard[x]]._Bidder, 1); 
            }
        }
    }

    /**
     * @dev Disperses NFTs By Ascending Ranking Of The Leaderboard (Use When TokenID Matters)
     */
    function __DisperseNFTsByAscendingRank() internal
    {
        require(SaleState._Active == false, "Auction: Auction Is Still Active, Must Disperse Funds First");
        require(!SaleState._NFTsDispersed, "Auction: NFTs Already Dispersed");
        SaleState._NFTsDispersed = true;
        IERC721 _NFT = IERC721(AuctionParams._NFT);
        uint[] memory _Ind = _ViewSortedLeaderboardBidIndexes();
        for(uint x; x < _Ind.length; x++)
        { 
            if(Bids[_Ind[x]]._Winner && !Bids[_Ind[x]]._NFTSent)
            {
                Bids[_Ind[x]]._NFTSent = true;
                _NFT._MintToFactory(Bids[_Ind[x]]._Bidder, 1); 
            }
        }
    }

    /*------------------------
     * PUBLIC VIEW FUNCTIONS *
    -------------------------*/

    /**
     * @dev Returns All Necessary Leaderboard Components
     * @param Wallet The Wallet Address Of The Bidder ('0x0000000000000000000000000000000000000000') If No Wallet
     */
    function ViewFrontend(address Wallet) public view returns (
        uint _LLB, 
        uint _MVB, 
        AllAuctionParams memory _AuctionParams, 
        Bid[] memory _RankedLeaderboard,
        Bid[] memory _MasterBids,
        uint[] memory _UserBidIndexes
    ) {
        uint LLB = _ViewLowestLeaderboardBid();
        _MasterBids = _ViewBidsUnique();
        _RankedLeaderboard = _ViewLeaderboardRanked();
        uint MVB = LLB * (AuctionParams._MinBIPSIncrease) / 100;
        if(SaleState._GlobalUniqueBids < AuctionParams._LeaderboardSize) { (LLB, MVB) = (SaleState._LastMinBid, SaleState._LastMinBid); }
        return (
            LLB,
            MVB,
            ViewAuctionParams(),
            ViewLeaderboardRanked(),
            _MasterBids,
            UserBidIndexes[Wallet]
        );
    }

    /**
     * @dev Returns The Total Bid Volume Of The Auction
     */
    function ViewTotalBidVolume() public view returns (uint) 
    { 
        uint TotalBidVolume;
        for(uint x; x < SaleState._GlobalUniqueBids; x++) { TotalBidVolume += Bids[x]._ETHValue; }
        return TotalBidVolume;
    }

    /**
     * @dev Returns The Total Proceeds For An Auction
     */
    function ViewTotalProceeds() public view returns (uint)
    {
        uint LLB = _ViewLowestLeaderboardBid();
        uint Rev;
        uint Rebate;
        for(uint x; x < AuctionParams._LeaderboardSize; x++) 
        { 
            if(AuctionParams._ClearingEnabled) { Rebate = Bids[Leaderboard[x]]._ETHValue - LLB; }
            Rev += Bids[Leaderboard[x]]._ETHValue - Rebate; 
        }
        return Rev;
    }

    /**
     * @dev Returns The Total Rebates For An Auction
     */
    function ViewTotalRebate() public view returns(uint) { return (ViewTotalBidVolume() - ViewTotalProceeds()); }

    /**
     * @dev Returns A `bool` If Math Checks Out
     */
    function ViewTotalBalanceResult() public view returns (bool)
    {
        return(ViewTotalBidVolume() - ViewTotalRebate() - ViewTotalProceeds() == 0);
    }

    /**
     * @dev Returns A Raw Sum Of The ETH Volume From The Leaderboard
     */
    function ViewLeaderboardTotalBidVolume() public view returns(uint)
    {
        uint TotalBidVolume;
        for(uint x; x < AuctionParams._LeaderboardSize; x++) 
        { 
            TotalBidVolume += Bids[Leaderboard[x]]._ETHValue;
        }
        return TotalBidVolume;
    }

    /**
     * @dev Returns A Raw Sum Of The ETH Volume From The Leaderboard
     */
    function ViewLeaderboardTotalBidValue() public view returns(uint)
    {
        uint LLB = _ViewLowestLeaderboardBid();
        uint Rebate;
        uint TotalBidValue;
        for(uint x; x < AuctionParams._LeaderboardSize; x++) 
        { 
            if(AuctionParams._ClearingEnabled) { Rebate = Bids[Leaderboard[x]]._ETHValue - LLB; }
            TotalBidValue += (Bids[Leaderboard[x]]._ETHValue - Rebate);
        }
        return TotalBidValue;
    }

    /**
     * @dev Returns All Bid Values In The Leaderboard
     */
    function ViewLeaderboardBids() public view returns (uint[] memory)
    {
        uint[] memory _Indexes = ViewLeaderboardIndexes();
        uint[] memory _BidValues = new uint[](AuctionParams._LeaderboardSize);
        for(uint x; x < AuctionParams._LeaderboardSize; x++) { _BidValues[x] = Bids[_Indexes[x]]._ETHValue; }
        return _BidValues;
    }

    /**
     * @dev Returns The Current Bid Leaderboard
     */
    function ViewLeaderboardRaw() public view returns (Bid[] memory)
    {
        Bid[] memory _Leaderboard = new Bid[](AuctionParams._LeaderboardSize);
        for(uint x; x < AuctionParams._LeaderboardSize; x++) { _Leaderboard[x] = Bids[Leaderboard[x]]; }
        return _Leaderboard;
    }

    /**
     * @dev Returns A Bid Array Of Ranked Top Bids
     */
    function ViewLeaderboardRanked() public view returns(Bid[] memory) { return _ViewLeaderboardRanked(); }

    /**
     * @dev Returns All Bid Indexes In The Leaderboard
     */
    function ViewLeaderboardIndexes() public view returns (uint[] memory)
    {
        uint[] memory _LeaderboardIndexes = new uint[](AuctionParams._LeaderboardSize);
        for(uint x; x < AuctionParams._LeaderboardSize; x++) { _LeaderboardIndexes[x] = Leaderboard[x]; }
        return _LeaderboardIndexes;
    }

    /**
     * @dev Returns A Individual 'Bid' Struct Corresponding To Input Index
     */
    function ViewBid(uint Index) public view returns (Bid memory) { return Bids[Index]; }

    /**
     * @dev Returns The Minimum Valid Bid 
     */
    function ViewMinimumValidBid() public view returns (uint ValidBid) 
    { 
        (ValidBid,) = _ViewMinimumValidBidAndIndex();
        return ValidBid;
    }

    /**
     * @dev Returns A 'Bid' Struct Array Corresponding To Input Indexes
     */
    function ViewBidsAtIndexes(uint[] calldata Indexes) public view returns(Bid[] memory) 
    {
        Bid[] memory _Bids = new Bid[](Indexes.length);
        for(uint x; x < Indexes.length; x++) { _Bids[x] = Bids[Indexes[x]]; }
        return _Bids;
    }

    /**
     * @dev Returns A 'Bid' Struct Array Of All Unique Bids In The Auction
     * note: this will throw `out of gas` after 1648~ unique bids because block gas limit is 30M, use `ViewBids()` with indexes after 1648~ unique bids
     */
    function ViewBidsUnique() public view returns(Bid[] memory) { return _ViewBidsUnique(); }

    /**
     * @dev Returns A `Bid` Struct Array Of All Unique Bids In The Auction Submitted By `Wallet`
     */
    function ViewWalletBids(address Wallet) public view returns(Bid[] memory)
    {
        uint[] memory _Indexes = UserBidIndexes[Wallet];
        Bid[] memory _Bids = new Bid[](_Indexes.length);
        for(uint x; x < _Indexes.length; x++) { _Bids[x] = Bids[_Indexes[x]]; }
        return _Bids;
    }

    /**
     * @dev Returns An Array Of `Wallet` Submitted Bid Indexes
     */
    function ViewWalletBidIndexes(address Wallet) public view returns(uint[] memory) { return UserBidIndexes[Wallet]; }

    /**
     * @dev Returns All Of The Current Auction Parameters
     */
    function ViewAuctionParams() public view returns (AllAuctionParams memory)
    {
        return AllAuctionParams (
            AuctionParams._Name,
            SaleState._Active,
            SaleState._NFTsDispersed,
            AuctionParams._KickbackEnabled,
            AuctionParams._ClearingEnabled,
            AuctionParams._LeaderboardSize,
            AuctionParams._UnixStartTime,
            AuctionParams._UnixEndTime,
            AuctionParams._MinBIPSIncrease,
            AuctionParams._SecondsExtension,
            AuctionParams._SecondsThreshold,
            SaleState._LastMinBid,
            SaleState._GlobalUniqueBids,
            AuctionParams._ProjectIDMintPass,
            AuctionParams._NFT
        );
    }

    /**
     * @dev Returns A Sorted uint[] Of Leaderboard Bid Indexes
     */
    function ViewSortLeaderboardBidIndexes() public view returns (uint[] memory) { return _ViewSortedLeaderboardBidIndexes(); }

    /*--------------------------
     * INTERNAL VIEW FUNCTIONS *
    ---------------------------*/

    /**
     * @dev Returns The Leaderboard Index Of The Smallest Bid In The Leaderboard 
     */
    function _ViewMinimumValidLeaderboardIndex() internal view returns (uint)
    {
        uint CurrentMinBid = type(uint).max;
        uint LeaderboardIndexToReplace;
        uint ETHValue;
        if(SaleState._GlobalUniqueBids < AuctionParams._LeaderboardSize) { return SaleState._GlobalUniqueBids; }
        for(uint IndexLeaderboard; IndexLeaderboard < AuctionParams._LeaderboardSize; IndexLeaderboard++)
        {
            ETHValue = Bids[Leaderboard[IndexLeaderboard]]._ETHValue;
            if(ETHValue <= CurrentMinBid)
            { 
                CurrentMinBid = ETHValue;
                LeaderboardIndexToReplace = IndexLeaderboard; 
            }
        }
        return LeaderboardIndexToReplace;
    }

    /**
     * @dev Returns The Lowest Bid In The Leaderboard
     */
    function _ViewLowestLeaderboardBid() internal view returns (uint LLB)
    {
        LLB = type(uint).max;
        for(uint x; x < AuctionParams._LeaderboardSize; x++)
        {
            if(Bids[Leaderboard[x]]._ETHValue < LLB) { LLB = Bids[Leaderboard[x]]._ETHValue; }
        }
        return LLB;
    }

    /**
     * @dev Returns The Minimum Valid Bid Which Is The Current Lowest Bid In The Leaderboard * 1.05
     */
    function _ViewMinimumValidBidAndIndex() internal view returns (uint, uint) 
    {
        uint LeaderboardIndex = _ViewMinimumValidLeaderboardIndex();
        return (        
            SaleState._GlobalUniqueBids < AuctionParams._LeaderboardSize 
            ? // If Unique Bids Less Than LeaderboardSize
            (SaleState._LastMinBid, LeaderboardIndex) // Return NewMinimumBid & Eligible LeaderboardIndex
            : // Else
            ((Bids[Leaderboard[LeaderboardIndex]]._ETHValue * AuctionParams._MinBIPSIncrease) / 100, LeaderboardIndex) // Return NewMinimumBid & Eligible LeaderboardIndex
        );
    }

    /**
     * @dev Returns A 'Bid' Struct Array Of All Unique Bids In The Auction
     * note: this will throw `out of gas` after 1648~ unique bids because block gas limit is 30M, use `ViewBids()` with indexes after 1648~ unique bids
     */
    function _ViewBidsUnique() internal view returns(Bid[] memory)
    {
        uint GlobalUniqueBids = SaleState._GlobalUniqueBids;
        Bid[] memory _Bids = new Bid[](GlobalUniqueBids);
        for(uint x; x < GlobalUniqueBids; x++) { _Bids[x] = Bids[x]; }
        return _Bids;
    }
    
    /**
     * @dev Returns A Bid Array Of Ranked Top Bids
     */
    function _ViewLeaderboardRanked() internal view returns(Bid[] memory)
    {
        uint[] memory _Ind = _ViewSortedLeaderboardBidIndexes();
        Bid[] memory _Leaderboard = new Bid[](_Ind.length);
        for(uint x; x < _Ind.length; x++) { _Leaderboard[x] = Bids[_Ind[x]]; }
        return _Leaderboard;
    }

    /**
     * @dev Returns A Sorted List Of ETH Bids @ '[n][0]' And The Indexes Of The Original Bids @ '[n][1]'
     * note: This Will Give Priority To Earlier Bid Indexes & Timestamps
     * note: insertion sort O(n^2) seemed like best approach because english auction bids increase as auction progresses, otherwise quicksort prob better O(nlogn)
     * note: because block gas limit is 30M, this will `out-of-gas` dependant on how much sorting needs done if you have a more eloquent way of doing this hmu
     * note: you should (in general) not sort large things in solidity (as of 0.8~) because it is very gas inefficient, this is just for demonstration purposes
     */
    function _ViewSortedLeaderboardBidIndexes() internal view returns (uint[] memory)
    {
        uint Size;
        if(SaleState._GlobalUniqueBids < AuctionParams._LeaderboardSize) { Size = SaleState._GlobalUniqueBids; }
        else { Size = AuctionParams._LeaderboardSize; }
        uint[][] memory BidsAndIndexes = new uint[][](Size);
        for(uint x; x < BidsAndIndexes.length; x++) 
        {
            BidsAndIndexes[x] = new uint[](3);                      // Init Sub-Array
            BidsAndIndexes[x][0] = Bids[Leaderboard[x]]._ETHValue;  // Assign [x][0] -> ETHValue
            BidsAndIndexes[x][1] = Leaderboard[x];                  // Assign [x][1] -> Original Index
            BidsAndIndexes[x][2] = Bids[Leaderboard[x]]._Timestamp; // Assign [x][2] -> Timestamp
        }
        for(uint i; i < BidsAndIndexes.length; i++)
        {
            uint ETHValue = BidsAndIndexes[i][0];   // Preserve ETHValue
            uint OGBidIndex = BidsAndIndexes[i][1]; // Preserve OGBidIndex
            uint Timestamp = BidsAndIndexes[i][2];  // Preserve Timestamp
            uint j = i;
            while(j > 0 && BidsAndIndexes[j-1][0] >= ETHValue)
            {
                if(
                    BidsAndIndexes[j-1][0] == ETHValue && BidsAndIndexes[j-1][1] > OGBidIndex // Preserve Lower Original Index
                    ||
                    BidsAndIndexes[j-1][0] == ETHValue && BidsAndIndexes[j-1][2] > Timestamp  // Preserve Lower Timestamp
                ) { break; } 
                BidsAndIndexes[j][0] = BidsAndIndexes[j-1][0]; // Move Larger Element To The Right
                BidsAndIndexes[j][1] = BidsAndIndexes[j-1][1]; // Move OG Index
                BidsAndIndexes[j][2] = BidsAndIndexes[j-1][2]; // Move Timestamp
                j--;
            }
            BidsAndIndexes[j][0] = ETHValue;   // Insert ETHValue In Correct Location
            BidsAndIndexes[j][1] = OGBidIndex; // Insert OGBidIndex In Correct Location
            BidsAndIndexes[j][2] = Timestamp;  // Insert Timestamp In Correct Location
        } 
        uint[] memory SortedBidIndexes = new uint[](Size);
        for(uint y; y < BidsAndIndexes.length; y++) { SortedBidIndexes[Size - 1 - y] = BidsAndIndexes[y][1]; }
        return SortedBidIndexes;
    }

    /**
     * @dev onlyAdmin Modifier
     */
    modifier onlyAdmin
    {
        require(Admin[msg.sender], "Auction: onlyAdmin: Caller Is Not Admin");
        _;
    }
}

/**
 * @dev Interface For ERC721 Contracts
 */
interface IERC721 
{ 
    /**
     * @dev Mints A NFT From Custom Smart Contract Directly
     */
    function _MintToFactory(address, uint) external; 

    /**
     * @dev Transfers An Already Minted NFT
     */
    function transferFrom(address from, address to, uint tokenID) external;
}