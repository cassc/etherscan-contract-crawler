{"SourceCode": "# pragma version 0.3.10\r\n# pragma optimize gas\r\n# pragma evm-version paris\r\n\"\"\"\r\n@title CurveTwocryptoOptimized\r\n@author Curve.Fi\r\n@license Copyright (c) Curve.Fi, 2023 - all rights reserved\r\n@notice A Curve AMM pool for 2 unpegged assets (e.g. WETH, USD).\r\n@dev All prices in the AMM are with respect to the first token in the pool.\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\nimplements: ERC20  # <--------------------- AMM contract is also the LP token.\r\n\r\n# --------------------------------- Interfaces -------------------------------\r\n\r\ninterface Math:\r\n    def wad_exp(_power: int256) -> uint256: view\r\n    def newton_D(\r\n        ANN: uint256,\r\n        gamma: uint256,\r\n        x_unsorted: uint256[N_COINS],\r\n        K0_prev: uint256\r\n    ) -> uint256: view\r\n    def get_y(\r\n        ANN: uint256,\r\n        gamma: uint256,\r\n        x: uint256[N_COINS],\r\n        D: uint256,\r\n        i: uint256,\r\n    ) -> uint256[2]: view\r\n    def get_p(\r\n        _xp: uint256[N_COINS],\r\n        _D: uint256,\r\n        _A_gamma: uint256[2],\r\n    ) -> uint256: view\r\n\r\ninterface Factory:\r\n    def admin() -> address: view\r\n    def fee_receiver() -> address: view\r\n    def views_implementation() -> address: view\r\n\r\ninterface Views:\r\n    def calc_token_amount(\r\n        amounts: uint256[N_COINS], deposit: bool, swap: address\r\n    ) -> uint256: view\r\n    def get_dy(\r\n        i: uint256, j: uint256, dx: uint256, swap: address\r\n    ) -> uint256: view\r\n    def get_dx(\r\n        i: uint256, j: uint256, dy: uint256, swap: address\r\n    ) -> uint256: view\r\n\r\n\r\n# ------------------------------- Events -------------------------------------\r\n\r\nevent Transfer:\r\n    sender: indexed(address)\r\n    receiver: indexed(address)\r\n    value: uint256\r\n\r\nevent Approval:\r\n    owner: indexed(address)\r\n    spender: indexed(address)\r\n    value: uint256\r\n\r\nevent TokenExchange:\r\n    buyer: indexed(address)\r\n    sold_id: uint256\r\n    tokens_sold: uint256\r\n    bought_id: uint256\r\n    tokens_bought: uint256\r\n    fee: uint256\r\n    packed_price_scale: uint256\r\n\r\nevent AddLiquidity:\r\n    provider: indexed(address)\r\n    token_amounts: uint256[N_COINS]\r\n    fee: uint256\r\n    token_supply: uint256\r\n    packed_price_scale: uint256\r\n\r\nevent RemoveLiquidity:\r\n    provider: indexed(address)\r\n    token_amounts: uint256[N_COINS]\r\n    token_supply: uint256\r\n\r\nevent RemoveLiquidityOne:\r\n    provider: indexed(address)\r\n    token_amount: uint256\r\n    coin_index: uint256\r\n    coin_amount: uint256\r\n    approx_fee: uint256\r\n    packed_price_scale: uint256\r\n\r\nevent NewParameters:\r\n    mid_fee: uint256\r\n    out_fee: uint256\r\n    fee_gamma: uint256\r\n    allowed_extra_profit: uint256\r\n    adjustment_step: uint256\r\n    ma_time: uint256\r\n    xcp_ma_time: uint256\r\n\r\nevent RampAgamma:\r\n    initial_A: uint256\r\n    future_A: uint256\r\n    initial_gamma: uint256\r\n    future_gamma: uint256\r\n    initial_time: uint256\r\n    future_time: uint256\r\n\r\nevent StopRampA:\r\n    current_A: uint256\r\n    current_gamma: uint256\r\n    time: uint256\r\n\r\nevent ClaimAdminFee:\r\n    admin: indexed(address)\r\n    tokens: uint256[N_COINS]\r\n\r\n\r\n# ----------------------- Storage/State Variables ----------------------------\r\n\r\nN_COINS: constant(uint256) = 2\r\nPRECISION: constant(uint256) = 10**18  # <------- The precision to convert to.\r\nPRECISIONS: immutable(uint256[N_COINS])\r\n\r\nMATH: public(immutable(Math))\r\ncoins: public(immutable(address[N_COINS]))\r\nfactory: public(immutable(Factory))\r\n\r\ncached_price_scale: uint256  # <------------------------ Internal price scale.\r\ncached_price_oracle: uint256  # <------- Price target given by moving average.\r\ncached_xcp_oracle: uint256  # <----------- EMA of totalSupply * virtual_price.\r\n\r\nlast_prices: public(uint256)\r\nlast_timestamp: public(uint256)    # idx 0 is for prices, idx 1 is for xcp.\r\nlast_xcp: public(uint256)\r\nxcp_ma_time: public(uint256)\r\n\r\ninitial_A_gamma: public(uint256)\r\ninitial_A_gamma_time: public(uint256)\r\n\r\nfuture_A_gamma: public(uint256)\r\nfuture_A_gamma_time: public(uint256)  # <------ Time when ramping is finished.\r\n#         This value is 0 (default) when pool is first deployed, and only gets\r\n#        populated by block.timestamp + future_time in `ramp_A_gamma` when the\r\n#                      ramping process is initiated. After ramping is finished\r\n#      (i.e. self.future_A_gamma_time < block.timestamp), the variable is left\r\n#                                                            and not set to 0.\r\n\r\nbalances: public(uint256[N_COINS])\r\nD: public(uint256)\r\nxcp_profit: public(uint256)\r\nxcp_profit_a: public(uint256)  # <--- Full profit at last claim of admin fees.\r\n\r\nvirtual_price: public(uint256)  # <------ Cached (fast to read) virtual price.\r\n#                          The cached `virtual_price` is also used internally.\r\n\r\n# Params that affect how price_scale get adjusted :\r\npacked_rebalancing_params: public(uint256)  # <---------- Contains rebalancing\r\n#               parameters allowed_extra_profit, adjustment_step, and ma_time.\r\n\r\n# Fee params that determine dynamic fees:\r\npacked_fee_params: public(uint256)  # <---- Packs mid_fee, out_fee, fee_gamma.\r\n\r\nADMIN_FEE: public(constant(uint256)) = 5 * 10**9  # <----- 50% of earned fees.\r\nMIN_FEE: constant(uint256) = 5 * 10**5  # <-------------------------- 0.5 BPS.\r\nMAX_FEE: constant(uint256) = 10 * 10**9\r\nNOISE_FEE: constant(uint256) = 10**5  # <---------------------------- 0.1 BPS.\r\n\r\n# ----------------------- Admin params ---------------------------------------\r\n\r\nlast_admin_fee_claim_timestamp: uint256\r\nadmin_lp_virtual_balance: uint256\r\n\r\nMIN_RAMP_TIME: constant(uint256) = 86400\r\nMIN_ADMIN_FEE_CLAIM_INTERVAL: constant(uint256) = 86400\r\n\r\nA_MULTIPLIER: constant(uint256) = 10000\r\nMIN_A: constant(uint256) = N_COINS**N_COINS * A_MULTIPLIER / 10\r\nMAX_A: constant(uint256) = N_COINS**N_COINS * A_MULTIPLIER * 1000\r\nMAX_A_CHANGE: constant(uint256) = 10\r\nMIN_GAMMA: constant(uint256) = 10**10\r\nMAX_GAMMA: constant(uint256) = 5 * 10**16\r\n\r\n# ----------------------- ERC20 Specific vars --------------------------------\r\n\r\nname: public(immutable(String[64]))\r\nsymbol: public(immutable(String[32]))\r\ndecimals: public(constant(uint8)) = 18\r\nversion: public(constant(String[8])) = \"v2.0.0\"\r\n\r\nbalanceOf: public(HashMap[address, uint256])\r\nallowance: public(HashMap[address, HashMap[address, uint256]])\r\ntotalSupply: public(uint256)\r\nnonces: public(HashMap[address, uint256])\r\n\r\nEIP712_TYPEHASH: constant(bytes32) = keccak256(\r\n    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\"\r\n)\r\nEIP2612_TYPEHASH: constant(bytes32) = keccak256(\r\n    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\r\n)\r\nVERSION_HASH: constant(bytes32) = keccak256(version)\r\nNAME_HASH: immutable(bytes32)\r\nCACHED_CHAIN_ID: immutable(uint256)\r\nsalt: public(immutable(bytes32))\r\nCACHED_DOMAIN_SEPARATOR: immutable(bytes32)\r\n\r\n\r\n# ----------------------- Contract -------------------------------------------\r\n\r\n@external\r\ndef __init__(\r\n    _name: String[64],\r\n    _symbol: String[32],\r\n    _coins: address[N_COINS],\r\n    _math: address,\r\n    _salt: bytes32,\r\n    packed_precisions: uint256,\r\n    packed_gamma_A: uint256,\r\n    packed_fee_params: uint256,\r\n    packed_rebalancing_params: uint256,\r\n    initial_price: uint256,\r\n):\r\n\r\n    MATH = Math(_math)\r\n\r\n    factory = Factory(msg.sender)\r\n    name = _name\r\n    symbol = _symbol\r\n    coins = _coins\r\n\r\n    PRECISIONS = self._unpack_2(packed_precisions)  # <-- Precisions of coins.\r\n\r\n    # --------------- Validate A and gamma parameters here and not in factory.\r\n    gamma_A: uint256[2] = self._unpack_2(packed_gamma_A)  # gamma is at idx 0.\r\n\r\n    assert gamma_A[0] > MIN_GAMMA-1\r\n    assert gamma_A[0] < MAX_GAMMA+1\r\n\r\n    assert gamma_A[1] > MIN_A-1\r\n    assert gamma_A[1] < MAX_A+1\r\n\r\n    self.initial_A_gamma = packed_gamma_A\r\n    self.future_A_gamma = packed_gamma_A\r\n    # ------------------------------------------------------------------------\r\n\r\n    self.packed_rebalancing_params = packed_rebalancing_params  # <-- Contains\r\n    #               rebalancing params: allowed_extra_profit, adjustment_step,\r\n    #                                                         and ma_exp_time.\r\n\r\n    self.packed_fee_params = packed_fee_params  # <-------------- Contains Fee\r\n    #                                  params: mid_fee, out_fee and fee_gamma.\r\n\r\n    self.cached_price_scale = initial_price\r\n    self.cached_price_oracle = initial_price\r\n    self.last_prices = initial_price\r\n    self.last_timestamp = self._pack_2(block.timestamp, block.timestamp)\r\n    self.xcp_profit_a = 10**18\r\n    self.xcp_ma_time = 62324  # <--------- 12 hours default on contract start.\r\n\r\n    #         Cache DOMAIN_SEPARATOR. If chain.id is not CACHED_CHAIN_ID, then\r\n    #     DOMAIN_SEPARATOR will be re-calculated each time `permit` is called.\r\n    #                   Otherwise, it will always use CACHED_DOMAIN_SEPARATOR.\r\n    #                       see: `_domain_separator()` for its implementation.\r\n    NAME_HASH = keccak256(name)\r\n    salt = _salt\r\n    CACHED_CHAIN_ID = chain.id\r\n    CACHED_DOMAIN_SEPARATOR = keccak256(\r\n        _abi_encode(\r\n            EIP712_TYPEHASH,\r\n            NAME_HASH,\r\n            VERSION_HASH,\r\n            chain.id,\r\n            self,\r\n            salt,\r\n        )\r\n    )\r\n\r\n    log Transfer(empty(address), self, 0)  # <------- Fire empty transfer from\r\n    #                                       0x0 to self for indexers to catch.\r\n\r\n\r\n# ------------------- Token transfers in and out of the AMM ------------------\r\n\r\n\r\n@internal\r\ndef _transfer_in(\r\n    _coin_idx: uint256,\r\n    _dx: uint256,\r\n    sender: address,\r\n    expect_optimistic_transfer: bool,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Transfers `_coin` from `sender` to `self` and calls `callback_sig`\r\n            if it is not empty.\r\n    @params _coin_idx uint256 Index of the coin to transfer in.\r\n    @params dx amount of `_coin` to transfer into the pool.\r\n    @params sender address to transfer `_coin` from.\r\n    @params expect_optimistic_transfer bool True if pool expects user to transfer.\r\n            This is only enabled for exchange_received.\r\n    @return The amount of tokens received.\r\n    \"\"\"\r\n    coin_balance: uint256 = ERC20(coins[_coin_idx]).balanceOf(self)\r\n\r\n    if expect_optimistic_transfer:  # Only enabled in exchange_received:\r\n        # it expects the caller of exchange_received to have sent tokens to\r\n        # the pool before calling this method.\r\n\r\n        # If someone donates extra tokens to the contract: do not acknowledge.\r\n        # We only want to know if there are dx amount of tokens. Anything extra,\r\n        # we ignore. This is why we need to check if received_amounts (which\r\n        # accounts for coin balances of the contract) is atleast dx.\r\n        # If we checked for received_amounts == dx, an extra transfer without a\r\n        # call to exchange_received will break the method.\r\n        dx: uint256 = coin_balance - self.balances[_coin_idx]\r\n        assert dx >= _dx  # dev: user didn't give us coins\r\n\r\n        # Adjust balances\r\n        self.balances[_coin_idx] += dx\r\n\r\n        return dx\r\n\r\n    # ----------------------------------------------- ERC20 transferFrom flow.\r\n\r\n    # EXTERNAL CALL\r\n    assert ERC20(coins[_coin_idx]).transferFrom(\r\n        sender,\r\n        self,\r\n        _dx,\r\n        default_return_value=True\r\n    )\r\n\r\n    dx: uint256 = ERC20(coins[_coin_idx]).balanceOf(self) - coin_balance\r\n    self.balances[_coin_idx] += dx\r\n    return dx\r\n\r\n\r\n@internal\r\ndef _transfer_out(_coin_idx: uint256, _amount: uint256, receiver: address):\r\n    \"\"\"\r\n    @notice Transfer a single token from the pool to receiver.\r\n    @dev This function is called by `remove_liquidity` and\r\n         `remove_liquidity_one`, `_claim_admin_fees` and `_exchange` methods.\r\n    @params _coin_idx uint256 Index of the token to transfer out\r\n    @params _amount Amount of token to transfer out\r\n    @params receiver Address to send the tokens to\r\n    \"\"\"\r\n\r\n    # Adjust balances before handling transfers:\r\n    self.balances[_coin_idx] -= _amount\r\n\r\n    # EXTERNAL CALL\r\n    assert ERC20(coins[_coin_idx]).transfer(\r\n        receiver,\r\n        _amount,\r\n        default_return_value=True\r\n    )\r\n\r\n\r\n# -------------------------- AMM Main Functions ------------------------------\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef exchange(\r\n    i: uint256,\r\n    j: uint256,\r\n    dx: uint256,\r\n    min_dy: uint256,\r\n    receiver: address = msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Exchange using wrapped native token by default\r\n    @param i Index value for the input coin\r\n    @param j Index value for the output coin\r\n    @param dx Amount of input coin being swapped in\r\n    @param min_dy Minimum amount of output coin to receive\r\n    @param receiver Address to send the output coin to. Default is msg.sender\r\n    @return uint256 Amount of tokens at index j received by the `receiver\r\n    \"\"\"\r\n    # _transfer_in updates self.balances here:\r\n    dx_received: uint256 = self._transfer_in(\r\n        i,\r\n        dx,\r\n        msg.sender,\r\n        False\r\n    )\r\n\r\n    # No ERC20 token transfers occur here:\r\n    out: uint256[3] = self._exchange(\r\n        i,\r\n        j,\r\n        dx_received,\r\n        min_dy,\r\n    )\r\n\r\n    # _transfer_out updates self.balances here. Update to state occurs before\r\n    # external calls:\r\n    self._transfer_out(j, out[0], receiver)\r\n\r\n    # log:\r\n    log TokenExchange(msg.sender, i, dx_received, j, out[0], out[1], out[2])\r\n\r\n    return out[0]\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef exchange_received(\r\n    i: uint256,\r\n    j: uint256,\r\n    dx: uint256,\r\n    min_dy: uint256,\r\n    receiver: address = msg.sender,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Exchange: but user must transfer dx amount of coin[i] tokens to pool first.\r\n            Pool will not call transferFrom and will only check if a surplus of\r\n            coins[i] is greater than or equal to `dx`.\r\n    @dev Use-case is to reduce the number of redundant ERC20 token\r\n         transfers in zaps. Primarily for dex-aggregators/arbitrageurs/searchers.\r\n         Note for users: please transfer + exchange_received in 1 tx.\r\n    @param i Index value for the input coin\r\n    @param j Index value for the output coin\r\n    @param dx Amount of input coin being swapped in\r\n    @param min_dy Minimum amount of output coin to receive\r\n    @param receiver Address to send the output coin to\r\n    @return uint256 Amount of tokens at index j received by the `receiver`\r\n    \"\"\"\r\n    # _transfer_in updates self.balances here:\r\n    dx_received: uint256 = self._transfer_in(\r\n        i,\r\n        dx,\r\n        msg.sender,\r\n        True  # <---- expect_optimistic_transfer is set to True here.\r\n    )\r\n\r\n    # No ERC20 token transfers occur here:\r\n    out: uint256[3] = self._exchange(\r\n        i,\r\n        j,\r\n        dx_received,\r\n        min_dy,\r\n    )\r\n\r\n    # _transfer_out updates self.balances here. Update to state occurs before\r\n    # external calls:\r\n    self._transfer_out(j, out[0], receiver)\r\n\r\n    # log:\r\n    log TokenExchange(msg.sender, i, dx_received, j, out[0], out[1], out[2])\r\n\r\n    return out[0]\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef add_liquidity(\r\n    amounts: uint256[N_COINS],\r\n    min_mint_amount: uint256,\r\n    receiver: address = msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Adds liquidity into the pool.\r\n    @param amounts Amounts of each coin to add.\r\n    @param min_mint_amount Minimum amount of LP to mint.\r\n    @param receiver Address to send the LP tokens to. Default is msg.sender\r\n    @return uint256 Amount of LP tokens received by the `receiver\r\n    \"\"\"\r\n\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n    xp: uint256[N_COINS] = self.balances\r\n    amountsp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    d_token: uint256 = 0\r\n    d_token_fee: uint256 = 0\r\n    old_D: uint256 = 0\r\n\r\n    assert amounts[0] + amounts[1] > 0  # dev: no coins to add\r\n\r\n    # --------------------- Get prices, balances -----------------------------\r\n\r\n    price_scale: uint256 = self.cached_price_scale\r\n\r\n    # -------------------------------------- Update balances and calculate xp.\r\n    xp_old: uint256[N_COINS] = xp\r\n    amounts_received: uint256[N_COINS] = empty(uint256[N_COINS])\r\n\r\n    ########################## TRANSFER IN <-------\r\n\r\n    for i in range(N_COINS):\r\n        if amounts[i] > 0:\r\n            # Updates self.balances here:\r\n            amounts_received[i] = self._transfer_in(\r\n                i,\r\n                amounts[i],\r\n                msg.sender,\r\n                False,  # <--------------------- Disable optimistic transfers.\r\n            )\r\n            xp[i] = xp[i] + amounts_received[i]\r\n\r\n    xp = [\r\n        xp[0] * PRECISIONS[0],\r\n        unsafe_div(xp[1] * price_scale * PRECISIONS[1], PRECISION)\r\n    ]\r\n    xp_old = [\r\n        xp_old[0] * PRECISIONS[0],\r\n        unsafe_div(xp_old[1] * price_scale * PRECISIONS[1], PRECISION)\r\n    ]\r\n\r\n    for i in range(N_COINS):\r\n        if amounts_received[i] > 0:\r\n            amountsp[i] = xp[i] - xp_old[i]\r\n\r\n    # -------------------- Calculate LP tokens to mint -----------------------\r\n\r\n    if self.future_A_gamma_time > block.timestamp:  # <--- A_gamma is ramping.\r\n\r\n        # ----- Recalculate the invariant if A or gamma are undergoing a ramp.\r\n        old_D = MATH.newton_D(A_gamma[0], A_gamma[1], xp_old, 0)\r\n\r\n    else:\r\n\r\n        old_D = self.D\r\n\r\n    D: uint256 = MATH.newton_D(A_gamma[0], A_gamma[1], xp, 0)\r\n\r\n    token_supply: uint256 = self.totalSupply\r\n    if old_D > 0:\r\n        d_token = token_supply * D / old_D - token_supply\r\n    else:\r\n        d_token = self.get_xcp(D, price_scale)  # <----- Making initial virtual price equal to 1.\r\n\r\n    assert d_token > 0  # dev: nothing minted\r\n\r\n    if old_D > 0:\r\n\r\n        d_token_fee = (\r\n            self._calc_token_fee(amountsp, xp) * d_token / 10**10 + 1\r\n        )\r\n\r\n        d_token -= d_token_fee\r\n        token_supply += d_token\r\n        self.mint(receiver, d_token)\r\n        self.admin_lp_virtual_balance += unsafe_div(ADMIN_FEE * d_token_fee, 10**10)\r\n\r\n        price_scale = self.tweak_price(A_gamma, xp, D, 0)\r\n\r\n    else:\r\n\r\n        # (re)instatiating an empty pool:\r\n\r\n        self.D = D\r\n        self.virtual_price = 10**18\r\n        self.xcp_profit = 10**18\r\n        self.xcp_profit_a = 10**18\r\n\r\n        # Initialise xcp oracle here:\r\n        self.cached_xcp_oracle = d_token  # <--- virtual_price * totalSupply / 10**18\r\n\r\n        self.mint(receiver, d_token)\r\n\r\n    assert d_token >= min_mint_amount, \"Slippage\"\r\n\r\n    # ---------------------------------------------- Log and claim admin fees.\r\n\r\n    log AddLiquidity(\r\n        receiver,\r\n        amounts_received,\r\n        d_token_fee,\r\n        token_supply,\r\n        price_scale\r\n    )\r\n\r\n    return d_token\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef remove_liquidity(\r\n    _amount: uint256,\r\n    min_amounts: uint256[N_COINS],\r\n    receiver: address = msg.sender,\r\n) -> uint256[N_COINS]:\r\n    \"\"\"\r\n    @notice This withdrawal method is very safe, does no complex math since\r\n            tokens are withdrawn in balanced proportions. No fees are charged.\r\n    @param _amount Amount of LP tokens to burn\r\n    @param min_amounts Minimum amounts of tokens to withdraw\r\n    @param receiver Address to send the withdrawn tokens to\r\n    @return uint256[3] Amount of pool tokens received by the `receiver`\r\n    \"\"\"\r\n    amount: uint256 = _amount\r\n    balances: uint256[N_COINS] = self.balances\r\n    withdraw_amounts: uint256[N_COINS] = empty(uint256[N_COINS])\r\n\r\n    # -------------------------------------------------------- Burn LP tokens.\r\n\r\n    total_supply: uint256 = self.totalSupply  # <------ Get totalSupply before\r\n    self.burnFrom(msg.sender, _amount)  # ---- reducing it with self.burnFrom.\r\n\r\n    # There are two cases for withdrawing tokens from the pool.\r\n    #   Case 1. Withdrawal does not empty the pool.\r\n    #           In this situation, D is adjusted proportional to the amount of\r\n    #           LP tokens burnt. ERC20 tokens transferred is proportional\r\n    #           to : (AMM balance * LP tokens in) / LP token total supply\r\n    #   Case 2. Withdrawal empties the pool.\r\n    #           In this situation, all tokens are withdrawn and the invariant\r\n    #           is reset.\r\n\r\n    if amount == total_supply:  # <----------------------------------- Case 2.\r\n\r\n        for i in range(N_COINS):\r\n\r\n            withdraw_amounts[i] = balances[i]\r\n\r\n    else:  # <-------------------------------------------------------- Case 1.\r\n\r\n        amount -= 1  # <---- To prevent rounding errors, favor LPs a tiny bit.\r\n\r\n        for i in range(N_COINS):\r\n\r\n            withdraw_amounts[i] = balances[i] * amount / total_supply\r\n            assert withdraw_amounts[i] >= min_amounts[i]\r\n\r\n    D: uint256 = self.D\r\n    self.D = D - unsafe_div(D * amount, total_supply)  # <----------- Reduce D\r\n    #      proportional to the amount of tokens leaving. Since withdrawals are\r\n    #       balanced, this is a simple subtraction. If amount == total_supply,\r\n    #                                                             D will be 0.\r\n\r\n    # ---------------------------------- Transfers ---------------------------\r\n\r\n    for i in range(N_COINS):\r\n        # _transfer_out updates self.balances here. Update to state occurs\r\n        # before external calls:\r\n        self._transfer_out(i, withdraw_amounts[i], receiver)\r\n\r\n    log RemoveLiquidity(msg.sender, withdraw_amounts, total_supply - _amount)\r\n\r\n    # --------------------------- Upkeep xcp oracle --------------------------\r\n\r\n    # Update xcp since liquidity was removed:\r\n    xp: uint256[N_COINS] = self.xp(self.balances, self.cached_price_scale)\r\n    last_xcp: uint256 = isqrt(xp[0] * xp[1])  # <----------- Cache it for now.\r\n\r\n    last_timestamp: uint256[2] = self._unpack_2(self.last_timestamp)\r\n    if last_timestamp[1] < block.timestamp:\r\n\r\n        cached_xcp_oracle: uint256 = self.cached_xcp_oracle\r\n        alpha: uint256 = MATH.wad_exp(\r\n            -convert(\r\n                unsafe_div(\r\n                    unsafe_sub(block.timestamp, last_timestamp[1]) * 10**18,\r\n                    self.xcp_ma_time  # <---------- xcp ma time has is longer.\r\n                ),\r\n                int256,\r\n            )\r\n        )\r\n\r\n        self.cached_xcp_oracle = unsafe_div(\r\n            last_xcp * (10**18 - alpha) + cached_xcp_oracle * alpha,\r\n            10**18\r\n        )\r\n        last_timestamp[1] = block.timestamp\r\n\r\n        # Pack and store timestamps:\r\n        self.last_timestamp = self._pack_2(last_timestamp[0], last_timestamp[1])\r\n\r\n    # Store last xcp\r\n    self.last_xcp = last_xcp\r\n\r\n    return withdraw_amounts\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef remove_liquidity_one_coin(\r\n    token_amount: uint256,\r\n    i: uint256,\r\n    min_amount: uint256,\r\n    receiver: address = msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw liquidity in a single token.\r\n            Involves fees (lower than swap fees).\r\n    @dev This operation also involves an admin fee claim.\r\n    @param token_amount Amount of LP tokens to burn\r\n    @param i Index of the token to withdraw\r\n    @param min_amount Minimum amount of token to withdraw.\r\n    @param receiver Address to send the withdrawn tokens to\r\n    @return Amount of tokens at index i received by the `receiver`\r\n    \"\"\"\r\n\r\n    self._claim_admin_fees()  # <--------- Auto-claim admin fees occasionally.\r\n\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n\r\n    dy: uint256 = 0\r\n    D: uint256 = 0\r\n    p: uint256 = 0\r\n    xp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    approx_fee: uint256 = 0\r\n\r\n    # ------------------------------------------------------------------------\r\n\r\n    dy, D, xp, approx_fee = self._calc_withdraw_one_coin(\r\n        A_gamma,\r\n        token_amount,\r\n        i,\r\n        (self.future_A_gamma_time > block.timestamp),  # <------- During ramps\r\n    )  #                                                  we need to update D.\r\n\r\n    assert dy >= min_amount, \"Slippage\"\r\n\r\n    # ---------------------------- State Updates -----------------------------\r\n\r\n    # Burn user's tokens:\r\n    self.burnFrom(msg.sender, token_amount)\r\n\r\n    packed_price_scale: uint256 = self.tweak_price(A_gamma, xp, D, 0)\r\n    #        Safe to use D from _calc_withdraw_one_coin here ---^\r\n\r\n    # ------------------------- Transfers ------------------------------------\r\n\r\n    # _transfer_out updates self.balances here. Update to state occurs before\r\n    # external calls:\r\n    self._transfer_out(i, dy, receiver)\r\n\r\n    log RemoveLiquidityOne(\r\n        msg.sender, token_amount, i, dy, approx_fee, packed_price_scale\r\n    )\r\n\r\n    return dy\r\n\r\n\r\n# -------------------------- Packing functions -------------------------------\r\n\r\n\r\n@internal\r\n@pure\r\ndef _pack_3(x: uint256[3]) -> uint256:\r\n    \"\"\"\r\n    @notice Packs 3 integers with values <= 10**18 into a uint256\r\n    @param x The uint256[3] to pack\r\n    @return uint256 Integer with packed values\r\n    \"\"\"\r\n    return (x[0] << 128) | (x[1] << 64) | x[2]\r\n\r\n\r\n@internal\r\n@pure\r\ndef _unpack_3(_packed: uint256) -> uint256[3]:\r\n    \"\"\"\r\n    @notice Unpacks a uint256 into 3 integers (values must be <= 10**18)\r\n    @param val The uint256 to unpack\r\n    @return uint256[3] A list of length 3 with unpacked integers\r\n    \"\"\"\r\n    return [\r\n        (_packed >> 128) & 18446744073709551615,\r\n        (_packed >> 64) & 18446744073709551615,\r\n        _packed & 18446744073709551615,\r\n    ]\r\n\r\n\r\n@pure\r\n@internal\r\ndef _pack_2(p1: uint256, p2: uint256) -> uint256:\r\n    return p1 | (p2 << 128)\r\n\r\n\r\n@pure\r\n@internal\r\ndef _unpack_2(packed: uint256) -> uint256[2]:\r\n    return [packed & (2**128 - 1), packed >> 128]\r\n\r\n\r\n# ---------------------- AMM Internal Functions -------------------------------\r\n\r\n\r\n@internal\r\ndef _exchange(\r\n    i: uint256,\r\n    j: uint256,\r\n    dx_received: uint256,\r\n    min_dy: uint256,\r\n) -> uint256[3]:\r\n\r\n    assert i != j  # dev: coin index out of range\r\n    assert dx_received > 0  # dev: do not exchange 0 coins\r\n\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n    xp: uint256[N_COINS] = self.balances\r\n    dy: uint256 = 0\r\n\r\n    y: uint256 = xp[j]\r\n    x0: uint256 = xp[i] - dx_received  # old xp[i]\r\n\r\n    price_scale: uint256 = self.cached_price_scale\r\n    xp = [\r\n        xp[0] * PRECISIONS[0],\r\n        unsafe_div(xp[1] * price_scale * PRECISIONS[1], PRECISION)\r\n    ]\r\n\r\n    # ----------- Update invariant if A, gamma are undergoing ramps ---------\r\n\r\n    t: uint256 = self.future_A_gamma_time\r\n    if t > block.timestamp:\r\n\r\n        x0 *= PRECISIONS[i]\r\n\r\n        if i > 0:\r\n            x0 = unsafe_div(x0 * price_scale, PRECISION)\r\n\r\n        x1: uint256 = xp[i]  # <------------------ Back up old value in xp ...\r\n        xp[i] = x0                                                         # |\r\n        self.D = MATH.newton_D(A_gamma[0], A_gamma[1], xp, 0)              # |\r\n        xp[i] = x1  # <-------------------------------------- ... and restore.\r\n\r\n    # ----------------------- Calculate dy and fees --------------------------\r\n\r\n    D: uint256 = self.D\r\n    y_out: uint256[2] = MATH.get_y(A_gamma[0], A_gamma[1], xp, D, j)\r\n    dy = xp[j] - y_out[0]\r\n    xp[j] -= dy\r\n    dy -= 1\r\n\r\n    if j > 0:\r\n        dy = dy * PRECISION / price_scale\r\n    dy /= PRECISIONS[j]\r\n\r\n    fee: uint256 = unsafe_div(self._fee(xp) * dy, 10**10)\r\n    dy -= fee  # <--------------------- Subtract fee from the outgoing amount.\r\n    assert dy >= min_dy, \"Slippage\"\r\n    y -= dy\r\n\r\n    y *= PRECISIONS[j]\r\n    if j > 0:\r\n        y = unsafe_div(y * price_scale, PRECISION)\r\n    xp[j] = y  # <------------------------------------------------- Update xp.\r\n\r\n    # ------ Tweak price_scale with good initial guess for newton_D ----------\r\n\r\n    price_scale = self.tweak_price(A_gamma, xp, 0, y_out[1])\r\n\r\n    return [dy, fee, price_scale]\r\n\r\n\r\n@internal\r\ndef tweak_price(\r\n    A_gamma: uint256[2],\r\n    _xp: uint256[N_COINS],\r\n    new_D: uint256,\r\n    K0_prev: uint256 = 0,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Updates price_oracle, last_price and conditionally adjusts\r\n            price_scale. This is called whenever there is an unbalanced\r\n            liquidity operation: _exchange, add_liquidity, or\r\n            remove_liquidity_one_coin.\r\n    @dev Contains main liquidity rebalancing logic, by tweaking `price_scale`.\r\n    @param A_gamma Array of A and gamma parameters.\r\n    @param _xp Array of current balances.\r\n    @param new_D New D value.\r\n    @param K0_prev Initial guess for `newton_D`.\r\n    \"\"\"\r\n\r\n    # ---------------------------- Read storage ------------------------------\r\n\r\n    price_oracle: uint256 = self.cached_price_oracle\r\n    last_prices: uint256 = self.last_prices\r\n    price_scale: uint256 = self.cached_price_scale\r\n    rebalancing_params: uint256[3] = self._unpack_3(self.packed_rebalancing_params)\r\n    # Contains: allowed_extra_profit, adjustment_step, ma_time. -----^\r\n\r\n    total_supply: uint256 = self.totalSupply\r\n    old_xcp_profit: uint256 = self.xcp_profit\r\n    old_virtual_price: uint256 = self.virtual_price\r\n\r\n    # ----------------------- Update Oracles if needed -----------------------\r\n\r\n    last_timestamp: uint256[2] = self._unpack_2(self.last_timestamp)\r\n    alpha: uint256 = 0\r\n    if last_timestamp[0] < block.timestamp:  # 0th index is for price_oracle.\r\n\r\n        #   The moving average price oracle is calculated using the last_price\r\n        #      of the trade at the previous block, and the price oracle logged\r\n        #              before that trade. This can happen only once per block.\r\n\r\n        # ------------------ Calculate moving average params -----------------\r\n\r\n        alpha = MATH.wad_exp(\r\n            -convert(\r\n                unsafe_div(\r\n                    unsafe_sub(block.timestamp, last_timestamp[0]) * 10**18,\r\n                    rebalancing_params[2]  # <----------------------- ma_time.\r\n                ),\r\n                int256,\r\n            )\r\n        )\r\n\r\n        # ---------------------------------------------- Update price oracles.\r\n\r\n        # ----------------- We cap state price that goes into the EMA with\r\n        #                                                 2 x price_scale.\r\n        price_oracle = unsafe_div(\r\n            min(last_prices, 2 * price_scale) * (10**18 - alpha) +\r\n            price_oracle * alpha,  # ^-------- Cap spot price into EMA.\r\n            10**18\r\n        )\r\n\r\n        self.cached_price_oracle = price_oracle\r\n        last_timestamp[0] = block.timestamp\r\n\r\n    # ----------------------------------------------------- Update xcp oracle.\r\n\r\n    if last_timestamp[1] < block.timestamp:\r\n\r\n        cached_xcp_oracle: uint256 = self.cached_xcp_oracle\r\n        alpha = MATH.wad_exp(\r\n            -convert(\r\n                unsafe_div(\r\n                    unsafe_sub(block.timestamp, last_timestamp[1]) * 10**18,\r\n                    self.xcp_ma_time  # <---------- xcp ma time has is longer.\r\n                ),\r\n                int256,\r\n            )\r\n        )\r\n\r\n        self.cached_xcp_oracle = unsafe_div(\r\n            self.last_xcp * (10**18 - alpha) + cached_xcp_oracle * alpha,\r\n            10**18\r\n        )\r\n\r\n        # Pack and store timestamps:\r\n        last_timestamp[1] = block.timestamp\r\n\r\n    self.last_timestamp = self._pack_2(last_timestamp[0], last_timestamp[1])\r\n\r\n    #  `price_oracle` is used further on to calculate its vector distance from\r\n    # price_scale. This distance is used to calculate the amount of adjustment\r\n    # to be done to the price_scale.\r\n    # ------------------------------------------------------------------------\r\n\r\n    # ------------------ If new_D is set to 0, calculate it ------------------\r\n\r\n    D_unadjusted: uint256 = new_D\r\n    if new_D == 0:  #  <--------------------------- _exchange sets new_D to 0.\r\n        D_unadjusted = MATH.newton_D(A_gamma[0], A_gamma[1], _xp, K0_prev)\r\n\r\n    # ----------------------- Calculate last_prices --------------------------\r\n\r\n    self.last_prices = unsafe_div(\r\n        MATH.get_p(_xp, D_unadjusted, A_gamma) * price_scale,\r\n        10**18\r\n    )\r\n\r\n    # ---------- Update profit numbers without price adjustment first --------\r\n\r\n    xp: uint256[N_COINS] = [\r\n        unsafe_div(D_unadjusted, N_COINS),\r\n        D_unadjusted * PRECISION / (N_COINS * price_scale)  # <------ safediv.\r\n    ]  #                                                     with price_scale.\r\n\r\n    xcp_profit: uint256 = 10**18\r\n    virtual_price: uint256 = 10**18\r\n\r\n    if old_virtual_price > 0:\r\n\r\n        xcp: uint256 = isqrt(xp[0] * xp[1])\r\n        virtual_price = 10**18 * xcp / total_supply\r\n\r\n        xcp_profit = unsafe_div(\r\n            old_xcp_profit * virtual_price,\r\n            old_virtual_price\r\n        )  # <---------------- Safu to do unsafe_div as old_virtual_price > 0.\r\n\r\n        #       If A and gamma are not undergoing ramps (t < block.timestamp),\r\n        #         ensure new virtual_price is not less than old virtual_price,\r\n        #                                        else the pool suffers a loss.\r\n        if self.future_A_gamma_time < block.timestamp:\r\n            assert virtual_price > old_virtual_price, \"Loss\"\r\n\r\n        # -------------------------- Cache last_xcp --------------------------\r\n\r\n        self.last_xcp = xcp  # geometric_mean(D * price_scale)\r\n\r\n    self.xcp_profit = xcp_profit\r\n\r\n    # ------------ Rebalance liquidity if there's enough profits to adjust it:\r\n    if virtual_price * 2 - 10**18 > xcp_profit + 2 * rebalancing_params[0]:\r\n        #                          allowed_extra_profit --------^\r\n\r\n        # ------------------- Get adjustment step ----------------------------\r\n\r\n        #                Calculate the vector distance between price_scale and\r\n        #                                                        price_oracle.\r\n        norm: uint256 = unsafe_div(\r\n            unsafe_mul(price_oracle, 10**18), price_scale\r\n        )\r\n        if norm > 10**18:\r\n            norm = unsafe_sub(norm, 10**18)\r\n        else:\r\n            norm = unsafe_sub(10**18, norm)\r\n        adjustment_step: uint256 = max(\r\n            rebalancing_params[1], unsafe_div(norm, 5)\r\n        )  #           ^------------------------------------- adjustment_step.\r\n\r\n        if norm > adjustment_step:  # <---------- We only adjust prices if the\r\n            #          vector distance between price_oracle and price_scale is\r\n            #             large enough. This check ensures that no rebalancing\r\n            #           occurs if the distance is low i.e. the pool prices are\r\n            #                                     pegged to the oracle prices.\r\n\r\n            # ------------------------------------- Calculate new price scale.\r\n\r\n            p_new: uint256 = unsafe_div(\r\n                price_scale * unsafe_sub(norm, adjustment_step) +\r\n                adjustment_step * price_oracle,\r\n                norm\r\n            )  # <---- norm is non-zero and gt adjustment_step; unsafe = safe.\r\n\r\n            # ---------------- Update stale xp (using price_scale) with p_new.\r\n\r\n            xp = [\r\n                _xp[0],\r\n                unsafe_div(_xp[1] * p_new, price_scale)\r\n            ]\r\n\r\n            # ------------------------------------------ Update D with new xp.\r\n            D: uint256 = MATH.newton_D(A_gamma[0], A_gamma[1], xp, 0)\r\n\r\n            for k in range(N_COINS):\r\n                frac: uint256 = xp[k] * 10**18 / D  # <----- Check validity of\r\n                assert (frac > 10**16 - 1) and (frac < 10**20 + 1)  #   p_new.\r\n\r\n            # ------------------------------------- Convert xp to real prices.\r\n            xp = [\r\n                unsafe_div(D, N_COINS),\r\n                D * PRECISION / (N_COINS * p_new)\r\n            ]\r\n\r\n            # ---------- Calculate new virtual_price using new xp and D. Reuse\r\n            #              `old_virtual_price` (but it has new virtual_price).\r\n            old_virtual_price = unsafe_div(\r\n                10**18 * isqrt(xp[0] * xp[1]), total_supply\r\n            )  # <----- unsafe_div because we did safediv before (if vp>1e18)\r\n\r\n            # ---------------------------- Proceed if we've got enough profit.\r\n            if (\r\n                old_virtual_price > 10**18 and\r\n                2 * old_virtual_price - 10**18 > xcp_profit\r\n            ):\r\n\r\n                self.D = D\r\n                self.virtual_price = old_virtual_price\r\n                self.cached_price_scale = p_new\r\n\r\n                return p_new\r\n\r\n    # --------- price_scale was not adjusted. Update the profit counter and D.\r\n    self.D = D_unadjusted\r\n    self.virtual_price = virtual_price\r\n\r\n    return price_scale\r\n\r\n\r\n@internal\r\ndef _claim_admin_fees():\r\n    \"\"\"\r\n    @notice Claims admin fees and sends it to fee_receiver set in the factory.\r\n    @dev Functionally similar to:\r\n         1. Calculating admin's share of fees,\r\n         2. minting LP tokens,\r\n         3. admin claims underlying tokens via remove_liquidity.\r\n    \"\"\"\r\n\r\n    # --------------------- Check if fees can be claimed ---------------------\r\n\r\n    # Disable fee claiming if:\r\n    # 1. If time passed since last fee claim is less than\r\n    #    MIN_ADMIN_FEE_CLAIM_INTERVAL.\r\n    # 2. Pool parameters are being ramped.\r\n\r\n    last_claim_time: uint256 = self.last_admin_fee_claim_timestamp\r\n    if (\r\n        unsafe_sub(block.timestamp, last_claim_time) < MIN_ADMIN_FEE_CLAIM_INTERVAL or\r\n        self.future_A_gamma_time > block.timestamp\r\n    ):\r\n        return\r\n\r\n    xcp_profit: uint256 = self.xcp_profit  # <---------- Current pool profits.\r\n    xcp_profit_a: uint256 = self.xcp_profit_a  # <- Profits at previous claim.\r\n    current_lp_token_supply: uint256 = self.totalSupply\r\n\r\n    # Do not claim admin fees if:\r\n    # 1. insufficient profits accrued since last claim, and\r\n    # 2. there are less than 10**18 (or 1 unit of) lp tokens, else it can lead\r\n    #    to manipulated virtual prices.\r\n\r\n    if xcp_profit <= xcp_profit_a or current_lp_token_supply < 10**18:\r\n        return\r\n\r\n    # ---------- Conditions met to claim admin fees: compute state. ----------\r\n\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n    D: uint256 = self.D\r\n    vprice: uint256 = self.virtual_price\r\n    price_scale: uint256 = self.cached_price_scale\r\n    fee_receiver: address = factory.fee_receiver()\r\n    balances: uint256[N_COINS] = self.balances\r\n\r\n    #  Admin fees are calculated as follows.\r\n    #      1. Calculate accrued profit since last claim. `xcp_profit`\r\n    #         is the current profits. `xcp_profit_a` is the profits\r\n    #         at the previous claim.\r\n    #      2. Take out admin's share, which is hardcoded at 5 * 10**9.\r\n    #         (50% => half of 100% => 10**10 / 2 => 5 * 10**9).\r\n    #      3. Since half of the profits go to rebalancing the pool, we\r\n    #         are left with half; so divide by 2.\r\n\r\n    fees: uint256 = unsafe_div(\r\n        unsafe_sub(xcp_profit, xcp_profit_a) * ADMIN_FEE, 2 * 10**10\r\n    )\r\n\r\n    # ------------------------------ Claim admin fees by minting admin's share\r\n    #                                                of the pool in LP tokens.\r\n\r\n    # This is the admin fee tokens claimed in self.add_liquidity. We add it to\r\n    # the LP token share that the admin needs to claim:\r\n    admin_share: uint256 = self.admin_lp_virtual_balance\r\n    frac: uint256 = 0\r\n    if fee_receiver != empty(address) and fees > 0:\r\n\r\n        # -------------------------------- Calculate admin share to be minted.\r\n        frac = vprice * 10**18 / (vprice - fees) - 10**18\r\n        admin_share += current_lp_token_supply * frac / 10**18\r\n\r\n        # ------ Subtract fees from profits that will be used for rebalancing.\r\n        xcp_profit -= fees * 2\r\n\r\n    # ------------------- Recalculate virtual_price following admin fee claim.\r\n    total_supply_including_admin_share: uint256 = (\r\n        current_lp_token_supply + admin_share\r\n    )\r\n    vprice = (\r\n        10**18 * self.get_xcp(D, price_scale) /\r\n        total_supply_including_admin_share\r\n    )\r\n\r\n    # Do not claim fees if doing so causes virtual price to drop below 10**18.\r\n    if vprice < 10**18:\r\n        return\r\n\r\n    # ---------------------------- Update State ------------------------------\r\n\r\n    # Set admin virtual LP balances to zero because we claimed:\r\n    self.admin_lp_virtual_balance = 0\r\n\r\n    self.xcp_profit = xcp_profit\r\n    self.last_admin_fee_claim_timestamp = block.timestamp\r\n\r\n    # Since we reduce balances: virtual price goes down\r\n    self.virtual_price = vprice\r\n\r\n    # Adjust D after admin seemingly removes liquidity\r\n    self.D = D - unsafe_div(D * admin_share, total_supply_including_admin_share)\r\n\r\n    if xcp_profit > xcp_profit_a:\r\n        self.xcp_profit_a = xcp_profit  # <-------- Cache last claimed profit.\r\n\r\n    # --------------------------- Handle Transfers ---------------------------\r\n\r\n    admin_tokens: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    if admin_share > 0:\r\n\r\n        for i in range(N_COINS):\r\n\r\n            admin_tokens[i] = (\r\n                balances[i] * admin_share /\r\n                total_supply_including_admin_share\r\n            )\r\n\r\n            # _transfer_out tokens to admin and update self.balances. State\r\n            # update to self.balances occurs before external contract calls:\r\n            self._transfer_out(i, admin_tokens[i], fee_receiver)\r\n\r\n        log ClaimAdminFee(fee_receiver, admin_tokens)\r\n\r\n\r\n@internal\r\n@pure\r\ndef xp(\r\n    balances: uint256[N_COINS],\r\n    price_scale: uint256,\r\n) -> uint256[N_COINS]:\r\n\r\n    return [\r\n        balances[0] * PRECISIONS[0],\r\n        unsafe_div(balances[1] * PRECISIONS[1] * price_scale, PRECISION)\r\n    ]\r\n\r\n\r\n@view\r\n@internal\r\ndef _A_gamma() -> uint256[2]:\r\n    t1: uint256 = self.future_A_gamma_time\r\n\r\n    A_gamma_1: uint256 = self.future_A_gamma\r\n    gamma1: uint256 = A_gamma_1 & 2**128 - 1\r\n    A1: uint256 = A_gamma_1 >> 128\r\n\r\n    if block.timestamp < t1:\r\n\r\n        # --------------- Handle ramping up and down of A --------------------\r\n\r\n        A_gamma_0: uint256 = self.initial_A_gamma\r\n        t0: uint256 = self.initial_A_gamma_time\r\n\r\n        t1 -= t0\r\n        t0 = block.timestamp - t0\r\n        t2: uint256 = t1 - t0\r\n\r\n        A1 = ((A_gamma_0 >> 128) * t2 + A1 * t0) / t1\r\n        gamma1 = ((A_gamma_0 & 2**128 - 1) * t2 + gamma1 * t0) / t1\r\n\r\n    return [A1, gamma1]\r\n\r\n\r\n@internal\r\n@view\r\ndef _fee(xp: uint256[N_COINS]) -> uint256:\r\n\r\n    fee_params: uint256[3] = self._unpack_3(self.packed_fee_params)\r\n    f: uint256 = xp[0] + xp[1]\r\n    f = fee_params[2] * 10**18 / (\r\n        fee_params[2] + 10**18 -\r\n        (10**18 * N_COINS**N_COINS) * xp[0] / f * xp[1] / f\r\n    )\r\n\r\n    return unsafe_div(\r\n        fee_params[0] * f + fee_params[1] * (10**18 - f),\r\n        10**18\r\n    )\r\n\r\n\r\n@internal\r\n@pure\r\ndef get_xcp(D: uint256, price_scale: uint256) -> uint256:\r\n\r\n    x: uint256[N_COINS] = [\r\n        unsafe_div(D, N_COINS),\r\n        D * PRECISION / (price_scale * N_COINS)\r\n    ]\r\n\r\n    return isqrt(x[0] * x[1])  # <------------------- Geometric Mean.\r\n\r\n\r\n@view\r\n@internal\r\ndef _calc_token_fee(amounts: uint256[N_COINS], xp: uint256[N_COINS]) -> uint256:\r\n    # fee = sum(amounts_i - avg(amounts)) * fee' / sum(amounts)\r\n    fee: uint256 = unsafe_div(\r\n        unsafe_mul(self._fee(xp), N_COINS),\r\n        unsafe_mul(4, unsafe_sub(N_COINS, 1))\r\n    )\r\n\r\n    S: uint256 = 0\r\n    for _x in amounts:\r\n        S += _x\r\n\r\n    avg: uint256 = unsafe_div(S, N_COINS)\r\n    Sdiff: uint256 = 0\r\n\r\n    for _x in amounts:\r\n        if _x > avg:\r\n            Sdiff += unsafe_sub(_x, avg)\r\n        else:\r\n            Sdiff += unsafe_sub(avg, _x)\r\n\r\n    return fee * Sdiff / S + NOISE_FEE\r\n\r\n\r\n@internal\r\n@view\r\ndef _calc_withdraw_one_coin(\r\n    A_gamma: uint256[2],\r\n    token_amount: uint256,\r\n    i: uint256,\r\n    update_D: bool,\r\n) -> (uint256, uint256, uint256[N_COINS], uint256):\r\n\r\n    token_supply: uint256 = self.totalSupply\r\n    assert token_amount <= token_supply  # dev: token amount more than supply\r\n    assert i < N_COINS  # dev: coin out of range\r\n\r\n    xx: uint256[N_COINS] = self.balances\r\n    D0: uint256 = 0\r\n\r\n    # -------------------------- Calculate D0 and xp -------------------------\r\n\r\n    price_scale_i: uint256 = self.cached_price_scale * PRECISIONS[1]\r\n    xp: uint256[N_COINS] = [\r\n        xx[0] * PRECISIONS[0],\r\n        unsafe_div(xx[1] * price_scale_i, PRECISION)\r\n    ]\r\n    if i == 0:\r\n        price_scale_i = PRECISION * PRECISIONS[0]\r\n\r\n    if update_D:  # <-------------- D is updated if pool is undergoing a ramp.\r\n        D0 = MATH.newton_D(A_gamma[0], A_gamma[1], xp, 0)\r\n    else:\r\n        D0 = self.D\r\n\r\n    D: uint256 = D0\r\n\r\n    # -------------------------------- Fee Calc ------------------------------\r\n\r\n    # Charge fees on D. Roughly calculate xp[i] after withdrawal and use that\r\n    # to calculate fee. Precision is not paramount here: we just want a\r\n    # behavior where the higher the imbalance caused the more fee the AMM\r\n    # charges.\r\n\r\n    # xp is adjusted assuming xp[0] ~= xp[1] ~= x[2], which is usually not the\r\n    #  case. We charge self._fee(xp), where xp is an imprecise adjustment post\r\n    #  withdrawal in one coin. If the withdraw is too large: charge max fee by\r\n    #   default. This is because the fee calculation will otherwise underflow.\r\n\r\n    xp_imprecise: uint256[N_COINS] = xp\r\n    xp_correction: uint256 = xp[i] * N_COINS * token_amount / token_supply\r\n    fee: uint256 = self._unpack_3(self.packed_fee_params)[1]  # <- self.out_fee.\r\n\r\n    if xp_correction < xp_imprecise[i]:\r\n        xp_imprecise[i] -= xp_correction\r\n        fee = self._fee(xp_imprecise)\r\n\r\n    dD: uint256 = unsafe_div(token_amount * D, token_supply)\r\n    D_fee: uint256 = fee * dD / (2 * 10**10) + 1  # <------- Actual fee on D.\r\n\r\n    # --------- Calculate `approx_fee` (assuming balanced state) in ith token.\r\n    # -------------------------------- We only need this for fee in the event.\r\n    approx_fee: uint256 = N_COINS * D_fee * xx[i] / D  # <------------------<---------- TODO: Check math.\r\n\r\n    # ------------------------------------------------------------------------\r\n    D -= (dD - D_fee)  # <----------------------------------- Charge fee on D.\r\n    # --------------------------------- Calculate `y_out`` with `(D - D_fee)`.\r\n    y: uint256 = MATH.get_y(A_gamma[0], A_gamma[1], xp, D, i)[0]\r\n    dy: uint256 = (xp[i] - y) * PRECISION / price_scale_i\r\n    xp[i] = y\r\n\r\n    return dy, D, xp, approx_fee\r\n\r\n\r\n# ------------------------ ERC20 functions -----------------------------------\r\n\r\n\r\n@internal\r\ndef _approve(_owner: address, _spender: address, _value: uint256):\r\n    self.allowance[_owner][_spender] = _value\r\n\r\n    log Approval(_owner, _spender, _value)\r\n\r\n\r\n@internal\r\ndef _transfer(_from: address, _to: address, _value: uint256):\r\n    assert _to not in [self, empty(address)]\r\n\r\n    self.balanceOf[_from] -= _value\r\n    self.balanceOf[_to] += _value\r\n\r\n    log Transfer(_from, _to, _value)\r\n\r\n\r\n@view\r\n@internal\r\ndef _domain_separator() -> bytes32:\r\n    if chain.id != CACHED_CHAIN_ID:\r\n        return keccak256(\r\n            _abi_encode(\r\n                EIP712_TYPEHASH,\r\n                NAME_HASH,\r\n                VERSION_HASH,\r\n                chain.id,\r\n                self,\r\n                salt,\r\n            )\r\n        )\r\n    return CACHED_DOMAIN_SEPARATOR\r\n\r\n\r\n@external\r\ndef transferFrom(_from: address, _to: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @dev Transfer tokens from one address to another.\r\n    @param _from address The address which you want to send tokens from\r\n    @param _to address The address which you want to transfer to\r\n    @param _value uint256 the amount of tokens to be transferred\r\n    @return bool True on successul transfer. Reverts otherwise.\r\n    \"\"\"\r\n    _allowance: uint256 = self.allowance[_from][msg.sender]\r\n    if _allowance != max_value(uint256):\r\n        self._approve(_from, msg.sender, _allowance - _value)\r\n\r\n    self._transfer(_from, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef transfer(_to: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @dev Transfer token for a specified address\r\n    @param _to The address to transfer to.\r\n    @param _value The amount to be transferred.\r\n    @return bool True on successful transfer. Reverts otherwise.\r\n    \"\"\"\r\n    self._transfer(msg.sender, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef approve(_spender: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Allow `_spender` to transfer up to `_value` amount\r\n            of tokens from the caller's account.\r\n    @param _spender The account permitted to spend up to `_value` amount of\r\n                    caller's funds.\r\n    @param _value The amount of tokens `_spender` is allowed to spend.\r\n    @return bool Success\r\n    \"\"\"\r\n    self._approve(msg.sender, _spender, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef permit(\r\n    _owner: address,\r\n    _spender: address,\r\n    _value: uint256,\r\n    _deadline: uint256,\r\n    _v: uint8,\r\n    _r: bytes32,\r\n    _s: bytes32,\r\n) -> bool:\r\n    \"\"\"\r\n    @notice Permit `_spender` to spend up to `_value` amount of `_owner`'s\r\n            tokens via a signature.\r\n    @dev In the event of a chain fork, replay attacks are prevented as\r\n         domain separator is recalculated. However, this is only if the\r\n         resulting chains update their chainId.\r\n    @param _owner The account which generated the signature and is granting an\r\n                  allowance.\r\n    @param _spender The account which will be granted an allowance.\r\n    @param _value The approval amount.\r\n    @param _deadline The deadline by which the signature must be submitted.\r\n    @param _v The last byte of the ECDSA signature.\r\n    @param _r The first 32 bytes of the ECDSA signature.\r\n    @param _s The second 32 bytes of the ECDSA signature.\r\n    @return bool Success.\r\n    \"\"\"\r\n    assert _owner != empty(address)  # dev: invalid owner\r\n    assert block.timestamp <= _deadline  # dev: permit expired\r\n\r\n    nonce: uint256 = self.nonces[_owner]\r\n    digest: bytes32 = keccak256(\r\n        concat(\r\n            b\"\\x19\\x01\",\r\n            self._domain_separator(),\r\n            keccak256(\r\n                _abi_encode(\r\n                    EIP2612_TYPEHASH, _owner, _spender, _value, nonce, _deadline\r\n                )\r\n            ),\r\n        )\r\n    )\r\n    assert ecrecover(digest, _v, _r, _s) == _owner  # dev: invalid signature\r\n\r\n    self.nonces[_owner] = unsafe_add(nonce, 1)  # <-- Unsafe add is safe here.\r\n    self._approve(_owner, _spender, _value)\r\n    return True\r\n\r\n\r\n@internal\r\ndef mint(_to: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @dev Mint an amount of the token and assigns it to an account.\r\n         This encapsulates the modification of balances such that the\r\n         proper events are emitted.\r\n    @param _to The account that will receive the created tokens.\r\n    @param _value The amount that will be created.\r\n    @return bool Success.\r\n    \"\"\"\r\n    self.totalSupply += _value\r\n    self.balanceOf[_to] += _value\r\n\r\n    log Transfer(empty(address), _to, _value)\r\n    return True\r\n\r\n\r\n@internal\r\ndef burnFrom(_to: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @dev Burn an amount of the token from a given account.\r\n    @param _to The account whose tokens will be burned.\r\n    @param _value The amount that will be burned.\r\n    @return bool Success.\r\n    \"\"\"\r\n    self.totalSupply -= _value\r\n    self.balanceOf[_to] -= _value\r\n\r\n    log Transfer(_to, empty(address), _value)\r\n    return True\r\n\r\n\r\n# ------------------------- AMM View Functions -------------------------------\r\n\r\n\r\n@internal\r\n@view\r\ndef internal_price_oracle() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the oracle price of the coin at index `k` w.r.t the coin\r\n            at index 0.\r\n    @dev The oracle is an exponential moving average, with a periodicity\r\n         determined by `self.ma_time`. The aggregated prices are cached state\r\n         prices (dy/dx) calculated AFTER the latest trade.\r\n    @param k The index of the coin.\r\n    @return uint256 Price oracle value of kth coin.\r\n    \"\"\"\r\n    price_oracle: uint256 = self.cached_price_oracle\r\n    price_scale: uint256 = self.cached_price_scale\r\n    last_prices_timestamp: uint256 = self._unpack_2(self.last_timestamp)[0]\r\n\r\n    if last_prices_timestamp < block.timestamp:  # <------------ Update moving\r\n        #                                                   average if needed.\r\n\r\n        last_prices: uint256 = self.last_prices\r\n        ma_time: uint256 = self._unpack_3(self.packed_rebalancing_params)[2]\r\n        alpha: uint256 = MATH.wad_exp(\r\n            -convert(\r\n                unsafe_sub(block.timestamp, last_prices_timestamp) * 10**18 / ma_time,\r\n                int256,\r\n            )\r\n        )\r\n\r\n        # ---- We cap state price that goes into the EMA with 2 x price_scale.\r\n        return (\r\n            min(last_prices, 2 * price_scale) * (10**18 - alpha) +\r\n            price_oracle * alpha\r\n        ) / 10**18\r\n\r\n    return price_oracle\r\n\r\n\r\n@external\r\n@view\r\ndef fee_receiver() -> address:\r\n    \"\"\"\r\n    @notice Returns the address of the admin fee receiver.\r\n    @return address Fee receiver.\r\n    \"\"\"\r\n    return factory.fee_receiver()\r\n\r\n\r\n@external\r\n@view\r\ndef admin() -> address:\r\n    \"\"\"\r\n    @notice Returns the address of the pool's admin.\r\n    @return address Admin.\r\n    \"\"\"\r\n    return factory.admin()\r\n\r\n\r\n@external\r\n@view\r\ndef calc_token_amount(amounts: uint256[N_COINS], deposit: bool) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate LP tokens minted or to be burned for depositing or\r\n            removing `amounts` of coins\r\n    @dev Includes fee.\r\n    @param amounts Amounts of tokens being deposited or withdrawn\r\n    @param deposit True if it is a deposit action, False if withdrawn.\r\n    @return uint256 Amount of LP tokens deposited or withdrawn.\r\n    \"\"\"\r\n    view_contract: address = factory.views_implementation()\r\n    return Views(view_contract).calc_token_amount(amounts, deposit, self)\r\n\r\n\r\n@external\r\n@view\r\ndef get_dy(i: uint256, j: uint256, dx: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get amount of coin[j] tokens received for swapping in dx amount of coin[i]\r\n    @dev Includes fee.\r\n    @param i index of input token. Check pool.coins(i) to get coin address at ith index\r\n    @param j index of output token\r\n    @param dx amount of input coin[i] tokens\r\n    @return uint256 Exact amount of output j tokens for dx amount of i input tokens.\r\n    \"\"\"\r\n    view_contract: address = factory.views_implementation()\r\n    return Views(view_contract).get_dy(i, j, dx, self)\r\n\r\n\r\n@external\r\n@view\r\ndef get_dx(i: uint256, j: uint256, dy: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get amount of coin[i] tokens to input for swapping out dy amount\r\n            of coin[j]\r\n    @dev This is an approximate method, and returns estimates close to the input\r\n         amount. Expensive to call on-chain.\r\n    @param i index of input token. Check pool.coins(i) to get coin address at\r\n           ith index\r\n    @param j index of output token\r\n    @param dy amount of input coin[j] tokens received\r\n    @return uint256 Approximate amount of input i tokens to get dy amount of j tokens.\r\n    \"\"\"\r\n    view_contract: address = factory.views_implementation()\r\n    return Views(view_contract).get_dx(i, j, dy, self)\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant(\"lock\")\r\ndef lp_price() -> uint256:\r\n    \"\"\"\r\n    @notice Calculates the current price of the LP token w.r.t coin at the\r\n            0th index\r\n    @return uint256 LP price.\r\n    \"\"\"\r\n    return 2 * self.virtual_price * isqrt(self.internal_price_oracle() * 10**18) / 10**18\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant(\"lock\")\r\ndef get_virtual_price() -> uint256:\r\n    \"\"\"\r\n    @notice Calculates the current virtual price of the pool LP token.\r\n    @dev Not to be confused with `self.virtual_price` which is a cached\r\n         virtual price.\r\n    @return uint256 Virtual Price.\r\n    \"\"\"\r\n    return 10**18 * self.get_xcp(self.D, self.cached_price_scale) / self.totalSupply\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant(\"lock\")\r\ndef price_oracle() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the oracle price of the coin at index `k` w.r.t the coin\r\n            at index 0.\r\n    @dev The oracle is an exponential moving average, with a periodicity\r\n         determined by `self.ma_time`. The aggregated prices are cached state\r\n         prices (dy/dx) calculated AFTER the latest trade.\r\n    @return uint256 Price oracle value of kth coin.\r\n    \"\"\"\r\n    return self.internal_price_oracle()\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant(\"lock\")\r\ndef xcp_oracle() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the oracle value for xcp.\r\n    @dev The oracle is an exponential moving average, with a periodicity\r\n         determined by `self.xcp_ma_time`.\r\n         `TVL` is xcp, calculated as either:\r\n            1. virtual_price * total_supply, OR\r\n            2. self.get_xcp(...), OR\r\n            3. MATH.geometric_mean(xp)\r\n    @return uint256 Oracle value of xcp.\r\n    \"\"\"\r\n\r\n    last_prices_timestamp: uint256 = self._unpack_2(self.last_timestamp)[1]\r\n    cached_xcp_oracle: uint256 = self.cached_xcp_oracle\r\n\r\n    if last_prices_timestamp < block.timestamp:\r\n\r\n        alpha: uint256 = MATH.wad_exp(\r\n            -convert(\r\n                unsafe_div(\r\n                    unsafe_sub(block.timestamp, last_prices_timestamp) * 10**18,\r\n                    self.xcp_ma_time\r\n                ),\r\n                int256,\r\n            )\r\n        )\r\n\r\n        return (self.last_xcp * (10**18 - alpha) + cached_xcp_oracle * alpha) / 10**18\r\n\r\n    return cached_xcp_oracle\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant(\"lock\")\r\ndef price_scale() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the price scale of the coin at index `k` w.r.t the coin\r\n            at index 0.\r\n    @dev Price scale determines the price band around which liquidity is\r\n         concentrated.\r\n    @return uint256 Price scale of coin.\r\n    \"\"\"\r\n    return self.cached_price_scale\r\n\r\n\r\n@external\r\n@view\r\ndef fee() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the fee charged by the pool at current state.\r\n    @dev Not to be confused with the fee charged at liquidity action, since\r\n         there the fee is calculated on `xp` AFTER liquidity is added or\r\n         removed.\r\n    @return uint256 fee bps.\r\n    \"\"\"\r\n    return self._fee(self.xp(self.balances, self.cached_price_scale))\r\n\r\n\r\n@view\r\n@external\r\ndef calc_withdraw_one_coin(token_amount: uint256, i: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculates output tokens with fee\r\n    @param token_amount LP Token amount to burn\r\n    @param i token in which liquidity is withdrawn\r\n    @return uint256 Amount of ith tokens received for burning token_amount LP tokens.\r\n    \"\"\"\r\n\r\n    return self._calc_withdraw_one_coin(\r\n        self._A_gamma(),\r\n        token_amount,\r\n        i,\r\n        (self.future_A_gamma_time > block.timestamp)\r\n    )[0]\r\n\r\n\r\n@external\r\n@view\r\ndef calc_token_fee(\r\n    amounts: uint256[N_COINS], xp: uint256[N_COINS]\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Returns the fee charged on the given amounts for add_liquidity.\r\n    @param amounts The amounts of coins being added to the pool.\r\n    @param xp The current balances of the pool multiplied by coin precisions.\r\n    @return uint256 Fee charged.\r\n    \"\"\"\r\n    return self._calc_token_fee(amounts, xp)\r\n\r\n\r\n@view\r\n@external\r\ndef A() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the current pool amplification parameter.\r\n    @return uint256 A param.\r\n    \"\"\"\r\n    return self._A_gamma()[0]\r\n\r\n\r\n@view\r\n@external\r\ndef gamma() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the current pool gamma parameter.\r\n    @return uint256 gamma param.\r\n    \"\"\"\r\n    return self._A_gamma()[1]\r\n\r\n\r\n@view\r\n@external\r\ndef mid_fee() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the current mid fee\r\n    @return uint256 mid_fee value.\r\n    \"\"\"\r\n    return self._unpack_3(self.packed_fee_params)[0]\r\n\r\n\r\n@view\r\n@external\r\ndef out_fee() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the current out fee\r\n    @return uint256 out_fee value.\r\n    \"\"\"\r\n    return self._unpack_3(self.packed_fee_params)[1]\r\n\r\n\r\n@view\r\n@external\r\ndef fee_gamma() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the current fee gamma\r\n    @return uint256 fee_gamma value.\r\n    \"\"\"\r\n    return self._unpack_3(self.packed_fee_params)[2]\r\n\r\n\r\n@view\r\n@external\r\ndef allowed_extra_profit() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the current allowed extra profit\r\n    @return uint256 allowed_extra_profit value.\r\n    \"\"\"\r\n    return self._unpack_3(self.packed_rebalancing_params)[0]\r\n\r\n\r\n@view\r\n@external\r\ndef adjustment_step() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the current adjustment step\r\n    @return uint256 adjustment_step value.\r\n    \"\"\"\r\n    return self._unpack_3(self.packed_rebalancing_params)[1]\r\n\r\n\r\n@view\r\n@external\r\ndef ma_time() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the current moving average time in seconds\r\n    @dev To get time in seconds, the parameter is multipled by ln(2)\r\n         One can expect off-by-one errors here.\r\n    @return uint256 ma_time value.\r\n    \"\"\"\r\n    return self._unpack_3(self.packed_rebalancing_params)[2] * 694 / 1000\r\n\r\n\r\n@view\r\n@external\r\ndef precisions() -> uint256[N_COINS]:  # <-------------- For by view contract.\r\n    \"\"\"\r\n    @notice Returns the precisions of each coin in the pool.\r\n    @return uint256[3] precisions of coins.\r\n    \"\"\"\r\n    return PRECISIONS\r\n\r\n\r\n@external\r\n@view\r\ndef fee_calc(xp: uint256[N_COINS]) -> uint256:  # <----- For by view contract.\r\n    \"\"\"\r\n    @notice Returns the fee charged by the pool at current state.\r\n    @param xp The current balances of the pool multiplied by coin precisions.\r\n    @return uint256 Fee value.\r\n    \"\"\"\r\n    return self._fee(xp)\r\n\r\n\r\n@view\r\n@external\r\ndef DOMAIN_SEPARATOR() -> bytes32:\r\n    \"\"\"\r\n    @notice EIP712 domain separator.\r\n    @return bytes32 Domain Separator set for the current chain.\r\n    \"\"\"\r\n    return self._domain_separator()\r\n\r\n\r\n# ------------------------- AMM Admin Functions ------------------------------\r\n\r\n\r\n@external\r\ndef ramp_A_gamma(\r\n    future_A: uint256, future_gamma: uint256, future_time: uint256\r\n):\r\n    \"\"\"\r\n    @notice Initialise Ramping A and gamma parameter values linearly.\r\n    @dev Only accessible by factory admin, and only\r\n    @param future_A The future A value.\r\n    @param future_gamma The future gamma value.\r\n    @param future_time The timestamp at which the ramping will end.\r\n    \"\"\"\r\n    assert msg.sender == factory.admin()  # dev: only owner\r\n    assert block.timestamp > self.initial_A_gamma_time + (MIN_RAMP_TIME - 1)  # dev: ramp undergoing\r\n    assert future_time > block.timestamp + MIN_RAMP_TIME - 1  # dev: insufficient time\r\n\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n    initial_A_gamma: uint256 = A_gamma[0] << 128\r\n    initial_A_gamma = initial_A_gamma | A_gamma[1]\r\n\r\n    assert future_A > MIN_A - 1\r\n    assert future_A < MAX_A + 1\r\n    assert future_gamma > MIN_GAMMA - 1\r\n    assert future_gamma < MAX_GAMMA + 1\r\n\r\n    ratio: uint256 = 10**18 * future_A / A_gamma[0]\r\n    assert ratio < 10**18 * MAX_A_CHANGE + 1\r\n    assert ratio > 10**18 / MAX_A_CHANGE - 1\r\n\r\n    ratio = 10**18 * future_gamma / A_gamma[1]\r\n    assert ratio < 10**18 * MAX_A_CHANGE + 1\r\n    assert ratio > 10**18 / MAX_A_CHANGE - 1\r\n\r\n    self.initial_A_gamma = initial_A_gamma\r\n    self.initial_A_gamma_time = block.timestamp\r\n\r\n    future_A_gamma: uint256 = future_A << 128\r\n    future_A_gamma = future_A_gamma | future_gamma\r\n    self.future_A_gamma_time = future_time\r\n    self.future_A_gamma = future_A_gamma\r\n\r\n    log RampAgamma(\r\n        A_gamma[0],\r\n        future_A,\r\n        A_gamma[1],\r\n        future_gamma,\r\n        block.timestamp,\r\n        future_time,\r\n    )\r\n\r\n\r\n@external\r\ndef stop_ramp_A_gamma():\r\n    \"\"\"\r\n    @notice Stop Ramping A and gamma parameters immediately.\r\n    @dev Only accessible by factory admin.\r\n    \"\"\"\r\n    assert msg.sender == factory.admin()  # dev: only owner\r\n\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n    current_A_gamma: uint256 = A_gamma[0] << 128\r\n    current_A_gamma = current_A_gamma | A_gamma[1]\r\n    self.initial_A_gamma = current_A_gamma\r\n    self.future_A_gamma = current_A_gamma\r\n    self.initial_A_gamma_time = block.timestamp\r\n    self.future_A_gamma_time = block.timestamp\r\n\r\n    # ------ Now (block.timestamp < t1) is always False, so we return saved A.\r\n\r\n    log StopRampA(A_gamma[0], A_gamma[1], block.timestamp)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef apply_new_parameters(\r\n    _new_mid_fee: uint256,\r\n    _new_out_fee: uint256,\r\n    _new_fee_gamma: uint256,\r\n    _new_allowed_extra_profit: uint256,\r\n    _new_adjustment_step: uint256,\r\n    _new_ma_time: uint256,\r\n    _new_xcp_ma_time: uint256,\r\n):\r\n    \"\"\"\r\n    @notice Commit new parameters.\r\n    @dev Only accessible by factory admin.\r\n    @param _new_mid_fee The new mid fee.\r\n    @param _new_out_fee The new out fee.\r\n    @param _new_fee_gamma The new fee gamma.\r\n    @param _new_allowed_extra_profit The new allowed extra profit.\r\n    @param _new_adjustment_step The new adjustment step.\r\n    @param _new_ma_time The new ma time. ma_time is time_in_seconds/ln(2).\r\n    @param _new_xcp_ma_time The new ma time for xcp oracle.\r\n    \"\"\"\r\n    assert msg.sender == factory.admin()  # dev: only owner\r\n\r\n    # ----------------------------- Set fee params ---------------------------\r\n\r\n    new_mid_fee: uint256 = _new_mid_fee\r\n    new_out_fee: uint256 = _new_out_fee\r\n    new_fee_gamma: uint256 = _new_fee_gamma\r\n\r\n    current_fee_params: uint256[3] = self._unpack_3(self.packed_fee_params)\r\n\r\n    if new_out_fee < MAX_FEE + 1:\r\n        assert new_out_fee > MIN_FEE - 1  # dev: fee is out of range\r\n    else:\r\n        new_out_fee = current_fee_params[1]\r\n\r\n    if new_mid_fee > MAX_FEE:\r\n        new_mid_fee = current_fee_params[0]\r\n    assert new_mid_fee <= new_out_fee  # dev: mid-fee is too high\r\n\r\n    if new_fee_gamma < 10**18:\r\n        assert new_fee_gamma > 0  # dev: fee_gamma out of range [1 .. 10**18]\r\n    else:\r\n        new_fee_gamma = current_fee_params[2]\r\n\r\n    self.packed_fee_params = self._pack_3([new_mid_fee, new_out_fee, new_fee_gamma])\r\n\r\n    # ----------------- Set liquidity rebalancing parameters -----------------\r\n\r\n    new_allowed_extra_profit: uint256 = _new_allowed_extra_profit\r\n    new_adjustment_step: uint256 = _new_adjustment_step\r\n    new_ma_time: uint256 = _new_ma_time\r\n\r\n    current_rebalancing_params: uint256[3] = self._unpack_3(self.packed_rebalancing_params)\r\n\r\n    if new_allowed_extra_profit > 10**18:\r\n        new_allowed_extra_profit = current_rebalancing_params[0]\r\n\r\n    if new_adjustment_step > 10**18:\r\n        new_adjustment_step = current_rebalancing_params[1]\r\n\r\n    if new_ma_time < 872542:  # <----- Calculated as: 7 * 24 * 60 * 60 / ln(2)\r\n        assert new_ma_time > 86  # dev: MA time should be longer than 60/ln(2)\r\n    else:\r\n        new_ma_time = current_rebalancing_params[2]\r\n\r\n    self.packed_rebalancing_params = self._pack_3(\r\n        [new_allowed_extra_profit, new_adjustment_step, new_ma_time]\r\n    )\r\n\r\n    # Set xcp oracle moving average window time:\r\n    new_xcp_ma_time: uint256 = _new_xcp_ma_time\r\n    if new_xcp_ma_time < 872542:\r\n        assert new_xcp_ma_time > 86  # dev: xcp MA time should be longer than 60/ln(2)\r\n    else:\r\n        new_xcp_ma_time = self.xcp_ma_time\r\n    self.xcp_ma_time = new_xcp_ma_time\r\n\r\n    # ---------------------------------- LOG ---------------------------------\r\n\r\n    log NewParameters(\r\n        new_mid_fee,\r\n        new_out_fee,\r\n        new_fee_gamma,\r\n        new_allowed_extra_profit,\r\n        new_adjustment_step,\r\n        new_ma_time,\r\n        _new_xcp_ma_time,\r\n    )", "ABI": "[{\"name\":\"Transfer\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"spender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TokenExchange\",\"inputs\":[{\"name\":\"buyer\",\"type\":\"address\",\"indexed\":true},{\"name\":\"sold_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"tokens_sold\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"bought_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"tokens_bought\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"packed_price_scale\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AddLiquidity\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_amounts\",\"type\":\"uint256[2]\",\"indexed\":false},{\"name\":\"fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"token_supply\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"packed_price_scale\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquidity\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_amounts\",\"type\":\"uint256[2]\",\"indexed\":false},{\"name\":\"token_supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquidityOne\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"coin_index\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"coin_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"approx_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"packed_price_scale\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewParameters\",\"inputs\":[{\"name\":\"mid_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"out_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"fee_gamma\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"allowed_extra_profit\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"adjustment_step\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"ma_time\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"xcp_ma_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RampAgamma\",\"inputs\":[{\"name\":\"initial_A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"future_A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"initial_gamma\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"future_gamma\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"initial_time\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"future_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"StopRampA\",\"inputs\":[{\"name\":\"current_A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"current_gamma\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ClaimAdminFee\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":true},{\"name\":\"tokens\",\"type\":\"uint256[2]\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_coins\",\"type\":\"address[2]\"},{\"name\":\"_math\",\"type\":\"address\"},{\"name\":\"_salt\",\"type\":\"bytes32\"},{\"name\":\"packed_precisions\",\"type\":\"uint256\"},{\"name\":\"packed_gamma_A\",\"type\":\"uint256\"},{\"name\":\"packed_fee_params\",\"type\":\"uint256\"},{\"name\":\"packed_rebalancing_params\",\"type\":\"uint256\"},{\"name\":\"initial_price\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"},{\"name\":\"min_dy\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"},{\"name\":\"min_dy\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange_received\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"},{\"name\":\"min_dy\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange_received\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"},{\"name\":\"min_dy\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"amounts\",\"type\":\"uint256[2]\"},{\"name\":\"min_mint_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"amounts\",\"type\":\"uint256[2]\"},{\"name\":\"min_mint_amount\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"min_amounts\",\"type\":\"uint256[2]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"min_amounts\",\"type\":\"uint256[2]\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"min_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"min_amount\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transferFrom\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transfer\",\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"approve\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"permit\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_deadline\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee_receiver\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_token_amount\",\"inputs\":[{\"name\":\"amounts\",\"type\":\"uint256[2]\"},{\"name\":\"deposit\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dy\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dx\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dy\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lp_price\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_virtual_price\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"price_oracle\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"xcp_oracle\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"price_scale\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_withdraw_one_coin\",\"inputs\":[{\"name\":\"token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_token_fee\",\"inputs\":[{\"name\":\"amounts\",\"type\":\"uint256[2]\"},{\"name\":\"xp\",\"type\":\"uint256[2]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"A\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gamma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"mid_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"out_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee_gamma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allowed_extra_profit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"adjustment_step\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"ma_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"precisions\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee_calc\",\"inputs\":[{\"name\":\"xp\",\"type\":\"uint256[2]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"DOMAIN_SEPARATOR\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"ramp_A_gamma\",\"inputs\":[{\"name\":\"future_A\",\"type\":\"uint256\"},{\"name\":\"future_gamma\",\"type\":\"uint256\"},{\"name\":\"future_time\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"stop_ramp_A_gamma\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"apply_new_parameters\",\"inputs\":[{\"name\":\"_new_mid_fee\",\"type\":\"uint256\"},{\"name\":\"_new_out_fee\",\"type\":\"uint256\"},{\"name\":\"_new_fee_gamma\",\"type\":\"uint256\"},{\"name\":\"_new_allowed_extra_profit\",\"type\":\"uint256\"},{\"name\":\"_new_adjustment_step\",\"type\":\"uint256\"},{\"name\":\"_new_ma_time\",\"type\":\"uint256\"},{\"name\":\"_new_xcp_ma_time\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"MATH\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"coins\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"factory\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_prices\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_timestamp\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_xcp\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"xcp_ma_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"initial_A_gamma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"initial_A_gamma_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_A_gamma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_A_gamma_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balances\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"D\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"xcp_profit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"xcp_profit_a\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"virtual_price\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"packed_rebalancing_params\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"packed_fee_params\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"ADMIN_FEE\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"decimals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"version\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allowance\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"nonces\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"salt\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]}]", "ContractName": "CurveTwocryptoOptimized", "CompilerVersion": "vyper:0.3.10", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000f939e0a03fb07f59a73314e73794be0e57ac1b4e0000000000000000000000001cfa5641c01406ab8ac350ded7d735ec412983720000000000000000000000002005995a71243be9fb995dab4742327dc76564dfb6b7c20982b8ac1ec1d2250f124d715e7458971a0e9f4cd23fc607f6176f2d310000000000000000000000000000000100000000000000000000000000000001000000000000000000000000004c4b400000000000000000002386f26fc10000000000000000000000000000004c4b400000000002aea5400011c37937e08000000000000000000000000002540be40000000500918bd8000000000000000258000000000000000000000000000000000000000000000000001826beb72ee000000000000000000000000000000000000000000000000000000000000000000b6372765553442f434a5059000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a637276555344434a505900000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}