{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Wombats.sol\": {\r\n      \"content\": \"// https://www.wombats.money/\\n// https://twitter.com/1000WOMBATS\\n// https://github.com/eWOMBATS/wombats\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nlibrary LibERC20 {\\n    event Transfer(address indexed from, address indexed to, uint amount);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function emitTransfer(address _from, address _to, uint _amount) internal {\\n        emit Transfer(_from, _to, _amount);\\n    }\\n\\n    function emitApproval(\\n        address _owner,\\n        address _spender,\\n        uint _value\\n    ) internal {\\n        emit Approval(_owner, _spender, _value);\\n    }\\n}\\n\\nlibrary LibERC721 {\\n    event Transfer(\\n        address indexed _from,\\n        address indexed _to,\\n        uint indexed _tokenId\\n    );\\n    event Approval(\\n        address indexed _owner,\\n        address indexed _approved,\\n        uint indexed _tokenId\\n    );\\n    event ApprovalForAll(\\n        address indexed _owner,\\n        address indexed _operator,\\n        bool _approved\\n    );\\n\\n    function emitTransfer(address _from, address _to, uint _tokenId) internal {\\n        emit Transfer(_from, _to, _tokenId);\\n    }\\n\\n    function emitApproval(\\n        address _owner,\\n        address _approve,\\n        uint _tokenId\\n    ) internal {\\n        emit Approval(_owner, _approve, _tokenId);\\n    }\\n\\n    function emitApprovalForAll(\\n        address _owner,\\n        address _operator,\\n        bool _approved\\n    ) internal {\\n        emit ApprovalForAll(_owner, _operator, _approved);\\n    }\\n}\\n\\ninterface IERC165 {\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\\ninterface IERC20 {\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\\ninterface IERC721 is IERC165 {\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function ownerOf(uint256 _tokenId) external view returns (address);\\n\\n    function safeTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _tokenId,\\n        bytes memory data\\n    ) external payable;\\n\\n    function safeTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _tokenId\\n    ) external payable;\\n\\n    function setApprovalForAll(address _operator, bool _approved) external;\\n\\n    function getApproved(uint256 _tokenId) external view returns (address);\\n\\n    function isApprovedForAll(\\n        address _owner,\\n        address _operator\\n    ) external view returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\\ninterface IERC404 is IERC20, IERC721 {\\n    function balanceOf(\\n        address account\\n    ) external view override(IERC20, IERC721) returns (uint256);\\n\\n    function approve(\\n        address spender,\\n        uint256 value\\n    ) external override(IERC20, IERC721) returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external override(IERC20, IERC721) returns (bool);\\n}\\n\\ninterface IERC721TokenReceiver {\\n    function onERC721Received(\\n        address _operator,\\n        address _from,\\n        uint256 _tokenId,\\n        bytes memory _data\\n    ) external returns (bytes4);\\n}\\n\\ncontract Wombats is IERC404 {\\n    string public baseURI;\\n    string internal constant _name = \\\"Wombats\\\";\\n    string internal constant _symbol = \\\"Wombats\\\";\\n\\n    uint internal constant _decimals = 18;\\n    uint internal constant _totalIds = 1000;\\n    uint internal constant _totalSupply = _totalIds * 10 ** _decimals;\\n    uint internal constant ONE = 10 ** _decimals;\\n    uint internal constant MAX_ID = ONE + _totalIds;\\n\\n    uint32 public minted;\\n    uint32[] private broken;\\n\\n    address public _owner;\\n    bool public supportsNFTinterface;\\n\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n    mapping(address => mapping(address => uint)) internal _allowance;\\n    mapping(uint256 tokenId => address) public ownerOf;\\n    mapping(uint256 => address) private _nftApprovals;\\n    mapping(address => uint) internal _balanceOf;\\n    mapping(address => uint32[]) public ownedNFTs;\\n    mapping(uint32 => uint256) private idToIndex;\\n\\n    error UnsupportedReceiver();\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == _owner, \\\"Only owner allowed\\\");\\n        _;\\n    }\\n\\n    constructor() {\\n        minted = uint32(ONE);\\n        _balanceOf[msg.sender] = _totalSupply;\\n        _owner = msg.sender;\\n    }\\n\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual returns (uint) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public pure override returns (uint) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint) {\\n        return _balanceOf[account];\\n    }\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) public view override returns (uint) {\\n        return _allowance[owner][spender];\\n    }\\n\\n    function setBaseURI(string memory newBaseURI) public onlyOwner {\\n        baseURI = newBaseURI;\\n    }\\n\\n    function changeDev(address newDev) public onlyOwner {\\n        _owner = newDev;\\n    }\\n\\n    function toggelNFTinterface() public onlyOwner {\\n        supportsNFTinterface = !supportsNFTinterface;\\n    }\\n\\n    function approve(\\n        address spender,\\n        uint amount\\n    ) public override returns (bool) {\\n        if (amount > ONE && amount <= MAX_ID) {\\n            address owner = ownerOf[amount];\\n            if (msg.sender != owner && !isApprovedForAll(owner, msg.sender))\\n                revert(\\\"You are not approved\\\");\\n            _nftApprovals[amount] = spender;\\n            LibERC721.emitApproval(owner, spender, amount);\\n            return true;\\n        }\\n\\n        _allowance[msg.sender][spender] = amount;\\n        LibERC20.emitApproval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function _transfer404(\\n        address from,\\n        address to,\\n        uint amount\\n    ) internal virtual {\\n        require(_balanceOf[from] >= amount, \\\"Transfer amount exceeds balance\\\");\\n\\n        uint256 fromDecimalsPre = _balanceOf[from] % ONE;\\n        uint256 toDecimalsPre = _balanceOf[to] % ONE;\\n\\n        _transfer20(from, to, amount);\\n\\n        uint256 fromDecimalsPost = _balanceOf[from] % ONE;\\n        uint256 toDecimalsPost = _balanceOf[to] % ONE;\\n\\n        uint32[] storage ownedNFTsArray = ownedNFTs[from];\\n\\n        uint32[] storage brokenIDsArray = broken;\\n\\n        if (fromDecimalsPre < fromDecimalsPost) {\\n            if (ownedNFTsArray.length > 0) {\\n                uint32 tokenId = ownedNFTsArray[0];\\n\\n                brokenIDsArray.push(tokenId);\\n                _transfer721(from, address(0), tokenId);\\n            }\\n        }\\n\\n        if (toDecimalsPre > toDecimalsPost) {\\n            if (brokenIDsArray.length > 0) {\\n                _transfer721(\\n                    address(0),\\n                    to,\\n                    brokenIDsArray[brokenIDsArray.length - 1]\\n                );\\n                brokenIDsArray.pop();\\n            } else {\\n                _mint(to);\\n            }\\n        }\\n\\n        uint amountInTokens = amount / ONE;\\n        if (from == _owner) return;\\n\\n        if (amountInTokens > 0) {\\n            uint len = ownedNFTsArray.length;\\n            len = amountInTokens < len ? amountInTokens : len;\\n            for (uint i = 0; i < len; i++) {\\n                _transfer721(from, to, ownedNFTsArray[0]);\\n            }\\n            amountInTokens -= len;\\n            len = brokenIDsArray.length;\\n            len = amountInTokens < len ? amountInTokens : len;\\n            for (uint i = 0; i < len; i++) {\\n                _transfer721(\\n                    address(0),\\n                    to,\\n                    brokenIDsArray[brokenIDsArray.length - 1]\\n                );\\n                brokenIDsArray.pop();\\n            }\\n\\n            _mintBatch(to, amountInTokens - len);\\n        }\\n    }\\n\\n    function _mintBatch(address to, uint256 amount) internal {\\n        if (amount == 0) return;\\n\\n        if (amount == 1) {\\n            _mint(to);\\n            return;\\n        }\\n        uint32 id = minted;\\n        uint256 ownedLen = ownedNFTs[to].length;\\n        for (uint i = 0; i < amount; ) {\\n            unchecked {\\n                id++;\\n            }\\n            ownerOf[id] = to;\\n            idToIndex[id] = ownedLen;\\n            ownedNFTs[to].push(id);\\n\\n            LibERC721.emitTransfer(address(0), to, id);\\n\\n            unchecked {\\n                ownedLen++;\\n                i++;\\n            }\\n        }\\n        unchecked {\\n            minted += uint32(amount);\\n        }\\n    }\\n\\n    function _mint(address to) internal returns (uint32 tokenId) {\\n        unchecked {\\n            minted++;\\n        }\\n        tokenId = minted;\\n\\n        ownerOf[tokenId] = to;\\n        idToIndex[tokenId] = ownedNFTs[to].length;\\n        ownedNFTs[to].push(tokenId);\\n\\n        LibERC721.emitTransfer(address(0), to, tokenId);\\n    }\\n\\n    function _updateOwnedNFTs(\\n        address from,\\n        address to,\\n        uint32 tokenId\\n    ) internal {\\n        uint256 index = idToIndex[tokenId];\\n        uint32[] storage nftArray = ownedNFTs[from];\\n        uint256 len = nftArray.length;\\n        uint32 lastTokenId = nftArray[len - 1];\\n\\n        nftArray[index] = lastTokenId;\\n        nftArray.pop();\\n\\n        if (len - 1 != 0) {\\n            idToIndex[lastTokenId] = index;\\n        }\\n\\n        ownedNFTs[to].push(tokenId);\\n        idToIndex[tokenId] = ownedNFTs[to].length - 1;\\n    }\\n\\n    function _transfer20(address from, address to, uint256 amount) internal {\\n        _balanceOf[from] -= amount;\\n        unchecked {\\n            _balanceOf[to] += amount;\\n        }\\n        LibERC20.emitTransfer(from, to, amount);\\n    }\\n\\n    function _transfer721(\\n        address from,\\n        address to,\\n        uint32 tokenId\\n    ) internal virtual {\\n        require(from == ownerOf[tokenId], \\\"Different owner\\\");\\n\\n        delete _nftApprovals[tokenId];\\n        ownerOf[tokenId] = to;\\n        _updateOwnedNFTs(from, to, tokenId);\\n        LibERC721.emitTransfer(from, to, tokenId);\\n    }\\n\\n    function transfer(address to, uint amount) public override returns (bool) {\\n        if (ownerOf[amount] == msg.sender) {\\n            _transfer721(msg.sender, to, uint32(amount));\\n            _transfer20(msg.sender, to, ONE);\\n            return true;\\n        }\\n        _transfer404(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint amount\\n    ) public override returns (bool) {\\n        if (amount > ONE && amount <= MAX_ID) {\\n            require(\\n                msg.sender == from ||\\n                    msg.sender == getApproved(amount) ||\\n                    isApprovedForAll(from, msg.sender),\\n                \\\"Not allowed\\\"\\n            );\\n\\n            _transfer721(from, to, uint32(amount));\\n            _transfer20(from, to, ONE);\\n            return true;\\n        }\\n\\n        _spendAllowance(from, msg.sender, amount);\\n        _transfer404(from, to, amount);\\n        return true;\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable override {\\n        require(\\n            msg.sender == from ||\\n                msg.sender == getApproved(tokenId) ||\\n                isApprovedForAll(from, msg.sender),\\n            \\\"Not allowed\\\"\\n        );\\n        _transfer721(from, to, uint32(tokenId));\\n        _transfer20(from, to, ONE);\\n\\n        if (\\n            to.code.length != 0 &&\\n            IERC721TokenReceiver(to).onERC721Received(\\n                msg.sender,\\n                from,\\n                tokenId,\\n                \\\"\\\"\\n            ) !=\\n            IERC721TokenReceiver.onERC721Received.selector\\n        ) {\\n            revert UnsupportedReceiver();\\n        }\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public payable override {\\n        require(\\n            msg.sender == from ||\\n                msg.sender == getApproved(tokenId) ||\\n                isApprovedForAll(from, msg.sender),\\n            \\\"Not allowed\\\"\\n        );\\n        _transfer721(from, to, uint32(tokenId));\\n        _transfer20(from, to, ONE);\\n\\n        if (\\n            to.code.length != 0 &&\\n            IERC721TokenReceiver(to).onERC721Received(\\n                msg.sender,\\n                from,\\n                tokenId,\\n                data\\n            ) !=\\n            IERC721TokenReceiver.onERC721Received.selector\\n        ) {\\n            revert UnsupportedReceiver();\\n        }\\n    }\\n\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint amount\\n    ) internal virtual {\\n        require(_allowance[owner][spender] >= amount, \\\"Insufficient allowance\\\");\\n        _allowance[owner][spender] -= amount;\\n    }\\n\\n    function getApproved(\\n        uint256 tokenId\\n    ) public view override returns (address) {\\n        if (ownerOf[tokenId] == address(0)) revert();\\n        return _nftApprovals[tokenId];\\n    }\\n\\n    function setApprovalForAll(\\n        address operator,\\n        bool approved\\n    ) public override {\\n        _operatorApprovals[msg.sender][operator] = approved;\\n        LibERC721.emitApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function isApprovedForAll(\\n        address owner,\\n        address operator\\n    ) public view override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    function tokenURI(uint256 id_) public view virtual returns (string memory) {\\n        uint256 n = (uint256(keccak256(abi.encodePacked(id_))) % 1000) + 1;\\n        return string.concat(baseURI, string.concat(toString(n), \\\".png\\\"));\\n    }\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(value % 10) + 48);\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    function withdraw() external onlyOwner {\\n        payable(_owner).transfer(address(this).balance);\\n    }\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view override returns (bool) {\\n        return\\n            (supportsNFTinterface && interfaceId == 0x80ac58cd) ||\\n            interfaceId == 0x01ffc9a7 ||\\n            interfaceId == 0x36372b07;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"UnsupportedReceiver\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDev\",\"type\":\"address\"}],\"name\":\"changeDev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minted\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownedNFTs\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supportsNFTinterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggelNFTinterface\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Wombats", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}