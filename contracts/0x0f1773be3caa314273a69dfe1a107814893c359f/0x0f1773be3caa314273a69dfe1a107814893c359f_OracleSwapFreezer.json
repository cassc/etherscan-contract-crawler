{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/contracts/facilitators/gsm/swapFreezer/OracleSwapFreezer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport {IPoolAddressesProvider} from '@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol';\\nimport {IPriceOracle} from '@aave/core-v3/contracts/interfaces/IPriceOracle.sol';\\nimport {AutomationCompatibleInterface} from '../dependencies/chainlink/AutomationCompatibleInterface.sol';\\nimport {IGsm} from '../interfaces/IGsm.sol';\\n\\n/**\\n * @title OracleSwapFreezer\\n * @author Aave\\n * @notice Swap freezer that enacts the freeze action based on underlying oracle price, GSM's state and predefined price boundaries\\n * @dev Chainlink Automation-compatible contract using Aave V3 Price Oracle, where prices are USD denominated with 8-decimal precision\\n * @dev Freeze action is executable if GSM is not seized, not frozen and price is outside of the freeze bounds\\n * @dev Unfreeze action is executable if GSM is not seized, frozen, unfreezing is allowed and price is inside the unfreeze bounds\\n */\\ncontract OracleSwapFreezer is AutomationCompatibleInterface {\\n  enum Action {\\n    NONE,\\n    FREEZE,\\n    UNFREEZE\\n  }\\n\\n  IGsm public immutable GSM;\\n  address public immutable UNDERLYING_ASSET;\\n  IPoolAddressesProvider public immutable ADDRESS_PROVIDER;\\n  uint128 internal immutable _freezeLowerBound;\\n  uint128 internal immutable _freezeUpperBound;\\n  uint128 internal immutable _unfreezeLowerBound;\\n  uint128 internal immutable _unfreezeUpperBound;\\n  bool internal immutable _allowUnfreeze;\\n\\n  /**\\n   * @dev Constructor\\n   * @dev Freeze/unfreeze bounds are specified in USD with 8-decimal precision, like Aave v3 Price Oracles\\n   * @dev Unfreeze boundaries are \\\"contained\\\" in freeze boundaries, where freezeLowerBound < unfreezeLowerBound and unfreezeUpperBound < freezeUpperBound\\n   * @dev All bound ranges are inclusive\\n   * @param gsm The GSM that this contract will trigger freezes/unfreezes on\\n   * @param underlyingAsset The address of the collateral asset\\n   * @param addressProvider The Aave Addresses Provider for looking up the Price Oracle\\n   * @param freezeLowerBound The lower price bound for freeze operations\\n   * @param freezeUpperBound The upper price bound for freeze operations\\n   * @param unfreezeLowerBound The lower price bound for unfreeze operations, must be 0 if unfreezing not allowed\\n   * @param unfreezeUpperBound The upper price bound for unfreeze operations, must be 0 if unfreezing not allowed\\n   * @param allowUnfreeze True if bounds verification should factor in the unfreeze boundary, false otherwise\\n   */\\n  constructor(\\n    IGsm gsm,\\n    address underlyingAsset,\\n    IPoolAddressesProvider addressProvider,\\n    uint128 freezeLowerBound,\\n    uint128 freezeUpperBound,\\n    uint128 unfreezeLowerBound,\\n    uint128 unfreezeUpperBound,\\n    bool allowUnfreeze\\n  ) {\\n    require(gsm.UNDERLYING_ASSET() == underlyingAsset, 'UNDERLYING_ASSET_MISMATCH');\\n    require(\\n      _validateBounds(\\n        freezeLowerBound,\\n        freezeUpperBound,\\n        unfreezeLowerBound,\\n        unfreezeUpperBound,\\n        allowUnfreeze\\n      ),\\n      'BOUNDS_NOT_VALID'\\n    );\\n    GSM = gsm;\\n    UNDERLYING_ASSET = underlyingAsset;\\n    ADDRESS_PROVIDER = addressProvider;\\n    _freezeLowerBound = freezeLowerBound;\\n    _freezeUpperBound = freezeUpperBound;\\n    _unfreezeLowerBound = unfreezeLowerBound;\\n    _unfreezeUpperBound = unfreezeUpperBound;\\n    _allowUnfreeze = allowUnfreeze;\\n  }\\n\\n  /// @inheritdoc AutomationCompatibleInterface\\n  function performUpkeep(bytes calldata) external {\\n    Action action = _getAction();\\n    if (action == Action.FREEZE) {\\n      GSM.setSwapFreeze(true);\\n    } else if (action == Action.UNFREEZE) {\\n      GSM.setSwapFreeze(false);\\n    }\\n  }\\n\\n  /// @inheritdoc AutomationCompatibleInterface\\n  function checkUpkeep(bytes calldata) external view returns (bool, bytes memory) {\\n    return (_getAction() == Action.NONE ? false : true, '');\\n  }\\n\\n  /**\\n   * @notice Returns whether or not the swap freezer can unfreeze a GSM\\n   * @return True if the freezer can unfreeze, false otherwise\\n   */\\n  function getCanUnfreeze() external view returns (bool) {\\n    return _allowUnfreeze;\\n  }\\n\\n  /**\\n   * @notice Returns the bound used for freeze operations\\n   * @return The freeze lower bound (inclusive)\\n   * @return The freeze upper bound (inclusive)\\n   */\\n  function getFreezeBound() external view returns (uint128, uint128) {\\n    return (_freezeLowerBound, _freezeUpperBound);\\n  }\\n\\n  /**\\n   * @notice Returns the bound used for unfreeze operations, or (0, 0) if unfreezing not allowed\\n   * @return The unfreeze lower bound (inclusive), or 0 if unfreezing not allowed\\n   * @return The unfreeze upper bound (inclusive), or 0 if unfreezing not allowed\\n   */\\n  function getUnfreezeBound() external view returns (uint128, uint128) {\\n    return (_unfreezeLowerBound, _unfreezeUpperBound);\\n  }\\n\\n  /**\\n   * @notice Fetches price oracle data and checks whether a swap freeze or unfreeze action is required\\n   * @return The action to take (none, freeze, or unfreeze)\\n   */\\n  function _getAction() internal view returns (Action) {\\n    if (GSM.getIsSeized()) {\\n      return Action.NONE;\\n    } else if (!GSM.getIsFrozen()) {\\n      if (_isActionAllowed(Action.FREEZE)) {\\n        return Action.FREEZE;\\n      }\\n    } else if (_allowUnfreeze) {\\n      if (_isActionAllowed(Action.UNFREEZE)) {\\n        return Action.UNFREEZE;\\n      }\\n    }\\n    return Action.NONE;\\n  }\\n\\n  /**\\n   * @notice Checks whether the action is allowed, based on the action, oracle price and freeze/unfreeze bounds\\n   * @dev Freeze action is allowed if price is outside of the freeze bounds\\n   * @dev Unfreeze action is allowed if price is inside the unfreeze bounds\\n   * @param actionToExecute The requested action type to validate\\n   * @return True if conditions to execute the action passed are met, false otherwise\\n   */\\n  function _isActionAllowed(Action actionToExecute) internal view returns (bool) {\\n    uint256 oraclePrice = IPriceOracle(ADDRESS_PROVIDER.getPriceOracle()).getAssetPrice(\\n      UNDERLYING_ASSET\\n    );\\n    // Assume a 0 oracle price is invalid and no action should be taken based on that data\\n    if (oraclePrice == 0) {\\n      return false;\\n    } else if (actionToExecute == Action.FREEZE) {\\n      if (oraclePrice <= _freezeLowerBound || oraclePrice >= _freezeUpperBound) {\\n        return true;\\n      }\\n    } else if (actionToExecute == Action.UNFREEZE) {\\n      if (oraclePrice >= _unfreezeLowerBound && oraclePrice <= _unfreezeUpperBound) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * @notice Verifies that the unfreeze bound and freeze bounds do not conflict, causing unexpected behaviour\\n   * @param freezeLowerBound The lower bound for freeze operations\\n   * @param freezeUpperBound The upper bound for freeze operations\\n   * @param unfreezeLowerBound The lower bound for unfreeze operations, must be 0 if unfreezing not allowed\\n   * @param unfreezeUpperBound The upper bound for unfreeze operations, must be 0 if unfreezing not allowed\\n   * @param allowUnfreeze True if bounds verification should factor in the unfreeze boundary, false otherwise\\n   * @return True if the bounds are valid and conflict-free, false otherwise\\n   */\\n  function _validateBounds(\\n    uint128 freezeLowerBound,\\n    uint128 freezeUpperBound,\\n    uint128 unfreezeLowerBound,\\n    uint128 unfreezeUpperBound,\\n    bool allowUnfreeze\\n  ) internal pure returns (bool) {\\n    if (freezeLowerBound >= freezeUpperBound) {\\n      return false;\\n    } else if (allowUnfreeze) {\\n      if (\\n        unfreezeLowerBound >= unfreezeUpperBound ||\\n        freezeLowerBound >= unfreezeLowerBound ||\\n        freezeUpperBound <= unfreezeUpperBound\\n      ) {\\n        return false;\\n      }\\n    } else {\\n      if (unfreezeLowerBound != 0 || unfreezeUpperBound != 0) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"node_modules/@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IPoolAddressesProvider\\n * @author Aave\\n * @notice Defines the basic interface for a Pool Addresses Provider.\\n */\\ninterface IPoolAddressesProvider {\\n  /**\\n   * @dev Emitted when the market identifier is updated.\\n   * @param oldMarketId The old id of the market\\n   * @param newMarketId The new id of the market\\n   */\\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\\n\\n  /**\\n   * @dev Emitted when the pool is updated.\\n   * @param oldAddress The old address of the Pool\\n   * @param newAddress The new address of the Pool\\n   */\\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the pool configurator is updated.\\n   * @param oldAddress The old address of the PoolConfigurator\\n   * @param newAddress The new address of the PoolConfigurator\\n   */\\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the price oracle is updated.\\n   * @param oldAddress The old address of the PriceOracle\\n   * @param newAddress The new address of the PriceOracle\\n   */\\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the ACL manager is updated.\\n   * @param oldAddress The old address of the ACLManager\\n   * @param newAddress The new address of the ACLManager\\n   */\\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the ACL admin is updated.\\n   * @param oldAddress The old address of the ACLAdmin\\n   * @param newAddress The new address of the ACLAdmin\\n   */\\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the price oracle sentinel is updated.\\n   * @param oldAddress The old address of the PriceOracleSentinel\\n   * @param newAddress The new address of the PriceOracleSentinel\\n   */\\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the pool data provider is updated.\\n   * @param oldAddress The old address of the PoolDataProvider\\n   * @param newAddress The new address of the PoolDataProvider\\n   */\\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when a new proxy is created.\\n   * @param id The identifier of the proxy\\n   * @param proxyAddress The address of the created proxy contract\\n   * @param implementationAddress The address of the implementation contract\\n   */\\n  event ProxyCreated(\\n    bytes32 indexed id,\\n    address indexed proxyAddress,\\n    address indexed implementationAddress\\n  );\\n\\n  /**\\n   * @dev Emitted when a new non-proxied contract address is registered.\\n   * @param id The identifier of the contract\\n   * @param oldAddress The address of the old contract\\n   * @param newAddress The address of the new contract\\n   */\\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\\n\\n  /**\\n   * @dev Emitted when the implementation of the proxy registered with id is updated\\n   * @param id The identifier of the contract\\n   * @param proxyAddress The address of the proxy contract\\n   * @param oldImplementationAddress The address of the old implementation contract\\n   * @param newImplementationAddress The address of the new implementation contract\\n   */\\n  event AddressSetAsProxy(\\n    bytes32 indexed id,\\n    address indexed proxyAddress,\\n    address oldImplementationAddress,\\n    address indexed newImplementationAddress\\n  );\\n\\n  /**\\n   * @notice Returns the id of the Aave market to which this contract points to.\\n   * @return The market id\\n   */\\n  function getMarketId() external view returns (string memory);\\n\\n  /**\\n   * @notice Associates an id with a specific PoolAddressesProvider.\\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\\n   * identify and validate multiple Aave markets.\\n   * @param newMarketId The market id\\n   */\\n  function setMarketId(string calldata newMarketId) external;\\n\\n  /**\\n   * @notice Returns an address by its identifier.\\n   * @dev The returned address might be an EOA or a contract, potentially proxied\\n   * @dev It returns ZERO if there is no registered address with the given id\\n   * @param id The id\\n   * @return The address of the registered for the specified id\\n   */\\n  function getAddress(bytes32 id) external view returns (address);\\n\\n  /**\\n   * @notice General function to update the implementation of a proxy registered with\\n   * certain `id`. If there is no proxy registered, it will instantiate one and\\n   * set as implementation the `newImplementationAddress`.\\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\\n   * setter function, in order to avoid unexpected consequences\\n   * @param id The id\\n   * @param newImplementationAddress The address of the new implementation\\n   */\\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\\n\\n  /**\\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\\n   * @param id The id\\n   * @param newAddress The address to set\\n   */\\n  function setAddress(bytes32 id, address newAddress) external;\\n\\n  /**\\n   * @notice Returns the address of the Pool proxy.\\n   * @return The Pool proxy address\\n   */\\n  function getPool() external view returns (address);\\n\\n  /**\\n   * @notice Updates the implementation of the Pool, or creates a proxy\\n   * setting the new `pool` implementation when the function is called for the first time.\\n   * @param newPoolImpl The new Pool implementation\\n   */\\n  function setPoolImpl(address newPoolImpl) external;\\n\\n  /**\\n   * @notice Returns the address of the PoolConfigurator proxy.\\n   * @return The PoolConfigurator proxy address\\n   */\\n  function getPoolConfigurator() external view returns (address);\\n\\n  /**\\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\\n   */\\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\\n\\n  /**\\n   * @notice Returns the address of the price oracle.\\n   * @return The address of the PriceOracle\\n   */\\n  function getPriceOracle() external view returns (address);\\n\\n  /**\\n   * @notice Updates the address of the price oracle.\\n   * @param newPriceOracle The address of the new PriceOracle\\n   */\\n  function setPriceOracle(address newPriceOracle) external;\\n\\n  /**\\n   * @notice Returns the address of the ACL manager.\\n   * @return The address of the ACLManager\\n   */\\n  function getACLManager() external view returns (address);\\n\\n  /**\\n   * @notice Updates the address of the ACL manager.\\n   * @param newAclManager The address of the new ACLManager\\n   */\\n  function setACLManager(address newAclManager) external;\\n\\n  /**\\n   * @notice Returns the address of the ACL admin.\\n   * @return The address of the ACL admin\\n   */\\n  function getACLAdmin() external view returns (address);\\n\\n  /**\\n   * @notice Updates the address of the ACL admin.\\n   * @param newAclAdmin The address of the new ACL admin\\n   */\\n  function setACLAdmin(address newAclAdmin) external;\\n\\n  /**\\n   * @notice Returns the address of the price oracle sentinel.\\n   * @return The address of the PriceOracleSentinel\\n   */\\n  function getPriceOracleSentinel() external view returns (address);\\n\\n  /**\\n   * @notice Updates the address of the price oracle sentinel.\\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\\n   */\\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\\n\\n  /**\\n   * @notice Returns the address of the data provider.\\n   * @return The address of the DataProvider\\n   */\\n  function getPoolDataProvider() external view returns (address);\\n\\n  /**\\n   * @notice Updates the address of the data provider.\\n   * @param newDataProvider The address of the new DataProvider\\n   */\\n  function setPoolDataProvider(address newDataProvider) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@aave/core-v3/contracts/interfaces/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IPriceOracle\\n * @author Aave\\n * @notice Defines the basic interface for a Price oracle.\\n */\\ninterface IPriceOracle {\\n  /**\\n   * @notice Returns the asset price in the base currency\\n   * @param asset The address of the asset\\n   * @return The price of the asset\\n   */\\n  function getAssetPrice(address asset) external view returns (uint256);\\n\\n  /**\\n   * @notice Set the price of the asset\\n   * @param asset The address of the asset\\n   * @param price The price of the asset\\n   */\\n  function setAssetPrice(address asset, uint256 price) external;\\n}\\n\"\r\n    },\r\n    \"src/contracts/facilitators/gsm/dependencies/chainlink/AutomationCompatibleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Chainlink Contracts v0.8\\npragma solidity ^0.8.0;\\n\\ninterface AutomationCompatibleInterface {\\n  /**\\n   * @notice method that is simulated by the keepers to see if any work actually\\n   * needs to be performed. This method does does not actually need to be\\n   * executable, and since it is only ever simulated it can consume lots of gas.\\n   * @dev To ensure that it is never called, you may want to add the\\n   * cannotExecute modifier from KeeperBase to your implementation of this\\n   * method.\\n   * @param checkData specified in the upkeep registration so it is always the\\n   * same for a registered upkeep. This can easily be broken down into specific\\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\\n   * same contract and easily differentiated by the contract.\\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\\n   * performUpkeep or not.\\n   * @return performData bytes that the keeper should call performUpkeep with, if\\n   * upkeep is needed. If you would like to encode data to decode later, try\\n   * `abi.encode`.\\n   */\\n  function checkUpkeep(\\n    bytes calldata checkData\\n  ) external returns (bool upkeepNeeded, bytes memory performData);\\n\\n  /**\\n   * @notice method that is actually executed by the keepers, via the registry.\\n   * The data returned by the checkUpkeep simulation will be passed into\\n   * this method to actually be executed.\\n   * @dev The input to this method should not be trusted, and the caller of the\\n   * method should not even be restricted to any single registry. Anyone should\\n   * be able call it, and the input should be validated, there is no guarantee\\n   * that the data passed in is the performData returned from checkUpkeep. This\\n   * could happen due to malicious keepers, racing keepers, or simply a state\\n   * change while the performUpkeep transaction is waiting for confirmation.\\n   * Always validate the data passed in.\\n   * @param performData is the data which was passed back from the checkData\\n   * simulation. If it is encoded, it can easily be decoded into other types by\\n   * calling `abi.decode`. This data should not be trusted, and should be\\n   * validated against the contract's current state.\\n   */\\n  function performUpkeep(bytes calldata performData) external;\\n}\\n\"\r\n    },\r\n    \"src/contracts/facilitators/gsm/interfaces/IGsm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IAccessControl} from '@openzeppelin/contracts/access/IAccessControl.sol';\\nimport {IGhoFacilitator} from '../../../gho/interfaces/IGhoFacilitator.sol';\\n\\n/**\\n * @title IGsm\\n * @author Aave\\n * @notice Defines the behaviour of a GHO Stability Module\\n */\\ninterface IGsm is IAccessControl, IGhoFacilitator {\\n  /**\\n   * @dev Emitted when a user buys an asset (selling GHO) in the GSM\\n   * @param originator The address of the buyer originating the request\\n   * @param receiver The address of the receiver of the underlying asset\\n   * @param underlyingAmount The amount of the underlying asset bought\\n   * @param ghoAmount The amount of GHO sold, inclusive of fee\\n   * @param fee The fee paid by the buyer, in GHO\\n   */\\n  event BuyAsset(\\n    address indexed originator,\\n    address indexed receiver,\\n    uint256 underlyingAmount,\\n    uint256 ghoAmount,\\n    uint256 fee\\n  );\\n\\n  /**\\n   * @dev Emitted when a user sells an asset (buying GHO) in the GSM\\n   * @param originator The address of the seller originating the request\\n   * @param receiver The address of the receiver of GHO\\n   * @param underlyingAmount The amount of the underlying asset sold\\n   * @param ghoAmount The amount of GHO bought, inclusive of fee\\n   * @param fee The fee paid by the buyer, in GHO\\n   */\\n  event SellAsset(\\n    address indexed originator,\\n    address indexed receiver,\\n    uint256 underlyingAmount,\\n    uint256 ghoAmount,\\n    uint256 fee\\n  );\\n\\n  /**\\n   * @dev Emitted when the Swap Freezer freezes buys/sells\\n   * @param freezer The address of the Swap Freezer\\n   * @param enabled True if swap functions are frozen, False otherwise\\n   */\\n  event SwapFreeze(address indexed freezer, bool enabled);\\n\\n  /**\\n   * @dev Emitted when a Liquidator seizes GSM funds\\n   * @param seizer The address originating the seizure request\\n   * @param recipient The address of the recipient of seized funds\\n   * @param underlyingAmount The amount of the underlying asset seized\\n   * @param ghoOutstanding The amount of remaining GHO that the GSM had minted\\n   */\\n  event Seized(\\n    address indexed seizer,\\n    address indexed recipient,\\n    uint256 underlyingAmount,\\n    uint256 ghoOutstanding\\n  );\\n\\n  /**\\n   * @dev Emitted when burning GHO after a seizure of GSM funds\\n   * @param burner The address of the burner\\n   * @param amount The amount of GHO burned\\n   * @param ghoOutstanding The amount of remaining GHO that the GSM had minted\\n   */\\n  event BurnAfterSeize(address indexed burner, uint256 amount, uint256 ghoOutstanding);\\n\\n  /**\\n   * @dev Emitted when the Fee Strategy is updated\\n   * @param oldFeeStrategy The address of the old Fee Strategy\\n   * @param newFeeStrategy The address of the new Fee Strategy\\n   */\\n  event FeeStrategyUpdated(address indexed oldFeeStrategy, address indexed newFeeStrategy);\\n\\n  /**\\n   * @dev Emitted when the GSM underlying asset Exposure Cap is updated\\n   * @param oldExposureCap The amount of the old Exposure Cap\\n   * @param newExposureCap The amount of the new Exposure Cap\\n   */\\n  event ExposureCapUpdated(uint256 oldExposureCap, uint256 newExposureCap);\\n\\n  /**\\n   * @dev Emitted when tokens are rescued from the GSM\\n   * @param tokenRescued The address of the rescued token\\n   * @param recipient The address that received the rescued tokens\\n   * @param amountRescued The amount of token rescued\\n   */\\n  event TokensRescued(\\n    address indexed tokenRescued,\\n    address indexed recipient,\\n    uint256 amountRescued\\n  );\\n\\n  /**\\n   * @notice Buys the GSM underlying asset in exchange for selling GHO\\n   * @dev Use `getAssetAmountForBuyAsset` function to calculate the amount based on the GHO amount to sell\\n   * @param minAmount The minimum amount of the underlying asset to buy\\n   * @param receiver Recipient address of the underlying asset being purchased\\n   * @return The amount of underlying asset bought\\n   * @return The amount of GHO sold by the user\\n   */\\n  function buyAsset(uint256 minAmount, address receiver) external returns (uint256, uint256);\\n\\n  /**\\n   * @notice Buys the GSM underlying asset in exchange for selling GHO, using an EIP-712 signature\\n   * @dev Use `getAssetAmountForBuyAsset` function to calculate the amount based on the GHO amount to sell\\n   * @param originator The signer of the request\\n   * @param minAmount The minimum amount of the underlying asset to buy\\n   * @param receiver Recipient address of the underlying asset being purchased\\n   * @param deadline Signature expiration deadline\\n   * @param signature Signature data\\n   * @return The amount of underlying asset bought\\n   * @return The amount of GHO sold by the user\\n   */\\n  function buyAssetWithSig(\\n    address originator,\\n    uint256 minAmount,\\n    address receiver,\\n    uint256 deadline,\\n    bytes calldata signature\\n  ) external returns (uint256, uint256);\\n\\n  /**\\n   * @notice Sells the GSM underlying asset in exchange for buying GHO\\n   * @dev Use `getAssetAmountForSellAsset` function to calculate the amount based on the GHO amount to buy\\n   * @param maxAmount The maximum amount of the underlying asset to sell\\n   * @param receiver Recipient address of the GHO being purchased\\n   * @return The amount of underlying asset sold\\n   * @return The amount of GHO bought by the user\\n   */\\n  function sellAsset(uint256 maxAmount, address receiver) external returns (uint256, uint256);\\n\\n  /**\\n   * @notice Sells the GSM underlying asset in exchange for buying GHO, using an EIP-712 signature\\n   * @dev Use `getAssetAmountForSellAsset` function to calculate the amount based on the GHO amount to buy\\n   * @param originator The signer of the request\\n   * @param maxAmount The maximum amount of the underlying asset to sell\\n   * @param receiver Recipient address of the GHO being purchased\\n   * @param deadline Signature expiration deadline\\n   * @param signature Signature data\\n   * @return The amount of underlying asset sold\\n   * @return The amount of GHO bought by the user\\n   */\\n  function sellAssetWithSig(\\n    address originator,\\n    uint256 maxAmount,\\n    address receiver,\\n    uint256 deadline,\\n    bytes calldata signature\\n  ) external returns (uint256, uint256);\\n\\n  /**\\n   * @notice Rescue and transfer tokens locked in this contract\\n   * @param token The address of the token\\n   * @param to The address of the recipient\\n   * @param amount The amount of token to transfer\\n   */\\n  function rescueTokens(address token, address to, uint256 amount) external;\\n\\n  /**\\n   * @notice Enable or disable the swap freeze\\n   * @param enable True to freeze swap functions, false otherwise\\n   */\\n  function setSwapFreeze(bool enable) external;\\n\\n  /**\\n   * @notice Seizes all of the underlying asset from the GSM, sending to the Treasury\\n   * @dev Seizing is a last resort mechanism to provide the Treasury with the entire amount of underlying asset\\n   * so it can be used to backstop any potential event impacting the functionality of the Gsm.\\n   * @dev Seizing disables the swap feature\\n   * @return The amount of underlying asset seized and transferred to Treasury\\n   */\\n  function seize() external returns (uint256);\\n\\n  /**\\n   * @notice Burns an amount of GHO after seizure reducing the facilitator bucket level effectively\\n   * @dev Passing an amount higher than the facilitator bucket level will result in burning all minted GHO\\n   * @dev Only callable if the GSM has assets seized, helpful to wind down the facilitator\\n   * @param amount The amount of GHO to burn\\n   * @return The amount of GHO burned\\n   */\\n  function burnAfterSeize(uint256 amount) external returns (uint256);\\n\\n  /**\\n   * @notice Updates the address of the Fee Strategy\\n   * @param feeStrategy The address of the new FeeStrategy\\n   */\\n  function updateFeeStrategy(address feeStrategy) external;\\n\\n  /**\\n   * @notice Updates the exposure cap of the underlying asset\\n   * @param exposureCap The new value for the exposure cap (in underlying asset terms)\\n   */\\n  function updateExposureCap(uint128 exposureCap) external;\\n\\n  /**\\n   * @notice Returns the EIP712 domain separator\\n   * @return The EIP712 domain separator\\n   */\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n  /**\\n   * @notice Returns the total amount of GHO, gross amount and fee result of buying assets\\n   * @param minAssetAmount The minimum amount of underlying asset to buy\\n   * @return The exact amount of underlying asset to be bought\\n   * @return The total amount of GHO the user sells (gross amount in GHO plus fee)\\n   * @return The gross amount of GHO\\n   * @return The fee amount in GHO, applied on top of gross amount of GHO\\n   */\\n  function getGhoAmountForBuyAsset(\\n    uint256 minAssetAmount\\n  ) external view returns (uint256, uint256, uint256, uint256);\\n\\n  /**\\n   * @notice Returns the total amount of GHO, gross amount and fee result of selling assets\\n   * @param maxAssetAmount The maximum amount of underlying asset to sell\\n   * @return The exact amount of underlying asset to sell\\n   * @return The total amount of GHO the user buys (gross amount in GHO minus fee)\\n   * @return The gross amount of GHO\\n   * @return The fee amount in GHO, applied to the gross amount of GHO\\n   */\\n  function getGhoAmountForSellAsset(\\n    uint256 maxAssetAmount\\n  ) external view returns (uint256, uint256, uint256, uint256);\\n\\n  /**\\n   * @notice Returns the amount of underlying asset, gross amount of GHO and fee result of buying assets\\n   * @param maxGhoAmount The maximum amount of GHO the user provides for buying underlying asset\\n   * @return The amount of underlying asset the user buys\\n   * @return The exact amount of GHO the user provides\\n   * @return The gross amount of GHO corresponding to the given total amount of GHO\\n   * @return The fee amount in GHO, charged for buying assets\\n   */\\n  function getAssetAmountForBuyAsset(\\n    uint256 maxGhoAmount\\n  ) external view returns (uint256, uint256, uint256, uint256);\\n\\n  /**\\n   * @notice Returns the amount of underlying asset, gross amount of GHO and fee result of selling assets\\n   * @param minGhoAmount The minimum amount of GHO the user must receive for selling underlying asset\\n   * @return The amount of underlying asset the user sells\\n   * @return The exact amount of GHO the user receives in exchange\\n   * @return The gross amount of GHO corresponding to the given total amount of GHO\\n   * @return The fee amount in GHO, charged for selling assets\\n   */\\n  function getAssetAmountForSellAsset(\\n    uint256 minGhoAmount\\n  ) external view returns (uint256, uint256, uint256, uint256);\\n\\n  /**\\n   * @notice Returns the remaining GSM exposure capacity\\n   * @return The amount of underlying asset that can be sold to the GSM\\n   */\\n  function getAvailableUnderlyingExposure() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the exposure limit to the underlying asset\\n   * @return The maximum amount of underlying asset that can be sold to the GSM\\n   */\\n  function getExposureCap() external view returns (uint128);\\n\\n  /**\\n   * @notice Returns the actual underlying asset balance immediately available in the GSM\\n   * @return The amount of underlying asset that can be bought from the GSM\\n   */\\n  function getAvailableLiquidity() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the Fee Strategy for the GSM\\n   * @dev It returns 0x0 in case of no fee strategy\\n   * @return The address of the FeeStrategy\\n   */\\n  function getFeeStrategy() external view returns (address);\\n\\n  /**\\n   * @notice Returns the amount of current accrued fees\\n   * @dev It does not factor in potential fees that can be accrued upon distribution of fees\\n   * @return The amount of accrued fees\\n   */\\n  function getAccruedFees() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the freeze status of the GSM\\n   * @return True if frozen, false if not\\n   */\\n  function getIsFrozen() external view returns (bool);\\n\\n  /**\\n   * @notice Returns the current seizure status of the GSM\\n   * @return True if the GSM has been seized, false if not\\n   */\\n  function getIsSeized() external view returns (bool);\\n\\n  /**\\n   * @notice Returns whether or not swaps via buyAsset/sellAsset are currently possible\\n   * @return True if the GSM has swapping enabled, false otherwise\\n   */\\n  function canSwap() external view returns (bool);\\n\\n  /**\\n   * @notice Returns the GSM revision number\\n   * @return The revision number\\n   */\\n  function GSM_REVISION() external pure returns (uint256);\\n\\n  /**\\n   * @notice Returns the address of the GHO token\\n   * @return The address of GHO token contract\\n   */\\n  function GHO_TOKEN() external view returns (address);\\n\\n  /**\\n   * @notice Returns the underlying asset of the GSM\\n   * @return The address of the underlying asset\\n   */\\n  function UNDERLYING_ASSET() external view returns (address);\\n\\n  /**\\n   * @notice Returns the price strategy of the GSM\\n   * @return The address of the price strategy\\n   */\\n  function PRICE_STRATEGY() external view returns (address);\\n\\n  /**\\n   * @notice Returns the current nonce (for EIP-712 signature methods) of an address\\n   * @param user The address of the user\\n   * @return The current nonce of the user\\n   */\\n  function nonces(address user) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the identifier of the Configurator Role\\n   * @return The bytes32 id hash of the Configurator role\\n   */\\n  function CONFIGURATOR_ROLE() external pure returns (bytes32);\\n\\n  /**\\n   * @notice Returns the identifier of the Token Rescuer Role\\n   * @return The bytes32 id hash of the TokenRescuer role\\n   */\\n  function TOKEN_RESCUER_ROLE() external pure returns (bytes32);\\n\\n  /**\\n   * @notice Returns the identifier of the Swap Freezer Role\\n   * @return The bytes32 id hash of the SwapFreezer role\\n   */\\n  function SWAP_FREEZER_ROLE() external pure returns (bytes32);\\n\\n  /**\\n   * @notice Returns the identifier of the Liquidator Role\\n   * @return The bytes32 id hash of the Liquidator role\\n   */\\n  function LIQUIDATOR_ROLE() external pure returns (bytes32);\\n\\n  /**\\n   * @notice Returns the EIP-712 signature typehash for buyAssetWithSig\\n   * @return The bytes32 signature typehash for buyAssetWithSig\\n   */\\n  function BUY_ASSET_WITH_SIG_TYPEHASH() external pure returns (bytes32);\\n\\n  /**\\n   * @notice Returns the EIP-712 signature typehash for sellAssetWithSig\\n   * @return The bytes32 signature typehash for sellAssetWithSig\\n   */\\n  function SELL_ASSET_WITH_SIG_TYPEHASH() external pure returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"src/contracts/gho/interfaces/IGhoFacilitator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IGhoFacilitator\\n * @author Aave\\n * @notice Defines the behavior of a Gho Facilitator\\n */\\ninterface IGhoFacilitator {\\n  /**\\n   * @dev Emitted when fees are distributed to the GhoTreasury\\n   * @param ghoTreasury The address of the ghoTreasury\\n   * @param asset The address of the asset transferred to the ghoTreasury\\n   * @param amount The amount of the asset transferred to the ghoTreasury\\n   */\\n  event FeesDistributedToTreasury(\\n    address indexed ghoTreasury,\\n    address indexed asset,\\n    uint256 amount\\n  );\\n\\n  /**\\n   * @dev Emitted when Gho Treasury address is updated\\n   * @param oldGhoTreasury The address of the old GhoTreasury contract\\n   * @param newGhoTreasury The address of the new GhoTreasury contract\\n   */\\n  event GhoTreasuryUpdated(address indexed oldGhoTreasury, address indexed newGhoTreasury);\\n\\n  /**\\n   * @notice Distribute fees to the GhoTreasury\\n   */\\n  function distributeFeesToTreasury() external;\\n\\n  /**\\n   * @notice Updates the address of the Gho Treasury\\n   * @dev WARNING: The GhoTreasury is where revenue fees are sent to. Update carefully\\n   * @param newGhoTreasury The address of the GhoTreasury\\n   */\\n  function updateGhoTreasury(address newGhoTreasury) external;\\n\\n  /**\\n   * @notice Returns the address of the Gho Treasury\\n   * @return The address of the GhoTreasury contract\\n   */\\n  function getGhoTreasury() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@aave/=node_modules/@aave/\",\r\n      \"@aave/core-v3/=node_modules/@aave/core-v3/\",\r\n      \"@aave/periphery-v3/=node_modules/@aave/periphery-v3/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"aave-stk-v1-5/=lib/aave-stk-v1-5/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"eth-gas-reporter/=node_modules/eth-gas-reporter/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hardhat-deploy/=node_modules/hardhat-deploy/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"aave-address-book/=lib/aave-address-book/src/\",\r\n      \"aave-helpers/=lib/aave-stk-v1-5/lib/aave-helpers/\",\r\n      \"aave-v3-core/=lib/aave-address-book/lib/aave-v3-core/\",\r\n      \"aave-v3-periphery/=lib/aave-address-book/lib/aave-v3-periphery/\",\r\n      \"erc4626-tests/=lib/aave-stk-v1-5/lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"openzeppelin-contracts/=lib/aave-stk-v1-5/lib/openzeppelin-contracts/\",\r\n      \"solidity-utils/=lib/solidity-utils/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IGsm\",\"name\":\"gsm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlyingAsset\",\"type\":\"address\"},{\"internalType\":\"contract IPoolAddressesProvider\",\"name\":\"addressProvider\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"freezeLowerBound\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"freezeUpperBound\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"unfreezeLowerBound\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"unfreezeUpperBound\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"allowUnfreeze\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ADDRESS_PROVIDER\",\"outputs\":[{\"internalType\":\"contract IPoolAddressesProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GSM\",\"outputs\":[{\"internalType\":\"contract IGsm\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNDERLYING_ASSET\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCanUnfreeze\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFreezeBound\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnfreezeBound\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OracleSwapFreezer", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000d8effc11df3f229aa1ea0509bc9dfa632a13578000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000002f39d218133afab8f2b819b1066c7e434ad94e9e0000000000000000000000000000000000000000000000000000000005e69ec000000000000000000000000000000000000000000000000000000000060523400000000000000000000000000000000000000000000000000000000005ee3fe00000000000000000000000000000000000000000000000000000000005fd82200000000000000000000000000000000000000000000000000000000000000001", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}