// SPDX-License-Identifier: AGPL-3.0

pragma solidity 0.8.15;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/proxy/utils/Initializable.sol";
import "@manifoldxyz/royalty-registry-solidity/contracts/overrides/IRoyaltyOverride.sol";
import "@manifoldxyz/royalty-registry-solidity/contracts/overrides/RoyaltyOverrideCore.sol";
import "@openzeppelin/contracts/utils/introspection/ERC165Storage.sol";

import "../../../misc/rarible/IRoyalties.sol";
import "../../../misc/rarible/LibPart.sol";
import "../../../misc/rarible/LibRoyaltiesV2.sol";

interface IERC721RoyaltyExtension {
    function setTokenRoyalties(
        IEIP2981RoyaltyOverride.TokenRoyaltyConfig[] calldata royaltyConfigs
    ) external;

    function setDefaultRoyalty(
        IEIP2981RoyaltyOverride.TokenRoyalty calldata royalty
    ) external;

    function getRaribleV2Royalties(uint256 id)
        external
        view
        returns (LibPart.Part[] memory result);
}

/**
 * @dev Extension to signal configured royalty to famous marketplaces as well as ERC2981.
 *
 * This extension currently supports Standard ERC2981, Rarible.
 * Note that OpenSea is supported via Flair metadata feature.
 */
abstract contract ERC721RoyaltyExtension is
    IERC721RoyaltyExtension,
    IRoyalties,
    Initializable,
    Ownable,
    ERC165Storage,
    EIP2981RoyaltyOverrideCore
{
    function __ERC721RoyaltyExtension_init(
        address defaultRoyaltyReceiver,
        uint16 defaultRoyaltyBps
    ) internal onlyInitializing {
        __ERC721RoyaltyExtension_init_unchained(
            defaultRoyaltyReceiver,
            defaultRoyaltyBps
        );
    }

    function __ERC721RoyaltyExtension_init_unchained(
        address defaultRoyaltyReceiver,
        uint16 defaultRoyaltyBps
    ) internal onlyInitializing {
        _registerInterface(type(IERC721RoyaltyExtension).interfaceId);
        _registerInterface(type(IEIP2981).interfaceId);
        _registerInterface(type(IEIP2981RoyaltyOverride).interfaceId);
        _registerInterface(LibRoyaltiesV2._INTERFACE_ID_ROYALTIES);

        TokenRoyalty memory royalty = TokenRoyalty(
            defaultRoyaltyReceiver,
            defaultRoyaltyBps
        );

        _setDefaultRoyalty(royalty);
    }

    function setTokenRoyalties(TokenRoyaltyConfig[] calldata royaltyConfigs)
        external
        override(IEIP2981RoyaltyOverride, IERC721RoyaltyExtension)
        onlyOwner
    {
        _setTokenRoyalties(royaltyConfigs);
    }

    function setDefaultRoyalty(TokenRoyalty calldata royalty)
        external
        override(IEIP2981RoyaltyOverride, IERC721RoyaltyExtension)
        onlyOwner
    {
        _setDefaultRoyalty(royalty);
    }

    function getRaribleV2Royalties(uint256 id)
        external
        view
        override(IRoyalties, IERC721RoyaltyExtension)
        returns (LibPart.Part[] memory result)
    {
        result = new LibPart.Part[](1);

        result[0].account = payable(defaultRoyalty.recipient);
        result[0].value = defaultRoyalty.bps;

        id;
        // avoid unused param warning
    }

    /* PUBLIC */

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC165Storage, EIP2981RoyaltyOverrideCore)
        returns (bool)
    {
        return ERC165Storage.supportsInterface(interfaceId);
    }
}