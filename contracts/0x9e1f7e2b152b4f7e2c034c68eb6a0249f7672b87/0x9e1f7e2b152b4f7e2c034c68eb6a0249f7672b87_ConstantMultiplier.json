{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/staking/interfaces/IMultiplier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\ninterface IMultiplier {\\n    /**\\n     * Applies a multiplier on the _amount, based on the _pool and _beneficiary.\\n     * The multiplier is not necessarily a constant number, it can be a more complex factor.\\n     */\\n    function applyMultiplier(\\n        uint256 _amount,\\n        address _beneficiary,\\n        address _pool\\n    ) external view returns (uint256);\\n\\n    function getDurationGroup(uint256 _duration) external view returns (uint8);\\n\\n    function getDurationMultiplier(uint256 _duration) external view returns (uint256);\\n\\n    function getMultiplier(address _beneficiary, address _pool) external view returns (uint256);\\n\\n    function getAmountMultiplier(uint256 _amount) external view returns (uint256);\\n\\n    function getAmountGroup(uint256 _amount) external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/staking/interfaces/IPenaltyFee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\ninterface IPenaltyFee {\\n    /**\\n     * Calculates the penalty fee for the given _amount for a specific _beneficiary.\\n     */\\n    function calculate(\\n        address _beneficiary,\\n        uint256 _amount,\\n        address _pool\\n    ) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/staking/interfaces/IStakingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nimport { IMultiplier } from \\\"../interfaces/IMultiplier.sol\\\";\\nimport { IPenaltyFee } from \\\"../interfaces/IPenaltyFee.sol\\\";\\n\\ninterface IStakingPool {\\n    function balanceOf(address _user) external view returns (uint256);\\n\\n    function rewardsMultiplier() external view returns (IMultiplier);\\n\\n    function penaltyFeeCalculator() external view returns (IPenaltyFee);\\n\\n    function minimumStakeTimestamp(address _beneficiary) external view returns (uint256);\\n\\n    function userStakeDuration(address _beneficiary) external view returns (uint256);\\n\\n    event RewardAdded(uint256 reward);\\n    event Staked(address indexed user, uint256 amount);\\n    event Unstaked(address indexed user, uint256 amount);\\n    event RewardPaid(address indexed user, uint256 reward);\\n    event RewardsDurationUpdated(uint256 rewardsDuration);\\n}\\n\"\r\n    },\r\n    \"contracts/staking/multipliers/ConstantMultiplier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nimport { IMultiplier } from \\\"../interfaces/IMultiplier.sol\\\";\\nimport { IStakingPool } from \\\"../interfaces/IStakingPool.sol\\\";\\n\\ncontract ConstantMultiplier is IMultiplier {\\n    struct MultiplierThreshold {\\n        uint256 threshold;\\n        uint256 multiplier;\\n    }\\n\\n    // Multiplier Thresholds\\n    MultiplierThreshold[] public amountThresholds;\\n    MultiplierThreshold[] public durationThresholds;\\n\\n    uint256 public constant MULTIPLIER_BASIS = 1e4;\\n\\n    /**\\n     * @notice Both arrays should be in ascending order.\\n     * @param _amountThresholds The amount thresholds\\n     * @param _durationThresholds The duration thresholds\\n     */\\n    constructor(MultiplierThreshold[] memory _amountThresholds, MultiplierThreshold[] memory _durationThresholds) {\\n        for (uint256 i = 0; i < _amountThresholds.length; i++) {\\n            MultiplierThreshold memory threshold = _amountThresholds[i];\\n            require(threshold.threshold > 0, \\\"ConstantMultiplier::setMultiplierThresholds: threshold = 0\\\");\\n            require(threshold.multiplier > 0, \\\"ConstantMultiplier::setMultiplierThresholds: multiplier = 0\\\");\\n            amountThresholds.push(threshold);\\n        }\\n\\n        for (uint256 i = 0; i < _durationThresholds.length; i++) {\\n            MultiplierThreshold memory threshold = _durationThresholds[i];\\n            require(threshold.threshold > 0, \\\"ConstantMultiplier::setMultiplierThresholds: threshold = 0\\\");\\n            require(threshold.multiplier > 0, \\\"ConstantMultiplier::setMultiplierThresholds: multiplier = 0\\\");\\n            durationThresholds.push(threshold);\\n        }\\n    }\\n\\n    function applyMultiplier(\\n        uint256 _amount,\\n        address _beneficiary,\\n        address _pool\\n    ) external view override returns (uint256) {\\n        uint256 multiplier = getMultiplier(_beneficiary, _pool);\\n        return (_amount * multiplier) / MULTIPLIER_BASIS;\\n    }\\n\\n    function getDurationGroup(uint256 _duration) public view override returns (uint8) {\\n        for (uint256 i = 0; i < durationThresholds.length; i++) {\\n            // The duration thresholds are sorted in ascending order\\n            MultiplierThreshold memory threshold = durationThresholds[i];\\n            if (_duration <= threshold.threshold) {\\n                return uint8(i);\\n            }\\n        }\\n        return uint8(durationThresholds.length - 1);\\n    }\\n\\n    function getDurationMultiplier(uint256 _duration) public view override returns (uint256) {\\n        uint8 group = getDurationGroup(_duration);\\n        return durationThresholds[group].multiplier;\\n    }\\n\\n    function getAmountGroup(uint256 _amount) public view override returns (uint8) {\\n        for (uint256 i = 0; i < amountThresholds.length; i++) {\\n            // The duration thresholds are sorted in ascending order\\n            MultiplierThreshold memory threshold = amountThresholds[i];\\n            if (_amount <= threshold.threshold) {\\n                return uint8(i);\\n            }\\n        }\\n        return uint8(amountThresholds.length - 1);\\n    }\\n\\n    function getAmountMultiplier(uint256 _amount) public view override returns (uint256) {\\n        uint8 group = getAmountGroup(_amount);\\n        return amountThresholds[group].multiplier;\\n    }\\n\\n    function getAmountThresholds() external view returns (MultiplierThreshold[] memory) {\\n        return amountThresholds;\\n    }\\n\\n    function getDurationThresholds() external view returns (MultiplierThreshold[] memory) {\\n        return durationThresholds;\\n    }\\n\\n    function getMultiplier(address _beneficiary, address _pool) public view override returns (uint256) {\\n        uint256 stakedAmount = IStakingPool(_pool).balanceOf(_beneficiary);\\n        uint256 stakedDuration = IStakingPool(_pool).userStakeDuration(_beneficiary);\\n        return getMultiplierForAmountAndDuration(stakedAmount, stakedDuration);\\n    }\\n\\n    function getMultiplierForAmountAndDuration(uint256 _amount, uint256 _duration) public view returns (uint256) {\\n        return (getAmountMultiplier(_amount) * getDurationMultiplier(_duration)) / MULTIPLIER_BASIS;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"}],\"internalType\":\"struct ConstantMultiplier.MultiplierThreshold[]\",\"name\":\"_amountThresholds\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"}],\"internalType\":\"struct ConstantMultiplier.MultiplierThreshold[]\",\"name\":\"_durationThresholds\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"MULTIPLIER_BASIS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"amountThresholds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"applyMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"durationThresholds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getAmountGroup\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getAmountMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAmountThresholds\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"}],\"internalType\":\"struct ConstantMultiplier.MultiplierThreshold[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"getDurationGroup\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"getDurationMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDurationThresholds\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"}],\"internalType\":\"struct ConstantMultiplier.MultiplierThreshold[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"getMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"getMultiplierForAmountAndDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ConstantMultiplier", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000002e90edd0000000000000000000000000000000000000000000000000000000000000002710000000000000000000000000000000000000000000000000000000746a5288000000000000000000000000000000000000000000000000000000000000004e20000000000000000000000000000000000000000000000000000000e8d4a510000000000000000000000000000000000000000000000000000000000000007530000000000000000000000000000000000000000000000000000009184e72a0000000000000000000000000000000000000000000000000000000000000009c4000000000000000000000000000000000000000000000000000005af3107a4000000000000000000000000000000000000000000000000000000000000000c3500000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000070800000000000000000000000000000000000000000000000000000000000030d400000000000000000000000000000000000000000000000000000000000038400000000000000000000000000000000000000000000000000000000000003a98000000000000000000000000000000000000000000000000000000000002a3000000000000000000000000000000000000000000000000000000000000004e200000000000000000000000000000000000000000000000000000000000093a800000000000000000000000000000000000000000000000000000000000009c40", "EVMVersion": "istanbul", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}