{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"ConvexDepositFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"Clones.sol\\\";\\nimport \\\"PrismaOwnable.sol\\\";\\n\\ninterface IConvexDepositToken {\\n    function initialize(uint256 pid) external;\\n\\n    function lpToken() external view returns (address);\\n\\n    function depositPid() external view returns (uint256);\\n}\\n\\n/**\\n    @notice Prisma Convex Factory\\n    @title Deploys clones of `ConvexDepositToken` as directed by the Prisma DAO\\n */\\ncontract ConvexFactory is PrismaOwnable {\\n    using Clones for address;\\n\\n    address public depositTokenImpl;\\n\\n    mapping(uint256 pid => address depositToken) public getDepositToken;\\n\\n    event NewDeployment(address depositToken, address lpToken, uint256 convexPid);\\n    event ImplementationSet(address depositTokenImpl);\\n\\n    constructor(\\n        address _prismaCore,\\n        address _depositTokenImpl,\\n        address[] memory _existingDeployments\\n    ) PrismaOwnable(_prismaCore) {\\n        depositTokenImpl = _depositTokenImpl;\\n        emit ImplementationSet(_depositTokenImpl);\\n\\n        for (uint i = 0; i < _existingDeployments.length; i++) {\\n            address depositToken = _existingDeployments[i];\\n            address lpToken = IConvexDepositToken(depositToken).lpToken();\\n            uint256 pid = IConvexDepositToken(depositToken).depositPid();\\n            getDepositToken[pid] = depositToken;\\n            emit NewDeployment(depositToken, lpToken, pid);\\n        }\\n    }\\n\\n    /**\\n        @dev After calling this function, the owner should also call `Vault.registerReceiver`\\n             to enable PRISMA emissions on the newly deployed `ConvexDepositToken`\\n     */\\n    function deployNewInstance(uint256 pid) external onlyOwner {\\n        // cloning reverts if duplicating the same pid with the same implementation\\n        // it is intentionally allowed to redeploy using the same pid with a new implementation\\n        address depositToken = depositTokenImpl.cloneDeterministic(bytes32(pid));\\n\\n        IConvexDepositToken(depositToken).initialize(pid);\\n        getDepositToken[pid] = depositToken;\\n\\n        emit NewDeployment(depositToken, IConvexDepositToken(depositToken).lpToken(), pid);\\n    }\\n\\n    function getDeterministicAddress(uint256 pid) external view returns (address) {\\n        return Clones.predictDeterministicAddress(depositTokenImpl, bytes32(pid));\\n    }\\n\\n    function setImplementation(address impl) external onlyOwner {\\n        depositTokenImpl = impl;\\n        emit ImplementationSet(impl);\\n    }\\n}\\n\"\r\n    },\r\n    \"Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"PrismaOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"IPrismaCore.sol\\\";\\n\\n/**\\n    @title Prisma Ownable\\n    @notice Contracts inheriting `PrismaOwnable` have the same owner as `PrismaCore`.\\n            The ownership cannot be independently modified or renounced.\\n */\\ncontract PrismaOwnable {\\n    IPrismaCore public immutable PRISMA_CORE;\\n\\n    constructor(address _prismaCore) {\\n        PRISMA_CORE = IPrismaCore(_prismaCore);\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == PRISMA_CORE.owner(), \\\"Only owner\\\");\\n        _;\\n    }\\n\\n    function owner() public view returns (address) {\\n        return PRISMA_CORE.owner();\\n    }\\n\\n    function guardian() public view returns (address) {\\n        return PRISMA_CORE.guardian();\\n    }\\n}\\n\"\r\n    },\r\n    \"IPrismaCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IPrismaCore {\\n    event FeeReceiverSet(address feeReceiver);\\n    event GuardianSet(address guardian);\\n    event NewOwnerAccepted(address oldOwner, address owner);\\n    event NewOwnerCommitted(address owner, address pendingOwner, uint256 deadline);\\n    event NewOwnerRevoked(address owner, address revokedOwner);\\n    event Paused();\\n    event PriceFeedSet(address priceFeed);\\n    event Unpaused();\\n\\n    function acceptTransferOwnership() external;\\n\\n    function commitTransferOwnership(address newOwner) external;\\n\\n    function revokeTransferOwnership() external;\\n\\n    function setFeeReceiver(address _feeReceiver) external;\\n\\n    function setGuardian(address _guardian) external;\\n\\n    function setPaused(bool _paused) external;\\n\\n    function setPriceFeed(address _priceFeed) external;\\n\\n    function OWNERSHIP_TRANSFER_DELAY() external view returns (uint256);\\n\\n    function feeReceiver() external view returns (address);\\n\\n    function guardian() external view returns (address);\\n\\n    function owner() external view returns (address);\\n\\n    function ownershipTransferDeadline() external view returns (uint256);\\n\\n    function paused() external view returns (bool);\\n\\n    function pendingOwner() external view returns (address);\\n\\n    function priceFeed() external view returns (address);\\n\\n    function startTime() external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"ConvexDepositFactory.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_prismaCore\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_depositTokenImpl\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_existingDeployments\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositTokenImpl\",\"type\":\"address\"}],\"name\":\"ImplementationSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"convexPid\",\"type\":\"uint256\"}],\"name\":\"NewDeployment\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PRISMA_CORE\",\"outputs\":[{\"internalType\":\"contract IPrismaCore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"deployNewInstance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositTokenImpl\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"getDepositToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"depositToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"getDeterministicAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"}],\"name\":\"setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ConvexFactory", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005d17ea085f2ff5da3e6979d5d26f1dbab664ccf8000000000000000000000000000ca04b3225137b9110e77e12f1b484cc227de9000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000ae09f649e9da1b6aea0c10527ac4e8a88a37480000000000000000000000000f6aa46869220ae703924d5331d88a21dcef3b19d0000000000000000000000003d56e0ea536a78976503618d663921c97a3cba3c", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}