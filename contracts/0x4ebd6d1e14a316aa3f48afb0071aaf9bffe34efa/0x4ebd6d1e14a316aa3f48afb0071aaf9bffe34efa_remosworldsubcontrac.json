{"SourceCode": "{\"contract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.14;\\n\\nimport \\\"./interface.sol\\\";\\n\\ncontract ERC721A is IERC721A {\\n    // Mask of an entry in packed address data.\\n    uint256 private constant BITMASK_ADDRESS_DATA_ENTRY = (1 \\u003c\\u003c 64) - 1;\\n\\n    // The bit position of `numberMinted` in packed address data.\\n    uint256 private constant BITPOS_NUMBER_MINTED = 64;\\n\\n    // The bit position of `numberBurned` in packed address data.\\n    uint256 private constant BITPOS_NUMBER_BURNED = 128;\\n\\n    // The bit position of `aux` in packed address data.\\n    uint256 private constant BITPOS_AUX = 192;\\n\\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\\n    uint256 private constant BITMASK_AUX_COMPLEMENT = (1 \\u003c\\u003c 192) - 1;\\n\\n    // The bit position of `startTimestamp` in packed ownership.\\n    uint256 private constant BITPOS_START_TIMESTAMP = 160;\\n\\n    // The bit mask of the `burned` bit in packed ownership.\\n    uint256 private constant BITMASK_BURNED = 1 \\u003c\\u003c 224;\\n    \\n    // The bit position of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant BITPOS_NEXT_INITIALIZED = 225;\\n\\n    // The bit mask of the `nextInitialized` bit in packed ownership.\\n    uint256 private constant BITMASK_NEXT_INITIALIZED = 1 \\u003c\\u003c 225;\\n\\n    // The tokenId of the next token to be minted.\\n    uint256 private _currentIndex;\\n\\n    // The number of tokens burned.\\n    uint256 private _burnCounter;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to ownership details\\n    // An empty struct value does not necessarily mean the token is unowned.\\n    // See `_packedOwnershipOf` implementation for details.\\n    //\\n    // Bits Layout:\\n    // - [0..159]   `addr`\\n    // - [160..223] `startTimestamp`\\n    // - [224]      `burned`\\n    // - [225]      `nextInitialized`\\n    mapping(uint256 =\\u003e uint256) private _packedOwnerships;\\n\\n    // Mapping owner address to address data.\\n    //\\n    // Bits Layout:\\n    // - [0..63]    `balance`\\n    // - [64..127]  `numberMinted`\\n    // - [128..191] `numberBurned`\\n    // - [192..255] `aux`\\n    mapping(address =\\u003e uint256) private _packedAddressData;\\n\\n    // Mapping from token ID to approved address.\\n    mapping(uint256 =\\u003e address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address =\\u003e mapping(address =\\u003e bool)) private _operatorApprovals;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _currentIndex = _startTokenId();}\\n\\n    //Returns the starting token ID\\n    function _startTokenId() internal view virtual returns (uint256) {\\n        return 0;}\\n\\n    //Returns the next token ID to be minted\\n    function _nextTokenId() internal view returns (uint256) {\\n        return _currentIndex;}\\n\\n    //Returns the total number of tokens in existence\\n    function totalSupply() public view override returns (uint256) {\\n        // Counter underflow is impossible as _burnCounter cannot be incremented\\n        // more than `_currentIndex - _startTokenId()` times.\\n        unchecked {return _currentIndex - _burnCounter - _startTokenId();}}\\n\\n    //Returns the total amount of tokens minted in the contract\\n    function _totalMinted() internal view returns (uint256) {\\n        // Counter underflow is impossible as _currentIndex does not decrement,\\n        // and it is initialized to `_startTokenId()`\\n        unchecked {\\n            return _currentIndex - _startTokenId();}}\\n\\n    //Returns the total number of tokens burned\\n    function _totalBurned() internal view returns (uint256) {\\n        return _burnCounter;}\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        // The interface IDs are constants representing the first 4 bytes of the XOR of\\n        // all function selectors in the interface. See: https://eips.ethereum.org/EIPS/eip-165\\n        // e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`\\n        return\\n            interfaceId == 0x01ffc9a7 || interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f;}\\n\\n    function balanceOf(address owner) public view override returns (uint256) {\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\n        return _packedAddressData[owner] \\u0026 BITMASK_ADDRESS_DATA_ENTRY;}\\n\\n    function _numberMinted(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] \\u003e\\u003e BITPOS_NUMBER_MINTED) \\u0026 BITMASK_ADDRESS_DATA_ENTRY;}\\n\\n    function _numberBurned(address owner) internal view returns (uint256) {\\n        return (_packedAddressData[owner] \\u003e\\u003e BITPOS_NUMBER_BURNED) \\u0026 BITMASK_ADDRESS_DATA_ENTRY;}\\n\\n    function _getAux(address owner) internal view returns (uint64) {\\n        return uint64(_packedAddressData[owner] \\u003e\\u003e BITPOS_AUX);}\\n\\n    function _setAux(address owner, uint64 aux) internal {\\n        uint256 packed = _packedAddressData[owner];\\n        uint256 auxCasted;\\n        assembly { // Cast aux without masking.\\n            auxCasted := aux}\\n        packed = (packed \\u0026 BITMASK_AUX_COMPLEMENT) | (auxCasted \\u003c\\u003c BITPOS_AUX);\\n        _packedAddressData[owner] = packed;}\\n\\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\\n        uint256 curr = tokenId;\\n        unchecked {\\n            if (_startTokenId() \\u003c= curr)\\n                if (curr \\u003c _currentIndex) {\\n                    uint256 packed = _packedOwnerships[curr];\\n                    // If not burned.\\n                    if (packed \\u0026 BITMASK_BURNED == 0) {\\n                        // Invariant:\\n                        // There will always be an ownership that has an address and is not burned\\n                        // before an ownership that does not have an address and is not burned.\\n                        // Hence, curr will not underflow.\\n                        //\\n                        // We can directly compare the packed value.\\n                        // If the address is zero, packed is zero.\\n                        while (packed == 0) {\\n                            packed = _packedOwnerships[--curr];}\\n                        return packed;}}}\\n        revert OwnerQueryForNonexistentToken();}\\n\\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\\n        ownership.addr = address(uint160(packed));\\n        ownership.startTimestamp = uint64(packed \\u003e\\u003e BITPOS_START_TIMESTAMP);\\n        ownership.burned = packed \\u0026 BITMASK_BURNED != 0;}\\n\\n    function _ownershipAt(uint256 index) internal view returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnerships[index]);}\\n\\n    function _initializeOwnershipAt(uint256 index) internal {\\n        if (_packedOwnerships[index] == 0) {\\n            _packedOwnerships[index] = _packedOwnershipOf(index);}}\\n\\n    function _ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {\\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));}\\n\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        return address(uint160(_packedOwnershipOf(tokenId)));}\\n\\n    function name() public view virtual override returns (string memory) {\\n        return _name;}\\n\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;}\\n\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : \\u0027\\u0027;}\\n\\n    //Base URI for computing {tokenURI}. \\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\u0027\\u0027;}\\n\\n    function _addressToUint256(address value) private pure returns (uint256 result) {\\n        assembly {\\n            result := value}}\\n\\n    function _boolToUint256(bool value) private pure returns (uint256 result) {\\n        assembly {\\n            result := value}}\\n\\n    function approve(address to, uint256 tokenId) public override {\\n        address owner = address(uint160(_packedOwnershipOf(tokenId)));\\n        if (to == owner) revert ApprovalToCurrentOwner();\\n        if (_msgSenderERC721A() != owner)\\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\\n                revert ApprovalCallerNotOwnerNorApproved();}\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(owner, to, tokenId);}\\n\\n    function getApproved(uint256 tokenId) public view override returns (address) {\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\n        return _tokenApprovals[tokenId];}\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        if (operator == _msgSenderERC721A()) revert ApproveToCaller();\\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);}\\n\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];}\\n\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        _transfer(from, to, tokenId);}\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\u0027\\u0027);}\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n        _transfer(from, to, tokenId);\\n        if (to.code.length != 0)\\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\n                revert TransferToNonERC721ReceiverImplementer();}}\\n\\n    //Returns whether `tokenId` exists\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        return _startTokenId() \\u003c= tokenId \\u0026\\u0026 tokenId \\u003c _currentIndex \\u0026\\u0026 _packedOwnerships[tokenId] \\u0026 BITMASK_BURNED == 0;}\\n\\n    //Equivalent to `_safeMint(to, quantity, \\u0027\\u0027)`\\n    function _safeMint(address to, uint256 quantity) internal {\\n        _safeMint(to, quantity, \\u0027\\u0027);}\\n\\n    //Safely mints `quantity` tokens and transfers them to `to`\\n    function _safeMint(address to, uint256 quantity, bytes memory _data) internal {\\n        uint256 startTokenId = _currentIndex;\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (quantity == 0) revert MintZeroQuantity();\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n        // Overflows are incredibly unrealistic.\\n        // balance or numberMinted overflow if current value of either + quantity \\u003e 1.8e19 (2**64) - 1\\n        // updatedIndex overflows if _currentIndex + quantity \\u003e 1.2e77 (2**256) - 1\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the balance and number minted.\\n            _packedAddressData[to] += quantity * ((1 \\u003c\\u003c BITPOS_NUMBER_MINTED) | 1);\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] =\\n                _addressToUint256(to) |\\n                (block.timestamp \\u003c\\u003c BITPOS_START_TIMESTAMP) |\\n                (_boolToUint256(quantity == 1) \\u003c\\u003c BITPOS_NEXT_INITIALIZED);\\n            uint256 updatedIndex = startTokenId;\\n            uint256 end = updatedIndex + quantity;\\n            if (to.code.length != 0) {\\n                do {\\n                    emit Transfer(address(0), to, updatedIndex);\\n                    if (!_checkContractOnERC721Received(address(0), to, updatedIndex++, _data)) {\\n                        revert TransferToNonERC721ReceiverImplementer();}} \\n                while (updatedIndex \\u003c end);\\n                // Reentrancy protection\\n                if (_currentIndex != startTokenId) revert();} \\n                else {\\n                do {emit Transfer(address(0), to, updatedIndex++);} while (updatedIndex \\u003c end);}\\n            _currentIndex = updatedIndex;}\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);}\\n\\n    //Mints `quantity` tokens and transfers them to `to`\\n    function _mint(address to, uint256 quantity) internal {\\n        uint256 startTokenId = _currentIndex;\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (quantity == 0) revert MintZeroQuantity();\\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\\n        // Overflows are incredibly unrealistic.\\n        // balance or numberMinted overflow if current value of either + quantity \\u003e 1.8e19 (2**64) - 1\\n        // updatedIndex overflows if _currentIndex + quantity \\u003e 1.2e77 (2**256) - 1\\n        unchecked {\\n            // Updates:\\n            // - `balance += quantity`.\\n            // - `numberMinted += quantity`.\\n            //\\n            // We can directly add to the balance and number minted.\\n            _packedAddressData[to] += quantity * ((1 \\u003c\\u003c BITPOS_NUMBER_MINTED) | 1);\\n            // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _packedOwnerships[startTokenId] =\\n                _addressToUint256(to) |\\n                (block.timestamp \\u003c\\u003c BITPOS_START_TIMESTAMP) |\\n                (_boolToUint256(quantity == 1) \\u003c\\u003c BITPOS_NEXT_INITIALIZED);\\n            uint256 updatedIndex = startTokenId;\\n            uint256 end = updatedIndex + quantity;\\n            do {emit Transfer(address(0), to, updatedIndex++);} while (updatedIndex \\u003c end);\\n            _currentIndex = updatedIndex;}\\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);}\\n\\n    //Transfers `tokenId` from `from` to `to`\\n    function _transfer(address from, address to, uint256 tokenId) private {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\\n        bool isApprovedOrOwner = (_msgSenderERC721A() == from ||\\n            isApprovedForAll(from, _msgSenderERC721A()) ||\\n            getApproved(tokenId) == _msgSenderERC721A());\\n        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\\n        if (to == address(0)) revert TransferToZeroAddress();\\n        _beforeTokenTransfers(from, to, tokenId, 1);\\n        // Clear approvals from the previous owner.\\n        delete _tokenApprovals[tokenId];\\n        // Underflow of the sender\\u0027s balance is impossible because we check for\\n        // ownership above and the recipient\\u0027s balance can\\u0027t realistically overflow.\\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\\n        unchecked {\\n            // We can directly increment and decrement the balances.\\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\\n            // Updates:\\n            // - `address` to the next owner.\\n            // - `startTimestamp` to the timestamp of transfering.\\n            // - `burned` to `false`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] =\\n                _addressToUint256(to) |\\n                (block.timestamp \\u003c\\u003c BITPOS_START_TIMESTAMP) |\\n                BITMASK_NEXT_INITIALIZED;\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked \\u0026 BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot\\u0027s address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;}}}}\\n        emit Transfer(from, to, tokenId);\\n        _afterTokenTransfers(from, to, tokenId, 1);}\\n\\n    //Equivalent to `_burn(tokenId, false)`\\n    function _burn(uint256 tokenId) internal virtual {\\n        _burn(tokenId, false);}\\n\\n    //Destroys `tokenId`\\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\\n        address from = address(uint160(prevOwnershipPacked));\\n        if (approvalCheck) {\\n            bool isApprovedOrOwner = (_msgSenderERC721A() == from || isApprovedForAll(from, _msgSenderERC721A()) || getApproved(tokenId) == _msgSenderERC721A());\\n            if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();}\\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\\n        // Clear approvals from the previous owner.\\n        delete _tokenApprovals[tokenId];\\n        // Underflow of the sender\\u0027s balance is impossible because we check for\\n        // ownership above and the recipient\\u0027s balance can\\u0027t realistically overflow.\\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\\n        unchecked {\\n            // Updates:\\n            // - `balance -= 1`.\\n            // - `numberBurned += 1`.\\n            //\\n            // We can directly decrement the balance, and increment the number burned.\\n            // This is equivalent to `packed -= 1; packed += 1 \\u003c\\u003c BITPOS_NUMBER_BURNED;`.\\n            _packedAddressData[from] += (1 \\u003c\\u003c BITPOS_NUMBER_BURNED) - 1;\\n            // Updates:\\n            // - `address` to the last owner.\\n            // - `startTimestamp` to the timestamp of burning.\\n            // - `burned` to `true`.\\n            // - `nextInitialized` to `true`.\\n            _packedOwnerships[tokenId] =\\n                _addressToUint256(from) |\\n                (block.timestamp \\u003c\\u003c BITPOS_START_TIMESTAMP) |\\n                BITMASK_BURNED | \\n                BITMASK_NEXT_INITIALIZED;\\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\\n            if (prevOwnershipPacked \\u0026 BITMASK_NEXT_INITIALIZED == 0) {\\n                uint256 nextTokenId = tokenId + 1;\\n                // If the next slot\\u0027s address is zero and not burned (i.e. packed value is zero).\\n                if (_packedOwnerships[nextTokenId] == 0) {\\n                    // If the next slot is within bounds.\\n                    if (nextTokenId != _currentIndex) {\\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;}}}}\\n        emit Transfer(from, address(0), tokenId);\\n        _afterTokenTransfers(from, address(0), tokenId, 1);\\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\\n        unchecked {_burnCounter++;}}\\n\\n    //Internal function to invoke {IERC721Receiver-onERC721Received} on a target contract\\n    function _checkContractOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) private returns (bool) {\\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (bytes4 retval) {\\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;} \\n            catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                revert TransferToNonERC721ReceiverImplementer();} \\n            else {\\n                assembly {revert(add(32, reason), mload(reason))}}}}\\n\\n    //Hook that is called before a set of serially-ordered token ids are about to be transferred\\n    function _beforeTokenTransfers(address from, address to, uint256 startTokenId, uint256 quantity) internal virtual {}\\n\\n    //Hook that is called after a set of serially-ordered token ids have been transferred\\n    function _afterTokenTransfers(address from, address to, uint256 startTokenId, uint256 quantity) internal virtual {}\\n\\n    //Returns the message sender (defaults to `msg.sender`)\\n    function _msgSenderERC721A() internal view virtual returns (address) {\\n        return msg.sender;}\\n\\n    //Converts a `uint256` to its ASCII `string` decimal representation\\n    function _toString(uint256 value) internal pure returns (string memory ptr) {\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), \\n            // but we allocate 128 bytes to keep the free memory pointer 32-byte word aliged.\\n            // We will need 1 32-byte word to store the length, \\n            // and 3 32-byte words to store a maximum of 78 digits. Total: 32 + 3 * 32 = 128.\\n            ptr := add(mload(0x40), 128)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, ptr)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := ptr\\n\\n            // We write the string from the rightmost digit to the leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // Costs a bit more than early returning for the zero case,\\n            // but cheaper in terms of deployment and overall runtime costs.\\n            for { \\n                // Initialize and perform the first pass without check.\\n                let temp := value\\n                // Move the pointer 1 byte leftwards to point to an empty character slot.\\n                ptr := sub(ptr, 1)\\n                // Write the character to the pointer. 48 is the ASCII index of \\u00270\\u0027.\\n                mstore8(ptr, add(48, mod(temp, 10)))\\n                temp := div(temp, 10)} \\n            temp { \\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)} { // Body of the for loop.\\n                ptr := sub(ptr, 1)\\n                mstore8(ptr, add(48, mod(temp, 10)))}\\n            let length := sub(end, ptr)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            ptr := sub(ptr, 32)\\n            // Store the length.\\n            mstore(ptr, length)}}}\\n\\nabstract contract ReentrancyGuard {\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;}\\n\\n    //Prevents a contract from calling itself, directly or indirectly.\\n    //Calling a `nonReentrant` function from another `nonReentrant`function is not supported. \\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n        _;\\n        _status = _NOT_ENTERED;}}\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;}\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;}}\\n\\nabstract contract Ownable is Context {\\n\\n    address private _owner;\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor() {\\n        //dev Initializes the contract setting the deployer as the initial owner\\n        _transferOwnership(_msgSender());}\\n\\n    function owner() public view virtual returns (address) {\\n        //Returns the address of the current owner\\n        return _owner;}\\n\\n    modifier onlyOwner() {\\n        //Throws if called by any account other than the owner\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;}\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        //Leaves the contract without owner\\n        _transferOwnership(address(0));}\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        //Transfers ownership of the contract to a new account (`newOwner`)\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);}\\n\\n    function _transferOwnership(address newOwner) internal virtual {\\n        //Transfers ownership of the contract to a new account (`newOwner`)\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);}}\\n\\n\\n\"},\"edition.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n/*\\n  ____                         \\n |  _ \\\\  ___  _ __ ___    ___  \\n | |_) |/ _ \\\\| \\u0027_ ` _ \\\\  / _ \\\\ \\n |  _ \\u003c|  __/| | | | | || (_) |\\n |_| \\\\_\\\\\\\\___||_| |_| |_| \\\\___/                           \\n   _____  _                   ______     _  _  _    _               \\n  / ____|| |                 |  ____|   | |(_)| |  (_)              \\n | |  __ | |  ___ __      __ | |__    __| | _ | |_  _   ___   _ __  \\n | | |_ || | / _ \\\\\\\\ \\\\ /\\\\ / / |  __|  / _` || || __|| | / _ \\\\ | \\u0027_ \\\\ \\n | |__| || || (_) |\\\\ V  V /  | |____| (_| || || |_ | || (_) || | | |\\n  \\\\_____||_| \\\\___/  \\\\_/\\\\_/   |______|\\\\__,_||_| \\\\__||_| \\\\___/ |_| |_|\\n                                                                                                                                                  \\nArtist and Founder: Joey Tadiar\\nSmart Contract: giudev.eth\\nTechnology: Forint Finance Ltd\\n\\n*/\\n\\n\\nimport \\\"./contract.sol\\\";\\nimport \\\"./library.sol\\\";\\n\\npragma solidity ^0.8.14;\\n\\ncontract remosworldsubcontract is ERC721A, Ownable, ReentrancyGuard {\\n    using Strings for uint256;\\n\\n    IERC721A public remosAddress;\\n\\n    string public uriPrefix = \\\"\\\";\\n    string public uriSuffix = \\\"\\\";\\n\\n    bool public revealed = false;\\n    bool public paused = true;\\n    \\n    mapping(address =\\u003e uint) public minted;\\n    mapping(uint =\\u003e bool) public idMinted;\\n\\n    uint256 public maxSupply = 500;\\n    uint256 public maxWalletAmount;\\n    \\n\\n    uint256 public mintedNFT;\\n    \\n    uint256 public priceNFT = 0 ether;\\n    string public hiddenMetadataUri = \\\"ipfs://QmacJbn9XuPeS11HLTSvCHfWTAKJ3x5xAoeFzGNZjXQ4hM/\\\";\\n\\n    string public _name = \\\"REMO: Glow Edition\\\";\\n    string public _symbol = \\\"REM003\\\";\\n    \\n    constructor() ERC721A(_name, _symbol) {}\\n\\n    modifier mintCompliance(uint256 _mintAmount) {\\n        require(msg.value \\u003e= priceNFT * _mintAmount, \\\"Insufficient Funds\\\");\\n        require(totalSupply() + _mintAmount \\u003c= maxSupply, \\\"Mintable supply exceeded!\\\");\\n        require(paused == false, \\\"Contract paused\\\");\\n        _;}\\n\\n    function checkBalance(address _addr) public view returns (uint256) {\\n        uint256 balance = remosAddress.balanceOf(_addr);\\n        return balance;}\\n\\n    function checkNFT(uint256[]memory _tokenId) public view returns (uint256[] memory, uint256[] memory) {\\n        \\n        uint256 _mintedAmount;\\n        uint256 _notMintedAmount;\\n\\n        for (uint256 i = 0; i \\u003c _tokenId.length; i++) {\\n            if (idMinted[_tokenId[i]] == false) {\\n                _notMintedAmount ++;}\\n            else {\\n                _mintedAmount ++;}}\\n\\n        uint256[] memory _notMintedNFT = new uint256[](_notMintedAmount);\\n        uint256[] memory _mintedNFT = new uint256[](_mintedAmount);\\n        uint256 _counterNotMinted;\\n        uint256 _counterMinted;\\n\\n        for (uint256 i = 0; i \\u003c _tokenId.length; i++) {\\n            if (idMinted[_tokenId[i]] == false) {\\n                _notMintedNFT[_counterNotMinted] = _tokenId[i];\\n                _counterNotMinted ++;}\\n            else {\\n                _mintedNFT[_counterMinted] = _tokenId[i];\\n                _counterMinted ++;}}\\n\\n        return (_notMintedNFT, _mintedNFT);}\\n\\n    function setPrice(uint256 _price) public onlyOwner {\\n        priceNFT = _price;}\\n\\n    function setNFTAddress(address _addr) public onlyOwner {\\n        remosAddress = IERC721A(_addr);}\\n\\n    function ownerBlacklistBatchNFT(uint256[]memory _nftId) public onlyOwner {\\n        for (uint256 i = 0; i \\u003c _nftId.length; i++) {\\n            idMinted[_nftId[i]] = true;}}\\n\\n    function blacklistBatchNFT(uint256[]memory _nftId) private {\\n        for (uint256 i = 0; i \\u003c _nftId.length; i++) {\\n            idMinted[_nftId[i]] = true;}}\\n\\n    function mint(uint256[] memory _tokenId) public payable mintCompliance(_tokenId.length) nonReentrant {\\n        for (uint256 i = 0; i \\u003c _tokenId.length; i++) {\\n            require(remosAddress.ownerOf(_tokenId[i]) == _msgSender() \\u0026\\u0026 idMinted[_tokenId[i]] == false, \\\"Not NFT owner or NFT not valid\\\");}\\n        _safeMint(_msgSender(), _tokenId.length);\\n        blacklistBatchNFT(_tokenId);}\\n\\n    function _startTokenId() internal view virtual override returns (uint256) {\\n        return 1;}\\n\\n    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {\\n        require(_exists(_tokenId), \\u0027ERC721Metadata: URI query for nonexistent token\\u0027);\\n        if (revealed == false) {\\n            return hiddenMetadataUri;}\\n        string memory currentBaseURI = _baseURI();\\n        return bytes(currentBaseURI).length \\u003e 0 ? string(abi.encodePacked(currentBaseURI, _tokenId.toString(), uriSuffix)): \\u0027\\u0027;}\\n    \\n    function setRevealed(bool _state) public onlyOwner {\\n        revealed = _state;}\\n\\n    function setPause(bool _state) public onlyOwner {\\n        paused = _state;}\\n\\n    function setHiddenMetadataUri(string memory _hiddenMetadataUri) public onlyOwner {\\n        hiddenMetadataUri = _hiddenMetadataUri;}\\n\\n    function setUriPrefix(string memory _uriPrefix) public onlyOwner {\\n        uriPrefix = _uriPrefix;}\\n\\n    function _baseURI() internal view virtual override returns (string memory) {\\n        return uriPrefix;}\\n\\n    function setUriSuffix(string memory _uriSuffix) public onlyOwner {\\n        uriSuffix = _uriSuffix;}\\n\\n    function getMinted() public view returns (uint256, uint256) {\\n        uint256 _mintedNFT = totalSupply();\\n        uint256 _totalSupply = maxSupply;\\n        return (_mintedNFT, _totalSupply);}\\n\\n    receive() external payable {}\\n\\n    fallback() external payable {}\\n\\n    function transferERC20(address _tokenAddr, address _to, uint _amount) public onlyOwner nonReentrant {  \\n        require(new_type_IERC20(_tokenAddr).transfer(_to, _amount), \\\"Could not transfer out tokens!\\\");}\\n\\n    function transferERC20O(address _tokenAddr, address _to, uint _amount) public onlyOwner nonReentrant {    \\n        old_type_IERC20(_tokenAddr).transfer(_to, _amount);}\\n        \\n    function withdrawEther(address _to) public onlyOwner nonReentrant {\\n        (bool os, ) = payable(_to).call{value: address(this).balance}(\\u0027\\u0027);\\n        require(os);}}\\n\"},\"interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.14;\\n                                  \\ninterface IERC721A {\\n\\n    // The caller must own the token or be an approved operator\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    //The token does not exist\\n    error ApprovalQueryForNonexistentToken();\\n\\n    //The caller cannot approve to their own address\\n    error ApproveToCaller();\\n\\n    //The caller cannot approve to the current owner\\n    error ApprovalToCurrentOwner();\\n\\n    //Cannot query the balance for the zero address\\n    error BalanceQueryForZeroAddress();\\n\\n    //Cannot mint to the zero address\\n    error MintToZeroAddress();\\n\\n    //The quantity of tokens minted must be more than zero\\n    error MintZeroQuantity();\\n\\n    //The token does not exist\\n    error OwnerQueryForNonexistentToken();\\n\\n    //The caller must own the token or be an approved operator.\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    ///The token must be owned by `from`\\n    error TransferFromIncorrectOwner();\\n\\n    //Cannot safely transfer to a contract that does not implement the ERC721Receiver interface.\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    //Cannot transfer to the zero address\\n    error TransferToZeroAddress();\\n\\n    //The token does not exist\\n    error URIQueryForNonexistentToken();\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Keeps track of the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;}\\n\\n    //Returns the total amount of tokens stored by the contract\\n    //Burned tokens are calculated here, use `_totalMinted()` if you want to count just minted tokens\\n    function totalSupply() external view returns (uint256);\\n\\n    //Returns true if this contract implements the interface defined by `interfaceId`\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    //Emitted when `tokenId` token is transferred from `from` to `to`\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    //Emitted when `owner` enables `approved` to manage the `tokenId` token\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    //Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    //Returns the number of tokens in `owner` account\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    //Returns the owner of the `tokenId` token\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    //Safely transfers `tokenId` token from `from` to `to`\\n    //Requirements: `from` cannot be the zero address\\n    //              `to` cannot be the zero address\\n    //              `tokenId` token must exist and be owned by `from`\\n    //              If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}\\n    //              If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    //Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n    //Requirements: `from` cannot be the zero address.\\n    //              `to` cannot be the zero address.\\n    //              `tokenId` token must exist and be owned by `from`\\n    //              If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}\\n    //              If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    //Transfers `tokenId` token from `from` to `to`\\n    //Requirements: `from` cannot be the zero address\\n    //              `to` cannot be the zero address\\n    //              `tokenId` token must be owned by `from`\\n    //              If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    //Gives permission to `to` to transfer `tokenId` token to another account\\n    function approve(address to, uint256 tokenId) external;\\n\\n    //Approve or remove `operator` as an operator for the caller\\n    //Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller\\n    //Requirements: The `operator` cannot be the caller.\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    //Returns the account approved for `tokenId` token.\\n    //Requirements: `tokenId` must exist\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    //Returns if the `operator` is allowed to manage all of the assets of `owner`\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    //Returns the token collection name\\n    function name() external view returns (string memory);\\n\\n    //Returns the token collection symbol\\n    function symbol() external view returns (string memory);\\n\\n    //Returns the Uniform Resource Identifier (URI) for `tokenId` token\\n    function tokenURI(uint256 tokenId) external view returns (string memory);}\\n\\ninterface ERC721A__IERC721Receiver {\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);}\\n\\ninterface new_type_IERC20 {\\n    function transfer(address, uint) external returns (bool);}\\n\\ninterface old_type_IERC20 {\\n    function transfer(address, uint) external;}\\n\\n\\n\"},\"library.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.14;\\n\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0\\\";}\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;}\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;}\\n        return string(buffer);}\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";}\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp \\u003e\\u003e= 8;}\\n        return toHexString(value, length);}\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i \\u003e 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value \\u0026 0xf];\\n            value \\u003e\\u003e= 4;}\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);}\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);}}\\n\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalToCurrentOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApproveToCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"URIQueryForNonexistentToken\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"_name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenId\",\"type\":\"uint256[]\"}],\"name\":\"checkNFT\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hiddenMetadataUri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idMinted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenId\",\"type\":\"uint256[]\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintedNFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_nftId\",\"type\":\"uint256[]\"}],\"name\":\"ownerBlacklistBatchNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceNFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remosAddress\",\"outputs\":[{\"internalType\":\"contract IERC721A\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revealed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_hiddenMetadataUri\",\"type\":\"string\"}],\"name\":\"setHiddenMetadataUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setNFTAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setRevealed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uriPrefix\",\"type\":\"string\"}],\"name\":\"setUriPrefix\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uriSuffix\",\"type\":\"string\"}],\"name\":\"setUriSuffix\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferERC20O\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uriPrefix\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uriSuffix\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "remosworldsubcontract", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://605f41df1e6926e111ecf0ffda34bde2c75f7cd9fa459c1393aad4771d87ecd4"}