{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Game.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./IterableMapping.sol\\\";\\n\\ncontract Game is Ownable {\\nusing IterableMapping for IterableMapping.Map;\\nIterableMapping.Map private playersScores;\\naddress public manager;\\naddress payable public address1;\\nuint256 public playPrice = 1000000000000000; // 0.001 Matic\\nuint256 public address1Share;\\nbool public gameStarted = false;\\nuint256 public highScore = 0;\\n\\nstruct Player {\\n    address player;\\n    uint256 score;\\n}\\n\\n// Evento para notificar cuando un jugador paga y juega\\nevent PlayerPaid(address indexed player, uint256 amount);\\n\\nmodifier onlyManager() {\\n    require(manager == msg.sender, \\\"Only manager can call this function.\\\");\\n    _;\\n}\\n\\nreceive() external payable {}\\n\\nconstructor(address payable _address1, address _manager) {\\n    manager = _manager;\\n    address1 = _address1;\\n    gameStarted = true; // remove on mainnet\\n}\\n\\nfunction setAddress1(address payable _address1) external onlyOwner {\\n    address1 = _address1;\\n}\\n\\nfunction setPlayPrice(uint256 _playPrice) external onlyOwner {\\n    playPrice = _playPrice;\\n}\\n\\nfunction setManager(address _manager) external onlyOwner {\\n    manager = _manager;\\n}\\n\\nfunction enableGame() external onlyOwner {\\n    require(!gameStarted, \\\"El juego ya ha comenzado.\\\");\\n    gameStarted = true;\\n}\\n\\nfunction setPlayerScore(\\n    address payable _player,\\n    uint256 _score\\n) external onlyManager {\\n    require(gameStarted, \\\"El juego aun no ha comenzado.\\\");\\n    highScore = _score;\\n    playersScores.set(_player, _score);\\n}\\n\\n// Funci\u00f3n para que un usuario pague el fee y juegue\\nfunction play() external payable {\\n    require(gameStarted, \\\"El juego aun no ha comenzado.\\\");\\n    require(msg.value == playPrice, \\\"Invalid amount of ETH.\\\");\\n\\n    // Calcula los shares para las direcciones\\n    address1Share = (msg.value * 30) / 100;\\n\\n    // Transfiere los pagos a las direcciones\\n    (bool sent, ) = address1.call{value: address1Share}(\\\"\\\");\\n    require(sent, \\\"Failed to send Ether\\\");\\n\\n    // Registra al jugador\\n    playersScores.set(msg.sender, 0);\\n\\n    // Emite un evento para notificar que un jugador ha pagado y jugado\\n    emit PlayerPaid(msg.sender, msg.value);\\n}\\n\\n// Funci\u00f3n para finalizar el juego y retirar el saldo restante\\nfunction endGame() external onlyOwner {\\n    require(gameStarted, \\\"El juego aun no ha comenzado.\\\");\\n    require(\\n        playersScores.size() >= 3,\\n        \\\"Debe haber al menos 3 jugadores para distribuir premios.\\\"\\n    );\\n\\n    // Obtiene las tres mejores direcciones de jugadores por puntuaci\u00f3n\\n    address[] memory topThreePlayers = getTopThreePlayers();\\n\\n    // Calcula la parte para los tres ganadores (70% restante)\\n    uint256 remainingShare = address(this).balance;\\n\\n    // Calcula las partes para los tres ganadores\\n    uint256 firstPlaceShare = (remainingShare * 40) / 100;\\n    uint256 secondPlaceShare = (remainingShare * 30) / 100;\\n    uint256 thirdPlaceShare = (remainingShare * 30) / 100;\\n\\n    gameStarted = false;\\n    for (uint256 i = 0; i < playersScores.size(); i++) {\\n        playersScores.remove(playersScores.getKeyAtIndex(i));\\n    }\\n    highScore = 0;\\n\\n    // Transfiere las partes a los tres ganadores\\n    (bool firstSent, ) = topThreePlayers[0].call{value: firstPlaceShare}(\\n        \\\"\\\"\\n    );\\n    require(firstSent, \\\"Fallo al enviar Ether al primer ganador.\\\");\\n\\n    (bool secondSent, ) = topThreePlayers[1].call{value: secondPlaceShare}(\\n        \\\"\\\"\\n    );\\n    require(secondSent, \\\"Fallo al enviar Ether al segundo ganador.\\\");\\n\\n    (bool thirdSent, ) = topThreePlayers[2].call{value: thirdPlaceShare}(\\n        \\\"\\\"\\n    );\\n    require(thirdSent, \\\"Fallo al enviar Ether al tercer ganador.\\\");\\n}\\n\\nfunction clearRanking() external onlyOwner {\\n    for (uint256 i = 0; i < playersScores.size(); i++) {\\n        playersScores.remove(playersScores.getKeyAtIndex(i));\\n    }\\n    highScore = 0;\\n}\\n\\n// Funci\u00f3n para que el propietario vea todas las direcciones de los jugadores\\nfunction getRanking() external view returns (Player[] memory) {\\n    Player[] memory players = new Player[](playersScores.size());\\n    for (uint256 i = 0; i < playersScores.size(); i++) {\\n        players[i] = Player({\\n            player: playersScores.getKeyAtIndex(i),\\n            score: playersScores.get(playersScores.getKeyAtIndex(i))\\n        });\\n    }\\n    return players;\\n}\\n\\n// function for get top 3 players by score\\nfunction getTopThreePlayers() public view returns (address[] memory) {\\n    address[] memory topThreePlayers = new address[](3);\\nuint256[3] memory topScores = [uint256(0), uint256(0), uint256(0)];\\n    for (uint256 i = 0; i < playersScores.size(); i++) {\\n        uint256 score = playersScores.get(playersScores.getKeyAtIndex(i));\\n        if (score > topScores[0]) {\\n            topScores[2] = topScores[1];\\n            topScores[1] = topScores[0];\\n            topScores[0] = score;\\n            topThreePlayers[2] = topThreePlayers[1];\\n            topThreePlayers[1] = topThreePlayers[0];\\n            topThreePlayers[0] = playersScores.getKeyAtIndex(i);\\n        } else if (score > topScores[1]) {\\n            topScores[2] = topScores[1];\\n            topScores[1] = score;\\n            topThreePlayers[2] = topThreePlayers[1];\\n            topThreePlayers[1] = playersScores.getKeyAtIndex(i);\\n        } else if (score > topScores[2]) {\\n            topScores[2] = score;\\n            topThreePlayers[2] = playersScores.getKeyAtIndex(i);\\n        }\\n    }\\n    return topThreePlayers;\\n}\\n}\"\r\n    },\r\n    \"contracts/IterableMapping.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nlibrary IterableMapping {\\n    // Iterable mapping from address to uint;\\n    struct Map {\\n        address[] keys;\\n        mapping(address => uint256) values;\\n        mapping(address => uint256) indexOf;\\n        mapping(address => bool) inserted;\\n    }\\n\\n    function get(Map storage map, address key) public view returns (uint256) {\\n        return map.values[key];\\n    }\\n\\n    function getIndexOfKey(Map storage map, address key)\\n        public\\n        view\\n        returns (int256)\\n    {\\n        if (!map.inserted[key]) {\\n            return -1;\\n        }\\n        return int256(map.indexOf[key]);\\n    }\\n\\n    function getKeyAtIndex(Map storage map, uint256 index)\\n        public\\n        view\\n        returns (address)\\n    {\\n        return map.keys[index];\\n    }\\n\\n    function size(Map storage map) public view returns (uint256) {\\n        return map.keys.length;\\n    }\\n\\n    function set(\\n        Map storage map,\\n        address key,\\n        uint256 val\\n    ) public {\\n        if (map.inserted[key]) {\\n            map.values[key] = val;\\n        } else {\\n            map.inserted[key] = true;\\n            map.values[key] = val;\\n            map.indexOf[key] = map.keys.length;\\n            map.keys.push(key);\\n        }\\n    }\\n\\n    function remove(Map storage map, address key) public {\\n        if (!map.inserted[key]) {\\n            return;\\n        }\\n\\n        delete map.inserted[key];\\n        delete map.values[key];\\n\\n        uint256 index = map.indexOf[key];\\n        uint256 lastIndex = map.keys.length - 1;\\n        address lastKey = map.keys[lastIndex];\\n\\n        map.indexOf[lastKey] = index;\\n        delete map.indexOf[key];\\n\\n        map.keys[index] = lastKey;\\n        map.keys.pop();\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/IterableMapping.sol\": {\r\n        \"IterableMapping\": \"0x9e5622e687ed27289622d0dc587b9f85ceaef061\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_address1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PlayerPaid\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"address1\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"address1Share\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearRanking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRanking\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"score\",\"type\":\"uint256\"}],\"internalType\":\"struct Game.Player[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTopThreePlayers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"highScore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"play\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"playPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_address1\",\"type\":\"address\"}],\"name\":\"setAddress1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_playPrice\",\"type\":\"uint256\"}],\"name\":\"setPlayPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_player\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_score\",\"type\":\"uint256\"}],\"name\":\"setPlayerScore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Game", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "0000000000000000000000006c6dafaf87de283eee8a89494aea5f79e5c7d4f50000000000000000000000006c6dafaf87de283eee8a89494aea5f79e5c7d4f5", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}