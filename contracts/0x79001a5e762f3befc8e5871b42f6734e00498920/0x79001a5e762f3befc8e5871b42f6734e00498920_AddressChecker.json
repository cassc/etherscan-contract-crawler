{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"AddressChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IAddressChecker.sol\\\";\\n\\n/**\\n * @title    Address Checker contract\\n * @notice   Gets data from multiple addresses in single function calls.\\n *           It can be used to check balances and to check whether there is bytecode\\n *           (contract deployed) for multiple addresses. This is useful in order to avoid\\n *           issuing a separate call for each address, which is very innefficient.\\n * @dev      This contract only contains view functions that doesn't spend gas. However, some RPC\\n *           providers put a cap on the amount of gas that the transaction *would* consume to\\n *           prevent spamming. As a rough refernece, a try using a free INFURA endpoint succesfully\\n *           executes around 75k addresses for getNativeBalances but fails when requesting 100k.\\n *           It's advised to split up such big lists to prevent failures.\\n */\\ncontract AddressChecker is IAddressChecker {\\n    /**\\n     * @notice  Returns an array of the native token balances for array of addresses.\\n     * @param addresses  Array of addresses to check.\\n     */\\n    function nativeBalances(address[] calldata addresses) external view override returns (uint[] memory) {\\n        uint256 length = addresses.length;\\n\\n        uint[] memory balances = new uint[](length);\\n\\n        for (uint i = 0; i < length; ) {\\n            balances[i] = addresses[i].balance;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return balances;\\n    }\\n\\n    /**\\n     * @notice  Returns an array of booleans signaling whether there is bytecode deployed for an array of addresses.\\n     * @param addresses  Array of addresses to check.\\n     */\\n    function contractsDeployed(address[] calldata addresses) external view override returns (bool[] memory) {\\n        uint256 length = addresses.length;\\n\\n        bool[] memory hasContractArray = new bool[](length);\\n\\n        for (uint i = 0; i < length; ) {\\n            hasContractArray[i] = addresses[i].code.length > 0;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return hasContractArray;\\n    }\\n\\n    /**\\n     * @notice  Returns an array of structs with both the native token balance and whether the addresses have bytecode\\n     *          deployed for for an array of addresses.\\n     * @param addresses  Array of addresses to check.\\n     */\\n    function addressStates(address[] calldata addresses) external view override returns (AddressState[] memory) {\\n        uint256 length = addresses.length;\\n\\n        AddressState[] memory addressStateArray = new AddressState[](length);\\n\\n        for (uint i = 0; i < length; ) {\\n            addressStateArray[i] = AddressState(addresses[i].balance, addresses[i].code.length > 0);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return addressStateArray;\\n    }\\n}\\n\"\r\n    },\r\n    \"IAddressChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IAddressChecker {\\n    struct AddressState {\\n        uint256 balance;\\n        bool hasContract;\\n    }\\n\\n    function nativeBalances(address[] calldata addresses) external view returns (uint[] memory);\\n\\n    function contractsDeployed(address[] calldata addresses) external view returns (bool[] memory);\\n\\n    function addressStates(address[] calldata addresses) external view returns (AddressState[] memory);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"libraries\": {\r\n      \"AddressChecker.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"addressStates\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasContract\",\"type\":\"bool\"}],\"internalType\":\"struct IAddressChecker.AddressState[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"contractsDeployed\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"nativeBalances\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AddressChecker", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}