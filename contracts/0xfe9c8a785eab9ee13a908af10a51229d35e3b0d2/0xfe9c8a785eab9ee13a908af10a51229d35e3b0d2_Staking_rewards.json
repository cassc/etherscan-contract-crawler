{"SourceCode": "# @version 0.3.10\r\n\"\"\"\r\n@title Staking rewards\r\n@author 1up\r\n@license GNU AGPLv3\r\n@notice\r\n    Tracks rewards for stakers.\r\n    Staking contract report changes in balances to this contract.\r\n    Assumes that any amount of locking token and discount token in the proxy is a reward for stakers.\r\n    Rewards can be harvested by anyone in exchange for a share of the rewards.\r\n    Users can claim their rewards as:\r\n        - The naked reward token\r\n        - Fully redeemed into the liquid locker token by paying for the redemption cost\r\n        - Partially redeemed into the liquid locker token by selling some of the rewards to\r\n            be able to pay for the redemption cost\r\n    Each of these potentially has different fees associated to them.\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\ninterface Rewards:\r\n    def report(_account: address, _amount: uint256, _supply: uint256): nonpayable\r\nimplements: Rewards\r\n\r\ninterface Redeemer:\r\n    def redeem(_account: address, _receiver: address, _lt_amount: uint256, _dt_amount: uint256, _data: Bytes[256]) -> uint256: payable\r\n\r\nproxy: public(immutable(address))\r\nstaking: public(immutable(ERC20))\r\nlocking_token: public(immutable(ERC20))\r\ndiscount_token: public(immutable(ERC20))\r\nmanagement: public(address)\r\npending_management: public(address)\r\nredeemer: public(Redeemer)\r\ntreasury: public(address)\r\nfee_rates: public(uint256[6])\r\npacked_integrals: public(uint256)\r\npacked_streaming: public(uint256) # updated | lt_amount | dt_amount\r\npacked_next: public(uint256)\r\npacked_account_integrals: public(HashMap[address, uint256])\r\npacked_pending_rewards: public(HashMap[address, uint256])\r\npacked_pending_fees: public(uint256)\r\n\r\nevent Claim:\r\n    account: indexed(address)\r\n    receiver: address\r\n    lt_amount: uint256\r\n    dt_amount: uint256\r\n    fee_idx: uint256\r\n    lt_fee: uint256\r\n    dt_fee: uint256\r\n\r\nevent ClaimFees:\r\n    lt_amount: uint256\r\n    dt_amount: uint256\r\n\r\nevent Harvest:\r\n    account: address\r\n    lt_amount: uint256\r\n    dt_amount: uint256\r\n    lt_fee: uint256\r\n    dt_fee: uint256\r\n\r\nevent SetRedeemer:\r\n    redeemer: address\r\n\r\nevent SetTreasury:\r\n    treasury: address\r\n\r\nevent SetFeeRate:\r\n    idx: uint256\r\n    rate: uint256\r\n\r\nevent PendingManagement:\r\n    management: address\r\n\r\nevent SetManagement:\r\n    management: address\r\n\r\nPRECISION: constant(uint256) = 10**18\r\nMASK: constant(uint256) = 2**128 - 1\r\nSMALL_MASK: constant(uint256) = 2**32 - 1\r\nBIG_MASK: constant(uint256) = 2**112 - 1\r\nWEEK_LENGTH: constant(uint256) = 7 * 24 * 60 * 60\r\nFEE_DENOMINATOR: constant(uint256) = 10_000\r\n\r\nHARVEST_FEE_IDX: constant(uint256)        = 0 # harvest\r\nDT_FEE_IDX: constant(uint256)             = 1 # claim discount token without redeem\r\nDT_REDEEM_SELL_FEE_IDX: constant(uint256) = 2 # claim with redeem, without ETH\r\nDT_REDEEM_FEE_IDX: constant(uint256)      = 3 # claim with redeem, with ETH\r\nLT_FEE_IDX: constant(uint256)             = 4 # claim locking token without deposit into ll\r\nLT_DEPOSIT_FEE_IDX: constant(uint256)     = 5 # claim locking token with deposit into ll\r\n\r\n@external\r\ndef __init__(_proxy: address, _staking: address, _locking_token: address, _discount_token: address):\r\n    \"\"\"\r\n    @notice Constructor\r\n    @param _proxy Proxy\r\n    @param _staking Staking contract\r\n    @param _locking_token Token that can be locked into the voting escrow\r\n    @param _discount_token Token that can be redeemed at a discount\r\n    \"\"\"\r\n    proxy = _proxy\r\n    staking = ERC20(_staking)\r\n    locking_token = ERC20(_locking_token)\r\n    discount_token = ERC20(_discount_token)\r\n    self.management = msg.sender\r\n    self.treasury = msg.sender\r\n    self.packed_streaming = self._pack_triplet(block.timestamp, 0, 0)\r\n\r\n@external\r\n@view\r\ndef pending(_account: address) -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Get the pending rewards of a user\r\n    @param _account User to get pending rewards for\r\n    @return Tuple with pending locking token and discount token rewards\r\n    \"\"\"\r\n    return self._unpack(self.packed_pending_rewards[_account])\r\n\r\n@external\r\n@view\r\ndef claimable(_account: address) -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Get the amount of claimable rewards of a user\r\n    @param _account User to get claimable rewards for\r\n    @return Tuple with claimable locking token and discount token rewards\r\n    \"\"\"\r\n    balance: uint256 = staking.balanceOf(_account)\r\n    supply: uint256 = staking.totalSupply()\r\n\r\n    current_week: uint256 = block.timestamp / WEEK_LENGTH\r\n    lt_integral: uint256 = 0\r\n    dt_integral: uint256 = 0\r\n    lt_integral, dt_integral = self._unpack(self.packed_integrals)\r\n\r\n    updated: uint256 = 0\r\n    lt_streaming: uint256 = 0\r\n    dt_streaming: uint256 = 0\r\n    updated, lt_streaming, dt_streaming = self._unpack_triplet(self.packed_streaming)\r\n\r\n    if supply > 0 and updated < block.timestamp:\r\n        # update integrals\r\n        streaming_week: uint256 = updated / WEEK_LENGTH\r\n        if current_week > streaming_week:\r\n            # new week: unlock all streaming rewards\r\n            updated = current_week * WEEK_LENGTH\r\n            lt_integral += lt_streaming * PRECISION / supply\r\n            dt_integral += dt_streaming * PRECISION / supply\r\n\r\n            lt_next: uint256 = 0\r\n            dt_next: uint256 = 0\r\n            lt_next, dt_next = self._unpack(self.packed_next)\r\n\r\n            if current_week > streaming_week + 1:\r\n                # unlock all next rewards\r\n                lt_streaming = 0\r\n                dt_streaming = 0\r\n                lt_integral += lt_next * PRECISION / supply\r\n                dt_integral += dt_next * PRECISION / supply\r\n            else:\r\n                # next rewards start streaming\r\n                lt_streaming = lt_next\r\n                dt_streaming = dt_next\r\n\r\n        # update streams\r\n        remaining: uint256 = (current_week + 1) * WEEK_LENGTH - updated\r\n        passed: uint256 = block.timestamp - updated # guaranteed to be <= remaining\r\n        lt_integral += (lt_streaming * passed / remaining) * PRECISION / supply\r\n        dt_integral += (dt_streaming * passed / remaining) * PRECISION / supply\r\n\r\n    lt_account_integral: uint256 = 0\r\n    dt_account_integral: uint256 = 0\r\n    lt_account_integral, dt_account_integral = self._unpack(self.packed_account_integrals[_account])\r\n\r\n    lt_pending: uint256 = 0\r\n    dt_pending: uint256 = 0\r\n    lt_pending, dt_pending = self._unpack(self.packed_pending_rewards[_account])\r\n\r\n    lt_pending += (lt_integral - lt_account_integral) * balance / PRECISION\r\n    dt_pending += (dt_integral - dt_account_integral) * balance / PRECISION\r\n\r\n    return lt_pending, dt_pending\r\n\r\n@external\r\n@payable\r\n@nonreentrant(\"lock\")\r\ndef claim(_receiver: address = msg.sender, _redeem_data: Bytes[256] = b\"\") -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Claim staking rewards\r\n    @param _receiver Rewards receiver\r\n    @param _redeem_data Additional data\r\n    @return\r\n        With redemption: tuple of liquid locker token rewards and zero\r\n        Without redemption: tuple of locking token and discount token rewards\r\n    \"\"\"\r\n    balance: uint256 = staking.balanceOf(msg.sender)\r\n    supply: uint256 = staking.totalSupply()\r\n\r\n    lt_amount: uint256 = 0\r\n    dt_amount: uint256 = 0\r\n    lt_amount, dt_amount = self._sync_user(msg.sender, balance, supply)\r\n\r\n    lt_pending_fees: uint256 = 0\r\n    dt_pending_fees: uint256 = 0\r\n    lt_pending_fees, dt_pending_fees = self._unpack(self.packed_pending_fees)\r\n\r\n    redeem: bool = len(_redeem_data) > 0 or msg.value > 0\r\n\r\n    # locking token\r\n    lt_fee: uint256 = LT_FEE_IDX\r\n    if redeem:\r\n        # deposit into liquid locker\r\n        lt_fee = LT_DEPOSIT_FEE_IDX\r\n    lt_fee = lt_amount * self.fee_rates[lt_fee] / FEE_DENOMINATOR\r\n    lt_amount -= lt_fee\r\n    lt_pending_fees += lt_fee\r\n\r\n    # discount token\r\n    fee_idx: uint256 = DT_FEE_IDX\r\n    if redeem:\r\n        if msg.value > 0:\r\n            # redeem by supplying ETH\r\n            fee_idx = DT_REDEEM_FEE_IDX\r\n        else:\r\n            # redeem by partially selling the rewards\r\n            fee_idx = DT_REDEEM_SELL_FEE_IDX\r\n    dt_fee: uint256 = dt_amount * self.fee_rates[fee_idx] / FEE_DENOMINATOR\r\n    dt_amount -= dt_fee\r\n    dt_pending_fees += dt_fee\r\n\r\n    # update pending amounts\r\n    self.packed_pending_rewards[msg.sender] = 0\r\n    self.packed_pending_fees = self._pack(lt_pending_fees, dt_pending_fees)\r\n    log Claim(msg.sender, _receiver, lt_amount, dt_amount, fee_idx, lt_fee, dt_fee)\r\n\r\n    if redeem:\r\n        redeemer: Redeemer = self.redeemer\r\n        assert redeemer.address != empty(address)\r\n        amount: uint256 = redeemer.redeem(msg.sender, _receiver, lt_amount, dt_amount, _redeem_data, value=msg.value)\r\n        return amount, 0\r\n    else:\r\n        # no redemption, transfer naked tokens\r\n        assert locking_token.transfer(_receiver, lt_amount, default_return_value=True)\r\n        assert discount_token.transfer(_receiver, dt_amount, default_return_value=True)\r\n        return lt_amount, dt_amount\r\n\r\n@external\r\ndef harvest(_lt_amount: uint256, _dt_amount: uint256, _receiver: address = msg.sender):\r\n    \"\"\"\r\n    @notice Harvest staking rewards in exchange for a bounty\r\n    @param _lt_amount Amount of locking tokens to harvest\r\n    @param _dt_amount Amount of discount tokens to harvest\r\n    @param _receiver Recipient of harvest bounty\r\n    \"\"\"\r\n    assert _lt_amount > 0 or _dt_amount > 0\r\n    lt_amount: uint256 = _lt_amount\r\n    dt_amount: uint256 = _dt_amount\r\n    fee_rate: uint256 = self.fee_rates[HARVEST_FEE_IDX]\r\n\r\n    # harvest locking tokens\r\n    lt_fee: uint256 = 0\r\n    if lt_amount > 0:\r\n        assert locking_token.transferFrom(proxy, self, lt_amount, default_return_value=True)\r\n        if fee_rate > 0:\r\n            lt_fee = lt_amount * fee_rate / FEE_DENOMINATOR\r\n            lt_amount -= lt_fee\r\n            assert locking_token.transfer(_receiver, lt_fee, default_return_value=True)\r\n\r\n    # harvest discount tokens\r\n    dt_fee: uint256 = 0\r\n    if _dt_amount > 0:\r\n        assert discount_token.transferFrom(proxy, self, dt_amount, default_return_value=True)\r\n        if fee_rate > 0:\r\n            dt_fee = dt_amount * fee_rate / FEE_DENOMINATOR\r\n            dt_amount -= dt_fee\r\n            assert discount_token.transfer(_receiver, dt_fee, default_return_value=True)\r\n\r\n    supply: uint256 = staking.totalSupply()\r\n    assert supply > 0\r\n    self._sync(supply)\r\n\r\n    lt_next: uint256 = 0\r\n    dt_next: uint256 = 0\r\n    lt_next, dt_next = self._unpack(self.packed_next)\r\n    self.packed_next = self._pack(lt_next + lt_amount, dt_next + dt_amount)\r\n    log Harvest(msg.sender, lt_amount, dt_amount, lt_fee, dt_fee)\r\n\r\n@external\r\ndef report(_account: address, _balance: uint256, _supply: uint256):\r\n    \"\"\"\r\n    @notice Report balance to sync reward integrals prior to a change\r\n    @param _account Account\r\n    @param _balance Balance before the change\r\n    @param _supply Supply before the change\r\n    \"\"\"\r\n    assert msg.sender == staking.address\r\n    self._sync_user(_account, _balance, _supply)\r\n\r\n@external\r\n@view\r\ndef pending_fees() -> (uint256, uint256):\r\n    return self._unpack(self.packed_pending_fees)\r\n\r\n@external\r\ndef claim_fees():\r\n    \"\"\"\r\n    @notice Claim fees by sending them to the treasury\r\n    \"\"\"\r\n    treasury: address = self.treasury\r\n\r\n    lt_pending: uint256 = 0\r\n    dt_pending: uint256 = 0\r\n    lt_pending, dt_pending = self._unpack(self.packed_pending_fees)\r\n    self.packed_pending_fees = 0\r\n\r\n    if lt_pending > 0:\r\n        assert locking_token.transfer(treasury, lt_pending, default_return_value=True)\r\n\r\n    if dt_pending > 0:\r\n        assert discount_token.transfer(treasury, dt_pending, default_return_value=True)\r\n    log ClaimFees(lt_pending, dt_pending)\r\n\r\n@external\r\ndef set_redeemer(_redeemer: address):\r\n    \"\"\"\r\n    @notice Set a new redeemer contract\r\n    @param _redeemer Redeemer address\r\n    @dev Retracts allowances for previous redeemer, if applicable\r\n    @dev Sets allowances for new redeemer, if applicable\r\n    @dev Can only be called by management\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n\r\n    previous: address = self.redeemer.address\r\n    if previous != empty(address):\r\n        # retract previous allowances\r\n        assert locking_token.approve(previous, 0, default_return_value=True)\r\n        assert discount_token.approve(previous, 0, default_return_value=True)\r\n    if _redeemer != empty(address):\r\n        # set new allowances\r\n        assert locking_token.approve(_redeemer, max_value(uint256), default_return_value=True)\r\n        assert discount_token.approve(_redeemer, max_value(uint256), default_return_value=True)\r\n\r\n    self.redeemer = Redeemer(_redeemer)\r\n    log SetRedeemer(_redeemer)\r\n\r\n@external\r\ndef set_treasury(_treasury: address):\r\n    \"\"\"\r\n    @notice Set a new treasury, recipient of fees\r\n    @param _treasury Treasury address\r\n    @dev Can only be called by management\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    self.treasury = _treasury\r\n    log SetTreasury(_treasury)\r\n\r\n@external\r\ndef set_fee_rate(_idx: uint256, _fee: uint256):\r\n    \"\"\"\r\n    @notice Set the fee rate for a specific fee type\r\n    @param _idx Fee type\r\n    @param _fee Fee rate (bps)\r\n    @dev Can only be called by management\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    assert _idx < 6\r\n    if _idx == HARVEST_FEE_IDX:\r\n        assert _fee <= FEE_DENOMINATOR / 10\r\n    else:\r\n        assert _fee <= FEE_DENOMINATOR / 2\r\n    self.fee_rates[_idx] = _fee\r\n    log SetFeeRate(_idx, _fee)\r\n\r\n@external\r\ndef set_management(_management: address):\r\n    \"\"\"\r\n    @notice \r\n        Set the pending management address.\r\n        Needs to be accepted by that account separately to transfer management over\r\n    @param _management New pending management address\r\n    \"\"\"\r\n    assert msg.sender == self.management\r\n    self.pending_management = _management\r\n    log PendingManagement(_management)\r\n\r\n@external\r\ndef accept_management():\r\n    \"\"\"\r\n    @notice \r\n        Accept management role.\r\n        Can only be called by account previously marked as pending management by current management\r\n    \"\"\"\r\n    assert msg.sender == self.pending_management\r\n    self.pending_management = empty(address)\r\n    self.management = msg.sender\r\n    log SetManagement(msg.sender)\r\n\r\n@external\r\ndef sync():\r\n    \"\"\"\r\n    @notice Sync global rewards. Updates rewards streams and integrals\r\n    \"\"\"\r\n    self._sync(staking.totalSupply())\r\n\r\n@internal\r\ndef _sync(_supply: uint256) -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Sync global rewards. Needs to be called before harvest and user sync\r\n    \"\"\"\r\n    current_week: uint256 = block.timestamp / WEEK_LENGTH\r\n    lt_integral: uint256 = 0\r\n    dt_integral: uint256 = 0\r\n    lt_integral, dt_integral = self._unpack(self.packed_integrals)\r\n\r\n    updated: uint256 = 0\r\n    lt_streaming: uint256 = 0\r\n    dt_streaming: uint256 = 0\r\n    updated, lt_streaming, dt_streaming = self._unpack_triplet(self.packed_streaming)\r\n\r\n    if _supply == 0 or updated == block.timestamp:\r\n        # nothing staked or already up-to-date: do nothing\r\n        return lt_integral, dt_integral\r\n\r\n    streaming_week: uint256 = updated / WEEK_LENGTH\r\n    if current_week > streaming_week:\r\n        # new week: unlock all streaming rewards\r\n        updated = current_week * WEEK_LENGTH # beginnning of this week\r\n        lt_integral += lt_streaming * PRECISION / _supply\r\n        dt_integral += dt_streaming * PRECISION / _supply\r\n\r\n        lt_next: uint256 = 0\r\n        dt_next: uint256 = 0\r\n        lt_next, dt_next = self._unpack(self.packed_next)\r\n        self.packed_next = 0\r\n\r\n        if current_week > streaming_week + 1:\r\n            # unlock all next rewards\r\n            lt_streaming = 0\r\n            dt_streaming = 0\r\n            lt_integral += lt_next * PRECISION / _supply\r\n            dt_integral += dt_next * PRECISION / _supply\r\n        else:\r\n            # next rewards start streaming\r\n            lt_streaming = lt_next\r\n            dt_streaming = dt_next\r\n\r\n    # update streams\r\n    remaining: uint256 = (current_week + 1) * WEEK_LENGTH - updated # always <= WEEK_LENGTH\r\n    passed: uint256 = block.timestamp - updated # always <= remaining\r\n    unlocked: uint256 = 0\r\n\r\n    unlocked = lt_streaming * passed / remaining\r\n    lt_integral += unlocked * PRECISION / _supply\r\n    lt_streaming -= unlocked\r\n\r\n    unlocked = dt_streaming * passed / remaining\r\n    dt_integral += unlocked * PRECISION / _supply\r\n    dt_streaming -= unlocked\r\n\r\n    self.packed_streaming = self._pack_triplet(block.timestamp, lt_streaming, dt_streaming)\r\n    self.packed_integrals = self._pack(lt_integral, dt_integral)\r\n    return lt_integral, dt_integral\r\n\r\n@internal\r\ndef _sync_user(_account: address, _balance: uint256, _supply: uint256) -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Sync a user's rewards. Needs to be called before the balance is changed\r\n    \"\"\"\r\n    lt_pending: uint256 = 0\r\n    dt_pending: uint256 = 0\r\n    lt_pending, dt_pending = self._unpack(self.packed_pending_rewards[_account])\r\n\r\n    lt_integral: uint256 = 0\r\n    dt_integral: uint256 = 0\r\n    lt_integral, dt_integral = self._sync(_supply)\r\n    if _balance == 0:\r\n        # no rewards to be distributed, sync integrals only\r\n        self.packed_account_integrals[_account] = self.packed_integrals\r\n        return lt_pending, dt_pending\r\n\r\n    lt_account_integral: uint256 = 0\r\n    dt_account_integral: uint256 = 0\r\n    lt_account_integral, dt_account_integral = self._unpack(self.packed_account_integrals[_account])\r\n\r\n    if lt_account_integral == lt_integral and dt_account_integral == dt_integral:\r\n        return lt_pending, dt_pending\r\n\r\n    lt_pending += (lt_integral - lt_account_integral) * _balance / PRECISION\r\n    dt_pending += (dt_integral - dt_account_integral) * _balance / PRECISION\r\n\r\n    self.packed_account_integrals[_account] = self.packed_integrals\r\n    self.packed_pending_rewards[_account] = self._pack(lt_pending, dt_pending)\r\n    return lt_pending, dt_pending\r\n\r\n@internal\r\n@pure\r\ndef _pack(_a: uint256, _b: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Pack two values into two equally sized parts of a single slot\r\n    \"\"\"\r\n    assert _a <= MASK and _b <= MASK\r\n    return _a | (_b << 128)\r\n\r\n@internal\r\n@pure\r\ndef _unpack(_packed: uint256) -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Unpack two values from two equally sized parts of a single slot\r\n    \"\"\"\r\n    return _packed & MASK, _packed >> 128\r\n\r\n@internal\r\n@pure\r\ndef _pack_triplet(_a: uint256, _b: uint256, _c: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Pack a small value and two big values into a single storage slot\r\n    \"\"\"\r\n    assert _a <= SMALL_MASK and _b <= BIG_MASK and _c <= BIG_MASK\r\n    return (_a << 224) | (_b << 112) | _c\r\n\r\n@internal\r\n@pure\r\ndef _unpack_triplet(_packed: uint256) -> (uint256, uint256, uint256):\r\n    \"\"\"\r\n    @notice Unpack a small value and two big values from a single storage slot\r\n    \"\"\"\r\n    return _packed >> 224, (_packed >> 112) & BIG_MASK, _packed & BIG_MASK", "ABI": "[{\"name\":\"Claim\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":false},{\"name\":\"lt_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"dt_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"fee_idx\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"lt_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"dt_fee\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ClaimFees\",\"inputs\":[{\"name\":\"lt_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"dt_amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Harvest\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"indexed\":false},{\"name\":\"lt_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"dt_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"lt_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"dt_fee\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetRedeemer\",\"inputs\":[{\"name\":\"redeemer\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetTreasury\",\"inputs\":[{\"name\":\"treasury\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetFeeRate\",\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"rate\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PendingManagement\",\"inputs\":[{\"name\":\"management\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetManagement\",\"inputs\":[{\"name\":\"management\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_proxy\",\"type\":\"address\"},{\"name\":\"_staking\",\"type\":\"address\"},{\"name\":\"_locking_token\",\"type\":\"address\"},{\"name\":\"_discount_token\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pending\",\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"claimable\",\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"claim\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"claim\",\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"claim\",\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_redeem_data\",\"type\":\"bytes\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"harvest\",\"inputs\":[{\"name\":\"_lt_amount\",\"type\":\"uint256\"},{\"name\":\"_dt_amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"harvest\",\"inputs\":[{\"name\":\"_lt_amount\",\"type\":\"uint256\"},{\"name\":\"_dt_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"report\",\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_balance\",\"type\":\"uint256\"},{\"name\":\"_supply\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pending_fees\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_fees\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_redeemer\",\"inputs\":[{\"name\":\"_redeemer\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_treasury\",\"inputs\":[{\"name\":\"_treasury\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_fee_rate\",\"inputs\":[{\"name\":\"_idx\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_management\",\"inputs\":[{\"name\":\"_management\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_management\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"sync\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"proxy\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"staking\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"locking_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"discount_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"management\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pending_management\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"redeemer\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"treasury\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee_rates\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"packed_integrals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"packed_streaming\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"packed_next\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"packed_account_integrals\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"packed_pending_rewards\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"packed_pending_fees\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]", "ContractName": "Staking rewards", "CompilerVersion": "vyper:0.3.10", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "000000000000000000000000242521ca01f330f050a65ff5b8ebbe92198ae64f000000000000000000000000cb7dce63abe175ca354dcca9cc10554d255777ee0000000000000000000000000bc529c00c6401aef6d220be8c6ea1667f6ad93e00000000000000000000000041252e8691e964f7de35156b68493bab6797a275", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}