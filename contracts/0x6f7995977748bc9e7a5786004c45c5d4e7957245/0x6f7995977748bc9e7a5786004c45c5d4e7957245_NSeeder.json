{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/NSeeder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title The NToken pseudo-random seed generator\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { ISeeder } from './interfaces/ISeeder.sol';\\nimport { IDescriptorMinimal } from './interfaces/IDescriptorMinimal.sol';\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract NSeeder is ISeeder, Ownable {\\n    /**\\n     * @notice Generate a pseudo-random Punk seed using the previous blockhash and punk ID.\\n     */\\n    // prettier-ignore\\n    uint256 public cTypeProbability;\\n    uint256[] public cSkinProbability;\\n    uint256[] public cAccCountProbability;\\n    uint256 public accTypeCount;\\n    mapping(uint256 => uint256) internal accExclusion; // i: acc index, excluded acc indexes as bitmap\\n\\n    uint256[] internal accCountByType; // accessories count by punk type, acc type, joined with one byte chunks\\n    uint16[][] internal accTypeWeight; // accessory types sum of weight by punk type\\n    uint16[][][] internal accAggWeightByType; // accessory aggregated sum of weight by punk type and acc type\\n\\n    // punk type, acc type, acc order id => accId\\n    mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256))) internal accIdByType;\\n\\n    // Whether the seeder can be updated\\n    bool public areProbabilitiesLocked;\\n\\n    event ProbabilitiesLocked();\\n\\n    modifier whenProbabilitiesNotLocked() {\\n        require(!areProbabilitiesLocked, 'Seeder probabilities are locked');\\n        _;\\n    }\\n\\n    function generateSeed(uint256 punkId, uint256 salt) external view override returns (ISeeder.Seed memory) {\\n        uint256 pseudorandomness = uint256(\\n            keccak256(abi.encodePacked(blockhash(block.number - 1), punkId, salt))\\n        );\\n        return generateSeedFromNumber(pseudorandomness);\\n    }\\n\\n    /**\\n     * @return a seed with sorted accessories\\n     * Public for test purposes.\\n     */\\n    function generateSeedFromNumber(uint256 pseudorandomness) public view returns (ISeeder.Seed memory) {\\n        Seed memory seed;\\n        uint256 tmp;\\n\\n        // Pick up random punk type\\n        uint24 partRandom = uint24(pseudorandomness);\\n        tmp = cTypeProbability;\\n        for (uint256 i = 0; tmp > 0; i ++) {\\n            if (partRandom <= tmp & 0xffffff) {\\n                seed.punkType = uint8(i);\\n                break;\\n            }\\n            tmp >>= 24;\\n        }\\n\\n        // Pick up random skin tone\\n        partRandom = uint24(pseudorandomness >> 24);\\n        tmp = cSkinProbability[seed.punkType];\\n        for (uint256 i = 0; tmp > 0; i ++) {\\n            if (partRandom <= tmp & 0xffffff) {\\n                seed.skinTone = uint8(i);\\n                break;\\n            }\\n            tmp >>= 24;\\n        }\\n\\n        // Pick up random accessory count\\n        partRandom = uint24(pseudorandomness >> 48);\\n        tmp = cAccCountProbability[seed.punkType];\\n        uint256 curAccCount = 0;\\n        for (uint256 i = 0; tmp > 0; i ++) {\\n            if (partRandom <= tmp & 0xffffff) {\\n                curAccCount = uint8(i);\\n                break;\\n            }\\n            tmp >>= 24;\\n        }\\n\\n        // Pick random values for accessories\\n        pseudorandomness >>= 72;\\n        seed.accessories = new Accessory[](curAccCount);\\n        uint16[] memory currAccTypeWeights = accTypeWeight[seed.punkType];\\n        assert(currAccTypeWeights.length == accTypeCount);\\n        uint16[] memory currAggAccTypeWeights = new uint16[](currAccTypeWeights.length);\\n        for (uint256 i = 0; i < curAccCount; i ++) {\\n            // calculate currAggAccTypeWeights\\n            uint16 temp = 0; // need to save variables, solidity stack-to-deep error, temp is acc aggregated weight\\n            for (uint256 j = 0; j < accTypeCount; j ++) {\\n                temp += currAccTypeWeights[j];\\n                currAggAccTypeWeights[j] = temp;\\n            }\\n            // todo temp == 0 check\\n            // random number for acc type selection\\n            temp = uint16((pseudorandomness % temp) + 1); // temp is acc type random\\n            pseudorandomness >>= 16;\\n            // select acc type\\n            uint256 accType = 0;\\n            for (uint256 j = 0; j < accTypeCount; j ++) {\\n                if (temp <= currAggAccTypeWeights[j]) {\\n                    accType = j;\\n                    break;\\n                }\\n            }\\n            // random number for acc id selection\\n            uint16[] memory currAccAggWeight = accAggWeightByType[seed.punkType][accType];\\n            temp = uint16((pseudorandomness % (currAccAggWeight[currAccAggWeight.length - 1])) + 1); // temp is acc id random\\n            pseudorandomness >>= 8;\\n            // select acc accId\\n            uint256 accIdx = 0;\\n            for (uint256 j = 0; j < currAccAggWeight.length; j ++) {\\n                if (temp <= currAccAggWeight[j]) {\\n                    accIdx = j;\\n                    break;\\n                }\\n            }\\n            // set Accessory\\n            seed.accessories[i] = Accessory({\\n                accType: uint16(accType),\\n                accId: uint16(accIdByType[seed.punkType][accType][accIdx])\\n            });\\n            // apply exclusions\\n            uint256 accExclusiveGroup = accExclusion[accType];\\n            for (uint256 j = 0; j < accTypeCount; j ++) {\\n                if ((accExclusiveGroup >> j) & 1 == 1) {\\n                    currAccTypeWeights[j] = 0;\\n                }\\n            }\\n        }\\n\\n        seed.accessories = _sortAccessories(seed.accessories);\\n        return seed;\\n    }\\n\\n    function _sortAccessories(Accessory[] memory accessories) internal pure returns (Accessory[] memory) {\\n        // all operations are safe\\n        unchecked {\\n            uint256[] memory accessoriesMap = new uint256[](16);\\n            for (uint256 i = 0 ; i < accessories.length; i ++) {\\n                // just check\\n                assert(accessoriesMap[accessories[i].accType] == 0);\\n                // 10_000 is a trick so filled entries are not zero\\n                accessoriesMap[accessories[i].accType] = 10_000 + accessories[i].accId;\\n            }\\n\\n            Accessory[] memory sortedAccessories = new Accessory[](accessories.length);\\n            uint256 j = 0;\\n            for (uint256 i = 0 ; i < 16 ; i ++) {\\n                if (accessoriesMap[i] != 0) {\\n                    sortedAccessories[j] = Accessory(uint16(i), uint16(accessoriesMap[i] - 10_000));\\n                    j++;\\n                }\\n            }\\n\\n            return sortedAccessories;\\n        }\\n    }\\n\\n    function setTypeProbability(uint256[] calldata probabilities) external onlyOwner whenProbabilitiesNotLocked {\\n        delete cTypeProbability;\\n        cTypeProbability = _calcProbability(probabilities);\\n    }\\n\\n    function setSkinProbability(uint16 punkType, uint256[] calldata probabilities) external onlyOwner whenProbabilitiesNotLocked {\\n        while (cSkinProbability.length < punkType + 1) {\\n            cSkinProbability.push(0);\\n        }\\n        delete cSkinProbability[punkType];\\n        cSkinProbability[punkType] = _calcProbability(probabilities);\\n    }\\n\\n    function setAccCountProbability(uint16 punkType, uint256[] calldata probabilities) external onlyOwner whenProbabilitiesNotLocked {\\n        while (cAccCountProbability.length < punkType + 1) {\\n            cAccCountProbability.push(0);\\n        }\\n        delete cAccCountProbability[punkType];\\n        cAccCountProbability[punkType] = _calcProbability(probabilities);\\n    }\\n\\n    // group list\\n    // key: group, value: accessory type\\n    function setAccExclusion(uint256[] calldata _accExclusion) external onlyOwner whenProbabilitiesNotLocked {\\n        require(_accExclusion.length == accTypeCount, \\\"NSeeder: A\\\");\\n        for(uint256 i = 0; i < accTypeCount; i ++) {\\n            accExclusion[i] = _accExclusion[i];\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets: accCountByType, accTypeCount, accIdByType.\\n     * According to accIds.\\n     */\\n    function setAccIdByType(uint256[][][] memory accIds, uint256[][][] memory accWeights) external onlyOwner whenProbabilitiesNotLocked {\\n        delete accCountByType;\\n        delete accTypeWeight;\\n        delete accAggWeightByType;\\n        require(accIds.length > 0, \\\"NSeeder: B\\\");\\n        require(accIds.length == accWeights.length, \\\"NSeeder: H\\\");\\n        uint256 count = accIds[0].length; // count of accessory types\\n        require(count < 28, \\\"NSeeder: C\\\"); // beacuse of seedHash calculation\\n        for (uint256 i = 0 ; i < accIds.length ; i ++) {\\n            require(accIds[i].length == count, \\\"NSeeder: D\\\");\\n            require(accWeights[i].length == count, \\\"NSeeder: I\\\");\\n            uint256 accCounts = 0;\\n            uint16[] memory accTypeWeightForPunk = new uint16[](count);\\n            uint16[][] memory accAggWeightByTypeForPunk = new uint16[][](count);\\n            for (uint256 j = 0 ; j < accIds[i].length ; j ++) {\\n                require(accIds[i][j].length < 255, \\\"NSeeder: E\\\"); // 256 - 1, because of seedHash calculation\\n                require(accIds[i][j].length == accWeights[i][j].length, \\\"NSeeder: J\\\");\\n                accCounts |= (1 << (j * 8)) * accIds[i][j].length;\\n                uint16[] memory accAggWeightByTypeForPunkAndType = new uint16[](accWeights[i][j].length);\\n                uint16 currAccAggWeightByTypeForPunkAndType = 0;\\n                for (uint256 k = 0 ; k < accIds[i][j].length ; k ++) {\\n                    require(accWeights[i][j][k] < type(uint16).max, \\\"NSeeder: K\\\");\\n                    require(accWeights[i][j][k] > 0, \\\"NSeeder: L\\\");\\n                    accIdByType[i][j][k] = accIds[i][j][k];\\n                    currAccAggWeightByTypeForPunkAndType += uint16(accWeights[i][j][k]);\\n                    accAggWeightByTypeForPunkAndType[k] = currAccAggWeightByTypeForPunkAndType;\\n                }\\n                accTypeWeightForPunk[j] = currAccAggWeightByTypeForPunkAndType;\\n                accAggWeightByTypeForPunk[j] = accAggWeightByTypeForPunkAndType;\\n            }\\n            accCountByType.push(accCounts);\\n            accTypeWeight.push(accTypeWeightForPunk);\\n            accAggWeightByType.push(accAggWeightByTypeForPunk);\\n        }\\n        accTypeCount = count;\\n    }\\n\\n    function _calcProbability(\\n        uint256[] calldata probabilities\\n    ) internal pure returns (uint256) {\\n        uint256 cumulative = 0;\\n        uint256 probs;\\n        require(probabilities.length > 0, \\\"NSeeder: F\\\");\\n        require(probabilities.length < 11, \\\"NSeeder: G\\\");\\n        for(uint256 i = 0; i < probabilities.length; i ++) {\\n            cumulative += probabilities[i];\\n            probs += (cumulative * 0xffffff / 100000) << (i * 24);\\n        }\\n        require(cumulative == 100000, \\\"Probability must be summed up 100000 ( 100.000% x1000 )\\\");\\n        return probs;\\n    }\\n\\n    /**\\n     * @notice Lock the seeder.\\n     * @dev This cannot be reversed and is only callable by the owner when not locked.\\n     */\\n    function lockProbabilities() external onlyOwner whenProbabilitiesNotLocked {\\n        areProbabilitiesLocked = true;\\n        emit ProbabilitiesLocked();\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISeeder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Interface for NSeeder\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\ninterface ISeeder {\\n    struct Accessory {\\n        uint16 accType;\\n        uint16 accId;\\n    }\\n    struct Seed {\\n        uint8 punkType;\\n        uint8 skinTone;\\n        Accessory[] accessories;\\n    }\\n\\n    function generateSeed(uint256 punkId, uint256 salt) external view returns (Seed memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDescriptorMinimal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Common interface for NDescriptor versions, as used by NToken and NSeeder.\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { ISeeder } from './ISeeder.sol';\\n\\ninterface IDescriptorMinimal {\\n    ///\\n    /// USED BY TOKEN\\n    ///\\n\\n    function tokenURI(uint256 tokenId, ISeeder.Seed memory seed) external view returns (string memory);\\n\\n    function dataURI(uint256 tokenId, ISeeder.Seed memory seed) external view returns (string memory);\\n\\n    ///\\n    /// USED BY SEEDER\\n    ///\\n\\n    function punkTypeCount() external view returns (uint256);\\n    function hatCount() external view returns (uint256);\\n    function helmetCount() external view returns (uint256);\\n    function hairCount() external view returns (uint256);\\n    function beardCount() external view returns (uint256);\\n    function eyesCount() external view returns (uint256);\\n    function glassesCount() external view returns (uint256);\\n    function gogglesCount() external view returns (uint256);\\n    function mouthCount() external view returns (uint256);\\n    function teethCount() external view returns (uint256);\\n    function lipsCount() external view returns (uint256);\\n    function neckCount() external view returns (uint256);\\n    function emotionCount() external view returns (uint256);\\n    function faceCount() external view returns (uint256);\\n    function earsCount() external view returns (uint256);\\n    function noseCount() external view returns (uint256);\\n    function cheeksCount() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ProbabilitiesLocked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accTypeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"areProbabilitiesLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cAccCountProbability\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cSkinProbability\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cTypeProbability\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"punkId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"generateSeed\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"punkType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"skinTone\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"accType\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"accId\",\"type\":\"uint16\"}],\"internalType\":\"struct ISeeder.Accessory[]\",\"name\":\"accessories\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISeeder.Seed\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pseudorandomness\",\"type\":\"uint256\"}],\"name\":\"generateSeedFromNumber\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"punkType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"skinTone\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"accType\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"accId\",\"type\":\"uint16\"}],\"internalType\":\"struct ISeeder.Accessory[]\",\"name\":\"accessories\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISeeder.Seed\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockProbabilities\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"punkType\",\"type\":\"uint16\"},{\"internalType\":\"uint256[]\",\"name\":\"probabilities\",\"type\":\"uint256[]\"}],\"name\":\"setAccCountProbability\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_accExclusion\",\"type\":\"uint256[]\"}],\"name\":\"setAccExclusion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[][][]\",\"name\":\"accIds\",\"type\":\"uint256[][][]\"},{\"internalType\":\"uint256[][][]\",\"name\":\"accWeights\",\"type\":\"uint256[][][]\"}],\"name\":\"setAccIdByType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"punkType\",\"type\":\"uint16\"},{\"internalType\":\"uint256[]\",\"name\":\"probabilities\",\"type\":\"uint256[]\"}],\"name\":\"setSkinProbability\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"probabilities\",\"type\":\"uint256[]\"}],\"name\":\"setTypeProbability\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NSeeder", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}