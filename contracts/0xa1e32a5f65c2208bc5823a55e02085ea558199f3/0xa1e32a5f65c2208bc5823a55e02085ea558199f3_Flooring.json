{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {UpgradeableBeacon} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IBeacon} from \\\"../beacon/IBeacon.sol\\\";\\nimport {Address} from \\\"../../utils/Address.sol\\\";\\nimport {StorageSlot} from \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n */\\nlibrary ERC1967Utils {\\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev The `implementation` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidImplementation(address implementation);\\n\\n    /**\\n     * @dev The `admin` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidAdmin(address admin);\\n\\n    /**\\n     * @dev The `beacon` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidBeacon(address beacon);\\n\\n    /**\\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\\n     */\\n    error ERC1967NonPayable();\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        if (newImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(newImplementation);\\n        }\\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        if (newAdmin == address(0)) {\\n            revert ERC1967InvalidAdmin(address(0));\\n        }\\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {IERC1967-AdminChanged} event.\\n     */\\n    function changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.beacon\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        if (newBeacon.code.length == 0) {\\n            revert ERC1967InvalidBeacon(newBeacon);\\n        }\\n\\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\\n\\n        address beaconImplementation = IBeacon(newBeacon).implementation();\\n        if (beaconImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(beaconImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-BeaconUpgraded} event.\\n     *\\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\\n     * efficiency.\\n     */\\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\\n     * if an upgrade doesn't perform an initialization call.\\n     */\\n    function _checkNonPayable() private {\\n        if (msg.value > 0) {\\n            revert ERC1967NonPayable();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length > 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"chainlink/v0.8/interfaces/VRFCoordinatorV2Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFCoordinatorV2Interface {\\n  /**\\n   * @notice Get configuration relevant for making requests\\n   * @return minimumRequestConfirmations global min for request confirmations\\n   * @return maxGasLimit global max for request gas limit\\n   * @return s_provingKeyHashes list of registered key hashes\\n   */\\n  function getRequestConfig() external view returns (uint16, uint32, bytes32[] memory);\\n\\n  /**\\n   * @notice Request a set of random words.\\n   * @param keyHash - Corresponds to a particular oracle job which uses\\n   * that key for generating the VRF proof. Different keyHash's have different gas price\\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\\n   * @param subId  - The ID of the VRF subscription. Must be funded\\n   * with the minimum subscription balance required for the selected keyHash.\\n   * @param minimumRequestConfirmations - How many blocks you'd like the\\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\n   * for why you may want to request more. The acceptable range is\\n   * [minimumRequestBlockConfirmations, 200].\\n   * @param callbackGasLimit - How much gas you'd like to receive in your\\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n   * may be slightly less than this amount because of gas used calling the function\\n   * (argument decoding etc.), so you may need to request slightly more than you expect\\n   * to have inside fulfillRandomWords. The acceptable range is\\n   * [0, maxGasLimit]\\n   * @param numWords - The number of uint256 random values you'd like to receive\\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n   * @return requestId - A unique identifier of the request. Can be used to match\\n   * a request to a response in fulfillRandomWords.\\n   */\\n  function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256 requestId);\\n\\n  /**\\n   * @notice Create a VRF subscription.\\n   * @return subId - A unique subscription id.\\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n   * @dev Note to fund the subscription, use transferAndCall. For example\\n   * @dev  LINKTOKEN.transferAndCall(\\n   * @dev    address(COORDINATOR),\\n   * @dev    amount,\\n   * @dev    abi.encode(subId));\\n   */\\n  function createSubscription() external returns (uint64 subId);\\n\\n  /**\\n   * @notice Get a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @return balance - LINK balance of the subscription in juels.\\n   * @return reqCount - number of requests for this subscription, determines fee tier.\\n   * @return owner - owner of the subscription.\\n   * @return consumers - list of consumer address which are able to use this subscription.\\n   */\\n  function getSubscription(\\n    uint64 subId\\n  ) external view returns (uint96 balance, uint64 reqCount, address owner, address[] memory consumers);\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @param newOwner - proposed new owner of the subscription\\n   */\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @dev will revert if original owner of subId has\\n   * not requested that msg.sender become the new owner.\\n   */\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\n\\n  /**\\n   * @notice Add a consumer to a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - New consumer which can use the subscription\\n   */\\n  function addConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Remove a consumer from a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - Consumer to remove from the subscription\\n   */\\n  function removeConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Cancel a subscription\\n   * @param subId - ID of the subscription\\n   * @param to - Where to send the remaining LINK to\\n   */\\n  function cancelSubscription(uint64 subId, address to) external;\\n\\n  /*\\n   * @notice Check to see if there exists a request commitment consumers\\n   * for all consumers and keyhashes for a given sub.\\n   * @param subId - ID of the subscription\\n   * @return true if there exists at least one unfulfilled request for the subscription, false\\n   * otherwise.\\n   */\\n  function pendingRequestExists(uint64 subId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"chainlink/v0.8/VRFConsumerBaseV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\\n * @dev 1. The fulfillment came from the VRFCoordinator\\n * @dev 2. The consumer contract implements fulfillRandomWords.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash). Create subscription, fund it\\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\\n * @dev subscription management functions).\\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\\n * @dev callbackGasLimit, numWords),\\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomWords method.\\n *\\n * @dev The randomness argument to fulfillRandomWords is a set of random words\\n * @dev generated from your requestId and the blockHash of the request.\\n *\\n * @dev If your contract could have concurrent requests open, you can use the\\n * @dev requestId returned from requestRandomWords to track which response is associated\\n * @dev with which randomness request.\\n * @dev See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ.\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request. It is for this reason that\\n * @dev that you can signal to an oracle you'd like them to wait longer before\\n * @dev responding to the request (however this is not enforced in the contract\\n * @dev and so remains effective only in the case of unmodified oracle software).\\n */\\nabstract contract VRFConsumerBaseV2 {\\n  error OnlyCoordinatorCanFulfill(address have, address want);\\n  address private immutable vrfCoordinator;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   */\\n  constructor(address _vrfCoordinator) {\\n    vrfCoordinator = _vrfCoordinator;\\n  }\\n\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomWords the VRF output expanded to the requested number of words\\n   */\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\\n    if (msg.sender != vrfCoordinator) {\\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\\n    }\\n    fulfillRandomWords(requestId, randomWords);\\n  }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        // Cache values to avoid duplicated sloads\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n\\n        // Allowed calls:\\n        // - initialSetup: the contract is not in the initializing state and no previous version was\\n        //                 initialized\\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n        //                 current contract is just being deployed\\n        bool initialSetup = initialized == 0 && isTopLevelCall;\\n        bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n        if (!initialSetup && !construction) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert InvalidInitialization();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        assembly {\\n            $.slot := INITIALIZABLE_STORAGE\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC1822Proxiable} from \\\"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\\\";\\nimport {ERC1967Utils} from \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\\\";\\nimport {Initializable} from \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\\n     * If the getter returns `\\\"5.0.0\\\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\\n     * during an upgrade.\\n     */\\n    string public constant UPGRADE_INTERFACE_VERSION = \\\"5.0.0\\\";\\n\\n    /**\\n     * @dev The call is from an unauthorized context.\\n     */\\n    error UUPSUnauthorizedCallContext();\\n\\n    /**\\n     * @dev The storage `slot` is unsupported as a UUID.\\n     */\\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        _checkProxy();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        _checkNotDelegated();\\n        _;\\n    }\\n\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data);\\n    }\\n\\n    /**\\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\\n     * See {_onlyProxy}.\\n     */\\n    function _checkProxy() internal view virtual {\\n        if (\\n            address(this) == __self || // Must be called through delegatecall\\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\\n        ) {\\n            revert UUPSUnauthorizedCallContext();\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts if the execution is performed via delegatecall.\\n     * See {notDelegated}.\\n     */\\n    function _checkNotDelegated() internal view virtual {\\n        if (address(this) != __self) {\\n            // Must not be called through delegatecall\\n            revert UUPSUnauthorizedCallContext();\\n        }\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\\n     *\\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\\n     * is expected to be the implementation slot in ERC1967.\\n     *\\n     * Emits an {IERC1967-Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\\n                revert UUPSUnsupportedProxiableUUID(slot);\\n            }\\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\\n        } catch {\\n            // The implementation is not UUPS\\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\\n     * reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-contracts/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\\n\\n    /**\\n     * @dev An int value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedIntToUint(int256 value);\\n\\n    /**\\n     * @dev Value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\\n\\n    /**\\n     * @dev An uint value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedUintToInt(uint256 value);\\n\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        if (value > type(uint248).max) {\\n            revert SafeCastOverflowedUintDowncast(248, value);\\n        }\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        if (value > type(uint240).max) {\\n            revert SafeCastOverflowedUintDowncast(240, value);\\n        }\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        if (value > type(uint232).max) {\\n            revert SafeCastOverflowedUintDowncast(232, value);\\n        }\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        if (value > type(uint224).max) {\\n            revert SafeCastOverflowedUintDowncast(224, value);\\n        }\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        if (value > type(uint216).max) {\\n            revert SafeCastOverflowedUintDowncast(216, value);\\n        }\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        if (value > type(uint208).max) {\\n            revert SafeCastOverflowedUintDowncast(208, value);\\n        }\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        if (value > type(uint200).max) {\\n            revert SafeCastOverflowedUintDowncast(200, value);\\n        }\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        if (value > type(uint192).max) {\\n            revert SafeCastOverflowedUintDowncast(192, value);\\n        }\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        if (value > type(uint184).max) {\\n            revert SafeCastOverflowedUintDowncast(184, value);\\n        }\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        if (value > type(uint176).max) {\\n            revert SafeCastOverflowedUintDowncast(176, value);\\n        }\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        if (value > type(uint168).max) {\\n            revert SafeCastOverflowedUintDowncast(168, value);\\n        }\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        if (value > type(uint160).max) {\\n            revert SafeCastOverflowedUintDowncast(160, value);\\n        }\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        if (value > type(uint152).max) {\\n            revert SafeCastOverflowedUintDowncast(152, value);\\n        }\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        if (value > type(uint144).max) {\\n            revert SafeCastOverflowedUintDowncast(144, value);\\n        }\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        if (value > type(uint136).max) {\\n            revert SafeCastOverflowedUintDowncast(136, value);\\n        }\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        if (value > type(uint128).max) {\\n            revert SafeCastOverflowedUintDowncast(128, value);\\n        }\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        if (value > type(uint120).max) {\\n            revert SafeCastOverflowedUintDowncast(120, value);\\n        }\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        if (value > type(uint112).max) {\\n            revert SafeCastOverflowedUintDowncast(112, value);\\n        }\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        if (value > type(uint104).max) {\\n            revert SafeCastOverflowedUintDowncast(104, value);\\n        }\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        if (value > type(uint96).max) {\\n            revert SafeCastOverflowedUintDowncast(96, value);\\n        }\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        if (value > type(uint88).max) {\\n            revert SafeCastOverflowedUintDowncast(88, value);\\n        }\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        if (value > type(uint80).max) {\\n            revert SafeCastOverflowedUintDowncast(80, value);\\n        }\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        if (value > type(uint72).max) {\\n            revert SafeCastOverflowedUintDowncast(72, value);\\n        }\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        if (value > type(uint64).max) {\\n            revert SafeCastOverflowedUintDowncast(64, value);\\n        }\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        if (value > type(uint56).max) {\\n            revert SafeCastOverflowedUintDowncast(56, value);\\n        }\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        if (value > type(uint48).max) {\\n            revert SafeCastOverflowedUintDowncast(48, value);\\n        }\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        if (value > type(uint40).max) {\\n            revert SafeCastOverflowedUintDowncast(40, value);\\n        }\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        if (value > type(uint32).max) {\\n            revert SafeCastOverflowedUintDowncast(32, value);\\n        }\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        if (value > type(uint24).max) {\\n            revert SafeCastOverflowedUintDowncast(24, value);\\n        }\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        if (value > type(uint16).max) {\\n            revert SafeCastOverflowedUintDowncast(16, value);\\n        }\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        if (value > type(uint8).max) {\\n            revert SafeCastOverflowedUintDowncast(8, value);\\n        }\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        if (value < 0) {\\n            revert SafeCastOverflowedIntToUint(value);\\n        }\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(248, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(240, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(232, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(224, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(216, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(208, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(200, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(192, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(184, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(176, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(168, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(160, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(152, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(144, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(136, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(128, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(120, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(112, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(104, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(96, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(88, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(80, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(72, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(64, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(56, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(48, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(40, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(32, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(24, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(16, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(8, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        if (value > uint256(type(int256).max)) {\\n            revert SafeCastOverflowedUintToInt(value);\\n        }\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nlibrary Constants {\\n    /// @notice Flooring protocol\\n    /// @dev floor token amount of 1 NFT (with 18 decimals)\\n    uint256 public constant FLOOR_TOKEN_AMOUNT = 1_000_000 ether;\\n    /// @dev The minimum vip level required to use `proxy collection`\\n    uint8 public constant PROXY_COLLECTION_VIP_THRESHOLD = 3;\\n\\n    /// @notice Rolling Bucket Constant Conf\\n    uint256 public constant BUCKET_SPAN_1 = 259199 seconds; // BUCKET_SPAN minus 1, used for rounding up\\n    uint256 public constant BUCKET_SPAN = 3 days;\\n    uint256 public constant MAX_LOCKING_BUCKET = 240;\\n    uint256 public constant MAX_LOCKING_PERIOD = 720 days; // MAX LOCKING BUCKET * BUCKET_SPAN\\n\\n    /// @notice Auction Config\\n    uint256 public constant FREE_AUCTION_PERIOD = 24 hours;\\n    uint256 public constant AUCTION_INITIAL_PERIODS = 24 hours;\\n    uint256 public constant AUCTION_COMPLETE_GRACE_PERIODS = 2 days;\\n    /// @dev minimum bid per NFT when someone starts aution on expired safebox\\n    uint256 public constant AUCTION_ON_EXPIRED_MINIMUM_BID = 100 ether;\\n    /// @dev admin fee charged per NFT when someone starts aution on expired safebox\\n    uint256 public constant AUCTION_ON_EXPIRED_SAFEBOX_COST = 100 ether;\\n    /// @dev admin fee charged per NFT when owner starts aution on himself safebox\\n    uint256 public constant AUCTION_COST = 100 ether;\\n\\n    /// @notice Raffle Config\\n    uint256 public constant RAFFLE_COST = 500 ether;\\n    uint256 public constant RAFFLE_COMPLETE_GRACE_PERIODS = 2 days;\\n\\n    /// @notice Private offer Config\\n    uint256 public constant PRIVATE_OFFER_DURATION = 24 hours;\\n    uint256 public constant PRIVATE_OFFER_COMPLETE_GRACE_DURATION = 2 days;\\n    uint256 public constant PRIVATE_OFFER_COST = 0;\\n\\n    uint256 public constant ADD_FREE_NFT_REWARD = 0;\\n\\n    /// @notice Lock/Unlock config\\n    uint256 public constant LOCKING_PCT_TO_SAFEBOX_MAINT_MIN = 1200 ether;\\n    uint256 public constant LOCKING_PCT_TO_SAFEBOX_MAINT_MAX = 345600 ether;\\n\\n    /// @notice Activities Fee Rate\\n\\n    /// @notice Fee rate used to distribute funds that collected from Auctions on expired safeboxes.\\n    /// these auction would be settled using credit token\\n    uint256 public constant FREE_AUCTION_FEE_RATE_BIPS = 2000; // 20%\\n    /// @notice Fee rate settled with credit token\\n    uint256 public constant CREDIT_FEE_RATE_BIPS = 150; // 2%\\n    /// @notice Fee rate settled with specified token\\n    uint256 public constant SPEC_FEE_RATE_BIPS = 300; // 3%\\n    /// @notice Fee rate settled with all other tokens\\n    uint256 public constant COMMON_FEE_RATE_BIPS = 500; // 5%\\n\\n    uint256 public constant VIP_LEVEL_COUNT = 8;\\n\\n    struct AuctionBidOption {\\n        uint256 extendDurationSecs;\\n        uint256 minimumRaisePct;\\n        uint256 vipLevel;\\n    }\\n\\n    function getVipLockingBuckets(uint256 vipLevel) internal pure returns (uint256 buckets) {\\n        require(vipLevel < VIP_LEVEL_COUNT);\\n        assembly {\\n            switch vipLevel\\n            case 1 { buckets := 1 }\\n            case 2 { buckets := 5 }\\n            case 3 { buckets := 20 }\\n            case 4 { buckets := 60 }\\n            case 5 { buckets := 120 }\\n            case 6 { buckets := 180 }\\n            case 7 { buckets := MAX_LOCKING_BUCKET }\\n        }\\n    }\\n\\n    function getVipLevel(uint256 totalCredit) internal pure returns (uint8) {\\n        if (totalCredit < 30_000 ether) {\\n            return 0;\\n        } else if (totalCredit < 100_000 ether) {\\n            return 1;\\n        } else if (totalCredit < 300_000 ether) {\\n            return 2;\\n        } else if (totalCredit < 1_000_000 ether) {\\n            return 3;\\n        } else if (totalCredit < 3_000_000 ether) {\\n            return 4;\\n        } else if (totalCredit < 10_000_000 ether) {\\n            return 5;\\n        } else if (totalCredit < 30_000_000 ether) {\\n            return 6;\\n        } else {\\n            return 7;\\n        }\\n    }\\n\\n    function getVipBalanceRequirements(uint256 vipLevel) internal pure returns (uint256 required) {\\n        require(vipLevel < VIP_LEVEL_COUNT);\\n\\n        assembly {\\n            switch vipLevel\\n            case 1 { required := 30000 }\\n            case 2 { required := 100000 }\\n            case 3 { required := 300000 }\\n            case 4 { required := 1000000 }\\n            case 5 { required := 3000000 }\\n            case 6 { required := 10000000 }\\n            case 7 { required := 30000000 }\\n        }\\n\\n        /// credit token should be scaled with 18 decimals(1 ether == 10**18)\\n        unchecked {\\n            return required * 1 ether;\\n        }\\n    }\\n\\n    function getBidOption(uint256 idx) internal pure returns (AuctionBidOption memory) {\\n        require(idx < 4);\\n        AuctionBidOption[4] memory bidOptions = [\\n            AuctionBidOption({extendDurationSecs: 5 minutes, minimumRaisePct: 1, vipLevel: 0}),\\n            AuctionBidOption({extendDurationSecs: 8 hours, minimumRaisePct: 10, vipLevel: 3}),\\n            AuctionBidOption({extendDurationSecs: 16 hours, minimumRaisePct: 20, vipLevel: 5}),\\n            AuctionBidOption({extendDurationSecs: 24 hours, minimumRaisePct: 40, vipLevel: 7})\\n        ];\\n        return bidOptions[idx];\\n    }\\n\\n    function raffleDurations(uint256 idx) internal pure returns (uint256 vipLevel, uint256 duration) {\\n        require(idx < 6);\\n\\n        vipLevel = idx;\\n        assembly {\\n            switch idx\\n            case 1 { duration := 1 }\\n            case 2 { duration := 2 }\\n            case 3 { duration := 3 }\\n            case 4 { duration := 5 }\\n            case 5 { duration := 7 }\\n        }\\n        unchecked {\\n            duration *= 1 days;\\n        }\\n    }\\n\\n    /// return locking ratio restrictions indicates that the vipLevel can utility infinite lock NFTs at corresponding ratio\\n    function getLockingRatioForInfinite(uint8 vipLevel) internal pure returns (uint256 ratio) {\\n        assembly {\\n            switch vipLevel\\n            case 1 { ratio := 0 }\\n            case 2 { ratio := 0 }\\n            case 3 { ratio := 20 }\\n            case 4 { ratio := 30 }\\n            case 5 { ratio := 40 }\\n            case 6 { ratio := 50 }\\n            case 7 { ratio := 80 }\\n        }\\n    }\\n\\n    function getVipRequiredStakingWithDiscount(uint256 requiredStaking, uint8 vipLevel)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (vipLevel < 3) {\\n            return requiredStaking;\\n        }\\n        unchecked {\\n            /// the higher vip level, more discount for staking\\n            ///  discount range: 10% - 50%\\n            return requiredStaking * (100 - (vipLevel - 2) * 10) / 100;\\n        }\\n    }\\n\\n    function getRequiredStakingForLockRatio(uint256 locked, uint256 totalManaged) internal pure returns (uint256) {\\n        if (totalManaged <= 0) {\\n            return 1200 ether;\\n        }\\n\\n        unchecked {\\n            uint256 lockingRatioPct = locked * 100 / totalManaged;\\n            if (lockingRatioPct <= 40) {\\n                return 1200 ether;\\n            } else if (lockingRatioPct < 60) {\\n                return 1320 ether + ((lockingRatioPct - 40) >> 1) * 120 ether;\\n            } else if (lockingRatioPct < 70) {\\n                return 2640 ether + ((lockingRatioPct - 60) >> 1) * 240 ether;\\n            } else if (lockingRatioPct < 80) {\\n                return 4080 ether + ((lockingRatioPct - 70) >> 1) * 480 ether;\\n            } else if (lockingRatioPct < 90) {\\n                return 6960 ether + ((lockingRatioPct - 80) >> 1) * 960 ether;\\n            } else if (lockingRatioPct < 100) {\\n                /// 108000 * 2^x\\n                return (108000 ether << ((lockingRatioPct - 90) >> 1)) / 5;\\n            } else {\\n                return 345600 ether;\\n            }\\n        }\\n    }\\n\\n    function getVipClaimCostWithDiscount(uint256 cost, uint8 vipLevel) internal pure returns (uint256) {\\n        if (vipLevel < 3) {\\n            return cost;\\n        }\\n\\n        unchecked {\\n            uint256 discount = 4000 ether << (vipLevel - 3);\\n            if (cost < discount) {\\n                return 0;\\n            } else {\\n                return cost - discount;\\n            }\\n        }\\n    }\\n\\n    function getClaimExpiredCost(uint256 free, uint256 totalManaged, uint8 vipLevel) internal pure returns (uint256) {\\n        uint256 realCost = getClaimCost(free, totalManaged);\\n        return getVipClaimCostWithDiscount(realCost, vipLevel);\\n    }\\n\\n    function getClaimRandomCost(uint256 free, uint256 totalManaged, uint8 vipLevel) internal pure returns (uint256) {\\n        uint256 realCost = getClaimCost(free, totalManaged);\\n        return getVipClaimCostWithDiscount(realCost, vipLevel);\\n    }\\n\\n    function getClaimCost(uint256 free, uint256 totalManaged) private pure returns (uint256) {\\n        if (totalManaged <= 0) {\\n            return 0;\\n        }\\n\\n        unchecked {\\n            uint256 lockingRatioPct = 100 - free * 100 / totalManaged;\\n\\n            if (lockingRatioPct <= 60) {\\n                return 0;\\n            } else if (lockingRatioPct < 100) {\\n                uint256 cost = 1 ether;\\n                assembly {\\n                    switch shr(1, sub(lockingRatioPct, 60))\\n                    case 0 { cost := mul(cost, 400) }\\n                    case 1 { cost := mul(cost, 600) }\\n                    case 2 { cost := mul(cost, 800) }\\n                    case 3 { cost := mul(cost, 1200) }\\n                    case 4 { cost := mul(cost, 1600) }\\n                    case 5 { cost := mul(cost, 2400) }\\n                    case 6 { cost := mul(cost, 3200) }\\n                    case 7 { cost := mul(cost, 4800) }\\n                    case 8 { cost := mul(cost, 6400) }\\n                    case 9 { cost := mul(cost, 9600) }\\n                    case 10 { cost := mul(cost, 12800) }\\n                    case 11 { cost := mul(cost, 19200) }\\n                    case 12 { cost := mul(cost, 25600) }\\n                    case 13 { cost := mul(cost, 38400) }\\n                    case 14 { cost := mul(cost, 51200) }\\n                    case 15 { cost := mul(cost, 76800) }\\n                    case 16 { cost := mul(cost, 102400) }\\n                    case 17 { cost := mul(cost, 153600) }\\n                    case 18 { cost := mul(cost, 204800) }\\n                    case 19 { cost := mul(cost, 307200) }\\n                }\\n                return cost;\\n            } else {\\n                return 307200 ether;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nlibrary Errors {\\n    /// @notice Safe Box error\\n    error SafeBoxHasExpire();\\n    error SafeBoxNotExist();\\n    error SafeBoxHasNotExpire();\\n    error SafeBoxAlreadyExist();\\n    error NoMatchingSafeBoxKey();\\n    error SafeBoxKeyAlreadyExist();\\n\\n    /// @notice Auction error\\n    error AuctionHasNotCompleted();\\n    error AuctionHasExpire();\\n    error AuctionBidIsNotHighEnough();\\n    error AuctionBidTokenMismatch();\\n    error AuctionSelfBid();\\n    error AuctionInvalidBidAmount();\\n    error AuctionNotExist();\\n    error SafeBoxAuctionWindowHasPassed();\\n\\n    /// @notice Activity common error\\n    error NftHasActiveActivities();\\n    error ActivityHasNotCompleted();\\n    error ActivityHasExpired();\\n    error ActivityNotExist();\\n\\n    /// @notice User account error\\n    error InsufficientCredit();\\n    error InsufficientBalanceForVipLevel();\\n    error NoPrivilege();\\n\\n    /// @notice Parameter error\\n    error InvalidParam();\\n    error NftCollectionNotSupported();\\n    error NftCollectionAlreadySupported();\\n    error ClaimableNftInsufficient();\\n    error TokenNotSupported();\\n}\\n\"\r\n    },\r\n    \"src/Flooring.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport {UUPSUpgradeable} from \\\"openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\\\";\\nimport \\\"chainlink/v0.8/interfaces/VRFCoordinatorV2Interface.sol\\\";\\nimport \\\"chainlink/v0.8/VRFConsumerBaseV2.sol\\\";\\n\\nimport \\\"./interface/IFlooring.sol\\\";\\nimport \\\"./interface/IFlooringEvent.sol\\\";\\nimport \\\"./interface/IFragmentToken.sol\\\";\\n\\nimport \\\"./logic/User.sol\\\";\\nimport \\\"./logic/Collection.sol\\\";\\nimport \\\"./logic/Auction.sol\\\";\\nimport \\\"./logic/Raffle.sol\\\";\\nimport \\\"./logic/PrivateOffer.sol\\\";\\nimport {CollectionState, SafeBox, AuctionInfo, RaffleInfo, PrivateOffer, UserFloorAccount} from \\\"./logic/Structs.sol\\\";\\nimport \\\"./Multicall.sol\\\";\\nimport \\\"./Errors.sol\\\";\\nimport \\\"./library/CurrencyTransfer.sol\\\";\\nimport {TrustedUpgradeable} from \\\"./library/TrustedUpgradeable.sol\\\";\\n\\ncontract Flooring is IFlooring, IFlooringEvent, Multicall, TrustedUpgradeable, UUPSUpgradeable, VRFConsumerBaseV2 {\\n    using CollectionLib for CollectionState;\\n    using AuctionLib for CollectionState;\\n    using RaffleLib for CollectionState;\\n    using PrivateOfferLib for CollectionState;\\n    using UserLib for UserFloorAccount;\\n\\n    struct RandomRequestInfo {\\n        uint96 typ;\\n        address collection;\\n        bytes data;\\n    }\\n\\n    /// Information related to Chainlink VRF Randomness Oracle.\\n\\n    /// The keyhash, which is network dependent.\\n    bytes32 internal immutable keyHash;\\n    /// Subscription Id, need to get from the Chainlink UI.\\n    uint64 internal immutable subId;\\n    /// Chainlink VRF Coordinator.\\n    VRFCoordinatorV2Interface internal immutable COORDINATOR;\\n\\n    /// A mapping from VRF request Id to raffle.\\n    mapping(uint256 => RandomRequestInfo) internal randomnessRequestToReceiver;\\n\\n    /// This should be the FLC token.\\n    address public immutable creditToken;\\n\\n    /// A mapping from collection address to `CollectionState`.\\n    mapping(address => CollectionState) internal collectionStates;\\n\\n    /// A mapping from user address to the `UserFloorAccount`s.\\n    mapping(address => UserFloorAccount) internal userFloorAccounts;\\n\\n    /// A mapping of supported ERC-20 token.\\n    mapping(address => bool) internal supportedTokens;\\n\\n    /// A mapping from Proxy Collection(wrapped) to underlying Collection.\\n    /// eg. Paraspace Derivative Token BAYC(nBAYC) -> BAYC\\n    /// Note. we only use proxy collection to transfer NFTs,\\n    ///       all other operations should use underlying Collection.(State, Log, CollectionAccount)\\n    ///       proxy collection has not `CollectionState`, but use underlying collection's state.\\n    ///       `fragmentNFTs` and `claimRandomNFT` don't support proxy collection\\n    mapping(address => address) internal collectionProxy;\\n\\n    constructor(bytes32 _keyHash, uint64 _subId, address _vrfCoordinator, address flcToken)\\n        payable\\n        VRFConsumerBaseV2(_vrfCoordinator)\\n    {\\n        keyHash = _keyHash;\\n        subId = _subId;\\n        COORDINATOR = VRFCoordinatorV2Interface(_vrfCoordinator);\\n        creditToken = flcToken;\\n\\n        _disableInitializers();\\n    }\\n\\n    /// required by the OZ UUPS module\\n    function _authorizeUpgrade(address) internal override onlyOwner {}\\n\\n    /// @dev just declare this as payable to reduce gas and bytecode\\n    function initialize() public payable initializer {\\n        __Trusted_init();\\n        __UUPSUpgradeable_init();\\n    }\\n\\n    function supportNewCollection(address _originalNFT, address fragmentToken) public onlyTrusted {\\n        CollectionState storage collection = collectionStates[_originalNFT];\\n        if (collection.nextKeyId > 0) revert Errors.NftCollectionAlreadySupported();\\n\\n        collection.nextKeyId = 1;\\n        collection.nextActivityId = 1;\\n        collection.floorToken = IFragmentToken(fragmentToken);\\n\\n        emit NewCollectionSupported(_originalNFT, fragmentToken);\\n    }\\n\\n    function supportNewToken(address _token, bool addOrRemove) public onlyTrusted {\\n        if (supportedTokens[_token] == addOrRemove) {\\n            return;\\n        } else {\\n            /// true - add\\n            /// false - remove\\n            supportedTokens[_token] = addOrRemove;\\n            emit UpdateTokenSupported(_token, addOrRemove);\\n        }\\n    }\\n\\n    function setCollectionProxy(address proxyCollection, address underlying) public onlyTrusted {\\n        if (collectionProxy[proxyCollection] == underlying) {\\n            return;\\n        } else {\\n            collectionProxy[proxyCollection] = underlying;\\n            emit ProxyCollectionChanged(proxyCollection, underlying);\\n        }\\n    }\\n\\n    function withdrawPlatformFee(address token, uint256 amount) public onlyTrusted {\\n        /// track platform fee with account, only can withdraw fee accumulated during tx.\\n        /// no need to check credit token balance for the account.\\n        userFloorAccounts[address(this)].withdrawToken(token, amount, false);\\n        CurrencyTransfer.safeTransfer(token, msg.sender, amount);\\n    }\\n\\n    function addAndLockCredit(address receiver, uint256 amount) public onlyTrusted {\\n        UserFloorAccount storage userFloorAccount = userFloorAccounts[receiver];\\n        userFloorAccount.depositToken(creditToken, amount);\\n        userFloorAccount.lockCredit(amount);\\n        CurrencyTransfer.safeTransferFrom(creditToken, msg.sender, address(this), amount);\\n\\n        emit DepositToken(msg.sender, receiver, creditToken, amount);\\n    }\\n\\n    function unlockCredit(address receiver, uint256 amount) public onlyTrusted {\\n        UserFloorAccount storage userFloorAccount = userFloorAccounts[receiver];\\n        userFloorAccount.unlockCredit(amount);\\n    }\\n\\n    function addTokens(address onBehalfOf, address token, uint256 amount) public payable {\\n        mustSupportedToken(token);\\n\\n        UserFloorAccount storage userFloorAccount = userFloorAccounts[onBehalfOf];\\n        userFloorAccount.depositToken(token, amount);\\n\\n        if (token == CurrencyTransfer.NATIVE) {\\n            require(amount == msg.value);\\n        } else {\\n            CurrencyTransfer.safeTransferFrom(token, msg.sender, address(this), amount);\\n        }\\n        emit DepositToken(msg.sender, onBehalfOf, token, amount);\\n    }\\n\\n    function removeTokens(address token, uint256 amount, address receiver) public {\\n        UserFloorAccount storage userFloorAccount = userFloorAccounts[msg.sender];\\n        userFloorAccount.withdrawToken(token, amount, token == creditToken);\\n        CurrencyTransfer.safeTransfer(token, receiver, amount);\\n        emit WithdrawToken(msg.sender, receiver, token, amount);\\n    }\\n\\n    function extMulticall(CallData[] calldata calls)\\n        external\\n        override(Multicall, IMulticall)\\n        onlyTrusted\\n        returns (bytes[] memory)\\n    {\\n        return multicall2(calls);\\n    }\\n\\n    function lockNFTs(\\n        address collection,\\n        uint256[] memory nftIds,\\n        uint256 expiryTs,\\n        uint256 vipLevel,\\n        uint256 maxCreditCost,\\n        address onBehalfOf\\n    ) public returns (uint256) {\\n        mustValidNftIds(nftIds);\\n        mustValidExpiryTs(expiryTs);\\n\\n        (CollectionState storage collectionState, address underlying) = useUnderlyingCollectionState(collection);\\n        return collectionState.lockNfts(\\n            userFloorAccounts[onBehalfOf],\\n            LockParam({\\n                proxyCollection: collection,\\n                collection: underlying,\\n                creditToken: creditToken,\\n                nftIds: nftIds,\\n                expiryTs: expiryTs,\\n                vipLevel: vipLevel,\\n                maxCreditCost: maxCreditCost\\n            }),\\n            onBehalfOf\\n        );\\n    }\\n\\n    function unlockNFTs(address collection, uint256 expiryTs, uint256[] memory nftIds, address receiver) public {\\n        mustValidNftIds(nftIds);\\n\\n        (CollectionState storage collectionState, address underlying) = useUnderlyingCollectionState(collection);\\n        collectionState.unlockNfts(userFloorAccounts[msg.sender], collection, underlying, nftIds, expiryTs, receiver);\\n    }\\n\\n    function claimExpiredNfts(address collection, uint256[] memory nftIds, uint256 maxCreditCost, address receiver)\\n        public\\n        returns (uint256)\\n    {\\n        mustValidNftIds(nftIds);\\n        (CollectionState storage collectionState, address underlying) = useUnderlyingCollectionState(collection);\\n\\n        return collectionState.claimExpiredNfts(\\n            userFloorAccounts, creditToken, collection, underlying, nftIds, maxCreditCost, receiver\\n        );\\n    }\\n\\n    function removeExpiredKeyAndRestoreCredit(address collection, uint256[] memory nftIds, address onBehalfOf)\\n        public\\n        returns (uint256)\\n    {\\n        mustValidNftIds(nftIds);\\n\\n        (CollectionState storage collectionState, address underlying) = useUnderlyingCollectionState(collection);\\n\\n        return collectionState.removeExpiredKeysAndRestoreCredits(\\n            userFloorAccounts[onBehalfOf], underlying, nftIds, onBehalfOf\\n        );\\n    }\\n\\n    function recalculateAvailableCredit(address onBehalfOf) public returns (uint256) {\\n        UserFloorAccount storage account = userFloorAccounts[onBehalfOf];\\n\\n        uint256 minMaintCredit = account.recalculateMinMaintCredit(onBehalfOf);\\n        unchecked {\\n            /// when locking or extending, we ensure that `minMaintCredit` is less than `totalCredit`\\n            /// availableCredit = totalCredit - minMaintCredit\\n            return account.tokenBalance(creditToken) - minMaintCredit;\\n        }\\n    }\\n\\n    function extendKeys(\\n        address collection,\\n        uint256[] memory nftIds,\\n        uint256 expiryTs,\\n        uint256 newVipLevel,\\n        uint256 maxCreditCost\\n    ) public returns (uint256) {\\n        mustValidNftIds(nftIds);\\n        mustValidExpiryTs(expiryTs);\\n\\n        (CollectionState storage collectionState, address underlying) = useUnderlyingCollectionState(collection);\\n        return collectionState.extendLockingForKeys(\\n            userFloorAccounts[msg.sender],\\n            LockParam({\\n                proxyCollection: collection,\\n                collection: underlying,\\n                creditToken: creditToken,\\n                nftIds: nftIds,\\n                expiryTs: expiryTs,\\n                vipLevel: newVipLevel,\\n                maxCreditCost: maxCreditCost\\n            })\\n        );\\n    }\\n\\n    function fragmentNFTs(address collection, uint256[] memory nftIds, address onBehalfOf) public {\\n        mustValidNftIds(nftIds);\\n        CollectionState storage collectionState = useCollectionState(collection);\\n\\n        collectionState.fragmentNFTs(collection, nftIds, onBehalfOf);\\n    }\\n\\n    function claimRandomNFT(address collection, uint256 claimCnt, uint256 maxCreditCost, address receiver)\\n        public\\n        returns (uint256)\\n    {\\n        CollectionState storage collectionState = useCollectionState(collection);\\n\\n        return collectionState.claimRandomNFT(\\n            userFloorAccounts, creditToken, collection, claimCnt, maxCreditCost, receiver\\n        );\\n    }\\n\\n    function initAuctionOnExpiredSafeBoxes(address collection, uint256[] memory nftIds, uint256 bidAmount) public {\\n        mustValidNftIds(nftIds);\\n        (CollectionState storage collectionState, address underlying) = useUnderlyingCollectionState(collection);\\n        collectionState.initAuctionOnExpiredSafeBoxes(userFloorAccounts, creditToken, underlying, nftIds, bidAmount);\\n    }\\n\\n    function ownerInitAuctions(\\n        address collection,\\n        uint256[] memory nftIds,\\n        uint256 maxExpiry,\\n        address token,\\n        uint256 minimumBid\\n    ) public {\\n        mustValidNftIds(nftIds);\\n        mustSupportedToken(token);\\n\\n        (CollectionState storage collectionState, address underlying) = useUnderlyingCollectionState(collection);\\n        collectionState.ownerInitAuctions(\\n            userFloorAccounts, creditToken, underlying, nftIds, maxExpiry, token, minimumBid\\n        );\\n    }\\n\\n    function placeBidOnAuction(address collection, uint256 nftId, uint256 bidAmount, uint256 bidOptionIdx) public {\\n        (CollectionState storage collectionState, address underlying) = useUnderlyingCollectionState(collection);\\n        collectionState.placeBidOnAuction(userFloorAccounts, creditToken, underlying, nftId, bidAmount, bidOptionIdx);\\n    }\\n\\n    function placeBidOnAuction(\\n        address collection,\\n        uint256 nftId,\\n        uint256 bidAmount,\\n        uint256 bidOptionIdx,\\n        address token,\\n        uint256 amountToTransfer\\n    ) public payable {\\n        addTokens(msg.sender, token, amountToTransfer);\\n        /// we don't check whether msg.value is equal to bidAmount, as we utility all currency balance of user account,\\n        /// it will be reverted if there is no enough balance to pay the required bid.\\n        placeBidOnAuction(collection, nftId, bidAmount, bidOptionIdx);\\n    }\\n\\n    function settleAuctions(address collection, uint256[] memory nftIds) public {\\n        mustValidNftIds(nftIds);\\n        (CollectionState storage collectionState, address underlying) = useUnderlyingCollectionState(collection);\\n        collectionState.settleAuctions(userFloorAccounts, underlying, nftIds);\\n    }\\n\\n    function ownerInitRaffles(RaffleInitParam memory param) public {\\n        mustValidNftIds(param.nftIds);\\n        mustSupportedToken(param.ticketToken);\\n\\n        (CollectionState storage collectionState, address underlying) = useUnderlyingCollectionState(param.collection);\\n        param.collection = underlying;\\n\\n        collectionState.ownerInitRaffles(userFloorAccounts, param, creditToken);\\n    }\\n\\n    function buyRaffleTickets(address collectionId, uint256 nftId, uint256 ticketCnt) public {\\n        (CollectionState storage collectionState, address underlying) = useUnderlyingCollectionState(collectionId);\\n\\n        collectionState.buyRaffleTickets(userFloorAccounts, creditToken, underlying, nftId, ticketCnt);\\n    }\\n\\n    function buyRaffleTickets(\\n        address collectionId,\\n        uint256 nftId,\\n        uint256 ticketCnt,\\n        address token,\\n        uint256 amountToTransfer\\n    ) public payable {\\n        addTokens(msg.sender, token, amountToTransfer);\\n        buyRaffleTickets(collectionId, nftId, ticketCnt);\\n    }\\n\\n    function settleRaffles(address collectionId, uint256[] memory nftIds) public {\\n        mustValidNftIds(nftIds);\\n        if (nftIds.length > 8) revert Errors.InvalidParam();\\n        (CollectionState storage collectionState, address underlying) = useUnderlyingCollectionState(collectionId);\\n\\n        (bytes memory toSettleNftIds, uint256 len) = collectionState.prepareSettleRaffles(nftIds);\\n        if (len > 0) {\\n            uint256 requestId = COORDINATOR.requestRandomWords(keyHash, subId, 3, 800_000, uint32(len));\\n            randomnessRequestToReceiver[requestId] =\\n                RandomRequestInfo({typ: 1, collection: underlying, data: toSettleNftIds});\\n        }\\n    }\\n\\n    function _completeSettleRaffles(address collectionId, bytes memory data, uint256[] memory randoms) private {\\n        CollectionState storage collection = collectionStates[collectionId];\\n        collection.settleRaffles(userFloorAccounts, collectionId, data, randoms);\\n    }\\n\\n    function ownerInitPrivateOffers(PrivateOfferInitParam memory param) public {\\n        mustValidNftIds(param.nftIds);\\n        mustSupportedToken(param.token);\\n\\n        (CollectionState storage collectionState, address underlying) = useUnderlyingCollectionState(param.collection);\\n        param.collection = underlying;\\n        collectionState.ownerInitPrivateOffers(userFloorAccounts, creditToken, param);\\n    }\\n\\n    function cancelPrivateOffers(address collectionId, uint256[] memory nftIds) public {\\n        (CollectionState storage collectionState, address underlying) = useUnderlyingCollectionState(collectionId);\\n        collectionState.removePrivateOffers(underlying, nftIds);\\n    }\\n\\n    function buyerAcceptPrivateOffers(address collectionId, uint256[] memory nftIds) public {\\n        mustValidNftIds(nftIds);\\n        (CollectionState storage collectionState, address underlying) = useUnderlyingCollectionState(collectionId);\\n        collectionState.buyerAcceptPrivateOffers(userFloorAccounts, underlying, nftIds, creditToken);\\n    }\\n\\n    function buyerAcceptPrivateOffers(\\n        address collectionId,\\n        uint256[] memory nftIds,\\n        address token,\\n        uint256 amountToTransfer\\n    ) public payable {\\n        addTokens(msg.sender, token, amountToTransfer);\\n        buyerAcceptPrivateOffers(collectionId, nftIds);\\n    }\\n\\n    function onERC721Received(address, /*operator*/ address, /*from*/ uint256, /*tokenId*/ bytes calldata /*data*/ )\\n        external\\n        pure\\n        override\\n        returns (bytes4)\\n    {\\n        return this.onERC721Received.selector;\\n    }\\n\\n    function useUnderlyingCollectionState(address collectionId)\\n        private\\n        view\\n        returns (CollectionState storage, address)\\n    {\\n        address underlying = collectionProxy[collectionId];\\n        if (underlying == address(0)) {\\n            underlying = collectionId;\\n        }\\n\\n        return (useCollectionState(underlying), underlying);\\n    }\\n\\n    function useCollectionState(address collectionId) private view returns (CollectionState storage) {\\n        CollectionState storage collection = collectionStates[collectionId];\\n        if (collection.nextKeyId == 0) revert Errors.NftCollectionNotSupported();\\n        return collection;\\n    }\\n\\n    function mustSupportedToken(address token) private view {\\n        if (!supportedTokens[token]) revert Errors.TokenNotSupported();\\n    }\\n\\n    function mustValidNftIds(uint256[] memory nftIds) private pure {\\n        if (nftIds.length == 0) revert Errors.InvalidParam();\\n\\n        /// nftIds should be ordered and there should be no duplicate elements.\\n        for (uint256 i = 1; i < nftIds.length;) {\\n            unchecked {\\n                if (nftIds[i] <= nftIds[i - 1]) {\\n                    revert Errors.InvalidParam();\\n                }\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function mustValidExpiryTs(uint256 expiryTs) private view {\\n        if (expiryTs != 0 && expiryTs <= block.timestamp) revert Errors.InvalidParam();\\n    }\\n\\n    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {\\n        RandomRequestInfo storage info = randomnessRequestToReceiver[requestId];\\n\\n        _completeSettleRaffles(info.collection, info.data, randomWords);\\n\\n        delete randomnessRequestToReceiver[requestId];\\n    }\\n\\n    function collectionLockingAt(address collection, uint256 startTimestamp, uint256 endTimestamp)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        return collectionStates[collection].getLockingBuckets(startTimestamp, endTimestamp);\\n    }\\n\\n    function extsload(bytes32 slot) external view returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            value := sload(slot)\\n        }\\n    }\\n\\n    function extsload(bytes32 startSlot, uint256 nSlots) external view returns (bytes memory) {\\n        bytes memory value = new bytes(nSlots << 5);\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let i := 0 } lt(i, nSlots) { i := add(i, 1) } {\\n                mstore(add(value, shl(5, add(i, 1))), sload(add(startSlot, i)))\\n            }\\n        }\\n\\n        return value;\\n    }\\n\\n    receive() external payable {\\n        addTokens(msg.sender, CurrencyTransfer.NATIVE, msg.value);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interface/IFlooring.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"./IMulticall.sol\\\";\\n\\ninterface IFlooring is IERC721Receiver, IMulticall {\\n    /// Admin Operations\\n\\n    /// @notice Add new collection for Flooring Protocol\\n    function supportNewCollection(address _originalNFT, address fragmentToken) external;\\n\\n    /// @notice Add new token which will be used as settlement token in Flooring Protocol\\n    /// @param addOrRemove `true` means add token, `false` means remove token\\n    function supportNewToken(address _tokenAddress, bool addOrRemove) external;\\n\\n    /// @notice set proxy collection config\\n    /// Note. the `tokenId`s of the proxy collection and underlying collection must be correspond one by one\\n    /// eg. Paraspace Derivative Token BAYC(nBAYC) -> BAYC\\n    function setCollectionProxy(address proxyCollection, address underlyingCollection) external;\\n\\n    /// @notice withdraw platform fee accumulated.\\n    /// Note. withdraw from `address(this)`'s account.\\n    function withdrawPlatformFee(address token, uint256 amount) external;\\n\\n    /// @notice Deposit and lock credit token on behalf of receiver\\n    /// user can not withdraw these tokens until `unlockCredit` is called.\\n    function addAndLockCredit(address receiver, uint256 amount) external;\\n\\n    /// @notice Unlock user credit token to allow withdraw\\n    /// used to release investors' funds as time goes\\n    /// Note. locked credit can be used to operate safeboxes(lock/unlock...)\\n    function unlockCredit(address receiver, uint256 amount) external;\\n\\n    /// User Operations\\n\\n    /// @notice User deposits token to the Floor Contract\\n    /// @param onBehalfOf deposit token into `onBehalfOf`'s account.(note. the tokens of msg.sender will be transfered)\\n    function addTokens(address onBehalfOf, address token, uint256 amount) external payable;\\n\\n    /// @notice User removes token from Floor Contract\\n    /// @param receiver who will receive the funds.(note. the token of msg.sender will be transfered)\\n    function removeTokens(address token, uint256 amount, address receiver) external;\\n\\n    /// @notice Lock specified `nftIds` into Flooring Safeboxes and receive corresponding Fragment Tokens of the `collection`\\n    /// @param expiryTs when the safeboxes expired, `0` means infinite lock without expiry\\n    /// @param vipLevel vip tier required in this lock operation\\n    /// @param maxCredit maximum credit can be locked in this operation, if real cost exceeds this limit, the tx will fail\\n    /// @param onBehalfOf who will receive the safebox and fragment tokens.(note. the NFTs of the msg.sender will be transfered)\\n    function lockNFTs(\\n        address collection,\\n        uint256[] memory nftIds,\\n        uint256 expiryTs,\\n        uint256 vipLevel,\\n        uint256 maxCredit,\\n        address onBehalfOf\\n    ) external returns (uint256);\\n\\n    /// @notice Extend the exist safeboxes with longer lock duration with more credit token staked\\n    /// @param expiryTs new expiry timestamp, should bigger than previous expiry\\n    function extendKeys(\\n        address collection,\\n        uint256[] memory nftIds,\\n        uint256 expiryTs,\\n        uint256 vipLevel,\\n        uint256 maxCredit\\n    ) external returns (uint256);\\n\\n    /// @notice Unlock specified `nftIds` which had been locked previously\\n    ///         sender's wallet should have enough Fragment Tokens of the `collection` which will be burned to redeem the NFTs\\n    /// @param expiryTs the latest nft's expiry, we need this to clear locking records\\n    ///                 if the value smaller than the latest nft's expiry, the tx will fail\\n    ///                 if part of `nftIds` were locked infinitely, just skip these expiry\\n    /// @param receiver who will receive the NFTs.\\n    ///                 note. - The safeboxes of the msg.sender will be removed.\\n    ///                       - The Fragment Tokens of the msg.sender will be burned.\\n    function unlockNFTs(address collection, uint256 expiryTs, uint256[] memory nftIds, address receiver) external;\\n\\n    /// @notice Fragment specified `nftIds` into Floor Vault and receive Fragment Tokens without any locking\\n    ///         after fragmented, any one has enough Fragment Tokens can redeem there `nftIds`\\n    /// @param onBehalfOf who will receive the fragment tokens.(note. the NFTs of the msg.sender will be transfered)\\n    function fragmentNFTs(address collection, uint256[] memory nftIds, address onBehalfOf) external;\\n\\n    /// @notice Claim `nftIds` which had been locked and had expired\\n    ///         sender's wallet should have enough Fragment Tokens of the `collection` which will be burned to redeem the NFTs\\n    /// @param maxCredit maximum credit can be costed in this operation, if real cost exceeds this limit, the tx will fail\\n    /// @param receiver who will receive the NFTs.\\n    ///                 note. - the msg.sender will pay the redemption cost.\\n    ///                       - The Fragment Tokens of the msg.sender will be burned.\\n    function claimExpiredNfts(address collection, uint256[] memory nftIds, uint256 maxCredit, address receiver)\\n        external\\n        returns (uint256);\\n\\n    /// @notice Randomly claim `claimCnt` NFTs from Floor Vault\\n    ///         sender's wallet should have enough Fragment Tokens of the `collection` which will be burned to redeem the NFTs\\n    /// @param maxCredit maximum credit can be costed in this operation, if real cost exceeds this limit, the tx will fail\\n    /// @param receiver who will receive the NFTs.\\n    ///                 note. - the msg.sender will pay the redemption cost.\\n    ///                       - The Fragment Tokens of the msg.sender will be burned.\\n    function claimRandomNFT(address collection, uint256 claimCnt, uint256 maxCredit, address receiver)\\n        external\\n        returns (uint256);\\n\\n    /// @notice Start auctions on specified `nftIds` with an initial bid price(`bidAmount`)\\n    ///         This kind of auctions will be settled with Floor Credit Token\\n    /// @param bidAmount initial bid price\\n    function initAuctionOnExpiredSafeBoxes(address collection, uint256[] memory nftIds, uint256 bidAmount) external;\\n\\n    /// @notice Owner starts auctions on his locked Safeboxes\\n    /// @param maxExpiry the latest nft's expiry, we need this to clear locking records\\n    /// @param token which token should be used to settle auctions(bid, settle)\\n    /// @param minimumBid minimum bid price when someone place a bid on the auction\\n    function ownerInitAuctions(\\n        address collection,\\n        uint256[] memory nftIds,\\n        uint256 maxExpiry,\\n        address token,\\n        uint256 minimumBid\\n    ) external;\\n\\n    /// @notice Place a bid on specified `nftId`'s action\\n    /// @param bidAmount bid price\\n    /// @param bidOptionIdx which option used to extend auction expiry and bid price\\n    function placeBidOnAuction(address collection, uint256 nftId, uint256 bidAmount, uint256 bidOptionIdx) external;\\n\\n    /// @notice Place a bid on specified `nftId`'s action\\n    /// @param token which token should be transfered to the Flooring for bidding. `0x0` means ETH(native)\\n    /// @param amountToTransfer how many `token` should to transfered\\n    function placeBidOnAuction(\\n        address collection,\\n        uint256 nftId,\\n        uint256 bidAmount,\\n        uint256 bidOptionIdx,\\n        address token,\\n        uint256 amountToTransfer\\n    ) external payable;\\n\\n    /// @notice Settle auctions of `nftIds`\\n    function settleAuctions(address collection, uint256[] memory nftIds) external;\\n\\n    struct RaffleInitParam {\\n        address collection;\\n        uint256[] nftIds;\\n        /// @notice which token used to buy and settle raffle\\n        address ticketToken;\\n        /// @notice price per ticket\\n        uint96 ticketPrice;\\n        /// @notice max tickets amount can be sold\\n        uint32 maxTickets;\\n        /// @notice durationIdx used to get how long does raffles last\\n        uint256 duration;\\n        /// @notice the largest epxiry of nfts, we need this to clear locking records\\n        uint256 maxExpiry;\\n    }\\n\\n    /// @notice Owner start raffles on locked `nftIds`\\n    function ownerInitRaffles(RaffleInitParam memory param) external;\\n\\n    /// @notice Buy `nftId`'s raffle tickets\\n    /// @param ticketCnt how many tickets should be bought in this operation\\n    function buyRaffleTickets(address collectionId, uint256 nftId, uint256 ticketCnt) external;\\n\\n    /// @notice Buy `nftId`'s raffle tickets\\n    /// @param token which token should be transfered to the Flooring for buying. `0x0` means ETH(native)\\n    /// @param amountToTransfer how many `token` should to transfered\\n    function buyRaffleTickets(\\n        address collectionId,\\n        uint256 nftId,\\n        uint256 ticketCnt,\\n        address token,\\n        uint256 amountToTransfer\\n    ) external payable;\\n\\n    /// @notice Settle raffles of `nftIds`\\n    function settleRaffles(address collectionId, uint256[] memory nftIds) external;\\n\\n    struct PrivateOfferInitParam {\\n        address collection;\\n        uint256[] nftIds;\\n        /// @notice the largest epxiry of nfts, we need this to clear locking records\\n        uint256 maxExpiry;\\n        /// @notice who will receive the otc offers\\n        address receiver;\\n        /// @notice which token used to settle offers\\n        address token;\\n        /// @notice price of the offers\\n        uint96 price;\\n    }\\n\\n    /// @notice Owner start private offers(otc) on locked `nftIds`\\n    function ownerInitPrivateOffers(PrivateOfferInitParam memory param) external;\\n\\n    /// @notice Owner or Receiver cancel the private offers of `nftIds`\\n    function cancelPrivateOffers(address collectionId, uint256[] memory nftIds) external;\\n\\n    /// @notice Receiver accept the private offers of `nftIds`\\n    function buyerAcceptPrivateOffers(address collectionId, uint256[] memory nftIds) external;\\n\\n    /// @notice Receiver accept the private offers of `nftIds`\\n    /// @param token which token should be transfered to the Flooring for buying. `0x0` means ETH(native)\\n    /// @param amountToTransfer how many `token` should to transfered\\n    function buyerAcceptPrivateOffers(\\n        address collectionId,\\n        uint256[] memory nftIds,\\n        address token,\\n        uint256 amountToTransfer\\n    ) external payable;\\n\\n    /// @notice Clear expired or mismatching safeboxes of `nftIds` in user account\\n    /// @param onBehalfOf whose account will be recalculated\\n    /// @return credit amount has been released\\n    function removeExpiredKeyAndRestoreCredit(address collection, uint256[] memory nftIds, address onBehalfOf)\\n        external\\n        returns (uint256);\\n\\n    /// @notice Update user's staking credit status by iterating all active collections in user account\\n    /// @param onBehalfOf whose account will be recalculated\\n    /// @return availableCredit how many credit available to use after this opeartion\\n    function recalculateAvailableCredit(address onBehalfOf) external returns (uint256 availableCredit);\\n\\n    /// Util operations\\n\\n    /// @notice Called by external contracts to access granular pool state\\n    /// @param slot Key of slot to sload\\n    /// @return value The value of the slot as bytes32\\n    function extsload(bytes32 slot) external view returns (bytes32 value);\\n\\n    /// @notice Called by external contracts to access granular pool state\\n    /// @param slot Key of slot to start sloading from\\n    /// @param nSlots Number of slots to load into return value\\n    /// @return value The value of the sload-ed slots concatenated as dynamic bytes\\n    function extsload(bytes32 slot, uint256 nSlots) external view returns (bytes memory value);\\n\\n    function creditToken() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/interface/IFlooringEvent.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport {SafeBoxKey} from \\\"../logic/Structs.sol\\\";\\n\\ninterface IFlooringEvent {\\n    event NewCollectionSupported(address indexed collection, address indexed floorToken);\\n    event UpdateTokenSupported(address indexed token, bool addOrRemove);\\n    event ProxyCollectionChanged(address indexed proxyCollection, address indexed underlyingCollection);\\n\\n    /// @notice `sender` deposit `token` into Flooring on behalf of `receiver`. `receiver`'s account will be updated.\\n    event DepositToken(address indexed sender, address indexed receiver, address indexed token, uint256 amount);\\n    /// @notice `sender` withdraw `token` from Flooring and transfer it to `receiver`.\\n    event WithdrawToken(address indexed sender, address indexed receiver, address indexed token, uint256 amount);\\n    /// @notice update the account maintain credit on behalfOf `onBehalfOf`\\n    event UpdateMaintainCredit(address indexed onBehalfOf, uint256 minMaintCredit);\\n\\n    /// @notice Lock NFTs\\n    /// @param sender who send the tx and pay the NFTs\\n    /// @param onBehalfOf who will hold the safeboxes and receive the Fragment Tokens\\n    /// @param collection contract addr of the collection\\n    /// @param tokenIds nft ids to lock\\n    /// @param safeBoxKeys compacted safe box keys with same order of `tokenIds`\\n    /// for each key, its format is: [167-160:vipLevel][159-96:keyId][95-0:lockedCredit]\\n    /// @param safeBoxExpiryTs expiry timestamp of safeboxes\\n    /// @param minMaintCredit `onBehalfOf`'s minMaintCredit after the lock\\n    event LockNft(\\n        address indexed sender,\\n        address indexed onBehalfOf,\\n        address indexed collection,\\n        uint256[] tokenIds,\\n        uint256[] safeBoxKeys,\\n        uint256 safeBoxExpiryTs,\\n        uint256 minMaintCredit,\\n        address proxyCollection\\n    );\\n\\n    /// @notice Extend keys\\n    /// @param operator who extend the keys\\n    /// @param collection contract addr of the collection\\n    /// @param tokenIds nft ids to lock\\n    /// @param safeBoxKeys compacted safe box keys with same order of `tokenIds`\\n    /// for each key, its format is: [167-160:vipLevel][159-96:keyId][95-0:lockedCredit]\\n    /// @param safeBoxExpiryTs expiry timestamp of safeboxes\\n    /// @param minMaintCredit `operator`'s minMaintCredit after the lock\\n    event ExtendKey(\\n        address indexed operator,\\n        address indexed collection,\\n        uint256[] tokenIds,\\n        uint256[] safeBoxKeys,\\n        uint256 safeBoxExpiryTs,\\n        uint256 minMaintCredit\\n    );\\n\\n    /// @notice Unlock NFTs\\n    /// @param operator who hold the safeboxes that will be unlocked\\n    /// @param receiver who will receive the NFTs\\n    event UnlockNft(\\n        address indexed operator,\\n        address indexed receiver,\\n        address indexed collection,\\n        uint256[] tokenIds,\\n        address proxyCollection\\n    );\\n\\n    /// @notice `operator` remove invalid keys on behalf of `onBehalfOf`.\\n    /// `onBehalfOf`'s account will be updated.\\n    event RemoveExpiredKey(\\n        address indexed operator,\\n        address indexed onBehalfOf,\\n        address indexed collection,\\n        uint256[] tokenIds,\\n        uint256[] safeBoxKeys\\n    );\\n\\n    /// @notice Claim expired safeboxes that maintain NFTs\\n    /// @param operator who will pay the redemption cost\\n    /// @param receiver who will receive the NFTs\\n    /// @param creditCost how many credit token cost in this claim\\n    event ClaimExpiredNft(\\n        address indexed operator,\\n        address indexed receiver,\\n        address indexed collection,\\n        uint256[] tokenIds,\\n        uint256 creditCost,\\n        address proxyCollection\\n    );\\n\\n    /// @notice Fragment NFTs to free pool\\n    /// @param operator who will pay the NFTs\\n    /// @param onBehalfOf who will receive the Fragment Tokens\\n    event FragmentNft(\\n        address indexed operator, address indexed onBehalfOf, address indexed collection, uint256[] tokenIds\\n    );\\n\\n    /// @notice Claim random NFTs from free pool\\n    /// @param operator who will pay the redemption cost\\n    /// @param receiver who will receive the NFTs\\n    /// @param creditCost how many credit token cost in this claim\\n    event ClaimRandomNft(\\n        address indexed operator,\\n        address indexed receiver,\\n        address indexed collection,\\n        uint256[] tokenIds,\\n        uint256 creditCost\\n    );\\n\\n    event AuctionStarted(\\n        address indexed trigger,\\n        address indexed collection,\\n        uint64[] activityIds,\\n        uint256[] tokenIds,\\n        address settleToken,\\n        uint256 minimumBid,\\n        uint256 feeRateBips,\\n        uint256 auctionEndTime,\\n        uint256 safeBoxExpiryTs,\\n        bool selfTriggered,\\n        uint256 adminFee\\n    );\\n\\n    event NewTopBidOnAuction(\\n        address indexed bidder,\\n        address indexed collection,\\n        uint64 activityId,\\n        uint256 tokenId,\\n        uint256 bidAmount,\\n        uint256 auctionEndTime,\\n        uint256 safeBoxExpiryTs\\n    );\\n\\n    event AuctionEnded(\\n        address indexed winner,\\n        address indexed collection,\\n        uint64 activityId,\\n        uint256 tokenId,\\n        uint256 safeBoxKeyId,\\n        uint256 collectedFunds\\n    );\\n\\n    event RaffleStarted(\\n        address indexed owner,\\n        address indexed collection,\\n        uint64[] activityIds,\\n        uint256[] nftIds,\\n        uint48 maxTickets,\\n        address settleToken,\\n        uint96 ticketPrice,\\n        uint256 feeRateBips,\\n        uint48 raffleEndTime,\\n        uint256 safeBoxExpiryTs,\\n        uint256 adminFee\\n    );\\n\\n    event RaffleTicketsSold(\\n        address indexed buyer,\\n        address indexed collection,\\n        uint64 activityId,\\n        uint256 nftId,\\n        uint256 ticketsSold,\\n        uint256 cost\\n    );\\n\\n    event RaffleSettled(\\n        address indexed winner,\\n        address indexed collection,\\n        uint64 activityId,\\n        uint256 nftId,\\n        uint256 safeBoxKeyId,\\n        uint256 collectedFunds\\n    );\\n\\n    event PrivateOfferStarted(\\n        address indexed seller,\\n        address indexed buyer,\\n        address indexed collection,\\n        uint64[] activityIds,\\n        uint256[] nftIds,\\n        address settleToken,\\n        uint96 price,\\n        uint256 offerEndTime,\\n        uint256 safeBoxExpiryTs,\\n        uint256 adminFee\\n    );\\n\\n    event PrivateOfferCanceled(\\n        address indexed operator, address indexed collection, uint64[] activityIds, uint256[] nftIds\\n    );\\n\\n    event PrivateOfferAccepted(\\n        address indexed buyer,\\n        address indexed collection,\\n        uint64[] activityIds,\\n        uint256[] nftIds,\\n        uint256[] safeBoxKeyIds\\n    );\\n}\\n\"\r\n    },\r\n    \"src/interface/IFragmentToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\ninterface IFragmentToken {\\n    error CallerIsNotTrustedContract();\\n\\n    function mint(address account, uint256 amount) external;\\n\\n    function burn(address account, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interface/IMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\n/// @title Multicall interface\\n/// @notice Enables calling multiple methods in a single call to the contract\\ninterface IMulticall {\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedMulticall();\\n\\n    struct CallData {\\n        address target;\\n        bytes callData;\\n    }\\n\\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\\n    /// @param data The encoded function data for each of the calls to make to this contract\\n    /// @return results The results from each of the calls passed in via data\\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results);\\n\\n    /// @notice Allow trusted caller to call specified addresses through the Contract\\n    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\\n    /// @param calls The encoded function data and target for each of the calls to make to this contract\\n    /// @return results The results from each of the calls passed in via calls\\n    function extMulticall(CallData[] calldata calls) external returns (bytes[] memory);\\n}\\n\"\r\n    },\r\n    \"src/library/Array.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nlibrary Array {\\n    /// @notice Compress `data` to [Length]:{[BytesLength][val...]}\\n    /// eg. [0, 255, 256] will be convert to bytes series: 0x03 0x00 0x01 0xFF 0x02 0x00 0x01\\n    /// 0x03 means there are 3 numbers\\n    /// 0x00 means first number is 0\\n    /// 0x01 means next number(255) has 1 byte to store the real value\\n    /// 0xFF equals 255\\n    /// 256 need 2 bytes(0x02) to store, and its value represented in hex is 0x0100\\n    function encodeUints(uint256[] memory data) internal pure returns (bytes memory res) {\\n        uint256 dataLen = data.length;\\n\\n        require(dataLen <= type(uint8).max);\\n\\n        unchecked {\\n            uint256 totalBytes;\\n            for (uint256 i; i < dataLen; ++i) {\\n                uint256 val = data[i];\\n                while (val > 0) {\\n                    val >>= 8;\\n                    ++totalBytes;\\n                }\\n            }\\n\\n            res = new bytes(dataLen + totalBytes + 1);\\n            assembly {\\n                /// skip res's length, store data length\\n                mstore8(add(res, 0x20), dataLen)\\n            }\\n\\n            /// start from the second element idx\\n            uint256 resIdx = 0x21;\\n            for (uint256 i; i < dataLen; ++i) {\\n                uint256 val = data[i];\\n\\n                uint256 byteLen;\\n                while (val > 0) {\\n                    val >>= 8;\\n                    ++byteLen;\\n                }\\n\\n                assembly {\\n                    /// store bytes length of the `i`th element\\n                    mstore8(add(res, resIdx), byteLen)\\n                }\\n                ++resIdx;\\n\\n                val = data[i];\\n                for (uint256 j; j < byteLen; ++j) {\\n                    assembly {\\n                        mstore8(add(res, resIdx), val)\\n                    }\\n                    val >>= 8;\\n                    ++resIdx;\\n                }\\n            }\\n        }\\n    }\\n\\n    function decodeUints(bytes memory data) internal pure returns (uint256[] memory res) {\\n        uint256 dataLen = data.length;\\n        require(dataLen > 0);\\n\\n        res = new uint256[](uint8(data[0]));\\n        uint256 k;\\n\\n        unchecked {\\n            for (uint256 i = 1; i < dataLen; ++i) {\\n                uint256 byteLen = uint8(data[i]);\\n                /// if byteLen is zero, it means current element is zero, no need to update `res`, just increment `k`\\n                if (byteLen > 0) {\\n                    uint256 tmp;\\n                    /// combine next `byteLen` bytes to `tmp`\\n                    for (uint256 j; j < byteLen; ++j) {\\n                        /// skip `byteLen`\\n                        ++i;\\n\\n                        tmp |= ((uint256(uint8(data[i]))) << (j * 8));\\n                    }\\n                    res[k] = tmp;\\n                }\\n\\n                ++k;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/library/CurrencyTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nlibrary CurrencyTransfer {\\n    /// @notice Thrown when an ERC20 transfer fails\\n    error ERC20TransferFailed();\\n    /// @notice Thrown when an NATIVE transfer fails\\n    error NativeTransferFailed();\\n\\n    address public constant NATIVE = address(0);\\n\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        // ref\\n        // https://docs.soliditylang.org/en/latest/internals/layout_in_memory.html\\n        // implementation from\\n        // https://github.com/transmissions11/solmate/blob/v7/src/utils/SafeTransferLib.sol\\n        // https://github.com/Uniswap/v4-core/blob/main/contracts/types/Currency.sol\\n        bool success;\\n\\n        if (token == NATIVE) {\\n            assembly {\\n                // Transfer the ETH and store if it succeeded or not.\\n                success := call(gas(), to, amount, 0, 0, 0, 0)\\n            }\\n\\n            if (!success) revert NativeTransferFailed();\\n        } else {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // We'll write our calldata to this slot below, but restore it later.\\n                let memPointer := mload(0x40)\\n\\n                // Write the abi-encoded calldata into memory, beginning with the function selector.\\n                mstore(0, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n                mstore(4, to) // Append the \\\"to\\\" argument.\\n                mstore(36, amount) // Append the \\\"amount\\\" argument.\\n\\n                success :=\\n                    and(\\n                        // Set success to whether the call reverted, if not we check it either\\n                        // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                        or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                        // We use 68 because that's the total length of our calldata (4 + 32 * 2)\\n                        // Counterintuitively, this call() must be positioned after the or() in the\\n                        // surrounding and() because and() evaluates its arguments from right to left.\\n                        call(gas(), token, 0, 0, 68, 0, 32)\\n                    )\\n\\n                mstore(0x60, 0) // Restore the zero slot to zero.\\n                mstore(0x40, memPointer) // Restore the memPointer.\\n            }\\n            if (!success) revert ERC20TransferFailed();\\n        }\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(4, from) // Append and mask the \\\"from\\\" argument.\\n            mstore(36, to) // Append and mask the \\\"to\\\" argument.\\n            // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n            mstore(68, amount)\\n\\n            success :=\\n                and(\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                    // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                    // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                    // Counterintuitively, this call must be positioned second to the or() call in the\\n                    // surrounding and() call or else returndatasize() will be zero during the computation.\\n                    call(gas(), token, 0, 0, 100, 0, 32)\\n                )\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, memPointer) // Restore the memPointer.\\n        }\\n\\n        if (!success) revert ERC20TransferFailed();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/library/ERC721Transfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nlibrary ERC721Transfer {\\n    /// @notice Thrown when an ERC721 transfer fails\\n    error ERC721TransferFailed();\\n\\n    function safeTransferFrom(address collection, address from, address to, uint256 tokenId) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(0, 0x42842e0e00000000000000000000000000000000000000000000000000000000)\\n            mstore(4, from) // Append and mask the \\\"from\\\" argument.\\n            mstore(36, to) // Append and mask the \\\"to\\\" argument.\\n            // Append the \\\"tokenId\\\" argument. Masking not required as it's a full 32 byte type.\\n            mstore(68, tokenId)\\n\\n            success :=\\n                and(\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                    // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                    // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                    // Counterintuitively, this call must be positioned second to the or() call in the\\n                    // surrounding and() call or else returndatasize() will be zero during the computation.\\n                    call(gas(), collection, 0, 0, 100, 0, 32)\\n                )\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, memPointer) // Restore the memPointer.\\n        }\\n\\n        if (!success) revert ERC721TransferFailed();\\n    }\\n\\n    function safeBatchTransferFrom(address collection, address from, address to, uint256[] memory tokenIds) internal {\\n        unchecked {\\n            uint256 len = tokenIds.length;\\n            for (uint256 i; i < len; ++i) {\\n                safeTransferFrom(collection, from, to, tokenIds[i]);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/library/OwnedUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract OwnedUpgradeable {\\n    error Unauthorized();\\n\\n    event OwnerUpdated(address indexed user, address indexed newOwner);\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        if (msg.sender != owner) revert Unauthorized();\\n\\n        _;\\n    }\\n\\n    function __Owned_init() internal {\\n        owner = msg.sender;\\n    }\\n\\n    function setOwner(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(msg.sender, newOwner);\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/library/RollingBuckets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"../Constants.sol\\\";\\n\\nlibrary RollingBuckets {\\n    error BucketValueExceedsLimit();\\n    error BucketLengthExceedsLimit();\\n\\n    /// @dev `MAX_BUCKET_SIZE` must be a multiple of `WORD_ELEMENT_SIZE`,\\n    /// otherwise some words may be incomplete which may lead to incorrect bit positioning.\\n    uint256 constant MAX_BUCKET_SIZE = Constants.MAX_LOCKING_BUCKET;\\n    /// @dev each `ELEMENT_BIT_SIZE` bits stores an element\\n    uint256 constant ELEMENT_BIT_SIZE = 24;\\n    /// @dev `ELEMENT_BIT_SIZE` bits mask\\n    uint256 constant MASK = 0xFFFFFF;\\n    /// @dev one word(256 bits) can store (256 // ELEMENT_BIT_SIZE) elements\\n    uint256 constant WORD_ELEMENT_SIZE = 10;\\n\\n    function position(uint256 tick) private pure returns (uint256 wordPos, uint256 bitPos) {\\n        unchecked {\\n            wordPos = tick / WORD_ELEMENT_SIZE;\\n            bitPos = tick % WORD_ELEMENT_SIZE;\\n        }\\n    }\\n\\n    function get(mapping(uint256 => uint256) storage buckets, uint256 bucketStamp) internal view returns (uint256) {\\n        unchecked {\\n            (uint256 wordPos, uint256 bitPos) = position(bucketStamp % MAX_BUCKET_SIZE);\\n            return (buckets[wordPos] >> (bitPos * ELEMENT_BIT_SIZE)) & MASK;\\n        }\\n    }\\n\\n    /// [first, last)\\n    function batchGet(mapping(uint256 => uint256) storage buckets, uint256 firstStamp, uint256 lastStamp)\\n        internal\\n        view\\n        returns (uint256[] memory)\\n    {\\n        if (firstStamp > lastStamp) revert BucketLengthExceedsLimit();\\n\\n        uint256 len;\\n        unchecked {\\n            len = lastStamp - firstStamp;\\n        }\\n\\n        if (len > MAX_BUCKET_SIZE) {\\n            revert BucketLengthExceedsLimit();\\n        }\\n\\n        uint256[] memory result = new uint256[](len);\\n        uint256 resultIndex;\\n\\n        unchecked {\\n            (uint256 wordPos, uint256 bitPos) = position(firstStamp % MAX_BUCKET_SIZE);\\n\\n            uint256 wordVal = buckets[wordPos];\\n            uint256 mask = MASK << (bitPos * ELEMENT_BIT_SIZE);\\n\\n            for (uint256 i = firstStamp; i < lastStamp;) {\\n                assembly {\\n                    /// increase idx firstly to skip `array length`\\n                    resultIndex := add(resultIndex, 0x20)\\n                    /// wordVal store order starts from lowest bit\\n                    /// result[i] = ((wordVal & mask) >> (bitPos * ELEMENT_BIT_SIZE))\\n                    mstore(add(result, resultIndex), shr(mul(bitPos, ELEMENT_BIT_SIZE), and(wordVal, mask)))\\n                    mask := shl(ELEMENT_BIT_SIZE, mask)\\n                    bitPos := add(bitPos, 1)\\n                    i := add(i, 1)\\n                }\\n\\n                if (bitPos == WORD_ELEMENT_SIZE) {\\n                    (wordPos, bitPos) = position(i % MAX_BUCKET_SIZE);\\n\\n                    wordVal = buckets[wordPos];\\n                    mask = MASK;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    function set(mapping(uint256 => uint256) storage buckets, uint256 bucketStamp, uint256 value) internal {\\n        if (value > MASK) revert BucketValueExceedsLimit();\\n\\n        unchecked {\\n            (uint256 wordPos, uint256 bitPos) = position(bucketStamp % MAX_BUCKET_SIZE);\\n\\n            uint256 wordValue = buckets[wordPos];\\n            uint256 newValue = value << (bitPos * ELEMENT_BIT_SIZE);\\n\\n            uint256 newWord = (wordValue & ~(MASK << (bitPos * ELEMENT_BIT_SIZE))) | newValue;\\n            buckets[wordPos] = newWord;\\n        }\\n    }\\n\\n    function batchSet(mapping(uint256 => uint256) storage buckets, uint256 firstStamp, uint256[] memory values)\\n        internal\\n    {\\n        uint256 valLength = values.length;\\n        if (valLength > MAX_BUCKET_SIZE) revert BucketLengthExceedsLimit();\\n        if (firstStamp > (type(uint256).max - valLength)) {\\n            revert BucketLengthExceedsLimit();\\n        }\\n\\n        unchecked {\\n            (uint256 wordPos, uint256 bitPos) = position(firstStamp % MAX_BUCKET_SIZE);\\n\\n            uint256 wordValue = buckets[wordPos];\\n            uint256 mask = ~(MASK << (bitPos * ELEMENT_BIT_SIZE));\\n\\n            /// reuse val length as End Postion\\n            valLength = (valLength + 1) * 0x20;\\n            /// start from first element offset\\n            for (uint256 i = 0x20; i < valLength; i += 0x20) {\\n                uint256 val;\\n                assembly {\\n                    val := mload(add(values, i))\\n                }\\n                if (val > MASK) revert BucketValueExceedsLimit();\\n\\n                assembly {\\n                    /// newVal = val << (bitPos * BIT_SIZE)\\n                    let newVal := shl(mul(bitPos, ELEMENT_BIT_SIZE), val)\\n                    /// save newVal to wordVal, clear corresponding bits and set them as newVal\\n                    /// wordValue = (wordVal & mask) | newVal\\n                    wordValue := or(and(wordValue, mask), newVal)\\n                    /// goto next number idx in current word\\n                    bitPos := add(bitPos, 1)\\n                    /// mask = ~(MASK << (bitPos, BIT_SIZE))\\n                    mask := not(shl(mul(bitPos, ELEMENT_BIT_SIZE), MASK))\\n                }\\n\\n                if (bitPos == WORD_ELEMENT_SIZE) {\\n                    /// store hole word\\n                    buckets[wordPos] = wordValue;\\n\\n                    /// get next word' position\\n                    (wordPos, bitPos) = position((firstStamp + (i / 0x20)) % MAX_BUCKET_SIZE);\\n                    wordValue = buckets[wordPos];\\n                    /// restore mask to make it start from lowest bits\\n                    mask = ~MASK;\\n                }\\n            }\\n            /// store last word which may incomplete\\n            buckets[wordPos] = wordValue;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/library/TrustedUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {OwnedUpgradeable} from \\\"./OwnedUpgradeable.sol\\\";\\n\\nabstract contract TrustedUpgradeable is OwnedUpgradeable {\\n    event TrustedUpdated(address trusted, bool setOrUnset);\\n\\n    mapping(address => uint256) public whitelist;\\n\\n    modifier onlyTrusted() virtual {\\n        if (whitelist[msg.sender] == 0) revert Unauthorized();\\n\\n        _;\\n    }\\n\\n    function __Trusted_init() internal {\\n        __Owned_init();\\n        whitelist[owner] = 1;\\n    }\\n\\n    function setTrusted(address trusted) public virtual onlyOwner {\\n        whitelist[trusted] = 1;\\n        emit TrustedUpdated(trusted, true);\\n    }\\n\\n    function unsetTrusted(address trusted) public virtual onlyOwner {\\n        delete whitelist[trusted];\\n        emit TrustedUpdated(trusted, false);\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/logic/Auction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"openzeppelin-contracts/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport {SafeBox, CollectionState, AuctionInfo} from \\\"./Structs.sol\\\";\\nimport \\\"./User.sol\\\";\\nimport \\\"./Collection.sol\\\";\\nimport \\\"./Helper.sol\\\";\\nimport \\\"../Errors.sol\\\";\\nimport \\\"../Constants.sol\\\";\\nimport \\\"../interface/IFlooring.sol\\\";\\nimport {SafeBoxLib} from \\\"./SafeBox.sol\\\";\\nimport \\\"../library/RollingBuckets.sol\\\";\\n\\nlibrary AuctionLib {\\n    using SafeCast for uint256;\\n    using CollectionLib for CollectionState;\\n    using SafeBoxLib for SafeBox;\\n    using RollingBuckets for mapping(uint256 => uint256);\\n    using UserLib for UserFloorAccount;\\n    using UserLib for CollectionAccount;\\n    using Helper for CollectionState;\\n\\n    event AuctionStarted(\\n        address indexed trigger,\\n        address indexed collection,\\n        uint64[] activityIds,\\n        uint256[] tokenIds,\\n        address settleToken,\\n        uint256 minimumBid,\\n        uint256 feeRateBips,\\n        uint256 auctionEndTime,\\n        uint256 safeBoxExpiryTs,\\n        bool selfTriggered,\\n        uint256 adminFee\\n    );\\n\\n    event NewTopBidOnAuction(\\n        address indexed bidder,\\n        address indexed collection,\\n        uint64 activityId,\\n        uint256 tokenId,\\n        uint256 bidAmount,\\n        uint256 auctionEndTime,\\n        uint256 safeBoxExpiryTs\\n    );\\n\\n    event AuctionEnded(\\n        address indexed winner,\\n        address indexed collection,\\n        uint64 activityId,\\n        uint256 tokenId,\\n        uint256 safeBoxKeyId,\\n        uint256 collectedFunds\\n    );\\n\\n    function ownerInitAuctions(\\n        CollectionState storage collection,\\n        mapping(address => UserFloorAccount) storage userAccounts,\\n        address creditToken,\\n        address collectionId,\\n        uint256[] memory nftIds,\\n        uint256 maxExpiry,\\n        address token,\\n        uint256 minimumBid\\n    ) public {\\n        UserFloorAccount storage userAccount = userAccounts[msg.sender];\\n        uint256 adminFee = Constants.AUCTION_COST * nftIds.length;\\n        /// transfer fee to contract account\\n        userAccount.transferToken(userAccounts[address(this)], creditToken, adminFee, true);\\n\\n        AuctionInfo memory auctionTemplate;\\n        auctionTemplate.endTime = uint96(block.timestamp + Constants.AUCTION_INITIAL_PERIODS);\\n        auctionTemplate.bidTokenAddress = token;\\n        auctionTemplate.minimumBid = minimumBid.toUint96();\\n        auctionTemplate.triggerAddress = msg.sender;\\n        auctionTemplate.isSelfTriggered = true;\\n        auctionTemplate.feeRateBips =\\n            uint32(getAuctionFeeRate(true, creditToken, address(collection.floorToken), token));\\n        auctionTemplate.lastBidAmount = 0;\\n        auctionTemplate.lastBidder = address(0);\\n\\n        (uint64[] memory activityIds, uint192 newExpiryTs) =\\n            _ownerInitAuctions(collection, userAccount.getByKey(collectionId), nftIds, maxExpiry, auctionTemplate);\\n\\n        emit AuctionStarted(\\n            msg.sender,\\n            collectionId,\\n            activityIds,\\n            nftIds,\\n            token,\\n            minimumBid,\\n            auctionTemplate.feeRateBips,\\n            auctionTemplate.endTime,\\n            newExpiryTs,\\n            true,\\n            adminFee\\n        );\\n    }\\n\\n    function _ownerInitAuctions(\\n        CollectionState storage collectionState,\\n        CollectionAccount storage userAccount,\\n        uint256[] memory nftIds,\\n        uint256 maxExpiry,\\n        AuctionInfo memory auctionTemplate\\n    ) private returns (uint64[] memory activityIds, uint32 newExpiryTs) {\\n        newExpiryTs = uint32(auctionTemplate.endTime + Constants.AUCTION_COMPLETE_GRACE_PERIODS);\\n\\n        uint256 firstIdx = Helper.counterStamp(newExpiryTs) - Helper.counterStamp(block.timestamp);\\n\\n        uint256[] memory toUpdateBucket;\\n        /// if maxExpiryTs == 0, it means all nftIds in this batch being locked infinitely that we don't need to update countingBuckets\\n        if (maxExpiry > 0) {\\n            toUpdateBucket = collectionState.countingBuckets.batchGet(\\n                Helper.counterStamp(block.timestamp),\\n                Math.min(Helper.counterStamp(maxExpiry), collectionState.lastUpdatedBucket)\\n            );\\n        }\\n\\n        activityIds = new uint64[](nftIds.length);\\n        for (uint256 i = 0; i < nftIds.length;) {\\n            if (collectionState.hasActiveActivities(nftIds[i])) revert Errors.NftHasActiveActivities();\\n\\n            (SafeBox storage safeBox,) = collectionState.useSafeBoxAndKey(userAccount, nftIds[i]);\\n\\n            if (safeBox.isInfiniteSafeBox()) {\\n                --collectionState.infiniteCnt;\\n            } else {\\n                uint256 oldExpiryTs = safeBox.expiryTs;\\n                if (oldExpiryTs < newExpiryTs) {\\n                    revert Errors.InvalidParam();\\n                }\\n                uint256 lastIdx = Helper.counterStamp(oldExpiryTs) - Helper.counterStamp(block.timestamp);\\n                if (firstIdx > lastIdx || lastIdx > toUpdateBucket.length) revert Errors.InvalidParam();\\n                for (uint256 k = firstIdx; k < lastIdx;) {\\n                    --toUpdateBucket[k];\\n                    unchecked {\\n                        ++k;\\n                    }\\n                }\\n            }\\n\\n            safeBox.expiryTs = newExpiryTs;\\n\\n            activityIds[i] = collectionState.generateNextActivityId();\\n\\n            auctionTemplate.activityId = activityIds[i];\\n            collectionState.activeAuctions[nftIds[i]] = auctionTemplate;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        if (toUpdateBucket.length > 0) {\\n            collectionState.countingBuckets.batchSet(Helper.counterStamp(block.timestamp), toUpdateBucket);\\n        }\\n    }\\n\\n    function initAuctionOnExpiredSafeBoxes(\\n        CollectionState storage collection,\\n        mapping(address => UserFloorAccount) storage userAccounts,\\n        address creditToken,\\n        address collectionId,\\n        uint256[] memory nftIds,\\n        uint256 bidAmount\\n    ) public {\\n        if (bidAmount < Constants.AUCTION_ON_EXPIRED_MINIMUM_BID) revert Errors.InvalidParam();\\n\\n        AuctionInfo memory auctionTemplate;\\n        auctionTemplate.endTime = uint96(block.timestamp + Constants.AUCTION_INITIAL_PERIODS);\\n        auctionTemplate.bidTokenAddress = creditToken;\\n        auctionTemplate.minimumBid = bidAmount.toUint96();\\n        auctionTemplate.triggerAddress = msg.sender;\\n        auctionTemplate.isSelfTriggered = false;\\n        auctionTemplate.feeRateBips =\\n            uint32(getAuctionFeeRate(false, creditToken, address(collection.floorToken), creditToken));\\n        auctionTemplate.lastBidAmount = bidAmount.toUint96();\\n        auctionTemplate.lastBidder = msg.sender;\\n\\n        (uint64[] memory activityIds, uint192 newExpiry) =\\n            _initAuctionOnExpiredSafeBoxes(collection, nftIds, auctionTemplate);\\n\\n        uint256 adminFee = Constants.AUCTION_ON_EXPIRED_SAFEBOX_COST * nftIds.length;\\n        userAccounts[msg.sender].transferToken(\\n            userAccounts[address(this)], creditToken, bidAmount * nftIds.length + adminFee, true\\n        );\\n\\n        emit AuctionStarted(\\n            msg.sender,\\n            collectionId,\\n            activityIds,\\n            nftIds,\\n            creditToken,\\n            bidAmount,\\n            auctionTemplate.feeRateBips,\\n            auctionTemplate.endTime,\\n            newExpiry,\\n            false,\\n            adminFee\\n        );\\n    }\\n\\n    function _initAuctionOnExpiredSafeBoxes(\\n        CollectionState storage collectionState,\\n        uint256[] memory nftIds,\\n        AuctionInfo memory auctionTemplate\\n    ) private returns (uint64[] memory activityIds, uint32 newExpiry) {\\n        newExpiry = uint32(auctionTemplate.endTime + Constants.AUCTION_COMPLETE_GRACE_PERIODS);\\n\\n        activityIds = new uint64[](nftIds.length);\\n        for (uint256 idx; idx < nftIds.length;) {\\n            uint256 nftId = nftIds[idx];\\n            if (collectionState.hasActiveActivities(nftId)) revert Errors.NftHasActiveActivities();\\n\\n            SafeBox storage safeBox = collectionState.useSafeBox(nftId);\\n            if (!safeBox.isSafeBoxExpired()) revert Errors.SafeBoxHasNotExpire();\\n            if (Helper.isAuctionPeriodOver(safeBox)) revert Errors.SafeBoxAuctionWindowHasPassed();\\n\\n            activityIds[idx] = collectionState.generateNextActivityId();\\n            auctionTemplate.activityId = activityIds[idx];\\n            collectionState.activeAuctions[nftId] = auctionTemplate;\\n\\n            /// We keep the owner of safebox unchanged, and it will be used to distribute auction funds\\n            safeBox.expiryTs = newExpiry;\\n            safeBox.keyId = SafeBoxLib.SAFEBOX_KEY_NOTATION;\\n\\n            unchecked {\\n                ++idx;\\n            }\\n        }\\n\\n        applyDiffToCounters(\\n            collectionState, Helper.counterStamp(block.timestamp), Helper.counterStamp(newExpiry), int256(nftIds.length)\\n        );\\n    }\\n\\n    struct BidParam {\\n        uint256 nftId;\\n        uint96 bidAmount;\\n        address bidder;\\n        uint256 extendDuration;\\n        uint256 minIncrPct;\\n    }\\n\\n    function placeBidOnAuction(\\n        CollectionState storage collection,\\n        mapping(address => UserFloorAccount) storage userAccounts,\\n        address creditToken,\\n        address collectionId,\\n        uint256 nftId,\\n        uint256 bidAmount,\\n        uint256 bidOptionIdx\\n    ) public {\\n        uint256 prevBidAmount;\\n        address prevBidder;\\n        {\\n            Constants.AuctionBidOption memory bidOption = Constants.getBidOption(bidOptionIdx);\\n            userAccounts[msg.sender].ensureVipCredit(uint8(bidOption.vipLevel), creditToken);\\n\\n            (prevBidAmount, prevBidder) = _placeBidOnAuction(\\n                collection,\\n                BidParam(\\n                    nftId, bidAmount.toUint96(), msg.sender, bidOption.extendDurationSecs, bidOption.minimumRaisePct\\n                )\\n            );\\n        }\\n\\n        AuctionInfo memory auction = collection.activeAuctions[nftId];\\n\\n        address bidToken = auction.bidTokenAddress;\\n        userAccounts[msg.sender].transferToken(\\n            userAccounts[address(this)], bidToken, bidAmount, bidToken == creditToken\\n        );\\n\\n        if (prevBidAmount > 0) {\\n            /// refund previous bid\\n            /// contract account no need to check credit requirements\\n            userAccounts[address(this)].transferToken(userAccounts[prevBidder], bidToken, prevBidAmount, false);\\n        }\\n\\n        SafeBox memory safebox = collection.safeBoxes[nftId];\\n        emit NewTopBidOnAuction(\\n            msg.sender, collectionId, auction.activityId, nftId, bidAmount, auction.endTime, safebox.expiryTs\\n        );\\n    }\\n\\n    function _placeBidOnAuction(CollectionState storage collectionState, BidParam memory param)\\n        private\\n        returns (uint128 prevBidAmount, address prevBidder)\\n    {\\n        AuctionInfo storage auctionInfo = collectionState.activeAuctions[param.nftId];\\n\\n        SafeBox storage safeBox = collectionState.useSafeBox(param.nftId);\\n        uint256 endTime = auctionInfo.endTime;\\n        {\\n            (prevBidAmount, prevBidder) = (auctionInfo.lastBidAmount, auctionInfo.lastBidder);\\n            // param check\\n            if (endTime == 0) revert Errors.AuctionNotExist();\\n            if (endTime <= block.timestamp) revert Errors.AuctionHasExpire();\\n            if (prevBidAmount >= param.bidAmount || auctionInfo.minimumBid > param.bidAmount) {\\n                revert Errors.AuctionBidIsNotHighEnough();\\n            }\\n            if (prevBidder == param.bidder) revert Errors.AuctionSelfBid();\\n            // owner starts auction, can not bid by himself\\n            if (auctionInfo.isSelfTriggered && param.bidder == safeBox.owner) revert Errors.AuctionSelfBid();\\n\\n            if (prevBidAmount > 0 && !isValidNewBid(param.bidAmount, prevBidAmount, param.minIncrPct)) {\\n                revert Errors.AuctionInvalidBidAmount();\\n            }\\n        }\\n\\n        /// Changing safebox key id which means the corresponding safebox key doesn't hold the safebox now\\n        safeBox.keyId = SafeBoxLib.SAFEBOX_KEY_NOTATION;\\n\\n        uint256 newAuctionEndTime = block.timestamp + param.extendDuration;\\n        if (newAuctionEndTime > endTime) {\\n            uint256 newSafeBoxExpiryTs = newAuctionEndTime + Constants.AUCTION_COMPLETE_GRACE_PERIODS;\\n            applyDiffToCounters(\\n                collectionState, Helper.counterStamp(safeBox.expiryTs), Helper.counterStamp(newSafeBoxExpiryTs), 1\\n            );\\n\\n            safeBox.expiryTs = uint32(newSafeBoxExpiryTs);\\n            auctionInfo.endTime = uint96(newAuctionEndTime);\\n        }\\n\\n        auctionInfo.lastBidAmount = param.bidAmount;\\n        auctionInfo.lastBidder = param.bidder;\\n    }\\n\\n    function settleAuctions(\\n        CollectionState storage collection,\\n        mapping(address => UserFloorAccount) storage userAccounts,\\n        address collectionId,\\n        uint256[] memory nftIds\\n    ) public {\\n        for (uint256 i; i < nftIds.length;) {\\n            uint256 nftId = nftIds[i];\\n            SafeBox storage safebox = Helper.useSafeBox(collection, nftId);\\n\\n            if (safebox.isSafeBoxExpired()) revert Errors.SafeBoxHasExpire();\\n\\n            AuctionInfo memory auctionInfo = collection.activeAuctions[nftId];\\n            if (auctionInfo.endTime == 0) revert Errors.AuctionNotExist();\\n            if (auctionInfo.endTime > block.timestamp) revert Errors.AuctionHasNotCompleted();\\n            /// noone bid on the aciton, can not be settled\\n            if (auctionInfo.lastBidder == address(0)) revert Errors.AuctionHasNotCompleted();\\n\\n            (uint256 earning,) = Helper.calculateActivityFee(auctionInfo.lastBidAmount, auctionInfo.feeRateBips);\\n            /// contract account no need to check credit requirements\\n            /// transfer earnings to old safebox owner\\n            userAccounts[address(this)].transferToken(\\n                userAccounts[safebox.owner], auctionInfo.bidTokenAddress, earning, false\\n            );\\n\\n            /// transfer safebox\\n            address winner = auctionInfo.lastBidder;\\n            SafeBoxKey memory key = SafeBoxKey({keyId: collection.generateNextKeyId(), lockingCredit: 0, vipLevel: 0});\\n\\n            safebox.keyId = key.keyId;\\n            safebox.owner = winner;\\n\\n            UserFloorAccount storage account = userAccounts[winner];\\n            CollectionAccount storage userCollectionAccount = account.getByKey(collectionId);\\n            userCollectionAccount.addSafeboxKey(nftId, key);\\n\\n            delete collection.activeAuctions[nftId];\\n\\n            emit AuctionEnded(winner, collectionId, auctionInfo.activityId, nftId, key.keyId, auctionInfo.lastBidAmount);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function isValidNewBid(uint256 newBid, uint256 previousBid, uint256 minRaisePct) private pure returns (bool) {\\n        uint256 minIncrement = previousBid * minRaisePct / 100;\\n        if (minIncrement < 1) {\\n            minIncrement = 1;\\n        }\\n\\n        if (newBid < previousBid + minIncrement) {\\n            return false;\\n        }\\n        // think: always thought this should be previousBid....\\n        uint256 newIncrementAmount = newBid / 100;\\n        if (newIncrementAmount < 1) {\\n            newIncrementAmount = 1;\\n        }\\n        return newBid % newIncrementAmount == 0;\\n    }\\n\\n    function applyDiffToCounters(\\n        CollectionState storage collectionState,\\n        uint256 startBucket,\\n        uint256 endBucket,\\n        int256 diff\\n    ) private {\\n        if (startBucket == endBucket) return;\\n        uint256[] memory buckets = Helper.prepareBucketUpdate(collectionState, startBucket, endBucket);\\n        unchecked {\\n            uint256 bucketLen = buckets.length;\\n            if (diff > 0) {\\n                uint256 tmp = uint256(diff);\\n                for (uint256 i; i < bucketLen; ++i) {\\n                    buckets[i] += tmp;\\n                }\\n            } else {\\n                uint256 tmp = uint256(-diff);\\n                for (uint256 i; i < bucketLen; ++i) {\\n                    buckets[i] -= tmp;\\n                }\\n            }\\n        }\\n        collectionState.countingBuckets.batchSet(startBucket, buckets);\\n        if (endBucket > collectionState.lastUpdatedBucket) {\\n            collectionState.lastUpdatedBucket = uint64(endBucket);\\n        }\\n    }\\n\\n    function getAuctionFeeRate(bool isSelfTriggered, address creditToken, address floorToken, address settleToken)\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        if (isSelfTriggered) {\\n            /// owner self trigger the aution\\n            return Helper.getTokenFeeRateBips(creditToken, floorToken, settleToken);\\n        } else {\\n            return Constants.FREE_AUCTION_FEE_RATE_BIPS;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/logic/Collection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"openzeppelin-contracts/contracts/utils/math/Math.sol\\\";\\nimport \\\"openzeppelin-contracts/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport \\\"../library/RollingBuckets.sol\\\";\\nimport \\\"../library/ERC721Transfer.sol\\\";\\n\\nimport \\\"../Errors.sol\\\";\\nimport \\\"../Constants.sol\\\";\\nimport \\\"./User.sol\\\";\\nimport \\\"./Helper.sol\\\";\\nimport {SafeBox, CollectionState, AuctionInfo, CollectionAccount, UserFloorAccount, LockParam} from \\\"./Structs.sol\\\";\\nimport {SafeBoxLib} from \\\"./SafeBox.sol\\\";\\n\\nimport \\\"../interface/IFlooring.sol\\\";\\n\\nlibrary CollectionLib {\\n    using SafeBoxLib for SafeBox;\\n    using SafeCast for uint256;\\n    using RollingBuckets for mapping(uint256 => uint256);\\n    using UserLib for CollectionAccount;\\n    using UserLib for UserFloorAccount;\\n\\n    event LockNft(\\n        address indexed sender,\\n        address indexed onBehalfOf,\\n        address indexed collection,\\n        uint256[] tokenIds,\\n        uint256[] safeBoxKeys,\\n        uint256 safeBoxExpiryTs,\\n        uint256 minMaintCredit,\\n        address proxyCollection\\n    );\\n    event ExtendKey(\\n        address indexed operator,\\n        address indexed collection,\\n        uint256[] tokenIds,\\n        uint256[] safeBoxKeys,\\n        uint256 safeBoxExpiryTs,\\n        uint256 minMaintCredit\\n    );\\n    event UnlockNft(\\n        address indexed operator,\\n        address indexed receiver,\\n        address indexed collection,\\n        uint256[] tokenIds,\\n        address proxyCollection\\n    );\\n    event RemoveExpiredKey(\\n        address indexed operator,\\n        address indexed onBehalfOf,\\n        address indexed collection,\\n        uint256[] tokenIds,\\n        uint256[] safeBoxKeys\\n    );\\n    event ClaimExpiredNft(\\n        address indexed operator,\\n        address indexed receiver,\\n        address indexed collection,\\n        uint256[] tokenIds,\\n        uint256 creditCost,\\n        address proxyCollection\\n    );\\n    event FragmentNft(\\n        address indexed operator, address indexed onBehalfOf, address indexed collection, uint256[] tokenIds\\n    );\\n    event ClaimRandomNft(\\n        address indexed operator,\\n        address indexed receiver,\\n        address indexed collection,\\n        uint256[] tokenIds,\\n        uint256 creditCost\\n    );\\n\\n    function fragmentNFTs(\\n        CollectionState storage collectionState,\\n        address collection,\\n        uint256[] memory nftIds,\\n        address onBehalfOf\\n    ) public {\\n        uint256 nftLen = nftIds.length;\\n        unchecked {\\n            for (uint256 i; i < nftLen; ++i) {\\n                collectionState.freeTokenIds.push(nftIds[i]);\\n            }\\n        }\\n        collectionState.floorToken.mint(onBehalfOf, Constants.FLOOR_TOKEN_AMOUNT * nftLen);\\n        ERC721Transfer.safeBatchTransferFrom(collection, msg.sender, address(this), nftIds);\\n\\n        emit FragmentNft(msg.sender, onBehalfOf, collection, nftIds);\\n    }\\n\\n    struct LockInfo {\\n        bool isInfinite;\\n        uint256 currentBucket;\\n        uint256 newExpiryBucket;\\n        uint256 totalManaged;\\n        uint256 newRequireLockCredit;\\n        uint64 infiniteCnt;\\n    }\\n\\n    function lockNfts(\\n        CollectionState storage collection,\\n        UserFloorAccount storage account,\\n        LockParam memory param,\\n        address onBehalfOf\\n    ) public returns (uint256 totalCreditCost) {\\n        if (onBehalfOf == address(this)) revert Errors.InvalidParam();\\n\\n        uint8 vipLevel = uint8(param.vipLevel);\\n        uint256 totalCredit = account.ensureVipCredit(vipLevel, param.creditToken);\\n        Helper.ensureMaxLocking(collection, vipLevel, param.expiryTs, param.nftIds.length);\\n        Helper.ensureProxyVipLevel(Constants.getVipLevel(totalCredit), param.collection != param.proxyCollection);\\n\\n        /// cache value to avoid multi-reads\\n        uint256 minMaintCredit = account.minMaintCredit;\\n        uint256[] memory nftIds = param.nftIds;\\n        uint256[] memory newKeys;\\n        {\\n            CollectionAccount storage userCollectionAccount = account.getOrAddCollection(param.collection);\\n\\n            (totalCreditCost, newKeys) = _lockNfts(collection, userCollectionAccount, nftIds, param.expiryTs, vipLevel);\\n\\n            // compute max credit for locking cost\\n            uint96 totalLockingCredit = userCollectionAccount.totalLockingCredit;\\n            {\\n                uint256 creditBuffer;\\n                unchecked {\\n                    creditBuffer = totalCredit - totalLockingCredit;\\n                }\\n                if (totalCreditCost > creditBuffer || totalCreditCost > param.maxCreditCost) {\\n                    revert Errors.InsufficientCredit();\\n                }\\n            }\\n\\n            totalLockingCredit += totalCreditCost.toUint96();\\n            userCollectionAccount.totalLockingCredit = totalLockingCredit;\\n\\n            if (totalLockingCredit > minMaintCredit) {\\n                account.minMaintCredit = totalLockingCredit;\\n                minMaintCredit = totalLockingCredit;\\n            }\\n        }\\n\\n        account.updateVipKeyCount(vipLevel, int256(nftIds.length));\\n        /// mint for `onBehalfOf`, transfer from msg.sender\\n        collection.floorToken.mint(onBehalfOf, Constants.FLOOR_TOKEN_AMOUNT * nftIds.length);\\n        ERC721Transfer.safeBatchTransferFrom(param.proxyCollection, msg.sender, address(this), nftIds);\\n\\n        emit LockNft(\\n            msg.sender,\\n            onBehalfOf,\\n            param.collection,\\n            nftIds,\\n            newKeys,\\n            param.expiryTs,\\n            minMaintCredit,\\n            param.proxyCollection\\n        );\\n    }\\n\\n    function _lockNfts(\\n        CollectionState storage collectionState,\\n        CollectionAccount storage account,\\n        uint256[] memory nftIds,\\n        uint256 expiryTs, // treat 0 as infinite lock.\\n        uint8 vipLevel\\n    ) private returns (uint256, uint256[] memory) {\\n        LockInfo memory info = LockInfo({\\n            isInfinite: expiryTs == 0,\\n            currentBucket: Helper.counterStamp(block.timestamp),\\n            newExpiryBucket: Helper.counterStamp(expiryTs),\\n            totalManaged: collectionState.activeSafeBoxCnt + collectionState.freeTokenIds.length,\\n            newRequireLockCredit: 0,\\n            infiniteCnt: collectionState.infiniteCnt\\n        });\\n        if (info.isInfinite) {\\n            /// if it is infinite lock, we need load all buckets to calculate the staking cost\\n            info.newExpiryBucket = Helper.counterStamp(block.timestamp + Constants.MAX_LOCKING_PERIOD);\\n        }\\n\\n        uint256[] memory buckets = Helper.prepareBucketUpdate(collectionState, info.currentBucket, info.newExpiryBucket);\\n        /// @dev `keys` used to log info, we just compact its fields into one 256 bits number\\n        uint256[] memory keys = new uint256[](nftIds.length);\\n\\n        for (uint256 idx; idx < nftIds.length;) {\\n            uint256 lockedCredit = updateCountersAndGetSafeboxCredit(buckets, info, vipLevel);\\n\\n            if (info.isInfinite) ++info.infiniteCnt;\\n\\n            SafeBoxKey memory key = SafeBoxKey({\\n                keyId: Helper.generateNextKeyId(collectionState),\\n                lockingCredit: lockedCredit.toUint96(),\\n                vipLevel: vipLevel\\n            });\\n\\n            account.addSafeboxKey(nftIds[idx], key);\\n            addSafeBox(\\n                collectionState, nftIds[idx], SafeBox({keyId: key.keyId, expiryTs: uint32(expiryTs), owner: msg.sender})\\n            );\\n\\n            keys[idx] = SafeBoxLib.encodeSafeBoxKey(key);\\n\\n            info.newRequireLockCredit += lockedCredit;\\n            unchecked {\\n                ++info.totalManaged;\\n                ++idx;\\n            }\\n        }\\n\\n        if (info.isInfinite) {\\n            collectionState.infiniteCnt = info.infiniteCnt;\\n        } else {\\n            collectionState.countingBuckets.batchSet(info.currentBucket, buckets);\\n            if (info.newExpiryBucket > collectionState.lastUpdatedBucket) {\\n                collectionState.lastUpdatedBucket = uint64(info.newExpiryBucket);\\n            }\\n        }\\n\\n        return (info.newRequireLockCredit, keys);\\n    }\\n\\n    function unlockNfts(\\n        CollectionState storage collection,\\n        UserFloorAccount storage userAccount,\\n        address proxyCollection,\\n        address collectionId,\\n        uint256[] memory nftIds,\\n        uint256 maxExpiryTs,\\n        address receiver\\n    ) public {\\n        CollectionAccount storage userCollectionAccount = userAccount.getByKey(collectionId);\\n        SafeBoxKey[] memory releasedKeys = _unlockNfts(collection, maxExpiryTs, nftIds, userCollectionAccount);\\n\\n        collection.floorToken.burn(msg.sender, Constants.FLOOR_TOKEN_AMOUNT * nftIds.length);\\n\\n        for (uint256 i = 0; i < releasedKeys.length;) {\\n            userAccount.updateVipKeyCount(releasedKeys[i].vipLevel, -1);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        ERC721Transfer.safeBatchTransferFrom(proxyCollection, address(this), receiver, nftIds);\\n\\n        emit UnlockNft(msg.sender, receiver, collectionId, nftIds, proxyCollection);\\n    }\\n\\n    function _unlockNfts(\\n        CollectionState storage collectionState,\\n        uint256 maxExpiryTs,\\n        uint256[] memory nftIds,\\n        CollectionAccount storage userCollectionAccount\\n    ) private returns (SafeBoxKey[] memory) {\\n        if (maxExpiryTs > 0 && maxExpiryTs < block.timestamp) revert Errors.SafeBoxHasExpire();\\n        SafeBoxKey[] memory expiredKeys = new SafeBoxKey[](nftIds.length);\\n        uint256 currentBucketTime = Helper.counterStamp(block.timestamp);\\n        uint256 creditToRelease = 0;\\n        uint256[] memory buckets;\\n\\n        /// if maxExpiryTs == 0, it means all nftIds in this batch being locked infinitely that we don't need to update countingBuckets\\n        if (maxExpiryTs > 0) {\\n            uint256 maxExpiryBucketTime = Math.min(Helper.counterStamp(maxExpiryTs), collectionState.lastUpdatedBucket);\\n            buckets = collectionState.countingBuckets.batchGet(currentBucketTime, maxExpiryBucketTime);\\n        }\\n\\n        for (uint256 i; i < nftIds.length;) {\\n            uint256 nftId = nftIds[i];\\n\\n            if (Helper.hasActiveActivities(collectionState, nftId)) revert Errors.NftHasActiveActivities();\\n\\n            (SafeBox storage safeBox, SafeBoxKey storage safeBoxKey) =\\n                Helper.useSafeBoxAndKey(collectionState, userCollectionAccount, nftId);\\n\\n            creditToRelease += safeBoxKey.lockingCredit;\\n            if (safeBox.isInfiniteSafeBox()) {\\n                --collectionState.infiniteCnt;\\n            } else {\\n                uint256 limit = Helper.counterStamp(safeBox.expiryTs) - currentBucketTime;\\n                if (limit > buckets.length) revert();\\n                for (uint256 idx; idx < limit;) {\\n                    --buckets[idx];\\n                    unchecked {\\n                        ++idx;\\n                    }\\n                }\\n            }\\n\\n            expiredKeys[i] = safeBoxKey;\\n\\n            removeSafeBox(collectionState, nftId);\\n            userCollectionAccount.removeSafeboxKey(nftId);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        userCollectionAccount.totalLockingCredit -= creditToRelease.toUint96();\\n        if (buckets.length > 0) {\\n            collectionState.countingBuckets.batchSet(currentBucketTime, buckets);\\n        }\\n\\n        return expiredKeys;\\n    }\\n\\n    function claimExpiredNfts(\\n        CollectionState storage collectionState,\\n        mapping(address => UserFloorAccount) storage userAccounts,\\n        address creditToken,\\n        address proxyCollection,\\n        address collectionId,\\n        uint256[] memory nftIds,\\n        uint256 maxCreditCost,\\n        address receiver\\n    ) public returns (uint256 totalCreditCost) {\\n        for (uint256 i = 0; i < nftIds.length;) {\\n            SafeBox storage safeBox = Helper.useSafeBox(collectionState, nftIds[i]);\\n            if (!safeBox.isSafeBoxExpired()) revert Errors.SafeBoxHasNotExpire();\\n            if (!Helper.isAuctionPeriodOver(safeBox)) revert Errors.AuctionHasNotCompleted();\\n\\n            removeSafeBox(collectionState, nftIds[i]);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        uint256 freeAmount = collectionState.freeTokenIds.length;\\n        UserFloorAccount storage userAccount = userAccounts[msg.sender];\\n\\n        totalCreditCost = nftIds.length\\n            * Constants.getClaimExpiredCost(\\n                freeAmount,\\n                collectionState.activeSafeBoxCnt + freeAmount,\\n                Constants.getVipLevel(userAccount.tokenBalance(creditToken))\\n            );\\n        if (totalCreditCost > maxCreditCost) {\\n            revert Errors.InsufficientCredit();\\n        }\\n\\n        userAccount.transferToken(userAccounts[address(this)], creditToken, totalCreditCost, true);\\n        collectionState.floorToken.burn(msg.sender, Constants.FLOOR_TOKEN_AMOUNT * nftIds.length);\\n        ERC721Transfer.safeBatchTransferFrom(proxyCollection, address(this), receiver, nftIds);\\n\\n        emit ClaimExpiredNft(msg.sender, receiver, collectionId, nftIds, totalCreditCost, proxyCollection);\\n    }\\n\\n    function extendLockingForKeys(\\n        CollectionState storage collection,\\n        UserFloorAccount storage userAccount,\\n        LockParam memory param\\n    ) public returns (uint256 totalCreditCost) {\\n        uint8 newVipLevel = uint8(param.vipLevel);\\n        uint256 totalCredit = userAccount.ensureVipCredit(newVipLevel, param.creditToken);\\n        Helper.ensureMaxLocking(collection, newVipLevel, param.expiryTs, param.nftIds.length);\\n\\n        uint256 minMaintCredit = userAccount.minMaintCredit;\\n        uint256[] memory safeBoxKeys;\\n        {\\n            CollectionAccount storage collectionAccount = userAccount.getOrAddCollection(param.collection);\\n\\n            // extend lock duration\\n            int256[] memory vipLevelDiffs;\\n            (vipLevelDiffs, totalCreditCost, safeBoxKeys) =\\n                _extendLockingForKeys(collection, collectionAccount, param.nftIds, param.expiryTs, uint8(newVipLevel));\\n\\n            // compute max credit for locking cost\\n            uint96 totalLockingCredit = collectionAccount.totalLockingCredit;\\n            {\\n                uint256 creditBuffer;\\n                unchecked {\\n                    creditBuffer = totalCredit - totalLockingCredit;\\n                }\\n                if (totalCreditCost > creditBuffer || totalCreditCost > param.maxCreditCost) {\\n                    revert Errors.InsufficientCredit();\\n                }\\n            }\\n\\n            // update user vip key counts\\n            for (uint256 vipLevel = 0; vipLevel < vipLevelDiffs.length;) {\\n                userAccount.updateVipKeyCount(uint8(vipLevel), vipLevelDiffs[vipLevel]);\\n                unchecked {\\n                    ++vipLevel;\\n                }\\n            }\\n\\n            totalLockingCredit += totalCreditCost.toUint96();\\n            collectionAccount.totalLockingCredit = totalLockingCredit;\\n            if (totalLockingCredit > minMaintCredit) {\\n                userAccount.minMaintCredit = totalLockingCredit;\\n                minMaintCredit = totalLockingCredit;\\n            }\\n        }\\n\\n        emit ExtendKey(msg.sender, param.collection, param.nftIds, safeBoxKeys, param.expiryTs, minMaintCredit);\\n    }\\n\\n    function _extendLockingForKeys(\\n        CollectionState storage collectionState,\\n        CollectionAccount storage userCollectionAccount,\\n        uint256[] memory nftIds,\\n        uint256 newExpiryTs, // expiryTs of 0 is infinite.\\n        uint8 newVipLevel\\n    ) private returns (int256[] memory, uint256, uint256[] memory) {\\n        LockInfo memory info = LockInfo({\\n            isInfinite: newExpiryTs == 0,\\n            currentBucket: Helper.counterStamp(block.timestamp),\\n            newExpiryBucket: Helper.counterStamp(newExpiryTs),\\n            totalManaged: collectionState.activeSafeBoxCnt + collectionState.freeTokenIds.length,\\n            newRequireLockCredit: 0,\\n            infiniteCnt: collectionState.infiniteCnt\\n        });\\n        if (info.isInfinite) {\\n            info.newExpiryBucket = Helper.counterStamp(block.timestamp + Constants.MAX_LOCKING_PERIOD);\\n        }\\n\\n        uint256[] memory buckets = Helper.prepareBucketUpdate(collectionState, info.currentBucket, info.newExpiryBucket);\\n        int256[] memory vipLevelDiffs = new int256[](Constants.VIP_LEVEL_COUNT);\\n        /// @dev `keys` used to log info, we just compact its fields into one 256 bits number\\n        uint256[] memory keys = new uint256[](nftIds.length);\\n\\n        for (uint256 idx; idx < nftIds.length;) {\\n            if (Helper.hasActiveActivities(collectionState, nftIds[idx])) revert Errors.NftHasActiveActivities();\\n\\n            (SafeBox storage safeBox, SafeBoxKey storage safeBoxKey) =\\n                Helper.useSafeBoxAndKey(collectionState, userCollectionAccount, nftIds[idx]);\\n\\n            {\\n                uint256 extendOffset = Helper.counterStamp(safeBox.expiryTs) - info.currentBucket;\\n                unchecked {\\n                    for (uint256 i; i < extendOffset; ++i) {\\n                        if (buckets[i] == 0) revert Errors.InvalidParam();\\n                        --buckets[i];\\n                    }\\n                }\\n            }\\n\\n            uint256 safeboxQuote = updateCountersAndGetSafeboxCredit(buckets, info, newVipLevel);\\n\\n            if (safeboxQuote > safeBoxKey.lockingCredit) {\\n                info.newRequireLockCredit += (safeboxQuote - safeBoxKey.lockingCredit);\\n                safeBoxKey.lockingCredit = safeboxQuote.toUint96();\\n            }\\n\\n            uint8 oldVipLevel = safeBoxKey.vipLevel;\\n            if (newVipLevel > oldVipLevel) {\\n                safeBoxKey.vipLevel = newVipLevel;\\n                --vipLevelDiffs[oldVipLevel];\\n                ++vipLevelDiffs[newVipLevel];\\n            }\\n\\n            if (info.isInfinite) {\\n                safeBox.expiryTs = 0;\\n                ++info.infiniteCnt;\\n            } else {\\n                safeBox.expiryTs = uint32(newExpiryTs);\\n            }\\n\\n            keys[idx] = SafeBoxLib.encodeSafeBoxKey(safeBoxKey);\\n\\n            unchecked {\\n                ++idx;\\n            }\\n        }\\n\\n        if (info.isInfinite) {\\n            collectionState.infiniteCnt = info.infiniteCnt;\\n        } else {\\n            collectionState.countingBuckets.batchSet(info.currentBucket, buckets);\\n            if (info.newExpiryBucket > collectionState.lastUpdatedBucket) {\\n                collectionState.lastUpdatedBucket = uint64(info.newExpiryBucket);\\n            }\\n        }\\n        return (vipLevelDiffs, info.newRequireLockCredit, keys);\\n    }\\n\\n    function updateCountersAndGetSafeboxCredit(uint256[] memory counters, LockInfo memory lockInfo, uint8 vipLevel)\\n        private\\n        pure\\n        returns (uint256 result)\\n    {\\n        unchecked {\\n            uint256 infiniteCnt = lockInfo.infiniteCnt;\\n            uint256 totalManaged = lockInfo.totalManaged;\\n\\n            uint256 counterOffsetEnd = (counters.length + 1) * 0x20;\\n            uint256 tmpCount;\\n            if (lockInfo.isInfinite) {\\n                for (uint256 i = 0x20; i < counterOffsetEnd; i += 0x20) {\\n                    assembly {\\n                        tmpCount := mload(add(counters, i))\\n                    }\\n                    result += Constants.getRequiredStakingForLockRatio(infiniteCnt + tmpCount, totalManaged);\\n                }\\n            } else {\\n                for (uint256 i = 0x20; i < counterOffsetEnd; i += 0x20) {\\n                    assembly {\\n                        tmpCount := mload(add(counters, i))\\n                    }\\n                    result += Constants.getRequiredStakingForLockRatio(infiniteCnt + tmpCount, totalManaged);\\n                    assembly {\\n                        /// increase counters[i]\\n                        mstore(add(counters, i), add(tmpCount, 1))\\n                    }\\n                }\\n            }\\n            result = Constants.getVipRequiredStakingWithDiscount(result, vipLevel);\\n        }\\n    }\\n\\n    function removeExpiredKeysAndRestoreCredits(\\n        CollectionState storage collectionState,\\n        UserFloorAccount storage userAccount,\\n        address collectionId,\\n        uint256[] memory nftIds,\\n        address onBehalfOf\\n    ) public returns (uint256 releasedCredit) {\\n        CollectionAccount storage collectionAccount = userAccount.getByKey(collectionId);\\n\\n        uint256 removedCnt;\\n        uint256[] memory removedIds = new uint256[](nftIds.length);\\n        uint256[] memory removedKeys = new uint256[](nftIds.length);\\n        for (uint256 i = 0; i < nftIds.length;) {\\n            uint256 nftId = nftIds[i];\\n            SafeBoxKey memory safeBoxKey = collectionAccount.getByKey(nftId);\\n            SafeBox memory safeBox = collectionState.safeBoxes[nftId];\\n\\n            if (safeBoxKey.keyId == 0) {\\n                revert Errors.InvalidParam();\\n            }\\n\\n            if (safeBox._isSafeBoxExpired() || !safeBox._isKeyMatchingSafeBox(safeBoxKey)) {\\n                removedIds[removedCnt] = nftId;\\n                removedKeys[removedCnt] = SafeBoxLib.encodeSafeBoxKey(safeBoxKey);\\n\\n                unchecked {\\n                    ++removedCnt;\\n                    releasedCredit += safeBoxKey.lockingCredit;\\n                }\\n\\n                userAccount.updateVipKeyCount(safeBoxKey.vipLevel, -1);\\n                collectionAccount.removeSafeboxKey(nftId);\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        if (releasedCredit > 0) {\\n            collectionAccount.totalLockingCredit -= releasedCredit.toUint96();\\n        }\\n\\n        emit RemoveExpiredKey(msg.sender, onBehalfOf, collectionId, removedIds, removedKeys);\\n    }\\n\\n    function claimRandomNFT(\\n        CollectionState storage collection,\\n        mapping(address => UserFloorAccount) storage userAccounts,\\n        address creditToken,\\n        address collectionId,\\n        uint256 claimCnt,\\n        uint256 maxCreditCost,\\n        address receiver\\n    ) public returns (uint256 totalCreditCost) {\\n        if (claimCnt == 0 || collection.freeTokenIds.length < claimCnt) revert Errors.ClaimableNftInsufficient();\\n\\n        uint256 freeAmount = collection.freeTokenIds.length;\\n        uint256 totalManaged = collection.activeSafeBoxCnt + freeAmount;\\n\\n        uint256[] memory selectedTokenIds = new uint256[](claimCnt);\\n\\n        UserFloorAccount storage userAccount = userAccounts[msg.sender];\\n        uint8 vipLevel = Constants.getVipLevel(userAccount.tokenBalance(creditToken));\\n        while (claimCnt > 0) {\\n            totalCreditCost += Constants.getClaimRandomCost(freeAmount, totalManaged, vipLevel);\\n\\n            /// just compute a deterministic random number\\n            uint256 chosenNftIdx = uint256(keccak256(abi.encodePacked(block.timestamp, block.prevrandao, totalManaged)))\\n                % collection.freeTokenIds.length;\\n\\n            unchecked {\\n                --claimCnt;\\n                --totalManaged;\\n                --freeAmount;\\n            }\\n\\n            selectedTokenIds[claimCnt] = collection.freeTokenIds[chosenNftIdx];\\n\\n            collection.freeTokenIds[chosenNftIdx] = collection.freeTokenIds[collection.freeTokenIds.length - 1];\\n            collection.freeTokenIds.pop();\\n        }\\n\\n        if (totalCreditCost > maxCreditCost) {\\n            revert Errors.InsufficientCredit();\\n        }\\n\\n        userAccount.transferToken(userAccounts[address(this)], creditToken, totalCreditCost, true);\\n        collection.floorToken.burn(msg.sender, Constants.FLOOR_TOKEN_AMOUNT * selectedTokenIds.length);\\n        ERC721Transfer.safeBatchTransferFrom(collectionId, address(this), receiver, selectedTokenIds);\\n\\n        emit ClaimRandomNft(msg.sender, receiver, collectionId, selectedTokenIds, totalCreditCost);\\n    }\\n\\n    function getLockingBuckets(CollectionState storage collection, uint256 startTimestamp, uint256 endTimestamp)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        return Helper.prepareBucketUpdate(\\n            collection,\\n            Helper.counterStamp(startTimestamp),\\n            Math.min(collection.lastUpdatedBucket, Helper.counterStamp(endTimestamp))\\n        );\\n    }\\n\\n    function addSafeBox(CollectionState storage collectionState, uint256 nftId, SafeBox memory safebox) internal {\\n        if (collectionState.safeBoxes[nftId].keyId > 0) revert Errors.SafeBoxAlreadyExist();\\n        collectionState.safeBoxes[nftId] = safebox;\\n        ++collectionState.activeSafeBoxCnt;\\n    }\\n\\n    function removeSafeBox(CollectionState storage collectionState, uint256 nftId) internal {\\n        delete collectionState.safeBoxes[nftId];\\n        --collectionState.activeSafeBoxCnt;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/logic/Helper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"../Constants.sol\\\";\\nimport \\\"../Errors.sol\\\";\\nimport \\\"./SafeBox.sol\\\";\\nimport \\\"./User.sol\\\";\\nimport {SafeBox, CollectionState, AuctionInfo, CollectionAccount, SafeBoxKey} from \\\"./Structs.sol\\\";\\nimport \\\"../library/RollingBuckets.sol\\\";\\n\\nlibrary Helper {\\n    using SafeBoxLib for SafeBox;\\n    using UserLib for CollectionAccount;\\n    using RollingBuckets for mapping(uint256 => uint256);\\n\\n    function counterStamp(uint256 timestamp) internal pure returns (uint96) {\\n        unchecked {\\n            return uint96((timestamp + Constants.BUCKET_SPAN_1) / Constants.BUCKET_SPAN);\\n        }\\n    }\\n\\n    function ensureProxyVipLevel(uint8 vipLevel, bool proxy) internal pure {\\n        if (proxy && vipLevel < Constants.PROXY_COLLECTION_VIP_THRESHOLD) {\\n            revert Errors.InvalidParam();\\n        }\\n    }\\n\\n    function ensureMaxLocking(\\n        CollectionState storage collection,\\n        uint8 vipLevel,\\n        uint256 requireExpiryTs,\\n        uint256 requireLockCnt\\n    ) internal view {\\n        /// vip level 0 can not use safebox utilities.\\n        if (vipLevel >= Constants.VIP_LEVEL_COUNT || vipLevel == 0) {\\n            revert Errors.InvalidParam();\\n        }\\n\\n        /// only check when it is not infinite lock\\n        if (requireExpiryTs > 0) {\\n            uint256 deltaBucket;\\n            unchecked {\\n                deltaBucket = counterStamp(requireExpiryTs) - counterStamp(block.timestamp);\\n            }\\n            if (deltaBucket == 0 || deltaBucket > Constants.getVipLockingBuckets(vipLevel)) {\\n                revert Errors.InvalidParam();\\n            }\\n        } else {\\n            uint256 freeAmount = collection.freeTokenIds.length;\\n            uint256 totalManaged = requireLockCnt + collection.activeSafeBoxCnt + freeAmount;\\n            uint256 lockingRatio = (100 - freeAmount * 100 / totalManaged);\\n            uint256 restrictRatio = Constants.getLockingRatioForInfinite(vipLevel);\\n            if (lockingRatio > restrictRatio) {\\n                revert Errors.InvalidParam();\\n            }\\n        }\\n    }\\n\\n    function useSafeBoxAndKey(CollectionState storage collection, CollectionAccount storage userAccount, uint256 nftId)\\n        internal\\n        view\\n        returns (SafeBox storage safeBox, SafeBoxKey storage key)\\n    {\\n        safeBox = collection.safeBoxes[nftId];\\n        if (safeBox.keyId == 0) revert Errors.SafeBoxNotExist();\\n        if (safeBox.isSafeBoxExpired()) revert Errors.SafeBoxHasExpire();\\n\\n        key = userAccount.getByKey(nftId);\\n        if (!safeBox.isKeyMatchingSafeBox(key)) revert Errors.NoMatchingSafeBoxKey();\\n    }\\n\\n    function useSafeBox(CollectionState storage collection, uint256 nftId)\\n        internal\\n        view\\n        returns (SafeBox storage safeBox)\\n    {\\n        safeBox = collection.safeBoxes[nftId];\\n        if (safeBox.keyId == 0) revert Errors.SafeBoxNotExist();\\n    }\\n\\n    function generateNextKeyId(CollectionState storage collectionState) internal returns (uint64 nextKeyId) {\\n        nextKeyId = collectionState.nextKeyId;\\n        ++collectionState.nextKeyId;\\n    }\\n\\n    function generateNextActivityId(CollectionState storage collection) internal returns (uint64 nextActivityId) {\\n        nextActivityId = collection.nextActivityId;\\n        ++collection.nextActivityId;\\n    }\\n\\n    function isAuctionPeriodOver(SafeBox storage safeBox) internal view returns (bool) {\\n        return safeBox.expiryTs + Constants.FREE_AUCTION_PERIOD < block.timestamp;\\n    }\\n\\n    function hasActiveActivities(CollectionState storage collection, uint256 nftId) internal view returns (bool) {\\n        return hasActiveAuction(collection, nftId) || hasActiveRaffle(collection, nftId)\\n            || hasActivePrivateOffer(collection, nftId);\\n    }\\n\\n    function hasActiveAuction(CollectionState storage collection, uint256 nftId) internal view returns (bool) {\\n        return collection.activeAuctions[nftId].endTime >= block.timestamp;\\n    }\\n\\n    function hasActiveRaffle(CollectionState storage collection, uint256 nftId) internal view returns (bool) {\\n        return collection.activeRaffles[nftId].endTime >= block.timestamp;\\n    }\\n\\n    function hasActivePrivateOffer(CollectionState storage collection, uint256 nftId) internal view returns (bool) {\\n        return collection.activePrivateOffers[nftId].endTime >= block.timestamp;\\n    }\\n\\n    function getTokenFeeRateBips(address creditToken, address floorToken, address settleToken)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 feeRateBips = Constants.COMMON_FEE_RATE_BIPS;\\n        if (settleToken == creditToken) {\\n            feeRateBips = Constants.CREDIT_FEE_RATE_BIPS;\\n        } else if (settleToken == floorToken) {\\n            feeRateBips = Constants.SPEC_FEE_RATE_BIPS;\\n        }\\n\\n        return feeRateBips;\\n    }\\n\\n    function calculateActivityFee(uint256 settleAmount, uint256 feeRateBips)\\n        internal\\n        pure\\n        returns (uint256 afterFee, uint256 fee)\\n    {\\n        fee = settleAmount * feeRateBips / 10000;\\n        unchecked {\\n            afterFee = settleAmount - fee;\\n        }\\n    }\\n\\n    function prepareBucketUpdate(CollectionState storage collection, uint256 startBucket, uint256 endBucket)\\n        internal\\n        view\\n        returns (uint256[] memory buckets)\\n    {\\n        uint256 validEnd = collection.lastUpdatedBucket;\\n        uint256 padding;\\n        if (endBucket < validEnd) {\\n            validEnd = endBucket;\\n        } else {\\n            unchecked {\\n                padding = endBucket - validEnd;\\n            }\\n        }\\n\\n        if (startBucket < validEnd) {\\n            if (padding == 0) {\\n                buckets = collection.countingBuckets.batchGet(startBucket, validEnd);\\n            } else {\\n                uint256 validLen;\\n                unchecked {\\n                    validLen = validEnd - startBucket;\\n                }\\n                buckets = new uint256[](validLen + padding);\\n                uint256[] memory tmp = collection.countingBuckets.batchGet(startBucket, validEnd);\\n                for (uint256 i; i < validLen;) {\\n                    buckets[i] = tmp[i];\\n                    unchecked {\\n                        ++i;\\n                    }\\n                }\\n            }\\n        } else {\\n            buckets = new uint256[](endBucket - startBucket);\\n        }\\n    }\\n\\n    function getActiveSafeBoxes(CollectionState storage collectionState, uint256 timestamp)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 bucketStamp = counterStamp(timestamp);\\n        if (collectionState.lastUpdatedBucket < bucketStamp) {\\n            return 0;\\n        }\\n        return collectionState.countingBuckets.get(bucketStamp);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/logic/PrivateOffer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"openzeppelin-contracts/contracts/utils/math/Math.sol\\\";\\n\\nimport \\\"../Errors.sol\\\";\\nimport \\\"../interface/IFlooring.sol\\\";\\nimport \\\"../library/RollingBuckets.sol\\\";\\nimport {SafeBox, CollectionState, PrivateOffer} from \\\"./Structs.sol\\\";\\nimport {SafeBoxLib} from \\\"./SafeBox.sol\\\";\\nimport \\\"./User.sol\\\";\\nimport \\\"./Helper.sol\\\";\\n\\nlibrary PrivateOfferLib {\\n    using SafeBoxLib for SafeBox;\\n    using RollingBuckets for mapping(uint256 => uint256);\\n    using UserLib for UserFloorAccount;\\n    using UserLib for CollectionAccount;\\n    using Helper for CollectionState;\\n\\n    // todo: event should be moved to Interface as far as Solidity 0.8.22 ready.\\n    // https://github.com/ethereum/solidity/pull/14274\\n    // https://github.com/ethereum/solidity/issues/14430\\n    event PrivateOfferStarted(\\n        address indexed seller,\\n        address indexed buyer,\\n        address indexed collection,\\n        uint64[] activityIds,\\n        uint256[] nftIds,\\n        address settleToken,\\n        uint96 price,\\n        uint256 offerEndTime,\\n        uint256 safeBoxExpiryTs,\\n        uint256 adminFee\\n    );\\n\\n    event PrivateOfferCanceled(\\n        address indexed operator, address indexed collection, uint64[] activityIds, uint256[] nftIds\\n    );\\n\\n    event PrivateOfferAccepted(\\n        address indexed buyer,\\n        address indexed collection,\\n        uint64[] activityIds,\\n        uint256[] nftIds,\\n        uint256[] safeBoxKeyIds\\n    );\\n\\n    struct PrivateOfferSettlement {\\n        SafeBoxKey safeBoxKey;\\n        uint256 nftId;\\n        address token;\\n        uint128 collectedFund;\\n        address seller;\\n        address buyer;\\n    }\\n\\n    function ownerInitPrivateOffers(\\n        CollectionState storage collection,\\n        mapping(address => UserFloorAccount) storage userAccounts,\\n        address creditToken,\\n        IFlooring.PrivateOfferInitParam memory param\\n    ) public {\\n        UserFloorAccount storage userAccount = userAccounts[msg.sender];\\n        uint256 totalFeeCost = param.nftIds.length * Constants.PRIVATE_OFFER_COST;\\n        userAccount.transferToken(userAccounts[address(this)], creditToken, totalFeeCost, true);\\n\\n        (uint64[] memory offerActivityIds, uint96 offerEndTime, uint192 safeBoxExpiryTs) =\\n            _ownerInitPrivateOffers(collection, userAccount.getByKey(param.collection), param);\\n\\n        emit PrivateOfferStarted(\\n            msg.sender,\\n            param.receiver,\\n            param.collection,\\n            offerActivityIds,\\n            param.nftIds,\\n            param.token,\\n            param.price,\\n            offerEndTime,\\n            safeBoxExpiryTs,\\n            totalFeeCost\\n        );\\n    }\\n\\n    function _ownerInitPrivateOffers(\\n        CollectionState storage collection,\\n        CollectionAccount storage userAccount,\\n        IFlooring.PrivateOfferInitParam memory param\\n    ) private returns (uint64[] memory offerActivityIds, uint96 offerEndTime, uint32 safeBoxExpiryTs) {\\n        if (param.receiver == msg.sender) {\\n            revert Errors.InvalidParam();\\n        }\\n\\n        offerEndTime = uint96(block.timestamp + Constants.PRIVATE_OFFER_DURATION);\\n        safeBoxExpiryTs = uint32(offerEndTime + Constants.PRIVATE_OFFER_COMPLETE_GRACE_DURATION);\\n        uint256 nowBucketCnt = Helper.counterStamp(block.timestamp);\\n\\n        uint256[] memory toUpdateBucket;\\n        if (param.maxExpiry > 0) {\\n            toUpdateBucket = collection.countingBuckets.batchGet(\\n                nowBucketCnt, Math.min(collection.lastUpdatedBucket, Helper.counterStamp(param.maxExpiry))\\n            );\\n        }\\n\\n        uint256 nftLen = param.nftIds.length;\\n        offerActivityIds = new uint64[](nftLen);\\n        uint256 firstIdx = Helper.counterStamp(safeBoxExpiryTs) - nowBucketCnt;\\n        for (uint256 i; i < nftLen;) {\\n            uint256 nftId = param.nftIds[i];\\n            if (collection.hasActiveActivities(nftId)) revert Errors.NftHasActiveActivities();\\n\\n            (SafeBox storage safeBox,) = collection.useSafeBoxAndKey(userAccount, nftId);\\n\\n            if (safeBox.isInfiniteSafeBox()) {\\n                --collection.infiniteCnt;\\n            } else {\\n                uint256 oldExpiryTs = safeBox.expiryTs;\\n                if (oldExpiryTs < safeBoxExpiryTs) {\\n                    revert Errors.InvalidParam();\\n                }\\n                uint256 lastIdx = Helper.counterStamp(oldExpiryTs) - nowBucketCnt;\\n                if (firstIdx > lastIdx || lastIdx > toUpdateBucket.length) revert Errors.InvalidParam();\\n                for (uint256 k = firstIdx; k < lastIdx;) {\\n                    --toUpdateBucket[k];\\n                    unchecked {\\n                        ++k;\\n                    }\\n                }\\n            }\\n\\n            safeBox.expiryTs = safeBoxExpiryTs;\\n            offerActivityIds[i] = collection.generateNextActivityId();\\n            collection.activePrivateOffers[nftId] = PrivateOffer({\\n                endTime: offerEndTime,\\n                owner: msg.sender,\\n                buyer: param.receiver,\\n                token: param.token,\\n                price: param.price,\\n                activityId: offerActivityIds[i]\\n            });\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        if (toUpdateBucket.length > 0) {\\n            collection.countingBuckets.batchSet(nowBucketCnt, toUpdateBucket);\\n        }\\n    }\\n\\n    function removePrivateOffers(CollectionState storage collection, address collectionId, uint256[] memory nftIds)\\n        public\\n    {\\n        uint64[] memory offerActivityIds = new uint64[](nftIds.length);\\n        for (uint256 i; i < nftIds.length;) {\\n            uint256 nftId = nftIds[i];\\n            PrivateOffer storage offer = collection.activePrivateOffers[nftId];\\n            if (offer.owner != msg.sender && offer.buyer != msg.sender) revert Errors.NoPrivilege();\\n\\n            offerActivityIds[i] = offer.activityId;\\n            delete collection.activePrivateOffers[nftId];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit PrivateOfferCanceled(msg.sender, collectionId, offerActivityIds, nftIds);\\n    }\\n\\n    function buyerAcceptPrivateOffers(\\n        CollectionState storage collection,\\n        mapping(address => UserFloorAccount) storage userAccounts,\\n        address collectionId,\\n        uint256[] memory nftIds,\\n        address creditToken\\n    ) public {\\n        (PrivateOfferSettlement[] memory settlements, uint64[] memory activityIds) =\\n            _buyerAcceptPrivateOffers(collection, nftIds);\\n\\n        uint256[] memory safeBoxKeyIds = new uint256[](settlements.length);\\n        for (uint256 i; i < settlements.length;) {\\n            PrivateOfferSettlement memory settlement = settlements[i];\\n\\n            UserFloorAccount storage buyerAccount = userAccounts[settlement.buyer];\\n            CollectionAccount storage buyerCollectionAccount = buyerAccount.getByKey(collectionId);\\n\\n            buyerCollectionAccount.addSafeboxKey(settlement.nftId, settlement.safeBoxKey);\\n\\n            if (settlement.collectedFund > 0) {\\n                UserFloorAccount storage sellerAccount = userAccounts[settlement.seller];\\n                buyerAccount.transferToken(\\n                    sellerAccount, settlement.token, settlement.collectedFund, settlement.token == creditToken\\n                );\\n            }\\n\\n            safeBoxKeyIds[i] = settlement.safeBoxKey.keyId;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        emit PrivateOfferAccepted(msg.sender, collectionId, activityIds, nftIds, safeBoxKeyIds);\\n    }\\n\\n    function _buyerAcceptPrivateOffers(CollectionState storage collection, uint256[] memory nftIds)\\n        private\\n        returns (PrivateOfferSettlement[] memory settlements, uint64[] memory offerActivityIds)\\n    {\\n        uint256 nftLen = nftIds.length;\\n        settlements = new PrivateOfferSettlement[](nftLen);\\n        offerActivityIds = new uint64[](nftLen);\\n        for (uint256 i; i < nftLen;) {\\n            uint256 nftId = nftIds[i];\\n            PrivateOffer storage offer = collection.activePrivateOffers[nftId];\\n            if (offer.endTime <= block.timestamp) revert Errors.ActivityHasExpired();\\n            if (offer.buyer != msg.sender) revert Errors.NoPrivilege();\\n\\n            SafeBox storage safeBox = collection.useSafeBox(nftId);\\n            if (safeBox.isSafeBoxExpired()) revert Errors.SafeBoxHasExpire();\\n\\n            SafeBoxKey memory newKey =\\n                SafeBoxKey({keyId: collection.generateNextKeyId(), vipLevel: 0, lockingCredit: 0});\\n            safeBox.keyId = newKey.keyId;\\n            safeBox.owner = msg.sender;\\n\\n            settlements[i] = PrivateOfferSettlement({\\n                safeBoxKey: newKey,\\n                nftId: nftId,\\n                seller: offer.owner,\\n                buyer: msg.sender,\\n                token: offer.token,\\n                collectedFund: offer.price\\n            });\\n            offerActivityIds[i] = offer.activityId;\\n\\n            delete collection.activePrivateOffers[nftId];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/logic/Raffle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport {SafeBox, CollectionState, RaffleInfo, TicketRecord} from \\\"./Structs.sol\\\";\\nimport \\\"./User.sol\\\";\\nimport \\\"./Collection.sol\\\";\\nimport \\\"./Helper.sol\\\";\\nimport \\\"../Errors.sol\\\";\\nimport \\\"../library/RollingBuckets.sol\\\";\\nimport \\\"../library/Array.sol\\\";\\n\\nlibrary RaffleLib {\\n    using CollectionLib for CollectionState;\\n    using SafeBoxLib for SafeBox;\\n    using RollingBuckets for mapping(uint256 => uint256);\\n    using UserLib for UserFloorAccount;\\n    using UserLib for CollectionAccount;\\n    using Helper for CollectionState;\\n\\n    event RaffleStarted(\\n        address indexed owner,\\n        address indexed collection,\\n        uint64[] activityIds,\\n        uint256[] nftIds,\\n        uint48 maxTickets,\\n        address settleToken,\\n        uint96 ticketPrice,\\n        uint256 feeRateBips,\\n        uint48 raffleEndTime,\\n        uint256 safeBoxExpiryTs,\\n        uint256 adminFee\\n    );\\n\\n    event RaffleTicketsSold(\\n        address indexed buyer,\\n        address indexed collection,\\n        uint64 activityId,\\n        uint256 nftId,\\n        uint256 ticketsSold,\\n        uint256 cost\\n    );\\n\\n    event RaffleSettled(\\n        address indexed winner,\\n        address indexed collection,\\n        uint64 activityId,\\n        uint256 nftId,\\n        uint256 safeBoxKeyId,\\n        uint256 collectedFunds\\n    );\\n\\n    function ownerInitRaffles(\\n        CollectionState storage collection,\\n        mapping(address => UserFloorAccount) storage userAccounts,\\n        IFlooring.RaffleInitParam memory param,\\n        address creditToken\\n    ) public {\\n        UserFloorAccount storage userAccount = userAccounts[msg.sender];\\n\\n        {\\n            if (uint256(param.maxTickets) * param.ticketPrice > type(uint96).max) revert Errors.InvalidParam();\\n\\n            (uint256 vipLevel, uint256 duration) = Constants.raffleDurations(param.duration);\\n            userAccount.ensureVipCredit(uint8(vipLevel), creditToken);\\n            param.duration = duration;\\n        }\\n\\n        uint256 adminFee = Constants.RAFFLE_COST * param.nftIds.length;\\n        userAccount.transferToken(userAccounts[address(this)], creditToken, adminFee, true);\\n\\n        uint256 feeRateBips = Helper.getTokenFeeRateBips(creditToken, address(collection.floorToken), param.ticketToken);\\n        (uint64[] memory raffleActivityIds, uint48 raffleEndTime, uint192 safeBoxExpiryTs) =\\n            _ownerInitRaffles(collection, userAccount.getByKey(param.collection), param, uint32(feeRateBips));\\n\\n        emit RaffleStarted(\\n            msg.sender,\\n            param.collection,\\n            raffleActivityIds,\\n            param.nftIds,\\n            param.maxTickets,\\n            param.ticketToken,\\n            param.ticketPrice,\\n            feeRateBips,\\n            raffleEndTime,\\n            safeBoxExpiryTs,\\n            adminFee\\n        );\\n    }\\n\\n    function _ownerInitRaffles(\\n        CollectionState storage collection,\\n        CollectionAccount storage userAccount,\\n        IFlooring.RaffleInitParam memory param,\\n        uint32 feeRateBips\\n    ) private returns (uint64[] memory raffleActivityIds, uint48 raffleEndTime, uint32 safeBoxExpiryTs) {\\n        raffleEndTime = uint48(block.timestamp + param.duration);\\n        safeBoxExpiryTs = uint32(raffleEndTime + Constants.RAFFLE_COMPLETE_GRACE_PERIODS);\\n\\n        uint256 startBucket = Helper.counterStamp(block.timestamp);\\n\\n        uint256[] memory toUpdateBucket;\\n        if (param.maxExpiry > 0) {\\n            toUpdateBucket = collection.countingBuckets.batchGet(\\n                startBucket, Math.min(Helper.counterStamp(param.maxExpiry), collection.lastUpdatedBucket)\\n            );\\n        }\\n\\n        raffleActivityIds = new uint64[](param.nftIds.length);\\n        uint256 firstIdx = Helper.counterStamp(safeBoxExpiryTs) - startBucket;\\n        for (uint256 i; i < param.nftIds.length;) {\\n            uint256 nftId = param.nftIds[i];\\n\\n            if (collection.hasActiveActivities(nftId)) revert Errors.NftHasActiveActivities();\\n\\n            (SafeBox storage safeBox,) = collection.useSafeBoxAndKey(userAccount, nftId);\\n\\n            if (safeBox.isInfiniteSafeBox()) {\\n                --collection.infiniteCnt;\\n            } else {\\n                uint256 oldExpiryTs = safeBox.expiryTs;\\n                if (oldExpiryTs < safeBoxExpiryTs) {\\n                    revert Errors.InvalidParam();\\n                }\\n                uint256 lastIdx = Helper.counterStamp(oldExpiryTs) - startBucket;\\n                if (firstIdx > lastIdx || lastIdx > toUpdateBucket.length) revert Errors.InvalidParam();\\n                for (uint256 k = firstIdx; k < lastIdx;) {\\n                    --toUpdateBucket[k];\\n                    unchecked {\\n                        ++k;\\n                    }\\n                }\\n            }\\n\\n            safeBox.expiryTs = safeBoxExpiryTs;\\n            raffleActivityIds[i] = collection.generateNextActivityId();\\n\\n            RaffleInfo storage newRaffle = collection.activeRaffles[nftId];\\n            newRaffle.endTime = raffleEndTime;\\n            newRaffle.token = param.ticketToken;\\n            newRaffle.ticketPrice = param.ticketPrice;\\n            newRaffle.maxTickets = param.maxTickets;\\n            newRaffle.owner = msg.sender;\\n            newRaffle.activityId = raffleActivityIds[i];\\n            newRaffle.feeRateBips = feeRateBips;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        if (toUpdateBucket.length > 0) {\\n            collection.countingBuckets.batchSet(startBucket, toUpdateBucket);\\n        }\\n    }\\n\\n    function buyRaffleTickets(\\n        CollectionState storage collection,\\n        mapping(address => UserFloorAccount) storage accounts,\\n        address creditToken,\\n        address collectionId,\\n        uint256 nftId,\\n        uint256 ticketCnt\\n    ) public {\\n        RaffleInfo storage raffle = collection.activeRaffles[nftId];\\n        if (raffle.owner == address(0) || raffle.owner == msg.sender) revert Errors.NoPrivilege();\\n        if (raffle.endTime < block.timestamp) revert Errors.ActivityHasExpired();\\n        if (raffle.maxTickets < raffle.ticketSold + ticketCnt) revert Errors.InvalidParam();\\n\\n        SafeBox storage safeBox = collection.useSafeBox(nftId);\\n        safeBox.keyId = SafeBoxLib.SAFEBOX_KEY_NOTATION;\\n\\n        // buyer buy tickets idx in [startIdx, endIdx)\\n        raffle.tickets.push(\\n            TicketRecord({\\n                buyer: msg.sender,\\n                startIdx: uint48(raffle.ticketSold),\\n                endIdx: uint48(raffle.ticketSold + ticketCnt)\\n            })\\n        );\\n\\n        uint256 cost = raffle.ticketPrice * ticketCnt;\\n        raffle.ticketSold += uint48(ticketCnt);\\n        raffle.collectedFund += uint96(cost);\\n\\n        address token = raffle.token;\\n        accounts[msg.sender].transferToken(accounts[address(this)], token, cost, token == creditToken);\\n\\n        emit RaffleTicketsSold(msg.sender, collectionId, raffle.activityId, nftId, ticketCnt, cost);\\n    }\\n\\n    function prepareSettleRaffles(CollectionState storage collection, uint256[] calldata nftIds)\\n        public\\n        returns (bytes memory compactedNftIds, uint256 nftIdsLen)\\n    {\\n        uint256 nftLen = nftIds.length;\\n        uint256[] memory tmpNftIds = new uint256[](nftLen);\\n        uint256 cnt;\\n        for (uint256 i; i < nftLen; ++i) {\\n            uint256 nftId = nftIds[i];\\n            RaffleInfo storage raffle = collection.activeRaffles[nftId];\\n\\n            if (raffle.endTime >= block.timestamp) revert Errors.ActivityHasNotCompleted();\\n            if (raffle.isSettling) revert Errors.InvalidParam();\\n\\n            if (raffle.ticketSold == 0) {\\n                continue;\\n            }\\n\\n            SafeBox storage safeBox = collection.useSafeBox(nftId);\\n            // raffle must be settled before safebox expired\\n            // otherwise it maybe conflict with auction\\n            if (safeBox.isSafeBoxExpired()) revert Errors.SafeBoxHasExpire();\\n\\n            tmpNftIds[cnt] = nftId;\\n            raffle.isSettling = true;\\n\\n            unchecked {\\n                ++cnt;\\n            }\\n        }\\n\\n        if (cnt == nftLen) {\\n            nftIdsLen = tmpNftIds.length;\\n            compactedNftIds = Array.encodeUints(tmpNftIds);\\n        } else {\\n            uint256[] memory toSettleNftIds = new uint256[](cnt);\\n            for (uint256 i; i < cnt;) {\\n                toSettleNftIds[i] = tmpNftIds[i];\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n            nftIdsLen = cnt;\\n            compactedNftIds = Array.encodeUints(toSettleNftIds);\\n        }\\n    }\\n\\n    function settleRaffles(\\n        CollectionState storage collection,\\n        mapping(address => UserFloorAccount) storage userAccounts,\\n        address collectionId,\\n        bytes memory compactedNftIds,\\n        uint256[] memory randoms\\n    ) public {\\n        uint256[] memory nftIds = Array.decodeUints(compactedNftIds);\\n\\n        for (uint256 i; i < nftIds.length;) {\\n            uint256 nftId = nftIds[i];\\n            RaffleInfo storage raffle = collection.activeRaffles[nftId];\\n\\n            TicketRecord memory winTicket = getWinTicket(raffle.tickets, uint48(randoms[i] % raffle.ticketSold));\\n\\n            SafeBoxKey memory key = SafeBoxKey({keyId: collection.generateNextKeyId(), vipLevel: 0, lockingCredit: 0});\\n\\n            {\\n                /// we don't check whether the safebox is exist, it had done in the `prepareSettleRaffles`\\n                SafeBox storage safeBox = collection.safeBoxes[nftId];\\n                safeBox.keyId = key.keyId;\\n                safeBox.owner = winTicket.buyer;\\n            }\\n\\n            {\\n                /// transfer safebox key to winner account\\n                CollectionAccount storage winnerCollectionAccount = userAccounts[winTicket.buyer].getByKey(collectionId);\\n                winnerCollectionAccount.addSafeboxKey(nftId, key);\\n            }\\n\\n            (uint256 earning,) = Helper.calculateActivityFee(raffle.collectedFund, raffle.feeRateBips);\\n            /// contract account no need to check credit requirements\\n            userAccounts[address(this)].transferToken(userAccounts[raffle.owner], raffle.token, earning, false);\\n\\n            emit RaffleSettled(winTicket.buyer, collectionId, raffle.activityId, nftId, key.keyId, raffle.collectedFund);\\n\\n            delete collection.activeRaffles[nftId];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function getWinTicket(TicketRecord[] storage tickets, uint48 idx)\\n        private\\n        view\\n        returns (TicketRecord memory ticket)\\n    {\\n        uint256 low;\\n        uint256 high = tickets.length;\\n\\n        unchecked {\\n            while (low <= high) {\\n                // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n                // because Math.average rounds down (it does integer division with truncation).\\n                uint256 mid = Math.average(low, high);\\n\\n                ticket = tickets[mid];\\n                if (ticket.startIdx <= idx && idx < ticket.endIdx) {\\n                    return ticket;\\n                }\\n\\n                if (ticket.startIdx < idx) {\\n                    high = mid;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/logic/SafeBox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport {SafeBox, SafeBoxKey} from \\\"./Structs.sol\\\";\\n\\nlibrary SafeBoxLib {\\n    uint64 public constant SAFEBOX_KEY_NOTATION = type(uint64).max;\\n\\n    function isInfiniteSafeBox(SafeBox storage safeBox) internal view returns (bool) {\\n        return safeBox.expiryTs == 0;\\n    }\\n\\n    function isSafeBoxExpired(SafeBox storage safeBox) internal view returns (bool) {\\n        return safeBox.expiryTs != 0 && safeBox.expiryTs < block.timestamp;\\n    }\\n\\n    function _isSafeBoxExpired(SafeBox memory safeBox) internal view returns (bool) {\\n        return safeBox.expiryTs != 0 && safeBox.expiryTs < block.timestamp;\\n    }\\n\\n    function isKeyMatchingSafeBox(SafeBox storage safeBox, SafeBoxKey storage safeBoxKey)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return safeBox.keyId == safeBoxKey.keyId;\\n    }\\n\\n    function _isKeyMatchingSafeBox(SafeBox memory safeBox, SafeBoxKey memory safeBoxKey) internal pure returns (bool) {\\n        return safeBox.keyId == safeBoxKey.keyId;\\n    }\\n\\n    function encodeSafeBoxKey(SafeBoxKey memory key) internal pure returns (uint256) {\\n        uint256 val = key.lockingCredit;\\n        val |= (uint256(key.keyId) << 96);\\n        val |= (uint256(key.vipLevel) << 160);\\n        return val;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/logic/Structs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"../interface/IFragmentToken.sol\\\";\\n\\nstruct SafeBox {\\n    /// Either matching a key OR Constants.SAFEBOX_KEY_NOTATION meaning temporarily\\n    /// held by a bidder in auction.\\n    uint64 keyId;\\n    /// The timestamp that the safe box expires.\\n    uint32 expiryTs;\\n    /// The owner of the safebox. It maybe outdated due to expiry\\n    address owner;\\n}\\n\\nstruct PrivateOffer {\\n    /// private offer end time\\n    uint96 endTime;\\n    /// which token used to accpet the offer\\n    address token;\\n    /// price of the offer\\n    uint96 price;\\n    address owner;\\n    /// who should receive the offer\\n    address buyer;\\n    uint64 activityId;\\n}\\n\\nstruct AuctionInfo {\\n    /// The end time for the auction.\\n    uint96 endTime;\\n    /// Bid token address.\\n    address bidTokenAddress;\\n    /// Minimum Bid.\\n    uint96 minimumBid;\\n    /// The person who trigger the auction at the beginning.\\n    address triggerAddress;\\n    uint96 lastBidAmount;\\n    address lastBidder;\\n    /// Whether the auction is triggered by the NFT owner itself\uff1f\\n    bool isSelfTriggered;\\n    uint64 activityId;\\n    uint32 feeRateBips;\\n}\\n\\nstruct TicketRecord {\\n    /// who buy the tickets\\n    address buyer;\\n    /// Start index of tickets\\n    /// [startIdx, endIdx)\\n    uint48 startIdx;\\n    /// End index of tickets\\n    uint48 endIdx;\\n}\\n\\nstruct RaffleInfo {\\n    /// raffle end time\\n    uint48 endTime;\\n    /// max tickets amount the raffle can sell\\n    uint48 maxTickets;\\n    /// which token used to buy the raffle tickets\\n    address token;\\n    /// price per ticket\\n    uint96 ticketPrice;\\n    /// total funds collected by selling tickets\\n    uint96 collectedFund;\\n    uint64 activityId;\\n    address owner;\\n    /// total sold tickets amount\\n    uint48 ticketSold;\\n    uint32 feeRateBips;\\n    /// whether the raffle is being settling\\n    bool isSettling;\\n    /// tickets sold records\\n    TicketRecord[] tickets;\\n}\\n\\nstruct CollectionState {\\n    /// The address of the Floor Token cooresponding to the NFTs.\\n    IFragmentToken floorToken;\\n    /// Records the active safe box in each time bucket.\\n    mapping(uint256 => uint256) countingBuckets;\\n    /// Stores all of the NFTs that has been fragmented but *without* locked up limit.\\n    uint256[] freeTokenIds;\\n    /// Huge map for all the `SafeBox`es in one collection.\\n    mapping(uint256 => SafeBox) safeBoxes;\\n    /// Stores all the ongoing auctions: nftId => `AuctionInfo`.\\n    mapping(uint256 => AuctionInfo) activeAuctions;\\n    /// Stores all the ongoing raffles: nftId => `RaffleInfo`.\\n    mapping(uint256 => RaffleInfo) activeRaffles;\\n    /// Stores all the ongoing private offers: nftId => `PrivateOffer`.\\n    mapping(uint256 => PrivateOffer) activePrivateOffers;\\n    /// The last bucket time the `countingBuckets` is updated.\\n    uint64 lastUpdatedBucket;\\n    /// Next Key Id. This should start from 1, we treat key id `SafeboxLib.SAFEBOX_KEY_NOTATION` as temporarily\\n    /// being used for activities(auction/raffle).\\n    uint64 nextKeyId;\\n    /// Active Safe Box Count.\\n    uint64 activeSafeBoxCnt;\\n    /// The number of infinite lock count.\\n    uint64 infiniteCnt;\\n    /// Next Activity Id. This should start from 1\\n    uint64 nextActivityId;\\n}\\n\\nstruct UserFloorAccount {\\n    /// @notice it should be maximum of the `totalLockingCredit` across all collections\\n    uint96 minMaintCredit;\\n    /// @notice used to iterate collection accounts\\n    /// packed with `minMaintCredit` to reduce storage slot access\\n    address firstCollection;\\n    /// @notice user vip level related info\\n    /// 0 - 239 bits: store SafeBoxKey Count per vip level, per level using 24 bits\\n    /// 240 - 247 bits: store minMaintVipLevel\\n    /// 248 - 255 bits: remaining\\n    uint256 vipInfo;\\n    /// @notice Locked Credit amount which cannot be withdrawn and will be released as time goes.\\n    uint256 lockedCredit;\\n    mapping(address => CollectionAccount) accounts;\\n    mapping(address => uint256) tokenAmounts;\\n}\\n\\nstruct SafeBoxKey {\\n    /// locked credit amount of this safebox\\n    uint96 lockingCredit;\\n    /// corresponding key id of the safebox\\n    uint64 keyId;\\n    /// which vip level the safebox locked\\n    uint8 vipLevel;\\n}\\n\\nstruct CollectionAccount {\\n    mapping(uint256 => SafeBoxKey) keys;\\n    /// total locking credit of all `keys` in this collection\\n    uint96 totalLockingCredit;\\n    /// track next collection as linked list\\n    address next;\\n}\\n\\n/// Internal Structure\\nstruct LockParam {\\n    address proxyCollection;\\n    address collection;\\n    uint256[] nftIds;\\n    uint256 expiryTs;\\n    uint256 vipLevel;\\n    uint256 maxCreditCost;\\n    address creditToken;\\n}\\n\"\r\n    },\r\n    \"src/logic/User.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"openzeppelin-contracts/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport \\\"../Constants.sol\\\";\\nimport \\\"../Errors.sol\\\";\\nimport {UserFloorAccount, CollectionAccount, SafeBoxKey} from \\\"./Structs.sol\\\";\\n\\nlibrary UserLib {\\n    using SafeCast for uint256;\\n\\n    /// @notice update the account maintain credit on behalfOf `onBehalfOf`\\n    event UpdateMaintainCredit(address indexed onBehalfOf, uint256 minMaintCredit);\\n\\n    address internal constant LIST_GUARD = address(1);\\n\\n    function ensureVipCredit(UserFloorAccount storage account, uint8 requireVipLevel, address creditToken)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 totalCredit = tokenBalance(account, creditToken);\\n        if (Constants.getVipBalanceRequirements(requireVipLevel) > totalCredit) {\\n            revert Errors.InsufficientBalanceForVipLevel();\\n        }\\n        return totalCredit;\\n    }\\n\\n    function getMinMaintVipLevel(UserFloorAccount storage account) internal view returns (uint8) {\\n        unchecked {\\n            return uint8(account.vipInfo >> 240);\\n        }\\n    }\\n\\n    function getMinLevelAndVipKeyCounts(uint256 vipInfo)\\n        internal\\n        pure\\n        returns (uint8 minLevel, uint256[] memory counts)\\n    {\\n        unchecked {\\n            counts = new uint256[](Constants.VIP_LEVEL_COUNT);\\n            minLevel = uint8(vipInfo >> 240);\\n            for (uint256 i; i < Constants.VIP_LEVEL_COUNT; ++i) {\\n                counts[i] = (vipInfo >> (i * 24)) & 0xFFFFFF;\\n            }\\n        }\\n    }\\n\\n    function storeMinLevelAndVipKeyCounts(\\n        UserFloorAccount storage account,\\n        uint8 minMaintVipLevel,\\n        uint256[] memory keyCounts\\n    ) internal {\\n        unchecked {\\n            uint256 _data = (uint256(minMaintVipLevel) << 240);\\n            for (uint256 i; i < Constants.VIP_LEVEL_COUNT; ++i) {\\n                _data |= ((keyCounts[i] & 0xFFFFFF) << (i * 24));\\n            }\\n            account.vipInfo = _data;\\n        }\\n    }\\n\\n    function getOrAddCollection(UserFloorAccount storage user, address collection)\\n        internal\\n        returns (CollectionAccount storage)\\n    {\\n        CollectionAccount storage entry = user.accounts[collection];\\n        if (entry.next == address(0)) {\\n            if (user.firstCollection == address(0)) {\\n                user.firstCollection = collection;\\n                entry.next = LIST_GUARD;\\n            } else {\\n                entry.next = user.firstCollection;\\n                user.firstCollection = collection;\\n            }\\n        }\\n        return entry;\\n    }\\n\\n    function removeCollection(UserFloorAccount storage userAccount, address collection, address prev) internal {\\n        CollectionAccount storage cur = userAccount.accounts[collection];\\n        if (cur.next == address(0)) revert Errors.InvalidParam();\\n\\n        if (collection == userAccount.firstCollection) {\\n            if (cur.next == LIST_GUARD) {\\n                userAccount.firstCollection = address(0);\\n            } else {\\n                userAccount.firstCollection = cur.next;\\n            }\\n        } else {\\n            CollectionAccount storage prevAccount = userAccount.accounts[prev];\\n            if (prevAccount.next != collection) revert Errors.InvalidParam();\\n            prevAccount.next = cur.next;\\n        }\\n\\n        delete userAccount.accounts[collection];\\n    }\\n\\n    function getByKey(UserFloorAccount storage userAccount, address collection)\\n        internal\\n        view\\n        returns (CollectionAccount storage)\\n    {\\n        return userAccount.accounts[collection];\\n    }\\n\\n    function addSafeboxKey(CollectionAccount storage account, uint256 nftId, SafeBoxKey memory key) internal {\\n        if (account.keys[nftId].keyId > 0) {\\n            revert Errors.SafeBoxKeyAlreadyExist();\\n        }\\n\\n        account.keys[nftId] = key;\\n    }\\n\\n    function removeSafeboxKey(CollectionAccount storage account, uint256 nftId) internal {\\n        delete account.keys[nftId];\\n    }\\n\\n    function getByKey(CollectionAccount storage account, uint256 nftId) internal view returns (SafeBoxKey storage) {\\n        return account.keys[nftId];\\n    }\\n\\n    function tokenBalance(UserFloorAccount storage account, address token) internal view returns (uint256) {\\n        return account.tokenAmounts[token];\\n    }\\n\\n    function lockCredit(UserFloorAccount storage account, uint256 amount) internal {\\n        unchecked {\\n            account.lockedCredit += amount;\\n        }\\n    }\\n\\n    function unlockCredit(UserFloorAccount storage account, uint256 amount) internal {\\n        unchecked {\\n            account.lockedCredit -= amount;\\n        }\\n    }\\n\\n    function depositToken(UserFloorAccount storage account, address token, uint256 amount) internal {\\n        account.tokenAmounts[token] += amount;\\n    }\\n\\n    function withdrawToken(UserFloorAccount storage account, address token, uint256 amount, bool isCreditToken)\\n        internal\\n    {\\n        uint256 balance = account.tokenAmounts[token];\\n        if (balance < amount) {\\n            revert Errors.InsufficientCredit();\\n        }\\n\\n        if (isCreditToken) {\\n            uint256 avaiableBuf;\\n            unchecked {\\n                avaiableBuf = balance - amount;\\n            }\\n            if (\\n                avaiableBuf < Constants.getVipBalanceRequirements(getMinMaintVipLevel(account))\\n                    || avaiableBuf < account.minMaintCredit || avaiableBuf < account.lockedCredit\\n            ) {\\n                revert Errors.InsufficientCredit();\\n            }\\n\\n            account.tokenAmounts[token] = avaiableBuf;\\n        } else {\\n            unchecked {\\n                account.tokenAmounts[token] = balance - amount;\\n            }\\n        }\\n    }\\n\\n    function transferToken(\\n        UserFloorAccount storage from,\\n        UserFloorAccount storage to,\\n        address token,\\n        uint256 amount,\\n        bool isCreditToken\\n    ) internal {\\n        withdrawToken(from, token, amount, isCreditToken);\\n        depositToken(to, token, amount);\\n    }\\n\\n    function updateVipKeyCount(UserFloorAccount storage account, uint8 vipLevel, int256 diff) internal {\\n        if (vipLevel > 0 && diff != 0) {\\n            (uint8 minMaintVipLevel, uint256[] memory keyCounts) = getMinLevelAndVipKeyCounts(account.vipInfo);\\n\\n            if (diff < 0) {\\n                keyCounts[vipLevel] -= uint256(-diff);\\n                if (vipLevel == minMaintVipLevel && keyCounts[vipLevel] == 0) {\\n                    uint8 newVipLevel = vipLevel;\\n                    do {\\n                        unchecked {\\n                            --newVipLevel;\\n                        }\\n                    } while (newVipLevel > 0 && keyCounts[newVipLevel] == 0);\\n\\n                    minMaintVipLevel = newVipLevel;\\n                }\\n            } else {\\n                keyCounts[vipLevel] += uint256(diff);\\n                if (vipLevel > minMaintVipLevel) {\\n                    minMaintVipLevel = vipLevel;\\n                }\\n            }\\n            storeMinLevelAndVipKeyCounts(account, minMaintVipLevel, keyCounts);\\n        }\\n    }\\n\\n    function recalculateMinMaintCredit(UserFloorAccount storage account, address onBehalfOf)\\n        public\\n        returns (uint256 maxLocking)\\n    {\\n        address prev = account.firstCollection;\\n        for (address collection = account.firstCollection; collection != LIST_GUARD && collection != address(0);) {\\n            (uint256 locking, address next) =\\n                (getByKey(account, collection).totalLockingCredit, getByKey(account, collection).next);\\n            if (locking == 0) {\\n                removeCollection(account, collection, prev);\\n                collection = next;\\n            } else {\\n                if (locking > maxLocking) {\\n                    maxLocking = locking;\\n                }\\n                prev = collection;\\n                collection = next;\\n            }\\n        }\\n\\n        account.minMaintCredit = uint96(maxLocking);\\n\\n        emit UpdateMaintainCredit(onBehalfOf, maxLocking);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport \\\"./interface/IMulticall.sol\\\";\\n\\n/// @title Multicall\\n/// @notice Enables calling multiple methods in a single call to the contract\\nabstract contract Multicall is IMulticall {\\n    /// @inheritdoc IMulticall\\n    function multicall(bytes[] calldata data) external virtual override returns (bytes[] memory) {\\n        bytes[] memory results = new bytes[](data.length);\\n        for (uint256 i; i < data.length;) {\\n            /// @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\\n\\n            if (success) {\\n                results[i] = result;\\n            } else {\\n                // Next 4 lines from\\n                // https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/utils/AddressUpgradeable.sol#L229\\n                if (result.length > 0) {\\n                    assembly {\\n                        let returndata_size := mload(result)\\n                        revert(add(32, result), returndata_size)\\n                    }\\n                } else {\\n                    revert FailedMulticall();\\n                }\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return results;\\n    }\\n\\n    function extMulticall(CallData[] calldata calls) external virtual override returns (bytes[] memory) {\\n        return multicall2(calls);\\n    }\\n\\n    /// @notice Aggregate calls, ensuring each returns success if required\\n    /// @param calls An array of CallData structs\\n    /// @return returnData An array of bytes\\n    function multicall2(CallData[] calldata calls) internal returns (bytes[] memory) {\\n        bytes[] memory results = new bytes[](calls.length);\\n        CallData calldata calli;\\n        for (uint256 i = 0; i < calls.length;) {\\n            calli = calls[i];\\n            (bool success, bytes memory result) = calli.target.call(calli.callData);\\n            if (success) {\\n                results[i] = result;\\n            } else {\\n                // Next 4 lines from\\n                // https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/utils/AddressUpgradeable.sol#L229\\n                if (result.length > 0) {\\n                    assembly {\\n                        let returndata_size := mload(result)\\n                        revert(add(32, result), returndata_size)\\n                    }\\n                } else {\\n                    revert FailedMulticall();\\n                }\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return results;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"src/logic/User.sol\": {\r\n        \"UserLib\": \"0x18fef124732702c6bb374dc92c09ebb9527095f3\"\r\n      },\r\n      \"src/logic/Collection.sol\": {\r\n        \"CollectionLib\": \"0xac19b1c26491617069cc85e3e5600624f017436a\"\r\n      },\r\n      \"src/logic/Auction.sol\": {\r\n        \"AuctionLib\": \"0x19d0715e6154285a7d6d8689006a1093af6f0f20\"\r\n      },\r\n      \"src/logic/PrivateOffer.sol\": {\r\n        \"PrivateOfferLib\": \"0xe0f08feafd681f1c44a3daee2b844a64b59207be\"\r\n      },\r\n      \"src/logic/Raffle.sol\": {\r\n        \"RaffleLib\": \"0x870ec57ae488559b310fb97df879fe31aeb80cd8\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_keyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_subId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_vrfCoordinator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"flcToken\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"ERC1967InvalidImplementation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1967NonPayable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedMulticall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientCredit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInitialization\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidParam\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NativeTransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NftCollectionAlreadySupported\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NftCollectionNotSupported\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitializing\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"have\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"}],\"name\":\"OnlyCoordinatorCanFulfill\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenNotSupported\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UUPSUnauthorizedCallContext\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"}],\"name\":\"UUPSUnsupportedProxiableUUID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"activityId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"safeBoxKeyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collectedFunds\",\"type\":\"uint256\"}],\"name\":\"AuctionEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"trigger\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"activityIds\",\"type\":\"uint64[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"settleToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumBid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeRateBips\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionEndTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"safeBoxExpiryTs\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"selfTriggered\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"adminFee\",\"type\":\"uint256\"}],\"name\":\"AuctionStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creditCost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxyCollection\",\"type\":\"address\"}],\"name\":\"ClaimExpiredNft\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creditCost\",\"type\":\"uint256\"}],\"name\":\"ClaimRandomNft\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"safeBoxKeys\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"safeBoxExpiryTs\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minMaintCredit\",\"type\":\"uint256\"}],\"name\":\"ExtendKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"FragmentNft\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"version\",\"type\":\"uint64\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"safeBoxKeys\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"safeBoxExpiryTs\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minMaintCredit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxyCollection\",\"type\":\"address\"}],\"name\":\"LockNft\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"floorToken\",\"type\":\"address\"}],\"name\":\"NewCollectionSupported\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"activityId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionEndTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"safeBoxExpiryTs\",\"type\":\"uint256\"}],\"name\":\"NewTopBidOnAuction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"activityIds\",\"type\":\"uint64[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"safeBoxKeyIds\",\"type\":\"uint256[]\"}],\"name\":\"PrivateOfferAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"activityIds\",\"type\":\"uint64[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"}],\"name\":\"PrivateOfferCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"activityIds\",\"type\":\"uint64[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"settleToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"price\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offerEndTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"safeBoxExpiryTs\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"adminFee\",\"type\":\"uint256\"}],\"name\":\"PrivateOfferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proxyCollection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlyingCollection\",\"type\":\"address\"}],\"name\":\"ProxyCollectionChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"activityId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"safeBoxKeyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collectedFunds\",\"type\":\"uint256\"}],\"name\":\"RaffleSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64[]\",\"name\":\"activityIds\",\"type\":\"uint64[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"maxTickets\",\"type\":\"uint48\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"settleToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"ticketPrice\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeRateBips\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"raffleEndTime\",\"type\":\"uint48\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"safeBoxExpiryTs\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"adminFee\",\"type\":\"uint256\"}],\"name\":\"RaffleStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"activityId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ticketsSold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"}],\"name\":\"RaffleTicketsSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"safeBoxKeys\",\"type\":\"uint256[]\"}],\"name\":\"RemoveExpiredKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trusted\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"setOrUnset\",\"type\":\"bool\"}],\"name\":\"TrustedUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxyCollection\",\"type\":\"address\"}],\"name\":\"UnlockNft\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minMaintCredit\",\"type\":\"uint256\"}],\"name\":\"UpdateMaintainCredit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"addOrRemove\",\"type\":\"bool\"}],\"name\":\"UpdateTokenSupported\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawToken\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"UPGRADE_INTERFACE_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addAndLockCredit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collectionId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ticketCnt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToTransfer\",\"type\":\"uint256\"}],\"name\":\"buyRaffleTickets\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collectionId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ticketCnt\",\"type\":\"uint256\"}],\"name\":\"buyRaffleTickets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collectionId\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"}],\"name\":\"buyerAcceptPrivateOffers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collectionId\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToTransfer\",\"type\":\"uint256\"}],\"name\":\"buyerAcceptPrivateOffers\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collectionId\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"}],\"name\":\"cancelPrivateOffers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"maxCreditCost\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"claimExpiredNfts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"claimCnt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxCreditCost\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"claimRandomNFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTimestamp\",\"type\":\"uint256\"}],\"name\":\"collectionLockingAt\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creditToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct IMulticall.CallData[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"extMulticall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"expiryTs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newVipLevel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxCreditCost\",\"type\":\"uint256\"}],\"name\":\"extendKeys\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"slot\",\"type\":\"bytes32\"}],\"name\":\"extsload\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"value\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"startSlot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nSlots\",\"type\":\"uint256\"}],\"name\":\"extsload\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"}],\"name\":\"fragmentNFTs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"}],\"name\":\"initAuctionOnExpiredSafeBoxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"expiryTs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vipLevel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxCreditCost\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"}],\"name\":\"lockNFTs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"maxExpiry\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumBid\",\"type\":\"uint256\"}],\"name\":\"ownerInitAuctions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"maxExpiry\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"price\",\"type\":\"uint96\"}],\"internalType\":\"struct IFlooring.PrivateOfferInitParam\",\"name\":\"param\",\"type\":\"tuple\"}],\"name\":\"ownerInitPrivateOffers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"ticketToken\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"ticketPrice\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"maxTickets\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxExpiry\",\"type\":\"uint256\"}],\"internalType\":\"struct IFlooring.RaffleInitParam\",\"name\":\"param\",\"type\":\"tuple\"}],\"name\":\"ownerInitRaffles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidOptionIdx\",\"type\":\"uint256\"}],\"name\":\"placeBidOnAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidOptionIdx\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToTransfer\",\"type\":\"uint256\"}],\"name\":\"placeBidOnAuction\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"}],\"name\":\"recalculateAvailableCredit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"onBehalfOf\",\"type\":\"address\"}],\"name\":\"removeExpiredKeyAndRestoreCredit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"removeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proxyCollection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"name\":\"setCollectionProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"trusted\",\"type\":\"address\"}],\"name\":\"setTrusted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"}],\"name\":\"settleAuctions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collectionId\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"}],\"name\":\"settleRaffles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_originalNFT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fragmentToken\",\"type\":\"address\"}],\"name\":\"supportNewCollection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"addOrRemove\",\"type\":\"bool\"}],\"name\":\"supportNewToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unlockCredit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiryTs\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"unlockNFTs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"trusted\",\"type\":\"address\"}],\"name\":\"unsetTrusted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawPlatformFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Flooring", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "8af398995b04c28e9951adb9721ef74c74f93e6a478f39e7e0777be13527e7ef0000000000000000000000000000000000000000000000000000000000000356000000000000000000000000271682deb8c4e0901d1a1550ad2e64d568e69909000000000000000000000000102c776ddb30c754ded4fdcc77a19230a60d4e4f", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}