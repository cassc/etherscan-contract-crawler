{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/transferProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MiladyCometh\\npragma solidity ^0.8.17;\\n\\n/// @author lcfr.eth\\n/// @notice helper contract for Flashbots rescues using bundler.lcfr.io\\n\\n/// @dev avoids using freememptr to avoid unnecessily calling add() in loops etc\\n/// @dev this is fine as our functions execution are short & sweet.\\n/// @dev for transferFrom calls the calldata is 0x64 bytes which is the size of the scratch space.\\n\\n/// @dev however for ERC1155 safeTransferFrom calls the calldata is 0xc4 bytes which is larger than the scratch space.\\n/// @dev we dont care tho - smash all the memory like its a stack based buffer and the year is 1992AD and your name is aleph1.\\n\\n/// @dev We dont call any other internal / contract methods and only perform external calls:\\n/// @dev No hash functions are used in our function executions so we dont need to care about 0x00 - 0x3f\\n/// @dev No dynamic memory is used in our function executions so we dont need to care about 0x40 - 0x5f\\n/// @dev No operations requiring the zero slot so we just plow through 0x60-0x7f+ also\\n\\ncontract transferProxy {\\n    // 0x383462e2 == \\\"notApproved()\\\"\\n    error notApproved();\\n    // 0x543bf3c4 == \\\"arrayLengthMismatch()\\\"\\n    error arrayLengthMismatch();\\n\\n    // transfers a batch of ERC721 tokens to a single address recipient from an approved caller address\\n    function approvedTransferERC721(uint256[] calldata tokenIds, address _contract, address _from, address _to) external {\\n        assembly {\\n            // check if caller isApprovedForAll() by _from on _contract or revert\\n            mstore(0x00, 0xe985e9c5ac1db17cac1db17cac1db17cac1db17cac1db17cac1db17cac1db17c)\\n            // store _from as the first parameter to isApprovedForAll()\\n            mstore(0x04, _from) \\n            // store caller as the second parameter to isApprovedForAll()\\n            mstore(0x24, caller())\\n            // call _contract.isApprovedForAll(_from, caller())\\n            let success := staticcall(gas(), _contract, 0x00, 0x44, 0x00, 0x00)\\n            // copy return data to 0x00 \\n            returndatacopy(0x00, 0x00, returndatasize())\\n            // revert if the call was not successful\\n            if iszero(success) {\\n                revert(0x00, returndatasize())\\n            }\\n            // check if the return data is 0x01 (true) or revert\\n            if iszero(mload(0x00)) {\\n                mstore(0x00, 0x383462e2)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // build calldata using the _from and _to thats supplied as an argument\\n            // transferFrom(address,address,uint256) selector\\n            // store the selector at 0x00\\n            mstore(0x00, 0x23b872ddac1db17cac1db17cac1db17cac1db17cac1db17cac1db17cac1db17c)\\n            // store the caller as the first parameter to transferFrom()\\n            mstore(0x04, _from)\\n            // store _to as the second parameter to transferFrom()\\n            mstore(0x24, _to)\\n\\n            // start our loop at 0\\n            let i := 0\\n            for {} 1 { i:= add(i, 1) } {\\n                // check if we have reached the end of the array. _data len starts at 1\\n                if eq(i, tokenIds.length){ break }\\n\\n                // copy the token id as the third parameter to transferFrom()\\n                calldatacopy(0x44, add(tokenIds.offset, shl(5, i)), 0x20)\\n\\n                // call the encoded method        \\n                success := call( gas(), _contract, 0x00, 0x00, 0x64, 0x00, 0x00)\\n\\n                if iszero(success) {\\n                    returndatacopy(0x00, 0x00, returndatasize())\\n                    revert(0x00, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice transfer assets from the owner to the _to address\\n    function ownerTransferERC721(uint256[] calldata tokenIds, address _to, address _contract) external {\\n        assembly {\\n            // transferFrom(address,address,uint256) selector\\n            // store the selector at 0x00\\n            mstore(0x00, 0x23b872ddac1db17cac1db17cac1db17cac1db17cac1db17cac1db17cac1db17c)\\n            // store the caller as the first parameter to transferFrom()\\n            mstore(0x04, caller())\\n            // store _to as the second parameter to transferFrom()\\n            mstore(0x24, _to)\\n\\n             let i := 0\\n             for {} 1 { i:= add(i, 1) } {\\n                if eq(i, tokenIds.length){ break }\\n\\n                // copy the token id as the third parameter to transferFrom()\\n                calldatacopy(0x44, add(tokenIds.offset, shl(5, i)), 0x20)\\n                \\n                // call transferFrom\\n                let success := call( gas(), _contract, 0x00, 0x00, 0x64, 0x00, 0x00)\\n\\n                if iszero(success) {\\n                    returndatacopy(0x00, 0x00, returndatasize())\\n                    revert(0x00, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice intended for transferring an array of tokens to an array of addresses from the owner\\n    function ownerAirDropERC721(uint256[] calldata tokenIds, address[] calldata _addrs, address _contract) external {\\n        assembly {\\n            // check if the arrays are the same length\\n            if iszero(eq(tokenIds.length, _addrs.length)) {\\n                mstore(0x00, 0x543bf3c4)\\n                revert(0x1c, 0x04)\\n            }\\n            // transferFrom(address,address,uint256) selector\\n            // store the selector at 0x00\\n            mstore(0x00, 0x23b872ddac1db17cac1db17cac1db17cac1db17cac1db17cac1db17cac1db17c)\\n            // store the caller as the first parameter to transferFrom()\\n            mstore(0x04, caller())\\n\\n             let i := 0\\n             for {} 1 { i:= add(i, 1) } {\\n                if eq(i, tokenIds.length){ break }\\n\\n                // offset for both arrays\\n                let offset := shl(5, i)\\n\\n                // copy the address to send to as the second parameter to transferFrom()\\n                calldatacopy(0x24, add(_addrs.offset, offset), 0x20)\\n\\n                // copy the token id as the third parameter to transferFrom()\\n                calldatacopy(0x44, add(tokenIds.offset, offset), 0x20)\\n                \\n                // call transferFrom\\n                let success := call( gas(), _contract, 0x00, 0x00, 0x64, 0x00, 0x00)\\n\\n                if iszero(success) {\\n                    returndatacopy(0x00, 0x00, returndatasize())\\n                    revert(0x00, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n\\n    // we just smash all the memory from 0x00 - 0xC4 like its a stack based buffer and the year is 1992.\\n    function ownerAirDropERC1155(uint256[] calldata _tokenIds, uint256[] calldata _amounts, address[] calldata _addrs, address _contract) external {\\n        assembly {\\n\\n            // check if all 3 the arrays are the same length\\n            let lenCheck := eq(_tokenIds.length, _amounts.length)\\n            lenCheck := and(lenCheck, eq(_amounts.length, _addrs.length))\\n\\n            if iszero(lenCheck) {\\n                mstore(0x00, 0x543bf3c4)\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // ERC1155 safeTransferFrom(address,address,uint256,uint256,bytes)\\n\\n            // store the selector at 0x00\\n            mstore(0x00, 0xf242432aac1db17cac1db17cac1db17cac1db17cac1db17cac1db17cac1db17c)\\n            // store the caller as the first parameter to safeTransferFrom()\\n            mstore(0x04, caller())\\n\\n             let i := 0\\n             for {} 1 { i:= add(i, 1) } {\\n                if eq(i, _tokenIds.length){ break }\\n\\n                // offset for both arrays\\n                let offset := shl(5, i)\\n\\n                // copy the address to send to as the second parameter\\n                calldatacopy(0x24, add(_addrs.offset, offset), 0x20)\\n\\n                // copy the token id as the third parameter\\n                calldatacopy(0x44, add(_tokenIds.offset, offset), 0x20)\\n\\n                // copy the amount as the fourth parameter\\n                calldatacopy(0x64, add(_amounts.offset, offset), 0x20)\\n\\n                // create an empty bytes and copy it as the fifth parameter\\n                mstore(0x84, 0xa0)\\n                mstore(0xa4, 0x00)\\n\\n                // call safeTransferFrom\\n                let success := call( gas(), _contract, 0x00, 0x00, 0xc4, 0x00, 0x00 )\\n\\n                if iszero(success) {\\n                    returndatacopy(0x00, 0x00, returndatasize())\\n                    revert(0x00, returndatasize())\\n                }\\n            }\\n        }\\n\\n    }\\n\\n    // ApprovedTransferERC1155 can be done via the ERC1155 safeBatchTransferFrom() function in the UI\\n    // OwnerTransferERC1155 can be done via the ERC1155 safeBatchTransferFrom() function in the UI\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"arrayLengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"notApproved\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"approvedTransferERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_addrs\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"ownerAirDropERC1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_addrs\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"ownerAirDropERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"ownerTransferERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "transferProxy", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}