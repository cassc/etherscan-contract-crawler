{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\ninterface TokenI {\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function balanceOf(address to) external returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n//*******************************************************************//\r\n//------------------ Contract to Manage Ownership -------------------//\r\n//*******************************************************************//\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev To Main Stake contract  .\r\n */\r\ncontract Alphastake is Ownable {\r\n    struct _staking {\r\n        uint256 _id;\r\n        uint256 _startTime;\r\n        uint256 _claimTime;\r\n        uint256 _amount;\r\n        uint256 _APY;\r\n    }\r\n    struct _stakingWithReward {\r\n        _staking _stakingData;\r\n        uint256 _currentRewards;\r\n    }\r\n    address public rewardPoolAddress;\r\n    address public tokenAddress = address(0);\r\n    mapping(address => mapping(uint256 => _staking)) private staking;\r\n    mapping(address => uint256) private activeStake;\r\n    uint256 private APY = 100;\r\n    uint256 private rewardPoolBal = 150000000000 * 10 ** 18;\r\n\r\n    constructor(address _tokenContract) {\r\n        tokenAddress = _tokenContract;\r\n        rewardPoolAddress = address(this);\r\n    }\r\n\r\n    /**\r\n     * @dev To show contract event  .\r\n     */\r\n    event StakeEvent(uint256 _stakeid, address _to, uint _stakeamount);\r\n    event Unstake(uint256 _stakeid, address _to, uint _amount);\r\n    event Claim(uint256 _stakeid, address _to, uint _claimamount);\r\n\r\n    /**\r\n     * @dev updates pool and apy.\r\n     */\r\n    function _updatePool(uint256 amount, bool isPositive) internal {\r\n        uint256 maxAPY = 100;\r\n        uint256 minAPY = 8;\r\n        uint256 initialSupply = 150000000000 * 10 ** 18;\r\n        uint256 breakpoint = initialSupply / 10;\r\n        if (isPositive) {\r\n            rewardPoolBal += amount;\r\n        } else {\r\n            rewardPoolBal -= amount;\r\n        }\r\n        if (rewardPoolBal >= initialSupply) {\r\n            APY = maxAPY;\r\n        }\r\n        if (rewardPoolBal >= breakpoint) {\r\n            APY =\r\n                minAPY +\r\n                ((((rewardPoolBal - breakpoint) * 10 ** 18) /\r\n                    (initialSupply - breakpoint)) * (maxAPY - minAPY)) /\r\n                10 ** 18;\r\n        } else {\r\n            APY = minAPY;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev returns APY for new users.\r\n     */\r\n    function currentAPY() public view returns (uint) {\r\n        return APY;\r\n    }\r\n\r\n    /**\r\n     * @dev returns stake instance data\r\n     */\r\n    function getStakingsWithRewards(\r\n        address user\r\n    ) public view returns (_stakingWithReward[] memory) {\r\n        uint256 userActiveStake = activeStake[user];\r\n        require(userActiveStake > 0, \"No active stake instances found\");\r\n        _stakingWithReward[]\r\n            memory stakingsWithRewards = new _stakingWithReward[](\r\n                userActiveStake\r\n            );\r\n        for (uint256 i = 0; i < userActiveStake; i++) {\r\n            stakingsWithRewards[i] = _stakingWithReward({\r\n                _stakingData: staking[user][i],\r\n                _currentRewards: currentRewards(user, i)\r\n            });\r\n        }\r\n        return stakingsWithRewards;\r\n    }\r\n\r\n    /**\r\n     * @dev return current pool balance.\r\n     *\r\n     */\r\n    function viewRewardPoolBalance() public view returns (uint256) {\r\n        return rewardPoolBal;\r\n    }\r\n\r\n    /**\r\n     * @dev returns the number of stake instances tied to a wallet.\r\n     */\r\n    function numberOfStakeInstances(\r\n        address user\r\n    ) public view returns (uint256) {\r\n        uint256 userActiveStake = activeStake[user];\r\n        return userActiveStake;\r\n    }\r\n\r\n    /**\r\n     * @dev returns current rewards for given stake instance\r\n     */\r\n    function currentRewards(\r\n        address user,\r\n        uint256 _stakeid\r\n    ) public view returns (uint256) {\r\n        require(_stakeid >= 0, \"Please set valid stakeid!\");\r\n        require(_stakeid < activeStake[user], \"Stake instance does not exist\");\r\n        uint32 oneMonth = 30 * 24 * 60 * 60;\r\n        uint256 currentTime = block.timestamp;\r\n        uint256 rewards = 0;\r\n        uint256 locktime = staking[user][_stakeid]._startTime + oneMonth;\r\n        uint256 oneYearDivisorAPY = 100 * 365 * 24 * 60 * 60;\r\n        uint256 userStartTime = staking[user][_stakeid]._startTime;\r\n        uint256 userClaimTime = staking[user][_stakeid]._claimTime;\r\n        uint256 userAmount = staking[user][_stakeid]._amount;\r\n        uint256 userAPY = staking[user][_stakeid]._APY;\r\n        uint256 gamma = 0;\r\n        if (currentTime >= locktime) {\r\n            uint256 timeDifference = 0;\r\n            uint256 alpha = 0;\r\n            uint256 beta = 0;\r\n            if (userClaimTime <= userStartTime) {\r\n                timeDifference = 0;\r\n            } else {\r\n                timeDifference = userClaimTime - userStartTime;\r\n            }\r\n            if (timeDifference <= oneMonth) {\r\n                alpha = timeDifference;\r\n            } else {\r\n                alpha = oneMonth;\r\n                beta = timeDifference - oneMonth;\r\n            }\r\n            if (currentTime <= locktime + beta) {\r\n                gamma = 0;\r\n            } else {\r\n                gamma = currentTime - (locktime + beta);\r\n            }\r\n            rewards =\r\n                (userAmount *\r\n                    userAPY *\r\n                    ((oneMonth - alpha) + (gamma * 3) / 2)) /\r\n                oneYearDivisorAPY;\r\n        } else {\r\n            if (currentTime <= userClaimTime) {\r\n                gamma = 0;\r\n            } else {\r\n                gamma = currentTime - userClaimTime;\r\n            }\r\n            rewards = (userAmount * userAPY * gamma) / oneYearDivisorAPY;\r\n        }\r\n        return rewards;\r\n    }\r\n\r\n    /**\r\n     * @dev stake amount for particular duration.\r\n     * parameters : _stakeamount ( need to set token amount for stake)\r\n     * it will increase activeStake result of particular wallet.\r\n     * NOTE: _stakeamount must be inserted without decimals\r\n     */\r\n    function stake(uint256 _stakeamount) public returns (bool) {\r\n        address user = msg.sender;\r\n        _stakeamount = _stakeamount * 10 ** 18;\r\n        require(\r\n            TokenI(tokenAddress).balanceOf(user) >= _stakeamount,\r\n            \"Insufficient tokens\"\r\n        );\r\n        require(_stakeamount > 0, \"Amount should be greater than 0\");\r\n        require(\r\n            TokenI(tokenAddress).allowance(user, rewardPoolAddress) >=\r\n                _stakeamount,\r\n            \"Insufficient allowance.\"\r\n        );\r\n        require(\r\n            TokenI(tokenAddress).transferFrom(\r\n                user,\r\n                rewardPoolAddress,\r\n                _stakeamount\r\n            ),\r\n            \"Token tranfer failed\"\r\n        );\r\n        staking[user][activeStake[user]] = _staking(\r\n            activeStake[user],\r\n            block.timestamp,\r\n            block.timestamp,\r\n            _stakeamount,\r\n            APY\r\n        );\r\n        activeStake[user] = activeStake[user] + 1;\r\n        emit StakeEvent(activeStake[user], address(this), _stakeamount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev stake amount release.\r\n     * parameters : _stakeid is active stake ids which is getting from activeStake-1\r\n     *\r\n     * it will decrease activeStake result of particular wallet.\r\n     * result : If unstake happen before time duration it will set 50% penalty on profited amount else it will sent you all stake amount,\r\n     *          to the staking wallet.\r\n     */\r\n    function unstake(uint256 _stakeid) public returns (bool) {\r\n        address user = msg.sender;\r\n        require(_stakeid >= 0, \"Please set valid stakeid!\");\r\n        require(_stakeid < activeStake[user], \"Stake instance does not exist\");\r\n        uint256 userAmount = staking[user][_stakeid]._amount;\r\n        uint256 withdrawAmount = viewWithdrawAmount(user, _stakeid);\r\n        uint256 userActiveStake = activeStake[user];\r\n        uint256 lastStake = userActiveStake - 1;\r\n        require(\r\n            TokenI(tokenAddress).transfer(user, withdrawAmount),\r\n            \"Token transfer failed\"\r\n        );\r\n        if (withdrawAmount >= userAmount) {\r\n            _updatePool(withdrawAmount - userAmount, true);\r\n        } else {\r\n            _updatePool(userAmount - withdrawAmount, false);\r\n        }\r\n        activeStake[user] = lastStake;\r\n\r\n        staking[user][_stakeid]._id = staking[user][lastStake]._id;\r\n        staking[user][_stakeid]._amount = staking[user][lastStake]._amount;\r\n        staking[user][_stakeid]._startTime = staking[user][lastStake]\r\n            ._startTime;\r\n        staking[user][_stakeid]._claimTime = staking[user][lastStake]\r\n            ._claimTime;\r\n        staking[user][_stakeid]._APY = staking[user][lastStake]._APY;\r\n\r\n        staking[user][lastStake]._id = 0;\r\n        staking[user][lastStake]._amount = 0;\r\n        staking[user][lastStake]._startTime = 0;\r\n        staking[user][lastStake]._claimTime = 0;\r\n        staking[user][lastStake]._APY = 0;\r\n        emit Unstake(_stakeid, user, withdrawAmount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev claims accrued rewards\r\n     */\r\n\r\n    function claim(uint256 _stakeid) public returns (bool) {\r\n        address user = msg.sender;\r\n        uint256 userActiveStake = activeStake[user];\r\n        require(_stakeid >= 0, \"Please set valid stakeid!\");\r\n        require(_stakeid < userActiveStake, \"Stake instance does not exist\");\r\n        uint256 claimAmount = currentRewards(user, _stakeid);\r\n        require(claimAmount > 0, \"Cannot claim non zero amount\");\r\n        require(\r\n            TokenI(tokenAddress).transfer(user, claimAmount),\r\n            \"Token transfer failed\"\r\n        );\r\n        _updatePool(claimAmount, false);\r\n        staking[user][_stakeid]._claimTime = block.timestamp;\r\n        emit Claim(_stakeid, user, claimAmount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev To know total withdrawal stake amount\r\n     * parameters : _stakeid is active stake ids which is getting from activeStake-\r\n     */\r\n    function viewWithdrawAmount(\r\n        address user,\r\n        uint256 _stakeid\r\n    ) public view returns (uint256) {\r\n        uint256 userActiveStake = activeStake[user];\r\n        require(_stakeid >= 0, \"Please set valid stakeid!\");\r\n        require(_stakeid < userActiveStake, \"Stake instance does not exist\");\r\n        uint32 oneWeek = 7 * 24 * 60 * 60;\r\n        bool isPositive = true;\r\n        uint256 currentTime = block.timestamp;\r\n        uint256 startTime = staking[user][_stakeid]._startTime;\r\n        uint256 locktime = startTime + 30 * 24 * 60 * 60;\r\n        uint256 penalty = (staking[user][_stakeid]._amount * 5) / 100;\r\n        uint256 userAmount = staking[user][_stakeid]._amount;\r\n        uint256 userRewards = currentRewards(user, _stakeid);\r\n        uint256 withdrawAmount = userAmount;\r\n        uint256 poolModifier = 0;\r\n\r\n        if (currentTime < startTime + oneWeek) {\r\n            poolModifier += penalty;\r\n            isPositive = false;\r\n        } else if (currentTime < startTime + oneWeek * 2) {\r\n            poolModifier += (userRewards * 25) / 100;\r\n        } else if (currentTime < startTime + oneWeek * 3) {\r\n            poolModifier += (userRewards * 35) / 100;\r\n        } else if (currentTime < locktime) {\r\n            poolModifier += (userRewards * 40) / 100;\r\n        } else {\r\n            poolModifier += userRewards;\r\n        }\r\n        if (isPositive) {\r\n            withdrawAmount += poolModifier;\r\n        } else {\r\n            withdrawAmount -= poolModifier;\r\n        }\r\n        return withdrawAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev To know Penalty amount, if you unstake before locktime\r\n     * parameters : _stakeid is active stake ids which is getting from activeStake-\r\n     */\r\n    function viewPenalty(\r\n        address user,\r\n        uint256 _stakeid\r\n    ) public view returns (uint256) {\r\n        uint256 userActiveStake = activeStake[user];\r\n        require(_stakeid >= 0, \"Please set valid stakeid!\");\r\n        require(_stakeid < userActiveStake, \"Stake instance does not exist\");\r\n        uint256 penaltyTime = staking[user][_stakeid]._startTime +\r\n            7 *\r\n            24 *\r\n            60 *\r\n            60;\r\n        uint256 penalty = 0;\r\n        if (block.timestamp < penaltyTime) {\r\n            penalty = (staking[user][_stakeid]._amount * 5) / 100;\r\n        }\r\n        return penalty;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stakeid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_claimamount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stakeid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stakeamount\",\"type\":\"uint256\"}],\"name\":\"StakeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stakeid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeid\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentAPY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakeid\",\"type\":\"uint256\"}],\"name\":\"currentRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getStakingsWithRewards\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_claimTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_APY\",\"type\":\"uint256\"}],\"internalType\":\"struct Alphastake._staking\",\"name\":\"_stakingData\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_currentRewards\",\"type\":\"uint256\"}],\"internalType\":\"struct Alphastake._stakingWithReward[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"numberOfStakeInstances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPoolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeamount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeid\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakeid\",\"type\":\"uint256\"}],\"name\":\"viewPenalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewRewardPoolBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakeid\",\"type\":\"uint256\"}],\"name\":\"viewWithdrawAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Alphastake", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000e784d58a669011311cf02880ec35657aef6e59e6", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d1f4fd4747ec6c56c28ff04fae84052c69e9cae52170fdef21690a3ebea746e6"}