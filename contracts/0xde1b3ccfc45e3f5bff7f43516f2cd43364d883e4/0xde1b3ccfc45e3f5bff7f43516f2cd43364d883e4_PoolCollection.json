{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlUpgradeable.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\\n */\\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControlUpgradeable {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = _allowances[owner][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastvalue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastvalue;\\n                // Update the index for the moved value\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/network/interfaces/IBancorNetwork.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport { IUpgradeable } from \\\"../../utility/interfaces/IUpgradeable.sol\\\";\\n\\nimport { Token } from \\\"../../token/Token.sol\\\";\\n\\nimport { IPoolCollection } from \\\"../../pools/interfaces/IPoolCollection.sol\\\";\\nimport { IPoolToken } from \\\"../../pools/interfaces/IPoolToken.sol\\\";\\n\\n/**\\n * @dev Flash-loan recipient interface\\n */\\ninterface IFlashLoanRecipient {\\n    /**\\n     * @dev a flash-loan recipient callback after each the caller must return the borrowed amount and an additional fee\\n     */\\n    function onFlashLoan(\\n        address caller,\\n        IERC20 erc20Token,\\n        uint256 amount,\\n        uint256 feeAmount,\\n        bytes memory data\\n    ) external;\\n}\\n\\n/**\\n * @dev Bancor Network interface\\n */\\ninterface IBancorNetwork is IUpgradeable {\\n    /**\\n     * @dev returns the set of all valid pool collections\\n     */\\n    function poolCollections() external view returns (IPoolCollection[] memory);\\n\\n    /**\\n     * @dev returns the set of all liquidity pools\\n     */\\n    function liquidityPools() external view returns (Token[] memory);\\n\\n    /**\\n     * @dev returns the respective pool collection for the provided pool\\n     */\\n    function collectionByPool(Token pool) external view returns (IPoolCollection);\\n\\n    /**\\n     * @dev creates new pools\\n     *\\n     * requirements:\\n     *\\n     * - none of the pools already exists\\n     */\\n    function createPools(Token[] calldata tokens, IPoolCollection poolCollection) external;\\n\\n    /**\\n     * @dev migrates a list of pools between pool collections\\n     *\\n     * notes:\\n     *\\n     * - invalid or incompatible pools will be skipped gracefully\\n     */\\n    function migratePools(Token[] calldata pools, IPoolCollection newPoolCollection) external;\\n\\n    /**\\n     * @dev deposits liquidity for the specified provider and returns the respective pool token amount\\n     *\\n     * requirements:\\n     *\\n     * - the caller must have approved the network to transfer the tokens on its behalf (except for in the\\n     *   native token case)\\n     */\\n    function depositFor(\\n        address provider,\\n        Token pool,\\n        uint256 tokenAmount\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @dev deposits liquidity for the current provider and returns the respective pool token amount\\n     *\\n     * requirements:\\n     *\\n     * - the caller must have approved the network to transfer the tokens on its behalf (except for in the\\n     *   native token case)\\n     */\\n    function deposit(Token pool, uint256 tokenAmount) external payable returns (uint256);\\n\\n    /**\\n     * @dev initiates liquidity withdrawal\\n     *\\n     * requirements:\\n     *\\n     * - the caller must have approved the contract to transfer the pool token amount on its behalf\\n     */\\n    function initWithdrawal(IPoolToken poolToken, uint256 poolTokenAmount) external returns (uint256);\\n\\n    /**\\n     * @dev cancels a withdrawal request, and returns the number of pool token amount associated with the withdrawal\\n     * request\\n     *\\n     * requirements:\\n     *\\n     * - the caller must have already initiated a withdrawal and received the specified id\\n     */\\n    function cancelWithdrawal(uint256 id) external returns (uint256);\\n\\n    /**\\n     * @dev withdraws liquidity and returns the withdrawn amount\\n     *\\n     * requirements:\\n     *\\n     * - the provider must have already initiated a withdrawal and received the specified id\\n     * - the specified withdrawal request is eligible for completion\\n     * - the provider must have approved the network to transfer vBNT amount on its behalf, when withdrawing BNT\\n     * liquidity\\n     */\\n    function withdraw(uint256 id) external returns (uint256);\\n\\n    /**\\n     * @dev performs a trade by providing the input source amount, sends the proceeds to the optional beneficiary (or\\n     * to the address of the caller, in case it's not supplied), and returns the trade target amount\\n     *\\n     * requirements:\\n     *\\n     * - the caller must have approved the network to transfer the source tokens on its behalf (except for in the\\n     *   native token case)\\n     */\\n    function tradeBySourceAmount(\\n        Token sourceToken,\\n        Token targetToken,\\n        uint256 sourceAmount,\\n        uint256 minReturnAmount,\\n        uint256 deadline,\\n        address beneficiary\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @dev performs a trade by providing the output target amount, sends the proceeds to the optional beneficiary (or\\n     * to the address of the caller, in case it's not supplied), and returns the trade source amount\\n     *\\n     * requirements:\\n     *\\n     * - the caller must have approved the network to transfer the source tokens on its behalf (except for in the\\n     *   native token case)\\n     */\\n    function tradeByTargetAmount(\\n        Token sourceToken,\\n        Token targetToken,\\n        uint256 targetAmount,\\n        uint256 maxSourceAmount,\\n        uint256 deadline,\\n        address beneficiary\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @dev performs a trade by providing the input source amount, sends the proceeds to the optional beneficiary (or\\n     * to the address of the caller, in case it's not supplied), and returns the trade target amount\\n     *\\n     * requirements:\\n     *\\n     * - the caller must have approved the network to transfer the source tokens on its behalf (except for in the\\n     *   native token case)\\n     * - the caller must be the _bancorArbitrage contract\\n     */\\n    function tradeBySourceAmountArb(\\n        Token sourceToken,\\n        Token targetToken,\\n        uint256 sourceAmount,\\n        uint256 minReturnAmount,\\n        uint256 deadline,\\n        address beneficiary\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @dev performs a trade by providing the output target amount, sends the proceeds to the optional beneficiary (or\\n     * to the address of the caller, in case it's not supplied), and returns the trade source amount\\n     *\\n     * requirements:\\n     *\\n     * - the caller must have approved the network to transfer the source tokens on its behalf (except for in the\\n     *   native token case)\\n     * - the caller must be the _bancorArbitrage contract\\n     */\\n    function tradeByTargetAmountArb(\\n        Token sourceToken,\\n        Token targetToken,\\n        uint256 targetAmount,\\n        uint256 maxSourceAmount,\\n        uint256 deadline,\\n        address beneficiary\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @dev provides a flash-loan\\n     *\\n     * requirements:\\n     *\\n     * - the recipient's callback must return *at least* the borrowed amount and fee back to the specified return address\\n     */\\n    function flashLoan(\\n        Token token,\\n        uint256 amount,\\n        IFlashLoanRecipient recipient,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev deposits liquidity during a migration\\n     */\\n    function migrateLiquidity(\\n        Token token,\\n        address provider,\\n        uint256 amount,\\n        uint256 availableAmount,\\n        uint256 originalAmount\\n    ) external payable;\\n\\n    /**\\n     * @dev withdraws pending network fees, and returns the amount of fees withdrawn\\n     *\\n     * requirements:\\n     *\\n     * - the caller must have the ROLE_NETWORK_FEE_MANAGER privilege\\n     */\\n    function withdrawNetworkFees(address recipient) external returns (uint256);\\n\\n    /**\\n     * @dev withdraws surplus tokens from a given pool to CarbonPOL contract,\\n     * and disables trading on the given pool if it is not already disabled\\n     */\\n    function withdrawPOL(Token pool) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/network/interfaces/INetworkSettings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\nimport { IUpgradeable } from \\\"../../utility/interfaces/IUpgradeable.sol\\\";\\n\\nimport { Token } from \\\"../../token/Token.sol\\\";\\n\\nerror NotWhitelisted();\\nerror NotWhitelistedForPOL();\\n\\nstruct VortexRewards {\\n    // the percentage of converted BNT to be sent to the initiator of the burning event (in units of PPM)\\n    uint32 burnRewardPPM;\\n    // the maximum burn reward to be sent to the initiator of the burning event\\n    uint256 burnRewardMaxAmount;\\n}\\n\\n/**\\n * @dev Network Settings interface\\n */\\ninterface INetworkSettings is IUpgradeable {\\n    /**\\n     * @dev returns the protected tokens whitelist\\n     */\\n    function protectedTokenWhitelist() external view returns (Token[] memory);\\n\\n    /**\\n     * @dev checks whether a given token is whitelisted\\n     */\\n    function isTokenWhitelisted(Token pool) external view returns (bool);\\n\\n    /**\\n     * @dev returns the tokens whitelist for POL\\n     */\\n    function tokenWhitelistForPOL() external view returns (Token[] memory);\\n\\n    /**\\n     * @dev checks whether a given token is whitelist for POL\\n     */\\n    function isTokenWhitelistedForPOL(Token pool) external view returns (bool);\\n\\n    /**\\n     * @dev returns the BNT funding limit for a given pool\\n     */\\n    function poolFundingLimit(Token pool) external view returns (uint256);\\n\\n    /**\\n     * @dev returns the minimum BNT trading liquidity required before the system enables trading in the relevant pool\\n     */\\n    function minLiquidityForTrading() external view returns (uint256);\\n\\n    /**\\n     * @dev returns the withdrawal fee (in units of PPM)\\n     */\\n    function withdrawalFeePPM() external view returns (uint32);\\n\\n    /**\\n     * @dev returns the default flash-loan fee (in units of PPM)\\n     */\\n    function defaultFlashLoanFeePPM() external view returns (uint32);\\n\\n    /**\\n     * @dev returns the flash-loan fee (in units of PPM) of a pool\\n     */\\n    function flashLoanFeePPM(Token pool) external view returns (uint32);\\n\\n    /**\\n     * @dev returns the vortex settings\\n     */\\n    function vortexRewards() external view returns (VortexRewards memory);\\n}\\n\"\r\n    },\r\n    \"contracts/pools/PoolCollection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\nimport { EnumerableSet } from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { Math } from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport { SafeCast } from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport { Token } from \\\"../token/Token.sol\\\";\\nimport { TokenLibrary } from \\\"../token/TokenLibrary.sol\\\";\\n\\nimport { IMasterVault } from \\\"../vaults/interfaces/IMasterVault.sol\\\";\\nimport { IExternalProtectionVault } from \\\"../vaults/interfaces/IExternalProtectionVault.sol\\\";\\n\\nimport { IVersioned } from \\\"../utility/interfaces/IVersioned.sol\\\";\\n\\nimport { PPM_RESOLUTION } from \\\"../utility/Constants.sol\\\";\\nimport { Owned } from \\\"../utility/Owned.sol\\\";\\nimport { BlockNumber } from \\\"../utility/BlockNumber.sol\\\";\\nimport { Fraction, Fraction112, FractionLibrary, zeroFraction112 } from \\\"../utility/FractionLibrary.sol\\\";\\nimport { Sint256, MathEx } from \\\"../utility/MathEx.sol\\\";\\n\\n// prettier-ignore\\nimport {\\n    Utils,\\n    AlreadyExists,\\n    DoesNotExist,\\n    InvalidParam,\\n    InvalidStakedBalance\\n} from \\\"../utility/Utils.sol\\\";\\n\\nimport { INetworkSettings, NotWhitelisted } from \\\"../network/interfaces/INetworkSettings.sol\\\";\\nimport { IBancorNetwork } from \\\"../network/interfaces/IBancorNetwork.sol\\\";\\n\\nimport { IPoolToken } from \\\"./interfaces/IPoolToken.sol\\\";\\nimport { IPoolTokenFactory } from \\\"./interfaces/IPoolTokenFactory.sol\\\";\\nimport { IPoolMigrator } from \\\"./interfaces/IPoolMigrator.sol\\\";\\n\\n// prettier-ignore\\nimport {\\n    AverageRates,\\n    IPoolCollection,\\n    PoolLiquidity,\\n    Pool,\\n    TRADING_STATUS_UPDATE_DEFAULT,\\n    TRADING_STATUS_UPDATE_ADMIN,\\n    TRADING_STATUS_UPDATE_MIN_LIQUIDITY,\\n    TRADING_STATUS_UPDATE_INVALID_STATE,\\n    TRADING_STATUS_UPDATE_NETWORK_DISABLE,\\n    TradeAmountAndFee,\\n    WithdrawalAmounts\\n} from \\\"./interfaces/IPoolCollection.sol\\\";\\n\\nimport { IBNTPool } from \\\"./interfaces/IBNTPool.sol\\\";\\n\\nimport { PoolCollectionWithdrawal } from \\\"./PoolCollectionWithdrawal.sol\\\";\\n\\n// base token withdrawal output amounts\\nstruct InternalWithdrawalAmounts {\\n    uint256 baseTokensToTransferFromMasterVault; // base token amount to transfer from the master vault to the provider\\n    uint256 bntToMintForProvider; // BNT amount to mint directly for the provider\\n    uint256 baseTokensToTransferFromEPV; // base token amount to transfer from the external protection vault to the provider\\n    Sint256 baseTokensTradingLiquidityDelta; // base token amount to add to the trading liquidity\\n    Sint256 bntTradingLiquidityDelta; // BNT amount to add to the trading liquidity and to the master vault\\n    Sint256 bntProtocolHoldingsDelta; // BNT amount add to the protocol equity\\n    uint256 baseTokensWithdrawalFee; // base token amount to keep in the pool as a withdrawal fee\\n    uint256 baseTokensWithdrawalAmount; // base token amount equivalent to the base pool token's withdrawal amount\\n    uint256 poolTokenAmount; // base pool token\\n    uint256 poolTokenTotalSupply; // base pool token's total supply\\n    uint256 newBaseTokenTradingLiquidity; // new base token trading liquidity\\n    uint256 newBNTTradingLiquidity; // new BNT trading liquidity\\n}\\n\\nstruct TargetTradingLiquidity {\\n    bool update;\\n    uint256 bnt;\\n    uint256 baseToken;\\n}\\n\\nenum PoolRateState {\\n    Uninitialized,\\n    Unstable,\\n    Stable\\n}\\n\\n/**\\n * @dev Pool Collection contract\\n *\\n * notes:\\n *\\n * - the address of reserve token serves as the pool unique ID in both contract functions and events\\n */\\ncontract PoolCollection is IPoolCollection, Owned, BlockNumber, Utils {\\n    using TokenLibrary for Token;\\n    using FractionLibrary for Fraction;\\n    using FractionLibrary for Fraction112;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using SafeCast for uint256;\\n\\n    error AlreadyEnabled();\\n    error DepositingDisabled();\\n    error InsufficientLiquidity();\\n    error InsufficientSourceAmount();\\n    error InsufficientTargetAmount();\\n    error InvalidRate();\\n    error RateUnstable();\\n    error TradingDisabled();\\n    error FundingLimitTooHigh();\\n\\n    uint16 private constant POOL_TYPE = 1;\\n    uint256 private constant LIQUIDITY_GROWTH_FACTOR = 2;\\n    uint256 private constant BOOTSTRAPPING_LIQUIDITY_BUFFER_FACTOR = 2;\\n    uint32 private constant DEFAULT_TRADING_FEE_PPM = 2_000; // 0.2%\\n    uint32 private constant DEFAULT_NETWORK_FEE_PPM = 200_000; // 20%\\n    uint32 private constant RATE_MAX_DEVIATION_PPM = 10_000; // %1\\n    uint32 private constant RATE_RESET_BLOCK_THRESHOLD = 100;\\n\\n    // the average rate is recalculated based on the ratio between the weights of the rates the smaller the weights are,\\n    // the larger the supported range of each one of the rates is\\n    uint256 private constant EMA_AVERAGE_RATE_WEIGHT = 4;\\n    uint256 private constant EMA_SPOT_RATE_WEIGHT = 1;\\n\\n    struct TradeIntermediateResult {\\n        uint256 sourceAmount;\\n        uint256 targetAmount;\\n        uint256 limit;\\n        uint256 tradingFeeAmount;\\n        uint256 networkFeeAmount;\\n        uint256 sourceBalance;\\n        uint256 targetBalance;\\n        uint256 stakedBalance;\\n        Token pool;\\n        bool isSourceBNT;\\n        bool bySourceAmount;\\n        uint32 tradingFeePPM;\\n        bytes32 contextId;\\n    }\\n\\n    struct TradeAmountAndTradingFee {\\n        uint256 amount;\\n        uint256 tradingFeeAmount;\\n    }\\n\\n    // the network contract\\n    IBancorNetwork private immutable _network;\\n\\n    // the address of the BNT token\\n    IERC20 private immutable _bnt;\\n\\n    // the network settings contract\\n    INetworkSettings private immutable _networkSettings;\\n\\n    // the master vault contract\\n    IMasterVault private immutable _masterVault;\\n\\n    // the BNT pool contract\\n    IBNTPool internal immutable _bntPool;\\n\\n    // the address of the external protection vault\\n    IExternalProtectionVault private immutable _externalProtectionVault;\\n\\n    // the pool token factory contract\\n    IPoolTokenFactory private immutable _poolTokenFactory;\\n\\n    // the pool migrator contract\\n    IPoolMigrator private immutable _poolMigrator;\\n\\n    // a mapping between tokens and their pools\\n    mapping(Token => Pool) internal _poolData;\\n\\n    // the set of all pools which are managed by this pool collection\\n    EnumerableSet.AddressSet private _pools;\\n\\n    // the default trading fee (in units of PPM)\\n    uint32 private _defaultTradingFeePPM;\\n\\n    // the global network fee (in units of PPM)\\n    uint32 private _networkFeePPM;\\n\\n    /**\\n     * @dev triggered when the default trading fee is updated\\n     */\\n    event DefaultTradingFeePPMUpdated(uint32 prevFeePPM, uint32 newFeePPM);\\n\\n    /**\\n     * @dev triggered when the network fee is updated\\n     */\\n    event NetworkFeePPMUpdated(uint32 prevFeePPM, uint32 newFeePPM);\\n\\n    /**\\n     * @dev triggered when a specific pool's trading fee is updated\\n     */\\n    event TradingFeePPMUpdated(Token indexed pool, uint32 prevFeePPM, uint32 newFeePPM);\\n\\n    /**\\n     * @dev triggered when trading in a specific pool is enabled/disabled\\n     */\\n    event TradingEnabled(Token indexed pool, bool indexed newStatus, uint8 indexed reason);\\n\\n    /**\\n     * @dev triggered when depositing into a specific pool is enabled/disabled\\n     */\\n    event DepositingEnabled(Token indexed pool, bool indexed newStatus);\\n\\n    /**\\n     * @dev triggered when new liquidity is deposited into a pool\\n     */\\n    event TokensDeposited(\\n        bytes32 indexed contextId,\\n        address indexed provider,\\n        Token indexed token,\\n        uint256 baseTokenAmount,\\n        uint256 poolTokenAmount\\n    );\\n\\n    /**\\n     * @dev triggered when existing liquidity is withdrawn from a pool\\n     */\\n    event TokensWithdrawn(\\n        bytes32 indexed contextId,\\n        address indexed provider,\\n        Token indexed token,\\n        uint256 baseTokenAmount,\\n        uint256 poolTokenAmount,\\n        uint256 externalProtectionBaseTokenAmount,\\n        uint256 bntAmount,\\n        uint256 withdrawalFeeAmount\\n    );\\n\\n    /**\\n     * @dev triggered when the trading liquidity in a pool is updated\\n     */\\n    event TradingLiquidityUpdated(\\n        bytes32 indexed contextId,\\n        Token indexed pool,\\n        Token indexed token,\\n        uint256 prevLiquidity,\\n        uint256 newLiquidity\\n    );\\n\\n    /**\\n     * @dev triggered when the total liquidity in a pool is updated\\n     */\\n    event TotalLiquidityUpdated(\\n        bytes32 indexed contextId,\\n        Token indexed pool,\\n        uint256 liquidity,\\n        uint256 stakedBalance,\\n        uint256 poolTokenSupply\\n    );\\n\\n    /**\\n     * @dev initializes a new PoolCollection contract\\n     */\\n    constructor(\\n        IBancorNetwork initNetwork,\\n        IERC20 initBNT,\\n        INetworkSettings initNetworkSettings,\\n        IMasterVault initMasterVault,\\n        IBNTPool initBNTPool,\\n        IExternalProtectionVault initExternalProtectionVault,\\n        IPoolTokenFactory initPoolTokenFactory,\\n        IPoolMigrator initPoolMigrator\\n    ) {\\n        _validAddress(address(initNetwork));\\n        _validAddress(address(initBNT));\\n        _validAddress(address(initNetworkSettings));\\n        _validAddress(address(initMasterVault));\\n        _validAddress(address(initBNTPool));\\n        _validAddress(address(initExternalProtectionVault));\\n        _validAddress(address(initPoolTokenFactory));\\n        _validAddress(address(initPoolMigrator));\\n\\n        _network = initNetwork;\\n        _bnt = initBNT;\\n        _networkSettings = initNetworkSettings;\\n        _masterVault = initMasterVault;\\n        _bntPool = initBNTPool;\\n        _externalProtectionVault = initExternalProtectionVault;\\n        _poolTokenFactory = initPoolTokenFactory;\\n        _poolMigrator = initPoolMigrator;\\n\\n        _setDefaultTradingFeePPM(DEFAULT_TRADING_FEE_PPM);\\n        _setNetworkFeePPM(DEFAULT_NETWORK_FEE_PPM);\\n    }\\n\\n    /**\\n     * @inheritdoc IVersioned\\n     */\\n    function version() external view virtual returns (uint16) {\\n        return 12;\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function poolType() external view virtual returns (uint16) {\\n        return POOL_TYPE;\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function defaultTradingFeePPM() external view returns (uint32) {\\n        return _defaultTradingFeePPM;\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function networkFeePPM() external view returns (uint32) {\\n        return _networkFeePPM;\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function pools() external view returns (Token[] memory) {\\n        uint256 length = _pools.length();\\n        Token[] memory list = new Token[](length);\\n        for (uint256 i = 0; i < length; i++) {\\n            list[i] = Token(_pools.at(i));\\n        }\\n        return list;\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function poolCount() external view returns (uint256) {\\n        return _pools.length();\\n    }\\n\\n    /**\\n     * @dev sets the default trading fee (in units of PPM)\\n     *\\n     * requirements:\\n     *\\n     * - the caller must be the owner of the contract\\n     */\\n    function setDefaultTradingFeePPM(\\n        uint32 newDefaultTradingFeePPM\\n    ) external onlyOwner validFee(newDefaultTradingFeePPM) {\\n        _setDefaultTradingFeePPM(newDefaultTradingFeePPM);\\n    }\\n\\n    /**\\n     * @dev sets the network fee (in units of PPM)\\n     *\\n     * requirements:\\n     *\\n     * - the caller must be the owner of the contract\\n     */\\n    function setNetworkFeePPM(uint32 newNetworkFeePPM) external onlyOwner validFee(newNetworkFeePPM) {\\n        _setNetworkFeePPM(newNetworkFeePPM);\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function createPool(Token token) external only(address(_network)) {\\n        if (!_networkSettings.isTokenWhitelisted(token)) {\\n            revert NotWhitelisted();\\n        }\\n\\n        IPoolToken newPoolToken = IPoolToken(_poolTokenFactory.createPoolToken(token));\\n\\n        newPoolToken.acceptOwnership();\\n\\n        Pool memory newPool = Pool({\\n            poolToken: newPoolToken,\\n            tradingFeePPM: _defaultTradingFeePPM,\\n            tradingEnabled: false,\\n            depositingEnabled: true,\\n            averageRates: AverageRates({ blockNumber: 0, rate: zeroFraction112(), invRate: zeroFraction112() }),\\n            liquidity: PoolLiquidity({ bntTradingLiquidity: 0, baseTokenTradingLiquidity: 0, stakedBalance: 0 })\\n        });\\n\\n        _addPool(token, newPool);\\n\\n        emit TradingEnabled({ pool: token, newStatus: newPool.tradingEnabled, reason: TRADING_STATUS_UPDATE_DEFAULT });\\n        emit TradingFeePPMUpdated({ pool: token, prevFeePPM: 0, newFeePPM: newPool.tradingFeePPM });\\n        emit DepositingEnabled({ pool: token, newStatus: newPool.depositingEnabled });\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function isPoolValid(Token pool) external view returns (bool) {\\n        return address(_poolData[pool].poolToken) != address(0);\\n    }\\n\\n    /**\\n     * @dev returns specific pool's data\\n     *\\n     * notes:\\n     *\\n     * - there is no guarantee that this function will remain forward compatible,\\n     *   so relying on it should be avoided and instead, rely on specific getters\\n     *   from the IPoolCollection interface\\n     */\\n    function poolData(Token pool) external view returns (Pool memory) {\\n        return _poolData[pool];\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function poolLiquidity(Token pool) external view returns (PoolLiquidity memory) {\\n        return _poolData[pool].liquidity;\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function poolToken(Token pool) external view returns (IPoolToken) {\\n        return _poolData[pool].poolToken;\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function tradingFeePPM(Token pool) external view returns (uint32) {\\n        return _poolData[pool].tradingFeePPM;\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function tradingEnabled(Token pool) external view returns (bool) {\\n        return _poolData[pool].tradingEnabled;\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function depositingEnabled(Token pool) external view returns (bool) {\\n        return _poolData[pool].depositingEnabled;\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function poolTokenToUnderlying(Token pool, uint256 poolTokenAmount) external view returns (uint256) {\\n        Pool storage data = _poolData[pool];\\n\\n        return _poolTokenToUnderlying(poolTokenAmount, data.poolToken.totalSupply(), data.liquidity.stakedBalance);\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function underlyingToPoolToken(Token pool, uint256 baseTokenAmount) external view returns (uint256) {\\n        Pool storage data = _poolData[pool];\\n\\n        return _underlyingToPoolToken(baseTokenAmount, data.poolToken.totalSupply(), data.liquidity.stakedBalance);\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function poolTokenAmountToBurn(\\n        Token pool,\\n        uint256 baseTokenAmountToDistribute,\\n        uint256 protocolPoolTokenAmount\\n    ) external view returns (uint256) {\\n        if (baseTokenAmountToDistribute == 0) {\\n            return 0;\\n        }\\n\\n        Pool storage data = _poolData[pool];\\n\\n        uint256 poolTokenSupply = data.poolToken.totalSupply();\\n        uint256 val = baseTokenAmountToDistribute * poolTokenSupply;\\n\\n        return\\n            MathEx.mulDivF(\\n                val,\\n                poolTokenSupply,\\n                val + data.liquidity.stakedBalance * (poolTokenSupply - protocolPoolTokenAmount)\\n            );\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function isPoolStable(Token pool) external view returns (bool) {\\n        Pool storage data = _poolData[pool];\\n\\n        return _poolRateState(data) == PoolRateState.Stable;\\n    }\\n\\n    /**\\n     * @dev sets the trading fee of a given pool\\n     *\\n     * requirements:\\n     *\\n     * - the caller must be the owner of the contract\\n     */\\n    function setTradingFeePPM(Token pool, uint32 newTradingFeePPM) external onlyOwner validFee(newTradingFeePPM) {\\n        Pool storage data = _poolStorage(pool);\\n\\n        uint32 prevTradingFeePPM = data.tradingFeePPM;\\n        if (prevTradingFeePPM == newTradingFeePPM) {\\n            return;\\n        }\\n\\n        data.tradingFeePPM = newTradingFeePPM;\\n\\n        emit TradingFeePPMUpdated({ pool: pool, prevFeePPM: prevTradingFeePPM, newFeePPM: newTradingFeePPM });\\n    }\\n\\n    /**\\n     * @dev enables trading in a given pool, by providing the funding rate as two virtual balances, and updates its\\n     * trading liquidity\\n     *\\n     * note that the virtual balances should be derived from token prices, normalized to the smallest unit of\\n     * tokens. In other words, the ratio between BNT and TKN virtual balances should be the ratio between the $ value\\n     * of 1 wei of TKN and 1 wei of BNT, taking both of their decimals into account. For example:\\n     *\\n     * - if the price of one (10**18 wei) BNT is $X and the price of one (10**18 wei) TKN is $Y, then the virtual balances\\n     *   should represent a ratio of X to Y\\n     * - if the price of one (10**18 wei) BNT is $X and the price of one (10**6 wei) USDC is $Y, then the virtual balances\\n     *   should represent a ratio of X to Y*10**12\\n     *\\n     * requirements:\\n     *\\n     * - the caller must be the owner of the contract\\n     */\\n    function enableTrading(Token pool, uint256 bntVirtualBalance, uint256 baseTokenVirtualBalance) external onlyOwner {\\n        Fraction memory fundingRate = Fraction({ n: bntVirtualBalance, d: baseTokenVirtualBalance });\\n        _validRate(fundingRate);\\n\\n        Pool storage data = _poolStorage(pool);\\n\\n        if (data.tradingEnabled) {\\n            revert AlreadyEnabled();\\n        }\\n\\n        // adjust the trading liquidity based on the base token vault balance and funding limits\\n        bytes32 contextId = keccak256(abi.encodePacked(msg.sender, pool, bntVirtualBalance, baseTokenVirtualBalance));\\n        uint256 minLiquidityForTrading = _networkSettings.minLiquidityForTrading();\\n        _updateTradingLiquidity(contextId, pool, data, fundingRate, minLiquidityForTrading);\\n\\n        // verify that the BNT trading liquidity is equal or greater than the minimum liquidity for trading\\n        if (data.liquidity.bntTradingLiquidity < minLiquidityForTrading) {\\n            revert InsufficientLiquidity();\\n        }\\n\\n        Fraction112 memory fundingRate112 = fundingRate.toFraction112();\\n        data.averageRates = AverageRates({\\n            blockNumber: _blockNumber(),\\n            rate: fundingRate112,\\n            invRate: fundingRate112.inverse()\\n        });\\n\\n        data.tradingEnabled = true;\\n\\n        emit TradingEnabled({ pool: pool, newStatus: true, reason: TRADING_STATUS_UPDATE_ADMIN });\\n    }\\n\\n    /**\\n     * @dev disables trading in a given pool\\n     *\\n     * requirements:\\n     *\\n     * - the caller must be the owner of the contract\\n     */\\n    function disableTrading(Token pool) external onlyOwner {\\n        Pool storage data = _poolStorage(pool);\\n        _resetTradingLiquidity(bytes32(0), pool, data, data.liquidity, TRADING_STATUS_UPDATE_ADMIN);\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function disableTradingByNetwork(Token pool) external only(address(_network)) {\\n        Pool storage data = _poolStorage(pool);\\n        _resetTradingLiquidity(bytes32(0), pool, data, data.liquidity, TRADING_STATUS_UPDATE_NETWORK_DISABLE);\\n    }\\n\\n    /**\\n     * @dev adjusts the trading liquidity in the given pool based on the base token\\n     * vault balance/funding limit\\n     *\\n     * requirements:\\n     *\\n     * - the caller must be the owner of the contract\\n     */\\n    function updateTradingLiquidity(Token pool) external onlyOwner {\\n        Pool storage data = _poolStorage(pool);\\n        PoolLiquidity memory liquidity = data.liquidity;\\n\\n        bytes32 contextId = keccak256(\\n            abi.encodePacked(msg.sender, pool, liquidity.bntTradingLiquidity, liquidity.baseTokenTradingLiquidity)\\n        );\\n\\n        AverageRates memory effectiveAverageRates = _effectiveAverageRates(\\n            data.averageRates,\\n            Fraction({ n: liquidity.bntTradingLiquidity, d: liquidity.baseTokenTradingLiquidity })\\n        );\\n        uint256 minLiquidityForTrading = _networkSettings.minLiquidityForTrading();\\n        _updateTradingLiquidity(\\n            contextId,\\n            pool,\\n            data,\\n            effectiveAverageRates.rate.fromFraction112(),\\n            minLiquidityForTrading\\n        );\\n    }\\n\\n    /**\\n     * @dev enables/disables depositing into a given pool\\n     *\\n     * requirements:\\n     *\\n     * - the caller must be the owner of the contract\\n     */\\n    function enableDepositing(Token pool, bool status) external onlyOwner {\\n        Pool storage data = _poolStorage(pool);\\n\\n        if (data.depositingEnabled == status) {\\n            return;\\n        }\\n\\n        data.depositingEnabled = status;\\n\\n        emit DepositingEnabled({ pool: pool, newStatus: status });\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function depositFor(\\n        bytes32 contextId,\\n        address provider,\\n        Token pool,\\n        uint256 baseTokenAmount\\n    ) external only(address(_network)) validAddress(provider) greaterThanZero(baseTokenAmount) returns (uint256) {\\n        Pool storage data = _poolStorage(pool);\\n\\n        if (!data.depositingEnabled) {\\n            revert DepositingDisabled();\\n        }\\n\\n        // if there are no pool tokens available to support the staked balance - reset the\\n        // trading liquidity and the staked balance\\n        // in addition, get the effective average rates\\n        uint256 prevPoolTokenTotalSupply = data.poolToken.totalSupply();\\n        uint256 currentStakedBalance = data.liquidity.stakedBalance;\\n        AverageRates memory effectiveAverageRates;\\n        if (prevPoolTokenTotalSupply == 0 && currentStakedBalance != 0) {\\n            currentStakedBalance = 0;\\n\\n            PoolLiquidity memory prevLiquidity = data.liquidity;\\n            _resetTradingLiquidity(contextId, pool, data, prevLiquidity, TRADING_STATUS_UPDATE_INVALID_STATE);\\n            effectiveAverageRates = AverageRates({\\n                blockNumber: 0,\\n                rate: zeroFraction112(),\\n                invRate: zeroFraction112()\\n            });\\n        } else {\\n            PoolLiquidity memory prevLiquidity = data.liquidity;\\n            effectiveAverageRates = _effectiveAverageRates(\\n                data.averageRates,\\n                Fraction({ n: prevLiquidity.bntTradingLiquidity, d: prevLiquidity.baseTokenTradingLiquidity })\\n            );\\n        }\\n\\n        // calculate the pool token amount to mint\\n        uint256 poolTokenAmount = _underlyingToPoolToken(\\n            baseTokenAmount,\\n            prevPoolTokenTotalSupply,\\n            currentStakedBalance\\n        );\\n\\n        // update the staked balance with the full base token amount\\n        data.liquidity.stakedBalance = currentStakedBalance + baseTokenAmount;\\n\\n        // mint pool tokens to the provider\\n        data.poolToken.mint(provider, poolTokenAmount);\\n\\n        // should be triggered before the trading liquidity is updated\\n        emit TokensDeposited({\\n            contextId: contextId,\\n            provider: provider,\\n            token: pool,\\n            baseTokenAmount: baseTokenAmount,\\n            poolTokenAmount: poolTokenAmount\\n        });\\n\\n        emit TotalLiquidityUpdated({\\n            contextId: contextId,\\n            pool: pool,\\n            liquidity: pool.balanceOf(address(_masterVault)),\\n            stakedBalance: data.liquidity.stakedBalance,\\n            poolTokenSupply: prevPoolTokenTotalSupply + poolTokenAmount\\n        });\\n\\n        // adjust the trading liquidity based on the base token vault balance and funding limits\\n        _updateTradingLiquidity(\\n            contextId,\\n            pool,\\n            data,\\n            effectiveAverageRates.rate.fromFraction112(),\\n            _networkSettings.minLiquidityForTrading()\\n        );\\n\\n        // if trading is enabled, then update the recent average rates\\n        if (data.tradingEnabled) {\\n            PoolLiquidity memory liquidity = data.liquidity;\\n            _updateAverageRates(\\n                data,\\n                Fraction({ n: liquidity.bntTradingLiquidity, d: liquidity.baseTokenTradingLiquidity })\\n            );\\n        }\\n\\n        return poolTokenAmount;\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function withdraw(\\n        bytes32 contextId,\\n        address provider,\\n        Token pool,\\n        uint256 poolTokenAmount,\\n        uint256 baseTokenAmount\\n    )\\n        external\\n        only(address(_network))\\n        validAddress(provider)\\n        greaterThanZero(poolTokenAmount)\\n        greaterThanZero(baseTokenAmount)\\n        returns (uint256)\\n    {\\n        Pool storage data = _poolStorage(pool);\\n        PoolLiquidity memory liquidity = data.liquidity;\\n\\n        uint256 poolTokenTotalSupply = data.poolToken.totalSupply();\\n        uint256 underlyingAmount = _poolTokenToUnderlying(\\n            poolTokenAmount,\\n            poolTokenTotalSupply,\\n            liquidity.stakedBalance\\n        );\\n\\n        if (baseTokenAmount > underlyingAmount) {\\n            revert InvalidParam();\\n        }\\n\\n        if (_poolRateState(data) == PoolRateState.Unstable) {\\n            revert RateUnstable();\\n        }\\n\\n        // obtain the withdrawal amounts\\n        InternalWithdrawalAmounts memory amounts = _poolWithdrawalAmounts(\\n            pool,\\n            poolTokenAmount,\\n            baseTokenAmount,\\n            liquidity,\\n            data.tradingFeePPM,\\n            poolTokenTotalSupply\\n        );\\n\\n        // execute the actual withdrawal\\n        _executeWithdrawal(contextId, provider, pool, data, amounts);\\n\\n        // if trading is enabled, then update the recent average rates\\n        if (data.tradingEnabled) {\\n            _updateAverageRates(\\n                data,\\n                Fraction({ n: data.liquidity.bntTradingLiquidity, d: data.liquidity.baseTokenTradingLiquidity })\\n            );\\n        }\\n\\n        return amounts.baseTokensToTransferFromMasterVault;\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function withdrawalAmounts(\\n        Token pool,\\n        uint256 poolTokenAmount\\n    ) external view validAddress(address(pool)) greaterThanZero(poolTokenAmount) returns (WithdrawalAmounts memory) {\\n        Pool storage data = _poolData[pool];\\n        PoolLiquidity memory liquidity = data.liquidity;\\n\\n        uint256 poolTokenTotalSupply = data.poolToken.totalSupply();\\n        uint256 underlyingAmount = _poolTokenToUnderlying(\\n            poolTokenAmount,\\n            poolTokenTotalSupply,\\n            liquidity.stakedBalance\\n        );\\n\\n        InternalWithdrawalAmounts memory amounts = _poolWithdrawalAmounts(\\n            pool,\\n            poolTokenAmount,\\n            underlyingAmount,\\n            liquidity,\\n            data.tradingFeePPM,\\n            poolTokenTotalSupply\\n        );\\n\\n        return\\n            WithdrawalAmounts({\\n                totalAmount: amounts.baseTokensWithdrawalAmount - amounts.baseTokensWithdrawalFee,\\n                baseTokenAmount: amounts.baseTokensToTransferFromMasterVault + amounts.baseTokensToTransferFromEPV,\\n                bntAmount: 0\\n            });\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function tradeBySourceAmount(\\n        bytes32 contextId,\\n        Token sourceToken,\\n        Token targetToken,\\n        uint256 sourceAmount,\\n        uint256 minReturnAmount,\\n        bool ignoreFees\\n    )\\n        external\\n        only(address(_network))\\n        greaterThanZero(sourceAmount)\\n        greaterThanZero(minReturnAmount)\\n        returns (TradeAmountAndFee memory)\\n    {\\n        TradeIntermediateResult memory result = _initTrade(\\n            contextId,\\n            sourceToken,\\n            targetToken,\\n            sourceAmount,\\n            minReturnAmount,\\n            true\\n        );\\n        if (ignoreFees) {\\n            result.tradingFeePPM = 0;\\n        }\\n\\n        _performTrade(result);\\n\\n        return\\n            TradeAmountAndFee({\\n                amount: result.targetAmount,\\n                tradingFeeAmount: result.tradingFeeAmount,\\n                networkFeeAmount: result.networkFeeAmount\\n            });\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function tradeByTargetAmount(\\n        bytes32 contextId,\\n        Token sourceToken,\\n        Token targetToken,\\n        uint256 targetAmount,\\n        uint256 maxSourceAmount,\\n        bool ignoreFees\\n    )\\n        external\\n        only(address(_network))\\n        greaterThanZero(targetAmount)\\n        greaterThanZero(maxSourceAmount)\\n        returns (TradeAmountAndFee memory)\\n    {\\n        TradeIntermediateResult memory result = _initTrade(\\n            contextId,\\n            sourceToken,\\n            targetToken,\\n            targetAmount,\\n            maxSourceAmount,\\n            false\\n        );\\n        if (ignoreFees) {\\n            result.tradingFeePPM = 0;\\n        }\\n\\n        _performTrade(result);\\n\\n        return\\n            TradeAmountAndFee({\\n                amount: result.sourceAmount,\\n                tradingFeeAmount: result.tradingFeeAmount,\\n                networkFeeAmount: result.networkFeeAmount\\n            });\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function tradeOutputAndFeeBySourceAmount(\\n        Token sourceToken,\\n        Token targetToken,\\n        uint256 sourceAmount\\n    ) external view greaterThanZero(sourceAmount) returns (TradeAmountAndFee memory) {\\n        TradeIntermediateResult memory result = _initTrade(bytes32(0), sourceToken, targetToken, sourceAmount, 1, true);\\n\\n        _processTrade(result);\\n\\n        return\\n            TradeAmountAndFee({\\n                amount: result.targetAmount,\\n                tradingFeeAmount: result.tradingFeeAmount,\\n                networkFeeAmount: result.networkFeeAmount\\n            });\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function tradeInputAndFeeByTargetAmount(\\n        Token sourceToken,\\n        Token targetToken,\\n        uint256 targetAmount\\n    ) external view greaterThanZero(targetAmount) returns (TradeAmountAndFee memory) {\\n        TradeIntermediateResult memory result = _initTrade(\\n            bytes32(0),\\n            sourceToken,\\n            targetToken,\\n            targetAmount,\\n            type(uint256).max,\\n            false\\n        );\\n\\n        _processTrade(result);\\n\\n        return\\n            TradeAmountAndFee({\\n                amount: result.sourceAmount,\\n                tradingFeeAmount: result.tradingFeeAmount,\\n                networkFeeAmount: result.networkFeeAmount\\n            });\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function onFeesCollected(Token pool, uint256 feeAmount) external only(address(_network)) {\\n        if (feeAmount == 0) {\\n            return;\\n        }\\n\\n        Pool storage data = _poolStorage(pool);\\n\\n        // increase the staked balance by the given amount\\n        data.liquidity.stakedBalance += feeAmount;\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function migratePoolIn(\\n        Token pool,\\n        Pool calldata data\\n    ) external validAddress(address(pool)) only(address(_poolMigrator)) {\\n        _addPool(pool, data);\\n\\n        data.poolToken.acceptOwnership();\\n    }\\n\\n    /**\\n     * @inheritdoc IPoolCollection\\n     */\\n    function migratePoolOut(\\n        Token pool,\\n        IPoolCollection targetPoolCollection\\n    ) external validAddress(address(targetPoolCollection)) only(address(_poolMigrator)) {\\n        IPoolToken cachedPoolToken = _poolData[pool].poolToken;\\n\\n        _removePool(pool);\\n\\n        cachedPoolToken.transferOwnership(address(targetPoolCollection));\\n    }\\n\\n    /**\\n     * @dev adds a pool\\n     */\\n    function _addPool(Token pool, Pool memory data) private {\\n        if (!_pools.add(address(pool))) {\\n            revert AlreadyExists();\\n        }\\n\\n        _poolData[pool] = data;\\n    }\\n\\n    /**\\n     * @dev removes a pool\\n     */\\n    function _removePool(Token pool) private {\\n        if (!_pools.remove(address(pool))) {\\n            revert DoesNotExist();\\n        }\\n\\n        delete _poolData[pool];\\n    }\\n\\n    /**\\n     * @dev returns withdrawal amounts\\n     */\\n    function _poolWithdrawalAmounts(\\n        Token pool,\\n        uint256 poolTokenAmount,\\n        uint256 baseTokensWithdrawalAmount,\\n        PoolLiquidity memory liquidity,\\n        uint32 poolTradingFeePPM,\\n        uint256 poolTokenTotalSupply\\n    ) internal view returns (InternalWithdrawalAmounts memory) {\\n        // the base token trading liquidity of a given pool can never be higher than the base token balance of the vault\\n        // whenever the base token trading liquidity is updated, it is set to at most the base token balance of the vault\\n        uint256 baseTokenExcessAmount = pool.balanceOf(address(_masterVault)) - liquidity.baseTokenTradingLiquidity;\\n\\n        PoolCollectionWithdrawal.Output memory output = PoolCollectionWithdrawal.calculateWithdrawalAmounts(\\n            liquidity.bntTradingLiquidity,\\n            liquidity.baseTokenTradingLiquidity,\\n            baseTokenExcessAmount,\\n            liquidity.stakedBalance,\\n            pool.balanceOf(address(_externalProtectionVault)),\\n            poolTradingFeePPM,\\n            _networkSettings.withdrawalFeePPM(),\\n            baseTokensWithdrawalAmount\\n        );\\n\\n        return\\n            InternalWithdrawalAmounts({\\n                baseTokensToTransferFromMasterVault: output.s,\\n                bntToMintForProvider: output.t,\\n                baseTokensToTransferFromEPV: output.u,\\n                baseTokensTradingLiquidityDelta: output.r,\\n                bntTradingLiquidityDelta: output.p,\\n                bntProtocolHoldingsDelta: output.q,\\n                baseTokensWithdrawalFee: output.v,\\n                baseTokensWithdrawalAmount: baseTokensWithdrawalAmount,\\n                poolTokenAmount: poolTokenAmount,\\n                poolTokenTotalSupply: poolTokenTotalSupply,\\n                newBaseTokenTradingLiquidity: output.r.isNeg\\n                    ? liquidity.baseTokenTradingLiquidity - output.r.value\\n                    : liquidity.baseTokenTradingLiquidity + output.r.value,\\n                newBNTTradingLiquidity: output.p.isNeg\\n                    ? liquidity.bntTradingLiquidity - output.p.value\\n                    : liquidity.bntTradingLiquidity + output.p.value\\n            });\\n    }\\n\\n    /**\\n     * @dev executes the following actions:\\n     *\\n     * - burn the network's base pool tokens\\n     * - update the pool's base token staked balance\\n     * - update the pool's base token trading liquidity\\n     * - update the pool's BNT trading liquidity\\n     * - update the pool's trading liquidity product\\n     * - emit an event if the pool's BNT trading liquidity has crossed the minimum threshold\\n     *   (either above the threshold or below the threshold)\\n     */\\n    function _executeWithdrawal(\\n        bytes32 contextId,\\n        address provider,\\n        Token pool,\\n        Pool storage data,\\n        InternalWithdrawalAmounts memory amounts\\n    ) private {\\n        PoolLiquidity storage liquidity = data.liquidity;\\n        PoolLiquidity memory prevLiquidity = liquidity;\\n\\n        data.poolToken.burn(amounts.poolTokenAmount);\\n\\n        uint256 newPoolTokenTotalSupply = amounts.poolTokenTotalSupply - amounts.poolTokenAmount;\\n        uint256 newStakedBalance = MathEx.mulDivF(\\n            liquidity.stakedBalance,\\n            newPoolTokenTotalSupply,\\n            amounts.poolTokenTotalSupply\\n        );\\n\\n        liquidity.stakedBalance = newStakedBalance;\\n\\n        // trading liquidity is assumed to never exceed 128 bits (the cast below will revert otherwise)\\n        liquidity.baseTokenTradingLiquidity = amounts.newBaseTokenTradingLiquidity.toUint128();\\n        liquidity.bntTradingLiquidity = amounts.newBNTTradingLiquidity.toUint128();\\n\\n        if (amounts.bntProtocolHoldingsDelta.value > 0) {\\n            assert(amounts.bntProtocolHoldingsDelta.isNeg); // currently no support for requesting funding here\\n\\n            _bntPool.renounceFunding(contextId, pool, amounts.bntProtocolHoldingsDelta.value);\\n        } else if (amounts.bntTradingLiquidityDelta.value > 0) {\\n            if (amounts.bntTradingLiquidityDelta.isNeg) {\\n                _bntPool.burnFromVault(amounts.bntTradingLiquidityDelta.value);\\n            } else {\\n                _bntPool.mint(address(_masterVault), amounts.bntTradingLiquidityDelta.value);\\n            }\\n        }\\n\\n        // if the provider should receive some base tokens from the external protection vault - remove the tokens from\\n        // the external protection vault and send them to the master vault\\n        if (amounts.baseTokensToTransferFromEPV > 0) {\\n            _externalProtectionVault.withdrawFunds(\\n                pool,\\n                payable(address(_masterVault)),\\n                amounts.baseTokensToTransferFromEPV\\n            );\\n            amounts.baseTokensToTransferFromMasterVault += amounts.baseTokensToTransferFromEPV;\\n        }\\n\\n        // if the provider should receive some base tokens from the master vault - remove the tokens from the master\\n        // vault and send them to the provider\\n        if (amounts.baseTokensToTransferFromMasterVault > 0) {\\n            _masterVault.withdrawFunds(pool, payable(provider), amounts.baseTokensToTransferFromMasterVault);\\n        }\\n\\n        // ensure that the average rate is reset when the pool is being emptied\\n        if (amounts.newBaseTokenTradingLiquidity == 0) {\\n            data.averageRates.rate = zeroFraction112();\\n            data.averageRates.invRate = zeroFraction112();\\n        }\\n\\n        // if the new BNT trading liquidity is below the minimum liquidity for trading - reset the liquidity\\n        if (amounts.newBNTTradingLiquidity < _networkSettings.minLiquidityForTrading()) {\\n            _resetTradingLiquidity(\\n                contextId,\\n                pool,\\n                data,\\n                prevLiquidity,\\n                amounts.newBNTTradingLiquidity,\\n                TRADING_STATUS_UPDATE_MIN_LIQUIDITY\\n            );\\n        } else {\\n            _dispatchTradingLiquidityEvents(contextId, pool, prevLiquidity, liquidity);\\n        }\\n\\n        emit TokensWithdrawn({\\n            contextId: contextId,\\n            provider: provider,\\n            token: pool,\\n            baseTokenAmount: amounts.baseTokensToTransferFromMasterVault,\\n            poolTokenAmount: amounts.poolTokenAmount,\\n            externalProtectionBaseTokenAmount: amounts.baseTokensToTransferFromEPV,\\n            bntAmount: 0,\\n            withdrawalFeeAmount: amounts.baseTokensWithdrawalFee\\n        });\\n\\n        emit TotalLiquidityUpdated({\\n            contextId: contextId,\\n            pool: pool,\\n            liquidity: pool.balanceOf(address(_masterVault)),\\n            stakedBalance: newStakedBalance,\\n            poolTokenSupply: newPoolTokenTotalSupply\\n        });\\n    }\\n\\n    /**\\n     * @dev sets the default trading fee (in units of PPM)\\n     */\\n    function _setDefaultTradingFeePPM(uint32 newDefaultTradingFeePPM) private {\\n        uint32 prevDefaultTradingFeePPM = _defaultTradingFeePPM;\\n        if (prevDefaultTradingFeePPM == newDefaultTradingFeePPM) {\\n            return;\\n        }\\n\\n        _defaultTradingFeePPM = newDefaultTradingFeePPM;\\n\\n        emit DefaultTradingFeePPMUpdated({ prevFeePPM: prevDefaultTradingFeePPM, newFeePPM: newDefaultTradingFeePPM });\\n    }\\n\\n    /**\\n     * @dev sets the network fee (in units of PPM)\\n     */\\n    function _setNetworkFeePPM(uint32 newNetworkFeePPM) private {\\n        uint32 prevNetworkFeePPM = _networkFeePPM;\\n        if (prevNetworkFeePPM == newNetworkFeePPM) {\\n            return;\\n        }\\n\\n        _networkFeePPM = newNetworkFeePPM;\\n\\n        emit NetworkFeePPMUpdated({ prevFeePPM: prevNetworkFeePPM, newFeePPM: newNetworkFeePPM });\\n    }\\n\\n    /**\\n     * @dev returns a storage reference to pool data\\n     */\\n    function _poolStorage(Token pool) private view returns (Pool storage) {\\n        Pool storage data = _poolData[pool];\\n        if (address(data.poolToken) == address(0)) {\\n            revert DoesNotExist();\\n        }\\n\\n        return data;\\n    }\\n\\n    /**\\n     * @dev calculates base tokens amount\\n     */\\n    function _poolTokenToUnderlying(\\n        uint256 poolTokenAmount,\\n        uint256 poolTokenSupply,\\n        uint256 stakedBalance\\n    ) private pure returns (uint256) {\\n        if (poolTokenSupply == 0) {\\n            // if this is the initial liquidity provision - use a one-to-one pool token to base token rate\\n            if (stakedBalance > 0) {\\n                revert InvalidStakedBalance();\\n            }\\n\\n            return poolTokenAmount;\\n        }\\n\\n        return MathEx.mulDivF(poolTokenAmount, stakedBalance, poolTokenSupply);\\n    }\\n\\n    /**\\n     * @dev calculates pool tokens amount\\n     */\\n    function _underlyingToPoolToken(\\n        uint256 baseTokenAmount,\\n        uint256 poolTokenSupply,\\n        uint256 stakedBalance\\n    ) private pure returns (uint256) {\\n        if (poolTokenSupply == 0) {\\n            // if this is the initial liquidity provision - use a one-to-one pool token to base token rate\\n            if (stakedBalance > 0) {\\n                revert InvalidStakedBalance();\\n            }\\n\\n            return baseTokenAmount;\\n        }\\n\\n        return MathEx.mulDivC(baseTokenAmount, poolTokenSupply, stakedBalance);\\n    }\\n\\n    /**\\n     * @dev calculates the target trading liquidities, taking into account the total out-of-curve base token liquidity,\\n     * and the deltas between the new and the previous states\\n     */\\n    function _calcTargetTradingLiquidity(\\n        uint256 baseTokenTotalLiquidity,\\n        uint256 fundingLimit,\\n        uint256 currentFunding,\\n        PoolLiquidity memory liquidity,\\n        Fraction memory fundingRate,\\n        uint256 minLiquidityForTrading\\n    ) private pure returns (TargetTradingLiquidity memory) {\\n        // calculate the target BNT trading liquidity based on the following:\\n        // - BNT liquidity required to match the based token unused (off-curve) liquidity\\n        // - BNT funding limit\\n        // - current BNT funding\\n        uint256 targetBNTTradingLiquidity = liquidity.bntTradingLiquidity;\\n        if (fundingLimit > currentFunding) {\\n            // increase the trading liquidity\\n            uint256 availableFunding = fundingLimit - currentFunding;\\n            uint256 baseTokenUnusedLiquidity = baseTokenTotalLiquidity - liquidity.baseTokenTradingLiquidity;\\n            uint256 targetBNTTradingLiquidityDelta = Math.min(\\n                MathEx.mulDivF(baseTokenUnusedLiquidity, fundingRate.n, fundingRate.d),\\n                availableFunding\\n            );\\n            targetBNTTradingLiquidity = liquidity.bntTradingLiquidity + targetBNTTradingLiquidityDelta;\\n        } else if (fundingLimit < currentFunding) {\\n            // decrease the trading liquidity\\n            uint256 excessFunding = currentFunding - fundingLimit;\\n            targetBNTTradingLiquidity = MathEx.subMax0(liquidity.bntTradingLiquidity, excessFunding);\\n        }\\n\\n        // if the target is equal to the current trading liquidity, no update is needed\\n        if (targetBNTTradingLiquidity == liquidity.bntTradingLiquidity) {\\n            return TargetTradingLiquidity({ update: false, bnt: 0, baseToken: 0 });\\n        }\\n\\n        // ensure that the target is above the minimum liquidity for trading\\n        if (targetBNTTradingLiquidity < minLiquidityForTrading) {\\n            return TargetTradingLiquidity({ update: true, bnt: 0, baseToken: 0 });\\n        }\\n\\n        // calculate the target base token trading liquidity using the following:\\n        // - calculate the delta between the current/target BNT trading liquidity\\n        // - calculate the base token trading liquidity delta based on the BNT trading liquidity delta and the funding rate\\n        // - apply the base token trading liquidity delta to the current base token trading liquidity\\n        //\\n        // note that the effective funding rate is always the rate between BNT and the base token)\\n        uint256 bntTradingLiquidityDelta;\\n        uint256 baseTokenTradingLiquidityDelta;\\n\\n        // liquidity increase\\n        // note that liquidity increase is capped\\n        if (targetBNTTradingLiquidity > liquidity.bntTradingLiquidity) {\\n            uint256 tradingLiquidityCap;\\n            if (liquidity.bntTradingLiquidity == 0) {\\n                // the current BNT trading liquidity is 0 - cap the target trading liquidity\\n                // by the default bootstrap amount, which includes a buffer to reduce the chance\\n                // for trading to be disabled as a result of trades in the pool\\n                tradingLiquidityCap = minLiquidityForTrading * BOOTSTRAPPING_LIQUIDITY_BUFFER_FACTOR;\\n            } else {\\n                // the current BNT trading liquidity is not 0 - cap the target using the growth factor\\n                tradingLiquidityCap = liquidity.bntTradingLiquidity * LIQUIDITY_GROWTH_FACTOR;\\n            }\\n\\n            // apply the trading liquidity cap\\n            targetBNTTradingLiquidity = Math.min(targetBNTTradingLiquidity, tradingLiquidityCap);\\n\\n            // calculate the trading liquidity deltas and return them\\n            bntTradingLiquidityDelta = targetBNTTradingLiquidity - liquidity.bntTradingLiquidity;\\n            baseTokenTradingLiquidityDelta = MathEx.mulDivF(bntTradingLiquidityDelta, fundingRate.d, fundingRate.n);\\n\\n            return\\n                TargetTradingLiquidity({\\n                    update: true,\\n                    bnt: targetBNTTradingLiquidity,\\n                    baseToken: liquidity.baseTokenTradingLiquidity + baseTokenTradingLiquidityDelta\\n                });\\n        }\\n\\n        // liquidity decrease\\n        // note that liquidity decrease isn't capped\\n        // calculate the trading liquidity deltas and return them\\n        bntTradingLiquidityDelta = liquidity.bntTradingLiquidity - targetBNTTradingLiquidity;\\n        baseTokenTradingLiquidityDelta = MathEx.mulDivF(bntTradingLiquidityDelta, fundingRate.d, fundingRate.n);\\n\\n        return\\n            TargetTradingLiquidity({\\n                update: true,\\n                bnt: targetBNTTradingLiquidity,\\n                baseToken: MathEx.subMax0(liquidity.baseTokenTradingLiquidity, baseTokenTradingLiquidityDelta)\\n            });\\n    }\\n\\n    /**\\n     * @dev adjusts the trading liquidity based on the newly added tokens delta amount, and funding limits\\n     */\\n    function _updateTradingLiquidity(\\n        bytes32 contextId,\\n        Token pool,\\n        Pool storage data,\\n        Fraction memory fundingRate,\\n        uint256 minLiquidityForTrading\\n    ) private {\\n        // ensure that the base token reserve isn't empty\\n        uint256 baseTokenTotalLiquidity = pool.balanceOf(address(_masterVault));\\n        if (baseTokenTotalLiquidity == 0) {\\n            revert InsufficientLiquidity();\\n        }\\n\\n        if (_poolRateState(data) == PoolRateState.Unstable) {\\n            return;\\n        }\\n\\n        PoolLiquidity memory prevLiquidity = data.liquidity;\\n        if (!fundingRate.isPositive()) {\\n            _resetTradingLiquidity(contextId, pool, data, prevLiquidity, TRADING_STATUS_UPDATE_MIN_LIQUIDITY);\\n            return;\\n        }\\n\\n        TargetTradingLiquidity memory targetTradingLiquidity = _calcTargetTradingLiquidity(\\n            baseTokenTotalLiquidity,\\n            _networkSettings.poolFundingLimit(pool),\\n            _bntPool.currentPoolFunding(pool),\\n            prevLiquidity,\\n            fundingRate,\\n            minLiquidityForTrading\\n        );\\n\\n        if (!targetTradingLiquidity.update) {\\n            return;\\n        }\\n\\n        if (targetTradingLiquidity.bnt == 0 || targetTradingLiquidity.baseToken == 0) {\\n            _resetTradingLiquidity(contextId, pool, data, prevLiquidity, TRADING_STATUS_UPDATE_MIN_LIQUIDITY);\\n            return;\\n        }\\n\\n        // update funding from the BNT pool\\n        if (targetTradingLiquidity.bnt > prevLiquidity.bntTradingLiquidity) {\\n            _bntPool.requestFunding(contextId, pool, targetTradingLiquidity.bnt - prevLiquidity.bntTradingLiquidity);\\n        } else if (targetTradingLiquidity.bnt < prevLiquidity.bntTradingLiquidity) {\\n            _bntPool.renounceFunding(contextId, pool, prevLiquidity.bntTradingLiquidity - targetTradingLiquidity.bnt);\\n        }\\n\\n        // trading liquidity is assumed to never exceed 128 bits (the cast below will revert otherwise)\\n        PoolLiquidity memory newLiquidity = PoolLiquidity({\\n            bntTradingLiquidity: targetTradingLiquidity.bnt.toUint128(),\\n            baseTokenTradingLiquidity: targetTradingLiquidity.baseToken.toUint128(),\\n            stakedBalance: prevLiquidity.stakedBalance\\n        });\\n\\n        // update the liquidity data of the pool\\n        data.liquidity = newLiquidity;\\n\\n        _dispatchTradingLiquidityEvents(contextId, pool, prevLiquidity, newLiquidity);\\n    }\\n\\n    function _dispatchTradingLiquidityEvents(\\n        bytes32 contextId,\\n        Token pool,\\n        PoolLiquidity memory prevLiquidity,\\n        PoolLiquidity memory newLiquidity\\n    ) private {\\n        if (newLiquidity.bntTradingLiquidity != prevLiquidity.bntTradingLiquidity) {\\n            emit TradingLiquidityUpdated({\\n                contextId: contextId,\\n                pool: pool,\\n                token: Token(address(_bnt)),\\n                prevLiquidity: prevLiquidity.bntTradingLiquidity,\\n                newLiquidity: newLiquidity.bntTradingLiquidity\\n            });\\n        }\\n\\n        if (newLiquidity.baseTokenTradingLiquidity != prevLiquidity.baseTokenTradingLiquidity) {\\n            emit TradingLiquidityUpdated({\\n                contextId: contextId,\\n                pool: pool,\\n                token: pool,\\n                prevLiquidity: prevLiquidity.baseTokenTradingLiquidity,\\n                newLiquidity: newLiquidity.baseTokenTradingLiquidity\\n            });\\n        }\\n    }\\n\\n    /**\\n     * @dev resets trading liquidity and renounces any remaining BNT funding\\n     */\\n    function _resetTradingLiquidity(\\n        bytes32 contextId,\\n        Token pool,\\n        Pool storage data,\\n        PoolLiquidity memory prevLiquidity,\\n        uint8 reason\\n    ) private {\\n        _resetTradingLiquidity(contextId, pool, data, prevLiquidity, data.liquidity.bntTradingLiquidity, reason);\\n    }\\n\\n    /**\\n     * @dev resets trading liquidity and renounces any remaining BNT funding\\n     */\\n    function _resetTradingLiquidity(\\n        bytes32 contextId,\\n        Token pool,\\n        Pool storage data,\\n        PoolLiquidity memory prevLiquidity,\\n        uint256 currentBNTTradingLiquidity,\\n        uint8 reason\\n    ) private {\\n        // reset the network and base token trading liquidities\\n        data.liquidity.bntTradingLiquidity = 0;\\n        data.liquidity.baseTokenTradingLiquidity = 0;\\n\\n        // reset the recent average rage\\n        data.averageRates = AverageRates({ blockNumber: 0, rate: zeroFraction112(), invRate: zeroFraction112() });\\n\\n        // ensure that trading is disabled\\n        if (data.tradingEnabled) {\\n            data.tradingEnabled = false;\\n\\n            emit TradingEnabled({ pool: pool, newStatus: false, reason: reason });\\n        }\\n\\n        // renounce all network liquidity\\n        if (currentBNTTradingLiquidity > 0) {\\n            _bntPool.renounceFunding(contextId, pool, currentBNTTradingLiquidity);\\n        }\\n\\n        _dispatchTradingLiquidityEvents(contextId, pool, prevLiquidity, data.liquidity);\\n    }\\n\\n    /**\\n     * @dev returns initial trading params\\n     */\\n    function _initTrade(\\n        bytes32 contextId,\\n        Token sourceToken,\\n        Token targetToken,\\n        uint256 amount,\\n        uint256 limit,\\n        bool bySourceAmount\\n    ) private view returns (TradeIntermediateResult memory result) {\\n        // ensure that BNT is either the source or the target token\\n        bool isSourceBNT = sourceToken.isEqual(_bnt);\\n        bool isTargetBNT = targetToken.isEqual(_bnt);\\n\\n        if (isSourceBNT && !isTargetBNT) {\\n            result.isSourceBNT = true;\\n            result.pool = targetToken;\\n        } else if (!isSourceBNT && isTargetBNT) {\\n            result.isSourceBNT = false;\\n            result.pool = sourceToken;\\n        } else {\\n            // BNT isn't one of the tokens or is both of them\\n            revert DoesNotExist();\\n        }\\n\\n        Pool storage data = _poolStorage(result.pool);\\n\\n        // verify that trading is enabled\\n        if (!data.tradingEnabled) {\\n            revert TradingDisabled();\\n        }\\n\\n        result.contextId = contextId;\\n        result.bySourceAmount = bySourceAmount;\\n\\n        if (result.bySourceAmount) {\\n            result.sourceAmount = amount;\\n        } else {\\n            result.targetAmount = amount;\\n        }\\n\\n        result.limit = limit;\\n        result.tradingFeePPM = data.tradingFeePPM;\\n\\n        PoolLiquidity memory liquidity = data.liquidity;\\n        if (result.isSourceBNT) {\\n            result.sourceBalance = liquidity.bntTradingLiquidity;\\n            result.targetBalance = liquidity.baseTokenTradingLiquidity;\\n        } else {\\n            result.sourceBalance = liquidity.baseTokenTradingLiquidity;\\n            result.targetBalance = liquidity.bntTradingLiquidity;\\n        }\\n\\n        result.stakedBalance = liquidity.stakedBalance;\\n    }\\n\\n    /**\\n     * @dev returns trade amount and fee by providing the source amount\\n     */\\n    function _tradeAmountAndFeeBySourceAmount(\\n        uint256 sourceBalance,\\n        uint256 targetBalance,\\n        uint32 feePPM,\\n        uint256 sourceAmount\\n    ) private pure returns (TradeAmountAndTradingFee memory) {\\n        if (sourceBalance == 0 || targetBalance == 0) {\\n            revert InsufficientLiquidity();\\n        }\\n\\n        uint256 targetAmount = MathEx.mulDivF(targetBalance, sourceAmount, sourceBalance + sourceAmount);\\n        uint256 tradingFeeAmount = MathEx.mulDivF(targetAmount, feePPM, PPM_RESOLUTION);\\n\\n        return\\n            TradeAmountAndTradingFee({ amount: targetAmount - tradingFeeAmount, tradingFeeAmount: tradingFeeAmount });\\n    }\\n\\n    /**\\n     * @dev returns trade amount and fee by providing either the target amount\\n     */\\n    function _tradeAmountAndFeeByTargetAmount(\\n        uint256 sourceBalance,\\n        uint256 targetBalance,\\n        uint32 feePPM,\\n        uint256 targetAmount\\n    ) private pure returns (TradeAmountAndTradingFee memory) {\\n        if (sourceBalance == 0) {\\n            revert InsufficientLiquidity();\\n        }\\n\\n        uint256 tradingFeeAmount = MathEx.mulDivF(targetAmount, feePPM, PPM_RESOLUTION - feePPM);\\n        uint256 fullTargetAmount = targetAmount + tradingFeeAmount;\\n        uint256 sourceAmount = MathEx.mulDivF(sourceBalance, fullTargetAmount, targetBalance - fullTargetAmount);\\n\\n        return TradeAmountAndTradingFee({ amount: sourceAmount, tradingFeeAmount: tradingFeeAmount });\\n    }\\n\\n    /**\\n     * @dev processes a trade by providing either the source or the target amount and updates the in-memory intermediate\\n     * result\\n     */\\n    function _processTrade(TradeIntermediateResult memory result) private view {\\n        TradeAmountAndTradingFee memory tradeAmountAndFee;\\n\\n        if (result.bySourceAmount) {\\n            tradeAmountAndFee = _tradeAmountAndFeeBySourceAmount(\\n                result.sourceBalance,\\n                result.targetBalance,\\n                result.tradingFeePPM,\\n                result.sourceAmount\\n            );\\n\\n            result.targetAmount = tradeAmountAndFee.amount;\\n\\n            // ensure that the target amount is above the requested minimum return amount\\n            if (result.targetAmount < result.limit) {\\n                revert InsufficientTargetAmount();\\n            }\\n        } else {\\n            tradeAmountAndFee = _tradeAmountAndFeeByTargetAmount(\\n                result.sourceBalance,\\n                result.targetBalance,\\n                result.tradingFeePPM,\\n                result.targetAmount\\n            );\\n\\n            result.sourceAmount = tradeAmountAndFee.amount;\\n\\n            // ensure that the user has provided enough tokens to make the trade\\n            if (result.sourceAmount == 0 || result.sourceAmount > result.limit) {\\n                revert InsufficientSourceAmount();\\n            }\\n        }\\n\\n        result.tradingFeeAmount = tradeAmountAndFee.tradingFeeAmount;\\n\\n        // sync the trading and staked balance\\n        result.sourceBalance += result.sourceAmount;\\n        result.targetBalance -= result.targetAmount;\\n\\n        if (result.isSourceBNT) {\\n            result.stakedBalance += result.tradingFeeAmount;\\n        }\\n\\n        _processNetworkFee(result);\\n    }\\n\\n    /**\\n     * @dev processes the network fee and updates the in-memory intermediate result\\n     */\\n    function _processNetworkFee(TradeIntermediateResult memory result) private view {\\n        if (_networkFeePPM == 0) {\\n            return;\\n        }\\n\\n        // calculate the target network fee amount\\n        uint256 targetNetworkFeeAmount = MathEx.mulDivF(result.tradingFeeAmount, _networkFeePPM, PPM_RESOLUTION);\\n\\n        // update the target balance (but don't deduct it from the full trading fee amount)\\n        result.targetBalance -= targetNetworkFeeAmount;\\n\\n        if (!result.isSourceBNT) {\\n            result.networkFeeAmount = targetNetworkFeeAmount;\\n\\n            return;\\n        }\\n\\n        // trade the network fee (taken from the base token) to BNT\\n        result.networkFeeAmount = _tradeAmountAndFeeBySourceAmount(\\n            result.targetBalance,\\n            result.sourceBalance,\\n            0,\\n            targetNetworkFeeAmount\\n        ).amount;\\n\\n        // since we have received the network fee in base tokens and have traded them for BNT (so that the network fee\\n        // is always kept in BNT), we'd need to adapt the trading liquidity and the staked balance accordingly\\n        result.targetBalance += targetNetworkFeeAmount;\\n        result.sourceBalance -= result.networkFeeAmount;\\n        result.stakedBalance -= targetNetworkFeeAmount;\\n    }\\n\\n    /**\\n     * @dev performs a trade\\n     */\\n    function _performTrade(TradeIntermediateResult memory result) private {\\n        Pool storage data = _poolData[result.pool];\\n        PoolLiquidity memory prevLiquidity = data.liquidity;\\n\\n        // update the recent average rate\\n        _updateAverageRates(\\n            data,\\n            Fraction({ n: prevLiquidity.bntTradingLiquidity, d: prevLiquidity.baseTokenTradingLiquidity })\\n        );\\n\\n        _processTrade(result);\\n\\n        // trading liquidity is assumed to never exceed 128 bits (the cast below will revert otherwise)\\n        PoolLiquidity memory newLiquidity = PoolLiquidity({\\n            bntTradingLiquidity: (result.isSourceBNT ? result.sourceBalance : result.targetBalance).toUint128(),\\n            baseTokenTradingLiquidity: (result.isSourceBNT ? result.targetBalance : result.sourceBalance).toUint128(),\\n            stakedBalance: result.stakedBalance\\n        });\\n\\n        _dispatchTradingLiquidityEvents(result.contextId, result.pool, prevLiquidity, newLiquidity);\\n\\n        // update the liquidity data of the pool\\n        data.liquidity = newLiquidity;\\n    }\\n\\n    /**\\n     * @dev returns the state of a pool's rate\\n     */\\n    function _poolRateState(Pool storage data) internal view returns (PoolRateState) {\\n        Fraction memory spotRate = Fraction({\\n            n: data.liquidity.bntTradingLiquidity,\\n            d: data.liquidity.baseTokenTradingLiquidity\\n        });\\n\\n        AverageRates memory averageRates = data.averageRates;\\n        Fraction112 memory rate = averageRates.rate;\\n        if (!spotRate.isPositive() || !rate.isPositive()) {\\n            return PoolRateState.Uninitialized;\\n        }\\n\\n        Fraction memory invSpotRate = spotRate.inverse();\\n        Fraction112 memory invRate = averageRates.invRate;\\n        if (!invSpotRate.isPositive() || !invRate.isPositive()) {\\n            return PoolRateState.Uninitialized;\\n        }\\n\\n        AverageRates memory effectiveAverageRates = _effectiveAverageRates(averageRates, spotRate);\\n\\n        if (\\n            MathEx.isInRange(effectiveAverageRates.rate.fromFraction112(), spotRate, RATE_MAX_DEVIATION_PPM) &&\\n            MathEx.isInRange(effectiveAverageRates.invRate.fromFraction112(), invSpotRate, RATE_MAX_DEVIATION_PPM)\\n        ) {\\n            return PoolRateState.Stable;\\n        }\\n\\n        return PoolRateState.Unstable;\\n    }\\n\\n    /**\\n     * @dev updates the average rates\\n     */\\n    function _updateAverageRates(Pool storage data, Fraction memory spotRate) private {\\n        data.averageRates = _effectiveAverageRates(data.averageRates, spotRate);\\n    }\\n\\n    /**\\n     * @dev returns the effective average rates\\n     */\\n    function _effectiveAverageRates(\\n        AverageRates memory averageRates,\\n        Fraction memory spotRate\\n    ) private view returns (AverageRates memory) {\\n        // if the spot rate is 0, reset the average rates\\n        if (!spotRate.isPositive()) {\\n            return AverageRates({ blockNumber: 0, rate: zeroFraction112(), invRate: zeroFraction112() });\\n        }\\n\\n        uint32 blockNumber = _blockNumber();\\n\\n        // can only be updated once in a single block\\n        uint32 prevUpdateBlock = averageRates.blockNumber;\\n        if (prevUpdateBlock == blockNumber) {\\n            return averageRates;\\n        }\\n\\n        // if sufficient blocks have passed, or if one of the rates isn't positive,\\n        // reset the average rates\\n        if (\\n            blockNumber - prevUpdateBlock >= RATE_RESET_BLOCK_THRESHOLD ||\\n            !averageRates.rate.isPositive() ||\\n            !averageRates.invRate.isPositive()\\n        ) {\\n            if (spotRate.isPositive()) {\\n                return\\n                    AverageRates({\\n                        blockNumber: blockNumber,\\n                        rate: spotRate.toFraction112(),\\n                        invRate: spotRate.inverse().toFraction112()\\n                    });\\n            }\\n\\n            return AverageRates({ blockNumber: 0, rate: zeroFraction112(), invRate: zeroFraction112() });\\n        }\\n\\n        return\\n            AverageRates({\\n                blockNumber: blockNumber,\\n                rate: _calcAverageRate(averageRates.rate, spotRate),\\n                invRate: _calcAverageRate(averageRates.invRate, spotRate.inverse())\\n            });\\n    }\\n\\n    /**\\n     * @dev calculates the average rate\\n     */\\n    function _calcAverageRate(\\n        Fraction112 memory averageRate,\\n        Fraction memory rate\\n    ) private pure returns (Fraction112 memory) {\\n        if (rate.n * averageRate.d == rate.d * averageRate.n) {\\n            return averageRate;\\n        }\\n\\n        return\\n            MathEx\\n                .weightedAverage(averageRate.fromFraction112(), rate, EMA_AVERAGE_RATE_WEIGHT, EMA_SPOT_RATE_WEIGHT)\\n                .toFraction112();\\n    }\\n\\n    /**\\n     * @dev verifies if the provided rate is valid\\n     */\\n    function _validRate(Fraction memory rate) internal pure {\\n        if (!rate.isPositive()) {\\n            revert InvalidRate();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pools/PoolCollectionWithdrawal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\nimport { PPM_RESOLUTION as M } from \\\"../utility/Constants.sol\\\";\\nimport { Sint256, Uint512, MathEx } from \\\"../utility/MathEx.sol\\\";\\n\\nerror PoolCollectionWithdrawalInputInvalid();\\n\\n/**\\n * @dev This library implements the mathematics behind base-token withdrawal.\\n * It exposes a single function which takes the following input values:\\n * `a` - BNT trading liquidity\\n * `b` - base token trading liquidity\\n * `c` - base token excess amount\\n * `e` - base token staked amount\\n * `w` - base token external protection vault balance\\n * `m` - trading fee in PPM units\\n * `n` - withdrawal fee in PPM units\\n * `x` - base token withdrawal amount\\n * And returns the following output values:\\n * `p` - BNT amount to add to the trading liquidity and to the master vault\\n * `q` - BNT amount to add to the protocol equity\\n * `r` - base token amount to add to the trading liquidity\\n * `s` - base token amount to transfer from the master vault to the provider\\n * `t` - BNT amount to mint directly for the provider\\n * `u` - base token amount to transfer from the external protection vault to the provider\\n * `v` - base token amount to keep in the pool as a withdrawal fee\\n * The following table depicts the actual formulae based on the current state of the system:\\n * +-----------+---------------------------------------------------------+----------------------------------------------------------+\\n * |           |                         Deficit                         |                       Surplus                            |\\n * +-----------+---------------------------------------------------------+----------------------------------------------------------+\\n * |           | p = a*x*(e*(1-n)-b-c)*(1-m)/(b*e-x*(e*(1-n)-b-c)*(1-m)) | p = -a*x*(b+c-e*(1-n))/(b*e*(1-m)+x*(b+c-e*(1-n))*(1-m)) |\\n * |           | q = 0                                                   | q = 0                                                    |\\n * |           | r = -x*(e*(1-n)-b-c)/e                                  | r = x*(b+c-e*(1-n))/e                                    |\\n * | Arbitrage | s = x*(1-n)                                             | s = x*(1-n)                                              |\\n * |           | t = 0                                                   | t = 0                                                    |\\n * |           | u = 0                                                   | u = 0                                                    |\\n * |           | v = x*n                                                 | v = x*n                                                  |\\n * +-----------+---------------------------------------------------------+----------------------------------------------------------+\\n * |           | p = -a*z/(b*e) where z = max(x*(1-n)*b-c*(e-x*(1-n)),0) | p = -a*z/b where z = max(x*(1-n)-c,0)                    |\\n * |           | q = -a*z/(b*e) where z = max(x*(1-n)*b-c*(e-x*(1-n)),0) | q = -a*z/b where z = max(x*(1-n)-c,0)                    |\\n * |           | r = -z/e       where z = max(x*(1-n)*b-c*(e-x*(1-n)),0) | r = -z     where z = max(x*(1-n)-c,0)                    |\\n * | Default   | s = x*(1-n)*(b+c)/e                                     | s = x*(1-n)                                              |\\n * |           | t = see function `externalProtection`                   | t = 0                                                    |\\n * |           | u = see function `externalProtection`                   | u = 0                                                    |\\n * |           | v = x*n                                                 | v = x*n                                                  |\\n * +-----------+---------------------------------------------------------+----------------------------------------------------------+\\n * |           | p = 0                                                   | p = 0                                                    |\\n * |           | q = 0                                                   | q = 0                                                    |\\n * |           | r = 0                                                   | r = 0                                                    |\\n * | Bootstrap | s = x*(1-n)*c/e                                         | s = x*(1-n)                                              |\\n * |           | t = see function `externalProtection`                   | t = 0                                                    |\\n * |           | u = see function `externalProtection`                   | u = 0                                                    |\\n * |           | v = x*n                                                 | v = x*n                                                  |\\n * +-----------+---------------------------------------------------------+----------------------------------------------------------+\\n * Note that for the sake of illustration, both `m` and `n` are assumed normalized (between 0 and 1).\\n * During runtime, it is taken into account that they are given in PPM units (between 0 and 1000000).\\n */\\nlibrary PoolCollectionWithdrawal {\\n    using MathEx for uint256;\\n\\n    struct Output {\\n        Sint256 p;\\n        Sint256 q;\\n        Sint256 r;\\n        uint256 s;\\n        uint256 t;\\n        uint256 u;\\n        uint256 v;\\n    }\\n\\n    /**\\n     * @dev returns `p`, `q`, `r`, `s`, `t`, `u` and `v` according to the current state:\\n     * +-------------------+-----------------------------------------------------------+\\n     * | `e > (b+c)/(1-n)` | bootstrap deficit or default deficit or arbitrage deficit |\\n     * +-------------------+-----------------------------------------------------------+\\n     * | `e < (b+c)`       | bootstrap surplus or default surplus or arbitrage surplus |\\n     * +-------------------+-----------------------------------------------------------+\\n     * | otherwise         | bootstrap surplus or default surplus                      |\\n     * +-------------------+-----------------------------------------------------------+\\n     */\\n    function calculateWithdrawalAmounts(\\n        uint256 a, // <= 2**128-1\\n        uint256 b, // <= 2**128-1\\n        uint256 c, // <= 2**128-1\\n        uint256 e, // <= 2**128-1\\n        uint256 w, // <= 2**128-1\\n        uint256 m, // <= M == 1000000\\n        uint256 n, // <= M == 1000000\\n        uint256 x /// <= e <= 2**128-1\\n    ) internal pure returns (Output memory output) {\\n        if (\\n            a > type(uint128).max ||\\n            b > type(uint128).max ||\\n            c > type(uint128).max ||\\n            e > type(uint128).max ||\\n            w > type(uint128).max ||\\n            m > M ||\\n            n > M ||\\n            x > e\\n        ) {\\n            revert PoolCollectionWithdrawalInputInvalid();\\n        }\\n\\n        uint256 y = (x * (M - n)) / M;\\n\\n        if ((e * (M - n)) / M > b + c) {\\n            uint256 f = (e * (M - n)) / M - (b + c);\\n            uint256 g = e - (b + c);\\n            if (isStable(b, c, e, x) && affordableDeficit(b, e, f, g, m, n, x)) {\\n                output = arbitrageDeficit(a, b, e, f, m, x, y);\\n            } else if (a > 0) {\\n                output = defaultDeficit(a, b, c, e, y);\\n                (output.t, output.u) = externalProtection(a, b, e, g, y, w);\\n            } else {\\n                output.s = (y * c) / e;\\n                (output.t, output.u) = externalProtection(a, b, e, g, y, w);\\n            }\\n        } else {\\n            uint256 f = MathEx.subMax0(b + c, e);\\n            if (f > 0 && isStable(b, c, e, x) && affordableSurplus(b, e, f, m, n, x)) {\\n                output = arbitrageSurplus(a, b, e, f, m, n, x, y);\\n            } else if (a > 0) {\\n                output = defaultSurplus(a, b, c, y);\\n            } else {\\n                output.s = y;\\n            }\\n        }\\n\\n        output.v = x - y;\\n    }\\n\\n    /**\\n     * @dev returns `x < e*c/(b+c)`\\n     */\\n    function isStable(\\n        uint256 b, // <= 2**128-1\\n        uint256 c, // <= 2**128-1\\n        uint256 e, // <= 2**128-1\\n        uint256 x /// <= e <= 2**128-1\\n    ) private pure returns (bool) {\\n        return b * x < c * (e - x);\\n    }\\n\\n    /**\\n     * @dev returns `b*e*((e*(1-n)-b-c)*m+e*n) > (e*(1-n)-b-c)*x*(e-b-c)*(1-m)`\\n     */\\n    function affordableDeficit(\\n        uint256 /*b*/, // <= 2**128-1\\n        uint256 /*e*/, // <= 2**128-1\\n        uint256 /*f*/, // == e*(1-n)-b-c <= e <= 2**128-1\\n        uint256 /*g*/, // == e-b-c <= e <= 2**128-1\\n        uint256 /*m*/, // <= M == 1000000\\n        uint256 /*n*/, // <= M == 1000000\\n        uint256 /*x*/ /// <  e*c/(b+c) <= e <= 2**128-1\\n    ) private pure returns (bool) {\\n        // temporarily disabled\\n        //Uint512 memory lhs = MathEx.mul512(b * e, f * m + e * n);\\n        //Uint512 memory rhs = MathEx.mul512(f * x, g * (M - m));\\n        //return MathEx.gt512(lhs, rhs);\\n        return false;\\n    }\\n\\n    /**\\n     * @dev returns `b*e*((b+c-e)*m+e*n) > (b+c-e)*x*(b+c-e*(1-n))*(1-m)`\\n     */\\n    function affordableSurplus(\\n        uint256 b, // <= 2**128-1\\n        uint256 e, // <= 2**128-1\\n        uint256 f, // == b+c-e <= 2**129-2\\n        uint256 m, // <= M == 1000000\\n        uint256 n, // <= M == 1000000\\n        uint256 x /// <  e*c/(b+c) <= e <= 2**128-1\\n    ) private pure returns (bool) {\\n        Uint512 memory lhs = MathEx.mul512(b * e, (f * m + e * n) * M);\\n        Uint512 memory rhs = MathEx.mul512(f * x, (f * M + e * n) * (M - m));\\n        return MathEx.gt512(lhs, rhs); // `x < e*c/(b+c)` --> `f*x < e*c*(b+c-e)/(b+c) <= e*c <= 2**256-1`\\n    }\\n\\n    /**\\n     * @dev returns:\\n     * `p = a*x*(e*(1-n)-b-c)*(1-m)/(b*e-x*(e*(1-n)-b-c)*(1-m))`\\n     * `q = 0`\\n     * `r = -x*(e*(1-n)-b-c)/e`\\n     * `s = x*(1-n)`\\n     */\\n    function arbitrageDeficit(\\n        uint256 a, // <= 2**128-1\\n        uint256 b, // <= 2**128-1\\n        uint256 e, // <= 2**128-1\\n        uint256 f, // == e*(1-n)-b-c <= e <= 2**128-1\\n        uint256 m, // <= M == 1000000\\n        uint256 x, // <= e <= 2**128-1\\n        uint256 y /// == x*(1-n) <= x <= e <= 2**128-1\\n    ) private pure returns (Output memory output) {\\n        uint256 i = f * (M - m);\\n        uint256 j = mulSubMulDivF(b, e * M, x, i, 1);\\n        output.p = MathEx.mulDivF(a * x, i, j).toPos256();\\n        output.r = MathEx.mulDivF(x, f, e).toNeg256();\\n        output.s = y;\\n    }\\n\\n    /**\\n     * @dev returns:\\n     * `p = -a*x*(b+c-e*(1-n))/(b*e*(1-m)+x*(b+c-e*(1-n))*(1-m))`\\n     * `q = 0`\\n     * `r = x*(b+c-e*(1-n))/e`\\n     * `s = x*(1-n)`\\n     */\\n    function arbitrageSurplus(\\n        uint256 a, // <= 2**128-1\\n        uint256 b, // <= 2**128-1\\n        uint256 e, // <= 2**128-1\\n        uint256 f, // == b+c-e <= 2**129-2\\n        uint256 m, // <= M == 1000000\\n        uint256 n, // <= M == 1000000\\n        uint256 x, // <= e <= 2**128-1\\n        uint256 y /// == x*(1-n) <= x <= e <= 2**128-1\\n    ) private pure returns (Output memory output) {\\n        uint256 i = f * M + e * n;\\n        uint256 j = mulAddMulDivF(b, e * (M - m), x, i * (M - m), M);\\n        output.p = MathEx.mulDivF(a * x, i, j).toNeg256();\\n        output.r = MathEx.mulDivF(x, i, e * M).toPos256();\\n        output.s = y;\\n    }\\n\\n    /**\\n     * @dev returns:\\n     * `p = -a*z/(b*e)` where `z = max(x*(1-n)*b-c*(e-x*(1-n)),0)`\\n     * `q = -a*z/(b*e)` where `z = max(x*(1-n)*b-c*(e-x*(1-n)),0)`\\n     * `r = -z/e` where `z = max(x*(1-n)*b-c*(e-x*(1-n)),0)`\\n     * `s = x*(1-n)*(b+c)/e`\\n     */\\n    function defaultDeficit(\\n        uint256 a, // <= 2**128-1\\n        uint256 b, // <= 2**128-1\\n        uint256 c, // <= 2**128-1\\n        uint256 e, // <= 2**128-1\\n        uint256 y /// == x*(1-n) <= x <= e <= 2**128-1\\n    ) private pure returns (Output memory output) {\\n        uint256 z = MathEx.subMax0(y * b, c * (e - y));\\n        output.p = MathEx.mulDivF(a, z, b * e).toNeg256();\\n        output.q = output.p;\\n        output.r = (z / e).toNeg256();\\n        output.s = MathEx.mulDivF(y, b + c, e);\\n    }\\n\\n    /**\\n     * @dev returns:\\n     * `p = -a*z/b` where `z = max(x*(1-n)-c,0)`\\n     * `q = -a*z/b` where `z = max(x*(1-n)-c,0)`\\n     * `r = -z` where `z = max(x*(1-n)-c,0)`\\n     * `s = x*(1-n)`\\n     */\\n    function defaultSurplus(\\n        uint256 a, // <= 2**128-1\\n        uint256 b, // <= 2**128-1\\n        uint256 c, // <= 2**128-1\\n        uint256 y /// == x*(1-n) <= x <= e <= 2**128-1\\n    ) private pure returns (Output memory output) {\\n        uint256 z = MathEx.subMax0(y, c);\\n        output.p = MathEx.mulDivF(a, z, b).toNeg256();\\n        output.q = output.p;\\n        output.r = z.toNeg256();\\n        output.s = y;\\n    }\\n\\n    /**\\n     * @dev returns `t` and `u` according to the current state:\\n     * +-----------------------+-------+---------------------------+-------------------+\\n     * | x*(1-n)*(e-b-c)/e > w | a > 0 | t                         | u                 |\\n     * +-----------------------+-------+---------------------------+-------------------+\\n     * | true                  | true  | a*(x*(1-n)*(e-b-c)/e-w)/b | w                 |\\n     * +-----------------------+-------+---------------------------+-------------------+\\n     * | true                  | false | 0                         | w                 |\\n     * +-----------------------+-------+---------------------------+-------------------+\\n     * | false                 | true  | 0                         | x*(1-n)*(e-b-c)/e |\\n     * +-----------------------+-------+---------------------------+-------------------+\\n     * | false                 | false | 0                         | x*(1-n)*(e-b-c)/e |\\n     * +-----------------------+-------+---------------------------+-------------------+\\n     */\\n    function externalProtection(\\n        uint256 a, // <= 2**128-1\\n        uint256 b, // <= 2**128-1\\n        uint256 e, // <= 2**128-1\\n        uint256 g, // == e-b-c <= e <= 2**128-1\\n        uint256 y, // == x*(1-n) <= x <= e <= 2**128-1\\n        uint256 w /// <= 2**128-1\\n    ) private pure returns (uint256 t, uint256 u) {\\n        uint256 yg = y * g;\\n        uint256 we = w * e;\\n        if (yg > we) {\\n            t = a > 0 ? MathEx.mulDivF(a, yg - we, b * e) : 0;\\n            u = w;\\n        } else {\\n            t = 0;\\n            u = yg / e;\\n        }\\n    }\\n\\n    /**\\n     * @dev returns `a*b+x*y/z`\\n     */\\n    function mulAddMulDivF(uint256 a, uint256 b, uint256 x, uint256 y, uint256 z) private pure returns (uint256) {\\n        return a * b + MathEx.mulDivF(x, y, z);\\n    }\\n\\n    /**\\n     * @dev returns `a*b-x*y/z`\\n     */\\n    function mulSubMulDivF(uint256 a, uint256 b, uint256 x, uint256 y, uint256 z) private pure returns (uint256) {\\n        return a * b - MathEx.mulDivF(x, y, z);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pools/interfaces/IBNTPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\nimport { IPoolToken } from \\\"./IPoolToken.sol\\\";\\n\\nimport { Token } from \\\"../../token/Token.sol\\\";\\n\\nimport { IVault } from \\\"../../vaults/interfaces/IVault.sol\\\";\\n\\n// the BNT pool token manager role is required to access the BNT pool tokens\\nbytes32 constant ROLE_BNT_POOL_TOKEN_MANAGER = keccak256(\\\"ROLE_BNT_POOL_TOKEN_MANAGER\\\");\\n\\n// the BNT manager role is required to request the BNT pool to mint BNT\\nbytes32 constant ROLE_BNT_MANAGER = keccak256(\\\"ROLE_BNT_MANAGER\\\");\\n\\n// the vault manager role is required to request the BNT pool to burn BNT from the master vault\\nbytes32 constant ROLE_VAULT_MANAGER = keccak256(\\\"ROLE_VAULT_MANAGER\\\");\\n\\n// the funding manager role is required to request or renounce funding from the BNT pool\\nbytes32 constant ROLE_FUNDING_MANAGER = keccak256(\\\"ROLE_FUNDING_MANAGER\\\");\\n\\n/**\\n * @dev BNT Pool interface\\n */\\ninterface IBNTPool is IVault {\\n    /**\\n     * @dev returns the BNT pool token contract\\n     */\\n    function poolToken() external view returns (IPoolToken);\\n\\n    /**\\n     * @dev returns the total staked BNT balance in the network\\n     */\\n    function stakedBalance() external view returns (uint256);\\n\\n    /**\\n     * @dev returns the current funding of given pool\\n     */\\n    function currentPoolFunding(Token pool) external view returns (uint256);\\n\\n    /**\\n     * @dev returns the available BNT funding for a given pool\\n     */\\n    function availableFunding(Token pool) external view returns (uint256);\\n\\n    /**\\n     * @dev converts the specified pool token amount to the underlying BNT amount\\n     */\\n    function poolTokenToUnderlying(uint256 poolTokenAmount) external view returns (uint256);\\n\\n    /**\\n     * @dev converts the specified underlying BNT amount to pool token amount\\n     */\\n    function underlyingToPoolToken(uint256 bntAmount) external view returns (uint256);\\n\\n    /**\\n     * @dev returns the number of pool token to burn in order to increase everyone's underlying value by the specified\\n     * amount\\n     */\\n    function poolTokenAmountToBurn(uint256 bntAmountToDistribute) external view returns (uint256);\\n\\n    /**\\n     * @dev mints BNT to the recipient\\n     *\\n     * requirements:\\n     *\\n     * - the caller must have the ROLE_BNT_MANAGER role\\n     */\\n    function mint(address recipient, uint256 bntAmount) external;\\n\\n    /**\\n     * @dev burns BNT from the vault\\n     *\\n     * requirements:\\n     *\\n     * - the caller must have the ROLE_VAULT_MANAGER role\\n     */\\n    function burnFromVault(uint256 bntAmount) external;\\n\\n    /**\\n     * @dev deposits BNT liquidity on behalf of a specific provider and returns the respective pool token amount\\n     *\\n     * requirements:\\n     *\\n     * - the caller must be the network contract\\n     * - BNT tokens must have been already deposited into the contract\\n     */\\n    function depositFor(\\n        bytes32 contextId,\\n        address provider,\\n        uint256 bntAmount,\\n        bool isMigrating,\\n        uint256 originalVBNTAmount\\n    ) external returns (uint256);\\n\\n    /**\\n     * @dev withdraws BNT liquidity on behalf of a specific provider and returns the withdrawn BNT amount\\n     *\\n     * requirements:\\n     *\\n     * - the caller must be the network contract\\n     * - bnBNT token must have been already deposited into the contract\\n     * - vBNT token must have been already deposited into the contract\\n     */\\n    function withdraw(\\n        bytes32 contextId,\\n        address provider,\\n        uint256 poolTokenAmount,\\n        uint256 bntAmount\\n    ) external returns (uint256);\\n\\n    /**\\n     * @dev returns the withdrawn BNT amount\\n     */\\n    function withdrawalAmount(uint256 poolTokenAmount) external view returns (uint256);\\n\\n    /**\\n     * @dev requests BNT funding\\n     *\\n     * requirements:\\n     *\\n     * - the caller must have the ROLE_FUNDING_MANAGER role\\n     * - the token must have been whitelisted\\n     * - the request amount should be below the funding limit for a given pool\\n     * - the average rate of the pool must not deviate too much from its spot rate\\n     */\\n    function requestFunding(\\n        bytes32 contextId,\\n        Token pool,\\n        uint256 bntAmount\\n    ) external;\\n\\n    /**\\n     * @dev renounces BNT funding\\n     *\\n     * requirements:\\n     *\\n     * - the caller must have the ROLE_FUNDING_MANAGER role\\n     * - the token must have been whitelisted\\n     * - the average rate of the pool must not deviate too much from its spot rate\\n     */\\n    function renounceFunding(\\n        bytes32 contextId,\\n        Token pool,\\n        uint256 bntAmount\\n    ) external;\\n\\n    /**\\n     * @dev notifies the pool of accrued fees\\n     *\\n     * requirements:\\n     *\\n     * - the caller must be the network contract\\n     */\\n    function onFeesCollected(\\n        Token pool,\\n        uint256 feeAmount,\\n        bool isTradeFee\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/pools/interfaces/IPoolCollection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\nimport { IVersioned } from \\\"../../utility/interfaces/IVersioned.sol\\\";\\nimport { Fraction112 } from \\\"../../utility/FractionLibrary.sol\\\";\\n\\nimport { Token } from \\\"../../token/Token.sol\\\";\\n\\nimport { IPoolToken } from \\\"./IPoolToken.sol\\\";\\n\\nstruct PoolLiquidity {\\n    uint128 bntTradingLiquidity; // the BNT trading liquidity\\n    uint128 baseTokenTradingLiquidity; // the base token trading liquidity\\n    uint256 stakedBalance; // the staked balance\\n}\\n\\nstruct AverageRates {\\n    uint32 blockNumber;\\n    Fraction112 rate;\\n    Fraction112 invRate;\\n}\\n\\nstruct Pool {\\n    IPoolToken poolToken; // the pool token of the pool\\n    uint32 tradingFeePPM; // the trading fee (in units of PPM)\\n    bool tradingEnabled; // whether trading is enabled\\n    bool depositingEnabled; // whether depositing is enabled\\n    AverageRates averageRates; // the recent average rates\\n    PoolLiquidity liquidity; // the overall liquidity in the pool\\n}\\n\\nstruct WithdrawalAmounts {\\n    uint256 totalAmount;\\n    uint256 baseTokenAmount;\\n    uint256 bntAmount;\\n}\\n\\n// trading enabling/disabling reasons\\nuint8 constant TRADING_STATUS_UPDATE_DEFAULT = 0;\\nuint8 constant TRADING_STATUS_UPDATE_ADMIN = 1;\\nuint8 constant TRADING_STATUS_UPDATE_MIN_LIQUIDITY = 2;\\nuint8 constant TRADING_STATUS_UPDATE_INVALID_STATE = 3;\\nuint8 constant TRADING_STATUS_UPDATE_NETWORK_DISABLE = 4;\\n\\nstruct TradeAmountAndFee {\\n    uint256 amount; // the source/target amount (depending on the context) resulting from the trade\\n    uint256 tradingFeeAmount; // the trading fee amount\\n    uint256 networkFeeAmount; // the network fee amount (always in units of BNT)\\n}\\n\\n/**\\n * @dev Pool Collection interface\\n */\\ninterface IPoolCollection is IVersioned {\\n    /**\\n     * @dev returns the type of the pool\\n     */\\n    function poolType() external view returns (uint16);\\n\\n    /**\\n     * @dev returns the default trading fee (in units of PPM)\\n     */\\n    function defaultTradingFeePPM() external view returns (uint32);\\n\\n    /**\\n     * @dev returns the network fee (in units of PPM)\\n     */\\n    function networkFeePPM() external view returns (uint32);\\n\\n    /**\\n     * @dev returns all the pools which are managed by this pool collection\\n     */\\n    function pools() external view returns (Token[] memory);\\n\\n    /**\\n     * @dev returns the number of all the pools which are managed by this pool collection\\n     */\\n    function poolCount() external view returns (uint256);\\n\\n    /**\\n     * @dev returns whether a pool is valid\\n     */\\n    function isPoolValid(Token pool) external view returns (bool);\\n\\n    /**\\n     * @dev returns the overall liquidity in the pool\\n     */\\n    function poolLiquidity(Token pool) external view returns (PoolLiquidity memory);\\n\\n    /**\\n     * @dev returns the pool token of the pool\\n     */\\n    function poolToken(Token pool) external view returns (IPoolToken);\\n\\n    /**\\n     * @dev returns the trading fee (in units of PPM)\\n     */\\n    function tradingFeePPM(Token pool) external view returns (uint32);\\n\\n    /**\\n     * @dev returns whether trading is enabled\\n     */\\n    function tradingEnabled(Token pool) external view returns (bool);\\n\\n    /**\\n     * @dev returns whether depositing is enabled\\n     */\\n    function depositingEnabled(Token pool) external view returns (bool);\\n\\n    /**\\n     * @dev returns whether the pool is stable\\n     */\\n    function isPoolStable(Token pool) external view returns (bool);\\n\\n    /**\\n     * @dev converts the specified pool token amount to the underlying base token amount\\n     */\\n    function poolTokenToUnderlying(Token pool, uint256 poolTokenAmount) external view returns (uint256);\\n\\n    /**\\n     * @dev converts the specified underlying base token amount to pool token amount\\n     */\\n    function underlyingToPoolToken(Token pool, uint256 baseTokenAmount) external view returns (uint256);\\n\\n    /**\\n     * @dev returns the number of pool token to burn in order to increase everyone's underlying value by the specified\\n     * amount\\n     */\\n    function poolTokenAmountToBurn(\\n        Token pool,\\n        uint256 baseTokenAmountToDistribute,\\n        uint256 protocolPoolTokenAmount\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev creates a new pool\\n     *\\n     * requirements:\\n     *\\n     * - the caller must be the network contract\\n     * - the pool should have been whitelisted\\n     * - the pool isn't already defined in the collection\\n     */\\n    function createPool(Token token) external;\\n\\n    /**\\n     * @dev deposits base token liquidity on behalf of a specific provider and returns the respective pool token amount\\n     *\\n     * requirements:\\n     *\\n     * - the caller must be the network contract\\n     * - assumes that the base token has been already deposited in the vault\\n     */\\n    function depositFor(\\n        bytes32 contextId,\\n        address provider,\\n        Token pool,\\n        uint256 baseTokenAmount\\n    ) external returns (uint256);\\n\\n    /**\\n     * @dev handles some of the withdrawal-related actions and returns the withdrawn base token amount\\n     *\\n     * requirements:\\n     *\\n     * - the caller must be the network contract\\n     * - the caller must have approved the collection to transfer/burn the pool token amount on its behalf\\n     */\\n    function withdraw(\\n        bytes32 contextId,\\n        address provider,\\n        Token pool,\\n        uint256 poolTokenAmount,\\n        uint256 baseTokenAmount\\n    ) external returns (uint256);\\n\\n    /**\\n     * @dev returns the amounts that would be returned if the position is currently withdrawn,\\n     * along with the breakdown of the base token and the BNT compensation\\n     */\\n    function withdrawalAmounts(Token pool, uint256 poolTokenAmount) external view returns (WithdrawalAmounts memory);\\n\\n    /**\\n     * @dev performs a trade by providing the source amount and returns the target amount and the associated fee\\n     *\\n     * requirements:\\n     *\\n     * - the caller must be the network contract\\n     */\\n    function tradeBySourceAmount(\\n        bytes32 contextId,\\n        Token sourceToken,\\n        Token targetToken,\\n        uint256 sourceAmount,\\n        uint256 minReturnAmount,\\n        bool ignoreFees\\n    ) external returns (TradeAmountAndFee memory);\\n\\n    /**\\n     * @dev performs a trade by providing the target amount and returns the required source amount and the associated fee\\n     *\\n     * requirements:\\n     *\\n     * - the caller must be the network contract\\n     */\\n    function tradeByTargetAmount(\\n        bytes32 contextId,\\n        Token sourceToken,\\n        Token targetToken,\\n        uint256 targetAmount,\\n        uint256 maxSourceAmount,\\n        bool ignoreFees\\n    ) external returns (TradeAmountAndFee memory);\\n\\n    /**\\n     * @dev returns the output amount and fee when trading by providing the source amount\\n     */\\n    function tradeOutputAndFeeBySourceAmount(\\n        Token sourceToken,\\n        Token targetToken,\\n        uint256 sourceAmount\\n    ) external view returns (TradeAmountAndFee memory);\\n\\n    /**\\n     * @dev returns the input amount and fee when trading by providing the target amount\\n     */\\n    function tradeInputAndFeeByTargetAmount(\\n        Token sourceToken,\\n        Token targetToken,\\n        uint256 targetAmount\\n    ) external view returns (TradeAmountAndFee memory);\\n\\n    /**\\n     * @dev notifies the pool of accrued fees\\n     *\\n     * requirements:\\n     *\\n     * - the caller must be the network contract\\n     */\\n    function onFeesCollected(Token pool, uint256 feeAmount) external;\\n\\n    /**\\n     * @dev migrates a pool to this pool collection\\n     *\\n     * requirements:\\n     *\\n     * - the caller must be the pool migrator contract\\n     */\\n    function migratePoolIn(Token pool, Pool calldata data) external;\\n\\n    /**\\n     * @dev migrates a pool from this pool collection\\n     *\\n     * requirements:\\n     *\\n     * - the caller must be the pool migrator contract\\n     */\\n    function migratePoolOut(Token pool, IPoolCollection targetPoolCollection) external;\\n\\n    /**\\n     * @dev disables trading on a pool\\n     *\\n     * requirements:\\n     *\\n     * - the caller must be the network contract\\n     */\\n    function disableTradingByNetwork(Token pool) external;\\n}\\n\"\r\n    },\r\n    \"contracts/pools/interfaces/IPoolMigrator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\nimport { Token } from \\\"../../token/Token.sol\\\";\\n\\nimport { IVersioned } from \\\"../../utility/interfaces/IVersioned.sol\\\";\\n\\nimport { IPoolCollection } from \\\"./IPoolCollection.sol\\\";\\n\\n/**\\n * @dev Pool Migrator interface\\n */\\ninterface IPoolMigrator is IVersioned {\\n    /**\\n     * @dev migrates a pool and returns the new pool collection it exists in\\n     *\\n     * notes:\\n     *\\n     * - invalid or incompatible pools will be skipped gracefully\\n     *\\n     * requirements:\\n     *\\n     * - the caller must be the network contract\\n     */\\n    function migratePool(Token pool, IPoolCollection newPoolCollection) external;\\n}\\n\"\r\n    },\r\n    \"contracts/pools/interfaces/IPoolToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { IERC20Permit } from \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\\\";\\n\\nimport { IERC20Burnable } from \\\"../../token/interfaces/IERC20Burnable.sol\\\";\\nimport { Token } from \\\"../../token/Token.sol\\\";\\n\\nimport { IVersioned } from \\\"../../utility/interfaces/IVersioned.sol\\\";\\nimport { IOwned } from \\\"../../utility/interfaces/IOwned.sol\\\";\\n\\n/**\\n * @dev Pool Token interface\\n */\\ninterface IPoolToken is IVersioned, IOwned, IERC20, IERC20Permit, IERC20Burnable {\\n    /**\\n     * @dev returns the address of the reserve token\\n     */\\n    function reserveToken() external view returns (Token);\\n\\n    /**\\n     * @dev increases the token supply and sends the new tokens to the given account\\n     *\\n     * requirements:\\n     *\\n     * - the caller must be the owner of the contract\\n     */\\n    function mint(address recipient, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/pools/interfaces/IPoolTokenFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\nimport { Token } from \\\"../../token/Token.sol\\\";\\n\\nimport { IUpgradeable } from \\\"../../utility/interfaces/IUpgradeable.sol\\\";\\n\\nimport { IPoolToken } from \\\"./IPoolToken.sol\\\";\\n\\n/**\\n * @dev Pool Token Factory interface\\n */\\ninterface IPoolTokenFactory is IUpgradeable {\\n    /**\\n     * @dev returns the custom symbol override for a given reserve token\\n     */\\n    function tokenSymbolOverride(Token token) external view returns (string memory);\\n\\n    /**\\n     * @dev returns the custom decimals override for a given reserve token\\n     */\\n    function tokenDecimalsOverride(Token token) external view returns (uint8);\\n\\n    /**\\n     * @dev creates a pool token for the specified token\\n     */\\n    function createPoolToken(Token token) external returns (IPoolToken);\\n}\\n\"\r\n    },\r\n    \"contracts/token/SafeERC20Ex.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n/**\\n * @dev extends the SafeERC20 library with additional operations\\n */\\nlibrary SafeERC20Ex {\\n    using SafeERC20 for IERC20;\\n\\n    /**\\n     * @dev ensures that the spender has sufficient allowance\\n     */\\n    function ensureApprove(IERC20 token, address spender, uint256 amount) internal {\\n        if (amount == 0) {\\n            return;\\n        }\\n\\n        uint256 allowance = token.allowance(address(this), spender);\\n        if (allowance >= amount) {\\n            return;\\n        }\\n\\n        if (allowance > 0) {\\n            token.safeApprove(spender, 0);\\n        }\\n        token.safeApprove(spender, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/token/Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\n/**\\n * @dev the main purpose of the Token interfaces is to ensure artificially that we won't use ERC20's standard functions,\\n * but only their safe versions, which are provided by SafeERC20 and SafeERC20Ex via the TokenLibrary contract\\n */\\ninterface Token {\\n\\n}\\n\"\r\n    },\r\n    \"contracts/token/TokenLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { ERC20 } from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport { SafeERC20Ex } from \\\"./SafeERC20Ex.sol\\\";\\n\\nimport { Token } from \\\"./Token.sol\\\";\\n\\n/**\\n * @dev This library implements ERC20 and SafeERC20 utilities for both the native token and for ERC20 tokens\\n */\\nlibrary TokenLibrary {\\n    using SafeERC20 for IERC20;\\n    using SafeERC20Ex for IERC20;\\n\\n    error PermitUnsupported();\\n\\n    // the address that represents the native token reserve\\n    address private constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    // the symbol that represents the native token\\n    string private constant NATIVE_TOKEN_SYMBOL = \\\"ETH\\\";\\n\\n    // the decimals for the native token\\n    uint8 private constant NATIVE_TOKEN_DECIMALS = 18;\\n\\n    // the token representing the native token\\n    Token public constant NATIVE_TOKEN = Token(NATIVE_TOKEN_ADDRESS);\\n\\n    /**\\n     * @dev returns whether the provided token represents an ERC20 or the native token reserve\\n     */\\n    function isNative(Token token) internal pure returns (bool) {\\n        return address(token) == NATIVE_TOKEN_ADDRESS;\\n    }\\n\\n    /**\\n     * @dev returns the symbol of the native token/ERC20 token\\n     */\\n    function symbol(Token token) internal view returns (string memory) {\\n        if (isNative(token)) {\\n            return NATIVE_TOKEN_SYMBOL;\\n        }\\n\\n        return toERC20(token).symbol();\\n    }\\n\\n    /**\\n     * @dev returns the decimals of the native token/ERC20 token\\n     */\\n    function decimals(Token token) internal view returns (uint8) {\\n        if (isNative(token)) {\\n            return NATIVE_TOKEN_DECIMALS;\\n        }\\n\\n        return toERC20(token).decimals();\\n    }\\n\\n    /**\\n     * @dev returns the balance of the native token/ERC20 token\\n     */\\n    function balanceOf(Token token, address account) internal view returns (uint256) {\\n        if (isNative(token)) {\\n            return account.balance;\\n        }\\n\\n        return toIERC20(token).balanceOf(account);\\n    }\\n\\n    /**\\n     * @dev transfers a specific amount of the native token/ERC20 token\\n     */\\n    function safeTransfer(Token token, address to, uint256 amount) internal {\\n        if (amount == 0) {\\n            return;\\n        }\\n\\n        if (isNative(token)) {\\n            payable(to).transfer(amount);\\n        } else {\\n            toIERC20(token).safeTransfer(to, amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev transfers a specific amount of the native token/ERC20 token from a specific holder using the allowance mechanism\\n     *\\n     * note that the function does not perform any action if the native token is provided\\n     */\\n    function safeTransferFrom(Token token, address from, address to, uint256 amount) internal {\\n        if (amount == 0 || isNative(token)) {\\n            return;\\n        }\\n\\n        toIERC20(token).safeTransferFrom(from, to, amount);\\n    }\\n\\n    /**\\n     * @dev approves a specific amount of the native token/ERC20 token from a specific holder\\n     *\\n     * note that the function does not perform any action if the native token is provided\\n     */\\n    function safeApprove(Token token, address spender, uint256 amount) internal {\\n        if (isNative(token)) {\\n            return;\\n        }\\n\\n        toIERC20(token).safeApprove(spender, amount);\\n    }\\n\\n    /**\\n     * @dev increases allowance of the native token/ERC20 token from a specific holder\\n     *\\n     * note that the function does not perform any action if the native token is provided\\n     */\\n    function safeIncreaseAllowance(Token token, address spender, uint256 amount) internal {\\n        if (isNative(token)) {\\n            return;\\n        }\\n\\n        toIERC20(token).safeIncreaseAllowance(spender, amount);\\n    }\\n\\n    /**\\n     * @dev ensures that the spender has sufficient allowance\\n     *\\n     * note that the function does not perform any action if the native token is provided\\n     */\\n    function ensureApprove(Token token, address spender, uint256 amount) internal {\\n        if (isNative(token)) {\\n            return;\\n        }\\n\\n        toIERC20(token).ensureApprove(spender, amount);\\n    }\\n\\n    /**\\n     * @dev compares between a token and another raw ERC20 token\\n     */\\n    function isEqual(Token token, IERC20 erc20Token) internal pure returns (bool) {\\n        return toIERC20(token) == erc20Token;\\n    }\\n\\n    /**\\n     * @dev utility function that converts a token to an IERC20\\n     */\\n    function toIERC20(Token token) internal pure returns (IERC20) {\\n        return IERC20(address(token));\\n    }\\n\\n    /**\\n     * @dev utility function that converts a token to an ERC20\\n     */\\n    function toERC20(Token token) internal pure returns (ERC20) {\\n        return ERC20(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/token/interfaces/IERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\n/**\\n * @dev burnable ERC20 interface\\n */\\ninterface IERC20Burnable {\\n    /**\\n     * @dev Destroys tokens from the caller.\\n     */\\n    function burn(uint256 amount) external;\\n\\n    /**\\n     * @dev Destroys tokens from a recipient, deducting from the caller's allowance\\n     *\\n     * requirements:\\n     *\\n     * - the caller must have allowance for recipient's tokens of at least the specified amount\\n     */\\n    function burnFrom(address recipient, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/utility/BlockNumber.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\n/**\\n * @dev this contract abstracts the block number in order to allow for more flexible control in tests\\n */\\nabstract contract BlockNumber {\\n    /**\\n     * @dev returns the current block-number\\n     */\\n    function _blockNumber() internal view virtual returns (uint32) {\\n        return uint32(block.number);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utility/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\nuint32 constant PPM_RESOLUTION = 1_000_000;\\n\"\r\n    },\r\n    \"contracts/utility/Fraction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\nstruct Fraction {\\n    uint256 n;\\n    uint256 d;\\n}\\n\\nstruct Fraction112 {\\n    uint112 n;\\n    uint112 d;\\n}\\n\\nerror InvalidFraction();\\n\"\r\n    },\r\n    \"contracts/utility/FractionLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\nimport { Fraction, Fraction112, InvalidFraction } from \\\"./Fraction.sol\\\";\\nimport { MathEx } from \\\"./MathEx.sol\\\";\\n\\n// solhint-disable-next-line func-visibility\\nfunction zeroFraction() pure returns (Fraction memory) {\\n    return Fraction({ n: 0, d: 1 });\\n}\\n\\n// solhint-disable-next-line func-visibility\\nfunction zeroFraction112() pure returns (Fraction112 memory) {\\n    return Fraction112({ n: 0, d: 1 });\\n}\\n\\n/**\\n * @dev this library provides a set of fraction operations\\n */\\nlibrary FractionLibrary {\\n    /**\\n     * @dev returns whether a standard fraction is valid\\n     */\\n    function isValid(Fraction memory fraction) internal pure returns (bool) {\\n        return fraction.d != 0;\\n    }\\n\\n    /**\\n     * @dev returns whether a 112-bit fraction is valid\\n     */\\n    function isValid(Fraction112 memory fraction) internal pure returns (bool) {\\n        return fraction.d != 0;\\n    }\\n\\n    /**\\n     * @dev returns whether a standard fraction is positive\\n     */\\n    function isPositive(Fraction memory fraction) internal pure returns (bool) {\\n        return isValid(fraction) && fraction.n != 0;\\n    }\\n\\n    /**\\n     * @dev returns whether a 112-bit fraction is positive\\n     */\\n    function isPositive(Fraction112 memory fraction) internal pure returns (bool) {\\n        return isValid(fraction) && fraction.n != 0;\\n    }\\n\\n    /**\\n     * @dev returns the inverse of a given fraction\\n     */\\n    function inverse(Fraction memory fraction) internal pure returns (Fraction memory) {\\n        Fraction memory invFraction = Fraction({ n: fraction.d, d: fraction.n });\\n\\n        if (!isValid(invFraction)) {\\n            revert InvalidFraction();\\n        }\\n\\n        return invFraction;\\n    }\\n\\n    /**\\n     * @dev returns the inverse of a given fraction\\n     */\\n    function inverse(Fraction112 memory fraction) internal pure returns (Fraction112 memory) {\\n        Fraction112 memory invFraction = Fraction112({ n: fraction.d, d: fraction.n });\\n\\n        if (!isValid(invFraction)) {\\n            revert InvalidFraction();\\n        }\\n\\n        return invFraction;\\n    }\\n\\n    /**\\n     * @dev reduces a standard fraction to a 112-bit fraction\\n     */\\n    function toFraction112(Fraction memory fraction) internal pure returns (Fraction112 memory) {\\n        Fraction memory truncatedFraction = MathEx.truncatedFraction(fraction, type(uint112).max);\\n\\n        return Fraction112({ n: uint112(truncatedFraction.n), d: uint112(truncatedFraction.d) });\\n    }\\n\\n    /**\\n     * @dev expands a 112-bit fraction to a standard fraction\\n     */\\n    function fromFraction112(Fraction112 memory fraction) internal pure returns (Fraction memory) {\\n        return Fraction({ n: fraction.n, d: fraction.d });\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utility/MathEx.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\nimport { Math } from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport { Fraction, InvalidFraction } from \\\"./Fraction.sol\\\";\\n\\nimport { PPM_RESOLUTION } from \\\"./Constants.sol\\\";\\n\\nuint256 constant ONE = 0x80000000000000000000000000000000;\\nuint256 constant LN2 = 0x58b90bfbe8e7bcd5e4f1d9cc01f97b57;\\n\\nstruct Uint512 {\\n    uint256 hi; // 256 most significant bits\\n    uint256 lo; // 256 least significant bits\\n}\\n\\nstruct Sint256 {\\n    uint256 value;\\n    bool isNeg;\\n}\\n\\n/**\\n * @dev this library provides a set of complex math operations\\n */\\nlibrary MathEx {\\n    error Overflow();\\n\\n    /**\\n     * @dev returns `2 ^ f` by calculating `e ^ (f * ln(2))`, where `e` is Euler's number:\\n     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\\n     * - The exponentiation of each binary exponent is given (pre-calculated)\\n     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\\n     * - The exponentiation of the input is calculated by multiplying the intermediate results above\\n     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\\n     */\\n    function exp2(Fraction memory f) internal pure returns (Fraction memory) {\\n        uint256 x = MathEx.mulDivF(LN2, f.n, f.d);\\n        uint256 y;\\n        uint256 z;\\n        uint256 n;\\n\\n        if (x >= (ONE << 4)) {\\n            revert Overflow();\\n        }\\n\\n        unchecked {\\n            z = y = x % (ONE >> 3); // get the input modulo 2^(-3)\\n            z = (z * y) / ONE;\\n            n += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\\n            z = (z * y) / ONE;\\n            n += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\\n            z = (z * y) / ONE;\\n            n += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\\n            z = (z * y) / ONE;\\n            n += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\\n            z = (z * y) / ONE;\\n            n += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\\n            z = (z * y) / ONE;\\n            n += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\\n            z = (z * y) / ONE;\\n            n += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\\n            z = (z * y) / ONE;\\n            n += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\\n            z = (z * y) / ONE;\\n            n += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\\n            z = (z * y) / ONE;\\n            n += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\\n            z = (z * y) / ONE;\\n            n += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\\n            z = (z * y) / ONE;\\n            n += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\\n            z = (z * y) / ONE;\\n            n += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\\n            z = (z * y) / ONE;\\n            n += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\\n            z = (z * y) / ONE;\\n            n += z * 0x000000000001c638; // add y^16 * (20! / 16!)\\n            z = (z * y) / ONE;\\n            n += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\\n            z = (z * y) / ONE;\\n            n += z * 0x000000000000017c; // add y^18 * (20! / 18!)\\n            z = (z * y) / ONE;\\n            n += z * 0x0000000000000014; // add y^19 * (20! / 19!)\\n            z = (z * y) / ONE;\\n            n += z * 0x0000000000000001; // add y^20 * (20! / 20!)\\n            n = n / 0x21c3677c82b40000 + y + ONE; // divide by 20! and then add y^1 / 1! + y^0 / 0!\\n\\n            if ((x & (ONE >> 3)) != 0)\\n                n = (n * 0x1c3d6a24ed82218787d624d3e5eba95f9) / 0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^(2^-3)\\n            if ((x & (ONE >> 2)) != 0)\\n                n = (n * 0x18ebef9eac820ae8682b9793ac6d1e778) / 0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^(2^-2)\\n            if ((x & (ONE >> 1)) != 0)\\n                n = (n * 0x1368b2fc6f9609fe7aceb46aa619baed5) / 0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^(2^-1)\\n            if ((x & (ONE << 0)) != 0)\\n                n = (n * 0x0bc5ab1b16779be3575bd8f0520a9f21e) / 0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^(2^+0)\\n            if ((x & (ONE << 1)) != 0)\\n                n = (n * 0x0454aaa8efe072e7f6ddbab84b40a55c5) / 0x00960aadc109e7a3bf4578099615711ea; // multiply by e^(2^+1)\\n            if ((x & (ONE << 2)) != 0)\\n                n = (n * 0x00960aadc109e7a3bf4578099615711d7) / 0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^(2^+2)\\n            if ((x & (ONE << 3)) != 0)\\n                n = (n * 0x0002bf84208204f5977f9a8cf01fdc307) / 0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^(2^+3)\\n        }\\n\\n        return Fraction({ n: n, d: ONE });\\n    }\\n\\n    /**\\n     * @dev returns a fraction with truncated components\\n     * note that since the input value is truncated, the use of the method incurs precision loss\\n     */\\n    function truncatedFraction(Fraction memory fraction, uint256 max) internal pure returns (Fraction memory) {\\n        uint256 scale = Math.ceilDiv(Math.max(fraction.n, fraction.d), max);\\n        Fraction memory truncated = Fraction({ n: fraction.n / scale, d: fraction.d / scale });\\n        if (truncated.d == 0) {\\n            revert InvalidFraction();\\n        }\\n\\n        return truncated;\\n    }\\n\\n    /**\\n     * @dev returns the weighted average of two fractions\\n     */\\n    function weightedAverage(\\n        Fraction memory fraction1,\\n        Fraction memory fraction2,\\n        uint256 weight1,\\n        uint256 weight2\\n    ) internal pure returns (Fraction memory) {\\n        return\\n            Fraction({\\n                n: fraction1.n * fraction2.d * weight1 + fraction1.d * fraction2.n * weight2,\\n                d: fraction1.d * fraction2.d * (weight1 + weight2)\\n            });\\n    }\\n\\n    /**\\n     * @dev returns whether or not the deviation of an offset sample from a base sample is within a permitted range\\n     * for example, if the maximum permitted deviation is 5%, then evaluate `95% * base <= offset <= 105% * base`\\n     */\\n    function isInRange(\\n        Fraction memory baseSample,\\n        Fraction memory offsetSample,\\n        uint32 maxDeviationPPM\\n    ) internal pure returns (bool) {\\n        Uint512 memory min = mul512(baseSample.n, offsetSample.d * (PPM_RESOLUTION - maxDeviationPPM));\\n        Uint512 memory mid = mul512(baseSample.d, offsetSample.n * PPM_RESOLUTION);\\n        Uint512 memory max = mul512(baseSample.n, offsetSample.d * (PPM_RESOLUTION + maxDeviationPPM));\\n        return lte512(min, mid) && lte512(mid, max);\\n    }\\n\\n    /**\\n     * @dev returns an `Sint256` positive representation of an unsigned integer\\n     */\\n    function toPos256(uint256 n) internal pure returns (Sint256 memory) {\\n        return Sint256({ value: n, isNeg: false });\\n    }\\n\\n    /**\\n     * @dev returns an `Sint256` negative representation of an unsigned integer\\n     */\\n    function toNeg256(uint256 n) internal pure returns (Sint256 memory) {\\n        return Sint256({ value: n, isNeg: true });\\n    }\\n\\n    /**\\n     * @dev returns the largest integer smaller than or equal to `x * y / z`\\n     */\\n    function mulDivF(uint256 x, uint256 y, uint256 z) internal pure returns (uint256) {\\n        Uint512 memory xy = mul512(x, y);\\n\\n        // if `x * y < 2 ^ 256`\\n        if (xy.hi == 0) {\\n            return xy.lo / z;\\n        }\\n\\n        // assert `x * y / z < 2 ^ 256`\\n        if (xy.hi >= z) {\\n            revert Overflow();\\n        }\\n\\n        uint256 m = _mulMod(x, y, z); // `m = x * y % z`\\n        Uint512 memory n = _sub512(xy, m); // `n = x * y - m` hence `n / z = floor(x * y / z)`\\n\\n        // if `n < 2 ^ 256`\\n        if (n.hi == 0) {\\n            return n.lo / z;\\n        }\\n\\n        uint256 p = _unsafeSub(0, z) & z; // `p` is the largest power of 2 which `z` is divisible by\\n        uint256 q = _div512(n, p); // `n` is divisible by `p` because `n` is divisible by `z` and `z` is divisible by `p`\\n        uint256 r = _inv256(z / p); // `z / p = 1 mod 2` hence `inverse(z / p) = 1 mod 2 ^ 256`\\n        return _unsafeMul(q, r); // `q * r = (n / p) * inverse(z / p) = n / z`\\n    }\\n\\n    /**\\n     * @dev returns the smallest integer larger than or equal to `x * y / z`\\n     */\\n    function mulDivC(uint256 x, uint256 y, uint256 z) internal pure returns (uint256) {\\n        uint256 w = mulDivF(x, y, z);\\n        if (_mulMod(x, y, z) > 0) {\\n            if (w >= type(uint256).max) {\\n                revert Overflow();\\n            }\\n\\n            return w + 1;\\n        }\\n        return w;\\n    }\\n\\n    /**\\n     * @dev returns the maximum of `n1 - n2` and 0\\n     */\\n    function subMax0(uint256 n1, uint256 n2) internal pure returns (uint256) {\\n        return n1 > n2 ? n1 - n2 : 0;\\n    }\\n\\n    /**\\n     * @dev returns the value of `x > y`\\n     */\\n    function gt512(Uint512 memory x, Uint512 memory y) internal pure returns (bool) {\\n        return x.hi > y.hi || (x.hi == y.hi && x.lo > y.lo);\\n    }\\n\\n    /**\\n     * @dev returns the value of `x < y`\\n     */\\n    function lt512(Uint512 memory x, Uint512 memory y) internal pure returns (bool) {\\n        return x.hi < y.hi || (x.hi == y.hi && x.lo < y.lo);\\n    }\\n\\n    /**\\n     * @dev returns the value of `x >= y`\\n     */\\n    function gte512(Uint512 memory x, Uint512 memory y) internal pure returns (bool) {\\n        return !lt512(x, y);\\n    }\\n\\n    /**\\n     * @dev returns the value of `x <= y`\\n     */\\n    function lte512(Uint512 memory x, Uint512 memory y) internal pure returns (bool) {\\n        return !gt512(x, y);\\n    }\\n\\n    /**\\n     * @dev returns the value of `x * y`\\n     */\\n    function mul512(uint256 x, uint256 y) internal pure returns (Uint512 memory) {\\n        uint256 p = _mulModMax(x, y);\\n        uint256 q = _unsafeMul(x, y);\\n        if (p >= q) {\\n            return Uint512({ hi: p - q, lo: q });\\n        }\\n        return Uint512({ hi: _unsafeSub(p, q) - 1, lo: q });\\n    }\\n\\n    /**\\n     * @dev returns the value of `x - y`, given that `x >= y`\\n     */\\n    function _sub512(Uint512 memory x, uint256 y) private pure returns (Uint512 memory) {\\n        if (x.lo >= y) {\\n            return Uint512({ hi: x.hi, lo: x.lo - y });\\n        }\\n        return Uint512({ hi: x.hi - 1, lo: _unsafeSub(x.lo, y) });\\n    }\\n\\n    /**\\n     * @dev returns the value of `x / pow2n`, given that `x` is divisible by `pow2n`\\n     */\\n    function _div512(Uint512 memory x, uint256 pow2n) private pure returns (uint256) {\\n        uint256 pow2nInv = _unsafeAdd(_unsafeSub(0, pow2n) / pow2n, 1); // `1 << (256 - n)`\\n        return _unsafeMul(x.hi, pow2nInv) | (x.lo / pow2n); // `(x.hi << (256 - n)) | (x.lo >> n)`\\n    }\\n\\n    /**\\n     * @dev returns the inverse of `d` modulo `2 ^ 256`, given that `d` is congruent to `1` modulo `2`\\n     */\\n    function _inv256(uint256 d) private pure returns (uint256) {\\n        // approximate the root of `f(x) = 1 / x - d` using the newton\u2013raphson convergence method\\n        uint256 x = 1;\\n        for (uint256 i = 0; i < 8; i++) {\\n            x = _unsafeMul(x, _unsafeSub(2, _unsafeMul(x, d))); // `x = x * (2 - x * d) mod 2 ^ 256`\\n        }\\n        return x;\\n    }\\n\\n    /**\\n     * @dev returns `(x + y) % 2 ^ 256`\\n     */\\n    function _unsafeAdd(uint256 x, uint256 y) private pure returns (uint256) {\\n        unchecked {\\n            return x + y;\\n        }\\n    }\\n\\n    /**\\n     * @dev returns `(x - y) % 2 ^ 256`\\n     */\\n    function _unsafeSub(uint256 x, uint256 y) private pure returns (uint256) {\\n        unchecked {\\n            return x - y;\\n        }\\n    }\\n\\n    /**\\n     * @dev returns `(x * y) % 2 ^ 256`\\n     */\\n    function _unsafeMul(uint256 x, uint256 y) private pure returns (uint256) {\\n        unchecked {\\n            return x * y;\\n        }\\n    }\\n\\n    /**\\n     * @dev returns `x * y % (2 ^ 256 - 1)`\\n     */\\n    function _mulModMax(uint256 x, uint256 y) private pure returns (uint256) {\\n        return mulmod(x, y, type(uint256).max);\\n    }\\n\\n    /**\\n     * @dev returns `x * y % z`\\n     */\\n    function _mulMod(uint256 x, uint256 y, uint256 z) private pure returns (uint256) {\\n        return mulmod(x, y, z);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utility/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\nimport { IOwned } from \\\"./interfaces/IOwned.sol\\\";\\nimport { AccessDenied } from \\\"./Utils.sol\\\";\\n\\n/**\\n * @dev this contract provides support and utilities for contract ownership\\n */\\nabstract contract Owned is IOwned {\\n    error SameOwner();\\n\\n    address private _owner;\\n    address private _newOwner;\\n\\n    /**\\n     * @dev triggered when the owner is updated\\n     */\\n    event OwnerUpdate(address indexed prevOwner, address indexed newOwner);\\n\\n    // solhint-disable func-name-mixedcase\\n\\n    /**\\n     * @dev initializes the contract\\n     */\\n    constructor() {\\n        _setOwnership(msg.sender);\\n    }\\n\\n    // solhint-enable func-name-mixedcase\\n\\n    // allows execution by the owner only\\n    modifier onlyOwner() {\\n        _onlyOwner();\\n\\n        _;\\n    }\\n\\n    // error message binary size optimization\\n    function _onlyOwner() private view {\\n        if (msg.sender != _owner) {\\n            revert AccessDenied();\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IOwned\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @inheritdoc IOwned\\n     */\\n    function transferOwnership(address ownerCandidate) public virtual onlyOwner {\\n        if (ownerCandidate == _owner) {\\n            revert SameOwner();\\n        }\\n\\n        _newOwner = ownerCandidate;\\n    }\\n\\n    /**\\n     * @inheritdoc IOwned\\n     */\\n    function acceptOwnership() public virtual {\\n        if (msg.sender != _newOwner) {\\n            revert AccessDenied();\\n        }\\n\\n        _setOwnership(_newOwner);\\n    }\\n\\n    /**\\n     * @dev returns the address of the new owner candidate\\n     */\\n    function newOwner() external view returns (address) {\\n        return _newOwner;\\n    }\\n\\n    /**\\n     * @dev sets the new owner internally\\n     */\\n    function _setOwnership(address ownerCandidate) private {\\n        address prevOwner = _owner;\\n\\n        _owner = ownerCandidate;\\n        _newOwner = address(0);\\n\\n        emit OwnerUpdate({ prevOwner: prevOwner, newOwner: ownerCandidate });\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utility/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\nimport { PPM_RESOLUTION } from \\\"./Constants.sol\\\";\\n\\nerror AccessDenied();\\nerror AlreadyExists();\\nerror DoesNotExist();\\nerror InvalidAddress();\\nerror InvalidExternalAddress();\\nerror InvalidFee();\\nerror InvalidPool();\\nerror InvalidPoolCollection();\\nerror InvalidStakedBalance();\\nerror InvalidToken();\\nerror InvalidParam();\\nerror NotEmpty();\\nerror NotPayable();\\nerror ZeroValue();\\n\\n/**\\n * @dev common utilities\\n */\\nabstract contract Utils {\\n    // allows execution by the caller only\\n    modifier only(address caller) {\\n        _only(caller);\\n\\n        _;\\n    }\\n\\n    function _only(address caller) internal view {\\n        if (msg.sender != caller) {\\n            revert AccessDenied();\\n        }\\n    }\\n\\n    // verifies that a value is greater than zero\\n    modifier greaterThanZero(uint256 value) {\\n        _greaterThanZero(value);\\n\\n        _;\\n    }\\n\\n    // error message binary size optimization\\n    function _greaterThanZero(uint256 value) internal pure {\\n        if (value == 0) {\\n            revert ZeroValue();\\n        }\\n    }\\n\\n    // validates an address - currently only checks that it isn't null\\n    modifier validAddress(address addr) {\\n        _validAddress(addr);\\n\\n        _;\\n    }\\n\\n    // error message binary size optimization\\n    function _validAddress(address addr) internal pure {\\n        if (addr == address(0)) {\\n            revert InvalidAddress();\\n        }\\n    }\\n\\n    // validates an external address - currently only checks that it isn't null or this\\n    modifier validExternalAddress(address addr) {\\n        _validExternalAddress(addr);\\n\\n        _;\\n    }\\n\\n    // error message binary size optimization\\n    function _validExternalAddress(address addr) internal view {\\n        if (addr == address(0) || addr == address(this)) {\\n            revert InvalidExternalAddress();\\n        }\\n    }\\n\\n    // ensures that the fee is valid\\n    modifier validFee(uint32 fee) {\\n        _validFee(fee);\\n\\n        _;\\n    }\\n\\n    // error message binary size optimization\\n    function _validFee(uint32 fee) internal pure {\\n        if (fee > PPM_RESOLUTION) {\\n            revert InvalidFee();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utility/interfaces/IOwned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\n/**\\n * @dev Owned interface\\n */\\ninterface IOwned {\\n    /**\\n     * @dev returns the address of the current owner\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @dev allows transferring the contract ownership\\n     *\\n     * requirements:\\n     *\\n     * - the caller must be the owner of the contract\\n     * - the new owner still needs to accept the transfer\\n     */\\n    function transferOwnership(address ownerCandidate) external;\\n\\n    /**\\n     * @dev used by a new owner to accept an ownership transfer\\n     */\\n    function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"contracts/utility/interfaces/IUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\nimport { IVersioned } from \\\"./IVersioned.sol\\\";\\n\\nimport { IAccessControlEnumerableUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\\\";\\n\\n/**\\n * @dev this is the common interface for upgradeable contracts\\n */\\ninterface IUpgradeable is IAccessControlEnumerableUpgradeable, IVersioned {\\n\\n}\\n\"\r\n    },\r\n    \"contracts/utility/interfaces/IVersioned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\n/**\\n * @dev an interface for a versioned contract\\n */\\ninterface IVersioned {\\n    function version() external view returns (uint16);\\n}\\n\"\r\n    },\r\n    \"contracts/vaults/interfaces/IExternalProtectionVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\nimport { IVault } from \\\"./IVault.sol\\\";\\n\\ninterface IExternalProtectionVault is IVault {}\\n\"\r\n    },\r\n    \"contracts/vaults/interfaces/IMasterVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\nimport { IVault } from \\\"./IVault.sol\\\";\\n\\ninterface IMasterVault is IVault {}\\n\"\r\n    },\r\n    \"contracts/vaults/interfaces/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity 0.8.13;\\n\\nimport { IUpgradeable } from \\\"../../utility/interfaces/IUpgradeable.sol\\\";\\n\\nimport { Token } from \\\"../../token/Token.sol\\\";\\n\\n// the asset manager role is required to access all the funds\\nbytes32 constant ROLE_ASSET_MANAGER = keccak256(\\\"ROLE_ASSET_MANAGER\\\");\\n\\ninterface IVault is IUpgradeable {\\n    /**\\n     * @dev triggered when tokens have been withdrawn from the vault\\n     */\\n    event FundsWithdrawn(Token indexed token, address indexed caller, address indexed target, uint256 amount);\\n\\n    /**\\n     * @dev triggered when tokens have been burned from the vault\\n     */\\n    event FundsBurned(Token indexed token, address indexed caller, uint256 amount);\\n\\n    /**\\n     * @dev tells whether the vault accepts native token deposits\\n     */\\n    function isPayable() external view returns (bool);\\n\\n    /**\\n     * @dev withdraws funds held by the contract and sends them to an account\\n     */\\n    function withdrawFunds(\\n        Token token,\\n        address payable target,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n     * @dev burns funds held by the contract\\n     */\\n    function burn(Token token, uint256 amount) external;\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IBancorNetwork\",\"name\":\"initNetwork\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"initBNT\",\"type\":\"address\"},{\"internalType\":\"contract INetworkSettings\",\"name\":\"initNetworkSettings\",\"type\":\"address\"},{\"internalType\":\"contract IMasterVault\",\"name\":\"initMasterVault\",\"type\":\"address\"},{\"internalType\":\"contract IBNTPool\",\"name\":\"initBNTPool\",\"type\":\"address\"},{\"internalType\":\"contract IExternalProtectionVault\",\"name\":\"initExternalProtectionVault\",\"type\":\"address\"},{\"internalType\":\"contract IPoolTokenFactory\",\"name\":\"initPoolTokenFactory\",\"type\":\"address\"},{\"internalType\":\"contract IPoolMigrator\",\"name\":\"initPoolMigrator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessDenied\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyEnabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DepositingDisabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FundingLimitTooHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientLiquidity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientSourceAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientTargetAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFraction\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidParam\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidStakedBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotWhitelisted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Overflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolCollectionWithdrawalInputInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RateUnstable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SameOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TradingDisabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroValue\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"prevFeePPM\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newFeePPM\",\"type\":\"uint32\"}],\"name\":\"DefaultTradingFeePPMUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"DepositingEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"prevFeePPM\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newFeePPM\",\"type\":\"uint32\"}],\"name\":\"NetworkFeePPMUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"contextId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Token\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolTokenAmount\",\"type\":\"uint256\"}],\"name\":\"TokensDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"contextId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Token\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"externalProtectionBaseTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bntAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawalFeeAmount\",\"type\":\"uint256\"}],\"name\":\"TokensWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"contextId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolTokenSupply\",\"type\":\"uint256\"}],\"name\":\"TotalLiquidityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"newStatus\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"reason\",\"type\":\"uint8\"}],\"name\":\"TradingEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"prevFeePPM\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newFeePPM\",\"type\":\"uint32\"}],\"name\":\"TradingFeePPMUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"contextId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Token\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevLiquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLiquidity\",\"type\":\"uint256\"}],\"name\":\"TradingLiquidityUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"createPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultTradingFeePPM\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"contextId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseTokenAmount\",\"type\":\"uint256\"}],\"name\":\"depositFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"depositingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"disableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"disableTradingByNetwork\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"enableDepositing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bntVirtualBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseTokenVirtualBalance\",\"type\":\"uint256\"}],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"isPoolStable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"isPoolValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract IPoolToken\",\"name\":\"poolToken\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"tradingFeePPM\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"tradingEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"depositingEnabled\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"uint112\",\"name\":\"n\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"d\",\"type\":\"uint112\"}],\"internalType\":\"struct Fraction112\",\"name\":\"rate\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint112\",\"name\":\"n\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"d\",\"type\":\"uint112\"}],\"internalType\":\"struct Fraction112\",\"name\":\"invRate\",\"type\":\"tuple\"}],\"internalType\":\"struct AverageRates\",\"name\":\"averageRates\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"bntTradingLiquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"baseTokenTradingLiquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"stakedBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolLiquidity\",\"name\":\"liquidity\",\"type\":\"tuple\"}],\"internalType\":\"struct Pool\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"migratePoolIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"contract IPoolCollection\",\"name\":\"targetPoolCollection\",\"type\":\"address\"}],\"name\":\"migratePoolOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkFeePPM\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"onFeesCollected\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"poolData\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IPoolToken\",\"name\":\"poolToken\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"tradingFeePPM\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"tradingEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"depositingEnabled\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"uint112\",\"name\":\"n\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"d\",\"type\":\"uint112\"}],\"internalType\":\"struct Fraction112\",\"name\":\"rate\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint112\",\"name\":\"n\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"d\",\"type\":\"uint112\"}],\"internalType\":\"struct Fraction112\",\"name\":\"invRate\",\"type\":\"tuple\"}],\"internalType\":\"struct AverageRates\",\"name\":\"averageRates\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"bntTradingLiquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"baseTokenTradingLiquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"stakedBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolLiquidity\",\"name\":\"liquidity\",\"type\":\"tuple\"}],\"internalType\":\"struct Pool\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"poolLiquidity\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"bntTradingLiquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"baseTokenTradingLiquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"stakedBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolLiquidity\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"poolToken\",\"outputs\":[{\"internalType\":\"contract IPoolToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseTokenAmountToDistribute\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolPoolTokenAmount\",\"type\":\"uint256\"}],\"name\":\"poolTokenAmountToBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolTokenAmount\",\"type\":\"uint256\"}],\"name\":\"poolTokenToUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolType\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"contract Token[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"newDefaultTradingFeePPM\",\"type\":\"uint32\"}],\"name\":\"setDefaultTradingFeePPM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"newNetworkFeePPM\",\"type\":\"uint32\"}],\"name\":\"setNetworkFeePPM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"newTradingFeePPM\",\"type\":\"uint32\"}],\"name\":\"setTradingFeePPM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"contextId\",\"type\":\"bytes32\"},{\"internalType\":\"contract Token\",\"name\":\"sourceToken\",\"type\":\"address\"},{\"internalType\":\"contract Token\",\"name\":\"targetToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"ignoreFees\",\"type\":\"bool\"}],\"name\":\"tradeBySourceAmount\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tradingFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"networkFeeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct TradeAmountAndFee\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"contextId\",\"type\":\"bytes32\"},{\"internalType\":\"contract Token\",\"name\":\"sourceToken\",\"type\":\"address\"},{\"internalType\":\"contract Token\",\"name\":\"targetToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"targetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"ignoreFees\",\"type\":\"bool\"}],\"name\":\"tradeByTargetAmount\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tradingFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"networkFeeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct TradeAmountAndFee\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"sourceToken\",\"type\":\"address\"},{\"internalType\":\"contract Token\",\"name\":\"targetToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"targetAmount\",\"type\":\"uint256\"}],\"name\":\"tradeInputAndFeeByTargetAmount\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tradingFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"networkFeeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct TradeAmountAndFee\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"sourceToken\",\"type\":\"address\"},{\"internalType\":\"contract Token\",\"name\":\"targetToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"}],\"name\":\"tradeOutputAndFeeBySourceAmount\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tradingFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"networkFeeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct TradeAmountAndFee\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"tradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"tradingFeePPM\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ownerCandidate\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseTokenAmount\",\"type\":\"uint256\"}],\"name\":\"underlyingToPoolToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"updateTradingLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"contextId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseTokenAmount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Token\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolTokenAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawalAmounts\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bntAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct WithdrawalAmounts\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PoolCollection", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000eef417e1d5cc832e619ae18d2f140de2999dd4fb0000000000000000000000001f573d6fb3f13d689ff844b4ce37794d79a7ff1c00000000000000000000000083e1814ba31f7ea95d216204bb45fe75ce09b14f000000000000000000000000649765821d9f64198c905ec0b2b037a4a52bc37300000000000000000000000002651e355d26f3506c1e644ba393fdd9ac95eaca000000000000000000000000fd31662b3d54edde9b6bdd32c9c27c8e292cad570000000000000000000000009e912953db31fe933bda43374208e967058d9d5f00000000000000000000000097cec0f2d355bf073619a5093f989709cae4a191", "EVMVersion": "london", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}