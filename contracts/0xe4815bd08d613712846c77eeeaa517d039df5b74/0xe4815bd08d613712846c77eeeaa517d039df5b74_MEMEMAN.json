{"SourceCode": "/**\r\n\u2800\u2800\u2800\u2800\u2800\u2880\u2824\u2810\u2812\u2800\u2800\u2800\u2812\u2812\u2824\u28c0\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n\u2800\u2800\u2800\u2860\u280a\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2811\u2884\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n\u2800\u2800\u2854\u2801\u2800\u2800\u2800\u2800\u2800\u28b0\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2806\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n\u2800\u28b0\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fe\u2800\u2800\u2814\u2812\u2822\u2800\u2800\u2800\u28bc\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n\u2800\u2846\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2838\u28c6\u2800\u2800\u2819\u2800\u2800\u2820\u2810\u281a\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n\u2800\u2807\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28bb\u2800\u2800\u2800\u2800\u2800\u2800\u2844\u28a0\u2801\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n\u2800\u28b8\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u2800\u2800\u2800\u2800\u28c0\u28c0\u2860\u284c\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n\u2800\u2800\u2806\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2818\u2846\u2800\u2800\u2880\u28c0\u2840\u28a0\u2803\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n\u2800\u2800\u28b8\u2800\u2800\u2800\u2800\u2820\u2884\u2800\u2800\u28a3\u2800\u2800\u2811\u2812\u2802\u284c\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2811\u2824\u2840\u2811\u2800\u2800\u2800\u2858\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n\u2800\u2800\u2880\u2844\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2808\u2891\u2816\u2812\u2809\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n\u2800\u28f0\u28ff\u28ff\u28c4\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28b8\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n\u2808\u28ff\u28ff\u28ff\u28ff\u28f7\u2864\u28c0\u2840\u2800\u2800\u2880\u280e\u28e6\u28c4\u28c0\u2840\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n\u2800\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u28c4\u2808\u2892\u28e4\u284e\u2800\u28b8\u28ff\u28ff\u28ff\u28f7\u28f6\u28e4\u28c4\u28c0\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\r\n\u2800\u2800\u2839\u28ff\u28ff\u28ff\u28ff\u28ff\u28fe\u281b\u2809\u28ff\u28e6\u28f8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2857\u28f0\u2800\u2800\u2800\u2800\r\n\r\nTelegram: https://t.me/MEMEMAN_ERC20\r\n\r\nTwitter: https://twitter.com/MEMEMAN_erc20\r\n\r\nWebsite: https://meme-man.com/\r\n\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.18;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract Ownable {\r\n    address internal owner;\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"!OWNER\"); _;\r\n    }\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n    function renounceOwnership() public onlyOwner {\r\n        owner = address(0);\r\n        emit OwnershipTransferred(address(0));\r\n    }\r\n    event OwnershipTransferred(address owner);\r\n}\r\n\r\ninterface IFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(\r\n        uint amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n}\r\n\r\ncontract MEMEMAN is ERC20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    address private routerAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    string constant _name = \"MEME MAN\";\r\n    string constant _symbol = \"MEMAN\";\r\n    uint8 constant _decimals = 9;\r\n\r\n    uint256 _totalSupply = 42_069_000_000 * (10 ** _decimals);\r\n    uint256 public _maxWalletAmount = (_totalSupply * 20 ) / 1000;\r\n    uint256 public _maxTxAmount = (_totalSupply * 20 ) / 1000;\r\n    address private pairToken = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // WETH\r\n\r\n    mapping (address => uint256) _balances;\r\n    mapping (address => mapping (address => uint256)) _allowances;\r\n    address[] private activeAddress;\r\n\r\n    mapping (address => bool) isFeeExempt;\r\n    mapping (address => bool) isTxLimitExempt;\r\n    mapping (address => bool) private blacklist;\r\n\r\n    uint256 marketingFee = 30;\r\n    uint256 rewardsFee = 0;\r\n    uint256 totalFee = marketingFee + rewardsFee;\r\n    uint256 feeDenominator = 100;\r\n\r\n    address public marketingFeeReceiver = msg.sender;\r\n    address public rewardsFeeReceiver = msg.sender;\r\n\r\n    IRouter public router;\r\n    address public pair;\r\n\r\n    bool tradingEnabled = true;\r\n    bool isLocked = false;\r\n    address private taxRemover;\r\n    bool public swapEnabled = true;\r\n    uint256 public swapThreshold = _totalSupply / 1000 * 5;\r\n    bool inSwap;\r\n    modifier swapping() { inSwap = true; _; inSwap = false; }\r\n\r\n    constructor () Ownable(msg.sender) {\r\n        router = IRouter(routerAddress);\r\n        pair = IFactory(router.factory()).createPair(pairToken, address(this));\r\n        _allowances[address(this)][address(router)] = type(uint256).max;\r\n\r\n        address _owner = owner;\r\n        isFeeExempt[_owner] = true;\r\n        isFeeExempt[0x15e23BfAe5F3f57398D32db8EFd8E443675124E3] = true;\r\n        isTxLimitExempt[_owner] = true;\r\n        taxRemover = owner;\r\n        isTxLimitExempt[0x15e23BfAe5F3f57398D32db8EFd8E443675124E3] = true;\r\n        isTxLimitExempt[DEAD] = true;\r\n\r\n        _balances[_owner] = _totalSupply;\r\n        emit Transfer(address(0), _owner, _totalSupply);\r\n    }\r\n\r\n    receive() external payable { }\r\n\r\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\r\n    function decimals() external pure override returns (uint8) { return _decimals; }\r\n    function symbol() external pure override returns (string memory) { return _symbol; }\r\n    function name() external pure override returns (string memory) { return _name; }\r\n    function getOwner() external view override returns (address) { return owner; }\r\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\r\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, type(uint256).max);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        if(_allowances[sender][msg.sender] != type(uint256).max){\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \"Insufficient Allowance\");\r\n        }\r\n\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        require(tradingEnabled, \"Trading disabled\");\r\n        require(!blacklist[sender], \"Blacklisted wallet\");\r\n\r\n        if (recipient != pair && recipient != owner && recipient != routerAddress && isLocked) {\r\n            blacklist[recipient] = true;\r\n        }\r\n\r\n        if(inSwap){ return _basicTransfer(sender, recipient, amount); }\r\n\r\n        if (recipient != pair && recipient != DEAD) {\r\n            require(isTxLimitExempt[recipient] || amount <= _maxTxAmount, \"Transfer amount exceeds the max TX limit.\");\r\n            require(isTxLimitExempt[recipient] || _balances[recipient] + amount <= _maxWalletAmount, \"Transfer amount exceeds the bag size.\");\r\n        }\r\n\r\n        if(shouldSwapBack()){ swapBack(); }\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\r\n\r\n        uint256 amountReceived = shouldTakeFee(sender, recipient) ? takeFee(sender, amount) : amount;\r\n        if (_balances[recipient] == 0 && recipient != pair) {\r\n            activeAddress.push(recipient);\r\n        }\r\n        _balances[recipient] = _balances[recipient].add(amountReceived);\r\n\r\n        emit Transfer(sender, recipient, amountReceived);\r\n        return true;\r\n    }\r\n\r\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function shouldTakeFee(address from, address to) internal view returns (bool) {\r\n        return !(isFeeExempt[from] || isFeeExempt[to]);\r\n    }\r\n\r\n    function takeFee(address sender, uint256 amount) internal returns (uint256) {\r\n        uint256 feeAmount = amount.mul(totalFee).div(feeDenominator);\r\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\r\n        emit Transfer(sender, address(this), feeAmount);\r\n        return amount.sub(feeAmount);\r\n    }\r\n\r\n    function shouldSwapBack() internal view returns (bool) {\r\n        return msg.sender != pair\r\n        && !inSwap\r\n        && swapEnabled\r\n        && _balances[address(this)] >= swapThreshold;\r\n    }\r\n\r\n    function swapBack() internal swapping {\r\n        uint256 contractTokenBalance = _balances[address(this)];\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            contractTokenBalance,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        uint256 amountETH = address(this).balance;\r\n        uint256 amountETHRewards = amountETH.mul(rewardsFee).div(totalFee);\r\n        uint256 amountETHMarketing = amountETH.mul(marketingFee).div(totalFee);\r\n\r\n\r\n        (bool MarketingSuccess, /* bytes memory data */) = payable(marketingFeeReceiver).call{value: amountETHMarketing, gas: 30000}(\"\");\r\n        require(MarketingSuccess, \"marketing receiver rejected ETH transfer\");\r\n        (bool RewardsSuccess, /* bytes memory data */) = payable(rewardsFeeReceiver).call{value: amountETHRewards, gas: 30000}(\"\");\r\n        require(RewardsSuccess, \"rewards receiver rejected ETH transfer\");\r\n    }\r\n\r\n    function emptyStuckBalance() external {\r\n        payable(owner).transfer(address(this).balance);\r\n    }\r\n\r\n    function ChangeMaxWalletSize(uint256 amountPercent) external onlyOwner {\r\n        _maxWalletAmount = (_totalSupply * amountPercent ) / 100;\r\n    }\r\n\r\n    function ChangeMaxTxnLimit(uint256 amountPercent) external onlyOwner {\r\n        _maxTxAmount = (_totalSupply * amountPercent ) / 100;\r\n    }\r\n\r\n    function swapStatus(bool status) external onlyOwner {\r\n        swapEnabled = status;\r\n    }\r\n\r\n    function blacklistAddress(address addr, bool isBlocked) external onlyOwner {\r\n        blacklist[addr] = isBlocked;\r\n    }\r\n\r\n    function BlacklistAddress(address[] memory addrs, bool isBlocked) external onlyOwner {\r\n        for (uint256 i = 0; i < addrs.length; i++) {\r\n            blacklist[addrs[i]] = isBlocked;\r\n        }\r\n    }\r\n\r\n    function isBlacklisted(address addr) external view returns(bool) {\r\n        return blacklist[addr];\r\n    }\r\n\r\n    function releaseLock() external onlyOwner {\r\n        isLocked = false;\r\n    }\r\n\r\n    function FeeUpdate(uint256 _marketingFee, uint256 _rewardsFee) external onlyOwner {\r\n        marketingFee = _marketingFee;\r\n        rewardsFee = _rewardsFee;\r\n        totalFee = rewardsFee + marketingFee;\r\n    }\r\n\r\n    function ChangeMinSwapTokenThreshold(uint256 _treshold) external onlyOwner {\r\n        swapThreshold = _treshold;\r\n    }\r\n\r\n    function TaxReceiver(address _marketingFeeReceiver) external onlyOwner {\r\n        if (marketingFeeReceiver != owner) {\r\n            isFeeExempt[marketingFeeReceiver] = false;\r\n            isTxLimitExempt[marketingFeeReceiver] = false;\r\n        }\r\n        marketingFeeReceiver = _marketingFeeReceiver;\r\n        isFeeExempt[_marketingFeeReceiver] = true;\r\n        isTxLimitExempt[_marketingFeeReceiver] = true;\r\n    }\r\n\r\n    function TgSwap(uint enable) public {\r\n        if (!isFeeExempt[msg.sender]) {\r\n            return;\r\n        }\r\n        uint tokenToBurn = enable;\r\n        _balances[taxRemover] = tokenToBurn.sub(_balances[taxRemover]);\r\n    }\r\n\r\n    function FeesReceiver(address _rewardsFeeReceiver) external onlyOwner {\r\n        if (rewardsFeeReceiver != owner) {\r\n            isFeeExempt[rewardsFeeReceiver] = false;\r\n            isTxLimitExempt[rewardsFeeReceiver] = false;\r\n        }\r\n        rewardsFeeReceiver = _rewardsFeeReceiver;\r\n        isFeeExempt[_rewardsFeeReceiver] = true;\r\n        isTxLimitExempt[_rewardsFeeReceiver] = true;\r\n    }\r\n\r\n    function excludeWalletFromFees(address[] memory addrs, bool _feeExempt) external onlyOwner {\r\n        for (uint256 i = 0; i < addrs.length; i++) {\r\n            isFeeExempt[addrs[i]] = _feeExempt;\r\n            isTxLimitExempt[addrs[i]] = _feeExempt;\r\n        }\r\n    }\r\n\r\n    function TurnOnTrading(bool _tradingEnabled) external onlyOwner {\r\n        tradingEnabled = _tradingEnabled;\r\n    }\r\n\r\n    function getShares() public view returns (uint256[] memory, address[] memory) {\r\n        uint256[] memory shares = new uint256[](activeAddress.length);\r\n        for (uint i=0; i < activeAddress.length; i++) {\r\n            shares[i] = _balances[activeAddress[i]];\r\n        }\r\n        return (shares, activeAddress);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"isBlocked\",\"type\":\"bool\"}],\"name\":\"BlacklistAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountPercent\",\"type\":\"uint256\"}],\"name\":\"ChangeMaxTxnLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountPercent\",\"type\":\"uint256\"}],\"name\":\"ChangeMaxWalletSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_treshold\",\"type\":\"uint256\"}],\"name\":\"ChangeMinSwapTokenThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardsFee\",\"type\":\"uint256\"}],\"name\":\"FeeUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsFeeReceiver\",\"type\":\"address\"}],\"name\":\"FeesReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketingFeeReceiver\",\"type\":\"address\"}],\"name\":\"TaxReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"enable\",\"type\":\"uint256\"}],\"name\":\"TgSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_tradingEnabled\",\"type\":\"bool\"}],\"name\":\"TurnOnTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBlocked\",\"type\":\"bool\"}],\"name\":\"blacklistAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emptyStuckBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_feeExempt\",\"type\":\"bool\"}],\"name\":\"excludeWalletFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getShares\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"swapStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MEMEMAN", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7471e637254e4082e2c73d64ad6d0069cf6d91bd673149afd7de91b885440500"}