{"SourceCode": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\n\n// \n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\nabstract contract ERC20Basic {\n    uint256 public totalSupply;\n    function balanceOf(address who) public view virtual returns (uint256);\n    function transfer(address to, uint256 value) public virtual returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// \n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\nabstract contract ERC20 is ERC20Basic {\n    function allowance(address owner, address spender) public view virtual returns (uint256);\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool);\n    function approve(address spender, uint256 value) public virtual returns (bool);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// \n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n/**\n * Safe unsigned safe math.\n *\n * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli\n *\n * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol\n *\n * Maintained here until merged to mainline zeppelin-solidity.\n *\n */\nlibrary SafeMathLibExt {\n\n    function times(uint a, uint b) public pure returns (uint) {\n        uint c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function divides(uint a, uint b) public pure returns (uint) {\n        assert(b > 0);\n        uint c = a / b;\n        assert(a == b * c + a % b);\n        return c;\n    }\n\n    function minus(uint a, uint b) public pure returns (uint) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function plus(uint a, uint b) public pure returns (uint) {\n        uint c = a + b;\n        assert(c >= a);\n        return c;\n    }\n\n}\n\n// \n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n/**\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\n *\n * Based on code by FirstBlood:\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20 {\n\n    using SafeMathLibExt for uint256;\n\n    /* Token supply got increased and a new owner received these tokens */\n    event Minted(address receiver, uint256 amount);\n\n    /* Actual balances of token holders */\n    mapping(address => uint256) public balances;\n\n    /* approve() allowances */\n    mapping (address => mapping (address => uint256)) public allowed;\n\n    /* Interface declaration */\n    function isToken() public pure returns (bool weAre) {\n        return true;\n    }\n\n    function transfer(address _to, uint256 _value) public virtual override returns (bool success) {\n        balances[msg.sender] = balances[msg.sender].minus(_value);\n        balances[_to] = balances[_to].plus(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public virtual override returns (bool success) {\n        uint256 _allowance = allowed[_from][msg.sender];\n\n        balances[_to] = balances[_to].plus(_value);\n        balances[_from] = balances[_from].minus(_value);\n        allowed[_from][msg.sender] = _allowance.minus(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public view virtual override returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public  virtual override returns (bool success) {\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        // if ((_addedValue != 0) && (allowed[msg.sender][_spender] != 0)) revert();\n        if(_value == 0 ) revert(\"Cannot approve 0 value\");\n        if(_spender == address(0)) revert(\"Cannot approve for Null aDDRESS\");\n        if(allowed[msg.sender][_spender] == 0 ) revert(\"Spender already approved,instead increase/decrease allowance\");\n\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function increaseAllowance(address _spender, uint256 _addedValue) public virtual returns (bool) {\n        if(_addedValue == 0 ) revert(\"Cannot add 0 allowance value\");\n        if(_spender == address(0)) revert(\"Cannot allow for Null address\");\n\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].plus(allowed[msg.sender][_spender]);\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender].plus(allowed[msg.sender][_spender]));\n        return true;\n    }\n\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) public virtual returns (bool) {\n        if(_subtractedValue == 0 ) revert(\"Cannot add 0 decrease value\");\n        if(_spender == address(0)) revert(\"Cannot allow for Null address\");\n        require(_subtractedValue <= allowed[msg.sender][_spender], \"Cannot remove more than allowance!\");\n        \n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].minus(allowed[msg.sender][_spender]);\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender].minus(allowed[msg.sender][_spender]));\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view virtual override returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n}\n\n// \n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n/**\n * Upgrade agent interface inspired by Lunyr.\n *\n * Upgrade agent transfers tokens to a new contract.\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\n */\nabstract contract UpgradeAgent {\n\n    uint public originalSupply;\n\n    /** Interface marker */\n    function isUpgradeAgent() public pure returns (bool) {\n        return true;\n    }\n\n    function upgradeFrom(address _from, uint256 _value) public virtual;\n\n}\n\n// \n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n/**\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\n *\n * First envisioned by Golem and Lunyr projects.\n */\ncontract UpgradeableToken is StandardToken {\n    using SafeMathLibExt for uint;\n\n    /** Contract / person who can set the upgrade path. \n        This can be the same as team multisig wallet, as what it is with its default value. */\n    address public upgradeMaster;\n\n    /** The next contract where the tokens will be migrated. */\n    UpgradeAgent public upgradeAgent;\n\n    /** How many tokens we have upgraded by now. */\n    uint256 public totalUpgraded;\n    /**\n    * Upgrade states.\n    *\n    * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\n    * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet\n    * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet\n    * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\n    *\n    */\n    enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n\n    /**\n    * Somebody has upgraded some of his tokens.\n    */\n    event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n\n    /**\n    * New upgrade agent available.\n    */\n    event UpgradeAgentSet(address agent);\n\n    /**\n    * New upgrade master available.\n    */   \n    event UpgradeMasterSet(address agent);\n\n\n    /**\n    * Do not allow construction without upgrade master set.\n    */\n    constructor(address _upgradeMaster) {\n        require(_upgradeMaster != address(0), \"Upgrade Master cannot be Null Address\");\n        upgradeMaster = _upgradeMaster;\n    }\n\n    /**\n    * Allow the token holder to upgrade some of their tokens to a new contract.\n    */\n    function upgrade(uint256 value) public {\n\n        UpgradeState state = getUpgradeState();\n        if (!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\n            // Called in a bad state\n            revert(\"Called in bad State\");\n        }\n\n        // Validate input value.\n        if (value == 0) revert(\"Invalid input value\");\n\n        balances[msg.sender] = balances[msg.sender].minus(value);\n\n        // Take tokens out from circulation\n        totalSupply = totalSupply.minus(value);\n        totalUpgraded = totalUpgraded.plus(value);\n\n        // Upgrade agent reissues the tokens\n        upgradeAgent.upgradeFrom(msg.sender, value);\n        emit Upgrade(msg.sender, address(upgradeAgent), value);\n    }\n\n    /**\n    * Child contract can enable to provide the condition when the upgrade can begun.\n    */\n    function canUpgrade() public virtual returns(bool) {\n        return true;\n    }\n\n    /**\n    * Set an upgrade agent that handles\n    */\n    function setUpgradeAgent(address agent) external {\n        if (!canUpgrade()) {\n            // The token is not yet in a state that we could think upgrading\n            revert(\"The token is not yet in a state that we could think upgrading\");\n        }\n\n        if (agent == address(0)) revert(\"Cannot be Zero Address\");\n        // Only a master can designate the next agent\n        if (msg.sender != upgradeMaster) revert(\"Only a master can designate the next agent\");\n        // Upgrade has already begun for an agent\n        if (getUpgradeState() == UpgradeState.Upgrading) revert(\"Upgrade has already begun for an agent\");\n\n        upgradeAgent = UpgradeAgent(agent);\n\n        // Bad interface\n        if (!upgradeAgent.isUpgradeAgent()) revert(\"Bad interface\");      \n\n        emit UpgradeAgentSet(agent);\n    }\n\n    /**\n    * Get the state of the token upgrade.\n    */\n    function getUpgradeState() public returns(UpgradeState) {\n        if (!canUpgrade()) return UpgradeState.NotAllowed;\n        else if (address(upgradeAgent) == address(0)) return UpgradeState.WaitingForAgent;\n        else if (totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n        else return UpgradeState.Upgrading;\n    }\n\n    /**\n    * Change the upgrade master.\n    *\n    * This allows us to set a new owner for the upgrade mechanism.\n    */\n    function setUpgradeMaster(address master) public {\n        if (master == address(0)) revert(\"Cannot set master contract to 0\");\n        if (msg.sender != upgradeMaster) revert(\"Msg Sender not upgrade master\");\n        upgradeMaster = master;\n\n        emit UpgradeMasterSet(master);\n    }\n}\n\n// \n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n    * account.\n    */\n    constructor ()  {\n        owner = msg.sender;\n    }\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n}\n\n// \n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n/**\n  * Define interface for releasing the token transfer after a successful crowdsale.\n  */\ncontract ReleasableToken is StandardToken, Ownable {\n    \n    event ReleaseAgentSet(address caller, address agent);\n    event TransferAgentSet(address callet, address agent, bool set);\n    \n    /* The finalizer contract that allows unlift the transfer limits on this token */\n    address public releaseAgent;\n\n    /** A crowdsale contract can release us to the wild if ICO success. \n        If false we are are in transfer lock up period.*/\n    bool public released = false;\n\n    /** Map of agents that are allowed to transfer tokens regardless of the lock down period. \n        These are crowdsale contracts and possible the team multisig itself. */\n    mapping (address => bool) public transferAgents;\n\n    \n\n    /**\n    * Limit token transfer until the crowdsale is over.\n    *\n    */\n    modifier canTransfer(address _sender) {\n\n        if (!released) {\n            if (!transferAgents[_sender]) {\n                revert(\"Not A Transfer Agent\");\n            }\n        }\n        _;\n    }\n\n    /**\n    * Set the contract that can call release and make the token transferable.\n    *\n    * Design choice. Allow reset the release agent to fix fat finger mistakes.\n    */\n    function setReleaseAgent(address addr) public onlyOwner inReleaseState(false) {\n        require(addr != address(0), \"Release Agent cannot be Null Address\");\n        // We don't do interface check here as we might want to a normal wallet address to act as a release agent\n        releaseAgent = addr;\n\n        emit ReleaseAgentSet(msg.sender, addr);\n    }\n\n    /**\n    * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.\n    */\n    function setTransferAgent(address addr, bool state) public onlyOwner inReleaseState(false) {\n        transferAgents[addr] = state;\n\n        emit TransferAgentSet(msg.sender, addr, state);\n    }\n\n    /**\n    * One way function to release the tokens to the wild.\n    *\n    * Can be called only from the release agent that is the final ICO contract. \n    * It is only called if the crowdsale has been success (first milestone reached).\n    */\n    function releaseTokenTransfer() public virtual onlyReleaseAgent {\n        released = true;\n    }\n\n    /** The function can be called only before or after the tokens have been releasesd */\n    modifier inReleaseState(bool releaseState) {\n        if (releaseState != released) {\n            revert(\"Not in released state\");\n        }\n        _;\n    }\n\n    /** The function can be called only by a whitelisted release agent. */\n    modifier onlyReleaseAgent() {\n        if (msg.sender != releaseAgent) {\n            revert(\"Not release agent\");\n        }\n        _;\n    }\n\n    function transfer(address _to, uint _value) public virtual override canTransfer(msg.sender) returns (bool success) {\n        // Call StandardToken.transfer()\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint _value) public virtual override canTransfer(_from) returns (bool success) {\n        // Call StandardToken.transferForm()\n        return super.transferFrom(_from, _to, _value);\n    }\n\n}\n\n// \n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n/**\n * A token that can increase its supply by another contract.\n *\n * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\n * Only mint agents, contracts whitelisted by owner, can mint new tokens.\n *\n */\ncontract MintableTokenExt is StandardToken, Ownable {\n\n    using SafeMathLibExt for uint;\n\n    bool public mintingFinished = false;\n\n    /** List of agents that are allowed to create new tokens */\n    mapping (address => bool) public mintAgents;\n\n    event MintingAgentChanged(address addr, bool state  );\n    event ReversedTokenListMultipleSet(uint length);\n    event FinalizedReversedAddress(address addr);\n\n    /** inPercentageUnit is percents of tokens multiplied to 10 up to percents decimals.\n    * For example, for reserved tokens in percents 2.54%\n    * inPercentageUnit = 254\n    * inPercentageDecimals = 2\n    */\n    struct ReservedTokensData {\n        uint inTokens;\n        uint inPercentageUnit;\n        uint inPercentageDecimals;\n        bool isReserved;\n        bool isDistributed;\n        bool isVested;\n    }\n\n    mapping (address => ReservedTokensData) public reservedTokensList;\n    address[] public reservedTokensDestinations;\n    uint public reservedTokensDestinationsLen = 0;\n    bool private reservedTokensDestinationsAreSet = false;\n\n    modifier onlyMintAgent() {\n        // Only crowdsale contracts are allowed to mint new tokens\n        if (!mintAgents[msg.sender]) {\n            revert(\"Only crowdsale contracts are allowed to mint new tokens\");\n        }\n        _;\n    }\n\n    /** Make sure we are not done yet. */\n    modifier canMint() {\n        if (mintingFinished) revert();\n        _;\n    }\n\n    function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n        ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n        reservedTokensData.isDistributed = true;\n\n        emit FinalizedReversedAddress(addr);\n    }\n\n    function isAddressReserved(address addr)  public  view virtual returns (bool isReserved) {\n        return reservedTokensList[addr].isReserved;\n    }\n\n    function areTokensDistributedForAddress(address addr) public view returns (bool isDistributed) {\n        return reservedTokensList[addr].isDistributed;\n    }\n\n    function getReservedTokens(address addr) public view returns (uint inTokens) {\n        return reservedTokensList[addr].inTokens;\n    }\n\n    function getReservedPercentageUnit(address addr) public view returns (uint inPercentageUnit) {\n        return reservedTokensList[addr].inPercentageUnit;\n    }\n\n    function getReservedPercentageDecimals(address addr) public view returns (uint inPercentageDecimals) {\n        return reservedTokensList[addr].inPercentageDecimals;\n    }\n\n    function getReservedIsVested(address addr) public view returns (bool isVested) {\n        return reservedTokensList[addr].isVested;\n    }\n\n    function setReservedTokensListMultiple(\n        address[] memory addrs, \n        uint[] memory inTokens, \n        uint[] memory inPercentageUnit, \n        uint[] memory inPercentageDecimals,\n        bool[] memory isVested\n        ) public canMint onlyOwner {\n        assert(!reservedTokensDestinationsAreSet);\n        assert(addrs.length == inTokens.length);\n        assert(inTokens.length == inPercentageUnit.length);\n        assert(inPercentageUnit.length == inPercentageDecimals.length);\n        for (uint iterator = 0; iterator < addrs.length; iterator++) {\n            if (addrs[iterator] != address(0)) {\n                setReservedTokensList(\n                    addrs[iterator],\n                    inTokens[iterator],\n                    inPercentageUnit[iterator],\n                    inPercentageDecimals[iterator],\n                    isVested[iterator]\n                    );\n            }\n        }\n        reservedTokensDestinationsAreSet = true;\n\n        emit ReversedTokenListMultipleSet(addrs.length);\n    }\n\n    /**\n    * Create new tokens and allocate them to an address..\n    *\n    * Only callably by a crowdsale contract (mint agent).\n    */\n    function mint(address receiver, uint amount) public onlyMintAgent canMint {\n        require(receiver != address(0), \"Receiver cannot be the Null Address\");\n        totalSupply = totalSupply.plus(amount);\n        balances[receiver] = balances[receiver].plus(amount);\n\n        // This will make the mint transaction apper in EtherScan.io\n        // We can remove this after there is a standardized minting event\n        emit Transfer(address(0), receiver, amount);\n    }\n\n    /**\n    * Owner can allow a crowdsale contract to mint new tokens.\n    */\n    function setMintAgent(address addr, bool state) public onlyOwner canMint {\n        require(addr != address(0), \"Mint Agent Cannot be Null Address\");\n        mintAgents[addr] = state;\n        emit MintingAgentChanged(addr, state);\n    }\n\n    function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals,bool isVested) \n    private canMint onlyOwner {\n        assert(addr != address(0));\n        if (!isAddressReserved(addr)) {\n            reservedTokensDestinations.push(addr);\n            reservedTokensDestinationsLen.plus(1);\n        }\n\n        reservedTokensList[addr] = ReservedTokensData({\n            inTokens: inTokens,\n            inPercentageUnit: inPercentageUnit,\n            inPercentageDecimals: inPercentageDecimals,\n            isReserved: true,\n            isDistributed: false,\n            isVested:isVested\n        });\n    }\n}\n\n// \n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n/**\n * A crowdsaled token.\n *\n * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\n *\n * - The token transfer() is disabled until the crowdsale is over\n * - The token contract gives an opt-in upgrade path to a new contract\n * - The same token can be part of several crowdsales through approve() mechanism\n * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\n *\n */\ncontract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken {\n    using SafeMathLibExt for uint256;\n\n    /** Name and symbol were updated. */\n    event UpdatedTokenInformation(string newName, string newSymbol);\n\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint256 _amount);\n\n    string public name;\n\n    string public symbol;\n\n    uint public decimals;\n\n    /* Minimum ammount of tokens every buyer can buy. */\n    uint256 public minCap;\n\n    /**\n    * Construct the token.\n    *\n    * This token must be created through a team multisig wallet, so that it is owned by that wallet.\n    *\n    * @param _name Token name\n    * @param _symbol Token symbol - should be all caps\n    * @param _initialSupply How many tokens we start with\n    * @param _decimals Number of decimal places\n    * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? \n    * Note that when the token becomes transferable the minting always ends.\n    */\n    constructor(string memory _name, string memory _symbol, uint256 _initialSupply, uint _decimals, bool _mintable, uint256 _globalMinCap) \n     UpgradeableToken(msg.sender) {\n\n        // Create any address, can be transferred\n        // to team multisig via changeOwner(),\n        // also remember to call setUpgradeMaster()\n        owner = msg.sender;\n\n        name = _name;\n        symbol = _symbol;\n\n        totalSupply = _initialSupply;\n\n        decimals = _decimals;\n\n        minCap = _globalMinCap;\n\n        // Create initially all balance on the team multisig\n        balances[owner] = totalSupply;\n\n        if (totalSupply > 0) {\n            emit Minted(owner, totalSupply);\n        }\n\n        // No more new supply allowed after the token creation\n        if (!_mintable) {\n            mintingFinished = true;\n            if (totalSupply == 0) {\n                revert(\"annot create a token without supply and no minting\"); // Cannot create a token without supply and no minting\n            }\n        }\n    }\n\n    /**\n    * When token is released to be transferable, enforce no new tokens can be created.\n    */\n    function releaseTokenTransfer() public virtual override onlyReleaseAgent {\n        mintingFinished = true;\n        super.releaseTokenTransfer();\n    }\n\n    /**\n    * Allow upgrade agent functionality kick in only if the crowdsale was success.\n    */\n    function canUpgrade() public virtual override returns(bool) {\n        return released && super.canUpgrade();\n    }\n\n    /**\n    * Owner can update token information here.\n    *\n    * It is often useful to conceal the actual token association, until\n    * the token operations, like central issuance or reissuance have been completed.\n    *\n    * This function allows the token owner to rename the token after the operations\n    * have been completed and then point the audience to use the token contract.\n    */\n    function setTokenInformation(string memory _name, string memory _symbol) external onlyOwner {\n        name = _name;\n        symbol = _symbol;\n\n        emit UpdatedTokenInformation(name, symbol);\n    }\n\n    /**\n    * Claim tokens that were accidentally sent to this contract.\n    *\n    * @param _token The address of the token contract that you want to recover.\n    */\n    function claimTokens(address _token) external onlyOwner {\n        require(_token != address(0));\n\n        ERC20 token = ERC20(_token);\n        uint256 balance = token.balanceOf(address(this));\n        token.transfer(owner, balance);\n\n        emit ClaimedTokens(_token, owner, balance);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public virtual override(StandardToken,ReleasableToken) returns (bool success) {\n        uint256 _allowance = allowed[_from][msg.sender];\n\n        balances[_to] = balances[_to].plus(_value);\n        balances[_from] = balances[_from].minus(_value);\n        allowed[_from][msg.sender] = _allowance.minus(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function transfer(address _to, uint256 _value) public virtual override(StandardToken,ReleasableToken) canTransfer(msg.sender) returns (bool success) {\n        // Call StandardToken.transfer()\n        return super.transfer(_to, _value);\n    }\n\n}\n\n// \n/**\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n *\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n */\n/**\n * A crowdsaled token.\n *\n * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\n *\n * - The token transfer() is disabled until the crowdsale is over\n * - The token contract gives an opt-in upgrade path to a new contract\n * - The same token can be part of several crowdsales through approve() mechanism\n * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\n *\n */\ncontract CrowdsaleTokenExtv1 is CrowdsaleTokenExt {\n    using SafeMathLibExt for uint256;\n\n    uint256 public originalSupply;\n\n    address public oldTokenAddress;\n\n    bool public isUpgradeAgent = false;\n    /**\n    * Construct the token.\n    *\n    * This token must be created through a team multisig wallet, so that it is owned by that wallet.\n    *\n    * @param _name Token name\n    * @param _symbol Token symbol - should be all caps\n    * @param _initialSupply How many tokens we start with\n    * @param _decimals Number of decimal places\n    * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? \n    * Note that when the token becomes transferable the minting always ends.\n    */\n    constructor(string memory _name, string memory _symbol, uint256 _initialSupply, uint256 _decimals, bool _mintable, \n    uint256 _globalMinCap, address _oldTokenAddress, uint256 _originalSupply) \n     CrowdsaleTokenExt(_name, _symbol, _initialSupply, _decimals, _mintable, _globalMinCap) {    \n        originalSupply = _originalSupply;\n        oldTokenAddress = _oldTokenAddress;\n        isUpgradeAgent = true;    \n    }\n\n    function upgradeFrom(address _from, uint256 value) public {\n        // Make sure the call is from old token contract\n        require(msg.sender == oldTokenAddress);\n        // Validate input value.\n        balances[_from] = balances[_from].plus(value);\n        // Take tokens out from circulation\n        totalSupply = totalSupply.plus(value);\n    }\n\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_initialSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_mintable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_globalMinCap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_oldTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_originalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"FinalizedReversedAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"MintingAgentChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"ReleaseAgentSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"ReversedTokenListMultipleSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"callet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"agent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"set\",\"type\":\"bool\"}],\"name\":\"TransferAgentSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newSymbol\",\"type\":\"string\"}],\"name\":\"UpdatedTokenInformation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"UpgradeAgentSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"UpgradeMasterSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"areTokensDistributedForAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isDistributed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canUpgrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"finalizeReservedAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getReservedIsVested\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isVested\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getReservedPercentageDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"inPercentageDecimals\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getReservedPercentageUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"inPercentageUnit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getReservedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"inTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUpgradeState\",\"outputs\":[{\"internalType\":\"enum UpgradeableToken.UpgradeState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isAddressReserved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isReserved\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"weAre\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isUpgradeAgent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mintAgents\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"originalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseAgent\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseTokenTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"released\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reservedTokensDestinations\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reservedTokensDestinationsLen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"reservedTokensList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"inTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inPercentageUnit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inPercentageDecimals\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isReserved\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isDistributed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isVested\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setMintAgent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setReleaseAgent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"inTokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"inPercentageUnit\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"inPercentageDecimals\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"isVested\",\"type\":\"bool[]\"}],\"name\":\"setReservedTokensListMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setTokenInformation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setTransferAgent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"setUpgradeAgent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"master\",\"type\":\"address\"}],\"name\":\"setUpgradeMaster\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUpgraded\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"transferAgents\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeAgent\",\"outputs\":[{\"internalType\":\"contract UpgradeAgent\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"upgradeFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradeMaster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CrowdsaleTokenExtv1", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000daf7ffd530c2b4ee36f9b862b58fe8a12196566500000000000000000000000000000000000000000000065a4da25d3016c000000000000000000000000000000000000000000000000000000000000000000004557469780000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000035554580000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "SafeMathLibExt:3aafd7dcba30a40ca9a1ddaf9af4bb5ac529fac1", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}