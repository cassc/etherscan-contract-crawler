{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/FloridaManFlip.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\n/*\\nIN DUANE WE TRUST\\n\\nhttps://t.me/fmantoken\\nhttps://www.floridamantoken.com\\nhttps://x.com/floridamantoken\\n\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWNNNNNNNNNNNNNNNNWWWWWWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNNXKKKK0000OOOOOOOOOOOOOO0000KKKKXXXNNWWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXXK00OOOkxxdddoolllccccccccccccclllooddxkkO00KKXXNWWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXK00Okkxddolc::;;;:::ccccccccllccccclcc::::;;::cloddkOO00KXNWWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXK0Okkxdolc:;;:cccllloodollllooloddoollodxoodxdolcccc::;:clodxkO0KXNWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNK0Okxxdlc:;;clllodxkdooolodoccolcccllllllcclolldxdooooodxxdocc:;;:loxkO0KXNWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNKOkxxdoc;;:ccloxxxoodxxxl::;coooodc,',::ccoxxxxdddxxoodxxdxkxdoddxdlc:;;:ldxOO0XNWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNKOkxxol:;:clldxxoloodolool;'',:clollc;..''''',:oxkkkxdkkxddddddoclddxxodxllc:;;coxOO0XNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMWXOkxxdl:;:cclooodxkxooooll:,,,,,;ldxkxxd;........';cokOkoldkOkxolldoloddodxddoooolc;;cdkOOKXWMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMWKkxxdl:;;codddollodxxxolool;'.';lodxkkxxdddc'.......',:okOkdodxxkOkdoooolloxddoooodxxol:;:ldkO0XWMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMN0kxxoc;;:cloddxxxdoloooddodo;....;ldddddoollcc:.....'''',:okkdocloxxddddoodoolollooddddoollc;,:okOOKNMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMW0xddo:,;coddlllooddddooodxxxo;.....,cloddoolccc:;'.'''',;ccclxkoloccdxlccododxkkxddoododddxdoodl:,:oxkOKNMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMW0xddo:,;:codddoccllllldxkxxxxo,''....,;:loool::cll:'';,,',',lllodol::cool:;:looodkkkkxddlldxxdooxdol:,;lxkOKWMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMWXkddo:,;loollloddlldxdxxkkkkkxc,'''....',;lll::clllcc:';c:,';,;oollllc;:ol:;;;;:ccldxkkkkkxoooooodddoooo:,:oxkOXWMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMNOdddc,;clloddoclooloxkkkkkkkkd:''',:'.....':cc::cododxkc'.,l;.;;cdoc:clccllc;;:cccccloxkkkkkkkxxdddoodxxdoc;,:dkkONMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMKxddl;,:odlccccclccodkkkkkkkkkd;...';'.......';cl::looxkkl,'':l,':col;;::clollol:clc::cloxkkkkkkkkxoloxxddocclc;,cxkkKWMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMW0ddo:,,:loddocccllldxxkkkkkkkkx:....''..........,;:::ldxkkl,,;:c:',cooc;cc;;oxddxddddoloddooxkkkOOkkkxdlllllclloo:,;okxONMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMNkodl;,;:cccloolccoddxxxxkkkkkkkd,.................';;;oxxkxc,;coc:,.;odl;:lc,,:lodxkkOkoccc:;:ldkOOOkkkkdollllloddoc,,lxxkXMMMMMMMMMMMMM\\nMMMMMMMMMMMMXxodc,;clccc::ccccoddxxxxxkkkkkkkd,......';,'........;,;dxxkx;,:ldl:;'':lc:::c::;,,;:c::;;::;,'',lxkkOkkkkkkdloxxddlllc;,:dxxKWMMMMMMMMMMM\\nMMMMMMMMMMMXdodc,;cooolccccclodddxxxxxxxkkkkkd;......,,,.........''cxxkkd;''cxxl;,'',;::;::::clcc:;;:c:;,...':lxkkkkkkkxxdollllooddl;,:dxxKWMMMMMMMMMM\\nMMMMMMMMMMXdoo:,;:clooooollloddddddxdddxxxxxxo,......','.........,lxkk0kl::;;cxko;,'''',:cllcclc:::::::;'....,lxkkkkkkxxxxxocoddddocc;';oxx0WMMMMMMMMM\\nMMMMMMMMMXdoo:,;::::clllooooooodddddddxxxxxxxc...........''''..':oxkO00kc:oxdlldkxl;,;,',cloooolccc;;:;;,'...,okkkkkkkxxxxxxdolllllooo:';oxdKMMMMMMMMM\\nMMMMMMMMXdlo:,;clcccc:ccloooooodddddddddxxxxx:...........,:::;;:codxkO0xlcodxxl:cooc;:clccc:::;,'''';:;;;;;,,:dkkkkkkxxxxxxxxdlcodxxdol;';dddKMMMMMMMM\\nMMMMMMMNxloc,;:;:::clc:clloooodddddddddddxxxxl...........;clcc:;;::;;:lc::cc:;,,'...';clool:,,'...',,'',;:cc;;oxkkkkxxxxxxxxddddodddoc::;':ddxXMMMMMMM\\nMMMMMMWOloc,,:clccccccclllooooooodddodddddxxxd;....''....'''.....';;,';oddl:;...    .;:clllllcc:,.,;,'',;::c:,cxxkkxxxxxdddddddocccccccll,'cdokNMMMMMM\\nMMMMMMKlll;,;::looolcclllllllooooooooddddddxxd;...''........     .,::,':ddc:'.       ....'',,,c:.';;:ll:,'''..;lddddddddddddddddoccoooool:',ldo0MMMMMM\\nMMMMMNxcl:,;:::::ccccllllllloodddodddddoddxddl'......'....        ....';kd;''...    ........ .....:c:colllc;,;::llllooddddddddddddollc:cc:;';dodXMMMMM\\nMMMMM0llc,;:ccccc::::ccloooooddxxxxxxxdooodddc.......'. ..     ........;kk:'''...   ..........','..,:lllccc:::;;:::cloddddddddddddc;;:::clc,'cdoOWMMMM\\nMMMMNdcl:,:cclllc:::::ccooddddxxddddddooodddd:.........................;kkl;,'...............'::,.....,;::cc::;,,;:cooooooddddddoooc::ccooo:';oodXMMMM\\nMMMM0lcc;;cccclllcccccloodoooooollllllooddddo;.........................;xkoll:,'............,ldc,.......'',;,,'.,:looooooooodooooddddddooooc,,ldlOMMMM\\nMMMWk:c:,:c:,:lc:ccccloooolccccclllllloooddo:........................ .;xkdooolcc:;'''',,:coxkd:'.......',;;;,'':ooollllooooooooodddoolcclc:,':olxNMMM\\nMMMNo:c;,:cc;,;;::::::cccccccllllllooooooodc........... ..'''''',,;,...:xOxodkOxllodddxkO00Okoc,''...:c,''..''..;lollloooooooooooooooc::::,;;',oooKMMM\\nMMMKc:c;;:clccccccccccc::cclooooollodddddddl...........  .':loooool'. .':cc:;;::;,,lkO00Okkdc;;::;..':cc:'......'clodddooooooolooooool;,;;:c:''lol0MMM\\nMMM0:::;;:::cloooooooolllllloooooooodddxxxdd:...........  ..;loodol,.......',,,:dxl;:dkkxxo:;coooc,'okxo;......,coooddooooooollloooooolllcllc,'cockWMM\\nMMMO;::;;,,,;clcllllollooooooooodoooddxxxxxxdl;.........    .':lol:;,,',;'...',;:coolcoxxxc;ldxxdl,.:oc,..''..;looooooooooooollloooooollclllc,':ocxWMM\\nMMMk;::;;,'';::;:::clllooooodddddddddddxxxxxxxdo:'.. ....    .,c:,.....;oo,'......',:ccodo:cxxxxdc','.....'',cooooooooooddolccloooooolcc:ccc:,.;ocdNMM\\nMMMk;;;;;;;,'',;:::clloooodddddddddddddxxxxxxxxxdl:,.....    .','......,;;;;;;,.......,:c::oxxxdo;,c;.....',:lolllllooooddol::looooooc::::;,,'.;lcdNMM\\nMMMk;;;;;;;;;;;:::cclloooodddddoddddddxxxxxxxxxxxdoooc;...    ......',:clllodxxxdolc:'..,,cdxxddl,:o,..',,;:cclllcllooooddlc;;coooollc;,,,,,;'.:lcdNMM\\nMMMO;,;;;;;:::::::;;;;:cllooooollloodddxddddxxxxxxddoo:....     .','',:clllllldxkkOOOxl:,;ldddol;;dd'..,::;;,,;;:llloooollc:;;clllllccc:::::;'':lcxWMM\\nMMMK:,;;;,,,;;;;;;;:::;::::::llllcclddollclloodddxddl:,....     .c:....'....',:oxkkOkkdc:ldddol:;dkl...',;''....,cllllllcllcc:cccccccccc::::;''clckWMM\\nMMMXl';;;,'''''''',,;;;:looollool::ccloooooooooooddddol;....     .,'..','....,oxkOOOOkxooddolc;:dOx:...'..'''...:ooollllllllllcccccccccc::::;',ccc0MMM\\nMMMWd,,;;,........'',,,,;clodxxxxddddxxxxxxxxxxxxdddoc;'.....     ..',;cllllldkO0000Okdlllc;,;lkOkdc...''......,lolc:::ccccc:::cc::::::::;;;,.;c:lXMMM\\nMMMMO;',;;'.........'',,'',,:clodxxdooxxxxxxxxxxddool;........     ..';coxxxdoxOOOOkxo:;,'.':dkOkxdc..........'clcc::::::;;;;;;::;;;;,;,,,;,'':c:xNMMM\\nMMMMXl',;;,............''''''',,;:cllc:codxdddoollllc;'.......       .';coxxo:coddolc,....;oxkkkxdd:'..''.....;cccccccccc::::::::;;;;,,,,,;,.,c:c0MMMM\\nMMMMWk,',;;...................'''''',;,'';::::ccllllc:'.......        ...',,,'..''......;ldxxkkxxdo:,,'.....';cc::::::::::;;;;;;;;,,,,,,,,,'';c;oNMMMM\\nMMMMMXl'';:,..........'''''''''''''''''',,,,,,,;;:::c:... ....  ..                ...,;ldxxxxkxxxdoc:;'....',;;:;;:cc::::::::;;;:::;;;;;;;,',:;:OWMMMM\\nMMMMMWO;',;:;;;;;;:::::::::::cccccccccccllllllllllollc'....,,..  ...    ...''',;:ccloodxxxxxxxxxdxo:lo;.   ...',,,cllccccccc:::::::::;;;,,'';:;dNMMMMM\\nMMMMMMNd'',:;,,,,,,,,;;;;;;;;;;;;;::::::::::::cc::::::,.'...,'.  ..'.  ..,:cllloodddddddddxxxxxxxxoclxdc..   . ..';;;;::::;;;,,,,,,,,,,'''',:;cKMMMMMM\\nMMMMMMMKc.',:,''''..''''''''',,,,,,,,;;;;;;;;;;;;;;;::;,''.....   .''.  ..,;:clooodddddddddxxxxxxxdcldxdc,..'....',;;::;;,,'',,;;;;,,'....,;,:OWMMMMMM\\nMMMMMMMW0:.',;'..'''''''',,,,,'''''''',,,,,,,;;;;:;;,,,,,,''...   .','. ..'',;clloooodoodddddddddddllolccol;:oc;'..'''''.................,;,;xNMMMMMMM\\nMMMMMMMMWk;.';;'.'''..'',,,,,,;;;;;;;;,,,,,;;;::;;;;,,,,,;;;;,'.   .,,....''',;:cllodooooodddoodddolcc:looc:lllclc;,'...'',,,,,,,,,''...';,,dNMMMMMMMM\\nMMMMMMMMMNk,.';:;'''..''''.......''',,,,,,;;;,,,,'..'',,;;;;,,'..  .';,....'',,;:loddoolloooolooolc:::lc:;:llc:cclllc:;,....'.........',,,,dXMMMMMMMMM\\nMMMMMMMMMMNk;.';:,..........'',;:cc::;;;;,,,,;;:::::;;;,,,,''....  ..;;,......',:clollllllccccccc;;;;::;;:llcc:cllcclllc:;,'....''....',,,dXMMMMMMMMMM\\nMMMMMMMMMMMNk;..,;,........''',,''..........',;:::;;,,,,;,''.. ..   .,:;,.....'',::ccccccc:;;::;,,,',,;;:cccc:cllllodddooolc:;;,,,''',,,,dXMMMMMMMMMMM\\nMMMMMMMMMMMMWO:..,;,...........................''''',;;;;'.... ..    .;:;,'''''',,;;;::::;,,,,,,,'',,,;:lc::::lollooddxxxxxololc,..',,';xNMMMMMMMMMMMM\\nMMMMMMMMMMMMMW0l'.';:,....................''',,,,,;::,,,..'... ...   .,cc;,''''''''';:::;,,,;,,,'',;,,:cc::::lllcccclooodooddo:;,,,,,':ONMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMWXd,..,:;'..............'',,,;;;,,,;::,.''.';c;. .'..   .coc,''......';cc;,,,;,,,',,;;;;::::::clol::ccccccccc:,...',,',oKWMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMNOc..';:,............',,,;;;,,'.'''...'.'cxkdc'''.    .:do:,'......,cc;,;:;;,'';::;;::;;;::::lolc:::::::;;'..',,''':xXMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMWKd;..';;..  .......''',;;'............';dxxdc;::'.   'ldoc;.....':c::clc;,;::c:;;:::,,;;::;cl:::;;::::,..',,''',o0WMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMN0l'..,::,.......''..........'.........,:cc;,codo:'..:dol:'...':oddol:::ccc:;;::;:;,'',;;;:::::::,,;,..,,,'''ckNMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMWNkc'..,::,..........',,,''.............''.';;:looolclooc'..';:clc;;;ccc:;,,;;,;;;,,;,'';:c:;,;;'''.',,''':xXWMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMWXkc'..,;:,.......',''....................,'',,;cooolc,...'',,,',;;;;;,,,;;,,;;,''cl:'..';;,,,,,,,,''':xKWMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMWXkc,..';;,.....','..............'.... .''.'',:odo;...',,,,'''',,;;,',;;,,;;,,..;lcc;'...',;,,''',cxKWMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMWXOo;...',,,...'...............';;'. ..'..'';co:'.'',,'''...',,,,,;;;;,;:,,'...;:;;,..',,,'.';lOXWMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNKxc,...,,,,,................':c:'..'..'',;:;,,,,''......','',,;:;',;,'''...',,;;,,,'.',cx0NWMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWX0d:'...,;;;,'.....'. .....'';;,',;,''''''''......'...''.';,,;,,,''',,'..,;;,,'.',:dOXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWX0dc,....,;;;,,,,'.......''........................'...,'',''',',;::;,,'..',cdOXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWN0xl;'....,,;::;,,,'...',...........'''.............''.',;;:;;,,'..',:lx0XWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWNX0xl:,'....',;;;;;;;:;;;,,''........'''''',,;;,,;;;;,,'....',:lx0XNWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWXKOxl:;'......',,;;;;;;;;;;;;;;;;;;;;;;;;,,'.....',;:ldOKXNWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNK0kxoc:;,'.........................'',;:codk0KNWWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWNXXK0OkxdollccccccccccclloodxkO0KXXNWWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWWWNNNNNNNNNNNNWWWWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM                            \\n*/\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"v2-periphery/interfaces/IUniswapV2Router02.sol\\\";\\nimport \\\"openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"openzeppelin-contracts/contracts/utils/Counters.sol\\\";\\nimport \\\"openzeppelin-contracts/contracts/access/Ownable.sol\\\";\\nimport \\\"openzeppelin-contracts/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"chainlink-brownie-contracts/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\\\";\\nimport \\\"chainlink-brownie-contracts/contracts/src/v0.8/VRFConsumerBaseV2.sol\\\";\\nimport \\\"./IFloridaManCard.sol\\\";\\n\\ncontract FloridaManFlip is VRFConsumerBaseV2, Ownable {\\n    using Counters for Counters.Counter;\\n    using SafeMath for uint256;\\n\\n    Counters.Counter public gameId;\\n\\n    struct Game {\\n        uint256 id;\\n        uint256 cardId;\\n        uint256 bet;\\n        bool exists;\\n        bool finished;\\n        bool heads;\\n        bool fman;\\n        address payable player;\\n        address payable winner;\\n        uint256[] randomWords;\\n    }\\n\\n    uint256 public minimumETHBetUSD = 20;\\n    uint256 public maximumETHBetUSD = 100;\\n    uint256 public minimumFMANBetUSD = 20;\\n    uint256 public maximumFMANBetUSD = 100;\\n\\n    mapping(uint256 => Game) public gameMapping;\\n    mapping(uint256 => uint256) public requestIdToGameId;\\n\\n    VRFCoordinatorV2Interface _vrfCoordinator;\\n    uint64 private _vrfSubscriptionId;\\n    bytes32 private _vrfKeyHash;\\n    uint32 private _vrfGasLimit = 200000;\\n    uint16 private _vrfRequestConfirmations = 3;\\n\\n    uint16 private _maxWinPercentage = 35;\\n    uint16 private _maxWinDropPercentage = 45;\\n\\n    address payable private _developerAddress;\\n    address private _cardAddress = 0x4fA9616AbBbFaf2EC503ade5FA3622b3604e5232;\\n    address private _tokenAddress = 0xD56990D60A7Abf3a7945F0565A98A708234b802C;\\n    address private _wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address private _usdcAddress = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n    address private _routerAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n\\n    event GameStarted(address indexed creator, uint256 indexed gameId, uint256 requestId);\\n    event GameFinished(uint256 indexed gameId, address indexed winner, uint256 result);\\n    event RandomnessFulfilled(uint256 requestId, uint256[] randomWords);\\n    event MinimumBetChanged(uint256 newBet, address changedBy);\\n    event MaximumBetChanged(uint256 newBet, address changedBy);\\n\\n    constructor(address __developerAddress, address _coordinator, bytes32 _keyHash, uint64 _subscriptionId)\\n        VRFConsumerBaseV2(_coordinator)\\n    {\\n        _developerAddress = payable(__developerAddress);\\n        _vrfCoordinator = VRFCoordinatorV2Interface(_coordinator);\\n        _vrfKeyHash = _keyHash;\\n        _vrfSubscriptionId = _subscriptionId;\\n    }\\n\\n    // //////////////////////////////////////////\\n    // PUBLIC\\n    // //////////////////////////////////////////\\n    function getMinimumETHBet() public view returns (uint256) {\\n        return _getETHFromUSD(minimumETHBetUSD);\\n    }\\n\\n    function getMinimumFMANBet() public view returns (uint256) {\\n        return _getFMANFromUSD(minimumETHBetUSD);\\n    }\\n\\n    function getMaximumETHBet() public view returns (uint256) {\\n        return _getETHFromUSD(maximumETHBetUSD);\\n    }\\n\\n    function getMaximumFMANBet() public view returns (uint256) {\\n        return _getFMANFromUSD(maximumFMANBetUSD);\\n    }\\n\\n    function play(uint256 _cardId, bool _heads) external payable returns (uint256) {\\n        require(msg.value <= address(this).balance, \\\"Bet must less than contract balance\\\");\\n\\n        uint256 minBet = getMinimumETHBet();\\n        require(msg.value >= minBet, \\\"Bet must be more than minimum\\\");\\n        uint256 maxBet = getMaximumETHBet();\\n        require(msg.value <= maxBet, \\\"Bet must be less than maximum\\\");\\n\\n        require(IERC1155(_cardAddress).balanceOf(msg.sender, _cardId) > 0, \\\"Must own at least 1 card\\\");\\n        IFloridaManCard(_cardAddress).safeTransferFrom(msg.sender, address(this), _cardId, 1, \\\"\\\");\\n\\n        return _play(_cardId, _heads, msg.value, false);\\n    }\\n\\n    function playFMAN(uint256 _cardId, bool _heads, uint256 _bet) external payable returns (uint256) {\\n        require(_bet <= IERC20(_tokenAddress).balanceOf(address(this)), \\\"Bet must less than contract FMAN balance\\\");\\n\\n        uint256 minBet = getMinimumFMANBet();\\n        require(_bet >= minBet, \\\"Bet must be more than minimum\\\");\\n        uint256 maxBet = getMaximumFMANBet();\\n        require(_bet <= maxBet, \\\"Bet must be less than maximum\\\");\\n\\n        require(IERC20(_tokenAddress).balanceOf(_msgSender()) >= _bet, \\\"Bet is greater than FMAN balance\\\");\\n        require(IERC20(_tokenAddress).transferFrom(_msgSender(), address(this), _bet), \\\"Failed to transfer FMAN\\\");\\n\\n        require(IERC1155(_cardAddress).balanceOf(msg.sender, _cardId) > 0, \\\"Must own at least 1 card\\\");\\n        IFloridaManCard(_cardAddress).safeTransferFrom(msg.sender, address(this), _cardId, 1, \\\"\\\");\\n\\n        return _play(_cardId, _heads, _bet, true);\\n    }\\n\\n    function getGame(uint256 _id) external view returns (Game memory) {\\n        return gameMapping[_id];\\n    }\\n\\n    function isGamePending(uint256 _id) external view returns (bool) {\\n        return gameMapping[_id].exists && !gameMapping[_id].finished;\\n    }\\n\\n    function isGameComplete(uint256 _id) external view returns (bool) {\\n        return gameMapping[_id].exists && gameMapping[_id].finished;\\n    }\\n\\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory)\\n        public\\n        virtual\\n        returns (bytes4)\\n    {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n\\n    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n\\n    // //////////////////////////////////////////\\n    // VRF\\n    // //////////////////////////////////////////\\n    function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal override {\\n        emit RandomnessFulfilled(_requestId, _randomWords);\\n\\n        uint256 _gameId = requestIdToGameId[_requestId];\\n\\n        require(gameMapping[_gameId].exists, \\\"Game does not exist\\\");\\n        require(!gameMapping[_gameId].finished, \\\"Game is not in the right state\\\");\\n\\n        bool isCardDroppable = IFloridaManCard(_cardAddress).isMintDroppable(gameMapping[_gameId].cardId);\\n\\n        uint256 seed = (_randomWords[0] % 100) + 1;\\n        uint256 maxWinPercentage = _maxWinPercentage;\\n\\n        if (isCardDroppable) {\\n            maxWinPercentage = _maxWinDropPercentage;\\n        }\\n\\n        if (seed <= maxWinPercentage) {\\n            gameMapping[_gameId].winner = gameMapping[_gameId].player;\\n\\n            if (gameMapping[_gameId].fman) {\\n                require(\\n                    IERC20(_tokenAddress).transfer(gameMapping[_gameId].player, gameMapping[_gameId].bet * 2),\\n                    \\\"Failed to transfer winnings\\\"\\n                );\\n            } else {\\n                payable(gameMapping[_gameId].player).transfer(gameMapping[_gameId].bet * 2);\\n            }\\n        } else {\\n            gameMapping[_gameId].winner = payable(address(this));\\n        }\\n\\n        gameMapping[_gameId].randomWords = _randomWords;\\n        gameMapping[_gameId].finished = true;\\n\\n        emit GameFinished(_gameId, gameMapping[_gameId].winner, seed);\\n    }\\n\\n    // //////////////////////////////////////////\\n    // OWNER\\n    // //////////////////////////////////////////\\n    function changeKeyHash(bytes32 _newHash) external onlyOwner {\\n        _vrfKeyHash = _newHash;\\n    }\\n\\n    function changeMinimumFMANBet(uint256 _usd) external onlyOwner {\\n        minimumFMANBetUSD = _usd;\\n\\n        emit MinimumBetChanged(_usd, msg.sender);\\n    }\\n\\n    function changeMinimumETHBet(uint256 _usd) external onlyOwner {\\n        minimumETHBetUSD = _usd;\\n\\n        emit MinimumBetChanged(_usd, msg.sender);\\n    }\\n\\n    function changeMaximumFMANBet(uint256 _usd) external onlyOwner {\\n        maximumFMANBetUSD = _usd;\\n\\n        emit MaximumBetChanged(_usd, msg.sender);\\n    }\\n\\n    function changeMaximumETHBet(uint256 _usd) external onlyOwner {\\n        maximumETHBetUSD = _usd;\\n\\n        emit MaximumBetChanged(_usd, msg.sender);\\n    }\\n\\n    function withdrawCards() external onlyOwner {\\n        uint256[] memory ids = IFloridaManCard(_cardAddress).getCardIds();\\n        uint256[] memory quantities = new uint256[](ids.length);\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            quantities[i] = IFloridaManCard(_cardAddress).balanceOf(address(this), ids[i]);\\n        }\\n\\n        IERC1155(_cardAddress).safeBatchTransferFrom(address(this), owner(), ids, quantities, \\\"\\\");\\n    }\\n\\n    function withdrawETH() external onlyOwner {\\n        uint256 balance = address(this).balance;\\n\\n        uint256 developerBalance = balance.mul(1000).div(10000);\\n        uint256 ownerBalance = balance.sub(developerBalance);\\n\\n        payable(_developerAddress).transfer(developerBalance);\\n        payable(owner()).transfer(ownerBalance);\\n    }\\n\\n    function withdrawFMAN() external onlyOwner {\\n        IERC20(_tokenAddress).transfer(msg.sender, IERC20(_tokenAddress).balanceOf(address(this)));\\n    }\\n\\n    // //////////////////////////////////////////\\n    // PRIVATE\\n    // //////////////////////////////////////////\\n    function _play(uint256 _cardId, bool _heads, uint256 _bet, bool _fman) private returns (uint256) {\\n        uint256 _id = gameId.current();\\n        gameId.increment();\\n        Game memory _game = Game({\\n            id: _id,\\n            cardId: _cardId,\\n            player: payable(msg.sender),\\n            bet: _bet,\\n            heads: _heads,\\n            fman: _fman,\\n            finished: false,\\n            winner: payable(address(0)),\\n            randomWords: new uint256[](0),\\n            exists: true\\n        });\\n        gameMapping[_id] = _game;\\n\\n        uint256 requestId = _vrfCoordinator.requestRandomWords(\\n            _vrfKeyHash, _vrfSubscriptionId, _vrfRequestConfirmations, _vrfGasLimit, 1\\n        );\\n        requestIdToGameId[requestId] = _id;\\n\\n        emit GameStarted(msg.sender, _id, requestId);\\n\\n        return _id;\\n    }\\n\\n    function _getETHFromUSD(uint256 _usd) internal view returns (uint256 amount) {\\n        address[] memory path = new address[](2);\\n        path[0] = _usdcAddress;\\n        path[1] = _wethAddress;\\n\\n        uint256[] memory amounts = IUniswapV2Router02(_routerAddress).getAmountsOut(_usd * (10 ** 6), path);\\n\\n        return amounts[1];\\n    }\\n\\n    function _getFMANFromUSD(uint256 _usd) internal view returns (uint256 amount) {\\n        address[] memory path = new address[](3);\\n        path[0] = _usdcAddress;\\n        path[1] = _wethAddress;\\n        path[2] = _tokenAddress;\\n\\n        uint256[] memory amounts = IUniswapV2Router02(_routerAddress).getAmountsOut(_usd * (10 ** 6), path);\\n\\n        return amounts[2];\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/chainlink-brownie-contracts/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFCoordinatorV2Interface {\\n  /**\\n   * @notice Get configuration relevant for making requests\\n   * @return minimumRequestConfirmations global min for request confirmations\\n   * @return maxGasLimit global max for request gas limit\\n   * @return s_provingKeyHashes list of registered key hashes\\n   */\\n  function getRequestConfig()\\n    external\\n    view\\n    returns (\\n      uint16,\\n      uint32,\\n      bytes32[] memory\\n    );\\n\\n  /**\\n   * @notice Request a set of random words.\\n   * @param keyHash - Corresponds to a particular oracle job which uses\\n   * that key for generating the VRF proof. Different keyHash's have different gas price\\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\\n   * @param subId  - The ID of the VRF subscription. Must be funded\\n   * with the minimum subscription balance required for the selected keyHash.\\n   * @param minimumRequestConfirmations - How many blocks you'd like the\\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\n   * for why you may want to request more. The acceptable range is\\n   * [minimumRequestBlockConfirmations, 200].\\n   * @param callbackGasLimit - How much gas you'd like to receive in your\\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n   * may be slightly less than this amount because of gas used calling the function\\n   * (argument decoding etc.), so you may need to request slightly more than you expect\\n   * to have inside fulfillRandomWords. The acceptable range is\\n   * [0, maxGasLimit]\\n   * @param numWords - The number of uint256 random values you'd like to receive\\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n   * @return requestId - A unique identifier of the request. Can be used to match\\n   * a request to a response in fulfillRandomWords.\\n   */\\n  function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256 requestId);\\n\\n  /**\\n   * @notice Create a VRF subscription.\\n   * @return subId - A unique subscription id.\\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n   * @dev Note to fund the subscription, use transferAndCall. For example\\n   * @dev  LINKTOKEN.transferAndCall(\\n   * @dev    address(COORDINATOR),\\n   * @dev    amount,\\n   * @dev    abi.encode(subId));\\n   */\\n  function createSubscription() external returns (uint64 subId);\\n\\n  /**\\n   * @notice Get a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @return balance - LINK balance of the subscription in juels.\\n   * @return reqCount - number of requests for this subscription, determines fee tier.\\n   * @return owner - owner of the subscription.\\n   * @return consumers - list of consumer address which are able to use this subscription.\\n   */\\n  function getSubscription(uint64 subId)\\n    external\\n    view\\n    returns (\\n      uint96 balance,\\n      uint64 reqCount,\\n      address owner,\\n      address[] memory consumers\\n    );\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @param newOwner - proposed new owner of the subscription\\n   */\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @dev will revert if original owner of subId has\\n   * not requested that msg.sender become the new owner.\\n   */\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\n\\n  /**\\n   * @notice Add a consumer to a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - New consumer which can use the subscription\\n   */\\n  function addConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Remove a consumer from a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - Consumer to remove from the subscription\\n   */\\n  function removeConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Cancel a subscription\\n   * @param subId - ID of the subscription\\n   * @param to - Where to send the remaining LINK to\\n   */\\n  function cancelSubscription(uint64 subId, address to) external;\\n\\n  /*\\n   * @notice Check to see if there exists a request commitment consumers\\n   * for all consumers and keyhashes for a given sub.\\n   * @param subId - ID of the subscription\\n   * @return true if there exists at least one unfulfilled request for the subscription, false\\n   * otherwise.\\n   */\\n  function pendingRequestExists(uint64 subId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/chainlink-brownie-contracts/contracts/src/v0.8/VRFConsumerBaseV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\\n * @dev 1. The fulfillment came from the VRFCoordinator\\n * @dev 2. The consumer contract implements fulfillRandomWords.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash). Create subscription, fund it\\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\\n * @dev subscription management functions).\\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\\n * @dev callbackGasLimit, numWords),\\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomWords method.\\n *\\n * @dev The randomness argument to fulfillRandomWords is a set of random words\\n * @dev generated from your requestId and the blockHash of the request.\\n *\\n * @dev If your contract could have concurrent requests open, you can use the\\n * @dev requestId returned from requestRandomWords to track which response is associated\\n * @dev with which randomness request.\\n * @dev See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ.\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request. It is for this reason that\\n * @dev that you can signal to an oracle you'd like them to wait longer before\\n * @dev responding to the request (however this is not enforced in the contract\\n * @dev and so remains effective only in the case of unmodified oracle software).\\n */\\nabstract contract VRFConsumerBaseV2 {\\n  error OnlyCoordinatorCanFulfill(address have, address want);\\n  address private immutable vrfCoordinator;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   */\\n  constructor(address _vrfCoordinator) {\\n    vrfCoordinator = _vrfCoordinator;\\n  }\\n\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomWords the VRF output expanded to the requested number of words\\n   */\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\\n    if (msg.sender != vrfCoordinator) {\\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\\n    }\\n    fulfillRandomWords(requestId, randomWords);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/IFloridaManCard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\nimport \\\"openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\npragma solidity ^0.8.19;\\n\\ninterface IFloridaManCard is IERC1155 {\\n    function mintMysteryPack(address _to, uint256 _seasonId, uint256 _quantity)\\n        external\\n        returns (uint256[] memory minted);\\n\\n    function withdrawFMAN() external;\\n\\n    function transfer(address _to, uint256 _id, uint256 _quantity) external;\\n    function mintBatch(address _to, uint256[] memory _ids, uint256[] memory _amounts) external;\\n\\n    function isCardValid(uint256 _id) external view returns (bool);\\n    function isSeasonValid(uint256 _id) external view returns (bool);\\n\\n    function isMintDroppable(uint256 _id) external view returns (bool);\\n\\n    function getSeasonCards(uint256 _id) external view returns (uint256[] memory seasonCardIds);\\n    function getSeasonIds() external view returns (uint256[] memory allSeasonIds);\\n    function getCardIds() external view returns (uint256[] memory allCardIds);\\n\\n    function getCard(uint256 _id)\\n        external\\n        view\\n        returns (\\n            uint256 id,\\n            uint256 level,\\n            uint256 usdPrice,\\n            uint256 totalSupply,\\n            uint256 maxOwnable,\\n            uint256 availableAmount,\\n            uint256 ownedAmount\\n        );\\n}\\n\"\r\n    },\r\n    \"lib/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"chainlink-brownie-contracts/=lib/chainlink-brownie-contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"v2-core/=lib/v2-core/contracts/\",\r\n      \"v2-periphery/=lib/v2-periphery/contracts/\",\r\n      \"lib/forge-std:ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/openzeppelin-contracts:ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/openzeppelin-contracts:erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"lib/openzeppelin-contracts:forge-std/=lib/openzeppelin-contracts/lib/forge-std/src/\",\r\n      \"lib/openzeppelin-contracts:openzeppelin/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"__developerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_coordinator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_keyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_subscriptionId\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"have\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"}],\"name\":\"OnlyCoordinatorCanFulfill\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"name\":\"GameFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"GameStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBet\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"changedBy\",\"type\":\"address\"}],\"name\":\"MaximumBetChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBet\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"changedBy\",\"type\":\"address\"}],\"name\":\"MinimumBetChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"RandomnessFulfilled\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_newHash\",\"type\":\"bytes32\"}],\"name\":\"changeKeyHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_usd\",\"type\":\"uint256\"}],\"name\":\"changeMaximumETHBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_usd\",\"type\":\"uint256\"}],\"name\":\"changeMaximumFMANBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_usd\",\"type\":\"uint256\"}],\"name\":\"changeMinimumETHBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_usd\",\"type\":\"uint256\"}],\"name\":\"changeMinimumFMANBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gameMapping\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cardId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bet\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"finished\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"heads\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"fman\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"winner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getGame\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cardId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bet\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"finished\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"heads\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"fman\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"internalType\":\"struct FloridaManFlip.Game\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaximumETHBet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaximumFMANBet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinimumETHBet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinimumFMANBet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"isGameComplete\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"isGamePending\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumETHBetUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumFMANBetUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumETHBetUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumFMANBetUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cardId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_heads\",\"type\":\"bool\"}],\"name\":\"play\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cardId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_heads\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_bet\",\"type\":\"uint256\"}],\"name\":\"playFMAN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"requestIdToGameId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawCards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFMAN\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FloridaManFlip", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c780e679b4ca9c9cc72b50a39e5ee06316af6d52000000000000000000000000271682deb8c4e0901d1a1550ad2e64d568e699099fe0eebf5e446e3c998ec9bb19951541aee00bb90ea201ae456421a2ded86805000000000000000000000000000000000000000000000000000000000000034e", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}