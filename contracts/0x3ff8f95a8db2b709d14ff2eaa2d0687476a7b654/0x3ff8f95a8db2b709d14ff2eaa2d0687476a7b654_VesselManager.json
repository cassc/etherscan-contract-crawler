{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822ProxiableUpgradeable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/interfaces/IERC1967Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n *\\n * _Available since v4.8.3._\\n */\\ninterface IERC1967Upgradeable {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeaconUpgradeable.sol\\\";\\nimport \\\"../../interfaces/IERC1967Upgradeable.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/StorageSlotUpgradeable.sol\\\";\\nimport \\\"../utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\\n    function __ERC1967Upgrade_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\\n    }\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(AddressUpgradeable.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(AddressUpgradeable.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"UUPSUpgradeable: must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Addresses.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\n// import \\\"./Dependencies/AddressesConfigurable.sol\\\";\\r\\nimport \\\"./Dependencies/AddressesMainnet.sol\\\";\\r\\n\\r\\ncontract Addresses is AddressesMainnet {}\\r\\n\"\r\n    },\r\n    \"contracts/Dependencies/AddressesMainnet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\nabstract contract AddressesMainnet {\\r\\n\\taddress public constant activePool = 0x2b0024ecee0626E9cFB5F0195F69DCaC5b759Dc9;\\r\\n\\taddress public constant adminContract = 0xf7Cc67326F9A1D057c1e4b110eF6c680B13a1f53;\\r\\n\\taddress public constant borrowerOperations = 0x2bCA0300c2aa65de6F19c2d241B54a445C9990E2;\\r\\n\\taddress public constant collSurplusPool = 0x09dfdF392a56E4316e97A13e20b09C415fCD3d7b;\\r\\n\\taddress public constant communityIssuance = address(0);\\r\\n\\taddress public constant debtToken = 0x15f74458aE0bFdAA1a96CA1aa779D715Cc1Eefe4;\\r\\n\\taddress public constant defaultPool = 0x84446698694B348EaeCE187b55df06AB4Ce72b35;\\r\\n\\taddress public constant feeCollector = 0x4928c8F8c20A1E3C295DddBe05095A9aBBdB3d14;\\r\\n\\taddress public constant gasPoolAddress = 0x40E0e274A42D9b1a9D4B64dC6c46D21228d45C20;\\r\\n\\taddress public constant grvtStaking = address(0);\\r\\n\\taddress public constant priceFeed = 0x89F1ecCF2644902344db02788A790551Bb070351;\\r\\n\\taddress public constant sortedVessels = 0xF31D88232F36098096d1eB69f0de48B53a1d18Ce;\\r\\n\\taddress public constant stabilityPool = 0x4F39F12064D83F6Dd7A2BDb0D53aF8be560356A6;\\r\\n\\taddress public constant timelockAddress = 0x57a1953bF194A1EF73396e442Ac7Dc761dCd23cc;\\r\\n\\taddress public constant treasuryAddress = 0x6F8Fe995422c5efE6487A7B07f67E84aaD9D4eC8;\\r\\n\\taddress public constant vesselManager = 0xdB5DAcB1DFbe16326C3656a88017f0cB4ece0977;\\r\\n\\taddress public constant vesselManagerOperations = 0xc49B737fa56f9142974a54F6C66055468eC631d0;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev This empty reserved space is put in place to allow future versions to add new\\r\\n\\t * variables without shifting down storage in the inheritance chain.\\r\\n\\t * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\r\\n\\t */\\r\\n\\tuint256[40] private __gap;\\r\\n}\\r\\n\\r\\n\"\r\n    },\r\n    \"contracts/Dependencies/BaseMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\nabstract contract BaseMath {\\r\\n\\tuint256 public constant DECIMAL_PRECISION = 1 ether;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Dependencies/GravitaBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\r\\n\\r\\nimport \\\"./BaseMath.sol\\\";\\r\\nimport \\\"./GravitaMath.sol\\\";\\r\\nimport \\\"../Interfaces/IActivePool.sol\\\";\\r\\nimport \\\"../Interfaces/IDefaultPool.sol\\\";\\r\\nimport \\\"../Interfaces/IGravitaBase.sol\\\";\\r\\nimport \\\"../Interfaces/IAdminContract.sol\\\";\\r\\nimport \\\"../Interfaces/IDefaultPool.sol\\\";\\r\\nimport \\\"../Addresses.sol\\\";\\r\\n\\r\\n/*\\r\\n * Base contract for VesselManager, BorrowerOperations and StabilityPool. Contains global system constants and\\r\\n * common functions.\\r\\n */\\r\\nabstract contract GravitaBase is IGravitaBase, BaseMath, OwnableUpgradeable, Addresses {\\r\\n\\t// --- Gas compensation functions ---\\r\\n\\r\\n\\t// Returns the composite debt (drawn debt + gas compensation) of a vessel, for the purpose of ICR calculation\\r\\n\\tfunction _getCompositeDebt(address _asset, uint256 _debt) internal view returns (uint256) {\\r\\n\\t\\treturn _debt + IAdminContract(adminContract).getDebtTokenGasCompensation(_asset);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _getNetDebt(address _asset, uint256 _debt) internal view returns (uint256) {\\r\\n\\t\\treturn _debt - IAdminContract(adminContract).getDebtTokenGasCompensation(_asset);\\r\\n\\t}\\r\\n\\r\\n\\t// Return the amount of ETH to be drawn from a vessel's collateral and sent as gas compensation.\\r\\n\\tfunction _getCollGasCompensation(address _asset, uint256 _entireColl) internal view returns (uint256) {\\r\\n\\t\\treturn _entireColl / IAdminContract(adminContract).getPercentDivisor(_asset);\\r\\n\\t}\\r\\n\\r\\n\\tfunction getEntireSystemColl(address _asset) public view returns (uint256 entireSystemColl) {\\r\\n\\t\\tuint256 activeColl = IActivePool(activePool).getAssetBalance(_asset);\\r\\n\\t\\tuint256 liquidatedColl = IDefaultPool(defaultPool).getAssetBalance(_asset);\\r\\n\\t\\treturn activeColl + liquidatedColl;\\r\\n\\t}\\r\\n\\r\\n\\tfunction getEntireSystemDebt(address _asset) public view returns (uint256 entireSystemDebt) {\\r\\n\\t\\tuint256 activeDebt = IActivePool(activePool).getDebtTokenBalance(_asset);\\r\\n\\t\\tuint256 closedDebt = IDefaultPool(defaultPool).getDebtTokenBalance(_asset);\\r\\n\\t\\treturn activeDebt + closedDebt;\\r\\n\\t}\\r\\n\\r\\n\\tfunction _getTCR(address _asset, uint256 _price) internal view returns (uint256 TCR) {\\r\\n\\t\\tuint256 entireSystemColl = getEntireSystemColl(_asset);\\r\\n\\t\\tuint256 entireSystemDebt = getEntireSystemDebt(_asset);\\r\\n\\t\\tTCR = GravitaMath._computeCR(entireSystemColl, entireSystemDebt, _price);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _checkRecoveryMode(address _asset, uint256 _price) internal view returns (bool) {\\r\\n\\t\\tuint256 TCR = _getTCR(_asset, _price);\\r\\n\\t\\treturn TCR < IAdminContract(adminContract).getCcr(_asset);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _requireUserAcceptsFee(uint256 _fee, uint256 _amount, uint256 _maxFeePercentage) internal view {\\r\\n\\t\\tuint256 feePercentage = (_fee * IAdminContract(adminContract).DECIMAL_PRECISION()) / _amount;\\r\\n\\t\\trequire(feePercentage <= _maxFeePercentage, \\\"Fee exceeded provided maximum\\\");\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Dependencies/GravitaMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\nlibrary GravitaMath {\\r\\n\\tuint256 internal constant DECIMAL_PRECISION = 1 ether;\\r\\n\\r\\n\\tuint256 internal constant EXPONENT_CAP = 525_600_000;\\r\\n\\r\\n\\t/* Precision for Nominal ICR (independent of price). Rationale for the value:\\r\\n\\t *\\r\\n\\t * - Making it \u201ctoo high\u201d could lead to overflows.\\r\\n\\t * - Making it \u201ctoo low\u201d could lead to an ICR equal to zero, due to truncation from Solidity floor division.\\r\\n\\t *\\r\\n\\t * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 ETH,\\r\\n\\t * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\\r\\n\\t *\\r\\n\\t */\\r\\n\\tuint256 internal constant NICR_PRECISION = 1e20;\\r\\n\\r\\n\\tfunction _min(uint256 _a, uint256 _b) internal pure returns (uint256) {\\r\\n\\t\\treturn (_a < _b) ? _a : _b;\\r\\n\\t}\\r\\n\\r\\n\\tfunction _max(uint256 _a, uint256 _b) internal pure returns (uint256) {\\r\\n\\t\\treturn (_a >= _b) ? _a : _b;\\r\\n\\t}\\r\\n\\r\\n\\t/*\\r\\n\\t * Multiply two decimal numbers and use normal rounding rules:\\r\\n\\t * -round product up if 19'th mantissa digit >= 5\\r\\n\\t * -round product down if 19'th mantissa digit < 5\\r\\n\\t *\\r\\n\\t * Used only inside the exponentiation, _decPow().\\r\\n\\t */\\r\\n\\tfunction decMul(uint256 x, uint256 y) internal pure returns (uint256 decProd) {\\r\\n\\t\\tuint256 prod_xy = x * y;\\r\\n\\r\\n\\t\\tdecProd = (prod_xy + (DECIMAL_PRECISION / 2)) / DECIMAL_PRECISION;\\r\\n\\t}\\r\\n\\r\\n\\t/*\\r\\n\\t * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\\r\\n\\t *\\r\\n\\t * Uses the efficient \\\"exponentiation by squaring\\\" algorithm. O(log(n)) complexity.\\r\\n\\t *\\r\\n\\t * Called by two functions that represent time in units of minutes:\\r\\n\\t * 1) VesselManager._calcDecayedBaseRate\\r\\n\\t * 2) CommunityIssuance._getCumulativeIssuanceFraction\\r\\n\\t *\\r\\n\\t * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\\r\\n\\t * \\\"minutes in 1000 years\\\": 60 * 24 * 365 * 1000\\r\\n\\t *\\r\\n\\t * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\\r\\n\\t * negligibly different from just passing the cap, since:\\r\\n\\t *\\r\\n\\t * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\\r\\n\\t * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\\r\\n\\t */\\r\\n\\tfunction _decPow(uint256 _base, uint256 _minutes) internal pure returns (uint256) {\\r\\n\\t\\tif (_minutes > EXPONENT_CAP) {\\r\\n\\t\\t\\t_minutes = EXPONENT_CAP;\\r\\n\\t\\t} // cap to avoid overflow\\r\\n\\r\\n\\t\\tif (_minutes == 0) {\\r\\n\\t\\t\\treturn DECIMAL_PRECISION;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tuint256 y = DECIMAL_PRECISION;\\r\\n\\t\\tuint256 x = _base;\\r\\n\\t\\tuint256 n = _minutes;\\r\\n\\r\\n\\t\\t// Exponentiation-by-squaring\\r\\n\\t\\twhile (n > 1) {\\r\\n\\t\\t\\tif (n % 2 == 0) {\\r\\n\\t\\t\\t\\tx = decMul(x, x);\\r\\n\\t\\t\\t\\tn = n / 2;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t// if (n % 2 != 0)\\r\\n\\t\\t\\t\\ty = decMul(x, y);\\r\\n\\t\\t\\t\\tx = decMul(x, x);\\r\\n\\t\\t\\t\\tn = (n - 1) / 2;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn decMul(x, y);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _getAbsoluteDifference(uint256 _a, uint256 _b) internal pure returns (uint256) {\\r\\n\\t\\treturn (_a >= _b) ? _a - _b : _b - _a;\\r\\n\\t}\\r\\n\\r\\n\\tfunction _computeNominalCR(uint256 _coll, uint256 _debt) internal pure returns (uint256) {\\r\\n\\t\\tif (_debt != 0) {\\r\\n\\t\\t\\treturn _coll * NICR_PRECISION / _debt;\\r\\n\\t\\t}\\r\\n\\t\\t// Return the maximal value for uint256 if the Vessel has a debt of 0. Represents \\\"infinite\\\" CR.\\r\\n\\t\\telse {\\r\\n\\t\\t\\t// if (_debt == 0)\\r\\n\\t\\t\\treturn type(uint256).max;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction _computeCR(\\r\\n\\t\\tuint256 _coll,\\r\\n\\t\\tuint256 _debt,\\r\\n\\t\\tuint256 _price\\r\\n\\t) internal pure returns (uint256) {\\r\\n\\t\\tif (_debt != 0) {\\r\\n\\t\\t\\tuint256 newCollRatio = _coll * _price / _debt;\\r\\n\\r\\n\\t\\t\\treturn newCollRatio;\\r\\n\\t\\t}\\r\\n\\t\\t// Return the maximal value for uint256 if the Vessel has a debt of 0. Represents \\\"infinite\\\" CR.\\r\\n\\t\\telse {\\r\\n\\t\\t\\t// if (_debt == 0)\\r\\n\\t\\t\\treturn type(uint256).max;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/IActivePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\nimport \\\"./IPool.sol\\\";\\r\\n\\r\\ninterface IActivePool is IPool {\\r\\n\\r\\n\\t// --- Events ---\\r\\n\\r\\n\\tevent ActivePoolDebtUpdated(address _asset, uint256 _debtTokenAmount);\\r\\n\\tevent ActivePoolAssetBalanceUpdated(address _asset, uint256 _balance);\\r\\n\\r\\n\\t// --- Functions ---\\r\\n\\r\\n\\tfunction sendAsset(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _account,\\r\\n\\t\\tuint256 _amount\\r\\n\\t) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/IAdminContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\nimport \\\"./IActivePool.sol\\\";\\r\\nimport \\\"./IDefaultPool.sol\\\";\\r\\nimport \\\"./IPriceFeed.sol\\\";\\r\\n\\r\\ninterface IAdminContract {\\r\\n\\t// Structs ----------------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\tstruct CollateralParams {\\r\\n\\t\\tuint256 decimals;\\r\\n\\t\\tuint256 index; // Maps to token address in validCollateral[]\\r\\n\\t\\tbool active;\\r\\n\\t\\tuint256 borrowingFee;\\r\\n\\t\\tuint256 ccr;\\r\\n\\t\\tuint256 mcr;\\r\\n\\t\\tuint256 debtTokenGasCompensation; // Amount of debtToken to be locked in gas pool on opening vessels\\r\\n\\t\\tuint256 minNetDebt; // Minimum amount of net debtToken a vessel must have\\r\\n\\t\\tuint256 mintCap;\\r\\n\\t\\tuint256 percentDivisor;\\r\\n\\t\\tuint256 redemptionFeeFloor;\\r\\n\\t\\tuint256 redemptionBlockTimestamp;\\r\\n\\t}\\r\\n\\r\\n\\t// Custom Errors ----------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\terror SafeCheckError(string parameter, uint256 valueEntered, uint256 minValue, uint256 maxValue);\\r\\n\\terror AdminContract__OnlyOwner();\\r\\n\\terror AdminContract__OnlyTimelock();\\r\\n\\terror AdminContract__CollateralAlreadyInitialized();\\r\\n\\r\\n\\t// Events -----------------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\tevent CollateralAdded(address _collateral);\\r\\n\\tevent MCRChanged(uint256 oldMCR, uint256 newMCR);\\r\\n\\tevent CCRChanged(uint256 oldCCR, uint256 newCCR);\\r\\n\\tevent MinNetDebtChanged(uint256 oldMinNet, uint256 newMinNet);\\r\\n\\tevent PercentDivisorChanged(uint256 oldPercentDiv, uint256 newPercentDiv);\\r\\n\\tevent BorrowingFeeChanged(uint256 oldBorrowingFee, uint256 newBorrowingFee);\\r\\n\\tevent RedemptionFeeFloorChanged(uint256 oldRedemptionFeeFloor, uint256 newRedemptionFeeFloor);\\r\\n\\tevent MintCapChanged(uint256 oldMintCap, uint256 newMintCap);\\r\\n\\tevent RedemptionBlockTimestampChanged(address _collateral, uint256 _blockTimestamp);\\r\\n\\r\\n\\t// Functions --------------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\tfunction DECIMAL_PRECISION() external view returns (uint256);\\r\\n\\r\\n\\tfunction _100pct() external view returns (uint256);\\r\\n\\r\\n\\tfunction addNewCollateral(address _collateral, uint256 _debtTokenGasCompensation, uint256 _decimals) external;\\r\\n\\r\\n\\tfunction setCollateralParameters(\\r\\n\\t\\taddress _collateral,\\r\\n\\t\\tuint256 borrowingFee,\\r\\n\\t\\tuint256 ccr,\\r\\n\\t\\tuint256 mcr,\\r\\n\\t\\tuint256 minNetDebt,\\r\\n\\t\\tuint256 mintCap,\\r\\n\\t\\tuint256 percentDivisor,\\r\\n\\t\\tuint256 redemptionFeeFloor\\r\\n\\t) external;\\r\\n\\r\\n\\tfunction setMCR(address _collateral, uint256 newMCR) external;\\r\\n\\r\\n\\tfunction setCCR(address _collateral, uint256 newCCR) external;\\r\\n\\r\\n\\tfunction setMinNetDebt(address _collateral, uint256 minNetDebt) external;\\r\\n\\r\\n\\tfunction setPercentDivisor(address _collateral, uint256 precentDivisor) external;\\r\\n\\r\\n\\tfunction setBorrowingFee(address _collateral, uint256 borrowingFee) external;\\r\\n\\r\\n\\tfunction setRedemptionFeeFloor(address _collateral, uint256 redemptionFeeFloor) external;\\r\\n\\r\\n\\tfunction setMintCap(address _collateral, uint256 mintCap) external;\\r\\n\\r\\n\\tfunction setRedemptionBlockTimestamp(address _collateral, uint256 _blockTimestamp) external;\\r\\n\\r\\n\\tfunction getIndex(address _collateral) external view returns (uint256);\\r\\n\\r\\n\\tfunction getIsActive(address _collateral) external view returns (bool);\\r\\n\\r\\n\\tfunction getValidCollateral() external view returns (address[] memory);\\r\\n\\r\\n\\tfunction getMcr(address _collateral) external view returns (uint256);\\r\\n\\r\\n\\tfunction getCcr(address _collateral) external view returns (uint256);\\r\\n\\r\\n\\tfunction getDebtTokenGasCompensation(address _collateral) external view returns (uint256);\\r\\n\\r\\n\\tfunction getMinNetDebt(address _collateral) external view returns (uint256);\\r\\n\\r\\n\\tfunction getPercentDivisor(address _collateral) external view returns (uint256);\\r\\n\\r\\n\\tfunction getBorrowingFee(address _collateral) external view returns (uint256);\\r\\n\\r\\n\\tfunction getRedemptionFeeFloor(address _collateral) external view returns (uint256);\\r\\n\\r\\n\\tfunction getRedemptionBlockTimestamp(address _collateral) external view returns (uint256);\\r\\n\\r\\n\\tfunction getMintCap(address _collateral) external view returns (uint256);\\r\\n\\r\\n\\tfunction getTotalAssetDebt(address _asset) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/ICollSurplusPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\nimport \\\"./IDeposit.sol\\\";\\r\\n\\r\\ninterface ICollSurplusPool is IDeposit {\\r\\n\\r\\n\\t// --- Events ---\\r\\n\\r\\n\\tevent CollBalanceUpdated(address indexed _account, uint256 _newBalance);\\r\\n\\tevent AssetSent(address _to, uint256 _amount);\\r\\n\\r\\n\\t// --- Functions ---\\r\\n\\r\\n\\tfunction getAssetBalance(address _asset) external view returns (uint256);\\r\\n\\r\\n\\tfunction getCollateral(address _asset, address _account) external view returns (uint256);\\r\\n\\r\\n\\tfunction accountSurplus(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _account,\\r\\n\\t\\tuint256 _amount\\r\\n\\t) external;\\r\\n\\r\\n\\tfunction claimColl(address _asset, address _account) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/IDebtToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"./IStabilityPool.sol\\\";\\r\\n\\r\\ninterface IDebtToken is IERC20 {\\r\\n\\t// --- Events ---\\r\\n\\r\\n\\tevent TokenBalanceUpdated(address _user, uint256 _amount);\\r\\n\\tevent EmergencyStopMintingCollateral(address _asset, bool state);\\r\\n\\tevent WhitelistChanged(address _whitelisted, bool whitelisted);\\r\\n\\r\\n\\tfunction emergencyStopMinting(address _asset, bool status) external;\\r\\n\\r\\n\\tfunction mint(address _asset, address _account, uint256 _amount) external;\\r\\n\\r\\n\\tfunction mintFromWhitelistedContract(uint256 _amount) external;\\r\\n\\r\\n\\tfunction burnFromWhitelistedContract(uint256 _amount) external;\\r\\n\\r\\n\\tfunction burn(address _account, uint256 _amount) external;\\r\\n\\r\\n\\tfunction sendToPool(address _sender, address poolAddress, uint256 _amount) external;\\r\\n\\r\\n\\tfunction returnFromPool(address poolAddress, address user, uint256 _amount) external;\\r\\n\\r\\n\\tfunction addWhitelist(address _address) external;\\r\\n\\r\\n\\tfunction removeWhitelist(address _address) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/IDefaultPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\nimport \\\"./IPool.sol\\\";\\r\\n\\r\\ninterface IDefaultPool is IPool {\\r\\n\\t// --- Events ---\\r\\n\\tevent DefaultPoolDebtUpdated(address _asset, uint256 _debt);\\r\\n\\tevent DefaultPoolAssetBalanceUpdated(address _asset, uint256 _balance);\\r\\n\\r\\n\\t// --- Functions ---\\r\\n\\tfunction sendAssetToActivePool(address _asset, uint256 _amount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/IDeposit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\ninterface IDeposit {\\r\\n\\tfunction receivedERC20(address _asset, uint256 _amount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/IFeeCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\ninterface IFeeCollector {\\r\\n\\r\\n\\t// Events -----------------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\tevent FeeRecordUpdated(address borrower, address asset, uint256 from, uint256 to, uint256 amount);\\r\\n\\tevent FeeCollected(address borrower, address asset, address collector, uint256 amount);\\r\\n\\tevent FeeRefunded(address borrower, address asset, uint256 amount);\\r\\n\\tevent RedemptionFeeCollected(address asset, uint256 amount);\\r\\n\\r\\n\\t// Structs ----------------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\tstruct FeeRecord {\\r\\n\\t\\tuint256 from; // timestamp in seconds\\r\\n\\t\\tuint256 to; // timestamp in seconds\\r\\n\\t\\tuint256 amount; // refundable fee amount\\r\\n\\t}\\r\\n\\r\\n\\t// Custom Errors ----------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\terror FeeCollector__ArrayMismatch();\\r\\n\\terror FeeCollector__BorrowerOperationsOnly(address sender, address expected);\\r\\n\\terror FeeCollector__BorrowerOperationsOrVesselManagerOnly(address sender, address expected1, address expected2);\\r\\n\\terror FeeCollector__InvalidGRVTStakingAddress();\\r\\n\\terror FeeCollector__VesselManagerOnly(address sender, address expected);\\r\\n\\r\\n\\t// Functions --------------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\tfunction increaseDebt(\\r\\n\\t\\taddress _borrower,\\r\\n\\t\\taddress _asset,\\r\\n\\t\\tuint256 _feeAmount\\r\\n\\t) external;\\r\\n\\r\\n\\tfunction decreaseDebt(\\r\\n\\t\\taddress _borrower,\\r\\n\\t\\taddress _asset,\\r\\n\\t\\tuint256 _paybackFraction\\r\\n\\t) external;\\r\\n\\r\\n\\tfunction closeDebt(address _borrower, address _asset) external;\\r\\n\\r\\n\\tfunction liquidateDebt(address _borrower, address _asset) external;\\r\\n\\r\\n\\tfunction simulateRefund(address _borrower, address _asset, uint256 _paybackFraction) external returns (uint256);\\r\\n\\r\\n\\tfunction collectFees(address[] calldata _borrowers, address[] calldata _assets) external;\\r\\n\\r\\n\\tfunction handleRedemptionFee(address _asset, uint256 _amount) external;\\r\\n\\r\\n\\tfunction getProtocolRevenueDestination() external view returns (address);\\r\\n}\\r\\n\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/IGravitaBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\nimport \\\"./IAdminContract.sol\\\";\\r\\n\\r\\ninterface IGravitaBase {\\r\\n\\tstruct Colls {\\r\\n\\t\\t// tokens and amounts should be the same length\\r\\n\\t\\taddress[] tokens;\\r\\n\\t\\tuint256[] amounts;\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\nimport \\\"./IDeposit.sol\\\";\\r\\n\\r\\ninterface IPool is IDeposit {\\r\\n\\r\\n\\t// --- Events ---\\r\\n\\r\\n\\tevent AssetSent(address _to, address indexed _asset, uint256 _amount);\\r\\n\\r\\n\\t// --- Functions ---\\r\\n\\r\\n\\tfunction getAssetBalance(address _asset) external view returns (uint256);\\r\\n\\r\\n\\tfunction getDebtTokenBalance(address _asset) external view returns (uint256);\\r\\n\\r\\n\\tfunction increaseDebt(address _asset, uint256 _amount) external;\\r\\n\\r\\n\\tfunction decreaseDebt(address _asset, uint256 _amount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/IPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\n/*\\r\\n * @dev from https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\r\\n */\\r\\ninterface ChainlinkAggregatorV3Interface {\\r\\n\\tfunction decimals() external view returns (uint8);\\r\\n\\r\\n\\tfunction latestRoundData()\\r\\n\\t\\texternal\\r\\n\\t\\tview\\r\\n\\t\\treturns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\r\\n}\\r\\n\\r\\ninterface IPriceFeed {\\r\\n\\t// Enums ----------------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\tenum ProviderType {\\r\\n\\t\\tChainlink\\r\\n\\t}\\r\\n\\r\\n\\t// Structs --------------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\tstruct OracleRecordV2 {\\r\\n\\t\\taddress oracleAddress;\\r\\n\\t\\tProviderType providerType;\\r\\n\\t\\tuint256 timeoutSeconds;\\r\\n\\t\\tuint256 decimals;\\r\\n\\t\\tbool isEthIndexed;\\r\\n\\t}\\r\\n\\r\\n\\t/// @dev Deprecated, but retained for upgradeability\\r\\n\\tstruct OracleRecord {\\r\\n\\t\\taddress chainLinkOracle;\\r\\n\\t\\tuint256 maxDeviationBetweenRounds;\\r\\n\\t\\tbool exists;\\r\\n\\t\\tbool isFeedWorking;\\r\\n\\t\\tbool isEthIndexed;\\r\\n\\t}\\r\\n\\r\\n\\t/// @dev Deprecated, but retained for upgradeability\\r\\n\\tstruct PriceRecord {\\r\\n\\t\\tuint256 scaledPrice;\\r\\n\\t\\tuint256 timestamp;\\r\\n\\t}\\r\\n\\r\\n\\t/// @dev Deprecated, but retained for upgradeability\\r\\n\\tstruct FeedResponse {\\r\\n\\t\\tuint80 roundId;\\r\\n\\t\\tint256 answer;\\r\\n\\t\\tuint256 timestamp;\\r\\n\\t\\tbool success;\\r\\n\\t\\tuint8 decimals;\\r\\n\\t}\\r\\n\\r\\n\\t// Custom Errors --------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\terror PriceFeed__ExistingOracleRequired();\\r\\n\\terror PriceFeed__InvalidDecimalsError();\\r\\n\\terror PriceFeed__InvalidOracleResponseError(address token);\\r\\n\\terror PriceFeed__TimelockOnlyError();\\r\\n\\terror PriceFeed__UnknownAssetError();\\r\\n\\r\\n\\t// Events ---------------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\tevent NewOracleRegistered(address token, address oracleAddress, bool isEthIndexed, bool isFallback);\\r\\n\\r\\n\\t// Functions ------------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\tfunction fetchPrice(address _token) external view returns (uint256);\\r\\n\\r\\n\\tfunction setOracle(\\r\\n\\t\\taddress _token,\\r\\n\\t\\taddress _oracle,\\r\\n\\t\\tProviderType _type,\\r\\n\\t\\tuint256 _timeoutSeconds,\\r\\n\\t\\tbool _isEthIndexed,\\r\\n\\t\\tbool _isFallback\\r\\n\\t) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/ISortedVessels.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\ninterface ISortedVessels {\\r\\n\\t// --- Events ---\\r\\n\\r\\n\\tevent NodeAdded(address indexed _asset, address _id, uint256 _NICR);\\r\\n\\tevent NodeRemoved(address indexed _asset, address _id);\\r\\n\\r\\n\\t// --- Functions ---\\r\\n\\r\\n\\tfunction insert(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _id,\\r\\n\\t\\tuint256 _ICR,\\r\\n\\t\\taddress _prevId,\\r\\n\\t\\taddress _nextId\\r\\n\\t) external;\\r\\n\\r\\n\\tfunction remove(address _asset, address _id) external;\\r\\n\\r\\n\\tfunction reInsert(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _id,\\r\\n\\t\\tuint256 _newICR,\\r\\n\\t\\taddress _prevId,\\r\\n\\t\\taddress _nextId\\r\\n\\t) external;\\r\\n\\r\\n\\tfunction contains(address _asset, address _id) external view returns (bool);\\r\\n\\r\\n\\tfunction isEmpty(address _asset) external view returns (bool);\\r\\n\\r\\n\\tfunction getSize(address _asset) external view returns (uint256);\\r\\n\\r\\n\\tfunction getFirst(address _asset) external view returns (address);\\r\\n\\r\\n\\tfunction getLast(address _asset) external view returns (address);\\r\\n\\r\\n\\tfunction getNext(address _asset, address _id) external view returns (address);\\r\\n\\r\\n\\tfunction getPrev(address _asset, address _id) external view returns (address);\\r\\n\\r\\n\\tfunction validInsertPosition(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\tuint256 _ICR,\\r\\n\\t\\taddress _prevId,\\r\\n\\t\\taddress _nextId\\r\\n\\t) external view returns (bool);\\r\\n\\r\\n\\tfunction findInsertPosition(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\tuint256 _ICR,\\r\\n\\t\\taddress _prevId,\\r\\n\\t\\taddress _nextId\\r\\n\\t) external view returns (address, address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/IStabilityPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\nimport \\\"./IDeposit.sol\\\";\\r\\n\\r\\ninterface IStabilityPool is IDeposit {\\r\\n\\t// --- Structs ---\\r\\n\\r\\n\\tstruct Snapshots {\\r\\n\\t\\tmapping(address => uint256) S;\\r\\n\\t\\tuint256 P;\\r\\n\\t\\tuint256 G;\\r\\n\\t\\tuint128 scale;\\r\\n\\t\\tuint128 epoch;\\r\\n\\t}\\r\\n\\r\\n\\t// --- Events ---\\r\\n\\r\\n\\tevent CommunityIssuanceAddressChanged(address newAddress);\\r\\n\\tevent DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);\\r\\n\\tevent SystemSnapshotUpdated(uint256 _P, uint256 _G);\\r\\n\\r\\n\\tevent AssetSent(address _asset, address _to, uint256 _amount);\\r\\n\\tevent GainsWithdrawn(address indexed _depositor, address[] _collaterals, uint256[] _amounts, uint256 _debtTokenLoss);\\r\\n\\tevent GRVTPaidToDepositor(address indexed _depositor, uint256 _GRVT);\\r\\n\\tevent StabilityPoolAssetBalanceUpdated(address _asset, uint256 _newBalance);\\r\\n\\tevent StabilityPoolDebtTokenBalanceUpdated(uint256 _newBalance);\\r\\n\\tevent StakeChanged(uint256 _newSystemStake, address _depositor);\\r\\n\\tevent UserDepositChanged(address indexed _depositor, uint256 _newDeposit);\\r\\n\\r\\n\\tevent P_Updated(uint256 _P);\\r\\n\\tevent S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);\\r\\n\\tevent G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);\\r\\n\\tevent EpochUpdated(uint128 _currentEpoch);\\r\\n\\tevent ScaleUpdated(uint128 _currentScale);\\r\\n\\r\\n\\t// --- Errors ---\\r\\n\\r\\n\\terror StabilityPool__ActivePoolOnly(address sender, address expected);\\r\\n\\terror StabilityPool__AdminContractOnly(address sender, address expected);\\r\\n\\terror StabilityPool__VesselManagerOnly(address sender, address expected);\\r\\n\\terror StabilityPool__ArrayNotInAscendingOrder();\\r\\n\\r\\n\\t// --- Functions ---\\r\\n\\r\\n\\tfunction addCollateralType(address _collateral) external;\\r\\n\\r\\n\\t/*\\r\\n\\t * Initial checks:\\r\\n\\t * - _amount is not zero\\r\\n\\t * ---\\r\\n\\t * - Triggers a GRVT issuance, based on time passed since the last issuance. The GRVT issuance is shared between *all* depositors.\\r\\n\\t * - Sends depositor's accumulated gains (GRVT, assets) to depositor\\r\\n\\t */\\r\\n\\tfunction provideToSP(uint256 _amount, address[] calldata _assets) external;\\r\\n\\r\\n\\t/*\\r\\n\\t * Initial checks:\\r\\n\\t * - _amount is zero or there are no under collateralized vessels left in the system\\r\\n\\t * - User has a non zero deposit\\r\\n\\t * ---\\r\\n\\t * - Triggers a GRVT issuance, based on time passed since the last issuance. The GRVT issuance is shared between *all* depositors.\\r\\n\\t * - Sends all depositor's accumulated gains (GRVT, assets) to depositor\\r\\n\\t * - Decreases deposit's stake, and takes new snapshots.\\r\\n\\t *\\r\\n\\t * If _amount > userDeposit, the user withdraws all of their compounded deposit.\\r\\n\\t */\\r\\n\\tfunction withdrawFromSP(uint256 _amount, address[] calldata _assets) external;\\r\\n\\r\\n\\t/*\\r\\n\\tInitial checks:\\r\\n\\t * - Caller is VesselManager\\r\\n\\t * ---\\r\\n\\t * Cancels out the specified debt against the debt token contained in the Stability Pool (as far as possible)\\r\\n\\t * and transfers the Vessel's collateral from ActivePool to StabilityPool.\\r\\n\\t * Only called by liquidation functions in the VesselManager.\\r\\n\\t */\\r\\n\\tfunction offset(uint256 _debt, address _asset, uint256 _coll) external;\\r\\n\\r\\n\\t/*\\r\\n\\t * Returns debt tokens held in the pool. Changes when users deposit/withdraw, and when Vessel debt is offset.\\r\\n\\t */\\r\\n\\tfunction getTotalDebtTokenDeposits() external view returns (uint256);\\r\\n\\r\\n\\t/*\\r\\n\\t * Calculates the asset gains earned by the deposit since its last snapshots were taken.\\r\\n\\t */\\r\\n\\tfunction getDepositorGains(\\r\\n\\t\\taddress _depositor,\\r\\n\\t\\taddress[] calldata _assets\\r\\n\\t) external view returns (address[] memory, uint256[] memory);\\r\\n\\r\\n\\t/*\\r\\n\\t * Calculate the GRVT gain earned by a deposit since its last snapshots were taken.\\r\\n\\t */\\r\\n\\tfunction getDepositorGRVTGain(address _depositor) external view returns (uint256);\\r\\n\\r\\n\\t/*\\r\\n\\t * Return the user's compounded deposits.\\r\\n\\t */\\r\\n\\tfunction getCompoundedDebtTokenDeposits(address _depositor) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Interfaces/IVesselManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\nimport \\\"./IActivePool.sol\\\";\\r\\nimport \\\"./ICollSurplusPool.sol\\\";\\r\\nimport \\\"./IDebtToken.sol\\\";\\r\\nimport \\\"./IDefaultPool.sol\\\";\\r\\nimport \\\"./IGravitaBase.sol\\\";\\r\\nimport \\\"./ISortedVessels.sol\\\";\\r\\nimport \\\"./IStabilityPool.sol\\\";\\r\\n\\r\\ninterface IVesselManager is IGravitaBase {\\r\\n\\t// Enums ------------------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\tenum Status {\\r\\n\\t\\tnonExistent,\\r\\n\\t\\tactive,\\r\\n\\t\\tclosedByOwner,\\r\\n\\t\\tclosedByLiquidation,\\r\\n\\t\\tclosedByRedemption\\r\\n\\t}\\r\\n\\r\\n\\tenum VesselManagerOperation {\\r\\n\\t\\tapplyPendingRewards,\\r\\n\\t\\tliquidateInNormalMode,\\r\\n\\t\\tliquidateInRecoveryMode,\\r\\n\\t\\tredeemCollateral\\r\\n\\t}\\r\\n\\r\\n\\t// Events -----------------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\tevent BaseRateUpdated(address indexed _asset, uint256 _baseRate);\\r\\n\\tevent LastFeeOpTimeUpdated(address indexed _asset, uint256 _lastFeeOpTime);\\r\\n\\tevent TotalStakesUpdated(address indexed _asset, uint256 _newTotalStakes);\\r\\n\\tevent SystemSnapshotsUpdated(address indexed _asset, uint256 _totalStakesSnapshot, uint256 _totalCollateralSnapshot);\\r\\n\\tevent LTermsUpdated(address indexed _asset, uint256 _L_Coll, uint256 _L_Debt);\\r\\n\\tevent VesselSnapshotsUpdated(address indexed _asset, uint256 _L_Coll, uint256 _L_Debt);\\r\\n\\tevent VesselIndexUpdated(address indexed _asset, address _borrower, uint256 _newIndex);\\r\\n\\r\\n\\tevent VesselUpdated(\\r\\n\\t\\taddress indexed _asset,\\r\\n\\t\\taddress indexed _borrower,\\r\\n\\t\\tuint256 _debt,\\r\\n\\t\\tuint256 _coll,\\r\\n\\t\\tuint256 _stake,\\r\\n\\t\\tVesselManagerOperation _operation\\r\\n\\t);\\r\\n\\r\\n\\t// Custom Errors ----------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\terror VesselManager__FeeBiggerThanAssetDraw();\\r\\n\\terror VesselManager__OnlyOneVessel();\\r\\n\\r\\n\\terror VesselManager__OnlyVesselManagerOperations();\\r\\n\\terror VesselManager__OnlyBorrowerOperations();\\r\\n\\terror VesselManager__OnlyVesselManagerOperationsOrBorrowerOperations();\\r\\n\\r\\n\\t// Structs ----------------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\tstruct Vessel {\\r\\n\\t\\tuint256 debt;\\r\\n\\t\\tuint256 coll;\\r\\n\\t\\tuint256 stake;\\r\\n\\t\\tStatus status;\\r\\n\\t\\tuint128 arrayIndex;\\r\\n\\t}\\r\\n\\r\\n\\t// Functions --------------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\tfunction executeFullRedemption(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _borrower,\\r\\n\\t\\tuint256 _newColl\\r\\n\\t) external;\\r\\n\\r\\n\\tfunction executePartialRedemption(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _borrower,\\r\\n\\t\\tuint256 _newDebt,\\r\\n\\t\\tuint256 _newColl,\\r\\n\\t\\tuint256 _newNICR,\\r\\n\\t\\taddress _upperPartialRedemptionHint,\\r\\n\\t\\taddress _lowerPartialRedemptionHint\\r\\n\\t) external;\\r\\n\\r\\n\\tfunction getVesselOwnersCount(address _asset) external view returns (uint256);\\r\\n\\r\\n\\tfunction getVesselFromVesselOwnersArray(address _asset, uint256 _index) external view returns (address);\\r\\n\\r\\n\\tfunction getNominalICR(address _asset, address _borrower) external view returns (uint256);\\r\\n\\r\\n\\tfunction getCurrentICR(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _borrower,\\r\\n\\t\\tuint256 _price\\r\\n\\t) external view returns (uint256);\\r\\n\\r\\n\\tfunction updateStakeAndTotalStakes(address _asset, address _borrower) external returns (uint256);\\r\\n\\r\\n\\tfunction updateVesselRewardSnapshots(address _asset, address _borrower) external;\\r\\n\\r\\n\\tfunction addVesselOwnerToArray(address _asset, address _borrower) external returns (uint256 index);\\r\\n\\r\\n\\tfunction applyPendingRewards(address _asset, address _borrower) external;\\r\\n\\r\\n\\tfunction getPendingAssetReward(address _asset, address _borrower) external view returns (uint256);\\r\\n\\r\\n\\tfunction getPendingDebtTokenReward(address _asset, address _borrower) external view returns (uint256);\\r\\n\\r\\n\\tfunction hasPendingRewards(address _asset, address _borrower) external view returns (bool);\\r\\n\\r\\n\\tfunction getEntireDebtAndColl(address _asset, address _borrower)\\r\\n\\t\\texternal\\r\\n\\t\\tview\\r\\n\\t\\treturns (\\r\\n\\t\\t\\tuint256 debt,\\r\\n\\t\\t\\tuint256 coll,\\r\\n\\t\\t\\tuint256 pendingDebtTokenReward,\\r\\n\\t\\t\\tuint256 pendingAssetReward\\r\\n\\t\\t);\\r\\n\\r\\n\\tfunction closeVessel(address _asset, address _borrower) external;\\r\\n\\r\\n\\tfunction closeVesselLiquidation(address _asset, address _borrower) external;\\r\\n\\r\\n\\tfunction removeStake(address _asset, address _borrower) external;\\r\\n\\r\\n\\tfunction getRedemptionRate(address _asset) external view returns (uint256);\\r\\n\\r\\n\\tfunction getRedemptionRateWithDecay(address _asset) external view returns (uint256);\\r\\n\\r\\n\\tfunction getRedemptionFeeWithDecay(address _asset, uint256 _assetDraw) external view returns (uint256);\\r\\n\\r\\n\\tfunction getBorrowingRate(address _asset) external view returns (uint256);\\r\\n\\r\\n\\tfunction getBorrowingFee(address _asset, uint256 _debtTokenAmount) external view returns (uint256);\\r\\n\\r\\n\\tfunction getVesselStatus(address _asset, address _borrower) external view returns (uint256);\\r\\n\\r\\n\\tfunction getVesselStake(address _asset, address _borrower) external view returns (uint256);\\r\\n\\r\\n\\tfunction getVesselDebt(address _asset, address _borrower) external view returns (uint256);\\r\\n\\r\\n\\tfunction getVesselColl(address _asset, address _borrower) external view returns (uint256);\\r\\n\\r\\n\\tfunction setVesselStatus(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _borrower,\\r\\n\\t\\tuint256 num\\r\\n\\t) external;\\r\\n\\r\\n\\tfunction increaseVesselColl(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _borrower,\\r\\n\\t\\tuint256 _collIncrease\\r\\n\\t) external returns (uint256);\\r\\n\\r\\n\\tfunction decreaseVesselColl(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _borrower,\\r\\n\\t\\tuint256 _collDecrease\\r\\n\\t) external returns (uint256);\\r\\n\\r\\n\\tfunction increaseVesselDebt(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _borrower,\\r\\n\\t\\tuint256 _debtIncrease\\r\\n\\t) external returns (uint256);\\r\\n\\r\\n\\tfunction decreaseVesselDebt(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _borrower,\\r\\n\\t\\tuint256 _collDecrease\\r\\n\\t) external returns (uint256);\\r\\n\\r\\n\\tfunction getTCR(address _asset, uint256 _price) external view returns (uint256);\\r\\n\\r\\n\\tfunction checkRecoveryMode(address _asset, uint256 _price) external returns (bool);\\r\\n\\r\\n\\tfunction isValidFirstRedemptionHint(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _firstRedemptionHint,\\r\\n\\t\\tuint256 _price\\r\\n\\t) external returns (bool);\\r\\n\\r\\n\\tfunction updateBaseRateFromRedemption(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\tuint256 _assetDrawn,\\r\\n\\t\\tuint256 _price,\\r\\n\\t\\tuint256 _totalDebtTokenSupply\\r\\n\\t) external returns (uint256);\\r\\n\\r\\n\\tfunction getRedemptionFee(address _asset, uint256 _assetDraw) external view returns (uint256);\\r\\n\\r\\n\\tfunction finalizeRedemption(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _receiver,\\r\\n\\t\\tuint256 _debtToRedeem,\\r\\n\\t\\tuint256 _fee,\\r\\n\\t\\tuint256 _totalRedemptionRewards\\r\\n\\t) external;\\r\\n\\r\\n\\tfunction redistributeDebtAndColl(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\tuint256 _debt,\\r\\n\\t\\tuint256 _coll,\\r\\n\\t\\tuint256 _debtToOffset,\\r\\n\\t\\tuint256 _collToSendToStabilityPool\\r\\n\\t) external;\\r\\n\\r\\n\\tfunction updateSystemSnapshots_excludeCollRemainder(address _asset, uint256 _collRemainder) external;\\r\\n\\r\\n\\tfunction movePendingVesselRewardsToActivePool(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\tuint256 _debtTokenAmount,\\r\\n\\t\\tuint256 _assetAmount\\r\\n\\t) external;\\r\\n\\r\\n\\tfunction isVesselActive(address _asset, address _borrower) external view returns (bool);\\r\\n\\r\\n\\tfunction sendGasCompensation(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _liquidator,\\r\\n\\t\\tuint256 _debtTokenAmount,\\r\\n\\t\\tuint256 _assetAmount\\r\\n\\t) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/VesselManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\r\\n\\r\\nimport \\\"./Dependencies/GravitaBase.sol\\\";\\r\\nimport \\\"./Interfaces/IVesselManager.sol\\\";\\r\\nimport \\\"./Interfaces/IFeeCollector.sol\\\";\\r\\n\\r\\ncontract VesselManager is IVesselManager, UUPSUpgradeable, ReentrancyGuardUpgradeable, GravitaBase {\\r\\n\\t// Constants ------------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\tstring public constant NAME = \\\"VesselManager\\\";\\r\\n\\r\\n\\tuint256 public constant SECONDS_IN_ONE_MINUTE = 60;\\r\\n\\t/*\\r\\n\\t * Half-life of 12h. 12h = 720 min\\r\\n\\t * (1/2) = d^720 => d = (1/2)^(1/720)\\r\\n\\t */\\r\\n\\tuint256 public constant MINUTE_DECAY_FACTOR = 999037758833783000;\\r\\n\\r\\n\\t/*\\r\\n\\t * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption.\\r\\n\\t * Corresponds to (1 / ALPHA) in the white paper.\\r\\n\\t */\\r\\n\\tuint256 public constant BETA = 2;\\r\\n\\r\\n\\t// Structs --------------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\t// Object containing the asset and debt token snapshots for a given active vessel\\r\\n\\tstruct RewardSnapshot {\\r\\n\\t\\tuint256 asset;\\r\\n\\t\\tuint256 debt;\\r\\n\\t}\\r\\n\\r\\n\\t// State ----------------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\tmapping(address => uint256) public baseRate;\\r\\n\\r\\n\\t// The timestamp of the latest fee operation (redemption or new debt token issuance)\\r\\n\\tmapping(address => uint256) public lastFeeOperationTime;\\r\\n\\r\\n\\t// Vessels[borrower address][Collateral address]\\r\\n\\tmapping(address => mapping(address => Vessel)) public Vessels;\\r\\n\\r\\n\\tmapping(address => uint256) public totalStakes;\\r\\n\\r\\n\\t// Snapshot of the value of totalStakes, taken immediately after the latest liquidation\\r\\n\\tmapping(address => uint256) public totalStakesSnapshot;\\r\\n\\r\\n\\t// Snapshot of the total collateral across the ActivePool and DefaultPool, immediately after the latest liquidation.\\r\\n\\tmapping(address => uint256) public totalCollateralSnapshot;\\r\\n\\r\\n\\t/*\\r\\n\\t * L_Colls and L_Debts track the sums of accumulated liquidation rewards per unit staked. During its lifetime, each stake earns:\\r\\n\\t *\\r\\n\\t * An asset gain of ( stake * [L_Colls - L_Colls(0)] )\\r\\n\\t * A debt increase of ( stake * [L_Debts - L_Debts(0)] )\\r\\n\\t *\\r\\n\\t * Where L_Colls(0) and L_Debts(0) are snapshots of L_Colls and L_Debts for the active Vessel taken at the instant the stake was made\\r\\n\\t */\\r\\n\\tmapping(address => uint256) public L_Colls;\\r\\n\\tmapping(address => uint256) public L_Debts;\\r\\n\\r\\n\\t// Map addresses with active vessels to their RewardSnapshot\\r\\n\\tmapping(address => mapping(address => RewardSnapshot)) public rewardSnapshots;\\r\\n\\r\\n\\t// Array of all active vessel addresses - used to to compute an approximate hint off-chain, for the sorted list insertion\\r\\n\\tmapping(address => address[]) public VesselOwners;\\r\\n\\r\\n\\t// Error trackers for the vessel redistribution calculation\\r\\n\\tmapping(address => uint256) public lastCollError_Redistribution;\\r\\n\\tmapping(address => uint256) public lastDebtError_Redistribution;\\r\\n\\r\\n\\tbool public isSetupInitialized;\\r\\n\\r\\n\\t// Modifiers ------------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\tmodifier onlyVesselManagerOperations() {\\r\\n\\t\\tif (msg.sender != vesselManagerOperations) {\\r\\n\\t\\t\\trevert VesselManager__OnlyVesselManagerOperations();\\r\\n\\t\\t}\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\tmodifier onlyBorrowerOperations() {\\r\\n\\t\\tif (msg.sender != borrowerOperations) {\\r\\n\\t\\t\\trevert VesselManager__OnlyBorrowerOperations();\\r\\n\\t\\t}\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\tmodifier onlyVesselManagerOperationsOrBorrowerOperations() {\\r\\n\\t\\tif (msg.sender != borrowerOperations && msg.sender != vesselManagerOperations) {\\r\\n\\t\\t\\trevert VesselManager__OnlyVesselManagerOperationsOrBorrowerOperations();\\r\\n\\t\\t}\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\t// Initializer ------------------------------------------------------------------------------------------------------\\r\\n\\r\\n\\tfunction initialize() public initializer {\\r\\n\\t\\t__Ownable_init();\\r\\n\\t\\t__UUPSUpgradeable_init();\\r\\n\\t\\t__ReentrancyGuard_init();\\r\\n\\t}\\r\\n\\r\\n\\t// External/public functions --------------------------------------------------------------------------------------\\r\\n\\r\\n\\tfunction isValidFirstRedemptionHint(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _firstRedemptionHint,\\r\\n\\t\\tuint256 _price\\r\\n\\t) external view returns (bool) {\\r\\n\\t\\tif (\\r\\n\\t\\t\\t_firstRedemptionHint == address(0) ||\\r\\n\\t\\t\\t!ISortedVessels(sortedVessels).contains(_asset, _firstRedemptionHint) ||\\r\\n\\t\\t\\tgetCurrentICR(_asset, _firstRedemptionHint, _price) < IAdminContract(adminContract).getMcr(_asset)\\r\\n\\t\\t) {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\t\\taddress nextVessel = ISortedVessels(sortedVessels).getNext(_asset, _firstRedemptionHint);\\r\\n\\t\\treturn\\r\\n\\t\\t\\tnextVessel == address(0) ||\\r\\n\\t\\t\\tgetCurrentICR(_asset, nextVessel, _price) < IAdminContract(adminContract).getMcr(_asset);\\r\\n\\t}\\r\\n\\r\\n\\t// Return the nominal collateral ratio (ICR) of a given Vessel, without the price. Takes a vessel's pending coll and debt rewards from redistributions into account.\\r\\n\\tfunction getNominalICR(address _asset, address _borrower) external view override returns (uint256) {\\r\\n\\t\\t(uint256 currentAsset, uint256 currentDebt) = _getCurrentVesselAmounts(_asset, _borrower);\\r\\n\\r\\n\\t\\tuint256 NICR = GravitaMath._computeNominalCR(currentAsset, currentDebt);\\r\\n\\t\\treturn NICR;\\r\\n\\t}\\r\\n\\r\\n\\t// Return the current collateral ratio (ICR) of a given Vessel. Takes a vessel's pending coll and debt rewards from redistributions into account.\\r\\n\\tfunction getCurrentICR(address _asset, address _borrower, uint256 _price) public view override returns (uint256) {\\r\\n\\t\\t(uint256 currentAsset, uint256 currentDebt) = _getCurrentVesselAmounts(_asset, _borrower);\\r\\n\\t\\tuint256 ICR = GravitaMath._computeCR(currentAsset, currentDebt, _price);\\r\\n\\t\\treturn ICR;\\r\\n\\t}\\r\\n\\r\\n\\t// Get the borrower's pending accumulated asset reward, earned by their stake\\r\\n\\tfunction getPendingAssetReward(address _asset, address _borrower) public view override returns (uint256) {\\r\\n\\t\\tuint256 snapshotAsset = rewardSnapshots[_borrower][_asset].asset;\\r\\n\\t\\tuint256 rewardPerUnitStaked = L_Colls[_asset] - snapshotAsset;\\r\\n\\t\\tif (rewardPerUnitStaked == 0 || !isVesselActive(_asset, _borrower)) {\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\t\\tuint256 stake = Vessels[_borrower][_asset].stake;\\r\\n\\t\\tuint256 pendingAssetReward = (stake * rewardPerUnitStaked) / DECIMAL_PRECISION;\\r\\n\\t\\treturn pendingAssetReward;\\r\\n\\t}\\r\\n\\r\\n\\t// Get the borrower's pending accumulated debt token reward, earned by their stake\\r\\n\\tfunction getPendingDebtTokenReward(address _asset, address _borrower) public view override returns (uint256) {\\r\\n\\t\\tuint256 snapshotDebt = rewardSnapshots[_borrower][_asset].debt;\\r\\n\\t\\tuint256 rewardPerUnitStaked = L_Debts[_asset] - snapshotDebt;\\r\\n\\t\\tif (rewardPerUnitStaked == 0 || !isVesselActive(_asset, _borrower)) {\\r\\n\\t\\t\\treturn 0;\\r\\n\\t\\t}\\r\\n\\t\\tuint256 stake = Vessels[_borrower][_asset].stake;\\r\\n\\t\\treturn (stake * rewardPerUnitStaked) / DECIMAL_PRECISION;\\r\\n\\t}\\r\\n\\r\\n\\tfunction hasPendingRewards(address _asset, address _borrower) public view override returns (bool) {\\r\\n\\t\\tif (!isVesselActive(_asset, _borrower)) {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\t\\treturn (rewardSnapshots[_borrower][_asset].asset < L_Colls[_asset]);\\r\\n\\t}\\r\\n\\r\\n\\tfunction getEntireDebtAndColl(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _borrower\\r\\n\\t) external view override returns (uint256 debt, uint256 coll, uint256 pendingDebtReward, uint256 pendingCollReward) {\\r\\n\\t\\tpendingDebtReward = getPendingDebtTokenReward(_asset, _borrower);\\r\\n\\t\\tpendingCollReward = getPendingAssetReward(_asset, _borrower);\\r\\n\\t\\tVessel storage vessel = Vessels[_borrower][_asset];\\r\\n\\t\\tdebt = vessel.debt + pendingDebtReward;\\r\\n\\t\\tcoll = vessel.coll + pendingCollReward;\\r\\n\\t}\\r\\n\\r\\n\\tfunction isVesselActive(address _asset, address _borrower) public view override returns (bool) {\\r\\n\\t\\treturn getVesselStatus(_asset, _borrower) == uint256(Status.active);\\r\\n\\t}\\r\\n\\r\\n\\tfunction getTCR(address _asset, uint256 _price) external view override returns (uint256) {\\r\\n\\t\\treturn _getTCR(_asset, _price);\\r\\n\\t}\\r\\n\\r\\n\\tfunction checkRecoveryMode(address _asset, uint256 _price) external view override returns (bool) {\\r\\n\\t\\treturn _checkRecoveryMode(_asset, _price);\\r\\n\\t}\\r\\n\\r\\n\\tfunction getBorrowingRate(address _asset) external view override returns (uint256) {\\r\\n\\t\\treturn IAdminContract(adminContract).getBorrowingFee(_asset);\\r\\n\\t}\\r\\n\\r\\n\\tfunction getBorrowingFee(address _asset, uint256 _debt) external view override returns (uint256) {\\r\\n\\t\\treturn (IAdminContract(adminContract).getBorrowingFee(_asset) * _debt) / DECIMAL_PRECISION;\\r\\n\\t}\\r\\n\\r\\n\\tfunction getRedemptionFee(address _asset, uint256 _assetDraw) public view returns (uint256) {\\r\\n\\t\\treturn _calcRedemptionFee(getRedemptionRate(_asset), _assetDraw);\\r\\n\\t}\\r\\n\\r\\n\\tfunction getRedemptionFeeWithDecay(address _asset, uint256 _assetDraw) external view override returns (uint256) {\\r\\n\\t\\treturn _calcRedemptionFee(getRedemptionRateWithDecay(_asset), _assetDraw);\\r\\n\\t}\\r\\n\\r\\n\\tfunction getRedemptionRate(address _asset) public view override returns (uint256) {\\r\\n\\t\\treturn _calcRedemptionRate(_asset, baseRate[_asset]);\\r\\n\\t}\\r\\n\\r\\n\\tfunction getRedemptionRateWithDecay(address _asset) public view override returns (uint256) {\\r\\n\\t\\treturn _calcRedemptionRate(_asset, _calcDecayedBaseRate(_asset));\\r\\n\\t}\\r\\n\\r\\n\\t// Called by Gravita contracts ------------------------------------------------------------------------------------\\r\\n\\r\\n\\tfunction addVesselOwnerToArray(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _borrower\\r\\n\\t) external override onlyBorrowerOperations returns (uint256 index) {\\r\\n\\t\\taddress[] storage assetOwners = VesselOwners[_asset];\\r\\n\\t\\tassetOwners.push(_borrower);\\r\\n\\t\\tindex = assetOwners.length - 1;\\r\\n\\t\\tVessels[_borrower][_asset].arrayIndex = uint128(index);\\r\\n\\t\\treturn index;\\r\\n\\t}\\r\\n\\r\\n\\tfunction executeFullRedemption(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _borrower,\\r\\n\\t\\tuint256 _newColl\\r\\n\\t) external override nonReentrant onlyVesselManagerOperations {\\r\\n\\t\\t_removeStake(_asset, _borrower);\\r\\n\\t\\t_closeVessel(_asset, _borrower, Status.closedByRedemption);\\r\\n\\t\\t_redeemCloseVessel(_asset, _borrower, IAdminContract(adminContract).getDebtTokenGasCompensation(_asset), _newColl);\\r\\n\\t\\tIFeeCollector(feeCollector).closeDebt(_borrower, _asset);\\r\\n\\t\\temit VesselUpdated(_asset, _borrower, 0, 0, 0, VesselManagerOperation.redeemCollateral);\\r\\n\\t}\\r\\n\\r\\n\\tfunction executePartialRedemption(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _borrower,\\r\\n\\t\\tuint256 _newDebt,\\r\\n\\t\\tuint256 _newColl,\\r\\n\\t\\tuint256 _newNICR,\\r\\n\\t\\taddress _upperPartialRedemptionHint,\\r\\n\\t\\taddress _lowerPartialRedemptionHint\\r\\n\\t) external override onlyVesselManagerOperations {\\r\\n\\t\\tISortedVessels(sortedVessels).reInsert(\\r\\n\\t\\t\\t_asset,\\r\\n\\t\\t\\t_borrower,\\r\\n\\t\\t\\t_newNICR,\\r\\n\\t\\t\\t_upperPartialRedemptionHint,\\r\\n\\t\\t\\t_lowerPartialRedemptionHint\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\tVessel storage vessel = Vessels[_borrower][_asset];\\r\\n\\t\\tuint256 paybackFraction = ((vessel.debt - _newDebt) * 1 ether) / vessel.debt;\\r\\n\\t\\tif (paybackFraction != 0) {\\r\\n\\t\\t\\tIFeeCollector(feeCollector).decreaseDebt(_borrower, _asset, paybackFraction);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvessel.debt = _newDebt;\\r\\n\\t\\tvessel.coll = _newColl;\\r\\n\\t\\t_updateStakeAndTotalStakes(_asset, _borrower);\\r\\n\\r\\n\\t\\temit VesselUpdated(_asset, _borrower, _newDebt, _newColl, vessel.stake, VesselManagerOperation.redeemCollateral);\\r\\n\\t}\\r\\n\\r\\n\\tfunction finalizeRedemption(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _receiver,\\r\\n\\t\\tuint256 _debtToRedeem,\\r\\n\\t\\tuint256 _assetFeeAmount,\\r\\n\\t\\tuint256 _assetRedeemedAmount\\r\\n\\t) external override onlyVesselManagerOperations {\\r\\n\\t\\t// Send the asset fee\\r\\n\\t\\tif (_assetFeeAmount != 0) {\\r\\n\\t\\t\\taddress destination = IFeeCollector(feeCollector).getProtocolRevenueDestination();\\r\\n\\t\\t\\tIActivePool(activePool).sendAsset(_asset, destination, _assetFeeAmount);\\r\\n\\t\\t\\tIFeeCollector(feeCollector).handleRedemptionFee(_asset, _assetFeeAmount);\\r\\n\\t\\t}\\r\\n\\t\\t// Burn the total debt tokens that is cancelled with debt, and send the redeemed asset to msg.sender\\r\\n\\t\\tIDebtToken(debtToken).burn(_receiver, _debtToRedeem);\\r\\n\\t\\t// Update Active Pool, and send asset to account\\r\\n\\t\\tuint256 collToSendToRedeemer = _assetRedeemedAmount - _assetFeeAmount;\\r\\n\\t\\tIActivePool(activePool).decreaseDebt(_asset, _debtToRedeem);\\r\\n\\t\\tIActivePool(activePool).sendAsset(_asset, _receiver, collToSendToRedeemer);\\r\\n\\t}\\r\\n\\r\\n\\tfunction updateBaseRateFromRedemption(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\tuint256 _assetDrawn,\\r\\n\\t\\tuint256 _price,\\r\\n\\t\\tuint256 _totalDebtTokenSupply\\r\\n\\t) external override onlyVesselManagerOperations returns (uint256) {\\r\\n\\t\\tuint256 decayedBaseRate = _calcDecayedBaseRate(_asset);\\r\\n\\t\\tuint256 redeemedDebtFraction = (_assetDrawn * _price) / _totalDebtTokenSupply;\\r\\n\\t\\tuint256 newBaseRate = decayedBaseRate + (redeemedDebtFraction / BETA);\\r\\n\\t\\tnewBaseRate = GravitaMath._min(newBaseRate, DECIMAL_PRECISION);\\r\\n\\t\\tassert(newBaseRate != 0);\\r\\n\\t\\tbaseRate[_asset] = newBaseRate;\\r\\n\\t\\temit BaseRateUpdated(_asset, newBaseRate);\\r\\n\\t\\t_updateLastFeeOpTime(_asset);\\r\\n\\t\\treturn newBaseRate;\\r\\n\\t}\\r\\n\\r\\n\\tfunction applyPendingRewards(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _borrower\\r\\n\\t) external override nonReentrant onlyVesselManagerOperationsOrBorrowerOperations {\\r\\n\\t\\treturn _applyPendingRewards(_asset, _borrower);\\r\\n\\t}\\r\\n\\r\\n\\t// Move a Vessel's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool\\r\\n\\tfunction movePendingVesselRewardsToActivePool(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\tuint256 _debt,\\r\\n\\t\\tuint256 _assetAmount\\r\\n\\t) external override onlyVesselManagerOperations {\\r\\n\\t\\t_movePendingVesselRewardsToActivePool(_asset, _debt, _assetAmount);\\r\\n\\t}\\r\\n\\r\\n\\t// Update borrower's snapshots of L_Colls and L_Debts to reflect the current values\\r\\n\\tfunction updateVesselRewardSnapshots(address _asset, address _borrower) external override onlyBorrowerOperations {\\r\\n\\t\\treturn _updateVesselRewardSnapshots(_asset, _borrower);\\r\\n\\t}\\r\\n\\r\\n\\tfunction updateStakeAndTotalStakes(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _borrower\\r\\n\\t) external override onlyBorrowerOperations returns (uint256) {\\r\\n\\t\\treturn _updateStakeAndTotalStakes(_asset, _borrower);\\r\\n\\t}\\r\\n\\r\\n\\tfunction removeStake(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _borrower\\r\\n\\t) external override onlyVesselManagerOperationsOrBorrowerOperations {\\r\\n\\t\\treturn _removeStake(_asset, _borrower);\\r\\n\\t}\\r\\n\\r\\n\\tfunction redistributeDebtAndColl(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\tuint256 _debt,\\r\\n\\t\\tuint256 _coll,\\r\\n\\t\\tuint256 _debtToOffset,\\r\\n\\t\\tuint256 _collToSendToStabilityPool\\r\\n\\t) external override nonReentrant onlyVesselManagerOperations {\\r\\n\\t\\tIStabilityPool(stabilityPool).offset(_debtToOffset, _asset, _collToSendToStabilityPool);\\r\\n\\r\\n\\t\\tif (_debt == 0) {\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\t\\t/*\\r\\n\\t\\t * Add distributed coll and debt rewards-per-unit-staked to the running totals. Division uses a \\\"feedback\\\"\\r\\n\\t\\t * error correction, to keep the cumulative error low in the running totals L_Colls and L_Debts:\\r\\n\\t\\t *\\r\\n\\t\\t * 1) Form numerators which compensate for the floor division errors that occurred the last time this\\r\\n\\t\\t * function was called.\\r\\n\\t\\t * 2) Calculate \\\"per-unit-staked\\\" ratios.\\r\\n\\t\\t * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\\r\\n\\t\\t * 4) Store these errors for use in the next correction when this function is called.\\r\\n\\t\\t * 5) Note: static analysis tools complain about this \\\"division before multiplication\\\", however, it is intended.\\r\\n\\t\\t */\\r\\n\\t\\tuint256 collNumerator = (_coll * DECIMAL_PRECISION) + lastCollError_Redistribution[_asset];\\r\\n\\t\\tuint256 debtNumerator = (_debt * DECIMAL_PRECISION) + lastDebtError_Redistribution[_asset];\\r\\n\\r\\n\\t\\t// Get the per-unit-staked terms\\r\\n\\t\\tuint256 assetStakes = totalStakes[_asset];\\r\\n\\t\\tuint256 collRewardPerUnitStaked = collNumerator / assetStakes;\\r\\n\\t\\tuint256 debtRewardPerUnitStaked = debtNumerator / assetStakes;\\r\\n\\r\\n\\t\\tlastCollError_Redistribution[_asset] = collNumerator - (collRewardPerUnitStaked * assetStakes);\\r\\n\\t\\tlastDebtError_Redistribution[_asset] = debtNumerator - (debtRewardPerUnitStaked * assetStakes);\\r\\n\\r\\n\\t\\t// Add per-unit-staked terms to the running totals\\r\\n\\t\\tuint256 liquidatedColl = L_Colls[_asset] + collRewardPerUnitStaked;\\r\\n\\t\\tuint256 liquidatedDebt = L_Debts[_asset] + debtRewardPerUnitStaked;\\r\\n\\t\\tL_Colls[_asset] = liquidatedColl;\\r\\n\\t\\tL_Debts[_asset] = liquidatedDebt;\\r\\n\\t\\temit LTermsUpdated(_asset, liquidatedColl, liquidatedDebt);\\r\\n\\r\\n\\t\\tIActivePool(activePool).decreaseDebt(_asset, _debt);\\r\\n\\t\\tIDefaultPool(defaultPool).increaseDebt(_asset, _debt);\\r\\n\\t\\tIActivePool(activePool).sendAsset(_asset, defaultPool, _coll);\\r\\n\\t}\\r\\n\\r\\n\\tfunction updateSystemSnapshots_excludeCollRemainder(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\tuint256 _collRemainder\\r\\n\\t) external onlyVesselManagerOperations {\\r\\n\\t\\tuint256 totalStakesCached = totalStakes[_asset];\\r\\n\\t\\ttotalStakesSnapshot[_asset] = totalStakesCached;\\r\\n\\t\\tuint256 activeColl = IActivePool(activePool).getAssetBalance(_asset);\\r\\n\\t\\tuint256 liquidatedColl = IDefaultPool(defaultPool).getAssetBalance(_asset);\\r\\n\\t\\tuint256 _totalCollateralSnapshot = activeColl - _collRemainder + liquidatedColl;\\r\\n\\t\\ttotalCollateralSnapshot[_asset] = _totalCollateralSnapshot;\\r\\n\\t\\temit SystemSnapshotsUpdated(_asset, totalStakesCached, _totalCollateralSnapshot);\\r\\n\\t}\\r\\n\\r\\n\\tfunction closeVessel(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _borrower\\r\\n\\t) external override onlyVesselManagerOperationsOrBorrowerOperations {\\r\\n\\t\\treturn _closeVessel(_asset, _borrower, Status.closedByOwner);\\r\\n\\t}\\r\\n\\r\\n\\tfunction closeVesselLiquidation(address _asset, address _borrower) external override onlyVesselManagerOperations {\\r\\n\\t\\t_closeVessel(_asset, _borrower, Status.closedByLiquidation);\\r\\n\\t\\tIFeeCollector(feeCollector).liquidateDebt(_borrower, _asset);\\r\\n\\t\\temit VesselUpdated(_asset, _borrower, 0, 0, 0, VesselManagerOperation.liquidateInNormalMode);\\r\\n\\t}\\r\\n\\r\\n\\tfunction sendGasCompensation(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _liquidator,\\r\\n\\t\\tuint256 _debtTokenAmount,\\r\\n\\t\\tuint256 _assetAmount\\r\\n\\t) external nonReentrant onlyVesselManagerOperations {\\r\\n\\t\\tif (_debtTokenAmount != 0) {\\r\\n\\t\\t\\tIDebtToken(debtToken).returnFromPool(gasPoolAddress, _liquidator, _debtTokenAmount);\\r\\n\\t\\t}\\r\\n\\t\\tif (_assetAmount != 0) {\\r\\n\\t\\t\\tIActivePool(activePool).sendAsset(_asset, _liquidator, _assetAmount);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t// Internal functions ---------------------------------------------------------------------------------------------\\r\\n\\r\\n\\tfunction _redeemCloseVessel(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _borrower,\\r\\n\\t\\tuint256 _debtTokenAmount,\\r\\n\\t\\tuint256 _assetAmount\\r\\n\\t) internal {\\r\\n\\t\\tIDebtToken(debtToken).burn(gasPoolAddress, _debtTokenAmount);\\r\\n\\t\\t// Update Active Pool, and send asset to account\\r\\n\\t\\tIActivePool(activePool).decreaseDebt(_asset, _debtTokenAmount);\\r\\n\\t\\t// send asset from Active Pool to CollSurplus Pool\\r\\n\\t\\tICollSurplusPool(collSurplusPool).accountSurplus(_asset, _borrower, _assetAmount);\\r\\n\\t\\tIActivePool(activePool).sendAsset(_asset, collSurplusPool, _assetAmount);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _movePendingVesselRewardsToActivePool(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\tuint256 _debtTokenAmount,\\r\\n\\t\\tuint256 _assetAmount\\r\\n\\t) internal {\\r\\n\\t\\tIDefaultPool(defaultPool).decreaseDebt(_asset, _debtTokenAmount);\\r\\n\\t\\tIActivePool(activePool).increaseDebt(_asset, _debtTokenAmount);\\r\\n\\t\\tIDefaultPool(defaultPool).sendAssetToActivePool(_asset, _assetAmount);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _getCurrentVesselAmounts(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _borrower\\r\\n\\t) internal view returns (uint256 coll, uint256 debt) {\\r\\n\\t\\tuint256 pendingCollReward = getPendingAssetReward(_asset, _borrower);\\r\\n\\t\\tuint256 pendingDebtReward = getPendingDebtTokenReward(_asset, _borrower);\\r\\n\\t\\tVessel memory vessel = Vessels[_borrower][_asset];\\r\\n\\t\\tcoll = vessel.coll + pendingCollReward;\\r\\n\\t\\tdebt = vessel.debt + pendingDebtReward;\\r\\n\\t}\\r\\n\\r\\n\\t// Add the borrowers's coll and debt rewards earned from redistributions, to their Vessel\\r\\n\\tfunction _applyPendingRewards(address _asset, address _borrower) internal {\\r\\n\\t\\tif (!hasPendingRewards(_asset, _borrower)) {\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Compute pending rewards\\r\\n\\t\\tuint256 pendingCollReward = getPendingAssetReward(_asset, _borrower);\\r\\n\\t\\tuint256 pendingDebtReward = getPendingDebtTokenReward(_asset, _borrower);\\r\\n\\r\\n\\t\\t// Apply pending rewards to vessel's state\\r\\n\\t\\tVessel storage vessel = Vessels[_borrower][_asset];\\r\\n\\t\\tvessel.coll = vessel.coll + pendingCollReward;\\r\\n\\t\\tvessel.debt = vessel.debt + pendingDebtReward;\\r\\n\\r\\n\\t\\t_updateVesselRewardSnapshots(_asset, _borrower);\\r\\n\\r\\n\\t\\t// Transfer from DefaultPool to ActivePool\\r\\n\\t\\t_movePendingVesselRewardsToActivePool(_asset, pendingDebtReward, pendingCollReward);\\r\\n\\r\\n\\t\\temit VesselUpdated(\\r\\n\\t\\t\\t_asset,\\r\\n\\t\\t\\t_borrower,\\r\\n\\t\\t\\tvessel.debt,\\r\\n\\t\\t\\tvessel.coll,\\r\\n\\t\\t\\tvessel.stake,\\r\\n\\t\\t\\tVesselManagerOperation.applyPendingRewards\\r\\n\\t\\t);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _updateVesselRewardSnapshots(address _asset, address _borrower) internal {\\r\\n\\t\\tuint256 liquidatedColl = L_Colls[_asset];\\r\\n\\t\\tuint256 liquidatedDebt = L_Debts[_asset];\\r\\n\\t\\tRewardSnapshot storage snapshot = rewardSnapshots[_borrower][_asset];\\r\\n\\t\\tsnapshot.asset = liquidatedColl;\\r\\n\\t\\tsnapshot.debt = liquidatedDebt;\\r\\n\\t\\temit VesselSnapshotsUpdated(_asset, liquidatedColl, liquidatedDebt);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _removeStake(address _asset, address _borrower) internal {\\r\\n\\t\\tVessel storage vessel = Vessels[_borrower][_asset];\\r\\n\\t\\ttotalStakes[_asset] -= vessel.stake;\\r\\n\\t\\tvessel.stake = 0;\\r\\n\\t}\\r\\n\\r\\n\\t// Update borrower's stake based on their latest collateral value\\r\\n\\tfunction _updateStakeAndTotalStakes(address _asset, address _borrower) internal returns (uint256) {\\r\\n\\t\\tVessel storage vessel = Vessels[_borrower][_asset];\\r\\n\\t\\tuint256 newStake = _computeNewStake(_asset, vessel.coll);\\r\\n\\t\\tuint256 oldStake = vessel.stake;\\r\\n\\t\\tvessel.stake = newStake;\\r\\n\\t\\tuint256 newTotal = totalStakes[_asset] - oldStake + newStake;\\r\\n\\t\\ttotalStakes[_asset] = newTotal;\\r\\n\\t\\temit TotalStakesUpdated(_asset, newTotal);\\r\\n\\t\\treturn newStake;\\r\\n\\t}\\r\\n\\r\\n\\t// Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation\\r\\n\\tfunction _computeNewStake(address _asset, uint256 _coll) internal view returns (uint256 stake) {\\r\\n\\t\\tuint256 assetColl = totalCollateralSnapshot[_asset];\\r\\n\\t\\tif (assetColl == 0) {\\r\\n\\t\\t\\tstake = _coll;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tuint256 assetStakes = totalStakesSnapshot[_asset];\\r\\n\\t\\t\\t/*\\r\\n\\t\\t\\t * The following assert() holds true because:\\r\\n\\t\\t\\t * - The system always contains >= 1 vessel\\r\\n\\t\\t\\t * - When we close or liquidate a vessel, we redistribute the pending rewards, so if all vessels were closed/liquidated,\\r\\n\\t\\t\\t * rewards would\u2019ve been emptied and totalCollateralSnapshot would be zero too.\\r\\n\\t\\t\\t */\\r\\n\\t\\t\\tassert(assetStakes != 0);\\r\\n\\t\\t\\tstake = (_coll * assetStakes) / assetColl;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction _closeVessel(address _asset, address _borrower, Status closedStatus) internal {\\r\\n\\t\\tassert(closedStatus != Status.nonExistent && closedStatus != Status.active);\\r\\n\\r\\n\\t\\tuint256 VesselOwnersArrayLength = VesselOwners[_asset].length;\\r\\n\\t\\tif (VesselOwnersArrayLength <= 1 || ISortedVessels(sortedVessels).getSize(_asset) <= 1) {\\r\\n\\t\\t\\trevert VesselManager__OnlyOneVessel();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tVessel storage vessel = Vessels[_borrower][_asset];\\r\\n\\t\\tvessel.status = closedStatus;\\r\\n\\t\\tvessel.coll = 0;\\r\\n\\t\\tvessel.debt = 0;\\r\\n\\r\\n\\t\\tRewardSnapshot storage rewardSnapshot = rewardSnapshots[_borrower][_asset];\\r\\n\\t\\trewardSnapshot.asset = 0;\\r\\n\\t\\trewardSnapshot.debt = 0;\\r\\n\\r\\n\\t\\t_removeVesselOwner(_asset, _borrower, VesselOwnersArrayLength);\\r\\n\\t\\tISortedVessels(sortedVessels).remove(_asset, _borrower);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _removeVesselOwner(address _asset, address _borrower, uint256 VesselOwnersArrayLength) internal {\\r\\n\\t\\tVessel memory vessel = Vessels[_borrower][_asset];\\r\\n\\t\\tassert(vessel.status != Status.nonExistent && vessel.status != Status.active);\\r\\n\\r\\n\\t\\tuint128 index = vessel.arrayIndex;\\r\\n\\t\\tuint256 length = VesselOwnersArrayLength;\\r\\n\\t\\tuint256 idxLast = length - 1;\\r\\n\\r\\n\\t\\tassert(index <= idxLast);\\r\\n\\r\\n\\t\\taddress[] storage vesselAssetOwners = VesselOwners[_asset];\\r\\n\\t\\taddress addressToMove = vesselAssetOwners[idxLast];\\r\\n\\r\\n\\t\\tvesselAssetOwners[index] = addressToMove;\\r\\n\\t\\tVessels[addressToMove][_asset].arrayIndex = index;\\r\\n\\t\\temit VesselIndexUpdated(_asset, addressToMove, index);\\r\\n\\r\\n\\t\\tvesselAssetOwners.pop();\\r\\n\\t}\\r\\n\\r\\n\\tfunction _calcRedemptionRate(address _asset, uint256 _baseRate) internal view returns (uint256) {\\r\\n\\t\\treturn GravitaMath._min(IAdminContract(adminContract).getRedemptionFeeFloor(_asset) + _baseRate, DECIMAL_PRECISION);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _calcRedemptionFee(uint256 _redemptionRate, uint256 _assetDraw) internal pure returns (uint256) {\\r\\n\\t\\tuint256 redemptionFee = (_redemptionRate * _assetDraw) / DECIMAL_PRECISION;\\r\\n\\t\\tif (redemptionFee >= _assetDraw) {\\r\\n\\t\\t\\trevert VesselManager__FeeBiggerThanAssetDraw();\\r\\n\\t\\t}\\r\\n\\t\\treturn redemptionFee;\\r\\n\\t}\\r\\n\\r\\n\\tfunction _updateLastFeeOpTime(address _asset) internal {\\r\\n\\t\\tuint256 timePassed = block.timestamp - lastFeeOperationTime[_asset];\\r\\n\\t\\tif (timePassed >= SECONDS_IN_ONE_MINUTE) {\\r\\n\\t\\t\\t// Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.\\r\\n\\t\\t\\tlastFeeOperationTime[_asset] = block.timestamp;\\r\\n\\t\\t\\temit LastFeeOpTimeUpdated(_asset, block.timestamp);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction _calcDecayedBaseRate(address _asset) internal view returns (uint256) {\\r\\n\\t\\tuint256 minutesPassed = _minutesPassedSinceLastFeeOp(_asset);\\r\\n\\t\\tuint256 decayFactor = GravitaMath._decPow(MINUTE_DECAY_FACTOR, minutesPassed);\\r\\n\\t\\treturn (baseRate[_asset] * decayFactor) / DECIMAL_PRECISION;\\r\\n\\t}\\r\\n\\r\\n\\tfunction _minutesPassedSinceLastFeeOp(address _asset) internal view returns (uint256) {\\r\\n\\t\\treturn (block.timestamp - lastFeeOperationTime[_asset]) / SECONDS_IN_ONE_MINUTE;\\r\\n\\t}\\r\\n\\r\\n\\t// --- Vessel property getters --------------------------------------------------------------------------------------\\r\\n\\r\\n\\tfunction getVesselStatus(address _asset, address _borrower) public view override returns (uint256) {\\r\\n\\t\\treturn uint256(Vessels[_borrower][_asset].status);\\r\\n\\t}\\r\\n\\r\\n\\tfunction getVesselStake(address _asset, address _borrower) external view override returns (uint256) {\\r\\n\\t\\treturn Vessels[_borrower][_asset].stake;\\r\\n\\t}\\r\\n\\r\\n\\tfunction getVesselDebt(address _asset, address _borrower) external view override returns (uint256) {\\r\\n\\t\\treturn Vessels[_borrower][_asset].debt;\\r\\n\\t}\\r\\n\\r\\n\\tfunction getVesselColl(address _asset, address _borrower) external view override returns (uint256) {\\r\\n\\t\\treturn Vessels[_borrower][_asset].coll;\\r\\n\\t}\\r\\n\\r\\n\\tfunction getVesselOwnersCount(address _asset) external view override returns (uint256) {\\r\\n\\t\\treturn VesselOwners[_asset].length;\\r\\n\\t}\\r\\n\\r\\n\\tfunction getVesselFromVesselOwnersArray(address _asset, uint256 _index) external view override returns (address) {\\r\\n\\t\\treturn VesselOwners[_asset][_index];\\r\\n\\t}\\r\\n\\r\\n\\t// --- Vessel property setters, called by Gravita's BorrowerOperations/VMRedemptions/VMLiquidations ---------------\\r\\n\\r\\n\\tfunction setVesselStatus(address _asset, address _borrower, uint256 _num) external override onlyBorrowerOperations {\\r\\n\\t\\tVessels[_borrower][_asset].status = Status(_num);\\r\\n\\t}\\r\\n\\r\\n\\tfunction increaseVesselColl(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _borrower,\\r\\n\\t\\tuint256 _collIncrease\\r\\n\\t) external override onlyBorrowerOperations returns (uint256 newColl) {\\r\\n\\t\\tVessel storage vessel = Vessels[_borrower][_asset];\\r\\n\\t\\tnewColl = vessel.coll + _collIncrease;\\r\\n\\t\\tvessel.coll = newColl;\\r\\n\\t}\\r\\n\\r\\n\\tfunction decreaseVesselColl(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _borrower,\\r\\n\\t\\tuint256 _collDecrease\\r\\n\\t) external override onlyBorrowerOperations returns (uint256 newColl) {\\r\\n\\t\\tVessel storage vessel = Vessels[_borrower][_asset];\\r\\n\\t\\tnewColl = vessel.coll - _collDecrease;\\r\\n\\t\\tvessel.coll = newColl;\\r\\n\\t}\\r\\n\\r\\n\\tfunction increaseVesselDebt(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _borrower,\\r\\n\\t\\tuint256 _debtIncrease\\r\\n\\t) external override onlyBorrowerOperations returns (uint256 newDebt) {\\r\\n\\t\\tVessel storage vessel = Vessels[_borrower][_asset];\\r\\n\\t\\tnewDebt = vessel.debt + _debtIncrease;\\r\\n\\t\\tvessel.debt = newDebt;\\r\\n\\t}\\r\\n\\r\\n\\tfunction decreaseVesselDebt(\\r\\n\\t\\taddress _asset,\\r\\n\\t\\taddress _borrower,\\r\\n\\t\\tuint256 _debtDecrease\\r\\n\\t) external override onlyBorrowerOperations returns (uint256) {\\r\\n\\t\\tVessel storage vessel = Vessels[_borrower][_asset];\\r\\n\\t\\tuint256 oldDebt = vessel.debt;\\r\\n\\t\\tif (_debtDecrease == 0) {\\r\\n\\t\\t\\treturn oldDebt; // no changes\\r\\n\\t\\t}\\r\\n\\t\\tuint256 paybackFraction = (_debtDecrease * 1 ether) / oldDebt;\\r\\n\\t\\tuint256 newDebt = oldDebt - _debtDecrease;\\r\\n\\t\\tvessel.debt = newDebt;\\r\\n\\t\\tif (paybackFraction != 0) {\\r\\n\\t\\t\\tIFeeCollector(feeCollector).decreaseDebt(_borrower, _asset, paybackFraction);\\r\\n\\t\\t}\\r\\n\\t\\treturn newDebt;\\r\\n\\t}\\r\\n\\r\\n\\tfunction authorizeUpgrade(address newImplementation) public {\\r\\n\\t\\t_authorizeUpgrade(newImplementation);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _authorizeUpgrade(address) internal override onlyOwner {}\\r\\n}\\r\\n\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"VesselManager__FeeBiggerThanAssetDraw\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VesselManager__OnlyBorrowerOperations\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VesselManager__OnlyOneVessel\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VesselManager__OnlyVesselManagerOperations\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VesselManager__OnlyVesselManagerOperationsOrBorrowerOperations\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_baseRate\",\"type\":\"uint256\"}],\"name\":\"BaseRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_L_Coll\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_L_Debt\",\"type\":\"uint256\"}],\"name\":\"LTermsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_lastFeeOpTime\",\"type\":\"uint256\"}],\"name\":\"LastFeeOpTimeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalStakesSnapshot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalCollateralSnapshot\",\"type\":\"uint256\"}],\"name\":\"SystemSnapshotsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newTotalStakes\",\"type\":\"uint256\"}],\"name\":\"TotalStakesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newIndex\",\"type\":\"uint256\"}],\"name\":\"VesselIndexUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_L_Coll\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_L_Debt\",\"type\":\"uint256\"}],\"name\":\"VesselSnapshotsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_debt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_coll\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum IVesselManager.VesselManagerOperation\",\"name\":\"_operation\",\"type\":\"uint8\"}],\"name\":\"VesselUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BETA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DECIMAL_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"L_Colls\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"L_Debts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINUTE_DECAY_FACTOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDS_IN_ONE_MINUTE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"VesselOwners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Vessels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coll\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"enum IVesselManager.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint128\",\"name\":\"arrayIndex\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activePool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"addVesselOwnerToArray\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"applyPendingRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"authorizeUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"baseRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowerOperations\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"checkRecoveryMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"closeVessel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"closeVesselLiquidation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collSurplusPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"communityIssuance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"debtToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collDecrease\",\"type\":\"uint256\"}],\"name\":\"decreaseVesselColl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newColl\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_debtDecrease\",\"type\":\"uint256\"}],\"name\":\"decreaseVesselDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newColl\",\"type\":\"uint256\"}],\"name\":\"executeFullRedemption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newColl\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newNICR\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_upperPartialRedemptionHint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lowerPartialRedemptionHint\",\"type\":\"address\"}],\"name\":\"executePartialRedemption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_debtToRedeem\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_assetFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_assetRedeemedAmount\",\"type\":\"uint256\"}],\"name\":\"finalizeRedemption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasPoolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_debt\",\"type\":\"uint256\"}],\"name\":\"getBorrowingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getBorrowingRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"getCurrentICR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"getEntireDebtAndColl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coll\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingDebtReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingCollReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getEntireSystemColl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"entireSystemColl\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getEntireSystemDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"entireSystemDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"getNominalICR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"getPendingAssetReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"getPendingDebtTokenReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetDraw\",\"type\":\"uint256\"}],\"name\":\"getRedemptionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetDraw\",\"type\":\"uint256\"}],\"name\":\"getRedemptionFeeWithDecay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getRedemptionRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getRedemptionRateWithDecay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"getTCR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"getVesselColl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"getVesselDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getVesselFromVesselOwnersArray\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getVesselOwnersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"getVesselStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"getVesselStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"grvtStaking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"hasPendingRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collIncrease\",\"type\":\"uint256\"}],\"name\":\"increaseVesselColl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newColl\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_debtIncrease\",\"type\":\"uint256\"}],\"name\":\"increaseVesselDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSetupInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_firstRedemptionHint\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"isValidFirstRedemptionHint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"isVesselActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastCollError_Redistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastDebtError_Redistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastFeeOperationTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_assetAmount\",\"type\":\"uint256\"}],\"name\":\"movePendingVesselRewardsToActivePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_coll\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_debtToOffset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_collToSendToStabilityPool\",\"type\":\"uint256\"}],\"name\":\"redistributeDebtAndColl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"removeStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardSnapshots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"asset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_debtTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_assetAmount\",\"type\":\"uint256\"}],\"name\":\"sendGasCompensation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"setVesselStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sortedVessels\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stabilityPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timelockAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalCollateralSnapshot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalStakesSnapshot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetDrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalDebtTokenSupply\",\"type\":\"uint256\"}],\"name\":\"updateBaseRateFromRedemption\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"updateStakeAndTotalStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collRemainder\",\"type\":\"uint256\"}],\"name\":\"updateSystemSnapshots_excludeCollRemainder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"updateVesselRewardSnapshots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vesselManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vesselManagerOperations\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VesselManager", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}