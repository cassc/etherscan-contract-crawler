{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20Upgradeable.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/interfaces/IERC4626Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (interfaces/IERC4626.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC4626 \\\"Tokenized Vault Standard\\\", as defined in\\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\\n *\\n * _Available since v4.7._\\n */\\ninterface IERC4626Upgradeable is IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed sender,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /**\\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\\n     *\\n     * - MUST be an ERC-20 token contract.\\n     * - MUST NOT revert.\\n     */\\n    function asset() external view returns (address assetTokenAddress);\\n\\n    /**\\n     * @dev Returns the total amount of the underlying asset that is \u201cmanaged\u201d by Vault.\\n     *\\n     * - SHOULD include any compounding that occurs from yield.\\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT revert.\\n     */\\n    function totalAssets() external view returns (uint256 totalManagedAssets);\\n\\n    /**\\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\\n     * through a deposit call.\\n     *\\n     * - MUST return a limited value if receiver is subject to some deposit limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\\n     * - MUST NOT revert.\\n     */\\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\\n     *   in the same transaction.\\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   deposit execution, and are accounted for during deposit.\\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n     */\\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\\n     * - MUST return a limited value if receiver is subject to some mint limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\\n     * - MUST NOT revert.\\n     */\\n    function maxMint(address receiver) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\\n     *   same transaction.\\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\\n     */\\n    function previewMint(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\\n     *   execution, and are accounted for during mint.\\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n     */\\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\\n     * Vault, through a withdraw call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\\n     *   called\\n     *   in the same transaction.\\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   withdraw execution, and are accounted for during withdraw.\\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\\n     * through a redeem call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\\n     *   same transaction.\\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\\n     */\\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   redeem execution, and are accounted for during redeem.\\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) external returns (uint256 assets);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[45] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.1) (token/ERC20/extensions/ERC4626.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20Upgradeable.sol\\\";\\nimport \\\"../utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"../../../interfaces/IERC4626Upgradeable.sol\\\";\\nimport \\\"../../../utils/math/MathUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the ERC4626 \\\"Tokenized Vault Standard\\\" as defined in\\n * https://eips.ethereum.org/EIPS/eip-4626[EIP-4626].\\n *\\n * This extension allows the minting and burning of \\\"shares\\\" (represented using the ERC20 inheritance) in exchange for\\n * underlying \\\"assets\\\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\\n * the ERC20 standard. Any additional extensions included along it would affect the \\\"shares\\\" token represented by this\\n * contract and not the \\\"assets\\\" token which is an independent contract.\\n *\\n * CAUTION: When the vault is empty or nearly empty, deposits are at high risk of being stolen through frontrunning with\\n * a \\\"donation\\\" to the vault that inflates the price of a share. This is variously known as a donation or inflation\\n * attack and is essentially a problem of slippage. Vault deployers can protect against this attack by making an initial\\n * deposit of a non-trivial amount of the asset, such that price manipulation becomes infeasible. Withdrawals may\\n * similarly be affected by slippage. Users can protect against this attack as well unexpected slippage in general by\\n * verifying the amount received is as expected, using a wrapper that performs these checks such as\\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\\n *\\n * _Available since v4.7._\\n */\\nabstract contract ERC4626Upgradeable is Initializable, ERC20Upgradeable, IERC4626Upgradeable {\\n    using MathUpgradeable for uint256;\\n\\n    IERC20Upgradeable private _asset;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC20 or ERC777).\\n     */\\n    function __ERC4626_init(IERC20Upgradeable asset_) internal onlyInitializing {\\n        __ERC4626_init_unchained(asset_);\\n    }\\n\\n    function __ERC4626_init_unchained(IERC20Upgradeable asset_) internal onlyInitializing {\\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\\n        _decimals = success ? assetDecimals : super.decimals();\\n        _asset = asset_;\\n    }\\n\\n    /**\\n     * @dev Attempts to fetch the asset decimals. A return value of false indicates that the attempt failed in some way.\\n     */\\n    function _tryGetAssetDecimals(IERC20Upgradeable asset_) private view returns (bool, uint8) {\\n        (bool success, bytes memory encodedDecimals) = address(asset_).staticcall(\\n            abi.encodeWithSelector(IERC20MetadataUpgradeable.decimals.selector)\\n        );\\n        if (success && encodedDecimals.length >= 32) {\\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\\n            if (returnedDecimals <= type(uint8).max) {\\n                return (true, uint8(returnedDecimals));\\n            }\\n        }\\n        return (false, 0);\\n    }\\n\\n    /**\\n     * @dev Decimals are read from the underlying asset in the constructor and cached. If this fails (e.g., the asset\\n     * has not been created yet), the cached value is set to a default obtained by `super.decimals()` (which depends on\\n     * inheritance but is most likely 18). Override this function in order to set a guaranteed hardcoded value.\\n     * See {IERC20Metadata-decimals}.\\n     */\\n    function decimals() public view virtual override(IERC20MetadataUpgradeable, ERC20Upgradeable) returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /** @dev See {IERC4626-asset}. */\\n    function asset() public view virtual override returns (address) {\\n        return address(_asset);\\n    }\\n\\n    /** @dev See {IERC4626-totalAssets}. */\\n    function totalAssets() public view virtual override returns (uint256) {\\n        return _asset.balanceOf(address(this));\\n    }\\n\\n    /** @dev See {IERC4626-convertToShares}. */\\n    function convertToShares(uint256 assets) public view virtual override returns (uint256 shares) {\\n        return _convertToShares(assets, MathUpgradeable.Rounding.Down);\\n    }\\n\\n    /** @dev See {IERC4626-convertToAssets}. */\\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256 assets) {\\n        return _convertToAssets(shares, MathUpgradeable.Rounding.Down);\\n    }\\n\\n    /** @dev See {IERC4626-maxDeposit}. */\\n    function maxDeposit(address) public view virtual override returns (uint256) {\\n        return _isVaultCollateralized() ? type(uint256).max : 0;\\n    }\\n\\n    /** @dev See {IERC4626-maxMint}. */\\n    function maxMint(address) public view virtual override returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    /** @dev See {IERC4626-maxWithdraw}. */\\n    function maxWithdraw(address owner) public view virtual override returns (uint256) {\\n        return _convertToAssets(balanceOf(owner), MathUpgradeable.Rounding.Down);\\n    }\\n\\n    /** @dev See {IERC4626-maxRedeem}. */\\n    function maxRedeem(address owner) public view virtual override returns (uint256) {\\n        return balanceOf(owner);\\n    }\\n\\n    /** @dev See {IERC4626-previewDeposit}. */\\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\\n        return _convertToShares(assets, MathUpgradeable.Rounding.Down);\\n    }\\n\\n    /** @dev See {IERC4626-previewMint}. */\\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\\n        return _convertToAssets(shares, MathUpgradeable.Rounding.Up);\\n    }\\n\\n    /** @dev See {IERC4626-previewWithdraw}. */\\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\\n        return _convertToShares(assets, MathUpgradeable.Rounding.Up);\\n    }\\n\\n    /** @dev See {IERC4626-previewRedeem}. */\\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\\n        return _convertToAssets(shares, MathUpgradeable.Rounding.Down);\\n    }\\n\\n    /** @dev See {IERC4626-deposit}. */\\n    function deposit(uint256 assets, address receiver) public virtual override returns (uint256) {\\n        require(assets <= maxDeposit(receiver), \\\"ERC4626: deposit more than max\\\");\\n\\n        uint256 shares = previewDeposit(assets);\\n        _deposit(_msgSender(), receiver, assets, shares);\\n\\n        return shares;\\n    }\\n\\n    /** @dev See {IERC4626-mint}.\\n     *\\n     * As opposed to {deposit}, minting is allowed even if the vault is in a state where the price of a share is zero.\\n     * In this case, the shares will be minted without requiring any assets to be deposited.\\n     */\\n    function mint(uint256 shares, address receiver) public virtual override returns (uint256) {\\n        require(shares <= maxMint(receiver), \\\"ERC4626: mint more than max\\\");\\n\\n        uint256 assets = previewMint(shares);\\n        _deposit(_msgSender(), receiver, assets, shares);\\n\\n        return assets;\\n    }\\n\\n    /** @dev See {IERC4626-withdraw}. */\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) public virtual override returns (uint256) {\\n        require(assets <= maxWithdraw(owner), \\\"ERC4626: withdraw more than max\\\");\\n\\n        uint256 shares = previewWithdraw(assets);\\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\\n\\n        return shares;\\n    }\\n\\n    /** @dev See {IERC4626-redeem}. */\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public virtual override returns (uint256) {\\n        require(shares <= maxRedeem(owner), \\\"ERC4626: redeem more than max\\\");\\n\\n        uint256 assets = previewRedeem(shares);\\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\\n\\n        return assets;\\n    }\\n\\n    /**\\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\\n     *\\n     * Will revert if assets > 0, totalSupply > 0 and totalAssets = 0. That corresponds to a case where any asset\\n     * would represent an infinite amount of shares.\\n     */\\n    function _convertToShares(uint256 assets, MathUpgradeable.Rounding rounding) internal view virtual returns (uint256 shares) {\\n        uint256 supply = totalSupply();\\n        return\\n            (assets == 0 || supply == 0)\\n                ? _initialConvertToShares(assets, rounding)\\n                : assets.mulDiv(supply, totalAssets(), rounding);\\n    }\\n\\n    /**\\n     * @dev Internal conversion function (from assets to shares) to apply when the vault is empty.\\n     *\\n     * NOTE: Make sure to keep this function consistent with {_initialConvertToAssets} when overriding it.\\n     */\\n    function _initialConvertToShares(\\n        uint256 assets,\\n        MathUpgradeable.Rounding /*rounding*/\\n    ) internal view virtual returns (uint256 shares) {\\n        return assets;\\n    }\\n\\n    /**\\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\\n     */\\n    function _convertToAssets(uint256 shares, MathUpgradeable.Rounding rounding) internal view virtual returns (uint256 assets) {\\n        uint256 supply = totalSupply();\\n        return\\n            (supply == 0) ? _initialConvertToAssets(shares, rounding) : shares.mulDiv(totalAssets(), supply, rounding);\\n    }\\n\\n    /**\\n     * @dev Internal conversion function (from shares to assets) to apply when the vault is empty.\\n     *\\n     * NOTE: Make sure to keep this function consistent with {_initialConvertToShares} when overriding it.\\n     */\\n    function _initialConvertToAssets(\\n        uint256 shares,\\n        MathUpgradeable.Rounding /*rounding*/\\n    ) internal view virtual returns (uint256 assets) {\\n        return shares;\\n    }\\n\\n    /**\\n     * @dev Deposit/mint common workflow.\\n     */\\n    function _deposit(\\n        address caller,\\n        address receiver,\\n        uint256 assets,\\n        uint256 shares\\n    ) internal virtual {\\n        // If _asset is ERC777, `transferFrom` can trigger a reenterancy BEFORE the transfer happens through the\\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\\n        // calls the vault, which is assumed not malicious.\\n        //\\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\\n        // assets are transferred and before the shares are minted, which is a valid state.\\n        // slither-disable-next-line reentrancy-no-eth\\n        SafeERC20Upgradeable.safeTransferFrom(_asset, caller, address(this), assets);\\n        _mint(receiver, shares);\\n\\n        emit Deposit(caller, receiver, assets, shares);\\n    }\\n\\n    /**\\n     * @dev Withdraw/redeem common workflow.\\n     */\\n    function _withdraw(\\n        address caller,\\n        address receiver,\\n        address owner,\\n        uint256 assets,\\n        uint256 shares\\n    ) internal virtual {\\n        if (caller != owner) {\\n            _spendAllowance(owner, caller, shares);\\n        }\\n\\n        // If _asset is ERC777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\\n        // calls the vault, which is assumed not malicious.\\n        //\\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\\n        // shares are burned and after the assets are transferred, which is a valid state.\\n        _burn(owner, shares);\\n        SafeERC20Upgradeable.safeTransfer(_asset, receiver, assets);\\n\\n        emit Withdraw(caller, receiver, owner, assets, shares);\\n    }\\n\\n    /**\\n     * @dev Checks if vault is \\\"healthy\\\" in the sense of having assets backing the circulating shares.\\n     */\\n    function _isVaultCollateralized() private view returns (bool) {\\n        return totalAssets() > 0 || totalSupply() == 0;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/draft-IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary MathUpgradeable {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSetUpgradeable {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/authority/Authority.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\\\";\\nimport \\\"./IAuthority.sol\\\";\\n\\n/**\\n * @title Authority Whitelist smart contract\\n * @notice this contract manages a whitelists for all the admins, borrowers and lenders\\n */\\ncontract Authority is OwnableUpgradeable, IAuthority {\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\n\\n    event BorrowerAdded(address indexed actor, address indexed borrower);\\n    event BorrowerRemoved(address indexed actor, address indexed borrower);\\n    event LenderAdded(address indexed actor, address indexed lender);\\n    event LenderRemoved(address indexed actor, address indexed lender);\\n    event AdminAdded(address indexed actor, address indexed admin);\\n    event AdminRemoved(address indexed actor, address indexed admin);\\n\\n    EnumerableSetUpgradeable.AddressSet whitelistedBorrowers;\\n    EnumerableSetUpgradeable.AddressSet whitelistedLenders;\\n    EnumerableSetUpgradeable.AddressSet admins;\\n\\n    /**\\n     * @notice Restricts function execution to the contract owner or admins\\n     * @dev Throws an error if the caller is not the owner or admin\\n     */\\n    modifier onlyOwnerOrAdmin() {\\n        require(owner() == msg.sender || admins.contains(msg.sender), \\\"Authority: caller is not the owner or admin\\\");\\n        _;\\n    }\\n\\n    /// @dev initializer\\n    function initialize() external initializer {\\n        __Ownable_init();\\n    }\\n\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @notice adds borrower address to the whitelist.\\n     * @param a address to add to the whitelist\\n     * @dev can only be called by the contract owner or admins\\n     */\\n    function addBorrower(address a) external onlyOwnerOrAdmin {\\n        if (whitelistedBorrowers.add(a)) {\\n            emit BorrowerAdded(msg.sender, a);\\n        }\\n    }\\n\\n    /**\\n     * @notice removes borrower address from the whitelist.\\n     * @param a address to remove from the whitelist\\n     * @dev can only be called by the contract owner or admins\\n     */\\n    function removeBorrower(address a) external onlyOwnerOrAdmin {\\n        if (whitelistedBorrowers.remove(a)) {\\n            emit BorrowerRemoved(msg.sender, a);\\n        }\\n    }\\n\\n    /**\\n     * @notice checks if the borrower address is in the whitelist.\\n     * @param a address to check\\n     * @return true if the address is in the whitelist\\n     */\\n    function isWhitelistedBorrower(address a) external view returns (bool) {\\n        return whitelistedBorrowers.contains(a);\\n    }\\n\\n    /**\\n     * @notice returns array of all whitelisted borrower addresses\\n     *\\n     */\\n    function allBorrowers() external view returns (address[] memory) {\\n        return whitelistedBorrowers.values();\\n    }\\n\\n    /**\\n     * @notice adds lenders address to the whitelist.\\n     * @param lender address to add to the whitelist\\n     */\\n    function addLender(address lender) external onlyOwnerOrAdmin {\\n        if (whitelistedLenders.add(lender)) {\\n            emit LenderAdded(msg.sender, lender);\\n        }\\n    }\\n\\n    /**\\n     * @notice removes lenders address from the whitelist.\\n     * @param lender address to remove from the whitelist\\n     */\\n    function removeLender(address lender) external onlyOwnerOrAdmin {\\n        if (whitelistedLenders.remove(lender)) {\\n            emit LenderRemoved(msg.sender, lender);\\n        }\\n    }\\n\\n    /**\\n     * @notice checks if the lender address is in the whitelist.\\n     * @param lender address to check\\n     * @return true if the address is in the whitelist\\n     */\\n    function isWhitelistedLender(address lender) external view returns (bool) {\\n        return whitelistedLenders.contains(lender);\\n    }\\n\\n    /// @notice returns array of all whitelisted lender addresses\\n    function allLenders() external view returns (address[] memory) {\\n        return whitelistedLenders.values();\\n    }\\n\\n    /**\\n     * @notice adds admin address to the list.\\n     * @param newAdmin address to add to the list\\n     */\\n    function addAdmin(address newAdmin) external onlyOwnerOrAdmin {\\n        if (admins.add(newAdmin)) {\\n            emit AdminAdded(msg.sender, newAdmin);\\n        }\\n    }\\n\\n    /**\\n     * @notice removes admin address from the list.\\n     * @param admin address to remove from the list\\n     */\\n    function removeAdmin(address admin) external onlyOwnerOrAdmin {\\n        if (admins.remove(admin)) {\\n            emit AdminRemoved(msg.sender, admin);\\n        }\\n    }\\n\\n    /**\\n     * @notice checks if the admin in the list.\\n     * @param a address to check\\n     * @return true if the address is in the list\\n     */\\n    function isAdmin(address a) external view returns (bool) {\\n        return admins.contains(a);\\n    }\\n\\n    /**\\n     * @notice returns array of all admin addresses\\n     */\\n    function allAdmins() external view returns (address[] memory) {\\n        return admins.values();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/authority/AuthorityAware.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport \\\"./IAuthority.sol\\\";\\n\\n/**\\n * @title Authority Whitelist smart contract\\n * @notice this contract manages a whitelists for all the admins, borrowers and lenders\\n */\\nabstract contract AuthorityAware is OwnableUpgradeable {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    IAuthority public authority;\\n\\n    bytes32[50] private __gaps;\\n\\n    modifier onlyOwnerOrAdmin() {\\n        _onlyOwnerOrAdmin();\\n        _;\\n    }\\n\\n    function _onlyOwnerOrAdmin() internal view {\\n        require(\\n            owner() == msg.sender || authority.isAdmin(msg.sender),\\n            \\\"AA:OA\\\" // \\\"AuthorityAware: caller is not the owner or admin\\\"\\n        );\\n    }\\n\\n    modifier onlyLender() { // only whitelisted lender\\n        require(\\n            authority.isWhitelistedLender(msg.sender),\\n            \\\"AA:L\\\" // \\\"AuthorityAware: caller is not a whitelisted lender\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyWhitelisted() {\\n        _onlyWhitelisted();\\n        _;\\n    }\\n\\n    function _onlyWhitelisted() internal view {\\n        require(\\n            owner() == msg.sender ||\\n                authority.isWhitelistedBorrower(msg.sender) ||\\n                authority.isWhitelistedLender(msg.sender) ||\\n                authority.isAdmin(msg.sender),\\n            \\\"AA:W\\\" // \\\"AuthorityAware: caller is not a whitelisted borrower or lender\\\"\\n        );\\n    }\\n\\n    function __AuthorityAware__init(address _authority) internal {\\n        authority = IAuthority(_authority);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/authority/IAuthority.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\n/**\\n * @title Authority Whitelist smart contract interface\\n * @notice this contract manages a whitelists for all the admins, borrowers and lenders\\n */\\ninterface IAuthority {\\n    function isWhitelistedBorrower(address a) external view returns (bool);\\n\\n    function isWhitelistedLender(address a) external view returns (bool);\\n\\n    function isAdmin(address a) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/factory/PoolFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\nimport \\\"../authority/AuthorityAware.sol\\\";\\nimport \\\"../pool/LendingPool.sol\\\";\\n\\ncontract PoolFactory is AuthorityAware {\\n    using Math for uint;\\n\\n    struct PoolRecord {\\n        string name;\\n        string tokenName;\\n        address poolAddress;\\n        address firstTrancheVaultAddress;\\n        address secondTrancheVaultAddress;\\n        address poolImplementationAddress;\\n        address trancheVaultImplementationAddress;\\n    }\\n\\n    uint private constant WAD = 10 ** 18;\\n\\n    event PoolCloned(address indexed addr, address implementationAddress);\\n    event TrancheVaultCloned(address indexed addr, address implementationAddress);\\n    event PoolDeployed(address indexed deployer, PoolRecord record);\\n\\n    address public poolImplementationAddress;\\n    address public trancheVaultImplementationAddress;\\n\\n    PoolRecord[] public poolRegistry;\\n\\n    address public feeSharingContractAddress;\\n\\n    /// @dev we need to track a nonce as salt for each implementation\\n    mapping(address => uint256) public nonces;\\n    mapping(address => bool) public prevDeployedTranche;\\n\\n    function initialize(address _authority) public initializer {\\n        __Ownable_init();\\n        __AuthorityAware__init(_authority);\\n    }\\n\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /// @notice it should be expressed that updating implemetation will make nonces at prior implementation stale\\n    /// @dev sets implementation for future pool deployments\\n    function setPoolImplementation(address implementation) external onlyOwnerOrAdmin {\\n        poolImplementationAddress = implementation;\\n    }\\n\\n    /// @dev sets implementation for future tranche vault deployments\\n    function setTrancheVaultImplementation(address implementation) external onlyOwnerOrAdmin {\\n        trancheVaultImplementationAddress = implementation;\\n    }\\n\\n    function setFeeSharingContractAddress(address implementation) external onlyOwnerOrAdmin {\\n        feeSharingContractAddress = implementation;\\n    }\\n\\n    /// @dev returns last deployed pool record\\n    function lastDeployedPoolRecord() external view returns (PoolRecord memory p) {\\n        p = poolRegistry[poolRegistry.length - 1];\\n    }\\n\\n    /// @dev removes all the pool records from storage\\n    function clearPoolRecords() external onlyOwnerOrAdmin {\\n        delete poolRegistry;\\n    }\\n\\n    /// @dev gets the length of the pool of records \\n    function poolRecordsLength() external view returns (uint) {\\n        return poolRegistry.length;\\n    }\\n\\n    /** @dev Deploys a clone of implementation as a new pool.\\n     * . See {LendingPool-initialize}\\n     */\\n    function deployPool(\\n        LendingPool.LendingPoolParams calldata params,\\n        uint[][] calldata fundingSplitWads\\n    ) external onlyOwner returns (address) {\\n        // validate wad\\n        uint256 wadMax;\\n        uint256 wadMin;\\n        for(uint256 i = 0; i < fundingSplitWads.length; i++) {\\n            require(fundingSplitWads[i].length == 2, \\\"LP026 - bad fundingSplitWads\\\");\\n            wadMax += fundingSplitWads[i][0];\\n            wadMin += fundingSplitWads[i][1];\\n        }\\n        require(wadMax == 1e18, \\\"LP024 - bad max wad\\\");\\n        require(wadMin == 1e18, \\\"LP027 - bad min wad\\\");\\n\\n        address poolAddress = _clonePool();\\n\\n        address[] memory trancheVaultAddresses = _deployTrancheVaults(\\n            params,\\n            fundingSplitWads,\\n            poolAddress,\\n            _msgSender()\\n        );\\n\\n        initializePoolAndCreatePoolRecord(poolAddress, params, trancheVaultAddresses, feeSharingContractAddress);\\n\\n        return poolAddress;\\n    }\\n\\n    function _clonePool() internal onlyOwner returns (address poolAddress) {\\n        address impl = poolImplementationAddress;\\n        poolAddress = Clones.cloneDeterministic(impl, bytes32(nonces[impl]++));\\n        emit PoolCloned(poolAddress, poolImplementationAddress);\\n    }\\n\\n    function nextLender() public view returns(address) {\\n        return nextAddress(poolImplementationAddress);\\n    }\\n\\n    function nextLenders() public view returns(address[4] memory lenders) {\\n        address impl = poolImplementationAddress;\\n        for(uint256 i = 0; i < lenders.length; i++) {\\n            lenders[i] = Clones.predictDeterministicAddress(impl, bytes32(nonces[impl] + i));\\n        }\\n    }\\n\\n    function nextTranches() public view returns(address[8] memory lenders) {\\n        address impl = trancheVaultImplementationAddress;\\n        for(uint256 i = 0; i < lenders.length; i++) {\\n            lenders[i] = Clones.predictDeterministicAddress(impl, bytes32(nonces[impl] + i));\\n        }\\n    }\\n\\n    function nextAddress(address impl) public view returns(address) {\\n        return Clones.predictDeterministicAddress(impl, bytes32(nonces[impl] + 1));\\n    }\\n\\n\\n    function _deployTrancheVaults(\\n        LendingPool.LendingPoolParams calldata params,\\n        uint[][] calldata fundingSplitWads,\\n        address poolAddress,\\n        address ownerAddress\\n    ) internal onlyOwner returns (address[] memory trancheVaultAddresses) {\\n        require(params.tranchesCount > 0, \\\"Error TrancheCount must be gt 0\\\");\\n        trancheVaultAddresses = new address[](params.tranchesCount);\\n\\n        for (uint8 i; i < params.tranchesCount; ++i) {\\n            address impl = trancheVaultImplementationAddress;\\n            trancheVaultAddresses[i] = Clones.cloneDeterministic(impl,  bytes32(nonces[impl]++));\\n\\n            emit TrancheVaultCloned(trancheVaultAddresses[i], impl);\\n            prevDeployedTranche[trancheVaultAddresses[i]] = true;\\n\\n            TrancheVault(trancheVaultAddresses[i]).initialize(\\n                poolAddress,\\n                i,\\n                params.minFundingCapacity.mulDiv(fundingSplitWads[i][1], WAD),\\n                params.maxFundingCapacity.mulDiv(fundingSplitWads[i][0], WAD),\\n                string(abi.encodePacked(params.name, \\\" Tranche \\\", Strings.toString(uint(i)), \\\" Token\\\")),\\n                string(abi.encodePacked(\\\"tv\\\", Strings.toString(uint(i)), params.token)),\\n                params.stableCoinContractAddress,\\n                address(authority)\\n            );\\n            TrancheVault(trancheVaultAddresses[i]).transferOwnership(ownerAddress);\\n        }\\n    }\\n\\n    function initializePoolAndCreatePoolRecord(\\n        address poolAddress,\\n        LendingPool.LendingPoolParams calldata params,\\n        address[] memory trancheVaultAddresses,\\n        address _feeSharingContractAddress\\n    ) public onlyOwner {\\n        LendingPool(poolAddress).initialize(\\n            params,\\n            trancheVaultAddresses,\\n            _feeSharingContractAddress,\\n            address(authority),\\n            address(this)\\n        );\\n        Ownable(poolAddress).transferOwnership(_msgSender());\\n\\n        PoolRecord memory record = PoolRecord(\\n            params.name,\\n            params.token,\\n            poolAddress,\\n            trancheVaultAddresses[0],\\n            trancheVaultAddresses.length > 1 ? trancheVaultAddresses[1] : address(0),\\n            poolImplementationAddress,\\n            trancheVaultImplementationAddress\\n        );\\n        poolRegistry.push(record);\\n\\n        emit PoolDeployed(_msgSender(), record);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/fee_sharing/IFeeSharing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IFeeSharing {\\n    function distributeFees() external;\\n}\\n\"\r\n    },\r\n    \"contracts/pool/ILendingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\n/// @notice interface for lending pool\\n/// This is not the full interface, rather a bare mininum to connect other contracts to the pool\\ninterface ILendingPool {\\n    function onTrancheDeposit(uint8 trancheId, address depositorAddress, uint amount) external;\\n\\n    function onTrancheWithdraw(uint8 trancheId, address depositorAddress, uint amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/pool/LendingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\nimport \\\"./PoolCalculations.sol\\\";\\nimport \\\"./PoolTransfers.sol\\\";\\nimport \\\"./ILendingPool.sol\\\";\\n\\nimport \\\"../fee_sharing/IFeeSharing.sol\\\";\\nimport \\\"../authority/AuthorityAware.sol\\\";\\nimport \\\"../vaults/TrancheVault.sol\\\";\\n\\ncontract LendingPool is ILendingPool, AuthorityAware, PausableUpgradeable {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using Math for uint;\\n\\n    /*///////////////////////////////////\\n       CONSTANTS\\n    ///////////////////////////////////*/\\n    string public constant VERSION = \\\"2023-06-12\\\";\\n\\n    uint internal constant WAD = 10 ** 18;\\n    uint internal constant DAY = 24 * 60 * 60;\\n    uint internal constant YEAR = 365 * DAY;\\n\\n    // DO NOT TOUCH WITHOUT LIBRARY CONSIDERATIONS\\n    struct Rewardable {\\n        uint stakedAssets;\\n        uint lockedPlatformTokens;\\n        uint redeemedRewards;\\n        uint64 start;\\n    }\\n\\n    struct RollOverSetting {\\n        bool enabled;\\n        bool principal;\\n        bool rewards;\\n        bool platformTokens;\\n    }\\n\\n    enum Stages {                   // WARNING, DO NOT REORDER ENUM!!!\\n        INITIAL,                    // 0\\n        OPEN,                       // 1\\n        FUNDED,                     // 2\\n        FUNDING_FAILED,             // 3\\n        FLC_DEPOSITED,              // 4\\n        BORROWED,                   // 5\\n        BORROWER_INTEREST_REPAID,   // 6\\n        DELINQUENT,                 // 7\\n        REPAID,                     // 8\\n        DEFAULTED,                  // 9\\n        FLC_WITHDRAWN               // 10\\n    }\\n\\n    struct LendingPoolParams {\\n        string name;\\n        string token;\\n        address stableCoinContractAddress;\\n        address platformTokenContractAddress;\\n        uint minFundingCapacity;\\n        uint maxFundingCapacity;\\n        uint64 fundingPeriodSeconds;\\n        uint64 lendingTermSeconds;\\n        address borrowerAddress;\\n        uint firstLossAssets;\\n        uint borrowerTotalInterestRateWad;\\n        uint repaymentRecurrenceDays;\\n        uint gracePeriodDays;\\n        uint protocolFeeWad;\\n        uint defaultPenalty;\\n        uint penaltyRateWad;\\n        uint8 tranchesCount;\\n        uint[] trancheAPRsWads;\\n        uint[] trancheBoostedAPRsWads;\\n        uint[] trancheBoostRatios;\\n        uint[] trancheCoveragesWads;\\n    }\\n\\n    /*///////////////////////////////////\\n       CONTRACT VARIABLES\\n    ///////////////////////////////////*/\\n    /*Initializer parameters*/\\n    string public name;\\n    string public token;\\n    address public stableCoinContractAddress;\\n    address public platformTokenContractAddress;\\n    uint public minFundingCapacity;\\n    uint public maxFundingCapacity;\\n    uint64 public fundingPeriodSeconds;\\n    uint64 public lendingTermSeconds;\\n    address public borrowerAddress;\\n    uint public firstLossAssets;\\n    uint public repaymentRecurrenceDays;\\n    uint public gracePeriodDays;\\n    uint public borrowerTotalInterestRateWad;\\n    uint public protocolFeeWad;\\n    uint public defaultPenalty;\\n    uint public penaltyRateWad;\\n    uint8 public tranchesCount;\\n    uint[] public trancheAPRsWads;\\n    uint[] public trancheBoostedAPRsWads;\\n    uint[] public trancheBoostRatios;\\n    uint[] public trancheCoveragesWads;\\n    /* Other contract addresses */\\n    address public poolFactoryAddress;\\n    address public feeSharingContractAddress;\\n    address[] public trancheVaultAddresses;\\n    /* Some Timestamps */\\n    uint64 public openedAt;\\n    uint64 public fundedAt;\\n    uint64 public fundingFailedAt;\\n    uint64 public flcDepositedAt;\\n    uint64 public borrowedAt;\\n    uint64 public repaidAt;\\n    uint64 public flcWithdrawntAt;\\n    uint64 public defaultedAt;\\n\\n    /* Interests & Yields */\\n    uint public collectedAssets;\\n    uint public borrowedAssets;\\n    uint public borrowerInterestRepaid;\\n\\n    EnumerableSet.AddressSet internal s_lenders;\\n\\n    /// @dev trancheId => (lenderAddress => RewardableRecord)\\n    mapping(uint8 => mapping(address => Rewardable)) public s_trancheRewardables;\\n\\n    /// @dev trancheId => stakedassets\\n    mapping(uint8 => uint256) public s_totalStakedAssetsByTranche;\\n\\n    /// @dev trancheId => lockedTokens\\n    mapping(uint8 => uint256) public s_totalLockedPlatformTokensByTranche;\\n\\n    /// @dev lenderAddress => RollOverSetting\\n    mapping(address => RollOverSetting) private s_rollOverSettings;\\n\\n    Stages public currentStage;\\n\\n    /*///////////////////////////////////\\n       MODIFIERS\\n    ///////////////////////////////////*/\\n\\n    modifier authTrancheVault(uint8 id) {\\n        _authTrancheVault(id);\\n        _;\\n    }\\n\\n    function _authTrancheVault(uint8 id) internal view {\\n        require(id < trancheVaultAddresses.length, \\\"LP001\\\"); // \\\"LendingPool: invalid trancheVault id\\\"\\n        require(trancheVaultAddresses[id] == _msgSender(), \\\"LP002\\\"); // \\\"LendingPool: trancheVault auth\\\"\\n    }\\n\\n    modifier onlyPoolBorrower() {\\n        _onlyPoolBorrower();\\n        _;\\n    }\\n\\n    function _onlyPoolBorrower() internal view {\\n        require(_msgSender() == borrowerAddress, \\\"LP003\\\"); // \\\"LendingPool: not a borrower\\\"\\n    }\\n\\n    modifier atStage(Stages _stage) {\\n        _atStage(_stage);\\n        _;\\n    }\\n\\n    function _atStage(Stages _stage) internal view {\\n        require(currentStage == _stage, \\\"LP004\\\"); // \\\"LendingPool: not at correct stage\\\"\\n    }\\n\\n    modifier atStages2(Stages _stage1, Stages _stage2) {\\n        _atStages2(_stage1, _stage2);\\n        _;\\n    }\\n\\n    function _atStages2(Stages _stage1, Stages _stage2) internal view {\\n        require(currentStage == _stage1 || currentStage == _stage2, \\\"LP004\\\"); // \\\"LendingPool: not at correct stage\\\"\\n    }\\n\\n    modifier atStages3(\\n        Stages _stage1,\\n        Stages _stage2,\\n        Stages _stage3\\n    ) {\\n        _atStages3(_stage1, _stage2, _stage3);\\n        _;\\n    }\\n\\n    function _atStages3(Stages _stage1, Stages _stage2, Stages _stage3) internal view {\\n        require(\\n            currentStage == _stage1 || currentStage == _stage2 || currentStage == _stage3,\\n            \\\"LP004\\\" // \\\"LendingPool: not at correct stage\\\"\\n        );\\n    }\\n\\n    /*///////////////////////////////////\\n       EVENTS\\n    ///////////////////////////////////*/\\n\\n    // State Changes //\\n    event PoolInitialized(\\n        LendingPoolParams params,\\n        address[] _trancheVaultAddresses,\\n        address _feeSharingContractAddress,\\n        address _authorityAddress\\n    );\\n    event PoolOpen(uint64 openedAt);\\n    event PoolFunded(uint64 fundedAt, uint collectedAssets);\\n    event PoolFundingFailed(uint64 fundingFailedAt);\\n    event PoolRepaid(uint64 repaidAt);\\n    event PoolDefaulted(uint64 defaultedAt);\\n    event PoolFirstLossCapitalWithdrawn(uint64 flcWithdrawntAt);\\n\\n    // Lender //\\n    event LenderDeposit(address indexed lender, uint8 indexed trancheId, uint256 amount);\\n    event LenderWithdraw(address indexed lender, uint8 indexed trancheId, uint256 amount);\\n    event LenderWithdrawInterest(address indexed lender, uint8 indexed trancheId, uint256 amount);\\n    event LenderTrancheRewardsChange(\\n        address indexed lender,\\n        uint8 indexed trancheId,\\n        uint lenderEffectiveAprWad,\\n        uint totalExpectedRewards,\\n        uint redeemedRewards\\n    );\\n    event LenderLockPlatformTokens(address indexed lender, uint8 indexed trancheId, uint256 amount);\\n    event LenderUnlockPlatformTokens(address indexed lender, uint8 indexed trancheId, uint256 amount);\\n\\n    // Borrower //\\n    event BorrowerDepositFirstLossCapital(address indexed borrower, uint amount);\\n    event BorrowerBorrow(address indexed borrower, uint amount);\\n    event BorrowerPayInterest(\\n        address indexed borrower,\\n        uint amount,\\n        uint lendersDistributedAmount,\\n        uint feeSharingContractAmount\\n    );\\n    event BorrowerPayPenalty(address indexed borrower, uint amount);\\n    event BorrowerRepayPrincipal(address indexed borrower, uint amount);\\n    event BorrowerWithdrawFirstLossCapital(address indexed borrower, uint amount);\\n\\n    /*///////////////////////////////////\\n       INITIALIZATION\\n    ///////////////////////////////////*/\\n\\n    function initialize(\\n        LendingPoolParams calldata params,\\n        address[] calldata _trancheVaultAddresses,\\n        address _feeSharingContractAddress,\\n        address _authorityAddress,\\n        address _poolFactoryAddress\\n    ) external initializer {\\n        PoolCalculations.validateInitParams(\\n            params,\\n            _trancheVaultAddresses,\\n            _feeSharingContractAddress,\\n            _authorityAddress\\n        );\\n\\n        PoolCalculations.validateWad(params.trancheCoveragesWads);\\n\\n        name = params.name;\\n        token = params.token;\\n        stableCoinContractAddress = params.stableCoinContractAddress;\\n        platformTokenContractAddress = params.platformTokenContractAddress;\\n        minFundingCapacity = params.minFundingCapacity;\\n        maxFundingCapacity = params.maxFundingCapacity;\\n        fundingPeriodSeconds = params.fundingPeriodSeconds;\\n        lendingTermSeconds = params.lendingTermSeconds;\\n        borrowerAddress = params.borrowerAddress;\\n        firstLossAssets = params.firstLossAssets;\\n        borrowerTotalInterestRateWad = params.borrowerTotalInterestRateWad;\\n        repaymentRecurrenceDays = params.repaymentRecurrenceDays;\\n        gracePeriodDays = params.gracePeriodDays;\\n        protocolFeeWad = params.protocolFeeWad;\\n        defaultPenalty = params.defaultPenalty;\\n        penaltyRateWad = params.penaltyRateWad;\\n        tranchesCount = params.tranchesCount;\\n        trancheAPRsWads = params.trancheAPRsWads;\\n        trancheBoostedAPRsWads = params.trancheBoostedAPRsWads;\\n        trancheBoostRatios = params.trancheBoostRatios;\\n        trancheCoveragesWads = params.trancheCoveragesWads;\\n\\n        trancheVaultAddresses = _trancheVaultAddresses;\\n        feeSharingContractAddress = _feeSharingContractAddress;\\n        poolFactoryAddress = _poolFactoryAddress;\\n\\n        __Ownable_init();\\n        __Pausable_init();\\n        __AuthorityAware__init(_authorityAddress);\\n\\n        emit PoolInitialized(params, _trancheVaultAddresses, _feeSharingContractAddress, _authorityAddress);\\n    }\\n\\n    /*///////////////////////////////////\\n       ADMIN FUNCTIONS\\n    ///////////////////////////////////*/\\n\\n    /** @dev Pauses the pool */\\n    function pause() external onlyOwnerOrAdmin {\\n        _pause();\\n    }\\n\\n    /** @dev Unpauses the pool */\\n    function unpause() external onlyOwnerOrAdmin {\\n        _unpause();\\n    }\\n\\n    /** @notice Marks the pool as opened. This function has to be called by *owner* when\\n     * - sets openedAt to current block timestamp\\n     * - enables deposits and withdrawals to tranche vaults\\n     */\\n    function adminOpenPool() external onlyOwnerOrAdmin atStage(Stages.FLC_DEPOSITED) whenNotPaused {\\n        openedAt = uint64(block.timestamp);\\n        currentStage = Stages.OPEN;\\n\\n        TrancheVault[] memory vaults = trancheVaultContracts();\\n\\n        for (uint i; i < trancheVaultAddresses.length; i++) {\\n            vaults[i].enableDeposits();\\n            vaults[i].enableWithdrawals();\\n        }\\n\\n        emit PoolOpen(openedAt);\\n    }\\n\\n    /** @notice Checks whether the pool was funded successfully or not.\\n     *  this function is expected to be called by *owner* once the funding period ends\\n     */\\n    function adminTransitionToFundedState() external onlyOwnerOrAdmin atStage(Stages.OPEN) {\\n        require(block.timestamp >= openedAt + fundingPeriodSeconds, \\\"Cannot accrue interest or declare failure before start time\\\");\\n        if (collectedAssets >= minFundingCapacity) {\\n            _transitionToFundedStage();\\n        } else {\\n            _transitionToFundingFailedStage();\\n        }\\n    }\\n\\n    function adminTransitionToDefaultedState() external onlyOwnerOrAdmin atStage(Stages.BORROWED) {\\n        require(block.timestamp >= fundedAt + lendingTermSeconds, \\\"LP023\\\"); // \\\"LendingPool: maturityDate not reached\\\"\\n        _transitionToDefaultedStage();\\n    }\\n\\n    function _transitionToFundedStage() internal whenNotPaused {\\n        fundedAt = uint64(block.timestamp);\\n        currentStage = Stages.FUNDED;\\n\\n        TrancheVault[] memory vaults = trancheVaultContracts();\\n\\n        for (uint i; i < vaults.length; i++) {\\n            TrancheVault tv = vaults[i];\\n            tv.disableDeposits();\\n            tv.disableWithdrawals();\\n            tv.sendAssetsToPool(tv.totalAssets());\\n        }\\n\\n        emit PoolFunded(fundedAt, collectedAssets);\\n    }\\n\\n    function _transitionToFundingFailedStage() internal whenNotPaused {\\n        fundingFailedAt = uint64(block.timestamp);\\n        currentStage = Stages.FUNDING_FAILED;\\n        \\n        TrancheVault[] memory vaults = trancheVaultContracts();\\n\\n        for (uint i; i < trancheVaultAddresses.length; i++) {\\n            vaults[i].disableDeposits();\\n            vaults[i].enableWithdrawals();\\n        }\\n        emit PoolFundingFailed(fundingFailedAt);\\n    }\\n\\n    function _transitionToFlcDepositedStage(uint flcAssets) internal whenNotPaused {\\n        flcDepositedAt = uint64(block.timestamp);\\n        currentStage = Stages.FLC_DEPOSITED;\\n        emit BorrowerDepositFirstLossCapital(borrowerAddress, flcAssets);\\n    }\\n\\n    function _transitionToBorrowedStage(uint amountToBorrow) internal whenNotPaused {\\n        borrowedAt = uint64(block.timestamp);\\n        borrowedAssets = amountToBorrow;\\n        currentStage = Stages.BORROWED;\\n\\n        emit BorrowerBorrow(borrowerAddress, amountToBorrow);\\n    }\\n\\n    function _transitionToPrincipalRepaidStage(uint repaidPrincipal) internal whenNotPaused {\\n        repaidAt = uint64(block.timestamp);\\n        currentStage = Stages.REPAID;\\n        emit BorrowerRepayPrincipal(borrowerAddress, repaidPrincipal);\\n        emit PoolRepaid(repaidAt);\\n    }\\n\\n    function _transitionToFlcWithdrawnStage(uint flcAssets) internal whenNotPaused {\\n        flcWithdrawntAt = uint64(block.timestamp);\\n        currentStage = Stages.FLC_WITHDRAWN;\\n        emit BorrowerWithdrawFirstLossCapital(borrowerAddress, flcAssets);\\n    }\\n\\n    function _claimTrancheInterestForLender(address lender, uint8 trancheId) internal {\\n        uint rewards = lenderRewardsByTrancheRedeemable(lender, trancheId);\\n        if (rewards > 0) {\\n            s_trancheRewardables[trancheId][lender].redeemedRewards += rewards;\\n            SafeERC20.safeTransfer(_stableCoinContract(), lender, rewards);\\n            emit LenderWithdrawInterest(lender, trancheId, rewards);\\n        }\\n    }\\n\\n    function _claimInterestForAllLenders() internal {\\n        TrancheVault[] memory vaults = trancheVaultContracts();\\n\\n        for (uint8 i; i < tranchesCount; i++) {\\n            for (uint j; j < lenderCount(); j++) {\\n                _claimTrancheInterestForLender(lendersAt(j), vaults[i].id());\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Transitions the pool to the defaulted state and pays out remaining assets to the tranche vaults\\n     * @dev This function is expected to be called by *owner* after the maturity date has passed and principal has not been repaid\\n     */\\n    function _transitionToDefaultedStage() internal whenNotPaused {\\n        defaultedAt = uint64(block.timestamp);\\n        currentStage = Stages.DEFAULTED;\\n        _claimInterestForAllLenders();\\n        // TODO: update repaid interest to be the total interest paid to lenders\\n        // TODO: should the protocol fees be paid in event of default\\n        uint availableAssets = _stableCoinContract().balanceOf(address(this));\\n        TrancheVault[] memory vaults = trancheVaultContracts();\\n\\n        for (uint i; i < trancheVaultAddresses.length; i++) {\\n            TrancheVault tv = vaults[i];\\n            uint assetsToSend = (trancheCoveragesWads[i] * availableAssets) / WAD;\\n            uint trancheDefaultRatioWad = (assetsToSend * WAD) / tv.totalAssets();\\n\\n            if (assetsToSend > 0) {\\n                SafeERC20.safeTransfer(_stableCoinContract(), address(tv), assetsToSend);\\n            }\\n            availableAssets -= assetsToSend;\\n            tv.setDefaultRatioWad(trancheDefaultRatioWad);\\n            tv.enableWithdrawals();\\n        }\\n\\n        emit PoolDefaulted(defaultedAt);\\n    }\\n\\n    /*///////////////////////////////////\\n      Lender (please also see onTrancheDeposit() and onTrancheWithdraw())\\n      Error group: 1\\n    ///////////////////////////////////*/\\n\\n    /** @notice Lock platform tokens in order to get APR boost\\n     *  @param trancheId tranche id\\n     *  @param platformTokens amount of PLATFORM tokens to lock\\n     */\\n    function lenderLockPlatformTokensByTranche(\\n        uint8 trancheId,\\n        uint platformTokens\\n    ) external onlyLender atStage(Stages.OPEN) whenNotPaused {\\n        require(\\n            platformTokens <= lenderPlatformTokensByTrancheLockable(_msgSender(), trancheId),\\n            \\\"LP101\\\" //\\\"LendingPool: lock will lead to overboost\\\"\\n        );\\n        require(IERC20(platformTokenContractAddress).totalSupply() > 0, \\\"Lock: Token Locking Disabled\\\");\\n\\n        Rewardable storage r = s_trancheRewardables[trancheId][_msgSender()];\\n        r.lockedPlatformTokens += platformTokens;\\n        s_totalLockedPlatformTokensByTranche[trancheId] += platformTokens;\\n\\n        SafeERC20.safeTransferFrom(IERC20(platformTokenContractAddress), _msgSender(), address(this), platformTokens);\\n\\n        emit LenderLockPlatformTokens(_msgSender(), trancheId, platformTokens);\\n        _emitLenderTrancheRewardsChange(_msgSender(), trancheId);\\n    }\\n\\n    /** @notice Unlock platform tokens after the pool is repaid AND rewards are redeemed\\n     *  @param trancheId tranche id\\n     *  @param platformTokens amount of PLATFORM tokens to unlock\\n     */\\n    function lenderUnlockPlatformTokensByTranche(\\n        uint8 trancheId,\\n        uint platformTokens\\n    ) external onlyLender atStages2(Stages.REPAID, Stages.FLC_WITHDRAWN) whenNotPaused {\\n        require(!s_rollOverSettings[msg.sender].platformTokens, \\\"LP102\\\"); // \\\"LendingPool: tokens are locked for rollover\\\"\\n        require(lenderRewardsByTrancheRedeemable(_msgSender(), trancheId) == 0, \\\"LP103\\\"); // \\\"LendingPool: rewards not redeemed\\\"\\n        require(IERC20(platformTokenContractAddress).totalSupply() > 0, \\\"Unlock: Token Locking Disabled\\\");\\n\\n        Rewardable storage r = s_trancheRewardables[trancheId][_msgSender()];\\n\\n        require(r.lockedPlatformTokens >= platformTokens, \\\"LP104\\\"); // LendingPool: not enough locked tokens\\\"\\n        r.lockedPlatformTokens -= platformTokens;\\n\\n        SafeERC20.safeTransfer(IERC20(platformTokenContractAddress), _msgSender(), platformTokens);\\n\\n        emit LenderUnlockPlatformTokens(_msgSender(), trancheId, platformTokens);\\n    }\\n\\n    /** @notice Redeem currently available rewards for a tranche\\n     *  @param trancheId tranche id\\n     *  @param toWithdraw amount of rewards to withdraw\\n     */\\n    function lenderRedeemRewardsByTranche(\\n        uint8 trancheId,\\n        uint toWithdraw\\n    ) public onlyLender atStages3(Stages.BORROWED, Stages.REPAID, Stages.FLC_WITHDRAWN) whenNotPaused {\\n        require(!s_rollOverSettings[msg.sender].rewards, \\\"LP105\\\"); // \\\"LendingPool: rewards are locked for rollover\\\"\\n        if (toWithdraw == 0) {\\n            return;\\n        }\\n        uint maxWithdraw = lenderRewardsByTrancheRedeemable(_msgSender(), trancheId);\\n        require(toWithdraw <= maxWithdraw, \\\"LP106\\\"); // \\\"LendingPool: amount to withdraw is too big\\\"\\n        s_trancheRewardables[trancheId][_msgSender()].redeemedRewards += toWithdraw;\\n\\n        SafeERC20.safeTransfer(_stableCoinContract(), _msgSender(), toWithdraw);\\n\\n        // if (IERC20(stableCoinContractAddress()).balanceOf(address(this)) < poolBalanceThreshold()) {\\n        //     _transitionToDelinquentStage();\\n        // }\\n\\n        emit LenderWithdrawInterest(_msgSender(), trancheId, toWithdraw);\\n        _emitLenderTrancheRewardsChange(_msgSender(), trancheId);\\n    }\\n\\n    /** @notice Redeem currently available rewards for two tranches\\n     *  @param toWithdraws amount of rewards to withdraw accross all tranches\\n     */\\n    function lenderRedeemRewards(\\n        uint[] calldata toWithdraws\\n    ) external onlyLender atStages3(Stages.BORROWED, Stages.REPAID, Stages.FLC_WITHDRAWN) whenNotPaused {\\n        require(!s_rollOverSettings[msg.sender].rewards, \\\"LP105\\\"); //\\\"LendingPool: rewards are locked for rollover\\\"\\n        require(toWithdraws.length == tranchesCount, \\\"LP107\\\"); //\\\"LendingPool: wrong amount of tranches\\\"\\n        for (uint8 i; i < toWithdraws.length; i++) {\\n            lenderRedeemRewardsByTranche(i, toWithdraws[i]);\\n        }\\n    }\\n\\n    /* VIEWS */\\n\\n    /// @notice average APR of all lenders across all tranches, boosted or not\\n    function allLendersInterest() public view returns (uint) {\\n        return (((allLendersEffectiveAprWad() * collectedAssets) / WAD) * lendingTermSeconds) / YEAR;\\n    }\\n\\n    function allLendersInterestByDate() public view returns (uint) {\\n        return PoolCalculations.allLendersInterestByDate(this);\\n    }\\n\\n    /// @notice average APR of all lenders across all tranches, boosted or not\\n    function allLendersEffectiveAprWad() public view returns (uint) {\\n        return PoolCalculations.allLendersEffectiveAprWad(this, tranchesCount);\\n    }\\n\\n    /// @notice weighted APR accross all the lenders\\n    function lenderTotalAprWad(address lenderAddress) public view returns (uint) {\\n        return PoolCalculations.lenderTotalAprWad(this, lenderAddress);\\n    }\\n\\n    /// @notice  Returns amount of stablecoins deposited across all the pool tranches by a lender\\n    function lenderAllDepositedAssets(address lenderAddress) public view returns (uint totalAssets) {\\n        totalAssets = 0;\\n        for (uint8 i; i < tranchesCount; ++i) {\\n            totalAssets += s_trancheRewardables[i][lenderAddress].stakedAssets;\\n        }\\n    }\\n\\n    /* VIEWS BY TRANCHE*/\\n\\n    /** @notice  Returns amount of stablecoins deposited to a pool tranche by a lender\\n     *  @param lenderAddress lender address\\n     *  @param trancheId tranche id\\n     */\\n    function lenderDepositedAssetsByTranche(address lenderAddress, uint8 trancheId) public view returns (uint) {\\n        return s_trancheRewardables[trancheId][lenderAddress].stakedAssets;\\n    }\\n\\n    /** @notice Returns amount of stablecoins to be paid for the lender by the end of the pool term.\\n     *  `lenderAPR * lenderDepositedAssets * lendingTermSeconds / YEAR`\\n     *  @param lenderAddress lender address\\n     *  @param trancheId tranche id\\n     */\\n    function lenderTotalExpectedRewardsByTranche(address lenderAddress, uint8 trancheId) public view returns (uint) {\\n        return\\n            PoolCalculations.lenderTotalExpectedRewardsByTranche(\\n                lenderDepositedAssetsByTranche(lenderAddress, trancheId),\\n                lenderEffectiveAprByTrancheWad(lenderAddress, trancheId),\\n                lendingTermSeconds\\n            );\\n    }\\n\\n    /** @notice Returns amount of stablecoin rewards generated for the lenders by current second.\\n     *  `lenderTotalExpectedRewardsByTranche * (secondsElapsed / lendingTermSeconds)`\\n     *  @param lenderAddress lender address\\n     *  @param trancheId tranche id\\n     */\\n    function lenderRewardsByTrancheGeneratedByDate(address lenderAddress, uint8 trancheId) public view returns (uint) {\\n        return PoolCalculations.lenderRewardsByTrancheGeneratedByDate(this, lenderAddress, trancheId);\\n    }\\n\\n    /** @notice Returns amount of stablecoin rewards that has been withdrawn by the lender.\\n     *  @param lenderAddress lender address\\n     *  @param trancheId tranche id\\n     */\\n    function lenderRewardsByTrancheRedeemed(address lenderAddress, uint8 trancheId) public view returns (uint) {\\n        return s_trancheRewardables[trancheId][lenderAddress].redeemedRewards;\\n    }\\n\\n    /** @notice Returns amount of stablecoin rewards that can be withdrawn by the lender. (generated - redeemed). Special means this one is distinguished from the FE version and is only used within the SCs\\n     *  @param lenderAddress lender address\\n     *  @param trancheId tranche id\\n     */\\n    function lenderRewardsByTrancheRedeemable(address lenderAddress, uint8 trancheId) public view returns (uint) {\\n        uint256 willReward = lenderRewardsByTrancheGeneratedByDate(lenderAddress, trancheId);\\n        uint256 hasRewarded = lenderRewardsByTrancheRedeemed(lenderAddress, trancheId);\\n        return willReward - hasRewarded;\\n    }\\n\\n    /** @notice Returns amount of stablecoin rewards that can be withdrawn by the lender. (generated - redeemed) only use in FE\\n     *  @param lenderAddress lender address\\n     *  @param trancheId tranche id\\n     */\\n    function lenderRewardsByTrancheRedeemableSpecial(address lenderAddress, uint8 trancheId) public view returns (uint) {\\n        uint256 willReward = lenderRewardsByTrancheGeneratedByDate(lenderAddress, trancheId);\\n        uint256 hasRewarded = lenderRewardsByTrancheRedeemed(lenderAddress, trancheId);\\n        if(hasRewarded > willReward) {\\n            return 0;\\n        }\\n        return willReward - hasRewarded;\\n    }\\n\\n    /** @notice Returns APR for the lender taking into account all the deposited USDC + platform tokens\\n     *  @param lenderAddress lender address\\n     *  @param trancheId tranche id\\n     */\\n    function lenderEffectiveAprByTrancheWad(address lenderAddress, uint8 trancheId) public view returns (uint) {\\n        return PoolCalculations.lenderEffectiveAprByTrancheWad(this, lenderAddress, trancheId);\\n    }\\n\\n    /** @notice Returns amount of platform tokens locked by the lender\\n     *  @param lenderAddress lender address\\n     *  @param trancheId tranche id\\n     */\\n    function lenderPlatformTokensByTrancheLocked(address lenderAddress, uint8 trancheId) public view returns (uint) {\\n        return s_trancheRewardables[trancheId][lenderAddress].lockedPlatformTokens;\\n    }\\n\\n    /** @notice Returns amount of staked tokens committed by the lender\\n     *  @param lenderAddress lender address\\n     *  @param trancheId tranche id\\n     */\\n    function lenderStakedTokensByTranche(address lenderAddress, uint8 trancheId) public view returns (uint) {\\n        return s_trancheRewardables[trancheId][lenderAddress].stakedAssets;\\n    }\\n\\n    /** @notice Returns amount of platform tokens that lender can lock in order to boost their APR\\n     *  @param lenderAddress lender address\\n     *  @param trancheId tranche id\\n     */\\n    function lenderPlatformTokensByTrancheLockable(address lenderAddress, uint8 trancheId) public view returns (uint) {\\n        Rewardable storage r = s_trancheRewardables[trancheId][lenderAddress];\\n        uint maxLockablePlatformTokens = r.stakedAssets * trancheBoostRatios[trancheId];\\n        return maxLockablePlatformTokens - r.lockedPlatformTokens;\\n    }\\n\\n    /*///////////////////////////////////\\n       Rollover settings\\n    ///////////////////////////////////*/\\n    /** @notice marks the intent of the lender to roll over their capital to the upcoming pool (called by older pool)\\n     *  if you opt to roll over you will not be able to withdraw stablecoins / platform tokens from the pool\\n     *  @param principal whether the principal should be rolled over\\n     *  @param rewards whether the rewards should be rolled over\\n     *  @param platformTokens whether the platform tokens should be rolled over\\n     */\\n    function lenderEnableRollOver(bool principal, bool rewards, bool platformTokens) external onlyLender {\\n        address lender = _msgSender();\\n        s_rollOverSettings[lender] = RollOverSetting(true, principal, rewards, platformTokens);\\n        PoolTransfers.lenderEnableRollOver(this, principal, rewards, platformTokens, lender);\\n    }\\n\\n    /**\\n     * @dev This function rolls funds from prior deployments into currently active deployments\\n     * @param deadLendingPoolAddr The address of the lender whose funds are transfering over to the new lender\\n     * @param deadTrancheAddrs The address of the tranches whose funds are mapping 1:1 with the next traches\\n     * @param lenderStartIndex The first lender to start migrating over\\n     * @param lenderEndIndex The last lender to migrate\\n     */\\n    function executeRollover(\\n        address deadLendingPoolAddr,\\n        address[] memory deadTrancheAddrs,\\n        uint256 lenderStartIndex,\\n        uint256 lenderEndIndex\\n    ) external onlyOwnerOrAdmin atStage(Stages.OPEN) whenNotPaused {\\n        PoolTransfers.executeRollover(this, deadLendingPoolAddr, deadTrancheAddrs, lenderStartIndex, lenderEndIndex);\\n    }\\n\\n    /** @notice cancels lenders intent to roll over the funds to the next pool.\\n     */\\n    function lenderDisableRollOver() external onlyLender {\\n        s_rollOverSettings[_msgSender()] = RollOverSetting(false, false, false, false);\\n    }\\n\\n    /** @notice returns lender's roll over settings\\n     *  @param lender lender address\\n     */\\n    function lenderRollOverSettings(address lender) external view returns (RollOverSetting memory) {\\n        return s_rollOverSettings[lender];\\n    }\\n\\n    /*///////////////////////////////////\\n       Borrower functions\\n       Error group: 2\\n    ///////////////////////////////////*/\\n    /** @notice Deposits first loss capital into the pool\\n     *  should be called by the borrower before the pool can start\\n     */\\n    function borrowerDepositFirstLossCapital() external onlyPoolBorrower atStage(Stages.INITIAL) whenNotPaused {\\n        _transitionToFlcDepositedStage(firstLossAssets);\\n        SafeERC20.safeTransferFrom(_stableCoinContract(), msg.sender, address(this), firstLossAssets);\\n    }\\n\\n    /** @notice Borrows collected funds from the pool */\\n    function borrow() external onlyPoolBorrower atStage(Stages.FUNDED) whenNotPaused {\\n        _transitionToBorrowedStage(collectedAssets);\\n        SafeERC20.safeTransfer(_stableCoinContract(), borrowerAddress, collectedAssets);\\n    }\\n\\n    /** @notice Lets the borrower withdraw first loss deposit in the event of funding failed */\\n    function borrowerRecoverFirstLossCapital() external atStage(Stages.FUNDING_FAILED) {\\n        uint256 copyFirstLossAssets = firstLossAssets;\\n        firstLossAssets = 0;\\n        SafeERC20.safeTransfer(_stableCoinContract(), borrowerAddress, copyFirstLossAssets);\\n    }\\n\\n    /** @notice Make an interest payment.\\n     *  If the pool is delinquent, the minimum payment is penalty + whatever interest that needs to be paid to bring the pool back to healthy state\\n     */\\n    function borrowerPayInterest(uint assets) external onlyPoolBorrower whenNotPaused {\\n        uint penalty = borrowerPenaltyAmount();\\n        require(penalty < assets, \\\"LP201\\\"); // \\\"LendingPool: penalty cannot be more than assets\\\"\\n\\n        if (penalty > 0) {\\n            uint balanceDifference = poolBalanceThreshold() - poolBalance();\\n            require(assets >= penalty + balanceDifference, \\\"LP202\\\"); // \\\"LendingPool: penalty+interest will not bring pool to healthy state\\\"\\n        }\\n\\n        uint feeableInterestAmount = assets - penalty;\\n        if (feeableInterestAmount > borrowerOutstandingInterest()) {\\n            feeableInterestAmount = borrowerOutstandingInterest();\\n        }\\n\\n        uint assetsToSendToFeeSharing = (feeableInterestAmount * protocolFeeWad) / WAD + penalty;\\n        uint assetsForLenders = assets - assetsToSendToFeeSharing;\\n\\n        borrowerInterestRepaid = borrowerInterestRepaid + assets - penalty;\\n\\n        if (assetsToSendToFeeSharing > 0) {\\n            SafeERC20.safeTransfer(_stableCoinContract(), feeSharingContractAddress, assetsToSendToFeeSharing);\\n        }\\n\\n        SafeERC20.safeTransferFrom(_stableCoinContract(), _msgSender(), address(this), assets);\\n\\n        if (penalty > 0) {\\n            emit BorrowerPayPenalty(_msgSender(), penalty);\\n        }\\n\\n        emit BorrowerPayInterest(borrowerAddress, assets, assetsForLenders, assetsToSendToFeeSharing);\\n    }\\n\\n    /** @notice Repay principal\\n     *  can be called only after all interest is paid\\n     *  can be called only after all penalties are paid\\n     */\\n    function borrowerRepayPrincipal() external onlyPoolBorrower atStage(Stages.BORROWED) whenNotPaused {\\n        require(borrowerOutstandingInterest() == 0, \\\"LP203\\\"); // \\\"LendingPool: interest must be paid before repaying principal\\\"\\n        require(borrowerPenaltyAmount() == 0, \\\"LP204\\\"); // \\\"LendingPool: penalty must be paid before repaying principal\\\"\\n\\n        _transitionToPrincipalRepaidStage(borrowedAssets);\\n        TrancheVault[] memory vaults = trancheVaultContracts();\\n\\n        SafeERC20.safeTransferFrom(_stableCoinContract(), _msgSender(), address(this), borrowedAssets);\\n        for (uint i; i < tranchesCount; ++i) {\\n            TrancheVault tv = vaults[i];\\n            SafeERC20.safeTransfer(_stableCoinContract(), address(tv), tv.totalAssets());\\n            tv.enableWithdrawals();\\n        }\\n    }\\n\\n    /** @notice Withdraw first loss capital and excess spread\\n     *  can be called only after principal is repaid\\n     */\\n    function borrowerWithdrawFirstLossCapitalAndExcessSpread() external onlyPoolBorrower atStage(Stages.REPAID) whenNotPaused {\\n        uint assetsToSend = firstLossAssets + borrowerExcessSpread();\\n        _transitionToFlcWithdrawnStage(assetsToSend);\\n        SafeERC20.safeTransfer(_stableCoinContract(), borrowerAddress, assetsToSend);\\n    }\\n\\n    /* VIEWS */\\n    /** @notice Pool balance threshold.\\n     *  if pool balance fallse below this threshold, the pool is considered delinquent and the borrower starts to face penalties.\\n     */\\n    function poolBalanceThreshold() public view returns (uint) {\\n        return PoolCalculations.poolBalanceThreshold(this);\\n    }\\n\\n    /** @notice Pool balance\\n     * First loss capital minus whatever rewards are generated for the lenders by date.\\n     */\\n    function poolBalance() public view returns (uint) {\\n        return PoolCalculations.poolBalance(this);\\n    }\\n\\n    function lendersAt(uint i) public view returns (address) {\\n        return s_lenders.at(i);\\n    }\\n\\n    function lenderCount() public view returns (uint256) {\\n        return s_lenders.length();\\n    }\\n\\n    /** @notice how much penalty the borrower owes because of the delinquency fact */\\n    function borrowerPenaltyAmount() public view returns (uint) {\\n        if(currentStage > Stages.FLC_DEPOSITED) {\\n            return PoolCalculations.borrowerPenaltyAmount(this);\\n        }\\n    }\\n\\n    /** @dev total interest to be paid by borrower = adjustedBorrowerAPR * collectedAssets\\n     *  @return interest amount of assets to be repaid\\n     */\\n    function borrowerExpectedInterest() public view returns (uint) {\\n        return PoolCalculations.borrowerExpectedInterest(collectedAssets, borrowerAdjustedInterestRateWad());\\n    }\\n\\n    /** @dev outstanding borrower interest = expectedBorrowerInterest - borrowerInterestAlreadyPaid\\n     *  @return interest amount of outstanding assets to be repaid\\n     */\\n    function borrowerOutstandingInterest() public view returns (uint) {\\n        return PoolCalculations.borrowerOutstandingInterest(borrowerInterestRepaid, borrowerExpectedInterest());\\n    }\\n\\n    /** @notice excess spread = interest paid by borrower - interest paid to lenders - fees\\n     *  Once the pool ends, can be withdrawn by the borrower alongside the first loss capital\\n     */\\n    function borrowerExcessSpread() public view returns (uint) {\\n        return PoolCalculations.borrowerExcessSpread(this);\\n    }\\n\\n    /** @dev adjusted borrower interest rate = APR * duration / 365 days\\n     *  @return adj borrower interest rate adjusted by duration of the loan\\n     */\\n    function borrowerAdjustedInterestRateWad() public view returns (uint adj) {\\n        return PoolCalculations.borrowerAdjustedInterestRateWad(borrowerTotalInterestRateWad, lendingTermSeconds);\\n    }\\n\\n    /*///////////////////////////////////\\n       COMMUNICATION WITH VAULTS\\n       Error group: 3\\n    ///////////////////////////////////*/\\n\\n    /// @dev TrancheVault will call that callback function when a lender deposits assets\\n    function onTrancheDeposit(\\n        uint8 trancheId,\\n        address depositorAddress,\\n        uint amount\\n    ) external authTrancheVault(trancheId) {\\n        // 1. find / create the rewardable\\n        Rewardable storage rewardable = s_trancheRewardables[trancheId][depositorAddress];\\n\\n        // 2. add lender to the lenders set\\n        s_lenders.add(depositorAddress);\\n\\n        // 3. add to the staked assets\\n        rewardable.stakedAssets += amount;\\n        collectedAssets += amount;\\n        s_totalStakedAssetsByTranche[trancheId] += amount;\\n\\n        // 4. set the start of the rewardable\\n        rewardable.start = uint64(block.timestamp);\\n\\n        emit LenderDeposit(depositorAddress, trancheId, amount);\\n        _emitLenderTrancheRewardsChange(depositorAddress, trancheId);\\n    }\\n\\n    /// @dev TrancheVault will call that callback function when a lender withdraws assets\\n    function onTrancheWithdraw(\\n        uint8 trancheId,\\n        address depositorAddress,\\n        uint amount\\n    ) external authTrancheVault(trancheId) whenNotPaused {\\n        require(!s_rollOverSettings[depositorAddress].principal, \\\"LP301\\\"); // \\\"LendingPool: principal locked for rollover\\\"\\n\\n        if (currentStage == Stages.REPAID || currentStage == Stages.FLC_WITHDRAWN) {\\n            emit LenderWithdraw(depositorAddress, trancheId, amount);\\n        } else {\\n            Rewardable storage rewardable = s_trancheRewardables[trancheId][depositorAddress];\\n\\n            assert(rewardable.stakedAssets >= amount);\\n\\n            rewardable.stakedAssets -= amount;\\n            collectedAssets -= amount;\\n            s_totalStakedAssetsByTranche[trancheId] -= amount;\\n\\n            if (rewardable.stakedAssets == 0) {\\n                s_lenders.remove(depositorAddress);\\n            }\\n            emit LenderWithdraw(depositorAddress, trancheId, amount);\\n            _emitLenderTrancheRewardsChange(depositorAddress, trancheId);\\n        }\\n    }\\n\\n    /*///////////////////////////////////\\n       HELPERS\\n    ///////////////////////////////////*/\\n\\n    function trancheVaultContracts() internal view returns (TrancheVault[] memory) {\\n        return PoolCalculations.trancheVaultContracts(this);\\n    }\\n\\n    function _emitLenderTrancheRewardsChange(address lenderAddress, uint8 trancheId) internal {\\n        emit LenderTrancheRewardsChange(\\n            lenderAddress,\\n            trancheId,\\n            lenderEffectiveAprByTrancheWad(lenderAddress, trancheId),\\n            lenderTotalExpectedRewardsByTranche(lenderAddress, trancheId),\\n            lenderRewardsByTrancheRedeemed(lenderAddress, trancheId)\\n        );\\n    }\\n\\n    function _stableCoinContract() internal view returns (IERC20) {\\n        return IERC20(stableCoinContractAddress);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pool/PoolCalculations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport \\\"./LendingPool.sol\\\";\\nimport \\\"../vaults/TrancheVault.sol\\\";\\nimport \\\"../authority/Authority.sol\\\";\\n\\nlibrary PoolCalculations {\\n    uint constant WAD = 10 ** 18;\\n    uint constant YEAR = 365 days;\\n\\n    function _wadPow(uint _xWad, uint _n) internal pure returns (uint) {\\n        uint xWad = _xWad;\\n        uint n = _n;\\n        uint result = n % 2 != 0 ? xWad : WAD;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            xWad = (xWad * xWad) / WAD;\\n\\n            if (n % 2 != 0) {\\n                result = (result * xWad) / WAD;\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    function poolBalanceThreshold(LendingPool lendingPool) public view returns (uint) {\\n        uint borrowedAssets = lendingPool.borrowedAssets();\\n\\n        uint borrowerTotalInterestRateWad = lendingPool.borrowerTotalInterestRateWad();\\n\\n        uint repaymentRecurrenceDays = lendingPool.repaymentRecurrenceDays();\\n\\n        uint gracePeriodDays = lendingPool.gracePeriodDays();\\n\\n        uint firstLossAssets = lendingPool.firstLossAssets();\\n\\n        uint dailyBorrowerInterestAmount = (borrowedAssets * borrowerTotalInterestRateWad) / WAD / 365;\\n\\n        uint interestGoDownAmount = (repaymentRecurrenceDays + gracePeriodDays) * dailyBorrowerInterestAmount;\\n\\n        if (interestGoDownAmount > firstLossAssets) {\\n            return 0;\\n        }\\n\\n        uint threshold = firstLossAssets - interestGoDownAmount;\\n\\n        return threshold;\\n    }\\n\\n    function poolBalance(LendingPool lendingPool) public view returns (uint) {\\n        uint firstLossAssets = lendingPool.firstLossAssets();\\n        uint borrowerInterestRepaid = lendingPool.borrowerInterestRepaid();\\n        uint allLendersInterestByDate = lendingPool.allLendersInterestByDate();\\n\\n        uint positiveBalance = firstLossAssets + borrowerInterestRepaid;\\n        if (allLendersInterestByDate > positiveBalance) {\\n            return 0;\\n        }\\n        return positiveBalance - allLendersInterestByDate;\\n    }\\n\\n    function borrowerPenaltyAmount(LendingPool lendingPool) public view returns (uint) {\\n        uint poolBalance = lendingPool.poolBalance();\\n\\n        uint poolBalanceThreshold = lendingPool.poolBalanceThreshold();\\n\\n        uint collectedAssets = lendingPool.collectedAssets();\\n\\n        uint allLendersEffectiveAprWad = lendingPool.allLendersEffectiveAprWad();\\n\\n        uint penaltyRateWad = lendingPool.penaltyRateWad();\\n\\n        if (poolBalance >= poolBalanceThreshold) {\\n            return 0;\\n        }\\n\\n        uint dailyLendersInterestAmount = (collectedAssets * allLendersEffectiveAprWad) / WAD / 365;\\n\\n        uint balanceDifference = poolBalanceThreshold - poolBalance;\\n\\n        uint daysDelinquent = balanceDifference / dailyLendersInterestAmount;\\n\\n        if (daysDelinquent == 0) {\\n            return 0;\\n        }\\n\\n        uint penaltyCoefficientWad = _wadPow(WAD + penaltyRateWad, daysDelinquent);\\n\\n        uint penalty = (balanceDifference * penaltyCoefficientWad) / WAD - balanceDifference;\\n\\n        return penalty;\\n    }\\n\\n    function borrowerExpectedInterest(\\n        uint collectedAssets,\\n        uint borrowerAdjustedInterestRateWad\\n    ) public pure returns (uint) {\\n        return (collectedAssets * borrowerAdjustedInterestRateWad) / WAD;\\n    }\\n\\n    function borrowerOutstandingInterest(\\n        uint borrowerInterestRepaid,\\n        uint borrowerExpectedInterest\\n    ) public pure returns (uint) {\\n        if (borrowerInterestRepaid > borrowerExpectedInterest) {\\n            return 0;\\n        }\\n        return borrowerExpectedInterest - borrowerInterestRepaid;\\n    }\\n\\n    function borrowerExcessSpread(LendingPool lendingPool) public view returns (uint) {\\n        uint borrowerInterestRepaid = lendingPool.borrowerInterestRepaid();\\n        uint allLendersInterest = lendingPool.allLendersInterest();\\n        uint borrowerExpectedInterest = lendingPool.borrowerExpectedInterest();\\n        uint protocolFeeWad = lendingPool.protocolFeeWad();\\n\\n        if (borrowerOutstandingInterest(borrowerInterestRepaid, borrowerExpectedInterest) > 0) {\\n            return 0;\\n        }\\n        uint fees = (borrowerExpectedInterest * protocolFeeWad) / WAD;\\n        return borrowerInterestRepaid - allLendersInterest - fees;\\n    }\\n\\n    function borrowerAdjustedInterestRateWad(\\n        uint borrowerTotalInterestRateWad,\\n        uint lendingTermSeconds\\n    ) public pure returns (uint adj) {\\n        return (borrowerTotalInterestRateWad * lendingTermSeconds) / YEAR;\\n    }\\n\\n    function lenderEffectiveAprByTrancheWad(\\n        LendingPool lendingPool,\\n        address lenderAddress,\\n        uint8 trancheId\\n    ) public view returns (uint) {\\n        uint stakedAssets = lendingPool.lenderStakedTokensByTranche(lenderAddress, trancheId);\\n        uint lockedPlatformTokens = lendingPool.lenderPlatformTokensByTrancheLocked(lenderAddress, trancheId);\\n        uint trancheBoostRatio = lendingPool.trancheBoostRatios(trancheId);\\n        uint trancheAPRWad = lendingPool.trancheAPRsWads(trancheId);\\n        uint trancheBoostedAPRWad = lendingPool.trancheBoostedAPRsWads(trancheId);\\n\\n        if (stakedAssets == 0) {\\n            return 0;\\n        }\\n        uint boostedAssets = lockedPlatformTokens / trancheBoostRatio;\\n        if (boostedAssets > stakedAssets) {\\n            boostedAssets = stakedAssets;\\n        }\\n        uint unBoostedAssets = stakedAssets - boostedAssets;\\n        uint weightedAverage = (unBoostedAssets * trancheAPRWad + boostedAssets * trancheBoostedAPRWad) / stakedAssets;\\n        return weightedAverage;\\n    }\\n\\n    function lenderRewardsByTrancheGeneratedByDate(\\n        LendingPool lendingPool,\\n        address lenderAddress,\\n        uint8 trancheId\\n    ) public view returns (uint) {\\n        uint fundedAt = lendingPool.fundedAt();\\n        if (fundedAt == 0) {\\n            return 0;\\n        }\\n        uint lenderDepositedAssets = lendingPool.lenderDepositedAssetsByTranche(lenderAddress, trancheId);\\n        uint lenderEffectiveApr = lendingPool.lenderEffectiveAprByTrancheWad(lenderAddress, trancheId);\\n        uint lendingTermSeconds = lendingPool.lendingTermSeconds();\\n\\n        uint secondsElapsed = block.timestamp - fundedAt;\\n        if (secondsElapsed > lendingTermSeconds) {\\n            secondsElapsed = lendingTermSeconds;\\n        }\\n        return (lenderDepositedAssets * lenderEffectiveApr * secondsElapsed) / (YEAR * WAD);\\n    }\\n\\n    function lenderTotalExpectedRewardsByTranche(\\n        uint lenderDepositedAssets,\\n        uint lenderEffectiveApr,\\n        uint lendingTermSeconds\\n    ) public pure returns (uint) {\\n        return (lenderDepositedAssets * lenderEffectiveApr * lendingTermSeconds) / (YEAR * WAD);\\n    }\\n\\n    function lenderTotalAprWad(LendingPool lendingPool, address lenderAddress) public view returns (uint) {\\n        uint256 tranchesCount = lendingPool.tranchesCount();\\n\\n        uint weightedApysWad = 0;\\n        uint totalAssets = 0;\\n        for (uint8 i; i < tranchesCount; i++) {\\n            uint staked = lendingPool.lenderStakedTokensByTranche(lenderAddress, i);\\n            totalAssets += staked;\\n            weightedApysWad += (lendingPool.lenderEffectiveAprByTrancheWad(lenderAddress, i) * staked);\\n        }\\n\\n        if (totalAssets == 0) {\\n            return 0;\\n        }\\n\\n        return weightedApysWad / totalAssets;\\n    }\\n\\n    function allLendersEffectiveAprWad(LendingPool lendingPool, uint256 tranchesCount) public view returns (uint) {\\n        uint weightedSum = 0;\\n        uint totalStakedAssets = 0;\\n        for (uint8 trancheId; trancheId < tranchesCount; trancheId++) {\\n            uint stakedAssets = lendingPool.s_totalStakedAssetsByTranche(trancheId);\\n            totalStakedAssets += stakedAssets;\\n\\n            uint boostedAssets = lendingPool.s_totalLockedPlatformTokensByTranche(trancheId) /\\n                lendingPool.trancheBoostRatios(trancheId);\\n            if (boostedAssets > stakedAssets) {\\n                boostedAssets = stakedAssets;\\n            }\\n            uint unBoostedAssets = stakedAssets - boostedAssets;\\n\\n            weightedSum += unBoostedAssets * lendingPool.trancheAPRsWads(trancheId);\\n            weightedSum += boostedAssets * lendingPool.trancheBoostedAPRsWads(trancheId);\\n        }\\n\\n        return weightedSum / totalStakedAssets;\\n    }\\n\\n    function allLendersInterestByDate(LendingPool lendingPool) public view returns (uint) {\\n        uint256 fundedAt = lendingPool.fundedAt();\\n        uint256 lendingTermSeconds = lendingPool.lendingTermSeconds();\\n        if (fundedAt == 0 || block.timestamp <= fundedAt) {\\n            return 0;\\n        }\\n        uint time = block.timestamp < fundedAt + lendingTermSeconds ? block.timestamp : fundedAt + lendingTermSeconds;\\n        uint elapsedTime = time - fundedAt;\\n        return (lendingPool.allLendersInterest() * elapsedTime) / lendingTermSeconds;\\n    }\\n\\n    function trancheVaultContracts(LendingPool lendingPool) public view returns (TrancheVault[] memory contracts) {\\n        uint256 trancheCount = lendingPool.tranchesCount();\\n        contracts = new TrancheVault[](trancheCount);\\n\\n        for (uint i; i < contracts.length; ++i) {\\n            contracts[i] = TrancheVault(lendingPool.trancheVaultAddresses(i));\\n        }\\n    }\\n\\n    function validateInitParams(\\n        LendingPool.LendingPoolParams calldata params,\\n        address[] calldata _trancheVaultAddresses,\\n        address _feeSharingContractAddress,\\n        address _authorityAddress\\n    ) public view {\\n        require(params.stableCoinContractAddress != address(0), \\\"LP005\\\"); // \\\"LendingPool: stableCoinContractAddress empty\\\"\\n\\n        require(params.minFundingCapacity > 0, \\\"LP006\\\"); // \\\"LendingPool: minFundingCapacity == 0\\\"\\n        require(params.maxFundingCapacity > 0, \\\"LP007\\\"); // \\\"LendingPool: maxFundingCapacity == 0\\\"\\n        require(\\n            params.maxFundingCapacity >= params.minFundingCapacity,\\n            \\\"LP008\\\" // \\\"LendingPool: maxFundingCapacity < minFundingCapacity\\\"\\n        );\\n\\n        require(params.fundingPeriodSeconds > 0, \\\"LP009\\\"); // \\\"LendingPool: fundingPeriodSeconds == 0\\\"\\n        require(params.lendingTermSeconds > 0, \\\"LP010\\\"); // \\\"LendingPool: lendingTermSeconds == 0\\\"\\n        require(params.borrowerAddress != address(0), \\\"LP011\\\"); // \\\"LendingPool: borrowerAddress empty\\\"\\n        require(Authority(_authorityAddress).isWhitelistedBorrower(params.borrowerAddress), \\\"LP023\\\");\\n        require(params.borrowerTotalInterestRateWad > 0, \\\"LP012\\\"); // \\\"LendingPool: borrower interest rate = 0%\\\"\\n        require(params.protocolFeeWad > 0, \\\"LP013\\\"); // \\\"LendingPool: protocolFee == 0%\\\"\\n        require(params.penaltyRateWad > 0, \\\"LP014\\\"); // \\\"LendingPool: penaltyRate == 0\\\"\\n\\n        require(params.tranchesCount > 0, \\\"LP015\\\"); // \\\"LendingPool: tranchesCount == 0\\\"\\n        require(_trancheVaultAddresses.length == params.tranchesCount, \\\"LP016\\\"); // \\\"LendingPool: trancheAddresses length\\\"\\n        require(params.trancheAPRsWads.length == params.tranchesCount, \\\"LP017\\\"); // \\\"LP001\\\");// \\\"LendingPool: tranche APRs length\\\"\\n        require(\\n            params.trancheBoostedAPRsWads.length == params.tranchesCount,\\n            \\\"LP018\\\" // \\\"LendingPool: tranche Boosted APRs length\\\"\\n        );\\n        require(\\n            params.trancheBoostedAPRsWads.length == params.tranchesCount,\\n            \\\"LP019\\\" // \\\"LendingPool: tranche Coverage APRs length\\\"\\n        );\\n\\n        for (uint i; i < params.tranchesCount; ++i) {\\n            require(params.trancheAPRsWads[i] > 0, \\\"tranche APRs == 0\\\");\\n            require(\\n                params.trancheBoostedAPRsWads[i] >= params.trancheAPRsWads[i],\\n                \\\"LP020\\\" // \\\"LendingPool: tranche boosted APRs < tranche APRs\\\"\\n            );\\n        }\\n\\n        require(_feeSharingContractAddress != address(0), \\\"LP021\\\"); // \\\"LendingPool: feeSharingAddress empty\\\"\\n        require(_authorityAddress != address(0), \\\"LP022\\\"); // \\\"LendingPool: authorityAddress empty\\\"\\n    }\\n\\n    function validateWad(uint256[] memory ints) external pure {\\n        for (uint256 i = 0; i < ints.length; i++) {\\n            require(ints[i] <= 1e18, \\\"LP024 - bad wad\\\");\\n        }\\n    }\\n\\n    function setInitializer(\\n        LendingPool.LendingPoolParams calldata params,\\n        string storage name,\\n        string storage token,\\n        uint[] storage trancheAPRsWads,\\n        uint[] storage trancheBoostedAPRsWads,\\n        uint[] storage trancheBoostRatios,\\n        uint[] storage trancheCoveragesWads\\n    ) public {\\n        bytes memory nameBytes = bytes(params.name);\\n        bytes memory tokenBytes = bytes(params.token);\\n\\n        for (uint i = 0; i < nameBytes.length; i++) {\\n            bytes(name)[i] = nameBytes[i];\\n        }\\n\\n        for (uint i = 0; i < tokenBytes.length; i++) {\\n            bytes(token)[i] = tokenBytes[i];\\n        }\\n\\n        for (uint i = 0; i < params.trancheAPRsWads.length; i++) {\\n            trancheAPRsWads[i] = params.trancheAPRsWads[i];\\n        }\\n\\n        for (uint i = 0; i < params.trancheBoostedAPRsWads.length; i++) {\\n            trancheBoostedAPRsWads[i] = params.trancheBoostedAPRsWads[i];\\n        }\\n\\n        for (uint i = 0; i < params.trancheBoostRatios.length; i++) {\\n            trancheBoostRatios[i] = params.trancheBoostRatios[i];\\n        }\\n\\n        for (uint i = 0; i < params.trancheCoveragesWads.length; i++) {\\n            trancheCoveragesWads[i] = params.trancheCoveragesWads[i];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pool/PoolTransfers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport \\\"./LendingPool.sol\\\";\\n\\nimport \\\"../factory/PoolFactory.sol\\\";\\nimport \\\"../vaults/TrancheVault.sol\\\";\\n\\nlibrary PoolTransfers {\\n    function lenderEnableRollOver(\\n        LendingPool lendingPool,\\n        bool principal,\\n        bool rewards,\\n        bool platformTokens,\\n        address lender\\n    ) external {\\n        PoolFactory poolFactory = PoolFactory(lendingPool.poolFactoryAddress());\\n        uint256 lockedPlatformTokens;\\n        uint256 trancheCount = lendingPool.tranchesCount();\\n        for (uint8 trancheId; trancheId < trancheCount; trancheId++) {\\n            (uint256 staked, , , ) = lendingPool.s_trancheRewardables(trancheId, lender);\\n            TrancheVault vault = TrancheVault(lendingPool.trancheVaultAddresses(trancheId));\\n            (, uint256 locked, , ) = lendingPool.s_trancheRewardables(trancheId, lender);\\n            lockedPlatformTokens += locked;\\n            vault.approveRollover(lender, staked);\\n        }\\n\\n        address[4] memory futureLenders = poolFactory.nextLenders();\\n        for (uint256 i = 0; i < futureLenders.length; i++) {\\n            SafeERC20.safeApprove(\\n                IERC20(lendingPool.platformTokenContractAddress()),\\n                futureLenders[i],\\n                0\\n            );\\n            // approve transfer of platform tokens\\n            SafeERC20.safeApprove(\\n                IERC20(lendingPool.platformTokenContractAddress()),\\n                futureLenders[i],\\n                lockedPlatformTokens\\n            );\\n\\n            SafeERC20.safeApprove(\\n                IERC20(lendingPool.stableCoinContractAddress()),\\n                futureLenders[i],\\n                0\\n            );\\n            // approve transfer of the stablecoin contract\\n            SafeERC20.safeApprove(\\n                IERC20(lendingPool.stableCoinContractAddress()), // asume tranches.asset() == stablecoin address\\n                futureLenders[i],\\n                2 ** 256 - 1 // infinity approve because we don't know how much interest will need to be accounted for\\n            );\\n        }\\n    }\\n\\n    function executeRollover(\\n        LendingPool lendingPool,\\n        address deadLendingPoolAddr,\\n        address[] memory deadTrancheAddrs,\\n        uint256 lenderStartIndex,\\n        uint256 lenderEndIndex\\n    ) external {\\n        uint256 tranchesCount = lendingPool.tranchesCount();\\n        require(tranchesCount == deadTrancheAddrs.length, \\\"tranche array mismatch\\\");\\n        require(\\n            keccak256(deadLendingPoolAddr.code) == keccak256(address(this).code),\\n            \\\"rollover incampatible due to version mismatch\\\"\\n        ); // upgrades to the next contract need to be set before users are allowed to rollover in the current contract\\n        // should do a check to ensure there aren't more than n protocols running in parallel, if this is true, the protocol will revert for reasons unknown to future devs\\n        LendingPool deadpool = LendingPool(deadLendingPoolAddr);\\n        for (uint256 i = lenderStartIndex; i <= lenderEndIndex; i++) {\\n            address lender = deadpool.lendersAt(i);\\n            LendingPool.RollOverSetting memory settings = LendingPool(deadLendingPoolAddr).lenderRollOverSettings(lender);\\n            if (!settings.enabled) {\\n                continue;\\n            }\\n\\n            for (uint8 trancheId; trancheId < tranchesCount; trancheId++) {\\n                TrancheVault vault = TrancheVault(lendingPool.trancheVaultAddresses(trancheId));\\n                uint256 rewards = settings.rewards ? deadpool.lenderRewardsByTrancheRedeemable(lender, trancheId) : 0;\\n                // lenderRewardsByTrancheRedeemable will revert if the lender has previously withdrawn\\n                // transfer rewards from dead lender to dead tranche\\n                SafeERC20.safeTransferFrom(\\n                    IERC20(lendingPool.stableCoinContractAddress()),\\n                    deadLendingPoolAddr,\\n                    deadTrancheAddrs[trancheId],\\n                    rewards\\n                );\\n\\n                vault.rollover(lender, deadTrancheAddrs[trancheId], rewards);\\n            }\\n\\n            // ask deadpool to move platform token into this new contract\\n            IERC20 platoken = IERC20(lendingPool.platformTokenContractAddress());\\n            uint256 platokens = platoken.allowance(deadLendingPoolAddr, address(this));\\n            SafeERC20.safeTransferFrom(platoken, deadLendingPoolAddr, address(this), platokens);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vaults/TrancheVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\n\\nimport \\\"../authority/AuthorityAware.sol\\\";\\nimport \\\"../pool/LendingPool.sol\\\";\\nimport \\\"../factory/PoolFactory.sol\\\";\\n\\ncontract TrancheVault is Initializable, ERC4626Upgradeable, PausableUpgradeable, AuthorityAware {\\n    using MathUpgradeable for uint256;\\n\\n    /*////////////////////////////////////////////////\\n      State\\n    ////////////////////////////////////////////////*/\\n\\n    mapping(address => mapping(address => uint256)) approvedRollovers;\\n\\n    /* id */\\n    uint8 private s_id;\\n    event ChangeId(uint8 oldValue, uint8 newValue);\\n\\n    function id() public view returns (uint8) {\\n        return s_id;\\n    }\\n\\n    function _setId(uint8 newValue) internal {\\n        uint8 oldValue = s_id;\\n        s_id = newValue;\\n        emit ChangeId(oldValue, newValue);\\n    }\\n\\n    /* poolAddress */\\n    address private s_poolAddress;\\n    event ChangePoolAddress(address oldValue, address newValue);\\n\\n    function poolAddress() public view returns (address) {\\n        return s_poolAddress;\\n    }\\n\\n    function _setPoolAddress(address newValue) internal {\\n        address oldValue = s_poolAddress;\\n        s_poolAddress = newValue;\\n        emit ChangePoolAddress(oldValue, newValue);\\n    }\\n\\n    /* minFundingCapacity */\\n    uint256 private s_minFundingCapacity;\\n    event ChangeMinFundingCapacity(uint256 oldValue, uint256 newValue);\\n\\n    function minFundingCapacity() public view returns (uint256) {\\n        return s_minFundingCapacity;\\n    }\\n\\n    function _setMinFundingCapacity(uint256 newValue) internal {\\n        uint256 oldValue = s_minFundingCapacity;\\n        s_minFundingCapacity = newValue;\\n        emit ChangeMinFundingCapacity(oldValue, newValue);\\n    }\\n\\n    /* maxFundingCapacity */\\n    uint256 private s_maxFundingCapacity;\\n    event ChangeMaxFundingCapacity(uint256 oldValue, uint256 newValue);\\n\\n    function maxFundingCapacity() public view returns (uint256) {\\n        return s_maxFundingCapacity;\\n    }\\n\\n    function _setMaxFundingCapacity(uint256 newValue) internal {\\n        uint256 oldValue = s_maxFundingCapacity;\\n        s_maxFundingCapacity = newValue;\\n        emit ChangeMaxFundingCapacity(oldValue, newValue);\\n    }\\n\\n    /* withdrawEnabled */\\n    bool private s_withdrawEnabled;\\n    event ChangeWithdrawEnabled(address indexed actor, bool oldValue, bool newValue);\\n\\n    function withdrawEnabled() public view returns (bool) {\\n        return s_withdrawEnabled;\\n    }\\n\\n    function _setWithdrawEnabled(bool newValue) internal {\\n        bool oldValue = s_withdrawEnabled;\\n        s_withdrawEnabled = newValue;\\n        emit ChangeWithdrawEnabled(msg.sender, oldValue, newValue);\\n    }\\n\\n    /* depositEnabled */\\n    bool private s_depositEnabled;\\n    event ChangeDepositEnabled(address indexed actor, bool oldValue, bool newValue);\\n\\n    function depositEnabled() public view returns (bool) {\\n        return s_depositEnabled;\\n    }\\n\\n    function _setDepositEnabled(bool newValue) internal {\\n        bool oldValue = s_depositEnabled;\\n        s_depositEnabled = newValue;\\n        emit ChangeDepositEnabled(msg.sender, oldValue, newValue);\\n    }\\n\\n    /* transferEnabled */\\n    bool private s_transferEnabled;\\n    event ChangeTransferEnabled(address indexed actor, bool oldValue, bool newValue);\\n\\n    function transferEnabled() public view returns (bool) {\\n        return s_transferEnabled;\\n    }\\n\\n    function _setTransferEnabled(bool newValue) internal {\\n        bool oldValue = s_transferEnabled;\\n        s_transferEnabled = newValue;\\n        emit ChangeTransferEnabled(msg.sender, oldValue, newValue);\\n    }\\n\\n    /* defaultRatio */\\n    uint private s_defaultRatioWad;\\n    event ChangeDefaultRatio(address indexed actor, uint oldValue, uint newValue);\\n\\n    function defaultRatioWad() public view returns (uint) {\\n        return s_defaultRatioWad;\\n    }\\n\\n    function isDefaulted() public view returns (bool) {\\n        return s_defaultRatioWad != 0;\\n    }\\n\\n    function _setDefaultRatioWad(uint newValue) internal {\\n        uint oldValue = s_defaultRatioWad;\\n        s_defaultRatioWad = newValue;\\n        emit ChangeDefaultRatio(msg.sender, oldValue, newValue);\\n    }\\n\\n    function setDefaultRatioWad(uint newValue) external onlyPool {\\n        _setDefaultRatioWad(newValue);\\n    }\\n\\n    /*////////////////////////////////////////////////\\n      Modifiers\\n    ////////////////////////////////////////////////*/\\n    modifier onlyPool() {\\n        require(_msgSender() == poolAddress(), \\\"Vault: onlyPool\\\");\\n        _;\\n    }\\n\\n    modifier onlyDeadTranche() {\\n        LendingPool pool = LendingPool(s_poolAddress);\\n        PoolFactory factory = PoolFactory(pool.poolFactoryAddress());\\n        require(factory.prevDeployedTranche(msg.sender), \\\"Vault: onlyDeadTranche\\\");\\n        _;\\n    }\\n\\n    modifier onlyOwnerOrPool() {\\n        require(_msgSender() == poolAddress() || _msgSender() == owner(), \\\"Vault: onlyOwnerOrPool\\\");\\n        _;\\n    }\\n\\n    modifier whenWithdrawEnabled() {\\n        require(withdrawEnabled(), \\\"Vault: withdraw disabled\\\");\\n        _;\\n    }\\n\\n    modifier whenDepositEnabled() {\\n        require(depositEnabled(), \\\"Vault: deposit disabled\\\");\\n        _;\\n    }\\n\\n    modifier whenTransferEnabled() {\\n        require(transferEnabled(), \\\"Vault: transfer disabled\\\");\\n        _;\\n    }\\n\\n    function _isWhitelisted(address) internal virtual returns (bool) {\\n        return true;\\n    }\\n\\n    /*////////////////////////////////////////////////\\n      CONSTRUCTOR\\n    ////////////////////////////////////////////////*/\\n    function initialize(\\n        address _poolAddress,\\n        uint8 _trancheId,\\n        uint _minCapacity,\\n        uint _maxCapacity,\\n        string memory _tokenName,\\n        string memory _symbol,\\n        address _underlying,\\n        address _authority\\n    ) external initializer {\\n        if (_minCapacity > _maxCapacity) {\\n            uint256 tmpMin = _minCapacity;\\n            _minCapacity = _maxCapacity;\\n            _maxCapacity = tmpMin;\\n        }\\n        require(_minCapacity <= _maxCapacity, \\\"Vault: min > max\\\");\\n        _setPoolAddress(_poolAddress);\\n        _setId(_trancheId);\\n        _setMinFundingCapacity(_minCapacity);\\n        _setMaxFundingCapacity(_maxCapacity);\\n        __ERC20_init(_tokenName, _symbol);\\n        __Pausable_init();\\n        __Ownable_init();\\n        __ERC4626_init(IERC20Upgradeable(_underlying));\\n        __AuthorityAware__init(_authority);\\n    }\\n\\n    /*////////////////////////////////////////////////\\n        ADMIN METHODS\\n    ////////////////////////////////////////////////*/\\n\\n    /** @dev enables deposits to the vault */\\n    function enableDeposits() external onlyOwnerOrPool {\\n        _setDepositEnabled(true);\\n    }\\n\\n    /** @dev disables deposits to the vault */\\n    function disableDeposits() external onlyOwnerOrPool {\\n        _setDepositEnabled(false);\\n    }\\n\\n    /** @dev enables withdrawals from the vault*/\\n    function enableWithdrawals() external onlyOwnerOrPool {\\n        _setWithdrawEnabled(true);\\n    }\\n\\n    /** @dev disables withdrawals from the vault*/\\n    function disableWithdrawals() external onlyOwnerOrPool {\\n        _setWithdrawEnabled(false);\\n    }\\n\\n    /** @dev enables vault token transfers */\\n    function enableTransfers() external onlyOwnerOrPool {\\n        _setTransferEnabled(true);\\n    }\\n\\n    /** @dev disables vault token transfers */\\n    function disableTransfers() external onlyOwnerOrPool {\\n        _setTransferEnabled(false);\\n    }\\n\\n    /** @dev Pauses the pool */\\n    function pause() external onlyOwnerOrAdmin {\\n        _pause();\\n    }\\n\\n    /** @dev Unpauses the pool */\\n    function unpause() external onlyOwnerOrAdmin {\\n        _unpause();\\n    }\\n\\n    /** @dev called by the pool in order to send assets*/\\n    function sendAssetsToPool(uint assets) external onlyPool whenNotPaused {\\n        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(asset()), poolAddress(), assets);\\n    }\\n\\n    /**@dev used to approve the process of the rollover to deployments that do not yet exist (executed with older tranche before creation of next tranche) */\\n    function approveRollover(address lender, uint256 assets) external onlyOwnerOrPool {\\n        LendingPool pool = LendingPool(poolAddress());\\n        PoolFactory factory = PoolFactory(pool.poolFactoryAddress());\\n\\n        address[8] memory futureTranches = factory.nextTranches();\\n        for (uint256 i = 0; i < futureTranches.length; i++) {\\n            //super.approve(futureTranches[i], convertToShares(amount));\\n            approvedRollovers[lender][futureTranches[i]] = assets;\\n        }\\n    }\\n\\n    function executeRolloverAndBurn(address lender, uint256 rewards) external onlyDeadTranche whenNotPaused returns (uint256) {\\n        TrancheVault newTranche = TrancheVault(_msgSender());\\n        uint256 assets = approvedRollovers[lender][address(newTranche)] + rewards;\\n        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(asset()), address(newTranche), assets);\\n        uint256 shares = convertToAssets(assets - rewards);\\n        _burn(lender, shares);\\n        return assets;\\n    }\\n\\n    /**@dev used to process the rollover (executed with newer tranche on deploy) */\\n    function rollover(address lender, address deadTrancheAddr, uint256 rewards) external onlyPool {\\n        TrancheVault deadTranche = TrancheVault(deadTrancheAddr);\\n        require(deadTranche.asset() == asset(), \\\"Incompatible asset types\\\");\\n        // transfer in capital from prev tranche\\n        uint256 assetsRolled = deadTranche.executeRolloverAndBurn(lender, rewards);\\n        IERC20Upgradeable(asset()).approve(address(this), assetsRolled);\\n        uint256 shares = previewDeposit(assetsRolled);\\n        _deposit(address(this), lender, assetsRolled, shares);\\n    }\\n\\n    /*////////////////////////////////////////////////\\n        ERC-4626 Overrides\\n    ////////////////////////////////////////////////*/\\n    /** @dev Deposit asset to the pool\\n     *      See {IERC4626-deposit}.\\n     * @param assets amount of underlying asset to deposit\\n     * @param receiver receiver address (just set it to msg sender)\\n     * @return amount of pool tokens minted for the deposit\\n     */\\n    function deposit(\\n        uint256 assets,\\n        address receiver\\n    ) public virtual override whenNotPaused onlyLender whenDepositEnabled returns (uint256) {\\n        return super.deposit(assets, receiver);\\n    }\\n\\n    /** @dev See {IERC4626-mint} */\\n    function mint(\\n        uint256 shares,\\n        address receiver\\n    ) public virtual override whenNotPaused onlyLender whenDepositEnabled returns (uint256) {\\n        return super.mint(shares, receiver);\\n    }\\n\\n    /** @dev Withdraw principal from the pool\\n     * See {IERC4626-withdraw}.\\n     * @param assets amount of underlying asset to withdraw\\n     * @param receiver address to which the underlying assets should be sent\\n     * @param owner owner of the principal (just use msg sender)\\n     * @return amount of pool tokens burned after withdrawal\\n     */\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) public override onlyLender whenNotPaused whenWithdrawEnabled returns (uint256) {\\n        return super.withdraw(assets, receiver, owner);\\n    }\\n\\n    /** @dev See {IERC4626-redeem}. */\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public override onlyLender whenNotPaused whenWithdrawEnabled returns (uint256) {\\n        return super.redeem(shares, receiver, owner);\\n    }\\n\\n    /** @dev Maximum amount of assets that the vault will accept\\n     *  See {IERC4626-maxDeposit}.\\n     *  @param . lender address (just set it to msg sender)\\n     *  @return maximum amount of assets that can be deposited to the pool\\n     */\\n    function maxDeposit(address) public view override returns (uint256) {\\n        if (paused() || !depositEnabled()) {\\n            return 0;\\n        }\\n        if (totalAssets() >= maxFundingCapacity()) {\\n            return 0;\\n        }\\n        return maxFundingCapacity() - totalAssets();\\n    }\\n\\n    /** @dev See {IERC4626-totalAssets}. */\\n    function totalAssets() public view override returns (uint256) {\\n        return convertToAssets(totalSupply());\\n    }\\n\\n    /** @dev See {IERC4626-maxMint}. */\\n    function maxMint(address) public view override returns (uint256) {\\n        return convertToShares(maxDeposit(msg.sender));\\n    }\\n\\n    /** @dev See {IERC4626-maxWithdraw}. */\\n    function maxWithdraw(address owner) public view override returns (uint256) {\\n        if (paused() || !withdrawEnabled()) {\\n            return 0;\\n        }\\n        return _convertToAssets(balanceOf(owner), MathUpgradeable.Rounding.Down);\\n    }\\n\\n    /** @dev See {IERC4626-maxRedeem}. */\\n    function maxRedeem(address owner) public view override returns (uint256) {\\n        if (paused() || !withdrawEnabled()) {\\n            return 0;\\n        }\\n        return balanceOf(owner);\\n    }\\n\\n    /** @dev will return 1:1 */\\n    function _convertToShares(\\n        uint256 assets,\\n        MathUpgradeable.Rounding rounding\\n    ) internal view override returns (uint256 shares) {\\n        if (isDefaulted()) {\\n            return assets.mulDiv(10 ** 18, s_defaultRatioWad, rounding);\\n        }\\n        return _initialConvertToShares(assets, rounding);\\n    }\\n\\n    /** @dev will return 1:1 */\\n    function _convertToAssets(\\n        uint256 shares,\\n        MathUpgradeable.Rounding rounding\\n    ) internal view override returns (uint256 assets) {\\n        if (isDefaulted()) {\\n            return shares.mulDiv(s_defaultRatioWad, 10 ** 18, rounding);\\n        }\\n        return _initialConvertToAssets(shares, rounding); // 1:1\\n    }\\n\\n    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal whenNotPaused override {\\n        // If _asset is ERC777, `transferFrom` can trigger a reenterancy BEFORE the transfer happens through the\\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\\n        // calls the vault, which is assumed not malicious.\\n        //\\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\\n        // assets are transferred and before the shares are minted, which is a valid state.\\n        // slither-disable-next-line reentrancy-no-eth\\n        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(asset()), caller, address(this), assets);\\n        _mint(receiver, shares);\\n        LendingPool(poolAddress()).onTrancheDeposit(id(), receiver, assets);\\n\\n        emit Deposit(caller, receiver, assets, shares);\\n    }\\n\\n    /**\\n     * @dev Withdraw/redeem common workflow.\\n     */\\n    function _withdraw(\\n        address caller,\\n        address receiver,\\n        address owner,\\n        uint256 assets,\\n        uint256 shares\\n    ) internal override whenNotPaused {\\n        if (caller != owner) {\\n            _spendAllowance(owner, caller, shares);\\n        }\\n\\n        _burn(owner, shares);\\n        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(asset()), receiver, assets);\\n        LendingPool(poolAddress()).onTrancheWithdraw(id(), owner, assets);\\n\\n        emit Withdraw(caller, receiver, owner, assets, shares);\\n    }\\n\\n    /*////////////////////////////////////////////////\\n        ERC20Upgradeable overrides\\n    ////////////////////////////////////////////////*/\\n    function _transfer(address, address, uint256) internal override whenNotPaused whenTransferEnabled {\\n        revert(\\\"Transfers are not implemented\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[]", "ContractName": "PoolTransfers", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "10", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}