{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/actions/ActionGuards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../../global/StorageLayoutV1.sol\\\";\\nimport \\\"../../internal/nToken/nTokenHandler.sol\\\";\\n\\nabstract contract ActionGuards is StorageLayoutV1 {\\n    uint256 internal constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    function initializeReentrancyGuard() internal {\\n        require(reentrancyStatus == 0);\\n\\n        // Initialize the guard to a non-zero value, see the OZ reentrancy guard\\n        // description for why this is more gas efficient:\\n        // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol\\n        reentrancyStatus = _NOT_ENTERED;\\n    }\\n\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(reentrancyStatus != _ENTERED, \\\"Reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        reentrancyStatus = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        reentrancyStatus = _NOT_ENTERED;\\n    }\\n\\n    // These accounts cannot receive deposits, transfers, fCash or any other\\n    // types of value transfers.\\n    function requireValidAccount(address account) internal view {\\n        require(account != Constants.RESERVE); // Reserve address is address(0)\\n        require(account != address(this));\\n        (\\n            uint256 isNToken,\\n            /* incentiveAnnualEmissionRate */,\\n            /* lastInitializedTime */,\\n            /* assetArrayLength */,\\n            /* parameters */\\n        ) = nTokenHandler.getNTokenContext(account);\\n        require(isNToken == 0);\\n    }\\n\\n    /// @dev Throws if called by any account other than the owner.\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function _checkValidCurrency(uint16 currencyId) internal view {\\n        require(0 < currencyId && currencyId <= maxCurrencyId, \\\"Invalid currency id\\\");\\n    }\\n}\"\r\n    },\r\n    \"contracts/external/actions/BatchAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./TradingAction.sol\\\";\\nimport \\\"./ActionGuards.sol\\\";\\nimport \\\"./nTokenMintAction.sol\\\";\\nimport \\\"./nTokenRedeemAction.sol\\\";\\nimport \\\"../SettleAssetsExternal.sol\\\";\\nimport \\\"../FreeCollateralExternal.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"../../global/StorageLayoutV1.sol\\\";\\nimport \\\"../../internal/balances/BalanceHandler.sol\\\";\\nimport \\\"../../internal/portfolio/PortfolioHandler.sol\\\";\\nimport \\\"../../internal/AccountContextHandler.sol\\\";\\nimport \\\"../../../interfaces/notional/NotionalCallback.sol\\\";\\n\\ncontract BatchAction is StorageLayoutV1, ActionGuards {\\n    using BalanceHandler for BalanceState;\\n    using PortfolioHandler for PortfolioState;\\n    using AccountContextHandler for AccountContext;\\n    using AssetRate for AssetRateParameters;\\n    using TokenHandler for Token;\\n    using SafeInt256 for int256;\\n\\n    /// @notice Executes a batch of balance transfers including minting and redeeming nTokens.\\n    /// @param account the account for the action\\n    /// @param actions array of balance actions to take, must be sorted by currency id\\n    /// @dev emit:CashBalanceChange, emit:nTokenSupplyChange\\n    /// @dev auth:msg.sender auth:ERC1155\\n    function batchBalanceAction(address account, BalanceAction[] calldata actions)\\n        external\\n        payable\\n        nonReentrant\\n    {\\n        require(account == msg.sender || msg.sender == address(this), \\\"Unauthorized\\\");\\n        requireValidAccount(account);\\n\\n        AccountContext memory accountContext = _settleAccountIfRequired(account);\\n        BalanceState memory balanceState;\\n\\n        for (uint256 i = 0; i < actions.length; i++) {\\n            BalanceAction calldata action = actions[i];\\n            // msg.value will only be used when currency id == 1, referencing ETH. The requirement\\n            // to sort actions by increasing id enforces that msg.value will only be used once.\\n            if (i > 0) {\\n                require(action.currencyId > actions[i - 1].currencyId, \\\"Unsorted actions\\\");\\n            }\\n            // Loads the currencyId into balance state\\n            balanceState.loadBalanceState(account, action.currencyId, accountContext);\\n\\n            _executeDepositAction(\\n                account,\\n                balanceState,\\n                action.actionType,\\n                action.depositActionAmount\\n            );\\n\\n            _calculateWithdrawActionAndFinalize(\\n                account,\\n                accountContext,\\n                balanceState,\\n                action.withdrawAmountInternalPrecision,\\n                action.withdrawEntireCashBalance,\\n                action.redeemToUnderlying\\n            );\\n        }\\n\\n        _finalizeAccountContext(account, accountContext);\\n    }\\n\\n    /// @notice Executes a batch of balance transfers and trading actions\\n    /// @param account the account for the action\\n    /// @param actions array of balance actions with trades to take, must be sorted by currency id\\n    /// @dev emit:CashBalanceChange, emit:nTokenSupplyChange, emit:LendBorrowTrade, emit:AddRemoveLiquidity,\\n    /// @dev emit:SettledCashDebt, emit:nTokenResidualPurchase, emit:ReserveFeeAccrued\\n    /// @dev auth:msg.sender auth:ERC1155\\n    function batchBalanceAndTradeAction(address account, BalanceActionWithTrades[] calldata actions)\\n        external\\n        payable\\n        nonReentrant\\n    {\\n        require(account == msg.sender || msg.sender == address(this), \\\"Unauthorized\\\");\\n        requireValidAccount(account);\\n        AccountContext memory accountContext = _batchBalanceAndTradeAction(account, actions);\\n        _finalizeAccountContext(account, accountContext);\\n    }\\n\\n    /// @notice Executes a batch of lending actions. This is different from batchBalanceAndTrade because\\n    /// it always pulls the required amount of tokens to get an account to a cash balance of zero. It reduces\\n    /// the gas costs for lending because there is no second token transfer where residual balances are sent\\n    /// back to the account.\\n    /// @dev Note that this method does not work with native ETH because it requires the ability to pull payment\\n    /// from an ERC20 token. Therefore, this method is marked as nonpayable. It will still work with cETH or aETH.\\n    /// @param account the account for the action\\n    /// @param actions array of batch lending actions\\n    /// @dev emit:CashBalanceChange, emit:LendBorrowTrade emit:SettledCashDebt\\n    /// @dev auth:msg.sender auth:ERC1155\\n    function batchLend(address account, BatchLend[] calldata actions)\\n        external\\n        nonReentrant\\n    {\\n        require(account == msg.sender || msg.sender == address(this), \\\"Unauthorized\\\");\\n        requireValidAccount(account);\\n\\n        AccountContext memory accountContext = _settleAccountIfRequired(account);\\n        // NOTE: loading the portfolio state must happen after settle account to get the\\n        // correct portfolio, it will have changed if the account is settled.\\n        PortfolioState memory portfolioState = PortfolioHandler.buildPortfolioState(\\n            account,\\n            accountContext.assetArrayLength,\\n            0\\n        );\\n        BalanceState memory balanceState;\\n\\n        for (uint256 i = 0; i < actions.length; i++) {\\n            BatchLend calldata action = actions[i];\\n            // msg.value will never be used in this method because it is non-payable\\n            if (i > 0) {\\n                require(action.currencyId > actions[i - 1].currencyId, \\\"Unsorted actions\\\");\\n            }\\n\\n            // Require that each action have at least 1 trade and all trades are lending trades\\n            uint256 numTrades = action.trades.length;\\n            require(numTrades > 0); // dev: no actions\\n            for (uint256 j = 0; j < numTrades; j++) {\\n                require(uint8(bytes1(action.trades[j])) == uint8(TradeActionType.Lend)); // dev: only lend trades\\n            }\\n\\n            // Loads the currencyId into balance state\\n            balanceState.loadBalanceState(account, action.currencyId, accountContext);\\n            (balanceState.netCashChange, portfolioState) = _executeTrades(\\n                account,\\n                action.currencyId,\\n                action.trades,\\n                accountContext,\\n                portfolioState\\n            );\\n            // This must be negative as a result of requiring only lending\\n            require(balanceState.netCashChange <= 0);\\n\\n            // Deposit sufficient cash to get the balance up to zero. If required cash is negative (i.e. there\\n            // is sufficient cash) then we don't need to do anything. The account's cash balance will be net off\\n            // and there will be no token transfer.\\n            // NOTE: it is possible that free collateral decreases as a result of lending a cash balance, will\\n            // check FC at the end of the method.\\n            int256 requiredCash = balanceState.storedCashBalance.add(balanceState.netCashChange).neg();\\n            if (requiredCash > 0) {\\n                if (action.depositUnderlying) {\\n                    // If depositing underlying, get the current asset rate and convert the required cash\\n                    // back to underlying.\\n                    AssetRateParameters memory ar = AssetRate.buildAssetRateStateful(action.currencyId);\\n                    Token memory underlyingToken = TokenHandler.getUnderlyingToken(action.currencyId);\\n                    int256 underlyingInternalAmount = ar.convertToUnderlying(requiredCash);\\n                    int256 underlyingExternalAmount = underlyingToken.convertToUnderlyingExternalWithAdjustment(\\n                        underlyingInternalAmount\\n                    );\\n\\n                    // This returns the cToken / aToken amount as a result of transfer and mint. It must be sufficient to\\n                    // cover the required cash.\\n                    int256 assetAmountInternal = balanceState.depositUnderlyingToken(account, underlyingExternalAmount);\\n                    require(assetAmountInternal >= requiredCash, \\\"Insufficient deposit\\\");\\n                } else {\\n                    // balanceState.finalize will handle conversions to external precision as well as aToken\\n                    // scaled balance conversions.\\n                    balanceState.netAssetTransferInternalPrecision = balanceState\\n                        .netAssetTransferInternalPrecision\\n                        .add(requiredCash);\\n                }\\n            }\\n\\n            // Will write all the balance changes to storage and transfer asset tokens if required.\\n            balanceState.finalize(account, accountContext, false);\\n        }\\n\\n        // Update the portfolio state if bitmap is not enabled. If bitmap is already enabled\\n        // then all the assets have already been updated in in storage.\\n        if (!accountContext.isBitmapEnabled()) {\\n            // NOTE: account context is updated in memory inside this method call.\\n            accountContext.storeAssetsAndUpdateContext(account, portfolioState, false);\\n        }\\n\\n        // This will save the account context and check free collateral\\n        _finalizeAccountContext(account, accountContext);\\n    }\\n\\n    /// @notice Executes a batch of balance transfers and trading actions via an authorized callback contract. This\\n    /// can be used as a \\\"flash loan\\\" facility for special contracts that migrate assets between protocols or perform\\n    /// other actions on behalf of the user.\\n    /// Contracts can borrow from Notional and receive a callback prior to an FC check, this can be useful if the contract\\n    /// needs to perform a trade or repay a debt on a different protocol before depositing collateral. Since Notional's AMM\\n    /// will never be as capital efficient or gas efficient as other flash loan facilities, this method requires whitelisting\\n    /// and will mainly be used for contracts that make migrating assets a better user experience.\\n    /// @param account the account that will take all the actions\\n    /// @param actions array of balance actions with trades to take, must be sorted by currency id\\n    /// @param callbackData arbitrary bytes to be passed backed to the caller in the callback\\n    /// @dev emit:CashBalanceChange, emit:nTokenSupplyChange, emit:LendBorrowTrade, emit:AddRemoveLiquidity,\\n    /// @dev emit:SettledCashDebt, emit:nTokenResidualPurchase, emit:ReserveFeeAccrued\\n    /// @dev auth:authorizedCallbackContract\\n    function batchBalanceAndTradeActionWithCallback(\\n        address account,\\n        BalanceActionWithTrades[] calldata actions,\\n        bytes calldata callbackData\\n    ) external payable {\\n        // NOTE: Re-entrancy is allowed for authorized callback functions.\\n        require(authorizedCallbackContract[msg.sender], \\\"Unauthorized\\\");\\n        requireValidAccount(account);\\n\\n        AccountContext memory accountContext = _batchBalanceAndTradeAction(account, actions);\\n        accountContext.setAccountContext(account);\\n\\n        // Be sure to set the account context before initiating the callback, all stateful updates\\n        // have been finalized at this point so we are safe to issue a callback. This callback may\\n        // re-enter Notional safely to deposit or take other actions.\\n        NotionalCallback(msg.sender).notionalCallback(msg.sender, account, callbackData);\\n\\n        if (accountContext.hasDebt != 0x00) {\\n            // NOTE: this method may update the account context to turn off the hasDebt flag, this\\n            // is ok because the worst case would be causing an extra free collateral check when it\\n            // is not required. This check will be entered if the account hasDebt prior to the callback\\n            // being triggered above, so it will happen regardless of what the callback function does.\\n            FreeCollateralExternal.checkFreeCollateralAndRevert(account);\\n        }\\n    }\\n\\n    function _batchBalanceAndTradeAction(\\n        address account,\\n        BalanceActionWithTrades[] calldata actions\\n    ) internal returns (AccountContext memory) {\\n        AccountContext memory accountContext = _settleAccountIfRequired(account);\\n        BalanceState memory balanceState;\\n        // NOTE: loading the portfolio state must happen after settle account to get the\\n        // correct portfolio, it will have changed if the account is settled.\\n        PortfolioState memory portfolioState = PortfolioHandler.buildPortfolioState(\\n            account,\\n            accountContext.assetArrayLength,\\n            0\\n        );\\n\\n        for (uint256 i = 0; i < actions.length; i++) {\\n            BalanceActionWithTrades calldata action = actions[i];\\n            // msg.value will only be used when currency id == 1, referencing ETH. The requirement\\n            // to sort actions by increasing id enforces that msg.value will only be used once.\\n            if (i > 0) {\\n                require(action.currencyId > actions[i - 1].currencyId, \\\"Unsorted actions\\\");\\n            }\\n            // Loads the currencyId into balance state\\n            balanceState.loadBalanceState(account, action.currencyId, accountContext);\\n\\n            // Does not revert on invalid action types here, they also have no effect.\\n            _executeDepositAction(\\n                account,\\n                balanceState,\\n                action.actionType,\\n                action.depositActionAmount\\n            );\\n\\n            if (action.trades.length > 0) {\\n                int256 netCash;\\n                (netCash, portfolioState) = _executeTrades(\\n                    account,\\n                    action.currencyId,\\n                    action.trades,\\n                    accountContext,\\n                    portfolioState\\n                );\\n\\n                // If the account owes cash after trading, ensure that it has enough\\n                if (netCash < 0) _checkSufficientCash(balanceState, netCash.neg());\\n                balanceState.netCashChange = balanceState.netCashChange.add(netCash);\\n            }\\n\\n            _calculateWithdrawActionAndFinalize(\\n                account,\\n                accountContext,\\n                balanceState,\\n                action.withdrawAmountInternalPrecision,\\n                action.withdrawEntireCashBalance,\\n                action.redeemToUnderlying\\n            );\\n        }\\n\\n        // Update the portfolio state if bitmap is not enabled. If bitmap is already enabled\\n        // then all the assets have already been updated in in storage.\\n        if (!accountContext.isBitmapEnabled()) {\\n            // NOTE: account context is updated in memory inside this method call.\\n            accountContext.storeAssetsAndUpdateContext(account, portfolioState, false);\\n        }\\n\\n        // NOTE: free collateral and account context will be set outside of this method call.\\n        return accountContext;\\n    }\\n\\n    /// @dev Executes deposits\\n    function _executeDepositAction(\\n        address account,\\n        BalanceState memory balanceState,\\n        DepositActionType depositType,\\n        uint256 depositActionAmount_\\n    ) private {\\n        int256 depositActionAmount = SafeInt256.toInt(depositActionAmount_);\\n        int256 assetInternalAmount;\\n        require(depositActionAmount >= 0);\\n\\n        if (depositType == DepositActionType.None) {\\n            return;\\n        } else if (\\n            depositType == DepositActionType.DepositAsset ||\\n            depositType == DepositActionType.DepositAssetAndMintNToken\\n        ) {\\n            // NOTE: this deposit will NOT revert on a failed transfer unless there is a\\n            // transfer fee. The actual transfer will take effect later in balanceState.finalize\\n            assetInternalAmount = balanceState.depositAssetToken(\\n                account,\\n                depositActionAmount,\\n                false // no force transfer\\n            );\\n        } else if (\\n            depositType == DepositActionType.DepositUnderlying ||\\n            depositType == DepositActionType.DepositUnderlyingAndMintNToken\\n        ) {\\n            // NOTE: this deposit will revert on a failed transfer immediately\\n            assetInternalAmount = balanceState.depositUnderlyingToken(account, depositActionAmount);\\n        } else if (depositType == DepositActionType.ConvertCashToNToken) {\\n            // _executeNTokenAction will check if the account has sufficient cash\\n            assetInternalAmount = depositActionAmount;\\n        }\\n\\n        _executeNTokenAction(\\n            balanceState,\\n            depositType,\\n            depositActionAmount,\\n            assetInternalAmount\\n        );\\n    }\\n\\n    /// @dev Executes nToken actions\\n    function _executeNTokenAction(\\n        BalanceState memory balanceState,\\n        DepositActionType depositType,\\n        int256 depositActionAmount,\\n        int256 assetInternalAmount\\n    ) private {\\n        // After deposits have occurred, check if we are minting nTokens\\n        if (\\n            depositType == DepositActionType.DepositAssetAndMintNToken ||\\n            depositType == DepositActionType.DepositUnderlyingAndMintNToken ||\\n            depositType == DepositActionType.ConvertCashToNToken\\n        ) {\\n            // Will revert if trying to mint ntokens and results in a negative cash balance\\n            _checkSufficientCash(balanceState, assetInternalAmount);\\n            balanceState.netCashChange = balanceState.netCashChange.sub(assetInternalAmount);\\n            revert(\\\"Disabled\\\");\\n\\n            // Converts a given amount of cash (denominated in internal precision) into nTokens\\n            int256 tokensMinted = nTokenMintAction.nTokenMint(\\n                balanceState.currencyId,\\n                assetInternalAmount\\n            );\\n\\n            balanceState.netNTokenSupplyChange = balanceState.netNTokenSupplyChange.add(\\n                tokensMinted\\n            );\\n        } else if (depositType == DepositActionType.RedeemNToken) {\\n            require(\\n                // prettier-ignore\\n                balanceState\\n                    .storedNTokenBalance\\n                    .add(balanceState.netNTokenTransfer) // transfers would not occur at this point\\n                    .add(balanceState.netNTokenSupplyChange) >= depositActionAmount,\\n                \\\"Insufficient token balance\\\"\\n            );\\n\\n            balanceState.netNTokenSupplyChange = balanceState.netNTokenSupplyChange.sub(\\n                depositActionAmount\\n            );\\n\\n            int256 assetCash = nTokenRedeemAction.nTokenRedeemViaBatch(\\n                balanceState.currencyId,\\n                depositActionAmount\\n            );\\n\\n            balanceState.netCashChange = balanceState.netCashChange.add(assetCash);\\n        }\\n    }\\n\\n    /// @dev Calculations any withdraws and finalizes balances\\n    function _calculateWithdrawActionAndFinalize(\\n        address account,\\n        AccountContext memory accountContext,\\n        BalanceState memory balanceState,\\n        uint256 withdrawAmountInternalPrecision,\\n        bool withdrawEntireCashBalance,\\n        bool redeemToUnderlying\\n    ) private {\\n        int256 withdrawAmount = SafeInt256.toInt(withdrawAmountInternalPrecision);\\n        require(withdrawAmount >= 0); // dev: withdraw action overflow\\n\\n        // NOTE: if withdrawEntireCashBalance is set it will override the withdrawAmountInternalPrecision input\\n        if (withdrawEntireCashBalance) {\\n            // This option is here so that accounts do not end up with dust after lending since we generally\\n            // cannot calculate exact cash amounts from the liquidity curve.\\n            withdrawAmount = balanceState.storedCashBalance\\n                .add(balanceState.netCashChange)\\n                .add(balanceState.netAssetTransferInternalPrecision);\\n\\n            // If the account has a negative cash balance then cannot withdraw\\n            if (withdrawAmount < 0) withdrawAmount = 0;\\n        }\\n\\n        // prettier-ignore\\n        balanceState.netAssetTransferInternalPrecision = balanceState\\n            .netAssetTransferInternalPrecision\\n            .sub(withdrawAmount);\\n\\n        balanceState.finalize(account, accountContext, redeemToUnderlying);\\n    }\\n\\n    function _finalizeAccountContext(address account, AccountContext memory accountContext)\\n        private\\n    {\\n        // At this point all balances, market states and portfolio states should be finalized. Just need to check free\\n        // collateral if required.\\n        accountContext.setAccountContext(account);\\n        if (accountContext.hasDebt != 0x00) {\\n            FreeCollateralExternal.checkFreeCollateralAndRevert(account);\\n        }\\n    }\\n\\n    function _executeTrades(\\n        address account,\\n        uint16 currencyId,\\n        bytes32[] calldata trades,\\n        AccountContext memory accountContext,\\n        PortfolioState memory portfolioState\\n    ) private returns (int256 netCash, PortfolioState memory postTradeState) {\\n        if (accountContext.isBitmapEnabled()) {\\n            require(\\n                accountContext.bitmapCurrencyId == currencyId,\\n                \\\"Invalid trades for account\\\"\\n            );\\n            bool didIncurDebt;\\n            (netCash, didIncurDebt) = TradingAction.executeTradesBitmapBatch(\\n                account,\\n                accountContext.bitmapCurrencyId,\\n                accountContext.nextSettleTime,\\n                trades\\n            );\\n            if (didIncurDebt) {\\n                accountContext.hasDebt = Constants.HAS_ASSET_DEBT | accountContext.hasDebt;\\n            }\\n        } else {\\n            // NOTE: we return portfolio state here instead of setting it inside executeTradesArrayBatch\\n            // because we want to only write to storage once after all trades are completed\\n            (postTradeState, netCash) = TradingAction.executeTradesArrayBatch(\\n                account,\\n                currencyId,\\n                portfolioState,\\n                trades\\n            );\\n        }\\n    }\\n\\n    /// @notice When lending, adding liquidity or minting nTokens the account must have a sufficient cash balance\\n    /// to do so.\\n    function _checkSufficientCash(BalanceState memory balanceState, int256 amountInternalPrecision)\\n        private\\n        pure\\n    {\\n        // The total cash position at this point is: storedCashBalance + netCashChange + netAssetTransferInternalPrecision\\n        require(\\n            amountInternalPrecision >= 0 &&\\n                balanceState.storedCashBalance\\n                .add(balanceState.netCashChange)\\n                .add(balanceState.netAssetTransferInternalPrecision) >= amountInternalPrecision,\\n            \\\"Insufficient cash\\\"\\n        );\\n    }\\n\\n    function _settleAccountIfRequired(address account)\\n        private\\n        returns (AccountContext memory)\\n    {\\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\\n        if (accountContext.mustSettleAssets()) {\\n            // Returns a new memory reference to account context\\n            return SettleAssetsExternal.settleAccount(account, accountContext);\\n        } else {\\n            return accountContext;\\n        }\\n    }\\n\\n    /// @notice Get a list of deployed library addresses (sorted by library name)\\n    function getLibInfo() external pure returns (address, address, address, address, address, address) {\\n        return (\\n            address(FreeCollateralExternal), \\n            address(MigrateIncentives), \\n            address(SettleAssetsExternal), \\n            address(TradingAction),\\n            address(nTokenMintAction), \\n            address(nTokenRedeemAction)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/actions/nTokenMintAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../../global/Constants.sol\\\";\\nimport \\\"../../internal/nToken/nTokenHandler.sol\\\";\\nimport \\\"../../internal/nToken/nTokenCalculations.sol\\\";\\nimport \\\"../../internal/markets/Market.sol\\\";\\nimport \\\"../../internal/markets/CashGroup.sol\\\";\\nimport \\\"../../internal/markets/AssetRate.sol\\\";\\nimport \\\"../../internal/balances/BalanceHandler.sol\\\";\\nimport \\\"../../internal/portfolio/PortfolioHandler.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary nTokenMintAction {\\n    using SafeInt256 for int256;\\n    using BalanceHandler for BalanceState;\\n    using CashGroup for CashGroupParameters;\\n    using Market for MarketParameters;\\n    using nTokenHandler for nTokenPortfolio;\\n    using PortfolioHandler for PortfolioState;\\n    using AssetRate for AssetRateParameters;\\n    using SafeMath for uint256;\\n    using nTokenHandler for nTokenPortfolio;\\n\\n    /// @notice Converts the given amount of cash to nTokens in the same currency.\\n    /// @param currencyId the currency associated the nToken\\n    /// @param amountToDepositInternal the amount of asset tokens to deposit denominated in internal decimals\\n    /// @return nTokens minted by this action\\n    function nTokenMint(uint16 currencyId, int256 amountToDepositInternal)\\n        external\\n        returns (int256)\\n    {\\n        uint256 blockTime = block.timestamp;\\n        nTokenPortfolio memory nToken;\\n        nToken.loadNTokenPortfolioStateful(currencyId);\\n\\n        int256 tokensToMint = nTokenCalculations.calculateTokensToMint(nToken, amountToDepositInternal, blockTime);\\n        require(tokensToMint >= 0, \\\"Invalid token amount\\\");\\n\\n        if (nToken.portfolioState.storedAssets.length == 0) {\\n            // If the token does not have any assets, then the markets must be initialized first.\\n            nToken.cashBalance = nToken.cashBalance.add(amountToDepositInternal);\\n            BalanceHandler.setBalanceStorageForNToken(\\n                nToken.tokenAddress,\\n                currencyId,\\n                nToken.cashBalance\\n            );\\n        } else {\\n            _depositIntoPortfolio(nToken, amountToDepositInternal, blockTime);\\n        }\\n\\n        // NOTE: token supply does not change here, it will change after incentives have been claimed\\n        // during BalanceHandler.finalize\\n        return tokensToMint;\\n    }\\n\\n\\n    /// @notice Portions out assetCashDeposit into amounts to deposit into individual markets. When\\n    /// entering this method we know that assetCashDeposit is positive and the nToken has been\\n    /// initialized to have liquidity tokens.\\n    function _depositIntoPortfolio(\\n        nTokenPortfolio memory nToken,\\n        int256 assetCashDeposit,\\n        uint256 blockTime\\n    ) private {\\n        (int256[] memory depositShares, int256[] memory leverageThresholds) =\\n            nTokenHandler.getDepositParameters(\\n                nToken.cashGroup.currencyId,\\n                nToken.cashGroup.maxMarketIndex\\n            );\\n\\n        // Loop backwards from the last market to the first market, the reasoning is a little complicated:\\n        // If we have to deleverage the markets (i.e. lend instead of provide liquidity) it's quite gas inefficient\\n        // to calculate the cash amount to lend. We do know that longer term maturities will have more\\n        // slippage and therefore the residual from the perMarketDeposit will be lower as the maturities get\\n        // closer to the current block time. Any residual cash from lending will be rolled into shorter\\n        // markets as this loop progresses.\\n        int256 residualCash;\\n        MarketParameters memory market;\\n        for (uint256 marketIndex = nToken.cashGroup.maxMarketIndex; marketIndex > 0; marketIndex--) {\\n            int256 fCashAmount;\\n            // Loads values into the market memory slot\\n            nToken.cashGroup.loadMarket(\\n                market,\\n                marketIndex,\\n                true, // Needs liquidity to true\\n                blockTime\\n            );\\n            // If market has not been initialized, continue. This can occur when cash groups extend maxMarketIndex\\n            // before initializing\\n            if (market.totalLiquidity == 0) continue;\\n\\n            // Checked that assetCashDeposit must be positive before entering\\n            int256 perMarketDeposit =\\n                assetCashDeposit\\n                    .mul(depositShares[marketIndex - 1])\\n                    .div(Constants.DEPOSIT_PERCENT_BASIS)\\n                    .add(residualCash);\\n\\n            (fCashAmount, residualCash) = _lendOrAddLiquidity(\\n                nToken,\\n                market,\\n                perMarketDeposit,\\n                leverageThresholds[marketIndex - 1],\\n                marketIndex,\\n                blockTime\\n            );\\n\\n            if (fCashAmount != 0) {\\n                BitmapAssetsHandler.addifCashAsset(\\n                    nToken.tokenAddress,\\n                    nToken.cashGroup.currencyId,\\n                    market.maturity,\\n                    nToken.lastInitializedTime,\\n                    fCashAmount\\n                );\\n            }\\n        }\\n\\n        // nToken is allowed to store assets directly without updating account context.\\n        nToken.portfolioState.storeAssets(nToken.tokenAddress);\\n\\n        // Defensive check to ensure that we do not somehow accrue negative residual cash.\\n        require(residualCash >= 0, \\\"Negative residual cash\\\");\\n        // This will occur if the three month market is over levered and we cannot lend into it\\n        if (residualCash > 0) {\\n            // Any remaining residual cash will be put into the nToken balance and added as liquidity on the\\n            // next market initialization\\n            nToken.cashBalance = nToken.cashBalance.add(residualCash);\\n            BalanceHandler.setBalanceStorageForNToken(\\n                nToken.tokenAddress,\\n                nToken.cashGroup.currencyId,\\n                nToken.cashBalance\\n            );\\n        }\\n    }\\n\\n    /// @notice For a given amount of cash to deposit, decides how much to lend or provide\\n    /// given the market conditions.\\n    function _lendOrAddLiquidity(\\n        nTokenPortfolio memory nToken,\\n        MarketParameters memory market,\\n        int256 perMarketDeposit,\\n        int256 leverageThreshold,\\n        uint256 marketIndex,\\n        uint256 blockTime\\n    ) private returns (int256 fCashAmount, int256 residualCash) {\\n        // We start off with the entire per market deposit as residuals\\n        residualCash = perMarketDeposit;\\n\\n        // If the market is over leveraged then we will lend to it instead of providing liquidity\\n        if (_isMarketOverLeveraged(nToken.cashGroup, market, leverageThreshold)) {\\n            (residualCash, fCashAmount) = _deleverageMarket(\\n                nToken.cashGroup,\\n                market,\\n                perMarketDeposit,\\n                blockTime,\\n                marketIndex\\n            );\\n\\n            // Recalculate this after lending into the market, if it is still over leveraged then\\n            // we will not add liquidity and just exit.\\n            if (_isMarketOverLeveraged(nToken.cashGroup, market, leverageThreshold)) {\\n                // Returns the residual cash amount\\n                return (fCashAmount, residualCash);\\n            }\\n        }\\n\\n        // Add liquidity to the market only if we have successfully delevered.\\n        // (marketIndex - 1) is the index of the nToken portfolio array where the asset is stored\\n        // If deleveraged, residualCash is what remains\\n        // If not deleveraged, residual cash is per market deposit\\n        fCashAmount = fCashAmount.add(\\n            _addLiquidityToMarket(nToken, market, marketIndex - 1, residualCash)\\n        );\\n        // No residual cash if we're adding liquidity\\n        return (fCashAmount, 0);\\n    }\\n\\n    /// @notice Markets are over levered when their proportion is greater than a governance set\\n    /// threshold. At this point, providing liquidity will incur too much negative fCash on the nToken\\n    /// account for the given amount of cash deposited, putting the nToken account at risk of liquidation.\\n    /// If the market is over leveraged, we call `deleverageMarket` to lend to the market instead.\\n    function _isMarketOverLeveraged(\\n        CashGroupParameters memory cashGroup,\\n        MarketParameters memory market,\\n        int256 leverageThreshold\\n    ) private pure returns (bool) {\\n        int256 totalCashUnderlying = cashGroup.assetRate.convertToUnderlying(market.totalAssetCash);\\n        // Comparison we want to do:\\n        // (totalfCash) / (totalfCash + totalCashUnderlying) > leverageThreshold\\n        // However, the division will introduce rounding errors so we change this to:\\n        // totalfCash * RATE_PRECISION > leverageThreshold * (totalfCash + totalCashUnderlying)\\n        // Leverage threshold is denominated in rate precision.\\n        return (\\n            market.totalfCash.mul(Constants.RATE_PRECISION) >\\n            leverageThreshold.mul(market.totalfCash.add(totalCashUnderlying))\\n        );\\n    }\\n\\n    function _addLiquidityToMarket(\\n        nTokenPortfolio memory nToken,\\n        MarketParameters memory market,\\n        uint256 index,\\n        int256 perMarketDeposit\\n    ) private returns (int256) {\\n        // Add liquidity to the market\\n        PortfolioAsset memory asset = nToken.portfolioState.storedAssets[index];\\n        // We expect that all the liquidity tokens are in the portfolio in order.\\n        require(\\n            asset.maturity == market.maturity &&\\n            // Ensures that the asset type references the proper liquidity token\\n            asset.assetType == index + Constants.MIN_LIQUIDITY_TOKEN_INDEX &&\\n            // Ensures that the storage state will not be overwritten\\n            asset.storageState == AssetStorageState.NoChange,\\n            \\\"PT: invalid liquidity token\\\"\\n        );\\n\\n        // This will update the market state as well, fCashAmount returned here is negative\\n        (int256 liquidityTokens, int256 fCashAmount) = market.addLiquidity(perMarketDeposit);\\n        asset.notional = asset.notional.add(liquidityTokens);\\n        asset.storageState = AssetStorageState.Update;\\n\\n        return fCashAmount;\\n    }\\n\\n    /// @notice Lends into the market to reduce the leverage that the nToken will add liquidity at. May fail due\\n    /// to slippage or result in some amount of residual cash.\\n    function _deleverageMarket(\\n        CashGroupParameters memory cashGroup,\\n        MarketParameters memory market,\\n        int256 perMarketDeposit,\\n        uint256 blockTime,\\n        uint256 marketIndex\\n    ) private returns (int256, int256) {\\n        uint256 timeToMaturity = market.maturity.sub(blockTime);\\n\\n        // Shift the last implied rate by some buffer and calculate the exchange rate to fCash. Hope that this\\n        // is sufficient to cover all potential slippage. We don't use the `getfCashGivenCashAmount` method here\\n        // because it is very gas inefficient.\\n        int256 assumedExchangeRate;\\n        if (market.lastImpliedRate < Constants.DELEVERAGE_BUFFER) {\\n            // Floor the exchange rate at zero interest rate\\n            assumedExchangeRate = Constants.RATE_PRECISION;\\n        } else {\\n            assumedExchangeRate = Market.getExchangeRateFromImpliedRate(\\n                market.lastImpliedRate.sub(Constants.DELEVERAGE_BUFFER),\\n                timeToMaturity\\n            );\\n        }\\n\\n        int256 fCashAmount;\\n        {\\n            int256 perMarketDepositUnderlying =\\n                cashGroup.assetRate.convertToUnderlying(perMarketDeposit);\\n            // NOTE: cash * exchangeRate = fCash\\n            fCashAmount = perMarketDepositUnderlying.mulInRatePrecision(assumedExchangeRate);\\n        }\\n        int256 netAssetCash = market.executeTrade(cashGroup, fCashAmount, timeToMaturity, marketIndex);\\n\\n        // This means that the trade failed\\n        if (netAssetCash == 0) {\\n            return (perMarketDeposit, 0);\\n        } else {\\n            // Ensure that net the per market deposit figure does not drop below zero, this should not be possible\\n            // given how we've calculated the exchange rate but extra caution here\\n            int256 residual = perMarketDeposit.add(netAssetCash);\\n            require(residual >= 0); // dev: insufficient cash\\n            return (residual, fCashAmount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/actions/nTokenRedeemAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../../internal/markets/Market.sol\\\";\\nimport \\\"../../internal/nToken/nTokenHandler.sol\\\";\\nimport \\\"../../internal/nToken/nTokenCalculations.sol\\\";\\nimport \\\"../../internal/portfolio/PortfolioHandler.sol\\\";\\nimport \\\"../../internal/portfolio/TransferAssets.sol\\\";\\nimport \\\"../../internal/balances/BalanceHandler.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"../../math/Bitmap.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary nTokenRedeemAction {\\n    using SafeInt256 for int256;\\n    using SafeMath for uint256;\\n    using Bitmap for bytes32;\\n    using BalanceHandler for BalanceState;\\n    using Market for MarketParameters;\\n    using CashGroup for CashGroupParameters;\\n    using PortfolioHandler for PortfolioState;\\n    using nTokenHandler for nTokenPortfolio;\\n\\n    /// @notice When redeeming nTokens via the batch they must all be sold to cash and this\\n    /// method will return the amount of asset cash sold.\\n    /// @param currencyId the currency associated the nToken\\n    /// @param tokensToRedeem the amount of nTokens to convert to cash\\n    /// @return amount of asset cash to return to the account, denominated in internal token decimals\\n    function nTokenRedeemViaBatch(uint16 currencyId, int256 tokensToRedeem)\\n        external\\n        returns (int256)\\n    {\\n        uint256 blockTime = block.timestamp;\\n        // prettier-ignore\\n        (\\n            int256 totalAssetCash,\\n            bool hasResidual,\\n            /* PortfolioAssets[] memory newfCashAssets */\\n        ) = _redeem(currencyId, tokensToRedeem, true, false, blockTime);\\n\\n        require(!hasResidual, \\\"Cannot redeem via batch, residual\\\");\\n        return totalAssetCash;\\n    }\\n\\n    /// @notice Redeems nTokens for asset cash and fCash\\n    /// @param currencyId the currency associated the nToken\\n    /// @param tokensToRedeem the amount of nTokens to convert to cash\\n    /// @param sellTokenAssets attempt to sell residual fCash and convert to cash, if unsuccessful then place\\n    /// back into the account's portfolio\\n    /// @param acceptResidualAssets if true, then ifCash residuals will be placed into the account and there will\\n    /// be no penalty assessed\\n    /// @return assetCash positive amount of asset cash to the account\\n    /// @return hasResidual true if there are fCash residuals left\\n    /// @return assets an array of fCash asset residuals to place into the account\\n    function redeem(\\n        uint16 currencyId,\\n        int256 tokensToRedeem,\\n        bool sellTokenAssets,\\n        bool acceptResidualAssets\\n    ) external returns (int256, bool, PortfolioAsset[] memory) {\\n        return _redeem(\\n            currencyId,\\n            tokensToRedeem,\\n            sellTokenAssets,\\n            acceptResidualAssets,\\n            block.timestamp\\n        );\\n    }\\n\\n    function _redeem(\\n        uint16 currencyId,\\n        int256 tokensToRedeem,\\n        bool sellTokenAssets,\\n        bool acceptResidualAssets,\\n        uint256 blockTime\\n    ) internal returns (int256, bool, PortfolioAsset[] memory) {\\n        require(tokensToRedeem > 0);\\n        nTokenPortfolio memory nToken;\\n        nToken.loadNTokenPortfolioStateful(currencyId);\\n        // nTokens cannot be redeemed during the period of time where they require settlement.\\n        require(nToken.getNextSettleTime() > blockTime, \\\"Requires settlement\\\");\\n        require(tokensToRedeem < nToken.totalSupply, \\\"Cannot redeem\\\");\\n        PortfolioAsset[] memory newifCashAssets;\\n\\n        // Get the ifCash bits that are idiosyncratic\\n        bytes32 ifCashBits = nTokenCalculations.getNTokenifCashBits(\\n            nToken.tokenAddress,\\n            currencyId,\\n            nToken.lastInitializedTime,\\n            blockTime,\\n            nToken.cashGroup.maxMarketIndex\\n        );\\n\\n        if (ifCashBits != 0 && acceptResidualAssets) {\\n            // This will remove all the ifCash assets proportionally from the account\\n            newifCashAssets = _reduceifCashAssetsProportional(\\n                nToken.tokenAddress,\\n                currencyId,\\n                nToken.lastInitializedTime,\\n                tokensToRedeem,\\n                nToken.totalSupply,\\n                ifCashBits\\n            );\\n\\n            // Once the ifCash bits have been withdrawn, set this to zero so that getLiquidityTokenWithdraw\\n            // simply gets the proportional amount of liquidity tokens to remove\\n            ifCashBits = 0;\\n        }\\n\\n        // Returns the liquidity tokens to withdraw per market and the netfCash amounts. Net fCash amounts are only\\n        // set when ifCashBits != 0. Otherwise they must be calculated in _withdrawLiquidityTokens\\n        (int256[] memory tokensToWithdraw, int256[] memory netfCash) = nTokenCalculations.getLiquidityTokenWithdraw(\\n            nToken,\\n            tokensToRedeem,\\n            blockTime,\\n            ifCashBits\\n        );\\n\\n        // Returns the totalAssetCash as a result of withdrawing liquidity tokens and cash. netfCash will be updated\\n        // in memory if required and will contain the fCash to be sold or returned to the portfolio\\n        int256 totalAssetCash = _reduceLiquidAssets(\\n           nToken,\\n           tokensToRedeem,\\n           tokensToWithdraw,\\n           netfCash,\\n           ifCashBits == 0, // If there are no residuals then we need to populate netfCash amounts\\n           blockTime\\n        );\\n\\n        bool netfCashRemaining = true;\\n        if (sellTokenAssets) {\\n            int256 assetCash;\\n            // NOTE: netfCash is modified in place and set to zero if the fCash is sold\\n            (assetCash, netfCashRemaining) = _sellfCashAssets(nToken, netfCash, blockTime);\\n            totalAssetCash = totalAssetCash.add(assetCash);\\n        }\\n\\n        if (netfCashRemaining) {\\n            // If the account is unwilling to accept residuals then will fail here.\\n            newifCashAssets = _addResidualsToAssets(nToken.portfolioState.storedAssets, newifCashAssets, netfCash);\\n            require(acceptResidualAssets || newifCashAssets.length == 0, \\\"Residuals\\\");\\n        }\\n\\n        return (totalAssetCash, netfCashRemaining, newifCashAssets);\\n    }\\n\\n    /// @notice Removes liquidity tokens and cash from the nToken\\n    /// @param nToken portfolio object\\n    /// @param nTokensToRedeem tokens to redeem\\n    /// @param tokensToWithdraw array of liquidity tokens to withdraw\\n    /// @param netfCash array of netfCash figures\\n    /// @param mustCalculatefCash true if netfCash must be calculated in the removeLiquidityTokens step\\n    /// @param blockTime current block time\\n    /// @return assetCashShare amount of cash the redeemer will receive from withdrawing cash assets from the nToken\\n    function _reduceLiquidAssets(\\n        nTokenPortfolio memory nToken,\\n        int256 nTokensToRedeem,\\n        int256[] memory tokensToWithdraw,\\n        int256[] memory netfCash,\\n        bool mustCalculatefCash,\\n        uint256 blockTime\\n    ) private returns (int256 assetCashShare) {\\n        // Get asset cash share for the nToken, if it exists. It is required in balance handler that the\\n        // nToken can never have a negative cash asset cash balance so what we get here is always positive\\n        // or zero.\\n        assetCashShare = nToken.cashBalance.mul(nTokensToRedeem).div(nToken.totalSupply);\\n        if (assetCashShare > 0) {\\n            nToken.cashBalance = nToken.cashBalance.subNoNeg(assetCashShare);\\n            BalanceHandler.setBalanceStorageForNToken(\\n                nToken.tokenAddress,\\n                nToken.cashGroup.currencyId,\\n                nToken.cashBalance\\n            );\\n        }\\n\\n        // Get share of liquidity tokens to remove, netfCash is modified in memory during this method if mustCalculatefcash\\n        // is set to true\\n        assetCashShare = assetCashShare.add(\\n            _removeLiquidityTokens(nToken, nTokensToRedeem, tokensToWithdraw, netfCash, blockTime, mustCalculatefCash)\\n        );\\n\\n        nToken.portfolioState.storeAssets(nToken.tokenAddress);\\n\\n        // NOTE: Token supply change will happen when we finalize balances and after minting of incentives\\n        return assetCashShare;\\n    }\\n\\n    /// @notice Removes nToken liquidity tokens and updates the netfCash figures.\\n    /// @param nToken portfolio object\\n    /// @param nTokensToRedeem tokens to redeem\\n    /// @param tokensToWithdraw array of liquidity tokens to withdraw\\n    /// @param netfCash array of netfCash figures\\n    /// @param blockTime current block time\\n    /// @param mustCalculatefCash true if netfCash must be calculated in the removeLiquidityTokens step\\n    /// @return totalAssetCashClaims is the amount of asset cash raised from liquidity token cash claims\\n    function _removeLiquidityTokens(\\n        nTokenPortfolio memory nToken,\\n        int256 nTokensToRedeem,\\n        int256[] memory tokensToWithdraw,\\n        int256[] memory netfCash,\\n        uint256 blockTime,\\n        bool mustCalculatefCash\\n    ) private returns (int256 totalAssetCashClaims) {\\n        MarketParameters memory market;\\n\\n        for (uint256 i = 0; i < nToken.portfolioState.storedAssets.length; i++) {\\n            PortfolioAsset memory asset = nToken.portfolioState.storedAssets[i];\\n            asset.notional = asset.notional.sub(tokensToWithdraw[i]);\\n            // Cannot redeem liquidity tokens down to zero or this will cause many issues with\\n            // market initialization.\\n            require(asset.notional > 0, \\\"Cannot redeem to zero\\\");\\n            require(asset.storageState == AssetStorageState.NoChange);\\n            asset.storageState = AssetStorageState.Update;\\n\\n            // This will load a market object in memory\\n            nToken.cashGroup.loadMarket(market, i + 1, true, blockTime);\\n            int256 fCashClaim;\\n            {\\n                int256 assetCash;\\n                // Remove liquidity from the market\\n                (assetCash, fCashClaim) = market.removeLiquidity(tokensToWithdraw[i]);\\n                totalAssetCashClaims = totalAssetCashClaims.add(assetCash);\\n            }\\n\\n            int256 fCashToNToken;\\n            if (mustCalculatefCash) {\\n                // Do this calculation if net ifCash is not set, will happen if there are no residuals\\n                int256 fCashShare = BitmapAssetsHandler.getifCashNotional(\\n                    nToken.tokenAddress,\\n                    nToken.cashGroup.currencyId,\\n                    asset.maturity\\n                );\\n                fCashShare = fCashShare.mul(nTokensToRedeem).div(nToken.totalSupply);\\n                // netfCash = fCashClaim + fCashShare\\n                netfCash[i] = fCashClaim.add(fCashShare);\\n                fCashToNToken = fCashShare.neg();\\n            } else {\\n                // Account will receive netfCash amount. Deduct that from the fCash claim and add the\\n                // remaining back to the nToken to net off the nToken's position\\n                // fCashToNToken = -fCashShare\\n                // netfCash = fCashClaim + fCashShare\\n                // fCashToNToken = -(netfCash - fCashClaim)\\n                // fCashToNToken = fCashClaim - netfCash\\n                fCashToNToken = fCashClaim.sub(netfCash[i]);\\n            }\\n\\n            // Removes the account's fCash position from the nToken\\n            BitmapAssetsHandler.addifCashAsset(\\n                nToken.tokenAddress,\\n                asset.currencyId,\\n                asset.maturity,\\n                nToken.lastInitializedTime,\\n                fCashToNToken\\n            );\\n        }\\n\\n        return totalAssetCashClaims;\\n    }\\n\\n    /// @notice Sells fCash assets back into the market for cash. Negative fCash assets will decrease netAssetCash\\n    /// as a result. The aim here is to ensure that accounts can redeem nTokens without having to take on\\n    /// fCash assets.\\n    function _sellfCashAssets(\\n        nTokenPortfolio memory nToken,\\n        int256[] memory netfCash,\\n        uint256 blockTime\\n    ) private returns (int256 totalAssetCash, bool hasResidual) {\\n        MarketParameters memory market;\\n        hasResidual = false;\\n\\n        for (uint256 i = 0; i < netfCash.length; i++) {\\n            if (netfCash[i] == 0) continue;\\n\\n            nToken.cashGroup.loadMarket(market, i + 1, false, blockTime);\\n            int256 netAssetCash = market.executeTrade(\\n                nToken.cashGroup,\\n                // Use the negative of fCash notional here since we want to net it out\\n                netfCash[i].neg(),\\n                nToken.portfolioState.storedAssets[i].maturity.sub(blockTime),\\n                i + 1\\n            );\\n\\n            if (netAssetCash == 0) {\\n                // This means that the trade failed\\n                hasResidual = true;\\n            } else {\\n                totalAssetCash = totalAssetCash.add(netAssetCash);\\n                netfCash[i] = 0;\\n            }\\n        }\\n    }\\n\\n    /// @notice Combines newifCashAssets array with netfCash assets into a single finalfCashAssets array\\n    function _addResidualsToAssets(\\n        PortfolioAsset[] memory liquidityTokens,\\n        PortfolioAsset[] memory newifCashAssets,\\n        int256[] memory netfCash\\n    ) internal pure returns (PortfolioAsset[] memory finalfCashAssets) {\\n        uint256 numAssetsToExtend;\\n        for (uint256 i = 0; i < netfCash.length; i++) {\\n            if (netfCash[i] != 0) numAssetsToExtend++;\\n        }\\n\\n        uint256 newLength = newifCashAssets.length + numAssetsToExtend;\\n        finalfCashAssets = new PortfolioAsset[](newLength);\\n        uint index = 0;\\n        for (; index < newifCashAssets.length; index++) {\\n            finalfCashAssets[index] = newifCashAssets[index];\\n        }\\n\\n        uint netfCashIndex = 0;\\n        for (; index < finalfCashAssets.length; ) {\\n            if (netfCash[netfCashIndex] != 0) {\\n                PortfolioAsset memory asset = finalfCashAssets[index];\\n                asset.currencyId = liquidityTokens[netfCashIndex].currencyId;\\n                asset.maturity = liquidityTokens[netfCashIndex].maturity;\\n                asset.assetType = Constants.FCASH_ASSET_TYPE;\\n                asset.notional = netfCash[netfCashIndex];\\n                index++;\\n            }\\n\\n            netfCashIndex++;\\n        }\\n\\n        return finalfCashAssets;\\n    }\\n\\n    /// @notice Used to reduce an nToken ifCash assets portfolio proportionately when redeeming\\n    /// nTokens to its underlying assets.\\n    function _reduceifCashAssetsProportional(\\n        address account,\\n        uint256 currencyId,\\n        uint256 lastInitializedTime,\\n        int256 tokensToRedeem,\\n        int256 totalSupply,\\n        bytes32 assetsBitmap\\n    ) internal returns (PortfolioAsset[] memory) {\\n        uint256 index = assetsBitmap.totalBitsSet();\\n        mapping(address => mapping(uint256 =>\\n            mapping(uint256 => ifCashStorage))) storage store = LibStorage.getifCashBitmapStorage();\\n\\n        PortfolioAsset[] memory assets = new PortfolioAsset[](index);\\n        index = 0;\\n\\n        uint256 bitNum = assetsBitmap.getNextBitNum();\\n        while (bitNum != 0) {\\n            uint256 maturity = DateTime.getMaturityFromBitNum(lastInitializedTime, bitNum);\\n            ifCashStorage storage fCashSlot = store[account][currencyId][maturity];\\n            int256 notional = fCashSlot.notional;\\n\\n            int256 notionalToTransfer = notional.mul(tokensToRedeem).div(totalSupply);\\n            int256 finalNotional = notional.sub(notionalToTransfer);\\n\\n            require(type(int128).min <= finalNotional && finalNotional <= type(int128).max); // dev: bitmap notional overflow\\n            fCashSlot.notional = int128(finalNotional);\\n\\n            PortfolioAsset memory asset = assets[index];\\n            asset.currencyId = currencyId;\\n            asset.maturity = maturity;\\n            asset.assetType = Constants.FCASH_ASSET_TYPE;\\n            asset.notional = notionalToTransfer;\\n            index += 1;\\n\\n            // Turn off the bit and look for the next one\\n            assetsBitmap = assetsBitmap.setBit(bitNum, false);\\n            bitNum = assetsBitmap.getNextBitNum();\\n        }\\n\\n        return assets;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/actions/TradingAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../FreeCollateralExternal.sol\\\";\\nimport \\\"../SettleAssetsExternal.sol\\\";\\nimport \\\"../../internal/markets/Market.sol\\\";\\nimport \\\"../../internal/markets/CashGroup.sol\\\";\\nimport \\\"../../internal/markets/AssetRate.sol\\\";\\nimport \\\"../../internal/balances/BalanceHandler.sol\\\";\\nimport \\\"../../internal/portfolio/PortfolioHandler.sol\\\";\\nimport \\\"../../internal/portfolio/TransferAssets.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary TradingAction {\\n    using PortfolioHandler for PortfolioState;\\n    using AccountContextHandler for AccountContext;\\n    using Market for MarketParameters;\\n    using CashGroup for CashGroupParameters;\\n    using AssetRate for AssetRateParameters;\\n    using SafeInt256 for int256;\\n    using SafeMath for uint256;\\n\\n    event LendBorrowTrade(\\n        address indexed account,\\n        uint16 indexed currencyId,\\n        uint40 maturity,\\n        int256 netAssetCash,\\n        int256 netfCash\\n    );\\n\\n    event AddRemoveLiquidity(\\n        address indexed account,\\n        uint16 indexed currencyId,\\n        uint40 maturity,\\n        int256 netAssetCash,\\n        int256 netfCash,\\n        int256 netLiquidityTokens\\n    );\\n\\n    event SettledCashDebt(\\n        address indexed settledAccount,\\n        uint16 indexed currencyId,\\n        address indexed settler,\\n        int256 amountToSettleAsset,\\n        int256 fCashAmount\\n    );\\n\\n    event nTokenResidualPurchase(\\n        uint16 indexed currencyId,\\n        uint40 indexed maturity,\\n        address indexed purchaser,\\n        int256 fCashAmountToPurchase,\\n        int256 netAssetCashNToken\\n    );\\n\\n    /// @dev Used internally to manage stack issues\\n    struct TradeContext {\\n        int256 cash;\\n        int256 fCashAmount;\\n        int256 fee;\\n        int256 netCash;\\n        int256 totalFee;\\n        uint256 blockTime;\\n    }\\n\\n    /// @notice Executes a trade for leveraged vaults (they can only lend or borrow).\\n    /// @param currencyId the currency id to lend or borrow\\n    /// @param trade the bytes32 encoded trade data\\n    function executeVaultTrade(uint16 currencyId, bytes32 trade)\\n        external\\n        returns (int256 netAssetCash) {\\n        CashGroupParameters memory cashGroup = CashGroup.buildCashGroupStateful(currencyId);\\n        MarketParameters memory market;\\n        TradeActionType tradeType = TradeActionType(uint256(uint8(bytes1(trade))));\\n\\n        (netAssetCash, /* */) = _executeLendBorrowTrade(cashGroup, market, tradeType, block.timestamp, trade);\\n    }\\n\\n    /// @notice Executes trades for a bitmapped portfolio, cannot be called directly\\n    /// @param account account to put fCash assets in\\n    /// @param bitmapCurrencyId currency id of the bitmap\\n    /// @param nextSettleTime used to calculate the relative positions in the bitmap\\n    /// @param trades tightly packed array of trades, schema is defined in global/Types.sol\\n    /// @return netCash generated by trading\\n    /// @return didIncurDebt if the bitmap had an fCash position go negative\\n    function executeTradesBitmapBatch(\\n        address account,\\n        uint16 bitmapCurrencyId,\\n        uint40 nextSettleTime,\\n        bytes32[] calldata trades\\n    ) external returns (int256, bool) {\\n        CashGroupParameters memory cashGroup = CashGroup.buildCashGroupStateful(bitmapCurrencyId);\\n        MarketParameters memory market;\\n        bool didIncurDebt;\\n        TradeContext memory c;\\n        c.blockTime = block.timestamp;\\n\\n        for (uint256 i = 0; i < trades.length; i++) {\\n            uint256 maturity;\\n            (maturity, c.cash, c.fCashAmount) = _executeTrade(\\n                account,\\n                cashGroup,\\n                market,\\n                trades[i],\\n                c.blockTime\\n            );\\n\\n            c.fCashAmount = BitmapAssetsHandler.addifCashAsset(\\n                account,\\n                bitmapCurrencyId,\\n                maturity,\\n                nextSettleTime,\\n                c.fCashAmount\\n            );\\n\\n            didIncurDebt = didIncurDebt || (c.fCashAmount < 0);\\n            c.netCash = c.netCash.add(c.cash);\\n        }\\n\\n        return (c.netCash, didIncurDebt);\\n    }\\n\\n    /// @notice Executes trades for a bitmapped portfolio, cannot be called directly\\n    /// @param account account to put fCash assets in\\n    /// @param currencyId currency id to trade\\n    /// @param portfolioState used to update the positions in the portfolio\\n    /// @param trades tightly packed array of trades, schema is defined in global/Types.sol\\n    /// @return resulting portfolio state\\n    /// @return netCash generated by trading\\n    function executeTradesArrayBatch(\\n        address account,\\n        uint16 currencyId,\\n        PortfolioState memory portfolioState,\\n        bytes32[] calldata trades\\n    ) external returns (PortfolioState memory, int256) {\\n        CashGroupParameters memory cashGroup = CashGroup.buildCashGroupStateful(currencyId);\\n        MarketParameters memory market;\\n        TradeContext memory c;\\n        c.blockTime = block.timestamp;\\n\\n        for (uint256 i = 0; i < trades.length; i++) {\\n            TradeActionType tradeType = TradeActionType(uint256(uint8(bytes1(trades[i]))));\\n\\n            if (\\n                tradeType == TradeActionType.AddLiquidity ||\\n                tradeType == TradeActionType.RemoveLiquidity\\n            ) {\\n                revert(\\\"Disabled\\\");\\n                /**\\n                 * Manual adding and removing of liquidity is currently disabled.\\n                 *\\n                 *  // Liquidity tokens can only be added by array portfolio\\n                 *  c.cash = _executeLiquidityTrade(\\n                 *      account,\\n                 *      cashGroup,\\n                 *      market,\\n                 *      tradeType,\\n                 *      trades[i],\\n                 *      portfolioState,\\n                 *      c.netCash\\n                 *  );\\n                 */\\n            } else {\\n                uint256 maturity;\\n                (maturity, c.cash, c.fCashAmount) = _executeTrade(\\n                    account,\\n                    cashGroup,\\n                    market,\\n                    trades[i],\\n                    c.blockTime\\n                );\\n\\n                portfolioState.addAsset(\\n                    currencyId,\\n                    maturity,\\n                    Constants.FCASH_ASSET_TYPE,\\n                    c.fCashAmount\\n                );\\n            }\\n\\n            c.netCash = c.netCash.add(c.cash);\\n        }\\n\\n        return (portfolioState, c.netCash);\\n    }\\n\\n    /// @notice Executes a non-liquidity token trade\\n    /// @param account the initiator of the trade\\n    /// @param cashGroup parameters for the trade\\n    /// @param market market memory location to use\\n    /// @param trade bytes32 encoding of the particular trade\\n    /// @param blockTime the current block time\\n    /// @return maturity of the asset that was traded\\n    /// @return cashAmount - a positive or negative cash amount accrued to the account\\n    /// @return fCashAmount - a positive or negative fCash amount accrued to the account\\n    function _executeTrade(\\n        address account,\\n        CashGroupParameters memory cashGroup,\\n        MarketParameters memory market,\\n        bytes32 trade,\\n        uint256 blockTime\\n    )\\n        private\\n        returns (\\n            uint256 maturity,\\n            int256 cashAmount,\\n            int256 fCashAmount\\n        )\\n    {\\n        TradeActionType tradeType = TradeActionType(uint256(uint8(bytes1(trade))));\\n        if (tradeType == TradeActionType.PurchaseNTokenResidual) {\\n            (maturity, cashAmount, fCashAmount) = _purchaseNTokenResidual(\\n                account,\\n                cashGroup,\\n                blockTime,\\n                trade\\n            );\\n        } else if (tradeType == TradeActionType.SettleCashDebt) {\\n            (maturity, cashAmount, fCashAmount) = _settleCashDebt(account, cashGroup, blockTime, trade);\\n        } else if (tradeType == TradeActionType.Lend || tradeType == TradeActionType.Borrow) {\\n            (cashAmount, fCashAmount) = _executeLendBorrowTrade(\\n                cashGroup,\\n                market,\\n                tradeType,\\n                blockTime,\\n                trade\\n            );\\n            require(cashAmount != 0, \\\"Trade failed, liquidity\\\");\\n\\n            // This is a little ugly but required to deal with stack issues. We know the market is loaded\\n            // with the proper maturity inside _executeLendBorrowTrade\\n            maturity = market.maturity;\\n            emit LendBorrowTrade(\\n                account,\\n                uint16(cashGroup.currencyId),\\n                uint40(maturity),\\n                cashAmount,\\n                fCashAmount\\n            );\\n        } else {\\n            revert(\\\"Invalid trade type\\\");\\n        }\\n    }\\n\\n    /// @notice Executes a liquidity token trade, no fees incurred and only array portfolios may hold\\n    /// liquidity tokens.\\n    /// @param account the initiator of the trade\\n    /// @param cashGroup parameters for the trade\\n    /// @param market market memory location to use\\n    /// @param tradeType whether this is add or remove liquidity\\n    /// @param trade bytes32 encoding of the particular trade\\n    /// @param portfolioState the current account's portfolio state\\n    /// @param netCash the current net cash accrued in this batch of trades, can be\\n    //  used for adding liquidity\\n    /// @return cashAmount: a positive or negative cash amount accrued to the account\\n    function _executeLiquidityTrade(\\n        address account,\\n        CashGroupParameters memory cashGroup,\\n        MarketParameters memory market,\\n        TradeActionType tradeType,\\n        bytes32 trade,\\n        PortfolioState memory portfolioState,\\n        int256 netCash\\n    ) private returns (int256) {\\n        uint256 marketIndex = uint8(bytes1(trade << 8));\\n        // NOTE: this loads the market in memory\\n        cashGroup.loadMarket(market, marketIndex, true, block.timestamp);\\n\\n        int256 cashAmount;\\n        int256 fCashAmount;\\n        int256 tokens;\\n        if (tradeType == TradeActionType.AddLiquidity) {\\n            cashAmount = int256((uint256(trade) >> 152) & type(uint88).max);\\n            // Setting cash amount to zero will deposit all net cash accumulated in this trade into\\n            // liquidity. This feature allows accounts to borrow in one maturity to provide liquidity\\n            // in another in a single transaction without dust. It also allows liquidity providers to\\n            // sell off the net cash residuals and use the cash amount in the new market without dust\\n            if (cashAmount == 0) cashAmount = netCash;\\n\\n            // Add liquidity will check cash amount is positive\\n            (tokens, fCashAmount) = market.addLiquidity(cashAmount);\\n            cashAmount = cashAmount.neg(); // Report a negative cash amount in the event\\n        } else {\\n            tokens = int256((uint256(trade) >> 152) & type(uint88).max);\\n            (cashAmount, fCashAmount) = market.removeLiquidity(tokens);\\n            tokens = tokens.neg(); // Report a negative amount tokens in the event\\n        }\\n\\n        {\\n            uint256 minImpliedRate = uint32(uint256(trade) >> 120);\\n            uint256 maxImpliedRate = uint32(uint256(trade) >> 88);\\n            // If minImpliedRate is not set then it will be zero\\n            require(market.lastImpliedRate >= minImpliedRate, \\\"Trade failed, slippage\\\");\\n            if (maxImpliedRate != 0)\\n                require(market.lastImpliedRate <= maxImpliedRate, \\\"Trade failed, slippage\\\");\\n        }\\n\\n        // Add the assets in this order so they are sorted\\n        portfolioState.addAsset(\\n            cashGroup.currencyId,\\n            market.maturity,\\n            Constants.FCASH_ASSET_TYPE,\\n            fCashAmount\\n        );\\n        // Adds the liquidity token asset\\n        portfolioState.addAsset(\\n            cashGroup.currencyId,\\n            market.maturity,\\n            marketIndex + 1,\\n            tokens\\n        );\\n\\n        emit AddRemoveLiquidity(\\n            account,\\n            cashGroup.currencyId,\\n            // This will not overflow for a long time\\n            uint40(market.maturity),\\n            cashAmount,\\n            fCashAmount,\\n            tokens\\n        );\\n\\n        return cashAmount;\\n    }\\n\\n    /// @notice Executes a lend or borrow trade\\n    /// @param cashGroup parameters for the trade\\n    /// @param market market memory location to use\\n    /// @param tradeType whether this is add or remove liquidity\\n    /// @param blockTime the current block time\\n    /// @param trade bytes32 encoding of the particular trade\\n    /// @return cashAmount - a positive or negative cash amount accrued to the account\\n    /// @return fCashAmount -  a positive or negative fCash amount accrued to the account\\n    function _executeLendBorrowTrade(\\n        CashGroupParameters memory cashGroup,\\n        MarketParameters memory market,\\n        TradeActionType tradeType,\\n        uint256 blockTime,\\n        bytes32 trade\\n    )\\n        private\\n        returns (\\n            int256 cashAmount,\\n            int256 fCashAmount\\n        )\\n    {\\n        uint256 marketIndex = uint256(uint8(bytes1(trade << 8)));\\n        // NOTE: this updates the market in memory\\n        cashGroup.loadMarket(market, marketIndex, false, blockTime);\\n\\n        fCashAmount = int256(uint88(bytes11(trade << 16)));\\n        // fCash to account will be negative here\\n        if (tradeType == TradeActionType.Borrow) fCashAmount = fCashAmount.neg();\\n\\n        cashAmount = market.executeTrade(\\n            cashGroup,\\n            fCashAmount,\\n            market.maturity.sub(blockTime),\\n            marketIndex\\n        );\\n\\n        uint256 rateLimit = uint256(uint32(bytes4(trade << 104)));\\n        if (rateLimit != 0) {\\n            if (tradeType == TradeActionType.Borrow) {\\n                // Do not allow borrows over the rate limit\\n                require(market.lastImpliedRate <= rateLimit, \\\"Trade failed, slippage\\\");\\n            } else {\\n                // Do not allow lends under the rate limit\\n                require(market.lastImpliedRate >= rateLimit, \\\"Trade failed, slippage\\\");\\n            }\\n        }\\n    }\\n\\n    /// @notice If an account has a negative cash balance we allow anyone to lend to to that account at a penalty\\n    /// rate to the 3 month market.\\n    /// @param account the account initiating the trade, used to check that self settlement is not possible\\n    /// @param cashGroup parameters for the trade\\n    /// @param blockTime the current block time\\n    /// @param trade bytes32 encoding of the particular trade\\n    /// @return maturity: the date of the three month maturity where fCash will be exchanged\\n    /// @return cashAmount: a negative cash amount that the account must pay to the settled account\\n    /// @return fCashAmount: a positive fCash amount that the account will receive\\n    function _settleCashDebt(\\n        address account,\\n        CashGroupParameters memory cashGroup,\\n        uint256 blockTime,\\n        bytes32 trade\\n    )\\n        internal\\n        returns (\\n            uint256,\\n            int256,\\n            int256\\n        )\\n    {\\n        address counterparty = address(uint256(trade) >> 88);\\n        // Allowing an account to settle itself would result in strange outcomes\\n        require(account != counterparty, \\\"Cannot settle self\\\");\\n        int256 amountToSettleAsset = int256(uint88(uint256(trade)));\\n\\n        AccountContext memory counterpartyContext =\\n            AccountContextHandler.getAccountContext(counterparty);\\n\\n        if (counterpartyContext.mustSettleAssets()) {\\n            counterpartyContext = SettleAssetsExternal.settleAccount(counterparty, counterpartyContext);\\n        }\\n\\n        // This will check if the amountToSettleAsset is valid and revert if it is not. Amount to settle is a positive\\n        // number denominated in asset terms. If amountToSettleAsset is set equal to zero on the input, will return the\\n        // max amount to settle. This will update the balance storage on the counterparty.\\n        amountToSettleAsset = BalanceHandler.setBalanceStorageForSettleCashDebt(\\n            counterparty,\\n            cashGroup,\\n            amountToSettleAsset,\\n            counterpartyContext\\n        );\\n\\n        // Settled account must borrow from the 3 month market at a penalty rate. This will fail if the market\\n        // is not initialized.\\n        uint256 threeMonthMaturity = DateTime.getReferenceTime(blockTime) + Constants.QUARTER;\\n        int256 fCashAmount =\\n            _getfCashSettleAmount(cashGroup, threeMonthMaturity, blockTime, amountToSettleAsset);\\n        // Defensive check to ensure that we can't inadvertently cause the settler to lose fCash.\\n        require(fCashAmount >= 0);\\n\\n        // It's possible that this action will put an account into negative free collateral. In this case they\\n        // will immediately become eligible for liquidation and the account settling the debt can also liquidate\\n        // them in the same transaction. Do not run a free collateral check here to allow this to happen.\\n        {\\n            PortfolioAsset[] memory assets = new PortfolioAsset[](1);\\n            assets[0].currencyId = cashGroup.currencyId;\\n            assets[0].maturity = threeMonthMaturity;\\n            assets[0].notional = fCashAmount.neg(); // This is the debt the settled account will incur\\n            assets[0].assetType = Constants.FCASH_ASSET_TYPE;\\n            // Can transfer assets, we have settled above\\n            counterpartyContext = TransferAssets.placeAssetsInAccount(\\n                counterparty,\\n                counterpartyContext,\\n                assets\\n            );\\n        }\\n        counterpartyContext.setAccountContext(counterparty);\\n\\n        emit SettledCashDebt(\\n            counterparty,\\n            uint16(cashGroup.currencyId),\\n            account,\\n            amountToSettleAsset,\\n            fCashAmount.neg()\\n        );\\n\\n        return (threeMonthMaturity, amountToSettleAsset.neg(), fCashAmount);\\n    }\\n\\n    /// @dev Helper method to calculate the fCashAmount from the penalty settlement rate\\n    function _getfCashSettleAmount(\\n        CashGroupParameters memory cashGroup,\\n        uint256 threeMonthMaturity,\\n        uint256 blockTime,\\n        int256 amountToSettleAsset\\n    ) private view returns (int256) {\\n        uint256 oracleRate = cashGroup.calculateOracleRate(threeMonthMaturity, blockTime);\\n\\n        int256 exchangeRate =\\n            Market.getExchangeRateFromImpliedRate(\\n                oracleRate.add(cashGroup.getSettlementPenalty()),\\n                threeMonthMaturity.sub(blockTime)\\n            );\\n\\n        // Amount to settle is positive, this returns the fCashAmount that the settler will\\n        // receive as a positive number\\n        return\\n            cashGroup.assetRate\\n                .convertToUnderlying(amountToSettleAsset)\\n                // Exchange rate converts from cash to fCash when multiplying\\n                .mulInRatePrecision(exchangeRate);\\n    }\\n\\n    /// @notice Allows an account to purchase ntoken residuals\\n    /// @param purchaser account that is purchasing the residuals\\n    /// @param cashGroup parameters for the trade\\n    /// @param blockTime the current block time\\n    /// @param trade bytes32 encoding of the particular trade\\n    /// @return maturity: the date of the idiosyncratic maturity where fCash will be exchanged\\n    /// @return cashAmount: a positive or negative cash amount that the account will receive or pay\\n    /// @return fCashAmount: a positive or negative fCash amount that the account will receive\\n    function _purchaseNTokenResidual(\\n        address purchaser,\\n        CashGroupParameters memory cashGroup,\\n        uint256 blockTime,\\n        bytes32 trade\\n    )\\n        internal\\n        returns (\\n            uint256,\\n            int256,\\n            int256\\n        )\\n    {\\n        uint256 maturity = uint256(uint32(uint256(trade) >> 216));\\n        int256 fCashAmountToPurchase = int88(uint88(uint256(trade) >> 128));\\n        require(maturity > blockTime, \\\"Invalid maturity\\\");\\n        // Require that the residual to purchase does not fall on an existing maturity (i.e.\\n        // it is an idiosyncratic maturity)\\n        require(\\n            !DateTime.isValidMarketMaturity(cashGroup.maxMarketIndex, maturity, blockTime),\\n            \\\"Non idiosyncratic maturity\\\"\\n        );\\n\\n        address nTokenAddress = nTokenHandler.nTokenAddress(cashGroup.currencyId);\\n        // prettier-ignore\\n        (\\n            /* currencyId */,\\n            /* incentiveRate */,\\n            uint256 lastInitializedTime,\\n            /* assetArrayLength */,\\n            bytes6 parameters\\n        ) = nTokenHandler.getNTokenContext(nTokenAddress);\\n\\n        // Restrict purchasing until some amount of time after the last initialized time to ensure that arbitrage\\n        // opportunities are not available (by generating residuals and then immediately purchasing them at a discount)\\n        // This is always relative to the last initialized time which is set at utc0 when initialized, not the\\n        // reference time. Therefore we will always restrict residual purchase relative to initialization, not reference.\\n        // This is safer, prevents an attack if someone forces residuals and then somehow prevents market initialization\\n        // until the residual time buffer passes.\\n        require(\\n            blockTime >\\n                lastInitializedTime.add(\\n                    uint256(uint8(parameters[Constants.RESIDUAL_PURCHASE_TIME_BUFFER])) * 1 hours\\n                ),\\n            \\\"Insufficient block time\\\"\\n        );\\n\\n        int256 notional =\\n            BitmapAssetsHandler.getifCashNotional(nTokenAddress, cashGroup.currencyId, maturity);\\n        // Check if amounts are valid and set them to the max available if necessary\\n        if (notional < 0 && fCashAmountToPurchase < 0) {\\n            // Does not allow purchasing more negative notional than available\\n            if (fCashAmountToPurchase < notional) fCashAmountToPurchase = notional;\\n        } else if (notional > 0 && fCashAmountToPurchase > 0) {\\n            // Does not allow purchasing more positive notional than available\\n            if (fCashAmountToPurchase > notional) fCashAmountToPurchase = notional;\\n        } else {\\n            // Does not allow moving notional in the opposite direction\\n            revert(\\\"Invalid amount\\\");\\n        }\\n\\n        // If fCashAmount > 0 then this will return netAssetCash > 0, if fCashAmount < 0 this will return\\n        // netAssetCash < 0. fCashAmount will go to the purchaser and netAssetCash will go to the nToken.\\n        int256 netAssetCashNToken =\\n            _getResidualPriceAssetCash(\\n                cashGroup,\\n                maturity,\\n                blockTime,\\n                fCashAmountToPurchase,\\n                parameters\\n            );\\n\\n        _updateNTokenPortfolio(\\n            nTokenAddress,\\n            cashGroup.currencyId,\\n            maturity,\\n            lastInitializedTime,\\n            fCashAmountToPurchase,\\n            netAssetCashNToken\\n        );\\n\\n        emit nTokenResidualPurchase(\\n            uint16(cashGroup.currencyId),\\n            uint40(maturity),\\n            purchaser,\\n            fCashAmountToPurchase,\\n            netAssetCashNToken\\n        );\\n\\n        return (maturity, netAssetCashNToken.neg(), fCashAmountToPurchase);\\n    }\\n\\n    /// @notice Returns the amount of asset cash required to purchase the nToken residual\\n    function _getResidualPriceAssetCash(\\n        CashGroupParameters memory cashGroup,\\n        uint256 maturity,\\n        uint256 blockTime,\\n        int256 fCashAmount,\\n        bytes6 parameters\\n    ) internal view returns (int256) {\\n        uint256 oracleRate = cashGroup.calculateOracleRate(maturity, blockTime);\\n        // Residual purchase incentive is specified in ten basis point increments\\n        uint256 purchaseIncentive =\\n            uint256(uint8(parameters[Constants.RESIDUAL_PURCHASE_INCENTIVE])) *\\n                Constants.TEN_BASIS_POINTS;\\n\\n        if (fCashAmount > 0) {\\n            // When fCash is positive then we add the purchase incentive, the purchaser\\n            // can pay less cash for the fCash relative to the oracle rate\\n            oracleRate = oracleRate.add(purchaseIncentive);\\n        } else if (oracleRate > purchaseIncentive) {\\n            // When fCash is negative, we reduce the interest rate that the purchaser will\\n            // borrow at, we do this check to ensure that we floor the oracle rate at zero.\\n            oracleRate = oracleRate.sub(purchaseIncentive);\\n        } else {\\n            // If the oracle rate is less than the purchase incentive floor the interest rate at zero\\n            oracleRate = 0;\\n        }\\n\\n        int256 exchangeRate =\\n            Market.getExchangeRateFromImpliedRate(oracleRate, maturity.sub(blockTime));\\n\\n        // Returns the net asset cash from the nToken perspective, which is the same sign as the fCash amount\\n        return\\n            cashGroup.assetRate.convertFromUnderlying(fCashAmount.divInRatePrecision(exchangeRate));\\n    }\\n\\n    function _updateNTokenPortfolio(\\n        address nTokenAddress,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 lastInitializedTime,\\n        int256 fCashAmountToPurchase,\\n        int256 netAssetCashNToken\\n    ) private {\\n        int256 finalNotional = BitmapAssetsHandler.addifCashAsset(\\n            nTokenAddress,\\n            currencyId,\\n            maturity,\\n            lastInitializedTime,\\n            fCashAmountToPurchase.neg() // the nToken takes on the negative position\\n        );\\n\\n        // Defensive check to ensure that fCash amounts do not flip signs\\n        require(\\n            (fCashAmountToPurchase > 0 && finalNotional >= 0) ||\\n            (fCashAmountToPurchase < 0 && finalNotional <= 0)\\n        );\\n\\n        // prettier-ignore\\n        (\\n            int256 nTokenCashBalance,\\n            /* storedNTokenBalance */,\\n            /* lastClaimTime */,\\n            /* accountIncentiveDebt */\\n        ) = BalanceHandler.getBalanceStorage(nTokenAddress, currencyId);\\n        nTokenCashBalance = nTokenCashBalance.add(netAssetCashNToken);\\n\\n        // This will ensure that the cash balance is not negative\\n        BalanceHandler.setBalanceStorageForNToken(nTokenAddress, currencyId, nTokenCashBalance);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/FreeCollateralExternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../external/SettleAssetsExternal.sol\\\";\\nimport \\\"../internal/AccountContextHandler.sol\\\";\\nimport \\\"../internal/valuation/FreeCollateral.sol\\\";\\n\\n/// @title Externally deployed library for free collateral calculations\\nlibrary FreeCollateralExternal {\\n    using AccountContextHandler for AccountContext;\\n\\n    /// @notice Returns the ETH denominated free collateral of an account, represents the amount of\\n    /// debt that the account can incur before liquidation. If an account's assets need to be settled this\\n    /// will revert, either settle the account or use the off chain SDK to calculate free collateral.\\n    /// @dev Called via the Views.sol method to return an account's free collateral. Does not work\\n    /// for the nToken, the nToken does not have an account context.\\n    /// @param account account to calculate free collateral for\\n    /// @return total free collateral in ETH w/ 8 decimal places\\n    /// @return array of net local values in asset values ordered by currency id\\n    function getFreeCollateralView(address account)\\n        external\\n        view\\n        returns (int256, int256[] memory)\\n    {\\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\\n        // The internal free collateral function does not account for settled assets. The Notional SDK\\n        // can calculate the free collateral off chain if required at this point.\\n        require(!accountContext.mustSettleAssets(), \\\"Assets not settled\\\");\\n        return FreeCollateral.getFreeCollateralView(account, accountContext, block.timestamp);\\n    }\\n\\n    /// @notice Calculates free collateral and will revert if it falls below zero. If the account context\\n    /// must be updated due to changes in debt settings, will update. Cannot check free collateral if assets\\n    /// need to be settled first.\\n    /// @dev Cannot be called directly by users, used during various actions that require an FC check. Must be\\n    /// called before the end of any transaction for accounts where FC can decrease.\\n    /// @param account account to calculate free collateral for\\n    function checkFreeCollateralAndRevert(address account) external {\\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\\n        require(!accountContext.mustSettleAssets(), \\\"Assets not settled\\\");\\n\\n        (int256 ethDenominatedFC, bool updateContext) =\\n            FreeCollateral.getFreeCollateralStateful(account, accountContext, block.timestamp);\\n\\n        if (updateContext) {\\n            accountContext.setAccountContext(account);\\n        }\\n\\n        require(ethDenominatedFC >= 0, \\\"Insufficient free collateral\\\");\\n    }\\n\\n    /// @notice Calculates liquidation factors for an account\\n    /// @dev Only called internally by liquidation actions, does some initial validation of currencies. If a currency is\\n    /// specified that the account does not have, a asset available figure of zero will be returned. If this is the case then\\n    /// liquidation actions will revert.\\n    /// @dev an ntoken account will return 0 FC and revert if called\\n    /// @param account account to liquidate\\n    /// @param localCurrencyId currency that the debts are denominated in\\n    /// @param collateralCurrencyId collateral currency to liquidate against, set to zero in the case of local currency liquidation\\n    /// @return accountContext the accountContext of the liquidated account\\n    /// @return factors struct of relevant factors for liquidation\\n    /// @return portfolio the portfolio array of the account (bitmap accounts will return an empty array)\\n    function getLiquidationFactors(\\n        address account,\\n        uint256 localCurrencyId,\\n        uint256 collateralCurrencyId\\n    )\\n        external\\n        returns (\\n            AccountContext memory accountContext,\\n            LiquidationFactors memory factors,\\n            PortfolioAsset[] memory portfolio\\n        )\\n    {\\n        accountContext = AccountContextHandler.getAccountContext(account);\\n        if (accountContext.mustSettleAssets()) {\\n            accountContext = SettleAssetsExternal.settleAccount(account, accountContext);\\n        }\\n\\n        if (accountContext.isBitmapEnabled()) {\\n            // A bitmap currency can only ever hold debt in this currency\\n            require(localCurrencyId == accountContext.bitmapCurrencyId);\\n        }\\n\\n        (factors, portfolio) = FreeCollateral.getLiquidationFactors(\\n            account,\\n            accountContext,\\n            block.timestamp,\\n            localCurrencyId,\\n            collateralCurrencyId\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/MigrateIncentives.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../global/LibStorage.sol\\\";\\nimport \\\"../internal/nToken/nTokenHandler.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n/**\\n * @notice Deployed library for migration of incentives from the old (inaccurate) calculation\\n * to a newer, more accurate calculation based on SushiSwap MasterChef math. The more accurate\\n * calculation is inside `Incentives.sol` and this library holds the legacy calculation. System\\n * migration code can be found in `MigrateIncentivesFix.sol`\\n */\\nlibrary MigrateIncentives {\\n    using SafeMath for uint256;\\n\\n    /// @notice Calculates the claimable incentives for a particular nToken and account in the\\n    /// previous regime. This should only ever be called ONCE for an account / currency combination\\n    /// to get the incentives accrued up until the migration date.\\n    function migrateAccountFromPreviousCalculation(\\n        address tokenAddress,\\n        uint256 nTokenBalance,\\n        uint256 lastClaimTime,\\n        uint256 lastClaimIntegralSupply\\n    ) external view returns (uint256) {\\n        (\\n            uint256 finalEmissionRatePerYear,\\n            uint256 finalTotalIntegralSupply,\\n            uint256 finalMigrationTime\\n        ) = _getMigratedIncentiveValues(tokenAddress);\\n\\n        // This if statement should never be true but we return 0 just in case\\n        if (lastClaimTime == 0 || lastClaimTime >= finalMigrationTime) return 0;\\n\\n        // No overflow here, checked above. All incentives are claimed up until finalMigrationTime\\n        // using the finalTotalIntegralSupply. Both these values are set on migration and will not\\n        // change.\\n        uint256 timeSinceMigration = finalMigrationTime - lastClaimTime;\\n\\n        // (timeSinceMigration * INTERNAL_TOKEN_PRECISION * finalEmissionRatePerYear) / YEAR\\n        uint256 incentiveRate =\\n            timeSinceMigration\\n                .mul(uint256(Constants.INTERNAL_TOKEN_PRECISION))\\n                // Migration emission rate is stored as is, denominated in whole tokens\\n                .mul(finalEmissionRatePerYear).mul(uint256(Constants.INTERNAL_TOKEN_PRECISION))\\n                .div(Constants.YEAR);\\n\\n        // Returns the average supply using the integral of the total supply.\\n        uint256 avgTotalSupply = finalTotalIntegralSupply.sub(lastClaimIntegralSupply).div(timeSinceMigration);\\n        if (avgTotalSupply == 0) return 0;\\n\\n        uint256 incentivesToClaim = nTokenBalance.mul(incentiveRate).div(avgTotalSupply);\\n        // incentiveRate has a decimal basis of 1e16 so divide by token precision to reduce to 1e8\\n        incentivesToClaim = incentivesToClaim.div(uint256(Constants.INTERNAL_TOKEN_PRECISION));\\n\\n        return incentivesToClaim;\\n    }\\n\\n    function _getMigratedIncentiveValues(\\n        address tokenAddress\\n    ) private view returns (\\n        uint256 finalEmissionRatePerYear,\\n        uint256 finalTotalIntegralSupply,\\n        uint256 finalMigrationTime\\n    ) {\\n        mapping(address => nTokenTotalSupplyStorage_deprecated) storage store = LibStorage.getDeprecatedNTokenTotalSupplyStorage();\\n        nTokenTotalSupplyStorage_deprecated storage d_nTokenStorage = store[tokenAddress];\\n\\n        // The total supply value is overridden as emissionRatePerYear during the initialization\\n        finalEmissionRatePerYear = d_nTokenStorage.totalSupply;\\n        finalTotalIntegralSupply = d_nTokenStorage.integralTotalSupply;\\n        finalMigrationTime = d_nTokenStorage.lastSupplyChangeTime;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/external/SettleAssetsExternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../internal/portfolio/PortfolioHandler.sol\\\";\\nimport \\\"../internal/balances/BalanceHandler.sol\\\";\\nimport \\\"../internal/settlement/SettlePortfolioAssets.sol\\\";\\nimport \\\"../internal/settlement/SettleBitmapAssets.sol\\\";\\nimport \\\"../internal/AccountContextHandler.sol\\\";\\n\\n/// @notice External library for settling assets\\nlibrary SettleAssetsExternal {\\n    using PortfolioHandler for PortfolioState;\\n    using AccountContextHandler for AccountContext;\\n    event AccountSettled(address indexed account);\\n\\n    /// @notice Settles an account, returns the new account context object after settlement.\\n    /// @dev The memory location of the account context object is not the same as the one returned.\\n    function settleAccount(\\n        address account,\\n        AccountContext memory accountContext\\n    ) external returns (AccountContext memory) {\\n        // Defensive check to ensure that this is a valid settlement\\n        require(accountContext.mustSettleAssets());\\n        SettleAmount[] memory settleAmounts;\\n        PortfolioState memory portfolioState;\\n\\n        if (accountContext.isBitmapEnabled()) {\\n            (int256 settledCash, uint256 blockTimeUTC0) =\\n                SettleBitmapAssets.settleBitmappedCashGroup(\\n                    account,\\n                    accountContext.bitmapCurrencyId,\\n                    accountContext.nextSettleTime,\\n                    block.timestamp\\n                );\\n            require(blockTimeUTC0 < type(uint40).max); // dev: block time utc0 overflow\\n            accountContext.nextSettleTime = uint40(blockTimeUTC0);\\n\\n            settleAmounts = new SettleAmount[](1);\\n            settleAmounts[0] = SettleAmount(accountContext.bitmapCurrencyId, settledCash);\\n        } else {\\n            portfolioState = PortfolioHandler.buildPortfolioState(\\n                account,\\n                accountContext.assetArrayLength,\\n                0\\n            );\\n            settleAmounts = SettlePortfolioAssets.settlePortfolio(portfolioState, block.timestamp);\\n            accountContext.storeAssetsAndUpdateContext(account, portfolioState, false);\\n        }\\n\\n        BalanceHandler.finalizeSettleAmounts(account, accountContext, settleAmounts);\\n\\n        emit AccountSettled(account);\\n\\n        return accountContext;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/global/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >=0.7.6;\\n\\n/// @title All shared constants for the Notional system should be declared here.\\nlibrary Constants {\\n    uint8 internal constant CETH_DECIMAL_PLACES = 8;\\n\\n    // Token precision used for all internal balances, TokenHandler library ensures that we\\n    // limit the dust amount caused by precision mismatches\\n    int256 internal constant INTERNAL_TOKEN_PRECISION = 1e8;\\n    uint256 internal constant INCENTIVE_ACCUMULATION_PRECISION = 1e18;\\n\\n    // ETH will be initialized as the first currency\\n    uint256 internal constant ETH_CURRENCY_ID = 1;\\n    uint8 internal constant ETH_DECIMAL_PLACES = 18;\\n    int256 internal constant ETH_DECIMALS = 1e18;\\n    // Used to prevent overflow when converting decimal places to decimal precision values via\\n    // 10**decimalPlaces. This is a safe value for int256 and uint256 variables. We apply this\\n    // constraint when storing decimal places in governance.\\n    uint256 internal constant MAX_DECIMAL_PLACES = 36;\\n\\n    // Address of the reserve account\\n    address internal constant RESERVE = address(0);\\n\\n    // Most significant bit\\n    bytes32 internal constant MSB =\\n        0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n    // Each bit set in this mask marks where an active market should be in the bitmap\\n    // if the first bit refers to the reference time. Used to detect idiosyncratic\\n    // fcash in the nToken accounts\\n    bytes32 internal constant ACTIVE_MARKETS_MASK = (\\n        MSB >> ( 90 - 1) | // 3 month\\n        MSB >> (105 - 1) | // 6 month\\n        MSB >> (135 - 1) | // 1 year\\n        MSB >> (147 - 1) | // 2 year\\n        MSB >> (183 - 1) | // 5 year\\n        MSB >> (211 - 1) | // 10 year\\n        MSB >> (251 - 1)   // 20 year\\n    );\\n\\n    // Basis for percentages\\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\\n    // Max number of traded markets, also used as the maximum number of assets in a portfolio array\\n    uint256 internal constant MAX_TRADED_MARKET_INDEX = 7;\\n    // Max number of fCash assets in a bitmap, this is based on the gas costs of calculating free collateral\\n    // for a bitmap portfolio\\n    uint256 internal constant MAX_BITMAP_ASSETS = 20;\\n    uint256 internal constant FIVE_MINUTES = 300;\\n\\n    // Internal date representations, note we use a 6/30/360 week/month/year convention here\\n    uint256 internal constant DAY = 86400;\\n    // We use six day weeks to ensure that all time references divide evenly\\n    uint256 internal constant WEEK = DAY * 6;\\n    uint256 internal constant MONTH = WEEK * 5;\\n    uint256 internal constant QUARTER = MONTH * 3;\\n    uint256 internal constant YEAR = QUARTER * 4;\\n    \\n    // These constants are used in DateTime.sol\\n    uint256 internal constant DAYS_IN_WEEK = 6;\\n    uint256 internal constant DAYS_IN_MONTH = 30;\\n    uint256 internal constant DAYS_IN_QUARTER = 90;\\n\\n    // Offsets for each time chunk denominated in days\\n    uint256 internal constant MAX_DAY_OFFSET = 90;\\n    uint256 internal constant MAX_WEEK_OFFSET = 360;\\n    uint256 internal constant MAX_MONTH_OFFSET = 2160;\\n    uint256 internal constant MAX_QUARTER_OFFSET = 7650;\\n\\n    // Offsets for each time chunk denominated in bits\\n    uint256 internal constant WEEK_BIT_OFFSET = 90;\\n    uint256 internal constant MONTH_BIT_OFFSET = 135;\\n    uint256 internal constant QUARTER_BIT_OFFSET = 195;\\n\\n    // This is a constant that represents the time period that all rates are normalized by, 360 days\\n    uint256 internal constant IMPLIED_RATE_TIME = 360 * DAY;\\n    // Number of decimal places that rates are stored in, equals 100%\\n    int256 internal constant RATE_PRECISION = 1e9;\\n    // One basis point in RATE_PRECISION terms\\n    uint256 internal constant BASIS_POINT = uint256(RATE_PRECISION / 10000);\\n    // Used to when calculating the amount to deleverage of a market when minting nTokens\\n    uint256 internal constant DELEVERAGE_BUFFER = 300 * BASIS_POINT;\\n    // Used for scaling cash group factors\\n    uint256 internal constant FIVE_BASIS_POINTS = 5 * BASIS_POINT;\\n    // Used for residual purchase incentive and cash withholding buffer\\n    uint256 internal constant TEN_BASIS_POINTS = 10 * BASIS_POINT;\\n\\n    // This is the ABDK64x64 representation of RATE_PRECISION\\n    // RATE_PRECISION_64x64 = ABDKMath64x64.fromUint(RATE_PRECISION)\\n    int128 internal constant RATE_PRECISION_64x64 = 0x3b9aca000000000000000000;\\n    int128 internal constant LOG_RATE_PRECISION_64x64 = 382276781265598821176;\\n    // Limit the market proportion so that borrowing cannot hit extremely high interest rates\\n    int256 internal constant MAX_MARKET_PROPORTION = RATE_PRECISION * 99 / 100;\\n\\n    uint8 internal constant FCASH_ASSET_TYPE = 1;\\n    // Liquidity token asset types are 1 + marketIndex (where marketIndex is 1-indexed)\\n    uint8 internal constant MIN_LIQUIDITY_TOKEN_INDEX = 2;\\n    uint8 internal constant MAX_LIQUIDITY_TOKEN_INDEX = 8;\\n\\n    // Used for converting bool to bytes1, solidity does not have a native conversion\\n    // method for this\\n    bytes1 internal constant BOOL_FALSE = 0x00;\\n    bytes1 internal constant BOOL_TRUE = 0x01;\\n\\n    // Account context flags\\n    bytes1 internal constant HAS_ASSET_DEBT = 0x01;\\n    bytes1 internal constant HAS_CASH_DEBT = 0x02;\\n    bytes2 internal constant ACTIVE_IN_PORTFOLIO = 0x8000;\\n    bytes2 internal constant ACTIVE_IN_BALANCES = 0x4000;\\n    bytes2 internal constant UNMASK_FLAGS = 0x3FFF;\\n    uint16 internal constant MAX_CURRENCIES = uint16(UNMASK_FLAGS);\\n\\n    // Equal to 100% of all deposit amounts for nToken liquidity across fCash markets.\\n    int256 internal constant DEPOSIT_PERCENT_BASIS = 1e8;\\n\\n    // nToken Parameters: there are offsets in the nTokenParameters bytes6 variable returned\\n    // in nTokenHandler. Each constant represents a position in the byte array.\\n    uint8 internal constant LIQUIDATION_HAIRCUT_PERCENTAGE = 0;\\n    uint8 internal constant CASH_WITHHOLDING_BUFFER = 1;\\n    uint8 internal constant RESIDUAL_PURCHASE_TIME_BUFFER = 2;\\n    uint8 internal constant PV_HAIRCUT_PERCENTAGE = 3;\\n    uint8 internal constant RESIDUAL_PURCHASE_INCENTIVE = 4;\\n    uint8 internal constant MAX_MINT_DEVIATION_LIMIT = 5;\\n\\n    // Liquidation parameters\\n    // Default percentage of collateral that a liquidator is allowed to liquidate, will be higher if the account\\n    // requires more collateral to be liquidated\\n    int256 internal constant DEFAULT_LIQUIDATION_PORTION = 40;\\n    // Percentage of local liquidity token cash claim delivered to the liquidator for liquidating liquidity tokens\\n    int256 internal constant TOKEN_REPO_INCENTIVE_PERCENT = 30;\\n\\n    // Pause Router liquidation enabled states\\n    bytes1 internal constant LOCAL_CURRENCY_ENABLED = 0x01;\\n    bytes1 internal constant COLLATERAL_CURRENCY_ENABLED = 0x02;\\n    bytes1 internal constant LOCAL_FCASH_ENABLED = 0x04;\\n    bytes1 internal constant CROSS_CURRENCY_FCASH_ENABLED = 0x08;\\n\\n    // Requires vault accounts to enter a position for a minimum of 5 blocks (approx 1 min)\\n    // to mitigate strange behavior where accounts may enter and exit using flash loans or other\\n    // MEV type behavior.\\n    uint256 internal constant VAULT_ACCOUNT_MIN_BLOCKS = 5;\\n}\\n\"\r\n    },\r\n    \"contracts/global/Deployments.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >=0.7.6;\\n\\n/// @title Hardcoded deployed contracts are listed here. These are hardcoded to reduce\\n/// gas costs for immutable addresses. They must be updated per environment that Notional\\n/// is deployed to.\\nlibrary Deployments {\\n    address internal constant NOTE_TOKEN_ADDRESS = 0xCFEAead4947f0705A14ec42aC3D44129E1Ef3eD5;\\n}\\n\"\r\n    },\r\n    \"contracts/global/LibStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./Types.sol\\\";\\nimport \\\"./Constants.sol\\\";\\nimport \\\"../../interfaces/notional/IRewarder.sol\\\";\\nimport \\\"../../interfaces/aave/ILendingPool.sol\\\";\\n\\nlibrary LibStorage {\\n\\n    /// @dev Offset for the initial slot in lib storage, gives us this number of storage slots\\n    /// available in StorageLayoutV1 and all subsequent storage layouts that inherit from it.\\n    uint256 private constant STORAGE_SLOT_BASE = 1000000;\\n    /// @dev Set to MAX_TRADED_MARKET_INDEX * 2, Solidity does not allow assigning constants from imported values\\n    uint256 private constant NUM_NTOKEN_MARKET_FACTORS = 14;\\n    /// @dev Theoretical maximum for MAX_PORTFOLIO_ASSETS, however, we limit this to MAX_TRADED_MARKET_INDEX\\n    /// in practice. It is possible to exceed that value during liquidation up to 14 potential assets.\\n    uint256 private constant MAX_PORTFOLIO_ASSETS = 16;\\n\\n    /// @dev Storage IDs for storage buckets. Each id maps to an internal storage\\n    /// slot used for a particular mapping\\n    ///     WARNING: APPEND ONLY\\n    enum StorageId {\\n        Unused,\\n        AccountStorage,\\n        nTokenContext,\\n        nTokenAddress,\\n        nTokenDeposit,\\n        nTokenInitialization,\\n        Balance,\\n        Token,\\n        SettlementRate,\\n        CashGroup,\\n        Market,\\n        AssetsBitmap,\\n        ifCashBitmap,\\n        PortfolioArray,\\n        // WARNING: this nTokenTotalSupply storage object was used for a buggy version\\n        // of the incentives calculation. It should only be used for accounts who have\\n        // not claimed before the migration\\n        nTokenTotalSupply_deprecated,\\n        AssetRate,\\n        ExchangeRate,\\n        nTokenTotalSupply,\\n        SecondaryIncentiveRewarder,\\n        LendingPool,\\n        VaultConfig,\\n        VaultState,\\n        VaultAccount,\\n        VaultBorrowCapacity,\\n        VaultSecondaryBorrow,\\n        VaultSettledAssets,\\n        VaultAccountSecondaryDebtShare\\n    }\\n\\n    /// @dev Mapping from an account address to account context\\n    function getAccountStorage() internal pure \\n        returns (mapping(address => AccountContext) storage store) \\n    {\\n        uint256 slot = _getStorageSlot(StorageId.AccountStorage);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from an nToken address to nTokenContext\\n    function getNTokenContextStorage() internal pure\\n        returns (mapping(address => nTokenContext) storage store) \\n    {\\n        uint256 slot = _getStorageSlot(StorageId.nTokenContext);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from currency id to nTokenAddress\\n    function getNTokenAddressStorage() internal pure\\n        returns (mapping(uint256 => address) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.nTokenAddress);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from currency id to uint32 fixed length array of\\n    /// deposit factors. Deposit shares and leverage thresholds are stored striped to\\n    /// reduce the number of storage reads.\\n    function getNTokenDepositStorage() internal pure\\n        returns (mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.nTokenDeposit);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from currency id to fixed length array of initialization factors,\\n    /// stored striped like deposit shares.\\n    function getNTokenInitStorage() internal pure\\n        returns (mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.nTokenInitialization);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from account to currencyId to it's balance storage for that currency\\n    function getBalanceStorage() internal pure\\n        returns (mapping(address => mapping(uint256 => BalanceStorage)) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.Balance);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from currency id to a boolean for underlying or asset token to\\n    /// the TokenStorage\\n    function getTokenStorage() internal pure\\n        returns (mapping(uint256 => mapping(bool => TokenStorage)) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.Token);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from currency id to maturity to its corresponding SettlementRate\\n    function getSettlementRateStorage() internal pure\\n        returns (mapping(uint256 => mapping(uint256 => SettlementRateStorage)) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.SettlementRate);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from currency id to maturity to its tightly packed cash group parameters\\n    function getCashGroupStorage() internal pure\\n        returns (mapping(uint256 => bytes32) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.CashGroup);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from currency id to maturity to settlement date for a market\\n    function getMarketStorage() internal pure\\n        returns (mapping(uint256 => mapping(uint256 => mapping(uint256 => MarketStorage))) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.Market);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from account to currency id to its assets bitmap\\n    function getAssetsBitmapStorage() internal pure\\n        returns (mapping(address => mapping(uint256 => bytes32)) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.AssetsBitmap);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from account to currency id to its maturity to its corresponding ifCash balance\\n    function getifCashBitmapStorage() internal pure\\n        returns (mapping(address => mapping(uint256 => mapping(uint256 => ifCashStorage))) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.ifCashBitmap);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from account to its fixed length array of portfolio assets\\n    function getPortfolioArrayStorage() internal pure\\n        returns (mapping(address => PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS]) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.PortfolioArray);\\n        assembly { store.slot := slot }\\n    }\\n\\n    function getDeprecatedNTokenTotalSupplyStorage() internal pure\\n        returns (mapping(address => nTokenTotalSupplyStorage_deprecated) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.nTokenTotalSupply_deprecated);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from nToken address to its total supply values\\n    function getNTokenTotalSupplyStorage() internal pure\\n        returns (mapping(address => nTokenTotalSupplyStorage) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.nTokenTotalSupply);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns the exchange rate between an underlying currency and asset for trading\\n    /// and free collateral. Mapping is from currency id to rate storage object.\\n    function getAssetRateStorage() internal pure\\n        returns (mapping(uint256 => AssetRateStorage) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.AssetRate);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns the exchange rate between an underlying currency and ETH for free\\n    /// collateral purposes. Mapping is from currency id to rate storage object.\\n    function getExchangeRateStorage() internal pure\\n        returns (mapping(uint256 => ETHRateStorage) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.ExchangeRate);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns the address of a secondary incentive rewarder for an nToken if it exists\\n    function getSecondaryIncentiveRewarder() internal pure\\n        returns (mapping(address => IRewarder) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.SecondaryIncentiveRewarder);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns the address of the lending pool\\n    function getLendingPool() internal pure returns (LendingPoolStorage storage store) {\\n        uint256 slot = _getStorageSlot(StorageId.LendingPool);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns object for an VaultConfig, mapping is from vault address to VaultConfig object\\n    function getVaultConfig() internal pure returns (\\n        mapping(address => VaultConfigStorage) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.VaultConfig);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns object for an VaultState, mapping is from vault address to maturity to VaultState object\\n    function getVaultState() internal pure returns (\\n        mapping(address => mapping(uint256 => VaultStateStorage)) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.VaultState);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns object for an VaultAccount, mapping is from account address to vault address to VaultAccount object\\n    function getVaultAccount() internal pure returns (\\n        mapping(address => mapping(address => VaultAccountStorage)) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.VaultAccount);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns object for a VaultBorrowCapacity, mapping is from vault address to currency to BorrowCapacity object\\n    function getVaultBorrowCapacity() internal pure returns (\\n        mapping(address => mapping(uint256 => VaultBorrowCapacityStorage)) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.VaultBorrowCapacity);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns object for an VaultAccount, mapping is from account address to vault address to maturity to\\n    /// currencyId to VaultSecondaryBorrowStorage object\\n    function getVaultSecondaryBorrow() internal pure returns (\\n        mapping(address => mapping(uint256 => mapping(uint256 => VaultSecondaryBorrowStorage))) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.VaultSecondaryBorrow);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns object for an VaultAccount, mapping is from account address to vault address to maturity to\\n    /// VaultSettledAssetsStorage object\\n    function getVaultSettledAssets() internal pure returns (\\n        mapping(address => mapping(uint256 => VaultSettledAssetsStorage)) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.VaultSettledAssets);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns object for an VaultAccount, mapping is from account address to vault address\\n    function getVaultAccountSecondaryDebtShare() internal pure returns (\\n        mapping(address => mapping(address => VaultAccountSecondaryDebtShareStorage)) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.VaultAccountSecondaryDebtShare);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Get the storage slot given a storage ID.\\n    /// @param storageId An entry in `StorageId`\\n    /// @return slot The storage slot.\\n    function _getStorageSlot(StorageId storageId)\\n        private\\n        pure\\n        returns (uint256 slot)\\n    {\\n        // This should never overflow with a reasonable `STORAGE_SLOT_EXP`\\n        // because Solidity will do a range check on `storageId` during the cast.\\n        return uint256(storageId) + STORAGE_SLOT_BASE;\\n    }\\n} \"\r\n    },\r\n    \"contracts/global/StorageLayoutV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./Types.sol\\\";\\n\\n/**\\n * @notice Storage layout for the system. Do not change this file once deployed, future storage\\n * layouts must inherit this and increment the version number.\\n */\\ncontract StorageLayoutV1 {\\n    // The current maximum currency id\\n    uint16 internal maxCurrencyId;\\n    // Sets the state of liquidations being enabled during a paused state. Each of the four lower\\n    // bits can be turned on to represent one of the liquidation types being enabled.\\n    bytes1 internal liquidationEnabledState;\\n    // Set to true once the system has been initialized\\n    bool internal hasInitialized;\\n\\n    /* Authentication Mappings */\\n    // This is set to the timelock contract to execute governance functions\\n    address public owner;\\n    // This is set to an address of a router that can only call governance actions\\n    address public pauseRouter;\\n    // This is set to an address of a router that can only call governance actions\\n    address public pauseGuardian;\\n    // On upgrades this is set in the case that the pause router is used to pass the rollback check\\n    address internal rollbackRouterImplementation;\\n\\n    // A blanket allowance for a spender to transfer any of an account's nTokens. This would allow a user\\n    // to set an allowance on all nTokens for a particular integrating contract system.\\n    // owner => spender => transferAllowance\\n    mapping(address => mapping(address => uint256)) internal nTokenWhitelist;\\n    // Individual transfer allowances for nTokens used for ERC20\\n    // owner => spender => currencyId => transferAllowance\\n    mapping(address => mapping(address => mapping(uint16 => uint256))) internal nTokenAllowance;\\n\\n    // Transfer operators\\n    // Mapping from a global ERC1155 transfer operator contract to an approval value for it\\n    mapping(address => bool) internal globalTransferOperator;\\n    // Mapping from an account => operator => approval status for that operator. This is a specific\\n    // approval between two addresses for ERC1155 transfers.\\n    mapping(address => mapping(address => bool)) internal accountAuthorizedTransferOperator;\\n    // Approval for a specific contract to use the `batchBalanceAndTradeActionWithCallback` method in\\n    // BatchAction.sol, can only be set by governance\\n    mapping(address => bool) internal authorizedCallbackContract;\\n\\n    // Reverse mapping from token addresses to currency ids, only used for referencing in views\\n    // and checking for duplicate token listings.\\n    mapping(address => uint16) internal tokenAddressToCurrencyId;\\n\\n    // Reentrancy guard\\n    uint256 internal reentrancyStatus;\\n}\\n\"\r\n    },\r\n    \"contracts/global/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >=0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../../interfaces/chainlink/AggregatorV2V3Interface.sol\\\";\\nimport \\\"../../interfaces/notional/AssetRateAdapter.sol\\\";\\n\\n/// @notice Different types of internal tokens\\n///  - UnderlyingToken: underlying asset for a cToken (except for Ether)\\n///  - cToken: Compound interest bearing token\\n///  - cETH: Special handling for cETH tokens\\n///  - Ether: the one and only\\n///  - NonMintable: tokens that do not have an underlying (therefore not cTokens)\\n///  - aToken: Aave interest bearing tokens\\nenum TokenType {\\n    UnderlyingToken,\\n    cToken,\\n    cETH,\\n    Ether,\\n    NonMintable,\\n    aToken\\n}\\n\\n/// @notice Specifies the different trade action types in the system. Each trade action type is\\n/// encoded in a tightly packed bytes32 object. Trade action type is the first big endian byte of the\\n/// 32 byte trade action object. The schemas for each trade action type are defined below.\\nenum TradeActionType {\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 fCashAmount, uint32 minImpliedRate, uint120 unused)\\n    Lend,\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 fCashAmount, uint32 maxImpliedRate, uint128 unused)\\n    Borrow,\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 assetCashAmount, uint32 minImpliedRate, uint32 maxImpliedRate, uint88 unused)\\n    AddLiquidity,\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 tokenAmount, uint32 minImpliedRate, uint32 maxImpliedRate, uint88 unused)\\n    RemoveLiquidity,\\n    // (uint8 TradeActionType, uint32 Maturity, int88 fCashResidualAmount, uint128 unused)\\n    PurchaseNTokenResidual,\\n    // (uint8 TradeActionType, address CounterpartyAddress, int88 fCashAmountToSettle)\\n    SettleCashDebt\\n}\\n\\n/// @notice Specifies different deposit actions that can occur during BalanceAction or BalanceActionWithTrades\\nenum DepositActionType {\\n    // No deposit action\\n    None,\\n    // Deposit asset cash, depositActionAmount is specified in asset cash external precision\\n    DepositAsset,\\n    // Deposit underlying tokens that are mintable to asset cash, depositActionAmount is specified in underlying token\\n    // external precision\\n    DepositUnderlying,\\n    // Deposits specified asset cash external precision amount into an nToken and mints the corresponding amount of\\n    // nTokens into the account\\n    DepositAssetAndMintNToken,\\n    // Deposits specified underlying in external precision, mints asset cash, and uses that asset cash to mint nTokens\\n    DepositUnderlyingAndMintNToken,\\n    // Redeems an nToken balance to asset cash. depositActionAmount is specified in nToken precision. Considered a deposit action\\n    // because it deposits asset cash into an account. If there are fCash residuals that cannot be sold off, will revert.\\n    RedeemNToken,\\n    // Converts specified amount of asset cash balance already in Notional to nTokens. depositActionAmount is specified in\\n    // Notional internal 8 decimal precision.\\n    ConvertCashToNToken\\n}\\n\\n/// @notice Used internally for PortfolioHandler state\\nenum AssetStorageState {\\n    NoChange,\\n    Update,\\n    Delete,\\n    RevertIfStored\\n}\\n\\n/****** Calldata objects ******/\\n\\n/// @notice Defines a batch lending action\\nstruct BatchLend {\\n    uint16 currencyId;\\n    // True if the contract should try to transfer underlying tokens instead of asset tokens\\n    bool depositUnderlying;\\n    // Array of tightly packed 32 byte objects that represent trades. See TradeActionType documentation\\n    bytes32[] trades;\\n}\\n\\n/// @notice Defines a balance action for batchAction\\nstruct BalanceAction {\\n    // Deposit action to take (if any)\\n    DepositActionType actionType;\\n    uint16 currencyId;\\n    // Deposit action amount must correspond to the depositActionType, see documentation above.\\n    uint256 depositActionAmount;\\n    // Withdraw an amount of asset cash specified in Notional internal 8 decimal precision\\n    uint256 withdrawAmountInternalPrecision;\\n    // If set to true, will withdraw entire cash balance. Useful if there may be an unknown amount of asset cash\\n    // residual left from trading.\\n    bool withdrawEntireCashBalance;\\n    // If set to true, will redeem asset cash to the underlying token on withdraw.\\n    bool redeemToUnderlying;\\n}\\n\\n/// @notice Defines a balance action with a set of trades to do as well\\nstruct BalanceActionWithTrades {\\n    DepositActionType actionType;\\n    uint16 currencyId;\\n    uint256 depositActionAmount;\\n    uint256 withdrawAmountInternalPrecision;\\n    bool withdrawEntireCashBalance;\\n    bool redeemToUnderlying;\\n    // Array of tightly packed 32 byte objects that represent trades. See TradeActionType documentation\\n    bytes32[] trades;\\n}\\n\\n/****** In memory objects ******/\\n/// @notice Internal object that represents settled cash balances\\nstruct SettleAmount {\\n    uint256 currencyId;\\n    int256 netCashChange;\\n}\\n\\n/// @notice Internal object that represents a token\\nstruct Token {\\n    address tokenAddress;\\n    bool hasTransferFee;\\n    int256 decimals;\\n    TokenType tokenType;\\n    uint256 maxCollateralBalance;\\n}\\n\\n/// @notice Internal object that represents an nToken portfolio\\nstruct nTokenPortfolio {\\n    CashGroupParameters cashGroup;\\n    PortfolioState portfolioState;\\n    int256 totalSupply;\\n    int256 cashBalance;\\n    uint256 lastInitializedTime;\\n    bytes6 parameters;\\n    address tokenAddress;\\n}\\n\\n/// @notice Internal object used during liquidation\\nstruct LiquidationFactors {\\n    address account;\\n    // Aggregate free collateral of the account denominated in ETH underlying, 8 decimal precision\\n    int256 netETHValue;\\n    // Amount of net local currency asset cash before haircuts and buffers available\\n    int256 localAssetAvailable;\\n    // Amount of net collateral currency asset cash before haircuts and buffers available\\n    int256 collateralAssetAvailable;\\n    // Haircut value of nToken holdings denominated in asset cash, will be local or collateral nTokens based\\n    // on liquidation type\\n    int256 nTokenHaircutAssetValue;\\n    // nToken parameters for calculating liquidation amount\\n    bytes6 nTokenParameters;\\n    // ETH exchange rate from local currency to ETH\\n    ETHRate localETHRate;\\n    // ETH exchange rate from collateral currency to ETH\\n    ETHRate collateralETHRate;\\n    // Asset rate for the local currency, used in cross currency calculations to calculate local asset cash required\\n    AssetRateParameters localAssetRate;\\n    // Used during currency liquidations if the account has liquidity tokens\\n    CashGroupParameters collateralCashGroup;\\n    // Used during currency liquidations if it is only a calculation, defaults to false\\n    bool isCalculation;\\n}\\n\\n/// @notice Internal asset array portfolio state\\nstruct PortfolioState {\\n    // Array of currently stored assets\\n    PortfolioAsset[] storedAssets;\\n    // Array of new assets to add\\n    PortfolioAsset[] newAssets;\\n    uint256 lastNewAssetIndex;\\n    // Holds the length of stored assets after accounting for deleted assets\\n    uint256 storedAssetLength;\\n}\\n\\n/// @notice In memory ETH exchange rate used during free collateral calculation.\\nstruct ETHRate {\\n    // The decimals (i.e. 10^rateDecimalPlaces) of the exchange rate, defined by the rate oracle\\n    int256 rateDecimals;\\n    // The exchange rate from base to ETH (if rate invert is required it is already done)\\n    int256 rate;\\n    // Amount of buffer as a multiple with a basis of 100 applied to negative balances.\\n    int256 buffer;\\n    // Amount of haircut as a multiple with a basis of 100 applied to positive balances\\n    int256 haircut;\\n    // Liquidation discount as a multiple with a basis of 100 applied to the exchange rate\\n    // as an incentive given to liquidators.\\n    int256 liquidationDiscount;\\n}\\n\\n/// @notice Internal object used to handle balance state during a transaction\\nstruct BalanceState {\\n    uint16 currencyId;\\n    // Cash balance stored in balance state at the beginning of the transaction\\n    int256 storedCashBalance;\\n    // nToken balance stored at the beginning of the transaction\\n    int256 storedNTokenBalance;\\n    // The net cash change as a result of asset settlement or trading\\n    int256 netCashChange;\\n    // Net asset transfers into or out of the account\\n    int256 netAssetTransferInternalPrecision;\\n    // Net token transfers into or out of the account\\n    int256 netNTokenTransfer;\\n    // Net token supply change from minting or redeeming\\n    int256 netNTokenSupplyChange;\\n    // The last time incentives were claimed for this currency\\n    uint256 lastClaimTime;\\n    // Accumulator for incentives that the account no longer has a claim over\\n    uint256 accountIncentiveDebt;\\n}\\n\\n/// @dev Asset rate used to convert between underlying cash and asset cash\\nstruct AssetRateParameters {\\n    // Address of the asset rate oracle\\n    AssetRateAdapter rateOracle;\\n    // The exchange rate from base to quote (if invert is required it is already done)\\n    int256 rate;\\n    // The decimals of the underlying, the rate converts to the underlying decimals\\n    int256 underlyingDecimals;\\n}\\n\\n/// @dev Cash group when loaded into memory\\nstruct CashGroupParameters {\\n    uint16 currencyId;\\n    uint256 maxMarketIndex;\\n    AssetRateParameters assetRate;\\n    bytes32 data;\\n}\\n\\n/// @dev A portfolio asset when loaded in memory\\nstruct PortfolioAsset {\\n    // Asset currency id\\n    uint256 currencyId;\\n    uint256 maturity;\\n    // Asset type, fCash or liquidity token.\\n    uint256 assetType;\\n    // fCash amount or liquidity token amount\\n    int256 notional;\\n    // Used for managing portfolio asset state\\n    uint256 storageSlot;\\n    // The state of the asset for when it is written to storage\\n    AssetStorageState storageState;\\n}\\n\\n/// @dev Market object as represented in memory\\nstruct MarketParameters {\\n    bytes32 storageSlot;\\n    uint256 maturity;\\n    // Total amount of fCash available for purchase in the market.\\n    int256 totalfCash;\\n    // Total amount of cash available for purchase in the market.\\n    int256 totalAssetCash;\\n    // Total amount of liquidity tokens (representing a claim on liquidity) in the market.\\n    int256 totalLiquidity;\\n    // This is the previous annualized interest rate in RATE_PRECISION that the market traded\\n    // at. This is used to calculate the rate anchor to smooth interest rates over time.\\n    uint256 lastImpliedRate;\\n    // Time lagged version of lastImpliedRate, used to value fCash assets at market rates while\\n    // remaining resistent to flash loan attacks.\\n    uint256 oracleRate;\\n    // This is the timestamp of the previous trade\\n    uint256 previousTradeTime;\\n}\\n\\n/****** Storage objects ******/\\n\\n/// @dev Token object in storage:\\n///  20 bytes for token address\\n///  1 byte for hasTransferFee\\n///  1 byte for tokenType\\n///  1 byte for tokenDecimals\\n///  9 bytes for maxCollateralBalance (may not always be set)\\nstruct TokenStorage {\\n    // Address of the token\\n    address tokenAddress;\\n    // Transfer fees will change token deposit behavior\\n    bool hasTransferFee;\\n    TokenType tokenType;\\n    uint8 decimalPlaces;\\n    // Upper limit on how much of this token the contract can hold at any time\\n    uint72 maxCollateralBalance;\\n}\\n\\n/// @dev Exchange rate object as it is represented in storage, total storage is 25 bytes.\\nstruct ETHRateStorage {\\n    // Address of the rate oracle\\n    AggregatorV2V3Interface rateOracle;\\n    // The decimal places of precision that the rate oracle uses\\n    uint8 rateDecimalPlaces;\\n    // True of the exchange rate must be inverted\\n    bool mustInvert;\\n    // NOTE: both of these governance values are set with BUFFER_DECIMALS precision\\n    // Amount of buffer to apply to the exchange rate for negative balances.\\n    uint8 buffer;\\n    // Amount of haircut to apply to the exchange rate for positive balances\\n    uint8 haircut;\\n    // Liquidation discount in percentage point terms, 106 means a 6% discount\\n    uint8 liquidationDiscount;\\n}\\n\\n/// @dev Asset rate oracle object as it is represented in storage, total storage is 21 bytes.\\nstruct AssetRateStorage {\\n    // Address of the rate oracle\\n    AssetRateAdapter rateOracle;\\n    // The decimal places of the underlying asset\\n    uint8 underlyingDecimalPlaces;\\n}\\n\\n/// @dev Governance parameters for a cash group, total storage is 9 bytes + 7 bytes for liquidity token haircuts\\n/// and 7 bytes for rate scalars, total of 23 bytes. Note that this is stored packed in the storage slot so there\\n/// are no indexes stored for liquidityTokenHaircuts or rateScalars, maxMarketIndex is used instead to determine the\\n/// length.\\nstruct CashGroupSettings {\\n    // Index of the AMMs on chain that will be made available. Idiosyncratic fCash\\n    // that is dated less than the longest AMM will be tradable.\\n    uint8 maxMarketIndex;\\n    // Time window in 5 minute increments that the rate oracle will be averaged over\\n    uint8 rateOracleTimeWindow5Min;\\n    // Total fees per trade, specified in BPS\\n    uint8 totalFeeBPS;\\n    // Share of the fees given to the protocol, denominated in percentage\\n    uint8 reserveFeeShare;\\n    // Debt buffer specified in 5 BPS increments\\n    uint8 debtBuffer5BPS;\\n    // fCash haircut specified in 5 BPS increments\\n    uint8 fCashHaircut5BPS;\\n    // If an account has a negative cash balance, it can be settled by incurring debt at the 3 month market. This\\n    // is the basis points for the penalty rate that will be added the current 3 month oracle rate.\\n    uint8 settlementPenaltyRate5BPS;\\n    // If an account has fCash that is being liquidated, this is the discount that the liquidator can purchase it for\\n    uint8 liquidationfCashHaircut5BPS;\\n    // If an account has fCash that is being liquidated, this is the discount that the liquidator can purchase it for\\n    uint8 liquidationDebtBuffer5BPS;\\n    // Liquidity token haircut applied to cash claims, specified as a percentage between 0 and 100\\n    uint8[] liquidityTokenHaircuts;\\n    // Rate scalar used to determine the slippage of the market\\n    uint8[] rateScalars;\\n}\\n\\n/// @dev Holds account level context information used to determine settlement and\\n/// free collateral actions. Total storage is 28 bytes\\nstruct AccountContext {\\n    // Used to check when settlement must be triggered on an account\\n    uint40 nextSettleTime;\\n    // For lenders that never incur debt, we use this flag to skip the free collateral check.\\n    bytes1 hasDebt;\\n    // Length of the account's asset array\\n    uint8 assetArrayLength;\\n    // If this account has bitmaps set, this is the corresponding currency id\\n    uint16 bitmapCurrencyId;\\n    // 9 total active currencies possible (2 bytes each)\\n    bytes18 activeCurrencies;\\n}\\n\\n/// @dev Holds nToken context information mapped via the nToken address, total storage is\\n/// 16 bytes\\nstruct nTokenContext {\\n    // Currency id that the nToken represents\\n    uint16 currencyId;\\n    // Annual incentive emission rate denominated in WHOLE TOKENS (multiply by\\n    // INTERNAL_TOKEN_PRECISION to get the actual rate)\\n    uint32 incentiveAnnualEmissionRate;\\n    // The last block time at utc0 that the nToken was initialized at, zero if it\\n    // has never been initialized\\n    uint32 lastInitializedTime;\\n    // Length of the asset array, refers to the number of liquidity tokens an nToken\\n    // currently holds\\n    uint8 assetArrayLength;\\n    // Each byte is a specific nToken parameter\\n    bytes6 nTokenParameters;\\n    // Reserved bytes for future usage\\n    bytes14 _unused;\\n    // Set to true if a secondary rewarder is set\\n    bool hasSecondaryRewarder;\\n}\\n\\n/// @dev Holds account balance information, total storage 32 bytes\\nstruct BalanceStorage {\\n    // Number of nTokens held by the account\\n    uint80 nTokenBalance;\\n    // Last time the account claimed their nTokens\\n    uint32 lastClaimTime;\\n    // Incentives that the account no longer has a claim over\\n    uint56 accountIncentiveDebt;\\n    // Cash balance of the account\\n    int88 cashBalance;\\n}\\n\\n/// @dev Holds information about a settlement rate, total storage 25 bytes\\nstruct SettlementRateStorage {\\n    uint40 blockTime;\\n    uint128 settlementRate;\\n    uint8 underlyingDecimalPlaces;\\n}\\n\\n/// @dev Holds information about a market, total storage is 42 bytes so this spans\\n/// two storage words\\nstruct MarketStorage {\\n    // Total fCash in the market\\n    uint80 totalfCash;\\n    // Total asset cash in the market\\n    uint80 totalAssetCash;\\n    // Last annualized interest rate the market traded at\\n    uint32 lastImpliedRate;\\n    // Last recorded oracle rate for the market\\n    uint32 oracleRate;\\n    // Last time a trade was made\\n    uint32 previousTradeTime;\\n    // This is stored in slot + 1\\n    uint80 totalLiquidity;\\n}\\n\\nstruct ifCashStorage {\\n    // Notional amount of fCash at the slot, limited to int128 to allow for\\n    // future expansion\\n    int128 notional;\\n}\\n\\n/// @dev A single portfolio asset in storage, total storage of 19 bytes\\nstruct PortfolioAssetStorage {\\n    // Currency Id for the asset\\n    uint16 currencyId;\\n    // Maturity of the asset\\n    uint40 maturity;\\n    // Asset type (fCash or Liquidity Token marker)\\n    uint8 assetType;\\n    // Notional\\n    int88 notional;\\n}\\n\\n/// @dev nToken total supply factors for the nToken, includes factors related\\n/// to claiming incentives, total storage 32 bytes. This is the deprecated version\\nstruct nTokenTotalSupplyStorage_deprecated {\\n    // Total supply of the nToken\\n    uint96 totalSupply;\\n    // Integral of the total supply used for calculating the average total supply\\n    uint128 integralTotalSupply;\\n    // Last timestamp the supply value changed, used for calculating the integralTotalSupply\\n    uint32 lastSupplyChangeTime;\\n}\\n\\n/// @dev nToken total supply factors for the nToken, includes factors related\\n/// to claiming incentives, total storage 32 bytes.\\nstruct nTokenTotalSupplyStorage {\\n    // Total supply of the nToken\\n    uint96 totalSupply;\\n    // How many NOTE incentives should be issued per nToken in 1e18 precision\\n    uint128 accumulatedNOTEPerNToken;\\n    // Last timestamp when the accumulation happened\\n    uint32 lastAccumulatedTime;\\n}\\n\\n/// @dev Used in view methods to return account balances in a developer friendly manner\\nstruct AccountBalance {\\n    uint16 currencyId;\\n    int256 cashBalance;\\n    int256 nTokenBalance;\\n    uint256 lastClaimTime;\\n    uint256 accountIncentiveDebt;\\n}\\n\\nstruct VaultConfigStorage {\\n    // Vault Flags (documented in VaultConfiguration.sol)\\n    uint16 flags;\\n    // Primary currency the vault borrows in\\n    uint16 borrowCurrencyId;\\n    // Specified in whole tokens in 1e8 precision, allows a 4.2 billion min borrow size\\n    uint32 minAccountBorrowSize;\\n    // Minimum collateral ratio for a vault specified in basis points, valid values are greater than 10_000\\n    // where the largest minimum collateral ratio is 65_536 which is much higher than anything reasonable.\\n    uint16 minCollateralRatioBPS;\\n    // Allows up to a 12.75% annualized fee\\n    uint8 feeRate5BPS;\\n    // A percentage that represents the share of the cash raised that will go to the liquidator\\n    uint8 liquidationRate;\\n    // A percentage of the fee given to the protocol\\n    uint8 reserveFeeShare;\\n    // Maximum market index where a vault can borrow from\\n    uint8 maxBorrowMarketIndex;\\n    // Maximum collateral ratio that a liquidator can push a an account to during deleveraging\\n    uint16 maxDeleverageCollateralRatioBPS;\\n    // An optional list of secondary borrow currencies\\n    uint16[2] secondaryBorrowCurrencies;\\n    // Required collateral ratio for accounts to stay inside a vault, prevents accounts\\n    // from \\\"free riding\\\" on vaults. Enforced on entry and exit, not on deleverage.\\n    uint16 maxRequiredAccountCollateralRatioBPS;\\n    // 80 bytes left\\n}\\n\\nstruct VaultBorrowCapacityStorage {\\n    // Total fCash across all maturities that caps the borrow capacity\\n    uint80 maxBorrowCapacity;\\n    // Current usage of that total borrow capacity\\n    uint80 totalUsedBorrowCapacity;\\n}\\n\\nstruct VaultSecondaryBorrowStorage {\\n    // fCash borrowed for a specific maturity on a secondary currency\\n    uint80 totalfCashBorrowed;\\n    // Used for accounting how much secondary borrow a single account owes as the fCashBorrowed\\n    // increases or decreases\\n    uint80 totalAccountDebtShares;\\n    // The total secondary fCash borrowed converted to the primary borrow currency (underlying)\\n    // snapshot prior to settlement. This is used to offset account value on settlement. Once this\\n    // value is set, accounts can no longer borrow or repay on the secondary borrow currency\\n    uint80 totalfCashBorrowedInPrimarySnapshot;\\n    // Set to true once when the snapshot is set\\n    bool hasSnapshotBeenSet;\\n}\\n\\nstruct VaultConfig {\\n    address vault;\\n    uint16 flags;\\n    uint16 borrowCurrencyId;\\n    int256 minAccountBorrowSize;\\n    int256 feeRate;\\n    int256 minCollateralRatio;\\n    int256 liquidationRate;\\n    int256 reserveFeeShare;\\n    uint256 maxBorrowMarketIndex;\\n    int256 maxDeleverageCollateralRatio;\\n    uint16[2] secondaryBorrowCurrencies;\\n    AssetRateParameters assetRate;\\n    int256 maxRequiredAccountCollateralRatio;\\n}\\n\\n/// @notice Represents a Vault's current borrow and collateral state\\nstruct VaultStateStorage {\\n    // This represents the total amount of borrowing in the vault for the current\\n    // vault term. This value must equal the total fCash borrowed by all accounts\\n    // in the vault.\\n    uint80 totalfCash;\\n    // The total amount of asset cash in the pool held as prepayment for fCash\\n    uint80 totalAssetCash;\\n    // Total vault shares in this maturity\\n    uint80 totalVaultShares;\\n    // Set to true if a vault has been fully settled and the cash can be pulled. Matured\\n    // accounts must wait for this flag to be set before they can proceed to exit after\\n    // maturity\\n    bool isSettled;\\n    // NOTE: 8 bits left\\n    // ----- This breaks into a new storage slot -------    \\n    // TODO: potentially make total strategy tokens bigger...\\n    // The total amount of strategy tokens held in the pool\\n    uint80 totalStrategyTokens;\\n    // Valuation of a strategy token at settlement\\n    int80 settlementStrategyTokenValue;\\n    // NOTE: 96 bits left\\n}\\n\\n/// @notice Represents the remaining assets in a vault post settlement\\nstruct VaultSettledAssetsStorage {\\n    // Remaining strategy tokens that have not been withdrawn\\n    uint80 remainingStrategyTokens;\\n    // Remaining asset cash that has not been withdrawn\\n    int80 remainingAssetCash;\\n}\\n\\nstruct VaultState {\\n    uint256 maturity;\\n    int256 totalfCash;\\n    bool isSettled;\\n    uint256 totalVaultShares;\\n    uint256 totalAssetCash;\\n    uint256 totalStrategyTokens;\\n    int256 settlementStrategyTokenValue;\\n}\\n\\n/// @notice Represents an account's position within an individual vault\\nstruct VaultAccountStorage {\\n    // The amount of fCash the account has borrowed from Notional. Stored as a uint but on the stack it\\n    // is represented as a negative number.\\n    uint80 fCash;\\n    // Vault shares that the account holds\\n    uint80 vaultShares;\\n    // Maturity when the vault shares and fCash will mature\\n    uint40 maturity;\\n    // Last block when a vault entered, used to ensure that vault accounts do not flash enter/exit.\\n    // While there is no specified attack vector here, we can use it to prevent an entire class\\n    // of attacks from happening without reducing UX.\\n    uint32 lastEntryBlockHeight;\\n}\\n\\nstruct VaultAccountSecondaryDebtShareStorage {\\n    // Maturity for the account's secondary borrows. This is stored separately from\\n    // the vault account maturity to ensure that we have access to the proper state\\n    // during a roll borrow position. It should never be allowed to deviate from the\\n    // vaultAccount.maturity value (unless it is cleared to zero).\\n    uint40 maturity;\\n    // Account debt shares for the first secondary currency\\n    uint80 accountDebtSharesOne;\\n    // Account debt shares for the second secondary currency\\n    uint80 accountDebtSharesTwo;\\n}\\n\\nstruct VaultAccount {\\n    int256 fCash;\\n    uint256 maturity;\\n    uint256 vaultShares;\\n    address account;\\n    // This cash balance is used just within a transaction to track deposits\\n    // and withdraws for an account. Must be zeroed by the time we store the account\\n    int256 tempCashBalance;\\n    uint256 lastEntryBlockHeight;\\n}\"\r\n    },\r\n    \"contracts/internal/AccountContextHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../global/LibStorage.sol\\\";\\nimport \\\"./balances/BalanceHandler.sol\\\";\\nimport \\\"./portfolio/BitmapAssetsHandler.sol\\\";\\nimport \\\"./portfolio/PortfolioHandler.sol\\\";\\n\\nlibrary AccountContextHandler {\\n    using PortfolioHandler for PortfolioState;\\n\\n    bytes18 private constant TURN_OFF_PORTFOLIO_FLAGS = 0x7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF;\\n    event AccountContextUpdate(address indexed account);\\n\\n    /// @notice Returns the account context of a given account\\n    function getAccountContext(address account) internal view returns (AccountContext memory) {\\n        mapping(address => AccountContext) storage store = LibStorage.getAccountStorage();\\n        return store[account];\\n    }\\n\\n    /// @notice Sets the account context of a given account\\n    function setAccountContext(AccountContext memory accountContext, address account) internal {\\n        mapping(address => AccountContext) storage store = LibStorage.getAccountStorage();\\n        store[account] = accountContext;\\n        emit AccountContextUpdate(account);\\n    }\\n\\n    function isBitmapEnabled(AccountContext memory accountContext) internal pure returns (bool) {\\n        return accountContext.bitmapCurrencyId != 0;\\n    }\\n\\n    /// @notice Enables a bitmap type portfolio for an account. A bitmap type portfolio allows\\n    /// an account to hold more fCash than a normal portfolio, except only in a single currency.\\n    /// Once enabled, it cannot be disabled or changed. An account can only enable a bitmap if\\n    /// it has no assets or debt so that we ensure no assets are left stranded.\\n    /// @param accountContext refers to the account where the bitmap will be enabled\\n    /// @param currencyId the id of the currency to enable\\n    /// @param blockTime the current block time to set the next settle time\\n    function enableBitmapForAccount(\\n        AccountContext memory accountContext,\\n        uint16 currencyId,\\n        uint256 blockTime\\n    ) internal pure {\\n        require(!isBitmapEnabled(accountContext), \\\"Cannot change bitmap\\\");\\n        require(0 < currencyId && currencyId <= Constants.MAX_CURRENCIES, \\\"Invalid currency id\\\");\\n\\n        // Account cannot have assets or debts\\n        require(accountContext.assetArrayLength == 0, \\\"Cannot have assets\\\");\\n        require(accountContext.hasDebt == 0x00, \\\"Cannot have debt\\\");\\n\\n        // Ensure that the active currency is set to false in the array so that there is no double\\n        // counting during FreeCollateral\\n        setActiveCurrency(accountContext, currencyId, false, Constants.ACTIVE_IN_BALANCES);\\n        accountContext.bitmapCurrencyId = currencyId;\\n\\n        // Setting this is required to initialize the assets bitmap\\n        uint256 nextSettleTime = DateTime.getTimeUTC0(blockTime);\\n        require(nextSettleTime < type(uint40).max); // dev: blockTime overflow\\n        accountContext.nextSettleTime = uint40(nextSettleTime);\\n    }\\n\\n    /// @notice Returns true if the context needs to settle\\n    function mustSettleAssets(AccountContext memory accountContext) internal view returns (bool) {\\n        uint256 blockTime = block.timestamp;\\n\\n        if (isBitmapEnabled(accountContext)) {\\n            // nextSettleTime will be set to utc0 after settlement so we\\n            // settle if this is strictly less than utc0\\n            return accountContext.nextSettleTime < DateTime.getTimeUTC0(blockTime);\\n        } else {\\n            // 0 value occurs on an uninitialized account\\n            // Assets mature exactly on the blockTime (not one second past) so in this\\n            // case we settle on the block timestamp\\n            return 0 < accountContext.nextSettleTime && accountContext.nextSettleTime <= blockTime;\\n        }\\n    }\\n\\n    /// @notice Checks if a currency id (uint16 max) is in the 9 slots in the account\\n    /// context active currencies list.\\n    /// @dev NOTE: this may be more efficient as a binary search since we know that the array\\n    /// is sorted\\n    function isActiveInBalances(AccountContext memory accountContext, uint256 currencyId)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        require(currencyId != 0 && currencyId <= Constants.MAX_CURRENCIES); // dev: invalid currency id\\n        bytes18 currencies = accountContext.activeCurrencies;\\n\\n        if (accountContext.bitmapCurrencyId == currencyId) return true;\\n\\n        while (currencies != 0x00) {\\n            uint256 cid = uint16(bytes2(currencies) & Constants.UNMASK_FLAGS);\\n            if (cid == currencyId) {\\n                // Currency found, return if it is active in balances or not\\n                return bytes2(currencies) & Constants.ACTIVE_IN_BALANCES == Constants.ACTIVE_IN_BALANCES;\\n            }\\n\\n            currencies = currencies << 16;\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @notice Iterates through the active currency list and removes, inserts or does nothing\\n    /// to ensure that the active currency list is an ordered byte array of uint16 currency ids\\n    /// that refer to the currencies that an account is active in.\\n    ///\\n    /// This is called to ensure that currencies are active when the account has a non zero cash balance,\\n    /// a non zero nToken balance or a portfolio asset.\\n    function setActiveCurrency(\\n        AccountContext memory accountContext,\\n        uint256 currencyId,\\n        bool isActive,\\n        bytes2 flags\\n    ) internal pure {\\n        require(0 < currencyId && currencyId <= Constants.MAX_CURRENCIES); // dev: invalid currency id\\n\\n        // If the bitmapped currency is already set then return here. Turning off the bitmap currency\\n        // id requires other logical handling so we will do it elsewhere.\\n        if (isActive && accountContext.bitmapCurrencyId == currencyId) return;\\n\\n        bytes18 prefix;\\n        bytes18 suffix = accountContext.activeCurrencies;\\n        uint256 shifts;\\n\\n        /// There are six possible outcomes from this search:\\n        /// 1. The currency id is in the list\\n        ///      - it must be set to active, do nothing\\n        ///      - it must be set to inactive, shift suffix and concatenate\\n        /// 2. The current id is greater than the one in the search:\\n        ///      - it must be set to active, append to prefix and then concatenate the suffix,\\n        ///        ensure that we do not lose the last 2 bytes if set.\\n        ///      - it must be set to inactive, it is not in the list, do nothing\\n        /// 3. Reached the end of the list:\\n        ///      - it must be set to active, check that the last two bytes are not set and then\\n        ///        append to the prefix\\n        ///      - it must be set to inactive, do nothing\\n        while (suffix != 0x00) {\\n            uint256 cid = uint256(uint16(bytes2(suffix) & Constants.UNMASK_FLAGS));\\n            // if matches and isActive then return, already in list\\n            if (cid == currencyId && isActive) {\\n                // set flag and return\\n                accountContext.activeCurrencies =\\n                    accountContext.activeCurrencies |\\n                    (bytes18(flags) >> (shifts * 16));\\n                return;\\n            }\\n\\n            // if matches and not active then shift suffix to remove\\n            if (cid == currencyId && !isActive) {\\n                // turn off flag, if both flags are off then remove\\n                suffix = suffix & ~bytes18(flags);\\n                if (bytes2(suffix) & ~Constants.UNMASK_FLAGS == 0x0000) suffix = suffix << 16;\\n                accountContext.activeCurrencies = prefix | (suffix >> (shifts * 16));\\n                return;\\n            }\\n\\n            // if greater than and isActive then insert into prefix\\n            if (cid > currencyId && isActive) {\\n                prefix = prefix | (bytes18(bytes2(uint16(currencyId)) | flags) >> (shifts * 16));\\n                // check that the total length is not greater than 9, meaning that the last\\n                // two bytes of the active currencies array should be zero\\n                require((accountContext.activeCurrencies << 128) == 0x00); // dev: AC: too many currencies\\n\\n                // append the suffix\\n                accountContext.activeCurrencies = prefix | (suffix >> ((shifts + 1) * 16));\\n                return;\\n            }\\n\\n            // if past the point of the currency id and not active, not in list\\n            if (cid > currencyId && !isActive) return;\\n\\n            prefix = prefix | (bytes18(bytes2(suffix)) >> (shifts * 16));\\n            suffix = suffix << 16;\\n            shifts += 1;\\n        }\\n\\n        // If reached this point and not active then return\\n        if (!isActive) return;\\n\\n        // if end and isActive then insert into suffix, check max length\\n        require(shifts < 9); // dev: AC: too many currencies\\n        accountContext.activeCurrencies =\\n            prefix |\\n            (bytes18(bytes2(uint16(currencyId)) | flags) >> (shifts * 16));\\n    }\\n\\n    function _clearPortfolioActiveFlags(bytes18 activeCurrencies) internal pure returns (bytes18) {\\n        bytes18 result;\\n        // This is required to clear the suffix as we append below\\n        bytes18 suffix = activeCurrencies & TURN_OFF_PORTFOLIO_FLAGS;\\n        uint256 shifts;\\n\\n        // This loop will append all currencies that are active in balances into the result.\\n        while (suffix != 0x00) {\\n            if (bytes2(suffix) & Constants.ACTIVE_IN_BALANCES == Constants.ACTIVE_IN_BALANCES) {\\n                // If any flags are active, then append.\\n                result = result | (bytes18(bytes2(suffix)) >> shifts);\\n                shifts += 16;\\n            }\\n            suffix = suffix << 16;\\n        }\\n\\n        return result;\\n    }\\n\\n    /// @notice Stores a portfolio array and updates the account context information, this method should\\n    /// be used whenever updating a portfolio array except in the case of nTokens\\n    function storeAssetsAndUpdateContext(\\n        AccountContext memory accountContext,\\n        address account,\\n        PortfolioState memory portfolioState,\\n        bool isLiquidation\\n    ) internal {\\n        // Each of these parameters is recalculated based on the entire array of assets in store assets,\\n        // regardless of whether or not they have been updated.\\n        (bool hasDebt, bytes32 portfolioCurrencies, uint8 assetArrayLength, uint40 nextSettleTime) =\\n            portfolioState.storeAssets(account);\\n        accountContext.nextSettleTime = nextSettleTime;\\n        require(mustSettleAssets(accountContext) == false); // dev: cannot store matured assets\\n        accountContext.assetArrayLength = assetArrayLength;\\n\\n        // During liquidation it is possible for an array to go over the max amount of assets allowed due to\\n        // liquidity tokens being withdrawn into fCash.\\n        if (!isLiquidation) {\\n            require(assetArrayLength <= uint8(Constants.MAX_TRADED_MARKET_INDEX)); // dev: max assets allowed\\n        }\\n\\n        // Sets the hasDebt flag properly based on whether or not portfolio has asset debt, meaning\\n        // a negative fCash balance.\\n        if (hasDebt) {\\n            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_ASSET_DEBT;\\n        } else {\\n            // Turns off the ASSET_DEBT flag\\n            accountContext.hasDebt = accountContext.hasDebt & ~Constants.HAS_ASSET_DEBT;\\n        }\\n\\n        // Clear the active portfolio active flags and they will be recalculated in the next step\\n        accountContext.activeCurrencies = _clearPortfolioActiveFlags(accountContext.activeCurrencies);\\n\\n        uint256 lastCurrency;\\n        while (portfolioCurrencies != 0) {\\n            // Portfolio currencies will not have flags, it is just an byte array of all the currencies found\\n            // in a portfolio. They are appended in a sorted order so we can compare to the previous currency\\n            // and only set it if they are different.\\n            uint256 currencyId = uint16(bytes2(portfolioCurrencies));\\n            if (currencyId != lastCurrency) {\\n                setActiveCurrency(accountContext, currencyId, true, Constants.ACTIVE_IN_PORTFOLIO);\\n            }\\n            lastCurrency = currencyId;\\n\\n            portfolioCurrencies = portfolioCurrencies << 16;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/balances/BalanceHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./Incentives.sol\\\";\\nimport \\\"./TokenHandler.sol\\\";\\nimport \\\"../AccountContextHandler.sol\\\";\\nimport \\\"../../global/Types.sol\\\";\\nimport \\\"../../global/Constants.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"../../math/FloatingPoint56.sol\\\";\\n\\nlibrary BalanceHandler {\\n    using SafeInt256 for int256;\\n    using TokenHandler for Token;\\n    using AssetRate for AssetRateParameters;\\n    using AccountContextHandler for AccountContext;\\n\\n    /// @notice Emitted when a cash balance changes\\n    event CashBalanceChange(address indexed account, uint16 indexed currencyId, int256 netCashChange);\\n    /// @notice Emitted when nToken supply changes (not the same as transfers)\\n    event nTokenSupplyChange(address indexed account, uint16 indexed currencyId, int256 tokenSupplyChange);\\n    /// @notice Emitted when reserve fees are accrued\\n    event ReserveFeeAccrued(uint16 indexed currencyId, int256 fee);\\n    /// @notice Emitted when reserve balance is updated\\n    event ReserveBalanceUpdated(uint16 indexed currencyId, int256 newBalance);\\n    /// @notice Emitted when reserve balance is harvested\\n    event ExcessReserveBalanceHarvested(uint16 indexed currencyId, int256 harvestAmount);\\n\\n    /// @notice Deposits asset tokens into an account\\n    /// @dev Handles two special cases when depositing tokens into an account.\\n    ///  - If a token has transfer fees then the amount specified does not equal the amount that the contract\\n    ///    will receive. Complete the deposit here rather than in finalize so that the contract has the correct\\n    ///    balance to work with.\\n    ///  - Force a transfer before finalize to allow a different account to deposit into an account\\n    /// @return assetAmountInternal which is the converted asset amount accounting for transfer fees\\n    function depositAssetToken(\\n        BalanceState memory balanceState,\\n        address account,\\n        int256 assetAmountExternal,\\n        bool forceTransfer\\n    ) internal returns (int256 assetAmountInternal) {\\n        if (assetAmountExternal == 0) return 0;\\n        require(assetAmountExternal > 0); // dev: deposit asset token amount negative\\n        Token memory token = TokenHandler.getAssetToken(balanceState.currencyId);\\n        if (token.tokenType == TokenType.aToken) {\\n            // Handles special accounting requirements for aTokens\\n            assetAmountExternal = AaveHandler.convertToScaledBalanceExternal(\\n                balanceState.currencyId,\\n                assetAmountExternal\\n            );\\n        }\\n\\n        // Force transfer is used to complete the transfer before going to finalize\\n        if (token.hasTransferFee || forceTransfer) {\\n            // If the token has a transfer fee the deposit amount may not equal the actual amount\\n            // that the contract will receive. We handle the deposit here and then update the netCashChange\\n            // accordingly which is denominated in internal precision.\\n            int256 assetAmountExternalPrecisionFinal = token.transfer(account, balanceState.currencyId, assetAmountExternal);\\n            // Convert the external precision to internal, it's possible that we lose dust amounts here but\\n            // this is unavoidable because we do not know how transfer fees are calculated.\\n            assetAmountInternal = token.convertToInternal(assetAmountExternalPrecisionFinal);\\n            // Transfer has been called\\n            balanceState.netCashChange = balanceState.netCashChange.add(assetAmountInternal);\\n\\n            return assetAmountInternal;\\n        } else {\\n            assetAmountInternal = token.convertToInternal(assetAmountExternal);\\n            // Otherwise add the asset amount here. It may be net off later and we want to only do\\n            // a single transfer during the finalize method. Use internal precision to ensure that internal accounting\\n            // and external account remain in sync.\\n            // Transfer will be deferred\\n            balanceState.netAssetTransferInternalPrecision = balanceState\\n                .netAssetTransferInternalPrecision\\n                .add(assetAmountInternal);\\n\\n            // Returns the converted assetAmountExternal to the internal amount\\n            return assetAmountInternal;\\n        }\\n    }\\n\\n    /// @notice Handle deposits of the underlying token\\n    /// @dev In this case we must wrap the underlying token into an asset token, ensuring that we do not end up\\n    /// with any underlying tokens left as dust on the contract.\\n    function depositUnderlyingToken(\\n        BalanceState memory balanceState,\\n        address account,\\n        int256 underlyingAmountExternal\\n    ) internal returns (int256) {\\n        if (underlyingAmountExternal == 0) return 0;\\n        require(underlyingAmountExternal > 0); // dev: deposit underlying token negative\\n\\n        Token memory underlyingToken = TokenHandler.getUnderlyingToken(balanceState.currencyId);\\n        // This is the exact amount of underlying tokens the account has in external precision.\\n        if (underlyingToken.tokenType == TokenType.Ether) {\\n            // Underflow checked above\\n            require(uint256(underlyingAmountExternal) == msg.value, \\\"ETH Balance\\\");\\n        } else {\\n            underlyingAmountExternal = underlyingToken.transfer(account, balanceState.currencyId, underlyingAmountExternal);\\n        }\\n\\n        Token memory assetToken = TokenHandler.getAssetToken(balanceState.currencyId);\\n        int256 assetTokensReceivedExternalPrecision =\\n            assetToken.mint(balanceState.currencyId, SafeInt256.toUint(underlyingAmountExternal));\\n\\n        // cTokens match INTERNAL_TOKEN_PRECISION so this will short circuit but we leave this here in case a different\\n        // type of asset token is listed in the future. It's possible if those tokens have a different precision dust may\\n        // accrue but that is not relevant now.\\n        int256 assetTokensReceivedInternal =\\n            assetToken.convertToInternal(assetTokensReceivedExternalPrecision);\\n        // Transfer / mint has taken effect\\n        balanceState.netCashChange = balanceState.netCashChange.add(assetTokensReceivedInternal);\\n\\n        return assetTokensReceivedInternal;\\n    }\\n\\n    /// @notice Finalizes an account's balances, handling any transfer logic required\\n    /// @dev This method SHOULD NOT be used for nToken accounts, for that use setBalanceStorageForNToken\\n    /// as the nToken is limited in what types of balances it can hold.\\n    function finalize(\\n        BalanceState memory balanceState,\\n        address account,\\n        AccountContext memory accountContext,\\n        bool redeemToUnderlying\\n    ) internal returns (int256 transferAmountExternal) {\\n        bool mustUpdate;\\n        if (balanceState.netNTokenTransfer < 0) {\\n            require(\\n                balanceState.storedNTokenBalance\\n                    .add(balanceState.netNTokenSupplyChange)\\n                    .add(balanceState.netNTokenTransfer) >= 0,\\n                \\\"Neg nToken\\\"\\n            );\\n        }\\n\\n        if (balanceState.netAssetTransferInternalPrecision < 0) {\\n            require(\\n                balanceState.storedCashBalance\\n                    .add(balanceState.netCashChange)\\n                    .add(balanceState.netAssetTransferInternalPrecision) >= 0,\\n                \\\"Neg Cash\\\"\\n            );\\n        }\\n\\n        // Transfer amount is checked inside finalize transfers in case when converting to external we\\n        // round down to zero. This returns the actual net transfer in internal precision as well.\\n        (\\n            transferAmountExternal,\\n            balanceState.netAssetTransferInternalPrecision\\n        ) = _finalizeTransfers(balanceState, account, redeemToUnderlying);\\n        // No changes to total cash after this point\\n        int256 totalCashChange = balanceState.netCashChange.add(balanceState.netAssetTransferInternalPrecision);\\n\\n        if (totalCashChange != 0) {\\n            balanceState.storedCashBalance = balanceState.storedCashBalance.add(totalCashChange);\\n            mustUpdate = true;\\n\\n            emit CashBalanceChange(\\n                account,\\n                uint16(balanceState.currencyId),\\n                totalCashChange\\n            );\\n        }\\n\\n        if (balanceState.netNTokenTransfer != 0 || balanceState.netNTokenSupplyChange != 0) {\\n            // Final nToken balance is used to calculate the account incentive debt\\n            int256 finalNTokenBalance = balanceState.storedNTokenBalance\\n                .add(balanceState.netNTokenTransfer)\\n                .add(balanceState.netNTokenSupplyChange);\\n\\n            // The toUint() call here will ensure that nToken balances never become negative\\n            Incentives.claimIncentives(balanceState, account, finalNTokenBalance.toUint());\\n\\n            balanceState.storedNTokenBalance = finalNTokenBalance;\\n\\n            if (balanceState.netNTokenSupplyChange != 0) {\\n                emit nTokenSupplyChange(\\n                    account,\\n                    uint16(balanceState.currencyId),\\n                    balanceState.netNTokenSupplyChange\\n                );\\n            }\\n\\n            mustUpdate = true;\\n        }\\n\\n        if (mustUpdate) {\\n            _setBalanceStorage(\\n                account,\\n                balanceState.currencyId,\\n                balanceState.storedCashBalance,\\n                balanceState.storedNTokenBalance,\\n                balanceState.lastClaimTime,\\n                balanceState.accountIncentiveDebt\\n            );\\n        }\\n\\n        accountContext.setActiveCurrency(\\n            balanceState.currencyId,\\n            // Set active currency to true if either balance is non-zero\\n            balanceState.storedCashBalance != 0 || balanceState.storedNTokenBalance != 0,\\n            Constants.ACTIVE_IN_BALANCES\\n        );\\n\\n        if (balanceState.storedCashBalance < 0) {\\n            // NOTE: HAS_CASH_DEBT cannot be extinguished except by a free collateral check where all balances\\n            // are examined\\n            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_CASH_DEBT;\\n        }\\n    }\\n\\n    /// @dev Returns the amount transferred in underlying or asset terms depending on how redeem to underlying\\n    /// is specified.\\n    function _finalizeTransfers(\\n        BalanceState memory balanceState,\\n        address account,\\n        bool redeemToUnderlying\\n    ) private returns (int256 actualTransferAmountExternal, int256 assetTransferAmountInternal) {\\n        Token memory assetToken = TokenHandler.getAssetToken(balanceState.currencyId);\\n        // Dust accrual to the protocol is possible if the token decimals is less than internal token precision.\\n        // See the comments in TokenHandler.convertToExternal and TokenHandler.convertToInternal\\n        int256 assetTransferAmountExternal =\\n            assetToken.convertToExternal(balanceState.netAssetTransferInternalPrecision);\\n\\n        if (assetTransferAmountExternal == 0) {\\n            return (0, 0);\\n        } else if (redeemToUnderlying && assetTransferAmountExternal < 0) {\\n            // We only do the redeem to underlying if the asset transfer amount is less than zero. If it is greater than\\n            // zero then we will do a normal transfer instead.\\n\\n            // We use the internal amount here and then scale it to the external amount so that there is\\n            // no loss of precision between our internal accounting and the external account. In this case\\n            // there will be no dust accrual in underlying tokens since we will transfer the exact amount\\n            // of underlying that was received.\\n\\n            actualTransferAmountExternal = assetToken.redeem(\\n                balanceState.currencyId,\\n                account,\\n                // No overflow, checked above\\n                uint256(assetTransferAmountExternal.neg())\\n            );\\n\\n            // In this case we're transferring underlying tokens, we want to convert the internal\\n            // asset transfer amount to store in cash balances\\n            assetTransferAmountInternal = assetToken.convertToInternal(assetTransferAmountExternal);\\n        } else {\\n            // NOTE: in the case of aTokens assetTransferAmountExternal is the scaledBalanceOf in external precision, it\\n            // will be converted to balanceOf denomination inside transfer\\n            actualTransferAmountExternal = assetToken.transfer(account, balanceState.currencyId, assetTransferAmountExternal);\\n            // Convert the actual transferred amount\\n            assetTransferAmountInternal = assetToken.convertToInternal(actualTransferAmountExternal);\\n        }\\n    }\\n\\n    /// @notice Special method for settling negative current cash debts. This occurs when an account\\n    /// has a negative fCash balance settle to cash. A settler may come and force the account to borrow\\n    /// at the prevailing 3 month rate\\n    /// @dev Use this method to avoid any nToken and transfer logic in finalize which is unnecessary.\\n    function setBalanceStorageForSettleCashDebt(\\n        address account,\\n        CashGroupParameters memory cashGroup,\\n        int256 amountToSettleAsset,\\n        AccountContext memory accountContext\\n    ) internal returns (int256) {\\n        require(amountToSettleAsset >= 0); // dev: amount to settle negative\\n        (int256 cashBalance, int256 nTokenBalance, uint256 lastClaimTime, uint256 accountIncentiveDebt) =\\n            getBalanceStorage(account, cashGroup.currencyId);\\n\\n        // Prevents settlement of positive balances\\n        require(cashBalance < 0, \\\"Invalid settle balance\\\");\\n        if (amountToSettleAsset == 0) {\\n            // Symbolizes that the entire debt should be settled\\n            amountToSettleAsset = cashBalance.neg();\\n            cashBalance = 0;\\n        } else {\\n            // A partial settlement of the debt\\n            require(amountToSettleAsset <= cashBalance.neg(), \\\"Invalid amount to settle\\\");\\n            cashBalance = cashBalance.add(amountToSettleAsset);\\n        }\\n\\n        // NOTE: we do not update HAS_CASH_DEBT here because it is possible that the other balances\\n        // also have cash debts\\n        if (cashBalance == 0 && nTokenBalance == 0) {\\n            accountContext.setActiveCurrency(\\n                cashGroup.currencyId,\\n                false,\\n                Constants.ACTIVE_IN_BALANCES\\n            );\\n        }\\n\\n        _setBalanceStorage(\\n            account,\\n            cashGroup.currencyId,\\n            cashBalance,\\n            nTokenBalance,\\n            lastClaimTime,\\n            accountIncentiveDebt\\n        );\\n\\n        // Emit the event here, we do not call finalize\\n        emit CashBalanceChange(account, cashGroup.currencyId, amountToSettleAsset);\\n\\n        return amountToSettleAsset;\\n    }\\n\\n    /**\\n     * @notice A special balance storage method for fCash liquidation to reduce the bytecode size.\\n     */\\n    function setBalanceStorageForfCashLiquidation(\\n        address account,\\n        AccountContext memory accountContext,\\n        uint16 currencyId,\\n        int256 netCashChange\\n    ) internal {\\n        (int256 cashBalance, int256 nTokenBalance, uint256 lastClaimTime, uint256 accountIncentiveDebt) =\\n            getBalanceStorage(account, currencyId);\\n\\n        int256 newCashBalance = cashBalance.add(netCashChange);\\n        // If a cash balance is negative already we cannot put an account further into debt. In this case\\n        // the netCashChange must be positive so that it is coming out of debt.\\n        if (newCashBalance < 0) {\\n            require(netCashChange > 0, \\\"Neg Cash\\\");\\n            // NOTE: HAS_CASH_DEBT cannot be extinguished except by a free collateral check\\n            // where all balances are examined. In this case the has cash debt flag should\\n            // already be set (cash balances cannot get more negative) but we do it again\\n            // here just to be safe.\\n            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_CASH_DEBT;\\n        }\\n\\n        bool isActive = newCashBalance != 0 || nTokenBalance != 0;\\n        accountContext.setActiveCurrency(currencyId, isActive, Constants.ACTIVE_IN_BALANCES);\\n\\n        // Emit the event here, we do not call finalize\\n        emit CashBalanceChange(account, currencyId, netCashChange);\\n\\n        _setBalanceStorage(\\n            account,\\n            currencyId,\\n            newCashBalance,\\n            nTokenBalance,\\n            lastClaimTime,\\n            accountIncentiveDebt\\n        );\\n    }\\n\\n    /// @notice Helper method for settling the output of the SettleAssets method\\n    function finalizeSettleAmounts(\\n        address account,\\n        AccountContext memory accountContext,\\n        SettleAmount[] memory settleAmounts\\n    ) internal {\\n        for (uint256 i = 0; i < settleAmounts.length; i++) {\\n            SettleAmount memory amt = settleAmounts[i];\\n            if (amt.netCashChange == 0) continue;\\n\\n            (\\n                int256 cashBalance,\\n                int256 nTokenBalance,\\n                uint256 lastClaimTime,\\n                uint256 accountIncentiveDebt\\n            ) = getBalanceStorage(account, amt.currencyId);\\n\\n            cashBalance = cashBalance.add(amt.netCashChange);\\n            accountContext.setActiveCurrency(\\n                amt.currencyId,\\n                cashBalance != 0 || nTokenBalance != 0,\\n                Constants.ACTIVE_IN_BALANCES\\n            );\\n\\n            if (cashBalance < 0) {\\n                accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_CASH_DEBT;\\n            }\\n\\n            emit CashBalanceChange(\\n                account,\\n                uint16(amt.currencyId),\\n                amt.netCashChange\\n            );\\n\\n            _setBalanceStorage(\\n                account,\\n                amt.currencyId,\\n                cashBalance,\\n                nTokenBalance,\\n                lastClaimTime,\\n                accountIncentiveDebt\\n            );\\n        }\\n    }\\n\\n    /// @notice Special method for setting balance storage for nToken\\n    function setBalanceStorageForNToken(\\n        address nTokenAddress,\\n        uint256 currencyId,\\n        int256 cashBalance\\n    ) internal {\\n        require(cashBalance >= 0); // dev: invalid nToken cash balance\\n        _setBalanceStorage(nTokenAddress, currencyId, cashBalance, 0, 0, 0);\\n    }\\n\\n    /// @notice Asses a fee or a refund to the nToken for leveraged vaults\\n    function incrementVaultFeeToNToken(uint256 currencyId, int256 fee) internal {\\n        require(fee >= 0); // dev: invalid fee\\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\\n        (int256 cashBalance, /* */, /* */, /* */) = getBalanceStorage(nTokenAddress, currencyId);\\n        cashBalance = cashBalance.add(fee);\\n        setBalanceStorageForNToken(nTokenAddress, currencyId, cashBalance);\\n    }\\n\\n    /// @notice increments fees to the reserve\\n    function incrementFeeToReserve(uint256 currencyId, int256 fee) internal {\\n        require(fee >= 0); // dev: invalid fee\\n        // prettier-ignore\\n        (int256 totalReserve, /* */, /* */, /* */) = getBalanceStorage(Constants.RESERVE, currencyId);\\n        totalReserve = totalReserve.add(fee);\\n        _setBalanceStorage(Constants.RESERVE, currencyId, totalReserve, 0, 0, 0);\\n        emit ReserveFeeAccrued(uint16(currencyId), fee);\\n    }\\n\\n    /// @notice harvests excess reserve balance\\n    function harvestExcessReserveBalance(uint16 currencyId, int256 reserve, int256 assetInternalRedeemAmount) internal {\\n        // parameters are validated by the caller\\n        reserve = reserve.subNoNeg(assetInternalRedeemAmount);\\n        _setBalanceStorage(Constants.RESERVE, currencyId, reserve, 0, 0, 0);\\n        emit ExcessReserveBalanceHarvested(currencyId, assetInternalRedeemAmount);\\n    }\\n\\n    /// @notice sets the reserve balance, see TreasuryAction.setReserveCashBalance\\n    function setReserveCashBalance(uint16 currencyId, int256 newBalance) internal {\\n        require(newBalance >= 0); // dev: invalid balance\\n        _setBalanceStorage(Constants.RESERVE, currencyId, newBalance, 0, 0, 0);\\n        emit ReserveBalanceUpdated(currencyId, newBalance);\\n    }\\n\\n    /// @notice Sets internal balance storage.\\n    function _setBalanceStorage(\\n        address account,\\n        uint256 currencyId,\\n        int256 cashBalance,\\n        int256 nTokenBalance,\\n        uint256 lastClaimTime,\\n        uint256 accountIncentiveDebt\\n    ) private {\\n        mapping(address => mapping(uint256 => BalanceStorage)) storage store = LibStorage.getBalanceStorage();\\n        BalanceStorage storage balanceStorage = store[account][currencyId];\\n\\n        require(cashBalance >= type(int88).min && cashBalance <= type(int88).max); // dev: stored cash balance overflow\\n        // Allows for 12 quadrillion nToken balance in 1e8 decimals before overflow\\n        require(nTokenBalance >= 0 && nTokenBalance <= type(uint80).max); // dev: stored nToken balance overflow\\n\\n        if (lastClaimTime == 0) {\\n            // In this case the account has migrated and we set the accountIncentiveDebt\\n            // The maximum NOTE supply is 100_000_000e8 (1e16) which is less than 2^56 (7.2e16) so we should never\\n            // encounter an overflow for accountIncentiveDebt\\n            require(accountIncentiveDebt <= type(uint56).max); // dev: account incentive debt overflow\\n            balanceStorage.accountIncentiveDebt = uint56(accountIncentiveDebt);\\n        } else {\\n            // In this case the last claim time has not changed and we do not update the last integral supply\\n            // (stored in the accountIncentiveDebt position)\\n            require(lastClaimTime == balanceStorage.lastClaimTime);\\n        }\\n\\n        balanceStorage.lastClaimTime = uint32(lastClaimTime);\\n        balanceStorage.nTokenBalance = uint80(nTokenBalance);\\n        balanceStorage.cashBalance = int88(cashBalance);\\n    }\\n\\n    /// @notice Gets internal balance storage, nTokens are stored alongside cash balances\\n    function getBalanceStorage(address account, uint256 currencyId)\\n        internal\\n        view\\n        returns (\\n            int256 cashBalance,\\n            int256 nTokenBalance,\\n            uint256 lastClaimTime,\\n            uint256 accountIncentiveDebt\\n        )\\n    {\\n        mapping(address => mapping(uint256 => BalanceStorage)) storage store = LibStorage.getBalanceStorage();\\n        BalanceStorage storage balanceStorage = store[account][currencyId];\\n\\n        nTokenBalance = balanceStorage.nTokenBalance;\\n        lastClaimTime = balanceStorage.lastClaimTime;\\n        if (lastClaimTime > 0) {\\n            // NOTE: this is only necessary to support the deprecated integral supply values, which are stored\\n            // in the accountIncentiveDebt slot\\n            accountIncentiveDebt = FloatingPoint56.unpackFrom56Bits(balanceStorage.accountIncentiveDebt);\\n        } else {\\n            accountIncentiveDebt = balanceStorage.accountIncentiveDebt;\\n        }\\n        cashBalance = balanceStorage.cashBalance;\\n    }\\n\\n    /// @notice Loads a balance state memory object\\n    /// @dev Balance state objects occupy a lot of memory slots, so this method allows\\n    /// us to reuse them if possible\\n    function loadBalanceState(\\n        BalanceState memory balanceState,\\n        address account,\\n        uint16 currencyId,\\n        AccountContext memory accountContext\\n    ) internal view {\\n        require(0 < currencyId && currencyId <= Constants.MAX_CURRENCIES); // dev: invalid currency id\\n        balanceState.currencyId = currencyId;\\n\\n        if (accountContext.isActiveInBalances(currencyId)) {\\n            (\\n                balanceState.storedCashBalance,\\n                balanceState.storedNTokenBalance,\\n                balanceState.lastClaimTime,\\n                balanceState.accountIncentiveDebt\\n            ) = getBalanceStorage(account, currencyId);\\n        } else {\\n            balanceState.storedCashBalance = 0;\\n            balanceState.storedNTokenBalance = 0;\\n            balanceState.lastClaimTime = 0;\\n            balanceState.accountIncentiveDebt = 0;\\n        }\\n\\n        balanceState.netCashChange = 0;\\n        balanceState.netAssetTransferInternalPrecision = 0;\\n        balanceState.netNTokenTransfer = 0;\\n        balanceState.netNTokenSupplyChange = 0;\\n    }\\n\\n    /// @notice Used when manually claiming incentives in nTokenAction. Also sets the balance state\\n    /// to storage to update the accountIncentiveDebt. lastClaimTime will be set to zero as accounts\\n    /// are migrated to the new incentive calculation\\n    function claimIncentivesManual(BalanceState memory balanceState, address account)\\n        internal\\n        returns (uint256 incentivesClaimed)\\n    {\\n        incentivesClaimed = Incentives.claimIncentives(\\n            balanceState,\\n            account,\\n            balanceState.storedNTokenBalance.toUint()\\n        );\\n\\n        _setBalanceStorage(\\n            account,\\n            balanceState.currencyId,\\n            balanceState.storedCashBalance,\\n            balanceState.storedNTokenBalance,\\n            balanceState.lastClaimTime,\\n            balanceState.accountIncentiveDebt\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/balances/Incentives.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./TokenHandler.sol\\\";\\nimport \\\"../nToken/nTokenHandler.sol\\\";\\nimport \\\"../nToken/nTokenSupply.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"../../external/MigrateIncentives.sol\\\";\\nimport \\\"../../../interfaces/notional/IRewarder.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary Incentives {\\n    using SafeMath for uint256;\\n    using SafeInt256 for int256;\\n\\n    /// @notice Calculates the total incentives to claim including those claimed under the previous\\n    /// less accurate calculation. Once an account is migrated it will only claim incentives under\\n    /// the more accurate regime\\n    function calculateIncentivesToClaim(\\n        BalanceState memory balanceState,\\n        address tokenAddress,\\n        uint256 accumulatedNOTEPerNToken,\\n        uint256 finalNTokenBalance\\n    ) internal view returns (uint256 incentivesToClaim) {\\n        if (balanceState.lastClaimTime > 0) {\\n            // If lastClaimTime is set then the account had incentives under the\\n            // previous regime. Will calculate the final amount of incentives to claim here\\n            // under the previous regime.\\n            incentivesToClaim = MigrateIncentives.migrateAccountFromPreviousCalculation(\\n                tokenAddress,\\n                balanceState.storedNTokenBalance.toUint(),\\n                balanceState.lastClaimTime,\\n                // In this case the accountIncentiveDebt is stored as lastClaimIntegralSupply under\\n                // the old calculation\\n                balanceState.accountIncentiveDebt\\n            );\\n\\n            // This marks the account as migrated and lastClaimTime will no longer be used\\n            balanceState.lastClaimTime = 0;\\n            // This value will be set immediately after this, set this to zero so that the calculation\\n            // establishes a new baseline.\\n            balanceState.accountIncentiveDebt = 0;\\n        }\\n\\n        // If an account was migrated then they have no accountIncentivesDebt and should accumulate\\n        // incentives based on their share since the new regime calculation started.\\n        // If an account is just initiating their nToken balance then storedNTokenBalance will be zero\\n        // and they will have no incentives to claim.\\n        // This calculation uses storedNTokenBalance which is the balance of the account up until this point,\\n        // this is important to ensure that the account does not claim for nTokens that they will mint or\\n        // redeem on a going forward basis.\\n\\n        // The calculation below has the following precision:\\n        //   storedNTokenBalance (INTERNAL_TOKEN_PRECISION)\\n        //   MUL accumulatedNOTEPerNToken (INCENTIVE_ACCUMULATION_PRECISION)\\n        //   DIV INCENTIVE_ACCUMULATION_PRECISION\\n        //  = INTERNAL_TOKEN_PRECISION - (accountIncentivesDebt) INTERNAL_TOKEN_PRECISION\\n        incentivesToClaim = incentivesToClaim.add(\\n            balanceState.storedNTokenBalance.toUint()\\n                .mul(accumulatedNOTEPerNToken)\\n                .div(Constants.INCENTIVE_ACCUMULATION_PRECISION)\\n                .sub(balanceState.accountIncentiveDebt)\\n        );\\n\\n        // Update accountIncentivesDebt denominated in INTERNAL_TOKEN_PRECISION which marks the portion\\n        // of the accumulatedNOTE that the account no longer has a claim over. Use the finalNTokenBalance\\n        // here instead of storedNTokenBalance to mark the overall incentives claim that the account\\n        // does not have a claim over. We do not aggregate this value with the previous accountIncentiveDebt\\n        // because accumulatedNOTEPerNToken is already an aggregated value.\\n\\n        // The calculation below has the following precision:\\n        //   finalNTokenBalance (INTERNAL_TOKEN_PRECISION)\\n        //   MUL accumulatedNOTEPerNToken (INCENTIVE_ACCUMULATION_PRECISION)\\n        //   DIV INCENTIVE_ACCUMULATION_PRECISION\\n        //   = INTERNAL_TOKEN_PRECISION\\n        balanceState.accountIncentiveDebt = finalNTokenBalance\\n            .mul(accumulatedNOTEPerNToken)\\n            .div(Constants.INCENTIVE_ACCUMULATION_PRECISION);\\n    }\\n\\n    /// @notice Incentives must be claimed every time nToken balance changes.\\n    /// @dev BalanceState.accountIncentiveDebt is updated in place here\\n    function claimIncentives(\\n        BalanceState memory balanceState,\\n        address account,\\n        uint256 finalNTokenBalance\\n    ) internal returns (uint256 incentivesToClaim) {\\n        uint256 blockTime = block.timestamp;\\n        address tokenAddress = nTokenHandler.nTokenAddress(balanceState.currencyId);\\n        // This will updated the nToken storage and return what the accumulatedNOTEPerNToken\\n        // is up until this current block time in 1e18 precision\\n        uint256 accumulatedNOTEPerNToken = nTokenSupply.changeNTokenSupply(\\n            tokenAddress,\\n            balanceState.netNTokenSupplyChange,\\n            blockTime\\n        );\\n\\n        incentivesToClaim = calculateIncentivesToClaim(\\n            balanceState,\\n            tokenAddress,\\n            accumulatedNOTEPerNToken,\\n            finalNTokenBalance\\n        );\\n\\n        // If a secondary incentive rewarder is set, then call it\\n        IRewarder rewarder = nTokenHandler.getSecondaryRewarder(tokenAddress);\\n        if (address(rewarder) != address(0)) {\\n            rewarder.claimRewards(\\n                account,\\n                balanceState.currencyId,\\n                // When this method is called from finalize, the storedNTokenBalance has not\\n                // been updated to finalNTokenBalance yet so this is the balance before the change.\\n                balanceState.storedNTokenBalance.toUint(),\\n                finalNTokenBalance,\\n                // When the rewarder is called, totalSupply has been updated already so may need to\\n                // adjust its calculation using the net supply change figure here. Supply change\\n                // may be zero when nTokens are transferred.\\n                balanceState.netNTokenSupplyChange,\\n                incentivesToClaim\\n            );\\n        }\\n\\n        if (incentivesToClaim > 0) TokenHandler.transferIncentive(account, incentivesToClaim);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/balances/protocols/AaveHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../../../global/Types.sol\\\";\\nimport \\\"../../../global/LibStorage.sol\\\";\\nimport \\\"../../../math/SafeInt256.sol\\\";\\nimport \\\"../TokenHandler.sol\\\";\\nimport \\\"../../../../interfaces/aave/IAToken.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary AaveHandler {\\n    using SafeMath for uint256;\\n    using SafeInt256 for int256;\\n    int256 internal constant RAY = 1e27;\\n    int256 internal constant halfRAY = RAY / 2;\\n\\n    bytes4 internal constant scaledBalanceOfSelector = IAToken.scaledBalanceOf.selector;\\n\\n    /**\\n     * @notice Mints an amount of aTokens corresponding to the the underlying.\\n     * @param underlyingToken address of the underlying token to pass to Aave\\n     * @param underlyingAmountExternal amount of underlying to deposit, in external precision\\n     */\\n    function mint(Token memory underlyingToken, uint256 underlyingAmountExternal) internal {\\n        // In AaveV3 this method is renamed to supply() but deposit() is still available for\\n        // backwards compatibility: https://github.com/aave/aave-v3-core/blob/master/contracts/protocol/pool/Pool.sol#L755\\n        // We use deposit here so that mainnet-fork tests against Aave v2 will pass.\\n        LibStorage.getLendingPool().lendingPool.deposit(\\n            underlyingToken.tokenAddress,\\n            underlyingAmountExternal,\\n            address(this),\\n            0\\n        );\\n    }\\n\\n    /**\\n     * @notice Redeems and sends an amount of aTokens to the specified account\\n     * @param underlyingToken address of the underlying token to pass to Aave\\n     * @param account account to receive the underlying\\n     * @param assetAmountExternal amount of aTokens in scaledBalanceOf terms\\n     */\\n    function redeem(\\n        Token memory underlyingToken,\\n        address account,\\n        uint256 assetAmountExternal\\n    ) internal returns (uint256 underlyingAmountExternal) {\\n        underlyingAmountExternal = convertFromScaledBalanceExternal(\\n            underlyingToken.tokenAddress,\\n            SafeInt256.toInt(assetAmountExternal)\\n        ).toUint();\\n        LibStorage.getLendingPool().lendingPool.withdraw(\\n            underlyingToken.tokenAddress,\\n            underlyingAmountExternal,\\n            account\\n        );\\n    }\\n\\n    /**\\n     * @notice Takes an assetAmountExternal (in this case is the Aave balanceOf representing principal plus interest)\\n     * and returns another assetAmountExternal value which represents the Aave scaledBalanceOf (representing a proportional\\n     * claim on Aave principal plus interest onto the future). This conversion ensures that depositors into Notional will\\n     * receive future Aave interest.\\n     * @dev There is no loss of precision within this function since it does the exact same calculation as Aave.\\n     * @param currencyId is the currency id\\n     * @param assetAmountExternal an Aave token amount representing principal plus interest supplied by the user. This must\\n     * be positive in this function, this method is only called when depositing aTokens directly\\n     * @return scaledAssetAmountExternal the Aave scaledBalanceOf equivalent. The decimal precision of this value will\\n     * be in external precision.\\n     */\\n    function convertToScaledBalanceExternal(uint256 currencyId, int256 assetAmountExternal) internal view returns (int256) {\\n        if (assetAmountExternal == 0) return 0;\\n        require(assetAmountExternal > 0);\\n\\n        Token memory underlyingToken = TokenHandler.getUnderlyingToken(currencyId);\\n        // We know that this value must be positive\\n        int256 index = _getReserveNormalizedIncome(underlyingToken.tokenAddress);\\n\\n        // Mimic the WadRay math performed by Aave (but do it in int256 instead)\\n        int256 halfIndex = index / 2;\\n\\n        // Overflow will occur when: (a * RAY + halfIndex) > int256.max\\n        require(assetAmountExternal <= (type(int256).max - halfIndex) / RAY);\\n\\n        // if index is zero then this will revert\\n        return (assetAmountExternal * RAY + halfIndex) / index;\\n    }\\n\\n    /**\\n     * @notice Takes an assetAmountExternal (in this case is the internal scaledBalanceOf in external decimal precision)\\n     * and returns another assetAmountExternal value which represents the Aave balanceOf representing the principal plus interest\\n     * that will be transferred. This is required to maintain compatibility with Aave's ERC20 transfer functions.\\n     * @dev There is no loss of precision because this does exactly what Aave's calculation would do\\n     * @param underlyingToken token address of the underlying asset\\n     * @param netScaledBalanceExternal an amount representing the scaledBalanceOf in external decimal precision calculated from\\n     * Notional cash balances. This amount may be positive or negative depending on if assets are being deposited (positive) or\\n     * withdrawn (negative).\\n     * @return netBalanceExternal the Aave balanceOf equivalent as a signed integer\\n     */\\n    function convertFromScaledBalanceExternal(address underlyingToken, int256 netScaledBalanceExternal) internal view returns (int256 netBalanceExternal) {\\n        if (netScaledBalanceExternal == 0) return 0;\\n\\n        // We know that this value must be positive\\n        int256 index = _getReserveNormalizedIncome(underlyingToken);\\n        // Use the absolute value here so that the halfRay rounding is applied correctly for negative values\\n        int256 abs = netScaledBalanceExternal.abs();\\n\\n        // Mimic the WadRay math performed by Aave (but do it in int256 instead)\\n\\n        // Overflow will occur when: (abs * index + halfRay) > int256.max\\n        // Here the first term is computed at compile time so it just does a division. If index is zero then\\n        // solidity will revert.\\n        require(abs <= (type(int256).max - halfRAY) / index);\\n        int256 absScaled = (abs * index + halfRAY) / RAY;\\n\\n        return netScaledBalanceExternal > 0 ? absScaled : absScaled.neg();\\n    }\\n\\n    /// @dev getReserveNormalizedIncome returns a uint256, so we know that the return value here is\\n    /// always positive even though we are converting to a signed int\\n    function _getReserveNormalizedIncome(address underlyingAsset) private view returns (int256) {\\n        return\\n            SafeInt256.toInt(\\n                LibStorage.getLendingPool().lendingPool.getReserveNormalizedIncome(underlyingAsset)\\n            );\\n    }\\n}\"\r\n    },\r\n    \"contracts/internal/balances/protocols/CompoundHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./GenericToken.sol\\\";\\nimport \\\"../../../../interfaces/compound/CErc20Interface.sol\\\";\\nimport \\\"../../../../interfaces/compound/CEtherInterface.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../../global/Types.sol\\\";\\n\\nlibrary CompoundHandler {\\n    using SafeMath for uint256;\\n\\n    // Return code for cTokens that represents no error\\n    uint256 internal constant COMPOUND_RETURN_CODE_NO_ERROR = 0;\\n\\n    function mintCETH(Token memory token, uint256 underlyingAmountExternal) internal {\\n        // Reverts on error\\n        CEtherInterface(token.tokenAddress).mint{value: underlyingAmountExternal}();\\n    }\\n\\n    function mint(Token memory token, uint256 underlyingAmountExternal) internal {\\n        uint256 success = CErc20Interface(token.tokenAddress).mint(underlyingAmountExternal);\\n        require(success == COMPOUND_RETURN_CODE_NO_ERROR, \\\"Mint\\\");\\n    }\\n\\n    function redeemCETH(\\n        Token memory assetToken,\\n        address account,\\n        uint256 assetAmountExternal\\n    ) internal returns (uint256 underlyingAmountExternal) {\\n        // Although the contract should never end with any ETH or underlying token balances, we still do this\\n        // starting and ending check in the case that tokens are accidentally sent to the contract address. They\\n        // will not be sent to some lucky address in a windfall.\\n        uint256 startingBalance = address(this).balance;\\n\\n        uint256 success = CErc20Interface(assetToken.tokenAddress).redeem(assetAmountExternal);\\n        require(success == COMPOUND_RETURN_CODE_NO_ERROR, \\\"Redeem\\\");\\n\\n        uint256 endingBalance = address(this).balance;\\n\\n        underlyingAmountExternal = endingBalance.sub(startingBalance);\\n\\n        // Withdraws the underlying amount out to the destination account\\n        GenericToken.transferNativeTokenOut(account, underlyingAmountExternal);\\n    }\\n\\n    function redeem(\\n        Token memory assetToken,\\n        Token memory underlyingToken,\\n        address account,\\n        uint256 assetAmountExternal\\n    ) internal returns (uint256 underlyingAmountExternal) {\\n        // Although the contract should never end with any ETH or underlying token balances, we still do this\\n        // starting and ending check in the case that tokens are accidentally sent to the contract address. They\\n        // will not be sent to some lucky address in a windfall.\\n        uint256 startingBalance = GenericToken.checkBalanceViaSelector(underlyingToken.tokenAddress, address(this), GenericToken.defaultBalanceOfSelector);\\n\\n        uint256 success = CErc20Interface(assetToken.tokenAddress).redeem(assetAmountExternal);\\n        require(success == COMPOUND_RETURN_CODE_NO_ERROR, \\\"Redeem\\\");\\n\\n        uint256 endingBalance = GenericToken.checkBalanceViaSelector(underlyingToken.tokenAddress, address(this), GenericToken.defaultBalanceOfSelector);\\n\\n        underlyingAmountExternal = endingBalance.sub(startingBalance);\\n\\n        // Withdraws the underlying amount out to the destination account\\n        GenericToken.safeTransferOut(underlyingToken.tokenAddress, account, underlyingAmountExternal);\\n    }\\n}\"\r\n    },\r\n    \"contracts/internal/balances/protocols/GenericToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\n\\nimport \\\"../../../../interfaces/IEIP20NonStandard.sol\\\";\\n\\nlibrary GenericToken {\\n    bytes4 internal constant defaultBalanceOfSelector = IEIP20NonStandard.balanceOf.selector;\\n\\n    /**\\n     * @dev Manually checks the balance of an account using the method selector. Reduces bytecode size and allows\\n     * for overriding the balanceOf selector to use scaledBalanceOf for aTokens\\n     */\\n    function checkBalanceViaSelector(\\n        address token,\\n        address account,\\n        bytes4 balanceOfSelector\\n    ) internal view returns (uint256 balance) {\\n        (bool success, bytes memory returnData) = token.staticcall(abi.encodeWithSelector(balanceOfSelector, account));\\n        require(success);\\n        (balance) = abi.decode(returnData, (uint256));\\n    }\\n\\n    function transferNativeTokenOut(\\n        address account,\\n        uint256 amount\\n    ) internal {\\n        // This does not work with contracts, but is reentrancy safe. If contracts want to withdraw underlying\\n        // ETH they will have to withdraw the cETH token and then redeem it manually.\\n        payable(account).transfer(amount);\\n    }\\n\\n    function safeTransferOut(\\n        address token,\\n        address account,\\n        uint256 amount\\n    ) internal {\\n        IEIP20NonStandard(token).transfer(account, amount);\\n        checkReturnCode();\\n    }\\n\\n    function safeTransferIn(\\n        address token,\\n        address account,\\n        uint256 amount\\n    ) internal {\\n        IEIP20NonStandard(token).transferFrom(account, address(this), amount);\\n        checkReturnCode();\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        IEIP20NonStandard(token).transferFrom(from, to, amount);\\n        checkReturnCode();\\n    }\\n\\n    function checkReturnCode() internal pure {\\n        bool success;\\n        uint256[1] memory result;\\n        assembly {\\n            switch returndatasize()\\n                case 0 {\\n                    // This is a non-standard ERC-20\\n                    success := 1 // set success to true\\n                }\\n                case 32 {\\n                    // This is a compliant ERC-20\\n                    returndatacopy(result, 0, 32)\\n                    success := mload(result) // Set `success = returndata` of external call\\n                }\\n                default {\\n                    // This is an excessively non-compliant ERC-20, revert.\\n                    revert(0, 0)\\n                }\\n        }\\n\\n        require(success, \\\"ERC20\\\");\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/internal/balances/TokenHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"../../global/LibStorage.sol\\\";\\nimport \\\"../../global/Types.sol\\\";\\nimport \\\"../../global/Constants.sol\\\";\\nimport \\\"../../global/Deployments.sol\\\";\\nimport \\\"./protocols/AaveHandler.sol\\\";\\nimport \\\"./protocols/CompoundHandler.sol\\\";\\nimport \\\"./protocols/GenericToken.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\n/// @notice Handles all external token transfers and events\\nlibrary TokenHandler {\\n    using SafeInt256 for int256;\\n    using SafeMath for uint256;\\n\\n    function setMaxCollateralBalance(uint256 currencyId, uint72 maxCollateralBalance) internal {\\n        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();\\n        TokenStorage storage tokenStorage = store[currencyId][false];\\n        tokenStorage.maxCollateralBalance = maxCollateralBalance;\\n    } \\n\\n    function getAssetToken(uint256 currencyId) internal view returns (Token memory) {\\n        return _getToken(currencyId, false);\\n    }\\n\\n    function getUnderlyingToken(uint256 currencyId) internal view returns (Token memory) {\\n        return _getToken(currencyId, true);\\n    }\\n\\n    /// @notice Gets token data for a particular currency id, if underlying is set to true then returns\\n    /// the underlying token. (These may not always exist)\\n    function _getToken(uint256 currencyId, bool underlying) private view returns (Token memory) {\\n        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();\\n        TokenStorage storage tokenStorage = store[currencyId][underlying];\\n\\n        return\\n            Token({\\n                tokenAddress: tokenStorage.tokenAddress,\\n                hasTransferFee: tokenStorage.hasTransferFee,\\n                // No overflow, restricted on storage\\n                decimals: int256(10**tokenStorage.decimalPlaces),\\n                tokenType: tokenStorage.tokenType,\\n                maxCollateralBalance: tokenStorage.maxCollateralBalance\\n            });\\n    }\\n\\n    /// @notice Sets a token for a currency id.\\n    function setToken(\\n        uint256 currencyId,\\n        bool underlying,\\n        TokenStorage memory tokenStorage\\n    ) internal {\\n        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();\\n\\n        if (tokenStorage.tokenType == TokenType.Ether && currencyId == Constants.ETH_CURRENCY_ID) {\\n            // Hardcoded parameters for ETH just to make sure we don't get it wrong.\\n            TokenStorage storage ts = store[currencyId][true];\\n            ts.tokenAddress = address(0);\\n            ts.hasTransferFee = false;\\n            ts.tokenType = TokenType.Ether;\\n            ts.decimalPlaces = Constants.ETH_DECIMAL_PLACES;\\n            ts.maxCollateralBalance = 0;\\n\\n            return;\\n        }\\n\\n        // Check token address\\n        require(tokenStorage.tokenAddress != address(0), \\\"TH: address is zero\\\");\\n        // Once a token is set we cannot override it. In the case that we do need to do change a token address\\n        // then we should explicitly upgrade this method to allow for a token to be changed.\\n        Token memory token = _getToken(currencyId, underlying);\\n        require(\\n            token.tokenAddress == tokenStorage.tokenAddress || token.tokenAddress == address(0),\\n            \\\"TH: token cannot be reset\\\"\\n        );\\n\\n        require(0 < tokenStorage.decimalPlaces \\n            && tokenStorage.decimalPlaces <= Constants.MAX_DECIMAL_PLACES, \\\"TH: invalid decimals\\\");\\n\\n        // Validate token type\\n        require(tokenStorage.tokenType != TokenType.Ether); // dev: ether can only be set once\\n        if (underlying) {\\n            // Underlying tokens cannot have max collateral balances, the contract only has a balance temporarily\\n            // during mint and redeem actions.\\n            require(tokenStorage.maxCollateralBalance == 0); // dev: underlying cannot have max collateral balance\\n            require(tokenStorage.tokenType == TokenType.UnderlyingToken); // dev: underlying token inconsistent\\n        } else {\\n            require(tokenStorage.tokenType != TokenType.UnderlyingToken); // dev: underlying token inconsistent\\n        }\\n\\n        if (tokenStorage.tokenType == TokenType.cToken || tokenStorage.tokenType == TokenType.aToken) {\\n            // Set the approval for the underlying so that we can mint cTokens or aTokens\\n            Token memory underlyingToken = getUnderlyingToken(currencyId);\\n\\n            // cTokens call transfer from the tokenAddress, but aTokens use the LendingPool\\n            // to initiate all transfers\\n            address approvalAddress = tokenStorage.tokenType == TokenType.cToken ?\\n                tokenStorage.tokenAddress :\\n                address(LibStorage.getLendingPool().lendingPool);\\n\\n            // ERC20 tokens should return true on success for an approval, but Tether\\n            // does not return a value here so we use the NonStandard interface here to\\n            // check that the approval was successful.\\n            IEIP20NonStandard(underlyingToken.tokenAddress).approve(\\n                approvalAddress,\\n                type(uint256).max\\n            );\\n            GenericToken.checkReturnCode();\\n        }\\n\\n        store[currencyId][underlying] = tokenStorage;\\n    }\\n\\n    /**\\n     * @notice If a token is mintable then will mint it. At this point we expect to have the underlying\\n     * balance in the contract already.\\n     * @param assetToken the asset token to mint\\n     * @param underlyingAmountExternal the amount of underlying to transfer to the mintable token\\n     * @return the amount of asset tokens minted, will always be a positive integer\\n     */\\n    function mint(Token memory assetToken, uint16 currencyId, uint256 underlyingAmountExternal) internal returns (int256) {\\n        // aTokens return the principal plus interest value when calling the balanceOf selector. We cannot use this\\n        // value in internal accounting since it will not allow individual users to accrue aToken interest. Use the\\n        // scaledBalanceOf function call instead for internal accounting.\\n        bytes4 balanceOfSelector = assetToken.tokenType == TokenType.aToken ?\\n            AaveHandler.scaledBalanceOfSelector :\\n            GenericToken.defaultBalanceOfSelector;\\n        \\n        uint256 startingBalance = GenericToken.checkBalanceViaSelector(assetToken.tokenAddress, address(this), balanceOfSelector);\\n\\n        if (assetToken.tokenType == TokenType.aToken) {\\n            Token memory underlyingToken = getUnderlyingToken(currencyId);\\n            AaveHandler.mint(underlyingToken, underlyingAmountExternal);\\n        } else if (assetToken.tokenType == TokenType.cToken) {\\n            CompoundHandler.mint(assetToken, underlyingAmountExternal);\\n        } else if (assetToken.tokenType == TokenType.cETH) {\\n            // NOTE: current deployed contracts rely on msg.value but this has been updated for\\n            // strategy vaults.\\n            CompoundHandler.mintCETH(assetToken, underlyingAmountExternal);\\n        } else {\\n            revert(); // dev: non mintable token\\n        }\\n\\n        uint256 endingBalance = GenericToken.checkBalanceViaSelector(assetToken.tokenAddress, address(this), balanceOfSelector);\\n        // This is the starting and ending balance in external precision\\n        return SafeInt256.toInt(endingBalance.sub(startingBalance));\\n    }\\n\\n    /**\\n     * @notice If a token is redeemable to underlying will redeem it and transfer the underlying balance\\n     * to the account\\n     * @param assetToken asset token to redeem\\n     * @param currencyId the currency id of the token\\n     * @param account account to transfer the underlying to\\n     * @param assetAmountExternal the amount to transfer in asset token denomination and external precision\\n     * @return the actual amount of underlying tokens transferred. this is used as a return value back to the\\n     * user, is not used for internal accounting purposes\\n     */\\n    function redeem(\\n        Token memory assetToken,\\n        uint256 currencyId,\\n        address account,\\n        uint256 assetAmountExternal\\n    ) internal returns (int256) {\\n        uint256 transferAmount;\\n        if (assetToken.tokenType == TokenType.cETH) {\\n            transferAmount = CompoundHandler.redeemCETH(assetToken, account, assetAmountExternal);\\n        } else {\\n            Token memory underlyingToken = getUnderlyingToken(currencyId);\\n            if (assetToken.tokenType == TokenType.aToken) {\\n                transferAmount = AaveHandler.redeem(underlyingToken, account, assetAmountExternal);\\n            } else if (assetToken.tokenType == TokenType.cToken) {\\n                transferAmount = CompoundHandler.redeem(assetToken, underlyingToken, account, assetAmountExternal);\\n            } else {\\n                revert(); // dev: non redeemable token\\n            }\\n        }\\n        \\n        // Use the negative value here to signify that assets have left the protocol\\n        return SafeInt256.toInt(transferAmount).neg();\\n    }\\n\\n    /// @notice Handles transfers into and out of the system denominated in the external token decimal\\n    /// precision.\\n    function transfer(\\n        Token memory token,\\n        address account,\\n        uint256 currencyId,\\n        int256 netTransferExternal\\n    ) internal returns (int256 actualTransferExternal) {\\n        // This will be true in all cases except for deposits where the token has transfer fees. For\\n        // aTokens this value is set before convert from scaled balances to principal plus interest\\n        actualTransferExternal = netTransferExternal;\\n\\n        if (token.tokenType == TokenType.aToken) {\\n            Token memory underlyingToken = getUnderlyingToken(currencyId);\\n            // aTokens need to be converted when we handle the transfer since the external balance format\\n            // is not the same as the internal balance format that we use\\n            netTransferExternal = AaveHandler.convertFromScaledBalanceExternal(\\n                underlyingToken.tokenAddress,\\n                netTransferExternal\\n            );\\n        }\\n\\n        if (netTransferExternal > 0) {\\n            // Deposits must account for transfer fees.\\n            int256 netDeposit = _deposit(token, account, uint256(netTransferExternal));\\n            // If an aToken has a transfer fee this will still return a balance figure\\n            // in scaledBalanceOf terms due to the selector\\n            if (token.hasTransferFee) actualTransferExternal = netDeposit;\\n        } else if (token.tokenType == TokenType.Ether) {\\n            // netTransferExternal can only be negative or zero at this point\\n            GenericToken.transferNativeTokenOut(account, uint256(netTransferExternal.neg()));\\n        } else {\\n            GenericToken.safeTransferOut(\\n                token.tokenAddress,\\n                account,\\n                // netTransferExternal is zero or negative here\\n                uint256(netTransferExternal.neg())\\n            );\\n        }\\n    }\\n\\n    /// @notice Handles token deposits into Notional. If there is a transfer fee then we must\\n    /// calculate the net balance after transfer. Amounts are denominated in the destination token's\\n    /// precision.\\n    function _deposit(\\n        Token memory token,\\n        address account,\\n        uint256 amount\\n    ) private returns (int256) {\\n        uint256 startingBalance;\\n        uint256 endingBalance;\\n        bytes4 balanceOfSelector = token.tokenType == TokenType.aToken ?\\n            AaveHandler.scaledBalanceOfSelector :\\n            GenericToken.defaultBalanceOfSelector;\\n\\n        if (token.hasTransferFee) {\\n            startingBalance = GenericToken.checkBalanceViaSelector(token.tokenAddress, address(this), balanceOfSelector);\\n        }\\n\\n        GenericToken.safeTransferIn(token.tokenAddress, account, amount);\\n\\n        if (token.hasTransferFee || token.maxCollateralBalance > 0) {\\n            // If aTokens have a max collateral balance then it will be applied against the scaledBalanceOf. This is probably\\n            // the correct behavior because if collateral accrues interest over time we should not somehow go over the\\n            // maxCollateralBalance due to the passage of time.\\n            endingBalance = GenericToken.checkBalanceViaSelector(token.tokenAddress, address(this), balanceOfSelector);\\n        }\\n\\n        if (token.maxCollateralBalance > 0) {\\n            int256 internalPrecisionBalance = convertToInternal(token, SafeInt256.toInt(endingBalance));\\n            // Max collateral balance is stored as uint72, no overflow\\n            require(internalPrecisionBalance <= SafeInt256.toInt(token.maxCollateralBalance)); // dev: over max collateral balance\\n        }\\n\\n        // Math is done in uint inside these statements and will revert on negative\\n        if (token.hasTransferFee) {\\n            return SafeInt256.toInt(endingBalance.sub(startingBalance));\\n        } else {\\n            return SafeInt256.toInt(amount);\\n        }\\n    }\\n\\n    function convertToInternal(Token memory token, int256 amount) internal pure returns (int256) {\\n        // If token decimals > INTERNAL_TOKEN_PRECISION:\\n        //  on deposit: resulting dust will accumulate to protocol\\n        //  on withdraw: protocol may lose dust amount. However, withdraws are only calculated based\\n        //    on a conversion from internal token precision to external token precision so therefore dust\\n        //    amounts cannot be specified for withdraws.\\n        // If token decimals < INTERNAL_TOKEN_PRECISION then this will add zeros to the\\n        // end of amount and will not result in dust.\\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\\n        return amount.mul(Constants.INTERNAL_TOKEN_PRECISION).div(token.decimals);\\n    }\\n\\n    function convertToExternal(Token memory token, int256 amount) internal pure returns (int256) {\\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\\n        // If token decimals > INTERNAL_TOKEN_PRECISION then this will increase amount\\n        // by adding a number of zeros to the end and will not result in dust.\\n        // If token decimals < INTERNAL_TOKEN_PRECISION:\\n        //  on deposit: Deposits are specified in external token precision and there is no loss of precision when\\n        //      tokens are converted from external to internal precision\\n        //  on withdraw: this calculation will round down such that the protocol retains the residual cash balance\\n        return amount.mul(token.decimals).div(Constants.INTERNAL_TOKEN_PRECISION);\\n    }\\n\\n    /// @notice Converts a token to an underlying external amount with adjustments for rounding errors when depositing\\n    function convertToUnderlyingExternalWithAdjustment(\\n        Token memory token,\\n        int256 underlyingInternalAmount\\n    ) internal pure returns (int256 underlyingExternalAmount) {\\n        if (token.decimals < Constants.INTERNAL_TOKEN_PRECISION) {\\n            // If external < 8, we could truncate down and cause an off by one error, for example we need\\n            // 1.00000011 cash and we deposit only 1.000000, missing 11 units. Therefore, we add a unit at the\\n            // lower precision (external) to get around off by one errors\\n            underlyingExternalAmount = convertToExternal(token, underlyingInternalAmount).add(1);\\n        } else {\\n            // If external > 8, we may not mint enough asset tokens because in the case of 1e18 precision \\n            // an off by 1 error at 1e8 precision is 1e10 units of the underlying token. In this case we\\n            // add 1 at the internal precision which has the effect of rounding up by 1e10\\n            underlyingExternalAmount = convertToExternal(token, underlyingInternalAmount.add(1));\\n        }\\n    }\\n\\n    /// @notice Converts and asset token value to it's native external precision. Used to handle aToken internal to\\n    /// rebasing native external precision.\\n    function convertAssetInternalToNativeExternal(\\n        Token memory assetToken,\\n        uint16 currencyId,\\n        int256 assetInternalAmount\\n    ) internal view returns (int256 assetNativeExternal) {\\n        assetNativeExternal = convertToExternal(assetToken, assetInternalAmount);\\n\\n        if (assetToken.tokenType == TokenType.aToken) {\\n            // Special handling for aTokens, we use scaled balance internally\\n            Token memory underlying = getUnderlyingToken(currencyId);\\n            assetNativeExternal = AaveHandler.convertFromScaledBalanceExternal(\\n                underlying.tokenAddress, assetNativeExternal\\n            );\\n        }\\n    }\\n\\n    /// @notice Convenience method for getting the balance using a token object\\n    function balanceOf(Token memory token, address account) internal view returns (uint256) {\\n        if (token.tokenType == TokenType.Ether) {\\n            return account.balance;\\n        } else {\\n            return IERC20(token.tokenAddress).balanceOf(account);\\n        }\\n    }\\n\\n    function transferIncentive(address account, uint256 tokensToTransfer) internal {\\n        GenericToken.safeTransferOut(Deployments.NOTE_TOKEN_ADDRESS, account, tokensToTransfer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/markets/AssetRate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../../global/Types.sol\\\";\\nimport \\\"../../global/LibStorage.sol\\\";\\nimport \\\"../../global/Constants.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"../../../interfaces/notional/AssetRateAdapter.sol\\\";\\n\\nlibrary AssetRate {\\n    using SafeInt256 for int256;\\n    event SetSettlementRate(uint256 indexed currencyId, uint256 indexed maturity, uint128 rate);\\n\\n    // Asset rates are in 1e18 decimals (cToken exchange rates), internal balances\\n    // are in 1e8 decimals. Therefore we leave this as 1e18 / 1e8 = 1e10\\n    int256 private constant ASSET_RATE_DECIMAL_DIFFERENCE = 1e10;\\n\\n    /// @notice Converts an internal asset cash value to its underlying token value.\\n    /// @param ar exchange rate object between asset and underlying\\n    /// @param assetBalance amount to convert to underlying\\n    function convertToUnderlying(AssetRateParameters memory ar, int256 assetBalance)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        // Calculation here represents:\\n        // rate * balance * internalPrecision / rateDecimals * underlyingPrecision\\n        int256 underlyingBalance = ar.rate\\n            .mul(assetBalance)\\n            .div(ASSET_RATE_DECIMAL_DIFFERENCE)\\n            .div(ar.underlyingDecimals);\\n\\n        return underlyingBalance;\\n    }\\n\\n    /// @notice Converts an internal underlying cash value to its asset cash value\\n    /// @param ar exchange rate object between asset and underlying\\n    /// @param underlyingBalance amount to convert to asset cash, denominated in internal token precision\\n    function convertFromUnderlying(AssetRateParameters memory ar, int256 underlyingBalance)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        // Calculation here represents:\\n        // rateDecimals * balance * underlyingPrecision / rate * internalPrecision\\n        int256 assetBalance = underlyingBalance\\n            .mul(ASSET_RATE_DECIMAL_DIFFERENCE)\\n            .mul(ar.underlyingDecimals)\\n            .div(ar.rate);\\n\\n        return assetBalance;\\n    }\\n\\n    /// @notice Returns the current per block supply rate, is used when calculating oracle rates\\n    /// for idiosyncratic fCash with a shorter duration than the 3 month maturity.\\n    function getSupplyRate(AssetRateParameters memory ar) internal view returns (uint256) {\\n        // If the rate oracle is not set, the asset is not interest bearing and has an oracle rate of zero.\\n        if (address(ar.rateOracle) == address(0)) return 0;\\n\\n        uint256 rate = ar.rateOracle.getAnnualizedSupplyRate();\\n        // Zero supply rate is valid since this is an interest rate, we do not divide by\\n        // the supply rate so we do not get div by zero errors.\\n        require(rate >= 0); // dev: invalid supply rate\\n\\n        return rate;\\n    }\\n\\n    function _getAssetRateStorage(uint256 currencyId)\\n        private\\n        view\\n        returns (AssetRateAdapter rateOracle, uint8 underlyingDecimalPlaces)\\n    {\\n        mapping(uint256 => AssetRateStorage) storage store = LibStorage.getAssetRateStorage();\\n        AssetRateStorage storage ar = store[currencyId];\\n        rateOracle = AssetRateAdapter(ar.rateOracle);\\n        underlyingDecimalPlaces = ar.underlyingDecimalPlaces;\\n    }\\n\\n    /// @notice Gets an asset rate using a view function, does not accrue interest so the\\n    /// exchange rate will not be up to date. Should only be used for non-stateful methods\\n    function _getAssetRateView(uint256 currencyId)\\n        private\\n        view\\n        returns (\\n            int256,\\n            AssetRateAdapter,\\n            uint8\\n        )\\n    {\\n        (AssetRateAdapter rateOracle, uint8 underlyingDecimalPlaces) = _getAssetRateStorage(currencyId);\\n\\n        int256 rate;\\n        if (address(rateOracle) == address(0)) {\\n            // If no rate oracle is set, then set this to the identity\\n            rate = ASSET_RATE_DECIMAL_DIFFERENCE;\\n            // This will get raised to 10^x and return 1, will not end up with div by zero\\n            underlyingDecimalPlaces = 0;\\n        } else {\\n            rate = rateOracle.getExchangeRateView();\\n            require(rate > 0); // dev: invalid exchange rate\\n        }\\n\\n        return (rate, rateOracle, underlyingDecimalPlaces);\\n    }\\n\\n    /// @notice Gets an asset rate using a stateful function, accrues interest so the\\n    /// exchange rate will be up to date for the current block.\\n    function _getAssetRateStateful(uint256 currencyId)\\n        private\\n        returns (\\n            int256,\\n            AssetRateAdapter,\\n            uint8\\n        )\\n    {\\n        (AssetRateAdapter rateOracle, uint8 underlyingDecimalPlaces) = _getAssetRateStorage(currencyId);\\n\\n        int256 rate;\\n        if (address(rateOracle) == address(0)) {\\n            // If no rate oracle is set, then set this to the identity\\n            rate = ASSET_RATE_DECIMAL_DIFFERENCE;\\n            // This will get raised to 10^x and return 1, will not end up with div by zero\\n            underlyingDecimalPlaces = 0;\\n        } else {\\n            rate = rateOracle.getExchangeRateStateful();\\n            require(rate > 0); // dev: invalid exchange rate\\n        }\\n\\n        return (rate, rateOracle, underlyingDecimalPlaces);\\n    }\\n\\n    /// @notice Returns an asset rate object using the view method\\n    function buildAssetRateView(uint256 currencyId)\\n        internal\\n        view\\n        returns (AssetRateParameters memory)\\n    {\\n        (int256 rate, AssetRateAdapter rateOracle, uint8 underlyingDecimalPlaces) =\\n            _getAssetRateView(currencyId);\\n\\n        return\\n            AssetRateParameters({\\n                rateOracle: rateOracle,\\n                rate: rate,\\n                // No overflow, restricted on storage\\n                underlyingDecimals: int256(10**underlyingDecimalPlaces)\\n            });\\n    }\\n\\n    /// @notice Returns an asset rate object using the stateful method\\n    function buildAssetRateStateful(uint256 currencyId)\\n        internal\\n        returns (AssetRateParameters memory)\\n    {\\n        (int256 rate, AssetRateAdapter rateOracle, uint8 underlyingDecimalPlaces) =\\n            _getAssetRateStateful(currencyId);\\n\\n        return\\n            AssetRateParameters({\\n                rateOracle: rateOracle,\\n                rate: rate,\\n                // No overflow, restricted on storage\\n                underlyingDecimals: int256(10**underlyingDecimalPlaces)\\n            });\\n    }\\n\\n    /// @dev Gets a settlement rate object\\n    function _getSettlementRateStorage(uint256 currencyId, uint256 maturity)\\n        private\\n        view\\n        returns (\\n            int256 settlementRate,\\n            uint8 underlyingDecimalPlaces\\n        )\\n    {\\n        mapping(uint256 => mapping(uint256 => SettlementRateStorage)) storage store = LibStorage.getSettlementRateStorage();\\n        SettlementRateStorage storage rateStorage = store[currencyId][maturity];\\n        settlementRate = rateStorage.settlementRate;\\n        underlyingDecimalPlaces = rateStorage.underlyingDecimalPlaces;\\n    }\\n\\n    /// @notice Returns a settlement rate object using the view method\\n    function buildSettlementRateView(uint256 currencyId, uint256 maturity)\\n        internal\\n        view\\n        returns (AssetRateParameters memory)\\n    {\\n        // prettier-ignore\\n        (\\n            int256 settlementRate,\\n            uint8 underlyingDecimalPlaces\\n        ) = _getSettlementRateStorage(currencyId, maturity);\\n\\n        // Asset exchange rates cannot be zero\\n        if (settlementRate == 0) {\\n            // If settlement rate has not been set then we need to fetch it\\n            // prettier-ignore\\n            (\\n                settlementRate,\\n                /* address */,\\n                underlyingDecimalPlaces\\n            ) = _getAssetRateView(currencyId);\\n        }\\n\\n        return AssetRateParameters(\\n            AssetRateAdapter(address(0)),\\n            settlementRate,\\n            // No overflow, restricted on storage\\n            int256(10**underlyingDecimalPlaces)\\n        );\\n    }\\n\\n    /// @notice Returns a settlement rate object and sets the rate if it has not been set yet\\n    function buildSettlementRateStateful(\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) internal returns (AssetRateParameters memory) {\\n        (int256 settlementRate, uint8 underlyingDecimalPlaces) =\\n            _getSettlementRateStorage(currencyId, maturity);\\n\\n        if (settlementRate == 0) {\\n            // Settlement rate has not yet been set, set it in this branch\\n            AssetRateAdapter rateOracle;\\n            // If rate oracle == 0 then this will return the identity settlement rate\\n            // prettier-ignore\\n            (\\n                settlementRate,\\n                rateOracle,\\n                underlyingDecimalPlaces\\n            ) = _getAssetRateStateful(currencyId);\\n\\n            if (address(rateOracle) != address(0)) {\\n                mapping(uint256 => mapping(uint256 => SettlementRateStorage)) storage store = LibStorage.getSettlementRateStorage();\\n                // Only need to set settlement rates when the rate oracle is set (meaning the asset token has\\n                // a conversion rate to an underlying). If not set then the asset cash always settles to underlying at a 1-1\\n                // rate since they are the same.\\n                require(0 < blockTime && maturity <= blockTime && blockTime <= type(uint40).max); // dev: settlement rate timestamp overflow\\n                require(0 < settlementRate && settlementRate <= type(uint128).max); // dev: settlement rate overflow\\n\\n                SettlementRateStorage storage rateStorage = store[currencyId][maturity];\\n                rateStorage.blockTime = uint40(blockTime);\\n                rateStorage.settlementRate = uint128(settlementRate);\\n                rateStorage.underlyingDecimalPlaces = underlyingDecimalPlaces;\\n                emit SetSettlementRate(currencyId, maturity, uint128(settlementRate));\\n            }\\n        }\\n\\n        return AssetRateParameters(\\n            AssetRateAdapter(address(0)),\\n            settlementRate,\\n            // No overflow, restricted on storage\\n            int256(10**underlyingDecimalPlaces)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/markets/CashGroup.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./Market.sol\\\";\\nimport \\\"./AssetRate.sol\\\";\\nimport \\\"./DateTime.sol\\\";\\nimport \\\"../../global/LibStorage.sol\\\";\\nimport \\\"../../global/Types.sol\\\";\\nimport \\\"../../global/Constants.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary CashGroup {\\n    using SafeMath for uint256;\\n    using SafeInt256 for int256;\\n    using AssetRate for AssetRateParameters;\\n    using Market for MarketParameters;\\n\\n    // Bit number references for each parameter in the 32 byte word (0-indexed)\\n    uint256 private constant MARKET_INDEX_BIT = 31;\\n    uint256 private constant RATE_ORACLE_TIME_WINDOW_BIT = 30;\\n    uint256 private constant TOTAL_FEE_BIT = 29;\\n    uint256 private constant RESERVE_FEE_SHARE_BIT = 28;\\n    uint256 private constant DEBT_BUFFER_BIT = 27;\\n    uint256 private constant FCASH_HAIRCUT_BIT = 26;\\n    uint256 private constant SETTLEMENT_PENALTY_BIT = 25;\\n    uint256 private constant LIQUIDATION_FCASH_HAIRCUT_BIT = 24;\\n    uint256 private constant LIQUIDATION_DEBT_BUFFER_BIT = 23;\\n    // 7 bytes allocated, one byte per market for the liquidity token haircut\\n    uint256 private constant LIQUIDITY_TOKEN_HAIRCUT_FIRST_BIT = 22;\\n    // 7 bytes allocated, one byte per market for the rate scalar\\n    uint256 private constant RATE_SCALAR_FIRST_BIT = 15;\\n\\n    // Offsets for the bytes of the different parameters\\n    uint256 private constant MARKET_INDEX = (31 - MARKET_INDEX_BIT) * 8;\\n    uint256 private constant RATE_ORACLE_TIME_WINDOW = (31 - RATE_ORACLE_TIME_WINDOW_BIT) * 8;\\n    uint256 private constant TOTAL_FEE = (31 - TOTAL_FEE_BIT) * 8;\\n    uint256 private constant RESERVE_FEE_SHARE = (31 - RESERVE_FEE_SHARE_BIT) * 8;\\n    uint256 private constant DEBT_BUFFER = (31 - DEBT_BUFFER_BIT) * 8;\\n    uint256 private constant FCASH_HAIRCUT = (31 - FCASH_HAIRCUT_BIT) * 8;\\n    uint256 private constant SETTLEMENT_PENALTY = (31 - SETTLEMENT_PENALTY_BIT) * 8;\\n    uint256 private constant LIQUIDATION_FCASH_HAIRCUT = (31 - LIQUIDATION_FCASH_HAIRCUT_BIT) * 8;\\n    uint256 private constant LIQUIDATION_DEBT_BUFFER = (31 - LIQUIDATION_DEBT_BUFFER_BIT) * 8;\\n    uint256 private constant LIQUIDITY_TOKEN_HAIRCUT = (31 - LIQUIDITY_TOKEN_HAIRCUT_FIRST_BIT) * 8;\\n    uint256 private constant RATE_SCALAR = (31 - RATE_SCALAR_FIRST_BIT) * 8;\\n\\n    /// @notice Returns the rate scalar scaled by time to maturity. The rate scalar multiplies\\n    /// the ln() portion of the liquidity curve as an inverse so it increases with time to\\n    /// maturity. The effect of the rate scalar on slippage must decrease with time to maturity.\\n    function getRateScalar(\\n        CashGroupParameters memory cashGroup,\\n        uint256 marketIndex,\\n        uint256 timeToMaturity\\n    ) internal pure returns (int256) {\\n        require(1 <= marketIndex && marketIndex <= cashGroup.maxMarketIndex); // dev: invalid market index\\n\\n        uint256 offset = RATE_SCALAR + 8 * (marketIndex - 1);\\n        int256 scalar = int256(uint8(uint256(cashGroup.data >> offset))) * Constants.RATE_PRECISION;\\n        int256 rateScalar =\\n            scalar.mul(int256(Constants.IMPLIED_RATE_TIME)).div(SafeInt256.toInt(timeToMaturity));\\n\\n        // Rate scalar is denominated in RATE_PRECISION, it is unlikely to underflow in the\\n        // division above.\\n        require(rateScalar > 0); // dev: rate scalar underflow\\n        return rateScalar;\\n    }\\n\\n    /// @notice Haircut on liquidity tokens to account for the risk associated with changes in the\\n    /// proportion of cash to fCash within the pool. This is set as a percentage less than or equal to 100.\\n    function getLiquidityHaircut(CashGroupParameters memory cashGroup, uint256 assetType)\\n        internal\\n        pure\\n        returns (uint8)\\n    {\\n        require(\\n            Constants.MIN_LIQUIDITY_TOKEN_INDEX <= assetType &&\\n            assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX\\n        ); // dev: liquidity haircut invalid asset type\\n        uint256 offset =\\n            LIQUIDITY_TOKEN_HAIRCUT + 8 * (assetType - Constants.MIN_LIQUIDITY_TOKEN_INDEX);\\n        return uint8(uint256(cashGroup.data >> offset));\\n    }\\n\\n    /// @notice Total trading fee denominated in RATE_PRECISION with basis point increments\\n    function getTotalFee(CashGroupParameters memory cashGroup) internal pure returns (uint256) {\\n        return uint256(uint8(uint256(cashGroup.data >> TOTAL_FEE))) * Constants.BASIS_POINT;\\n    }\\n\\n    /// @notice Percentage of the total trading fee that goes to the reserve\\n    function getReserveFeeShare(CashGroupParameters memory cashGroup)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        return uint8(uint256(cashGroup.data >> RESERVE_FEE_SHARE));\\n    }\\n\\n    /// @notice fCash haircut for valuation denominated in rate precision with five basis point increments\\n    function getfCashHaircut(CashGroupParameters memory cashGroup) internal pure returns (uint256) {\\n        return\\n            uint256(uint8(uint256(cashGroup.data >> FCASH_HAIRCUT))) * Constants.FIVE_BASIS_POINTS;\\n    }\\n\\n    /// @notice fCash debt buffer for valuation denominated in rate precision with five basis point increments\\n    function getDebtBuffer(CashGroupParameters memory cashGroup) internal pure returns (uint256) {\\n        return uint256(uint8(uint256(cashGroup.data >> DEBT_BUFFER))) * Constants.FIVE_BASIS_POINTS;\\n    }\\n\\n    /// @notice Time window factor for the rate oracle denominated in seconds with five minute increments.\\n    function getRateOracleTimeWindow(CashGroupParameters memory cashGroup)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        // This is denominated in 5 minute increments in storage\\n        return uint256(uint8(uint256(cashGroup.data >> RATE_ORACLE_TIME_WINDOW))) * Constants.FIVE_MINUTES;\\n    }\\n\\n    /// @notice Penalty rate for settling cash debts denominated in basis points\\n    function getSettlementPenalty(CashGroupParameters memory cashGroup)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return\\n            uint256(uint8(uint256(cashGroup.data >> SETTLEMENT_PENALTY))) * Constants.FIVE_BASIS_POINTS;\\n    }\\n\\n    /// @notice Haircut for positive fCash during liquidation denominated rate precision\\n    /// with five basis point increments\\n    function getLiquidationfCashHaircut(CashGroupParameters memory cashGroup)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return\\n            uint256(uint8(uint256(cashGroup.data >> LIQUIDATION_FCASH_HAIRCUT))) * Constants.FIVE_BASIS_POINTS;\\n    }\\n\\n    /// @notice Haircut for negative fCash during liquidation denominated rate precision\\n    /// with five basis point increments\\n    function getLiquidationDebtBuffer(CashGroupParameters memory cashGroup)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return\\n            uint256(uint8(uint256(cashGroup.data >> LIQUIDATION_DEBT_BUFFER))) * Constants.FIVE_BASIS_POINTS;\\n    }\\n\\n    function loadMarket(\\n        CashGroupParameters memory cashGroup,\\n        MarketParameters memory market,\\n        uint256 marketIndex,\\n        bool needsLiquidity,\\n        uint256 blockTime\\n    ) internal view {\\n        require(1 <= marketIndex && marketIndex <= cashGroup.maxMarketIndex, \\\"Invalid market\\\");\\n        uint256 maturity =\\n            DateTime.getReferenceTime(blockTime).add(DateTime.getTradedMarket(marketIndex));\\n\\n        market.loadMarket(\\n            cashGroup.currencyId,\\n            maturity,\\n            blockTime,\\n            needsLiquidity,\\n            getRateOracleTimeWindow(cashGroup)\\n        );\\n    }\\n\\n    /// @notice Returns the linear interpolation between two market rates. The formula is\\n    /// slope = (longMarket.oracleRate - shortMarket.oracleRate) / (longMarket.maturity - shortMarket.maturity)\\n    /// interpolatedRate = slope * (assetMaturity - shortMarket.maturity) + shortMarket.oracleRate\\n    function interpolateOracleRate(\\n        uint256 shortMaturity,\\n        uint256 longMaturity,\\n        uint256 shortRate,\\n        uint256 longRate,\\n        uint256 assetMaturity\\n    ) internal pure returns (uint256) {\\n        require(shortMaturity < assetMaturity); // dev: cash group interpolation error, short maturity\\n        require(assetMaturity < longMaturity); // dev: cash group interpolation error, long maturity\\n\\n        // It's possible that the rates are inverted where the short market rate > long market rate and\\n        // we will get an underflow here so we check for that\\n        if (longRate >= shortRate) {\\n            return\\n                (longRate - shortRate)\\n                    .mul(assetMaturity - shortMaturity)\\n                // No underflow here, checked above\\n                    .div(longMaturity - shortMaturity)\\n                    .add(shortRate);\\n        } else {\\n            // In this case the slope is negative so:\\n            // interpolatedRate = shortMarket.oracleRate - slope * (assetMaturity - shortMarket.maturity)\\n            // NOTE: this subtraction should never overflow, the linear interpolation between two points above zero\\n            // cannot go below zero\\n            return\\n                shortRate.sub(\\n                    // This is reversed to keep it it positive\\n                    (shortRate - longRate)\\n                        .mul(assetMaturity - shortMaturity)\\n                    // No underflow here, checked above\\n                        .div(longMaturity - shortMaturity)\\n                );\\n        }\\n    }\\n\\n    /// @dev Gets an oracle rate given any valid maturity.\\n    function calculateOracleRate(\\n        CashGroupParameters memory cashGroup,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) internal view returns (uint256) {\\n        (uint256 marketIndex, bool idiosyncratic) =\\n            DateTime.getMarketIndex(cashGroup.maxMarketIndex, maturity, blockTime);\\n        uint256 timeWindow = getRateOracleTimeWindow(cashGroup);\\n\\n        if (!idiosyncratic) {\\n            return Market.getOracleRate(cashGroup.currencyId, maturity, timeWindow, blockTime);\\n        } else {\\n            uint256 referenceTime = DateTime.getReferenceTime(blockTime);\\n            // DateTime.getMarketIndex returns the market that is past the maturity if idiosyncratic\\n            uint256 longMaturity = referenceTime.add(DateTime.getTradedMarket(marketIndex));\\n            uint256 longRate =\\n                Market.getOracleRate(cashGroup.currencyId, longMaturity, timeWindow, blockTime);\\n\\n            uint256 shortMaturity;\\n            uint256 shortRate;\\n            if (marketIndex == 1) {\\n                // In this case the short market is the annualized asset supply rate\\n                shortMaturity = blockTime;\\n                shortRate = cashGroup.assetRate.getSupplyRate();\\n            } else {\\n                // Minimum value for marketIndex here is 2\\n                shortMaturity = referenceTime.add(DateTime.getTradedMarket(marketIndex - 1));\\n\\n                shortRate = Market.getOracleRate(\\n                    cashGroup.currencyId,\\n                    shortMaturity,\\n                    timeWindow,\\n                    blockTime\\n                );\\n            }\\n\\n            return interpolateOracleRate(shortMaturity, longMaturity, shortRate, longRate, maturity);\\n        }\\n    }\\n\\n    function _getCashGroupStorageBytes(uint256 currencyId) private view returns (bytes32 data) {\\n        mapping(uint256 => bytes32) storage store = LibStorage.getCashGroupStorage();\\n        return store[currencyId];\\n    }\\n\\n    /// @dev Helper method for validating maturities in ERC1155Action\\n    function getMaxMarketIndex(uint256 currencyId) internal view returns (uint8) {\\n        bytes32 data = _getCashGroupStorageBytes(currencyId);\\n        return uint8(data[MARKET_INDEX_BIT]);\\n    }\\n\\n    /// @notice Checks all cash group settings for invalid values and sets them into storage\\n    function setCashGroupStorage(uint256 currencyId, CashGroupSettings calldata cashGroup)\\n        internal\\n    {\\n        // Due to the requirements of the yield curve we do not allow a cash group to have solely a 3 month market.\\n        // The reason is that borrowers will not have a further maturity to roll from their 3 month fixed to a 6 month\\n        // fixed. It also complicates the logic in the nToken initialization method. Additionally, we cannot have cash\\n        // groups with 0 market index, it has no effect.\\n        require(2 <= cashGroup.maxMarketIndex && cashGroup.maxMarketIndex <= Constants.MAX_TRADED_MARKET_INDEX,\\n            \\\"CG: invalid market index\\\"\\n        );\\n        require(\\n            cashGroup.reserveFeeShare <= Constants.PERCENTAGE_DECIMALS,\\n            \\\"CG: invalid reserve share\\\"\\n        );\\n        require(cashGroup.liquidityTokenHaircuts.length == cashGroup.maxMarketIndex);\\n        require(cashGroup.rateScalars.length == cashGroup.maxMarketIndex);\\n        // This is required so that fCash liquidation can proceed correctly\\n        require(cashGroup.liquidationfCashHaircut5BPS < cashGroup.fCashHaircut5BPS);\\n        require(cashGroup.liquidationDebtBuffer5BPS < cashGroup.debtBuffer5BPS);\\n\\n        // Market indexes cannot decrease or they will leave fCash assets stranded in the future with no valuation curve\\n        uint8 previousMaxMarketIndex = getMaxMarketIndex(currencyId);\\n        require(\\n            previousMaxMarketIndex <= cashGroup.maxMarketIndex,\\n            \\\"CG: market index cannot decrease\\\"\\n        );\\n\\n        // Per cash group settings\\n        bytes32 data =\\n            (bytes32(uint256(cashGroup.maxMarketIndex)) |\\n                (bytes32(uint256(cashGroup.rateOracleTimeWindow5Min)) << RATE_ORACLE_TIME_WINDOW) |\\n                (bytes32(uint256(cashGroup.totalFeeBPS)) << TOTAL_FEE) |\\n                (bytes32(uint256(cashGroup.reserveFeeShare)) << RESERVE_FEE_SHARE) |\\n                (bytes32(uint256(cashGroup.debtBuffer5BPS)) << DEBT_BUFFER) |\\n                (bytes32(uint256(cashGroup.fCashHaircut5BPS)) << FCASH_HAIRCUT) |\\n                (bytes32(uint256(cashGroup.settlementPenaltyRate5BPS)) << SETTLEMENT_PENALTY) |\\n                (bytes32(uint256(cashGroup.liquidationfCashHaircut5BPS)) <<\\n                    LIQUIDATION_FCASH_HAIRCUT) |\\n                (bytes32(uint256(cashGroup.liquidationDebtBuffer5BPS)) << LIQUIDATION_DEBT_BUFFER));\\n\\n        // Per market group settings\\n        for (uint256 i = 0; i < cashGroup.liquidityTokenHaircuts.length; i++) {\\n            require(\\n                cashGroup.liquidityTokenHaircuts[i] <= Constants.PERCENTAGE_DECIMALS,\\n                \\\"CG: invalid token haircut\\\"\\n            );\\n\\n            data =\\n                data |\\n                (bytes32(uint256(cashGroup.liquidityTokenHaircuts[i])) <<\\n                    (LIQUIDITY_TOKEN_HAIRCUT + i * 8));\\n        }\\n\\n        for (uint256 i = 0; i < cashGroup.rateScalars.length; i++) {\\n            // Causes a divide by zero error\\n            require(cashGroup.rateScalars[i] != 0, \\\"CG: invalid rate scalar\\\");\\n            data = data | (bytes32(uint256(cashGroup.rateScalars[i])) << (RATE_SCALAR + i * 8));\\n        }\\n\\n        mapping(uint256 => bytes32) storage store = LibStorage.getCashGroupStorage();\\n        store[currencyId] = data;\\n    }\\n\\n    /// @notice Deserialize the cash group storage bytes into a user friendly object\\n    function deserializeCashGroupStorage(uint256 currencyId)\\n        internal\\n        view\\n        returns (CashGroupSettings memory)\\n    {\\n        bytes32 data = _getCashGroupStorageBytes(currencyId);\\n        uint8 maxMarketIndex = uint8(data[MARKET_INDEX_BIT]);\\n        uint8[] memory tokenHaircuts = new uint8[](uint256(maxMarketIndex));\\n        uint8[] memory rateScalars = new uint8[](uint256(maxMarketIndex));\\n\\n        for (uint8 i = 0; i < maxMarketIndex; i++) {\\n            tokenHaircuts[i] = uint8(data[LIQUIDITY_TOKEN_HAIRCUT_FIRST_BIT - i]);\\n            rateScalars[i] = uint8(data[RATE_SCALAR_FIRST_BIT - i]);\\n        }\\n\\n        return\\n            CashGroupSettings({\\n                maxMarketIndex: maxMarketIndex,\\n                rateOracleTimeWindow5Min: uint8(data[RATE_ORACLE_TIME_WINDOW_BIT]),\\n                totalFeeBPS: uint8(data[TOTAL_FEE_BIT]),\\n                reserveFeeShare: uint8(data[RESERVE_FEE_SHARE_BIT]),\\n                debtBuffer5BPS: uint8(data[DEBT_BUFFER_BIT]),\\n                fCashHaircut5BPS: uint8(data[FCASH_HAIRCUT_BIT]),\\n                settlementPenaltyRate5BPS: uint8(data[SETTLEMENT_PENALTY_BIT]),\\n                liquidationfCashHaircut5BPS: uint8(data[LIQUIDATION_FCASH_HAIRCUT_BIT]),\\n                liquidationDebtBuffer5BPS: uint8(data[LIQUIDATION_DEBT_BUFFER_BIT]),\\n                liquidityTokenHaircuts: tokenHaircuts,\\n                rateScalars: rateScalars\\n            });\\n    }\\n\\n    function _buildCashGroup(uint16 currencyId, AssetRateParameters memory assetRate)\\n        private\\n        view\\n        returns (CashGroupParameters memory)\\n    {\\n        bytes32 data = _getCashGroupStorageBytes(currencyId);\\n        uint256 maxMarketIndex = uint8(data[MARKET_INDEX_BIT]);\\n\\n        return\\n            CashGroupParameters({\\n                currencyId: currencyId,\\n                maxMarketIndex: maxMarketIndex,\\n                assetRate: assetRate,\\n                data: data\\n            });\\n    }\\n\\n    /// @notice Builds a cash group using a view version of the asset rate\\n    function buildCashGroupView(uint16 currencyId)\\n        internal\\n        view\\n        returns (CashGroupParameters memory)\\n    {\\n        AssetRateParameters memory assetRate = AssetRate.buildAssetRateView(currencyId);\\n        return _buildCashGroup(currencyId, assetRate);\\n    }\\n\\n    /// @notice Builds a cash group using a stateful version of the asset rate\\n    function buildCashGroupStateful(uint16 currencyId)\\n        internal\\n        returns (CashGroupParameters memory)\\n    {\\n        AssetRateParameters memory assetRate = AssetRate.buildAssetRateStateful(currencyId);\\n        return _buildCashGroup(currencyId, assetRate);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/markets/DateTime.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../../global/Constants.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary DateTime {\\n    using SafeMath for uint256;\\n\\n    /// @notice Returns the current reference time which is how all the AMM dates are calculated.\\n    function getReferenceTime(uint256 blockTime) internal pure returns (uint256) {\\n        require(blockTime >= Constants.QUARTER);\\n        return blockTime - (blockTime % Constants.QUARTER);\\n    }\\n\\n    /// @notice Truncates a date to midnight UTC time\\n    function getTimeUTC0(uint256 time) internal pure returns (uint256) {\\n        require(time >= Constants.DAY);\\n        return time - (time % Constants.DAY);\\n    }\\n\\n    /// @notice These are the predetermined market offsets for trading\\n    /// @dev Markets are 1-indexed because the 0 index means that no markets are listed for the cash group.\\n    function getTradedMarket(uint256 index) internal pure returns (uint256) {\\n        if (index == 1) return Constants.QUARTER;\\n        if (index == 2) return 2 * Constants.QUARTER;\\n        if (index == 3) return Constants.YEAR;\\n        if (index == 4) return 2 * Constants.YEAR;\\n        if (index == 5) return 5 * Constants.YEAR;\\n        if (index == 6) return 10 * Constants.YEAR;\\n        if (index == 7) return 20 * Constants.YEAR;\\n\\n        revert(\\\"Invalid index\\\");\\n    }\\n\\n    /// @notice Determines if the maturity falls on one of the valid on chain market dates.\\n    function isValidMarketMaturity(\\n        uint256 maxMarketIndex,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) internal pure returns (bool) {\\n        require(maxMarketIndex > 0, \\\"CG: no markets listed\\\");\\n        require(maxMarketIndex <= Constants.MAX_TRADED_MARKET_INDEX, \\\"CG: market index bound\\\");\\n\\n        if (maturity % Constants.QUARTER != 0) return false;\\n        uint256 tRef = DateTime.getReferenceTime(blockTime);\\n\\n        for (uint256 i = 1; i <= maxMarketIndex; i++) {\\n            if (maturity == tRef.add(DateTime.getTradedMarket(i))) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @notice Determines if an idiosyncratic maturity is valid and returns the bit reference that is the case.\\n    function isValidMaturity(\\n        uint256 maxMarketIndex,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) internal pure returns (bool) {\\n        uint256 tRef = DateTime.getReferenceTime(blockTime);\\n        uint256 maxMaturity = tRef.add(DateTime.getTradedMarket(maxMarketIndex));\\n        // Cannot trade past max maturity\\n        if (maturity > maxMaturity) return false;\\n\\n        // prettier-ignore\\n        (/* */, bool isValid) = DateTime.getBitNumFromMaturity(blockTime, maturity);\\n        return isValid;\\n    }\\n\\n    /// @notice Returns the market index for a given maturity, if the maturity is idiosyncratic\\n    /// will return the nearest market index that is larger than the maturity.\\n    /// @return uint marketIndex, bool isIdiosyncratic\\n    function getMarketIndex(\\n        uint256 maxMarketIndex,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) internal pure returns (uint256, bool) {\\n        require(maxMarketIndex > 0, \\\"CG: no markets listed\\\");\\n        require(maxMarketIndex <= Constants.MAX_TRADED_MARKET_INDEX, \\\"CG: market index bound\\\");\\n        uint256 tRef = DateTime.getReferenceTime(blockTime);\\n\\n        for (uint256 i = 1; i <= maxMarketIndex; i++) {\\n            uint256 marketMaturity = tRef.add(DateTime.getTradedMarket(i));\\n            // If market matches then is not idiosyncratic\\n            if (marketMaturity == maturity) return (i, false);\\n            // Returns the market that is immediately greater than the maturity\\n            if (marketMaturity > maturity) return (i, true);\\n        }\\n\\n        revert(\\\"CG: no market found\\\");\\n    }\\n\\n    /// @notice Given a bit number and the reference time of the first bit, returns the bit number\\n    /// of a given maturity.\\n    /// @return bitNum and a true or false if the maturity falls on the exact bit\\n    function getBitNumFromMaturity(uint256 blockTime, uint256 maturity)\\n        internal\\n        pure\\n        returns (uint256, bool)\\n    {\\n        uint256 blockTimeUTC0 = getTimeUTC0(blockTime);\\n\\n        // Maturities must always divide days evenly\\n        if (maturity % Constants.DAY != 0) return (0, false);\\n        // Maturity cannot be in the past\\n        if (blockTimeUTC0 >= maturity) return (0, false);\\n\\n        // Overflow check done above\\n        // daysOffset has no remainders, checked above\\n        uint256 daysOffset = (maturity - blockTimeUTC0) / Constants.DAY;\\n\\n        // These if statements need to fall through to the next one\\n        if (daysOffset <= Constants.MAX_DAY_OFFSET) {\\n            return (daysOffset, true);\\n        } else if (daysOffset <= Constants.MAX_WEEK_OFFSET) {\\n            // (daysOffset - MAX_DAY_OFFSET) is the days overflow into the week portion, must be > 0\\n            // (blockTimeUTC0 % WEEK) / DAY is the offset into the week portion\\n            // This returns the offset from the previous max offset in days\\n            uint256 offsetInDays =\\n                daysOffset -\\n                    Constants.MAX_DAY_OFFSET +\\n                    (blockTimeUTC0 % Constants.WEEK) /\\n                    Constants.DAY;\\n            \\n            return (\\n                // This converts the offset in days to its corresponding bit position, truncating down\\n                // if it does not divide evenly into DAYS_IN_WEEK\\n                Constants.WEEK_BIT_OFFSET + offsetInDays / Constants.DAYS_IN_WEEK,\\n                (offsetInDays % Constants.DAYS_IN_WEEK) == 0\\n            );\\n        } else if (daysOffset <= Constants.MAX_MONTH_OFFSET) {\\n            uint256 offsetInDays =\\n                daysOffset -\\n                    Constants.MAX_WEEK_OFFSET +\\n                    (blockTimeUTC0 % Constants.MONTH) /\\n                    Constants.DAY;\\n\\n            return (\\n                Constants.MONTH_BIT_OFFSET + offsetInDays / Constants.DAYS_IN_MONTH,\\n                (offsetInDays % Constants.DAYS_IN_MONTH) == 0\\n            );\\n        } else if (daysOffset <= Constants.MAX_QUARTER_OFFSET) {\\n            uint256 offsetInDays =\\n                daysOffset -\\n                    Constants.MAX_MONTH_OFFSET +\\n                    (blockTimeUTC0 % Constants.QUARTER) /\\n                    Constants.DAY;\\n\\n            return (\\n                Constants.QUARTER_BIT_OFFSET + offsetInDays / Constants.DAYS_IN_QUARTER,\\n                (offsetInDays % Constants.DAYS_IN_QUARTER) == 0\\n            );\\n        }\\n\\n        // This is the maximum 1-indexed bit num, it is never valid because it is beyond the 20\\n        // year max maturity\\n        return (256, false);\\n    }\\n\\n    /// @notice Given a bit number and a block time returns the maturity that the bit number\\n    /// should reference. Bit numbers are one indexed.\\n    function getMaturityFromBitNum(uint256 blockTime, uint256 bitNum)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        require(bitNum != 0); // dev: cash group get maturity from bit num is zero\\n        require(bitNum <= 256); // dev: cash group get maturity from bit num overflow\\n        uint256 blockTimeUTC0 = getTimeUTC0(blockTime);\\n        uint256 firstBit;\\n\\n        if (bitNum <= Constants.WEEK_BIT_OFFSET) {\\n            return blockTimeUTC0 + bitNum * Constants.DAY;\\n        } else if (bitNum <= Constants.MONTH_BIT_OFFSET) {\\n            firstBit =\\n                blockTimeUTC0 +\\n                Constants.MAX_DAY_OFFSET * Constants.DAY -\\n                // This backs up to the day that is divisible by a week\\n                (blockTimeUTC0 % Constants.WEEK);\\n            return firstBit + (bitNum - Constants.WEEK_BIT_OFFSET) * Constants.WEEK;\\n        } else if (bitNum <= Constants.QUARTER_BIT_OFFSET) {\\n            firstBit =\\n                blockTimeUTC0 +\\n                Constants.MAX_WEEK_OFFSET * Constants.DAY -\\n                (blockTimeUTC0 % Constants.MONTH);\\n            return firstBit + (bitNum - Constants.MONTH_BIT_OFFSET) * Constants.MONTH;\\n        } else {\\n            firstBit =\\n                blockTimeUTC0 +\\n                Constants.MAX_MONTH_OFFSET * Constants.DAY -\\n                (blockTimeUTC0 % Constants.QUARTER);\\n            return firstBit + (bitNum - Constants.QUARTER_BIT_OFFSET) * Constants.QUARTER;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/markets/Market.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./AssetRate.sol\\\";\\nimport \\\"./CashGroup.sol\\\";\\nimport \\\"./DateTime.sol\\\";\\nimport \\\"../balances/BalanceHandler.sol\\\";\\nimport \\\"../../global/LibStorage.sol\\\";\\nimport \\\"../../global/Types.sol\\\";\\nimport \\\"../../global/Constants.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"../../math/ABDKMath64x64.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary Market {\\n    using SafeMath for uint256;\\n    using SafeInt256 for int256;\\n    using CashGroup for CashGroupParameters;\\n    using AssetRate for AssetRateParameters;\\n\\n    // Max positive value for a ABDK64x64 integer\\n    int256 private constant MAX64 = 0x7FFFFFFFFFFFFFFF;\\n\\n    /// @notice Add liquidity to a market, assuming that it is initialized. If not then\\n    /// this method will revert and the market must be initialized first.\\n    /// Return liquidityTokens and negative fCash to the portfolio\\n    function addLiquidity(MarketParameters memory market, int256 assetCash)\\n        internal\\n        returns (int256 liquidityTokens, int256 fCash)\\n    {\\n        require(market.totalLiquidity > 0, \\\"M: zero liquidity\\\");\\n        if (assetCash == 0) return (0, 0);\\n        require(assetCash > 0); // dev: negative asset cash\\n\\n        liquidityTokens = market.totalLiquidity.mul(assetCash).div(market.totalAssetCash);\\n        // No need to convert this to underlying, assetCash / totalAssetCash is a unitless proportion.\\n        fCash = market.totalfCash.mul(assetCash).div(market.totalAssetCash);\\n\\n        market.totalLiquidity = market.totalLiquidity.add(liquidityTokens);\\n        market.totalfCash = market.totalfCash.add(fCash);\\n        market.totalAssetCash = market.totalAssetCash.add(assetCash);\\n        _setMarketStorageForLiquidity(market);\\n        // Flip the sign to represent the LP's net position\\n        fCash = fCash.neg();\\n    }\\n\\n    /// @notice Remove liquidity from a market, assuming that it is initialized.\\n    /// Return assetCash and positive fCash to the portfolio\\n    function removeLiquidity(MarketParameters memory market, int256 tokensToRemove)\\n        internal\\n        returns (int256 assetCash, int256 fCash)\\n    {\\n        if (tokensToRemove == 0) return (0, 0);\\n        require(tokensToRemove > 0); // dev: negative tokens to remove\\n\\n        assetCash = market.totalAssetCash.mul(tokensToRemove).div(market.totalLiquidity);\\n        fCash = market.totalfCash.mul(tokensToRemove).div(market.totalLiquidity);\\n\\n        market.totalLiquidity = market.totalLiquidity.subNoNeg(tokensToRemove);\\n        market.totalfCash = market.totalfCash.subNoNeg(fCash);\\n        market.totalAssetCash = market.totalAssetCash.subNoNeg(assetCash);\\n\\n        _setMarketStorageForLiquidity(market);\\n    }\\n\\n    function executeTrade(\\n        MarketParameters memory market,\\n        CashGroupParameters memory cashGroup,\\n        int256 fCashToAccount,\\n        uint256 timeToMaturity,\\n        uint256 marketIndex\\n    ) internal returns (int256 netAssetCash) {\\n        int256 netAssetCashToReserve;\\n        (netAssetCash, netAssetCashToReserve) = calculateTrade(\\n            market,\\n            cashGroup,\\n            fCashToAccount,\\n            timeToMaturity,\\n            marketIndex\\n        );\\n\\n        if (netAssetCash != 0) {\\n            MarketStorage storage marketStorage = _getMarketStoragePointer(market);\\n            _setMarketStorage(\\n                marketStorage,\\n                market.totalfCash,\\n                market.totalAssetCash,\\n                market.lastImpliedRate,\\n                market.oracleRate,\\n                market.previousTradeTime\\n            );\\n            BalanceHandler.incrementFeeToReserve(cashGroup.currencyId, netAssetCashToReserve);\\n        }\\n    }\\n\\n    /// @notice Calculates the asset cash amount the results from trading fCashToAccount with the market. A positive\\n    /// fCashToAccount is equivalent of lending, a negative is borrowing. Updates the market state in memory.\\n    /// @param market the current market state\\n    /// @param cashGroup cash group configuration parameters\\n    /// @param fCashToAccount the fCash amount that will be deposited into the user's portfolio. The net change\\n    /// to the market is in the opposite direction.\\n    /// @param timeToMaturity number of seconds until maturity\\n    /// @return netAssetCash, netAssetCashToReserve\\n    function calculateTrade(\\n        MarketParameters memory market,\\n        CashGroupParameters memory cashGroup,\\n        int256 fCashToAccount,\\n        uint256 timeToMaturity,\\n        uint256 marketIndex\\n    ) internal view returns (int256, int256) {\\n        // We return false if there is not enough fCash to support this trade.\\n        // if fCashToAccount > 0 and totalfCash - fCashToAccount <= 0 then the trade will fail\\n        // if fCashToAccount < 0 and totalfCash > 0 then this will always pass\\n        if (market.totalfCash <= fCashToAccount) return (0, 0);\\n\\n        // Calculates initial rate factors for the trade\\n        (int256 rateScalar, int256 totalCashUnderlying, int256 rateAnchor) =\\n            getExchangeRateFactors(market, cashGroup, timeToMaturity, marketIndex);\\n\\n        // Calculates the exchange rate from cash to fCash before any liquidity fees\\n        // are applied\\n        int256 preFeeExchangeRate;\\n        {\\n            bool success;\\n            (preFeeExchangeRate, success) = _getExchangeRate(\\n                market.totalfCash,\\n                totalCashUnderlying,\\n                rateScalar,\\n                rateAnchor,\\n                fCashToAccount\\n            );\\n            if (!success) return (0, 0);\\n        }\\n\\n        // Given the exchange rate, returns the net cash amounts to apply to each of the\\n        // three relevant balances.\\n        (int256 netCashToAccount, int256 netCashToMarket, int256 netCashToReserve) =\\n            _getNetCashAmountsUnderlying(\\n                cashGroup,\\n                preFeeExchangeRate,\\n                fCashToAccount,\\n                timeToMaturity\\n            );\\n        // Signifies a failed net cash amount calculation\\n        if (netCashToAccount == 0) return (0, 0);\\n\\n        {\\n            // Set the new implied interest rate after the trade has taken effect, this\\n            // will be used to calculate the next trader's interest rate.\\n            market.totalfCash = market.totalfCash.subNoNeg(fCashToAccount);\\n            market.lastImpliedRate = getImpliedRate(\\n                market.totalfCash,\\n                totalCashUnderlying.add(netCashToMarket),\\n                rateScalar,\\n                rateAnchor,\\n                timeToMaturity\\n            );\\n\\n            // It's technically possible that the implied rate is actually exactly zero (or\\n            // more accurately the natural log rounds down to zero) but we will still fail\\n            // in this case. If this does happen we may assume that markets are not initialized.\\n            if (market.lastImpliedRate == 0) return (0, 0);\\n        }\\n\\n        return\\n            _setNewMarketState(\\n                market,\\n                cashGroup.assetRate,\\n                netCashToAccount,\\n                netCashToMarket,\\n                netCashToReserve\\n            );\\n    }\\n\\n    /// @notice Returns factors for calculating exchange rates\\n    /// @return\\n    ///    rateScalar: a scalar value in rate precision that defines the slope of the line\\n    ///    totalCashUnderlying: the converted asset cash to underlying cash for calculating\\n    ///    the exchange rates for the trade\\n    ///    rateAnchor: an offset from the x axis to maintain interest rate continuity over time\\n    function getExchangeRateFactors(\\n        MarketParameters memory market,\\n        CashGroupParameters memory cashGroup,\\n        uint256 timeToMaturity,\\n        uint256 marketIndex\\n    )\\n        internal\\n        pure\\n        returns (\\n            int256,\\n            int256,\\n            int256\\n        )\\n    {\\n        int256 rateScalar = cashGroup.getRateScalar(marketIndex, timeToMaturity);\\n        int256 totalCashUnderlying = cashGroup.assetRate.convertToUnderlying(market.totalAssetCash);\\n\\n        // This would result in a divide by zero\\n        if (market.totalfCash == 0 || totalCashUnderlying == 0) return (0, 0, 0);\\n\\n        // Get the rate anchor given the market state, this will establish the baseline for where\\n        // the exchange rate is set.\\n        int256 rateAnchor;\\n        {\\n            bool success;\\n            (rateAnchor, success) = _getRateAnchor(\\n                market.totalfCash,\\n                market.lastImpliedRate,\\n                totalCashUnderlying,\\n                rateScalar,\\n                timeToMaturity\\n            );\\n            if (!success) return (0, 0, 0);\\n        }\\n\\n        return (rateScalar, totalCashUnderlying, rateAnchor);\\n    }\\n\\n    /// @dev Returns net asset cash amounts to the account, the market and the reserve\\n    /// @return\\n    ///     netCashToAccount: this is a positive or negative amount of cash change to the account\\n    ///     netCashToMarket: this is a positive or negative amount of cash change in the market\\n    //      netCashToReserve: this is always a positive amount of cash accrued to the reserve\\n    function _getNetCashAmountsUnderlying(\\n        CashGroupParameters memory cashGroup,\\n        int256 preFeeExchangeRate,\\n        int256 fCashToAccount,\\n        uint256 timeToMaturity\\n    )\\n        private\\n        pure\\n        returns (\\n            int256,\\n            int256,\\n            int256\\n        )\\n    {\\n        // Fees are specified in basis points which is an rate precision denomination. We convert this to\\n        // an exchange rate denomination for the given time to maturity. (i.e. get e^(fee * t) and multiply\\n        // or divide depending on the side of the trade).\\n        // tradeExchangeRate = exp((tradeInterestRateNoFee +/- fee) * timeToMaturity)\\n        // tradeExchangeRate = tradeExchangeRateNoFee (* or /) exp(fee * timeToMaturity)\\n        // cash = fCash / exchangeRate, exchangeRate > 1\\n        int256 preFeeCashToAccount =\\n            fCashToAccount.divInRatePrecision(preFeeExchangeRate).neg();\\n        int256 fee = getExchangeRateFromImpliedRate(cashGroup.getTotalFee(), timeToMaturity);\\n\\n        if (fCashToAccount > 0) {\\n            // Lending\\n            // Dividing reduces exchange rate, lending should receive less fCash for cash\\n            int256 postFeeExchangeRate = preFeeExchangeRate.divInRatePrecision(fee);\\n            // It's possible that the fee pushes exchange rates into negative territory. This is not possible\\n            // when borrowing. If this happens then the trade has failed.\\n            if (postFeeExchangeRate < Constants.RATE_PRECISION) return (0, 0, 0);\\n\\n            // cashToAccount = -(fCashToAccount / exchangeRate)\\n            // postFeeExchangeRate = preFeeExchangeRate / feeExchangeRate\\n            // preFeeCashToAccount = -(fCashToAccount / preFeeExchangeRate)\\n            // postFeeCashToAccount = -(fCashToAccount / postFeeExchangeRate)\\n            // netFee = preFeeCashToAccount - postFeeCashToAccount\\n            // netFee = (fCashToAccount / postFeeExchangeRate) - (fCashToAccount / preFeeExchangeRate)\\n            // netFee = ((fCashToAccount * feeExchangeRate) / preFeeExchangeRate) - (fCashToAccount / preFeeExchangeRate)\\n            // netFee = (fCashToAccount / preFeeExchangeRate) * (feeExchangeRate - 1)\\n            // netFee = -(preFeeCashToAccount) * (feeExchangeRate - 1)\\n            // netFee = preFeeCashToAccount * (1 - feeExchangeRate)\\n            // RATE_PRECISION - fee will be negative here, preFeeCashToAccount < 0, fee > 0\\n            fee = preFeeCashToAccount.mulInRatePrecision(Constants.RATE_PRECISION.sub(fee));\\n        } else {\\n            // Borrowing\\n            // cashToAccount = -(fCashToAccount / exchangeRate)\\n            // postFeeExchangeRate = preFeeExchangeRate * feeExchangeRate\\n\\n            // netFee = preFeeCashToAccount - postFeeCashToAccount\\n            // netFee = (fCashToAccount / postFeeExchangeRate) - (fCashToAccount / preFeeExchangeRate)\\n            // netFee = ((fCashToAccount / (feeExchangeRate * preFeeExchangeRate)) - (fCashToAccount / preFeeExchangeRate)\\n            // netFee = (fCashToAccount / preFeeExchangeRate) * (1 / feeExchangeRate - 1)\\n            // netFee = preFeeCashToAccount * ((1 - feeExchangeRate) / feeExchangeRate)\\n            // NOTE: preFeeCashToAccount is negative in this branch so we negate it to ensure that fee is a positive number\\n            // preFee * (1 - fee) / fee will be negative, use neg() to flip to positive\\n            // RATE_PRECISION - fee will be negative\\n            fee = preFeeCashToAccount.mul(Constants.RATE_PRECISION.sub(fee)).div(fee).neg();\\n        }\\n\\n        int256 cashToReserve =\\n            fee.mul(cashGroup.getReserveFeeShare()).div(Constants.PERCENTAGE_DECIMALS);\\n\\n        return (\\n            // postFeeCashToAccount = preFeeCashToAccount - fee\\n            preFeeCashToAccount.sub(fee),\\n            // netCashToMarket = -(preFeeCashToAccount - fee + cashToReserve)\\n            (preFeeCashToAccount.sub(fee).add(cashToReserve)).neg(),\\n            cashToReserve\\n        );\\n    }\\n\\n    /// @notice Sets the new market state\\n    /// @return\\n    ///     netAssetCashToAccount: the positive or negative change in asset cash to the account\\n    ///     assetCashToReserve: the positive amount of cash that accrues to the reserve\\n    function _setNewMarketState(\\n        MarketParameters memory market,\\n        AssetRateParameters memory assetRate,\\n        int256 netCashToAccount,\\n        int256 netCashToMarket,\\n        int256 netCashToReserve\\n    ) private view returns (int256, int256) {\\n        int256 netAssetCashToMarket = assetRate.convertFromUnderlying(netCashToMarket);\\n        // Set storage checks that total asset cash is above zero\\n        market.totalAssetCash = market.totalAssetCash.add(netAssetCashToMarket);\\n\\n        // Sets the trade time for the next oracle update\\n        market.previousTradeTime = block.timestamp;\\n        int256 assetCashToReserve = assetRate.convertFromUnderlying(netCashToReserve);\\n        int256 netAssetCashToAccount = assetRate.convertFromUnderlying(netCashToAccount);\\n        return (netAssetCashToAccount, assetCashToReserve);\\n    }\\n\\n    /// @notice Rate anchors update as the market gets closer to maturity. Rate anchors are not comparable\\n    /// across time or markets but implied rates are. The goal here is to ensure that the implied rate\\n    /// before and after the rate anchor update is the same. Therefore, the market will trade at the same implied\\n    /// rate that it last traded at. If these anchors do not update then it opens up the opportunity for arbitrage\\n    /// which will hurt the liquidity providers.\\n    ///\\n    /// The rate anchor will update as the market rolls down to maturity. The calculation is:\\n    /// newExchangeRate = e^(lastImpliedRate * timeToMaturity / Constants.IMPLIED_RATE_TIME)\\n    /// newAnchor = newExchangeRate - ln((proportion / (1 - proportion)) / rateScalar\\n    ///\\n    /// where:\\n    /// lastImpliedRate = ln(exchangeRate') * (Constants.IMPLIED_RATE_TIME / timeToMaturity')\\n    ///      (calculated when the last trade in the market was made)\\n    /// @return the new rate anchor and a boolean that signifies success\\n    function _getRateAnchor(\\n        int256 totalfCash,\\n        uint256 lastImpliedRate,\\n        int256 totalCashUnderlying,\\n        int256 rateScalar,\\n        uint256 timeToMaturity\\n    ) internal pure returns (int256, bool) {\\n        // This is the exchange rate at the new time to maturity\\n        int256 newExchangeRate = getExchangeRateFromImpliedRate(lastImpliedRate, timeToMaturity);\\n        if (newExchangeRate < Constants.RATE_PRECISION) return (0, false);\\n\\n        int256 rateAnchor;\\n        {\\n            // totalfCash / (totalfCash + totalCashUnderlying)\\n            int256 proportion =\\n                totalfCash.divInRatePrecision(totalfCash.add(totalCashUnderlying));\\n\\n            (int256 lnProportion, bool success) = _logProportion(proportion);\\n            if (!success) return (0, false);\\n\\n            // newExchangeRate - ln(proportion / (1 - proportion)) / rateScalar\\n            rateAnchor = newExchangeRate.sub(lnProportion.divInRatePrecision(rateScalar));\\n        }\\n\\n        return (rateAnchor, true);\\n    }\\n\\n    /// @notice Calculates the current market implied rate.\\n    /// @return the implied rate and a bool that is true on success\\n    function getImpliedRate(\\n        int256 totalfCash,\\n        int256 totalCashUnderlying,\\n        int256 rateScalar,\\n        int256 rateAnchor,\\n        uint256 timeToMaturity\\n    ) internal pure returns (uint256) {\\n        // This will check for exchange rates < Constants.RATE_PRECISION\\n        (int256 exchangeRate, bool success) =\\n            _getExchangeRate(totalfCash, totalCashUnderlying, rateScalar, rateAnchor, 0);\\n        if (!success) return 0;\\n\\n        // Uses continuous compounding to calculate the implied rate:\\n        // ln(exchangeRate) * Constants.IMPLIED_RATE_TIME / timeToMaturity\\n        int128 rate = ABDKMath64x64.fromInt(exchangeRate);\\n        // Scales down to a floating point for LN\\n        int128 rateScaled = ABDKMath64x64.div(rate, Constants.RATE_PRECISION_64x64);\\n        // We will not have a negative log here because we check that exchangeRate > Constants.RATE_PRECISION\\n        // inside getExchangeRate\\n        int128 lnRateScaled = ABDKMath64x64.ln(rateScaled);\\n        // Scales up to a fixed point\\n        uint256 lnRate =\\n            ABDKMath64x64.toUInt(ABDKMath64x64.mul(lnRateScaled, Constants.RATE_PRECISION_64x64));\\n\\n        // lnRate * IMPLIED_RATE_TIME / ttm\\n        uint256 impliedRate = lnRate.mul(Constants.IMPLIED_RATE_TIME).div(timeToMaturity);\\n\\n        // Implied rates over 429% will overflow, this seems like a safe assumption\\n        if (impliedRate > type(uint32).max) return 0;\\n\\n        return impliedRate;\\n    }\\n\\n    /// @notice Converts an implied rate to an exchange rate given a time to maturity. The\\n    /// formula is E = e^rt\\n    function getExchangeRateFromImpliedRate(uint256 impliedRate, uint256 timeToMaturity)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        int128 expValue =\\n            ABDKMath64x64.fromUInt(\\n                impliedRate.mul(timeToMaturity).div(Constants.IMPLIED_RATE_TIME)\\n            );\\n        int128 expValueScaled = ABDKMath64x64.div(expValue, Constants.RATE_PRECISION_64x64);\\n        int128 expResult = ABDKMath64x64.exp(expValueScaled);\\n        int128 expResultScaled = ABDKMath64x64.mul(expResult, Constants.RATE_PRECISION_64x64);\\n\\n        return ABDKMath64x64.toInt(expResultScaled);\\n    }\\n\\n    /// @notice Returns the exchange rate between fCash and cash for the given market\\n    /// Calculates the following exchange rate:\\n    ///     (1 / rateScalar) * ln(proportion / (1 - proportion)) + rateAnchor\\n    /// where:\\n    ///     proportion = totalfCash / (totalfCash + totalUnderlyingCash)\\n    /// @dev has an underscore to denote as private but is marked internal for the mock\\n    function _getExchangeRate(\\n        int256 totalfCash,\\n        int256 totalCashUnderlying,\\n        int256 rateScalar,\\n        int256 rateAnchor,\\n        int256 fCashToAccount\\n    ) internal pure returns (int256, bool) {\\n        int256 numerator = totalfCash.subNoNeg(fCashToAccount);\\n\\n        // This is the proportion scaled by Constants.RATE_PRECISION\\n        // (totalfCash + fCash) / (totalfCash + totalCashUnderlying)\\n        int256 proportion =\\n            numerator.divInRatePrecision(totalfCash.add(totalCashUnderlying));\\n\\n        // This limit is here to prevent the market from reaching extremely high interest rates via an\\n        // excessively large proportion (high amounts of fCash relative to cash).\\n        // Market proportion can only increase via borrowing (fCash is added to the market and cash is\\n        // removed). Over time, the returns from asset cash will slightly decrease the proportion (the\\n        // value of cash underlying in the market must be monotonically increasing). Therefore it is not\\n        // possible for the proportion to go over max market proportion unless borrowing occurs.\\n        if (proportion > Constants.MAX_MARKET_PROPORTION) return (0, false);\\n\\n        (int256 lnProportion, bool success) = _logProportion(proportion);\\n        if (!success) return (0, false);\\n\\n        // lnProportion / rateScalar + rateAnchor\\n        int256 rate = lnProportion.divInRatePrecision(rateScalar).add(rateAnchor);\\n        // Do not succeed if interest rates fall below 1\\n        if (rate < Constants.RATE_PRECISION) {\\n            return (0, false);\\n        } else {\\n            return (rate, true);\\n        }\\n    }\\n\\n    /// @dev This method calculates the log of the proportion inside the logit function which is\\n    /// defined as ln(proportion / (1 - proportion)). Special handling here is required to deal with\\n    /// fixed point precision and the ABDK library.\\n    function _logProportion(int256 proportion) internal pure returns (int256, bool) {\\n        // This will result in divide by zero, short circuit\\n        if (proportion == Constants.RATE_PRECISION) return (0, false);\\n\\n        // Convert proportion to what is used inside the logit function (p / (1-p))\\n        int256 logitP = proportion.divInRatePrecision(Constants.RATE_PRECISION.sub(proportion));\\n\\n        // ABDK does not handle log of numbers that are less than 1, in order to get the right value\\n        // scaled by RATE_PRECISION we use the log identity:\\n        // (ln(logitP / RATE_PRECISION)) * RATE_PRECISION = (ln(logitP) - ln(RATE_PRECISION)) * RATE_PRECISION\\n        int128 abdkProportion = ABDKMath64x64.fromInt(logitP);\\n        // Here, abdk will revert due to negative log so abort\\n        if (abdkProportion <= 0) return (0, false);\\n        int256 result =\\n            ABDKMath64x64.toInt(\\n                ABDKMath64x64.mul(\\n                    ABDKMath64x64.sub(\\n                        ABDKMath64x64.ln(abdkProportion),\\n                        Constants.LOG_RATE_PRECISION_64x64\\n                    ),\\n                    Constants.RATE_PRECISION_64x64\\n                )\\n            );\\n\\n        return (result, true);\\n    }\\n\\n    /// @notice Oracle rate protects against short term price manipulation. Time window will be set to a value\\n    /// on the order of minutes to hours. This is to protect fCash valuations from market manipulation. For example,\\n    /// a trader could use a flash loan to dump a large amount of cash into the market and depress interest rates.\\n    /// Since we value fCash in portfolios based on these rates, portfolio values will decrease and they may then\\n    /// be liquidated.\\n    ///\\n    /// Oracle rates are calculated when the market is loaded from storage.\\n    ///\\n    /// The oracle rate is a lagged weighted average over a short term price window. If we are past\\n    /// the short term window then we just set the rate to the lastImpliedRate, otherwise we take the\\n    /// weighted average:\\n    ///     lastImpliedRatePreTrade * (currentTs - previousTs) / timeWindow +\\n    ///         oracleRatePrevious * (1 - (currentTs - previousTs) / timeWindow)\\n    function _updateRateOracle(\\n        uint256 previousTradeTime,\\n        uint256 lastImpliedRate,\\n        uint256 oracleRate,\\n        uint256 rateOracleTimeWindow,\\n        uint256 blockTime\\n    ) private pure returns (uint256) {\\n        require(rateOracleTimeWindow > 0); // dev: update rate oracle, time window zero\\n\\n        // This can occur when using a view function get to a market state in the past\\n        if (previousTradeTime > blockTime) return lastImpliedRate;\\n\\n        uint256 timeDiff = blockTime.sub(previousTradeTime);\\n        if (timeDiff > rateOracleTimeWindow) {\\n            // If past the time window just return the lastImpliedRate\\n            return lastImpliedRate;\\n        }\\n\\n        // (currentTs - previousTs) / timeWindow\\n        uint256 lastTradeWeight =\\n            timeDiff.mul(uint256(Constants.RATE_PRECISION)).div(rateOracleTimeWindow);\\n\\n        // 1 - (currentTs - previousTs) / timeWindow\\n        uint256 oracleWeight = uint256(Constants.RATE_PRECISION).sub(lastTradeWeight);\\n\\n        uint256 newOracleRate =\\n            (lastImpliedRate.mul(lastTradeWeight).add(oracleRate.mul(oracleWeight))).div(\\n                uint256(Constants.RATE_PRECISION)\\n            );\\n\\n        return newOracleRate;\\n    }\\n\\n    function getOracleRate(\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 rateOracleTimeWindow,\\n        uint256 blockTime\\n    ) internal view returns (uint256) {\\n        mapping(uint256 => mapping(uint256 => \\n            mapping(uint256 => MarketStorage))) storage store = LibStorage.getMarketStorage();\\n        uint256 settlementDate = DateTime.getReferenceTime(blockTime) + Constants.QUARTER;\\n        MarketStorage storage marketStorage = store[currencyId][maturity][settlementDate];\\n\\n        uint256 lastImpliedRate = marketStorage.lastImpliedRate;\\n        uint256 oracleRate = marketStorage.oracleRate;\\n        uint256 previousTradeTime = marketStorage.previousTradeTime;\\n\\n        // If the oracle rate is set to zero this can only be because the markets have past their settlement\\n        // date but the new set of markets has not yet been initialized. This means that accounts cannot be liquidated\\n        // during this time, but market initialization can be called by anyone so the actual time that this condition\\n        // exists for should be quite short.\\n        require(oracleRate > 0, \\\"Market not initialized\\\");\\n\\n        return\\n            _updateRateOracle(\\n                previousTradeTime,\\n                lastImpliedRate,\\n                oracleRate,\\n                rateOracleTimeWindow,\\n                blockTime\\n            );\\n    }\\n\\n    /// @notice Reads a market object directly from storage. `loadMarket` should be called instead of this method\\n    /// which ensures that the rate oracle is set properly.\\n    function _loadMarketStorage(\\n        MarketParameters memory market,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        bool needsLiquidity,\\n        uint256 settlementDate\\n    ) private view {\\n        // Market object always uses the most current reference time as the settlement date\\n        mapping(uint256 => mapping(uint256 => \\n            mapping(uint256 => MarketStorage))) storage store = LibStorage.getMarketStorage();\\n        MarketStorage storage marketStorage = store[currencyId][maturity][settlementDate];\\n        bytes32 slot;\\n        assembly {\\n            slot := marketStorage.slot\\n        }\\n\\n        market.storageSlot = slot;\\n        market.maturity = maturity;\\n        market.totalfCash = marketStorage.totalfCash;\\n        market.totalAssetCash = marketStorage.totalAssetCash;\\n        market.lastImpliedRate = marketStorage.lastImpliedRate;\\n        market.oracleRate = marketStorage.oracleRate;\\n        market.previousTradeTime = marketStorage.previousTradeTime;\\n\\n        if (needsLiquidity) {\\n            market.totalLiquidity = marketStorage.totalLiquidity;\\n        } else {\\n            market.totalLiquidity = 0;\\n        }\\n    }\\n\\n    function _getMarketStoragePointer(\\n        MarketParameters memory market\\n    ) private pure returns (MarketStorage storage marketStorage) {\\n        bytes32 slot = market.storageSlot;\\n        assembly {\\n            marketStorage.slot := slot\\n        }\\n    }\\n\\n    function _setMarketStorageForLiquidity(MarketParameters memory market) internal {\\n        MarketStorage storage marketStorage = _getMarketStoragePointer(market);\\n        // Oracle rate does not change on liquidity\\n        uint32 storedOracleRate = marketStorage.oracleRate;\\n\\n        _setMarketStorage(\\n            marketStorage,\\n            market.totalfCash,\\n            market.totalAssetCash,\\n            market.lastImpliedRate,\\n            storedOracleRate,\\n            market.previousTradeTime\\n        );\\n\\n        _setTotalLiquidity(marketStorage, market.totalLiquidity);\\n    }\\n\\n    function setMarketStorageForInitialize(\\n        MarketParameters memory market,\\n        uint256 currencyId,\\n        uint256 settlementDate\\n    ) internal {\\n        // On initialization we have not yet calculated the storage slot so we get it here.\\n        mapping(uint256 => mapping(uint256 => \\n            mapping(uint256 => MarketStorage))) storage store = LibStorage.getMarketStorage();\\n        MarketStorage storage marketStorage = store[currencyId][market.maturity][settlementDate];\\n\\n        _setMarketStorage(\\n            marketStorage,\\n            market.totalfCash,\\n            market.totalAssetCash,\\n            market.lastImpliedRate,\\n            market.oracleRate,\\n            market.previousTradeTime\\n        );\\n\\n        _setTotalLiquidity(marketStorage, market.totalLiquidity);\\n    }\\n\\n    function _setTotalLiquidity(\\n        MarketStorage storage marketStorage,\\n        int256 totalLiquidity\\n    ) internal {\\n        require(totalLiquidity >= 0 && totalLiquidity <= type(uint80).max); // dev: market storage totalLiquidity overflow\\n        marketStorage.totalLiquidity = uint80(totalLiquidity);\\n    }\\n\\n    function _setMarketStorage(\\n        MarketStorage storage marketStorage,\\n        int256 totalfCash,\\n        int256 totalAssetCash,\\n        uint256 lastImpliedRate,\\n        uint256 oracleRate,\\n        uint256 previousTradeTime\\n    ) private {\\n        require(totalfCash >= 0 && totalfCash <= type(uint80).max); // dev: storage totalfCash overflow\\n        require(totalAssetCash >= 0 && totalAssetCash <= type(uint80).max); // dev: storage totalAssetCash overflow\\n        require(0 < lastImpliedRate && lastImpliedRate <= type(uint32).max); // dev: storage lastImpliedRate overflow\\n        require(0 < oracleRate && oracleRate <= type(uint32).max); // dev: storage oracleRate overflow\\n        require(0 <= previousTradeTime && previousTradeTime <= type(uint32).max); // dev: storage previous trade time overflow\\n\\n        marketStorage.totalfCash = uint80(totalfCash);\\n        marketStorage.totalAssetCash = uint80(totalAssetCash);\\n        marketStorage.lastImpliedRate = uint32(lastImpliedRate);\\n        marketStorage.oracleRate = uint32(oracleRate);\\n        marketStorage.previousTradeTime = uint32(previousTradeTime);\\n    }\\n\\n    /// @notice Creates a market object and ensures that the rate oracle time window is updated appropriately.\\n    function loadMarket(\\n        MarketParameters memory market,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 blockTime,\\n        bool needsLiquidity,\\n        uint256 rateOracleTimeWindow\\n    ) internal view {\\n        // Always reference the current settlement date\\n        uint256 settlementDate = DateTime.getReferenceTime(blockTime) + Constants.QUARTER;\\n        loadMarketWithSettlementDate(\\n            market,\\n            currencyId,\\n            maturity,\\n            blockTime,\\n            needsLiquidity,\\n            rateOracleTimeWindow,\\n            settlementDate\\n        );\\n    }\\n\\n    /// @notice Creates a market object and ensures that the rate oracle time window is updated appropriately, this\\n    /// is mainly used in the InitializeMarketAction contract.\\n    function loadMarketWithSettlementDate(\\n        MarketParameters memory market,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 blockTime,\\n        bool needsLiquidity,\\n        uint256 rateOracleTimeWindow,\\n        uint256 settlementDate\\n    ) internal view {\\n        _loadMarketStorage(market, currencyId, maturity, needsLiquidity, settlementDate);\\n\\n        market.oracleRate = _updateRateOracle(\\n            market.previousTradeTime,\\n            market.lastImpliedRate,\\n            market.oracleRate,\\n            rateOracleTimeWindow,\\n            blockTime\\n        );\\n    }\\n\\n    function loadSettlementMarket(\\n        MarketParameters memory market,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 settlementDate\\n    ) internal view {\\n        _loadMarketStorage(market, currencyId, maturity, true, settlementDate);\\n    }\\n\\n    /// Uses Newton's method to converge on an fCash amount given the amount of\\n    /// cash. The relation between cash and fcash is:\\n    /// cashAmount * exchangeRate * fee + fCash = 0\\n    /// where exchangeRate(fCash) = (rateScalar ^ -1) * ln(p / (1 - p)) + rateAnchor\\n    ///       p = (totalfCash - fCash) / (totalfCash + totalCash)\\n    ///       if cashAmount < 0: fee = feeRate ^ -1\\n    ///       if cashAmount > 0: fee = feeRate\\n    ///\\n    /// Newton's method is:\\n    /// fCash_(n+1) = fCash_n - f(fCash) / f'(fCash)\\n    ///\\n    /// f(fCash) = cashAmount * exchangeRate(fCash) * fee + fCash\\n    ///\\n    ///                                    (totalfCash + totalCash)\\n    /// exchangeRate'(fCash) = -  ------------------------------------------\\n    ///                           (totalfCash - fCash) * (totalCash + fCash)\\n    ///\\n    /// https://www.wolframalpha.com/input/?i=ln%28%28%28a-x%29%2F%28a%2Bb%29%29%2F%281-%28a-x%29%2F%28a%2Bb%29%29%29\\n    ///\\n    ///                     (cashAmount * fee) * (totalfCash + totalCash)\\n    /// f'(fCash) = 1 - ------------------------------------------------------\\n    ///                 rateScalar * (totalfCash - fCash) * (totalCash + fCash)\\n    ///\\n    /// NOTE: each iteration costs about 11.3k so this is only done via a view function.\\n    function getfCashGivenCashAmount(\\n        int256 totalfCash,\\n        int256 netCashToAccount,\\n        int256 totalCashUnderlying,\\n        int256 rateScalar,\\n        int256 rateAnchor,\\n        int256 feeRate,\\n        int256 maxDelta\\n    ) internal pure returns (int256) {\\n        require(maxDelta >= 0);\\n        int256 fCashChangeToAccountGuess = netCashToAccount.mulInRatePrecision(rateAnchor).neg();\\n        for (uint8 i = 0; i < 250; i++) {\\n            (int256 exchangeRate, bool success) =\\n                _getExchangeRate(\\n                    totalfCash,\\n                    totalCashUnderlying,\\n                    rateScalar,\\n                    rateAnchor,\\n                    fCashChangeToAccountGuess\\n                );\\n\\n            require(success); // dev: invalid exchange rate\\n            int256 delta =\\n                _calculateDelta(\\n                    netCashToAccount,\\n                    totalfCash,\\n                    totalCashUnderlying,\\n                    rateScalar,\\n                    fCashChangeToAccountGuess,\\n                    exchangeRate,\\n                    feeRate\\n                );\\n\\n            if (delta.abs() <= maxDelta) return fCashChangeToAccountGuess;\\n            fCashChangeToAccountGuess = fCashChangeToAccountGuess.sub(delta);\\n        }\\n\\n        revert(\\\"No convergence\\\");\\n    }\\n\\n    /// @dev Calculates: f(fCash) / f'(fCash)\\n    /// f(fCash) = cashAmount * exchangeRate * fee + fCash\\n    ///                     (cashAmount * fee) * (totalfCash + totalCash)\\n    /// f'(fCash) = 1 - ------------------------------------------------------\\n    ///                 rateScalar * (totalfCash - fCash) * (totalCash + fCash)\\n    function _calculateDelta(\\n        int256 cashAmount,\\n        int256 totalfCash,\\n        int256 totalCashUnderlying,\\n        int256 rateScalar,\\n        int256 fCashGuess,\\n        int256 exchangeRate,\\n        int256 feeRate\\n    ) private pure returns (int256) {\\n        int256 derivative;\\n        // rateScalar * (totalfCash - fCash) * (totalCash + fCash)\\n        // Precision: TOKEN_PRECISION ^ 2\\n        int256 denominator =\\n            rateScalar.mulInRatePrecision(\\n                (totalfCash.sub(fCashGuess)).mul(totalCashUnderlying.add(fCashGuess))\\n            );\\n\\n        if (fCashGuess > 0) {\\n            // Lending\\n            exchangeRate = exchangeRate.divInRatePrecision(feeRate);\\n            require(exchangeRate >= Constants.RATE_PRECISION); // dev: rate underflow\\n\\n            // (cashAmount / fee) * (totalfCash + totalCash)\\n            // Precision: TOKEN_PRECISION ^ 2\\n            derivative = cashAmount\\n                .mul(totalfCash.add(totalCashUnderlying))\\n                .divInRatePrecision(feeRate);\\n        } else {\\n            // Borrowing\\n            exchangeRate = exchangeRate.mulInRatePrecision(feeRate);\\n            require(exchangeRate >= Constants.RATE_PRECISION); // dev: rate underflow\\n\\n            // (cashAmount * fee) * (totalfCash + totalCash)\\n            // Precision: TOKEN_PRECISION ^ 2\\n            derivative = cashAmount.mulInRatePrecision(\\n                feeRate.mul(totalfCash.add(totalCashUnderlying))\\n            );\\n        }\\n        // 1 - numerator / denominator\\n        // Precision: TOKEN_PRECISION\\n        derivative = Constants.INTERNAL_TOKEN_PRECISION.sub(derivative.div(denominator));\\n\\n        // f(fCash) = cashAmount * exchangeRate * fee + fCash\\n        // NOTE: exchangeRate at this point already has the fee taken into account\\n        int256 numerator = cashAmount.mulInRatePrecision(exchangeRate);\\n        numerator = numerator.add(fCashGuess);\\n\\n        // f(fCash) / f'(fCash), note that they are both denominated as cashAmount so use TOKEN_PRECISION\\n        // here instead of RATE_PRECISION\\n        return numerator.mul(Constants.INTERNAL_TOKEN_PRECISION).div(derivative);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/nToken/nTokenCalculations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./nTokenHandler.sol\\\";\\nimport \\\"../portfolio/BitmapAssetsHandler.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"../../math/Bitmap.sol\\\";\\n\\nlibrary nTokenCalculations {\\n    using Bitmap for bytes32;\\n    using SafeInt256 for int256;\\n    using AssetRate for AssetRateParameters;\\n    using CashGroup for CashGroupParameters;\\n\\n    /// @notice Calculates the tokens to mint to the account as a ratio of the nToken\\n    /// present value denominated in asset cash terms.\\n    /// @return the amount of tokens to mint, the ifCash bitmap\\n    function calculateTokensToMint(\\n        nTokenPortfolio memory nToken,\\n        int256 assetCashToDeposit,\\n        uint256 blockTime\\n    ) internal view returns (int256) {\\n        require(assetCashToDeposit >= 0); // dev: deposit amount negative\\n        if (assetCashToDeposit == 0) return 0;\\n\\n        if (nToken.lastInitializedTime != 0) {\\n            // For the sake of simplicity, nTokens cannot be minted if they have assets\\n            // that need to be settled. This is only done during market initialization.\\n            uint256 nextSettleTime = nTokenHandler.getNextSettleTime(nToken);\\n            // If next settle time <= blockTime then the token can be settled\\n            require(nextSettleTime > blockTime, \\\"Requires settlement\\\");\\n        }\\n\\n        if (nToken.totalSupply == 0) {\\n            // Allow for the first deposit and bypass all the PV valuation\\n            return assetCashToDeposit;\\n        } else {\\n            (int256 nTokenOracleValue, int256 nTokenSpotValue) = nTokenCalculations.getNTokenAssetPVForMinting(\\n                nToken, blockTime\\n            );\\n\\n            // Defensive check to ensure PV remains positive\\n            require(nTokenOracleValue >= 0);\\n            require(nTokenSpotValue >= 0);\\n\\n            int256 maxValueDeviationPercent = int256(\\n                uint256(uint8(nToken.parameters[Constants.MAX_MINT_DEVIATION_LIMIT]))\\n            );\\n            // Check deviation limit here\\n            int256 deviationInPercentage = nTokenOracleValue.sub(nTokenSpotValue).abs()\\n                .mul(Constants.PERCENTAGE_DECIMALS).div(nTokenOracleValue);\\n            require(deviationInPercentage <= maxValueDeviationPercent, \\\"Over Deviation Limit\\\");\\n\\n            // nTokenSpotValuePost = nTokenOracleValue + amountToDeposit\\n            // (tokenSupply + tokensToMint) / tokenSupply == (nTokenSpotValue + amountToDeposit) / nTokenOracleValue\\n            // (tokenSupply + tokensToMint) == (nTokenSpotValue + amountToDeposit) * tokenSupply / nTokenOracleValue\\n            // (tokenSupply + tokensToMint) == tokenSupply + (amountToDeposit * tokenSupply) / nTokenSpotValue\\n            // tokensToMint == (amountToDeposit * tokenSupply) / nTokenSpotValue\\n            return assetCashToDeposit.mul(nToken.totalSupply).div(nTokenSpotValue);\\n        }\\n    }\\n\\n    function getNTokenAssetPVForMinting(nTokenPortfolio memory nToken, uint256 blockTime)\\n        internal view returns (int256 nTokenOracleValue, int256 nTokenSpotValue) {\\n        // Skip the \\\"nextSettleTime\\\" check in this method. nTokens are not mintable when markets\\n        // are not yet initialized.\\n\\n        (int256 totalOracleValueInMarkets, /* int256[] memory netfCash */) = getNTokenMarketValue(\\n            {nToken: nToken, blockTime: blockTime, useOracleRate: true}\\n        );\\n        (int256 totalSpotValueInMarkets, /* int256[] memory netfCash */) = getNTokenMarketValue(\\n            {nToken: nToken, blockTime: blockTime, useOracleRate: false}\\n        );\\n        int256 ifCashResidualAssetPV = _getIfCashResidualAssetPV(nToken, blockTime);\\n\\n        // Return the total present value denominated in asset terms\\n        nTokenOracleValue = totalOracleValueInMarkets.add(ifCashResidualAssetPV).add(nToken.cashBalance);\\n        nTokenSpotValue = totalSpotValueInMarkets.add(ifCashResidualAssetPV).add(nToken.cashBalance);\\n    }\\n\\n    /// @notice Returns the nToken present value denominated in asset terms.\\n    function getNTokenAssetPV(nTokenPortfolio memory nToken, uint256 blockTime)\\n        internal\\n        view\\n        returns (int256)\\n    {\\n        {\\n            uint256 nextSettleTime = nTokenHandler.getNextSettleTime(nToken);\\n            // If the first asset maturity has passed (the 3 month), this means that all the LTs must\\n            // be settled except the 6 month (which is now the 3 month). We don't settle LTs except in\\n            // initialize markets so we calculate the cash value of the portfolio here.\\n            if (nextSettleTime <= blockTime) {\\n                // NOTE: this condition should only be present for a very short amount of time, which is the window between\\n                // when the markets are no longer tradable at quarter end and when the new markets have been initialized.\\n                // We time travel back to one second before maturity to value the liquidity tokens. Although this value is\\n                // not strictly correct the different should be quite slight. We do this to ensure that free collateral checks\\n                // for withdraws and liquidations can still be processed. If this condition persists for a long period of time then\\n                // the entire protocol will have serious problems as markets will not be tradable.\\n                blockTime = nextSettleTime - 1;\\n            }\\n        }\\n\\n        // This is the total value in liquid assets\\n        (int256 totalOracleValueInMarkets, /* int256[] memory netfCash */) = getNTokenMarketValue(\\n            {nToken: nToken, blockTime: blockTime, useOracleRate: true}\\n        );\\n\\n        int256 ifCashResidualAssetPV = _getIfCashResidualAssetPV(nToken, blockTime);\\n\\n        // Return the total present value denominated in asset cash terms\\n        return totalOracleValueInMarkets.add(ifCashResidualAssetPV).add(nToken.cashBalance);\\n    }\\n\\n    function _getIfCashResidualAssetPV(\\n        nTokenPortfolio memory nToken, uint256 blockTime\\n    ) private view returns (int256) {\\n        // Then get the total value in any idiosyncratic fCash residuals (if they exist)\\n        bytes32 ifCashBits = getNTokenifCashBits(\\n            nToken.tokenAddress,\\n            nToken.cashGroup.currencyId,\\n            nToken.lastInitializedTime,\\n            blockTime,\\n            nToken.cashGroup.maxMarketIndex\\n        );\\n\\n        if (ifCashBits != 0) {\\n            // Non idiosyncratic residuals have already been accounted for\\n            (int256 ifCashResidualUnderlyingPV, /* hasDebt */) = BitmapAssetsHandler.getNetPresentValueFromBitmap(\\n                nToken.tokenAddress,\\n                nToken.cashGroup.currencyId,\\n                nToken.lastInitializedTime,\\n                blockTime,\\n                nToken.cashGroup,\\n                false, // nToken present value calculation does not use risk adjusted values\\n                ifCashBits\\n            );\\n            return nToken.cashGroup.assetRate.convertFromUnderlying(ifCashResidualUnderlyingPV);\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /**\\n     * @notice Handles the case when liquidity tokens should be withdrawn in proportion to their amounts\\n     * in the market. This will be the case when there is no idiosyncratic fCash residuals in the nToken\\n     * portfolio.\\n     * @param nToken portfolio object for nToken\\n     * @param nTokensToRedeem amount of nTokens to redeem\\n     * @param tokensToWithdraw array of liquidity tokens to withdraw from each market, proportional to\\n     * the account's share of the total supply\\n     * @param netfCash an empty array to hold net fCash values calculated later when the tokens are actually\\n     * withdrawn from markets\\n     */\\n    function _getProportionalLiquidityTokens(\\n        nTokenPortfolio memory nToken,\\n        int256 nTokensToRedeem\\n    ) private pure returns (int256[] memory tokensToWithdraw, int256[] memory netfCash) {\\n        uint256 numMarkets = nToken.portfolioState.storedAssets.length;\\n        tokensToWithdraw = new int256[](numMarkets);\\n        netfCash = new int256[](numMarkets);\\n\\n        for (uint256 i = 0; i < numMarkets; i++) {\\n            int256 totalTokens = nToken.portfolioState.storedAssets[i].notional;\\n            tokensToWithdraw[i] = totalTokens.mul(nTokensToRedeem).div(nToken.totalSupply);\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the number of liquidity tokens to withdraw from each market if the nToken\\n     * has idiosyncratic residuals during nToken redeem. In this case the redeemer will take\\n     * their cash from the rest of the fCash markets, redeeming around the nToken.\\n     * @param nToken portfolio object for nToken\\n     * @param nTokensToRedeem amount of nTokens to redeem\\n     * @param blockTime block time\\n     * @param ifCashBits the bits in the bitmap that represent ifCash assets\\n     * @return tokensToWithdraw array of tokens to withdraw from each corresponding market\\n     * @return netfCash array of netfCash amounts to go back to the account\\n     */\\n    function getLiquidityTokenWithdraw(\\n        nTokenPortfolio memory nToken,\\n        int256 nTokensToRedeem,\\n        uint256 blockTime,\\n        bytes32 ifCashBits\\n    ) internal view returns (int256[] memory, int256[] memory) {\\n        // If there are no ifCash bits set then this will just return the proportion of all liquidity tokens\\n        if (ifCashBits == 0) return _getProportionalLiquidityTokens(nToken, nTokensToRedeem);\\n\\n        (\\n            int256 totalAssetValueInMarkets,\\n            int256[] memory netfCash\\n        ) = getNTokenMarketValue({nToken: nToken, blockTime: blockTime, useOracleRate: true});\\n        int256[] memory tokensToWithdraw = new int256[](netfCash.length);\\n\\n        // NOTE: this total portfolio asset value does not include any cash balance the nToken may hold.\\n        // The redeemer will always get a proportional share of this cash balance and therefore we don't\\n        // need to account for it here when we calculate the share of liquidity tokens to withdraw. We are\\n        // only concerned with the nToken's portfolio assets in this method.\\n        int256 totalPortfolioAssetValue;\\n        {\\n            // Returns the risk adjusted net present value for the idiosyncratic residuals\\n            (int256 underlyingPV, /* hasDebt */) = BitmapAssetsHandler.getNetPresentValueFromBitmap(\\n                nToken.tokenAddress,\\n                nToken.cashGroup.currencyId,\\n                nToken.lastInitializedTime,\\n                blockTime,\\n                nToken.cashGroup,\\n                true, // use risk adjusted here to assess a penalty for withdrawing around the residual\\n                ifCashBits\\n            );\\n\\n            // NOTE: we do not include cash balance here because the account will always take their share\\n            // of the cash balance regardless of the residuals\\n            totalPortfolioAssetValue = totalAssetValueInMarkets.add(\\n                nToken.cashGroup.assetRate.convertFromUnderlying(underlyingPV)\\n            );\\n        }\\n\\n        // Loops through each liquidity token and calculates how much the redeemer can withdraw to get\\n        // the requisite amount of present value after adjusting for the ifCash residual value that is\\n        // not accessible via redemption.\\n        for (uint256 i = 0; i < tokensToWithdraw.length; i++) {\\n            int256 totalTokens = nToken.portfolioState.storedAssets[i].notional;\\n            // Redeemer's baseline share of the liquidity tokens based on total supply:\\n            //      redeemerShare = totalTokens * nTokensToRedeem / totalSupply\\n            // Scalar factor to account for residual value (need to inflate the tokens to withdraw\\n            // proportional to the value locked up in ifCash residuals):\\n            //      scaleFactor = totalPortfolioAssetValue / totalAssetValueInMarkets\\n            // Final math equals:\\n            //      tokensToWithdraw = redeemerShare * scalarFactor\\n            //      tokensToWithdraw = (totalTokens * nTokensToRedeem * totalPortfolioAssetValue)\\n            //         / (totalAssetValueInMarkets * totalSupply)\\n            tokensToWithdraw[i] = totalTokens\\n                .mul(nTokensToRedeem)\\n                .mul(totalPortfolioAssetValue);\\n\\n            tokensToWithdraw[i] = tokensToWithdraw[i]\\n                .div(totalAssetValueInMarkets)\\n                .div(nToken.totalSupply);\\n\\n            // This is the share of net fcash that will be credited back to the account\\n            netfCash[i] = netfCash[i].mul(tokensToWithdraw[i]).div(totalTokens);\\n        }\\n\\n        return (tokensToWithdraw, netfCash);\\n    }\\n\\n    /// @notice Returns the value of all the liquid assets in an nToken portfolio which are defined by\\n    /// the liquidity tokens held in each market and their corresponding fCash positions. The formula\\n    /// can be described as:\\n    /// totalAssetValue = sum_per_liquidity_token(cashClaim + presentValue(netfCash))\\n    ///     where netfCash = fCashClaim + fCash\\n    ///     and fCash refers the the fCash position at the corresponding maturity\\n    function getNTokenMarketValue(nTokenPortfolio memory nToken, uint256 blockTime, bool useOracleRate)\\n        internal\\n        view\\n        returns (int256 totalAssetValue, int256[] memory netfCash)\\n    {\\n        uint256 numMarkets = nToken.portfolioState.storedAssets.length;\\n        netfCash = new int256[](numMarkets);\\n\\n        MarketParameters memory market;\\n        for (uint256 i = 0; i < numMarkets; i++) {\\n            // Load the corresponding market into memory\\n            nToken.cashGroup.loadMarket(market, i + 1, true, blockTime);\\n            PortfolioAsset memory liquidityToken = nToken.portfolioState.storedAssets[i];\\n\\n            // Get the fCash claims and fCash assets. We do not use haircut versions here because\\n            // nTokenRedeem does not require it and getNTokenPV does not use it (a haircut is applied\\n            // at the end of the calculation to the entire PV instead).\\n            (int256 assetCashClaim, int256 fCashClaim) = AssetHandler.getCashClaims(liquidityToken, market);\\n\\n            // fCash is denominated in underlying\\n            netfCash[i] = fCashClaim.add(\\n                BitmapAssetsHandler.getifCashNotional(\\n                    nToken.tokenAddress,\\n                    nToken.cashGroup.currencyId,\\n                    liquidityToken.maturity\\n                )\\n            );\\n\\n            // This calculates for a single liquidity token:\\n            // assetCashClaim + convertToAssetCash(pv(netfCash))\\n            int256 netAssetValueInMarket = assetCashClaim.add(\\n                nToken.cashGroup.assetRate.convertFromUnderlying(\\n                    AssetHandler.getPresentfCashValue(\\n                        netfCash[i],\\n                        liquidityToken.maturity,\\n                        blockTime,\\n                        // No need to call cash group for oracle rate, it is up to date here\\n                        // and we are assured to be referring to this market.\\n                        useOracleRate ? market.oracleRate : market.lastImpliedRate\\n                    )\\n                )\\n            );\\n\\n            // Calculate the running total\\n            totalAssetValue = totalAssetValue.add(netAssetValueInMarket);\\n        }\\n    }\\n\\n    /// @notice Returns just the bits in a bitmap that are idiosyncratic\\n    function getNTokenifCashBits(\\n        address tokenAddress,\\n        uint256 currencyId,\\n        uint256 lastInitializedTime,\\n        uint256 blockTime,\\n        uint256 maxMarketIndex\\n    ) internal view returns (bytes32) {\\n        // If max market index is less than or equal to 2, there are never ifCash assets by construction\\n        if (maxMarketIndex <= 2) return bytes32(0);\\n        bytes32 assetsBitmap = BitmapAssetsHandler.getAssetsBitmap(tokenAddress, currencyId);\\n        // Handles the case when there are no assets at the first initialization\\n        if (assetsBitmap == 0) return assetsBitmap;\\n\\n        uint256 tRef = DateTime.getReferenceTime(blockTime);\\n\\n        if (tRef == lastInitializedTime) {\\n            // This is a more efficient way to turn off ifCash assets in the common case when the market is\\n            // initialized immediately\\n            return assetsBitmap & ~(Constants.ACTIVE_MARKETS_MASK);\\n        } else {\\n            // In this branch, initialize markets has occurred past the time above. It would occur in these\\n            // two scenarios (both should be exceedingly rare):\\n            // 1. initializing a cash group with 3+ markets for the first time (not beginning on the tRef)\\n            // 2. somehow initialize markets has been delayed for more than 24 hours\\n            for (uint i = 1; i <= maxMarketIndex; i++) {\\n                // In this loop we get the maturity of each active market and turn off the corresponding bit\\n                // one by one. It is less efficient than the option above.\\n                uint256 maturity = tRef + DateTime.getTradedMarket(i);\\n                (uint256 bitNum, /* */) = DateTime.getBitNumFromMaturity(lastInitializedTime, maturity);\\n                assetsBitmap = assetsBitmap.setBit(bitNum, false);\\n            }\\n\\n            return assetsBitmap;\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/internal/nToken/nTokenHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./nTokenSupply.sol\\\";\\nimport \\\"../markets/CashGroup.sol\\\";\\nimport \\\"../markets/AssetRate.sol\\\";\\nimport \\\"../portfolio/PortfolioHandler.sol\\\";\\nimport \\\"../balances/BalanceHandler.sol\\\";\\nimport \\\"../../global/LibStorage.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary nTokenHandler {\\n    using SafeInt256 for int256;\\n\\n    /// @dev Mirror of the value in LibStorage, solidity compiler does not allow assigning\\n    /// two constants to each other.\\n    uint256 private constant NUM_NTOKEN_MARKET_FACTORS = 14;\\n\\n    /// @notice Returns an account context object that is specific to nTokens.\\n    function getNTokenContext(address tokenAddress)\\n        internal\\n        view\\n        returns (\\n            uint16 currencyId,\\n            uint256 incentiveAnnualEmissionRate,\\n            uint256 lastInitializedTime,\\n            uint8 assetArrayLength,\\n            bytes6 parameters\\n        )\\n    {\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\n        nTokenContext storage context = store[tokenAddress];\\n\\n        currencyId = context.currencyId;\\n        incentiveAnnualEmissionRate = context.incentiveAnnualEmissionRate;\\n        lastInitializedTime = context.lastInitializedTime;\\n        assetArrayLength = context.assetArrayLength;\\n        parameters = context.nTokenParameters;\\n    }\\n\\n    /// @notice Returns the nToken token address for a given currency\\n    function nTokenAddress(uint256 currencyId) internal view returns (address tokenAddress) {\\n        mapping(uint256 => address) storage store = LibStorage.getNTokenAddressStorage();\\n        return store[currencyId];\\n    }\\n\\n    /// @notice Called by governance to set the nToken token address and its reverse lookup. Cannot be\\n    /// reset once this is set.\\n    function setNTokenAddress(uint16 currencyId, address tokenAddress) internal {\\n        mapping(uint256 => address) storage addressStore = LibStorage.getNTokenAddressStorage();\\n        require(addressStore[currencyId] == address(0), \\\"PT: token address exists\\\");\\n\\n        mapping(address => nTokenContext) storage contextStore = LibStorage.getNTokenContextStorage();\\n        nTokenContext storage context = contextStore[tokenAddress];\\n        require(context.currencyId == 0, \\\"PT: currency exists\\\");\\n\\n        // This will initialize all other context slots to zero\\n        context.currencyId = currencyId;\\n        addressStore[currencyId] = tokenAddress;\\n    }\\n\\n    /// @notice Set nToken token collateral parameters\\n    function setNTokenCollateralParameters(\\n        address tokenAddress,\\n        uint8 residualPurchaseIncentive10BPS,\\n        uint8 pvHaircutPercentage,\\n        uint8 residualPurchaseTimeBufferHours,\\n        uint8 cashWithholdingBuffer10BPS,\\n        uint8 liquidationHaircutPercentage,\\n        uint8 maxMintDeviationPercentage\\n    ) internal {\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\n        nTokenContext storage context = store[tokenAddress];\\n\\n        require(liquidationHaircutPercentage <= Constants.PERCENTAGE_DECIMALS, \\\"Invalid haircut\\\");\\n        // The pv haircut percentage must be less than the liquidation percentage or else liquidators will not\\n        // get profit for liquidating nToken.\\n        require(pvHaircutPercentage < liquidationHaircutPercentage, \\\"Invalid pv haircut\\\");\\n        // The mint deviation percentage cannot be greater than the difference between the liquidation haircut\\n        // percentage and the pv haircut percentage.\\n        require(maxMintDeviationPercentage <= liquidationHaircutPercentage - pvHaircutPercentage);\\n        // Ensure that the cash withholding buffer is greater than the residual purchase incentive or\\n        // the nToken may not have enough cash to pay accounts to buy its negative ifCash\\n        require(residualPurchaseIncentive10BPS <= cashWithholdingBuffer10BPS, \\\"Invalid discounts\\\");\\n\\n        bytes6 parameters = (\\n            (bytes6(uint48(liquidationHaircutPercentage)) << 40) |\\n            (bytes6(uint48(cashWithholdingBuffer10BPS)) << 32) |\\n            (bytes6(uint48(residualPurchaseTimeBufferHours)) << 24) |\\n            (bytes6(uint48(pvHaircutPercentage)) << 16) |\\n            (bytes6(uint48(residualPurchaseIncentive10BPS)) << 8) |\\n            (bytes6(uint48(maxMintDeviationPercentage)))\\n        );\\n\\n        // Set the parameters\\n        context.nTokenParameters = parameters;\\n    }\\n\\n    /// @notice Sets a secondary rewarder contract on an nToken so that incentives can come from a different\\n    /// contract, aside from the native NOTE token incentives.\\n    function setSecondaryRewarder(\\n        uint16 currencyId,\\n        IRewarder rewarder\\n    ) internal {\\n        address tokenAddress = nTokenAddress(currencyId);\\n        // nToken must exist for a secondary rewarder\\n        require(tokenAddress != address(0));\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\n        nTokenContext storage context = store[tokenAddress];\\n\\n        // Setting the rewarder to address(0) will disable it. We use a context setting here so that\\n        // we can save a storage read before getting the rewarder\\n        context.hasSecondaryRewarder = (address(rewarder) != address(0));\\n        LibStorage.getSecondaryIncentiveRewarder()[tokenAddress] = rewarder;\\n    }\\n\\n    /// @notice Returns the secondary rewarder if it is set\\n    function getSecondaryRewarder(address tokenAddress) internal view returns (IRewarder) {\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\n        nTokenContext storage context = store[tokenAddress];\\n        \\n        if (context.hasSecondaryRewarder) {\\n            return LibStorage.getSecondaryIncentiveRewarder()[tokenAddress];\\n        } else {\\n            return IRewarder(address(0));\\n        }\\n    }\\n\\n    function setArrayLengthAndInitializedTime(\\n        address tokenAddress,\\n        uint8 arrayLength,\\n        uint256 lastInitializedTime\\n    ) internal {\\n        require(lastInitializedTime >= 0 && uint256(lastInitializedTime) < type(uint32).max); // dev: next settle time overflow\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\n        nTokenContext storage context = store[tokenAddress];\\n        context.lastInitializedTime = uint32(lastInitializedTime);\\n        context.assetArrayLength = arrayLength;\\n    }\\n\\n    /// @notice Returns the array of deposit shares and leverage thresholds for nTokens\\n    function getDepositParameters(uint256 currencyId, uint256 maxMarketIndex)\\n        internal\\n        view\\n        returns (int256[] memory depositShares, int256[] memory leverageThresholds)\\n    {\\n        mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store = LibStorage.getNTokenDepositStorage();\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage depositParameters = store[currencyId];\\n        (depositShares, leverageThresholds) = _getParameters(depositParameters, maxMarketIndex, false);\\n    }\\n\\n    /// @notice Sets the deposit parameters\\n    /// @dev We pack the values in alternating between the two parameters into either one or two\\n    // storage slots depending on the number of markets. This is to save storage reads when we use the parameters.\\n    function setDepositParameters(\\n        uint256 currencyId,\\n        uint32[] calldata depositShares,\\n        uint32[] calldata leverageThresholds\\n    ) internal {\\n        require(\\n            depositShares.length <= Constants.MAX_TRADED_MARKET_INDEX,\\n            \\\"PT: deposit share length\\\"\\n        );\\n        require(depositShares.length == leverageThresholds.length, \\\"PT: leverage share length\\\");\\n\\n        uint256 shareSum;\\n        for (uint256 i; i < depositShares.length; i++) {\\n            // This cannot overflow in uint 256 with 9 max slots\\n            shareSum = shareSum + depositShares[i];\\n            require(\\n                leverageThresholds[i] > 0 && leverageThresholds[i] < Constants.RATE_PRECISION,\\n                \\\"PT: leverage threshold\\\"\\n            );\\n        }\\n\\n        // Total deposit share must add up to 100%\\n        require(shareSum == uint256(Constants.DEPOSIT_PERCENT_BASIS), \\\"PT: deposit shares sum\\\");\\n\\n        mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store = LibStorage.getNTokenDepositStorage();\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage depositParameters = store[currencyId];\\n        _setParameters(depositParameters, depositShares, leverageThresholds);\\n    }\\n\\n    /// @notice Sets the initialization parameters for the markets, these are read only when markets\\n    /// are initialized\\n    function setInitializationParameters(\\n        uint256 currencyId,\\n        uint32[] calldata annualizedAnchorRates,\\n        uint32[] calldata proportions\\n    ) internal {\\n        require(annualizedAnchorRates.length <= Constants.MAX_TRADED_MARKET_INDEX, \\\"PT: annualized anchor rates length\\\");\\n        require(proportions.length == annualizedAnchorRates.length, \\\"PT: proportions length\\\");\\n\\n        for (uint256 i; i < proportions.length; i++) {\\n            // Proportions must be between zero and the rate precision\\n            require(annualizedAnchorRates[i] > 0, \\\"NT: anchor rate zero\\\");\\n            require(\\n                proportions[i] > 0 && proportions[i] < Constants.RATE_PRECISION,\\n                \\\"PT: invalid proportion\\\"\\n            );\\n        }\\n\\n        mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store = LibStorage.getNTokenInitStorage();\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage initParameters = store[currencyId];\\n        _setParameters(initParameters, annualizedAnchorRates, proportions);\\n    }\\n\\n    /// @notice Returns the array of initialization parameters for a given currency.\\n    function getInitializationParameters(uint256 currencyId, uint256 maxMarketIndex)\\n        internal\\n        view\\n        returns (int256[] memory annualizedAnchorRates, int256[] memory proportions)\\n    {\\n        mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store = LibStorage.getNTokenInitStorage();\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage initParameters = store[currencyId];\\n        (annualizedAnchorRates, proportions) = _getParameters(initParameters, maxMarketIndex, true);\\n    }\\n\\n    function _getParameters(\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage slot,\\n        uint256 maxMarketIndex,\\n        bool noUnset\\n    ) private view returns (int256[] memory, int256[] memory) {\\n        uint256 index = 0;\\n        int256[] memory array1 = new int256[](maxMarketIndex);\\n        int256[] memory array2 = new int256[](maxMarketIndex);\\n        for (uint256 i; i < maxMarketIndex; i++) {\\n            array1[i] = slot[index];\\n            index++;\\n            array2[i] = slot[index];\\n            index++;\\n\\n            if (noUnset) {\\n                require(array1[i] > 0 && array2[i] > 0, \\\"PT: init value zero\\\");\\n            }\\n        }\\n\\n        return (array1, array2);\\n    }\\n\\n    function _setParameters(\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage slot,\\n        uint32[] calldata array1,\\n        uint32[] calldata array2\\n    ) private {\\n        uint256 index = 0;\\n        for (uint256 i = 0; i < array1.length; i++) {\\n            slot[index] = array1[i];\\n            index++;\\n\\n            slot[index] = array2[i];\\n            index++;\\n        }\\n    }\\n\\n    function loadNTokenPortfolioNoCashGroup(nTokenPortfolio memory nToken, uint16 currencyId)\\n        internal\\n        view\\n    {\\n        nToken.tokenAddress = nTokenAddress(currencyId);\\n        // prettier-ignore\\n        (\\n            /* currencyId */,\\n            /* incentiveRate */,\\n            uint256 lastInitializedTime,\\n            uint8 assetArrayLength,\\n            bytes6 parameters\\n        ) = getNTokenContext(nToken.tokenAddress);\\n\\n        // prettier-ignore\\n        (\\n            uint256 totalSupply,\\n            /* accumulatedNOTEPerNToken */,\\n            /* lastAccumulatedTime */\\n        ) = nTokenSupply.getStoredNTokenSupplyFactors(nToken.tokenAddress);\\n\\n        nToken.lastInitializedTime = lastInitializedTime;\\n        nToken.totalSupply = int256(totalSupply);\\n        nToken.parameters = parameters;\\n\\n        nToken.portfolioState = PortfolioHandler.buildPortfolioState(\\n            nToken.tokenAddress,\\n            assetArrayLength,\\n            0\\n        );\\n\\n        // prettier-ignore\\n        (\\n            nToken.cashBalance,\\n            /* nTokenBalance */,\\n            /* lastClaimTime */,\\n            /* accountIncentiveDebt */\\n        ) = BalanceHandler.getBalanceStorage(nToken.tokenAddress, currencyId);\\n    }\\n\\n    /// @notice Uses buildCashGroupStateful\\n    function loadNTokenPortfolioStateful(nTokenPortfolio memory nToken, uint16 currencyId)\\n        internal\\n    {\\n        loadNTokenPortfolioNoCashGroup(nToken, currencyId);\\n        nToken.cashGroup = CashGroup.buildCashGroupStateful(currencyId);\\n    }\\n\\n    /// @notice Uses buildCashGroupView\\n    function loadNTokenPortfolioView(nTokenPortfolio memory nToken, uint16 currencyId)\\n        internal\\n        view\\n    {\\n        loadNTokenPortfolioNoCashGroup(nToken, currencyId);\\n        nToken.cashGroup = CashGroup.buildCashGroupView(currencyId);\\n    }\\n\\n    /// @notice Returns the next settle time for the nToken which is 1 quarter away\\n    function getNextSettleTime(nTokenPortfolio memory nToken) internal pure returns (uint256) {\\n        if (nToken.lastInitializedTime == 0) return 0;\\n        return DateTime.getReferenceTime(nToken.lastInitializedTime) + Constants.QUARTER;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/internal/nToken/nTokenSupply.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./nTokenHandler.sol\\\";\\nimport \\\"../../global/LibStorage.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary nTokenSupply {\\n    using SafeInt256 for int256;\\n    using SafeMath for uint256;\\n\\n    /// @notice Retrieves stored nToken supply and related factors. Do not use accumulatedNOTEPerNToken for calculating\\n    /// incentives! Use `getUpdatedAccumulatedNOTEPerNToken` instead.\\n    function getStoredNTokenSupplyFactors(address tokenAddress)\\n        internal\\n        view\\n        returns (\\n            uint256 totalSupply,\\n            uint256 accumulatedNOTEPerNToken,\\n            uint256 lastAccumulatedTime\\n        )\\n    {\\n        mapping(address => nTokenTotalSupplyStorage) storage store = LibStorage.getNTokenTotalSupplyStorage();\\n        nTokenTotalSupplyStorage storage nTokenStorage = store[tokenAddress];\\n        totalSupply = nTokenStorage.totalSupply;\\n        // NOTE: DO NOT USE THIS RETURNED VALUE FOR CALCULATING INCENTIVES. The accumulatedNOTEPerNToken\\n        // must be updated given the block time. Use `getUpdatedAccumulatedNOTEPerNToken` instead\\n        accumulatedNOTEPerNToken = nTokenStorage.accumulatedNOTEPerNToken;\\n        lastAccumulatedTime = nTokenStorage.lastAccumulatedTime;\\n    }\\n\\n    /// @notice Returns the updated accumulated NOTE per nToken for calculating incentives\\n    function getUpdatedAccumulatedNOTEPerNToken(address tokenAddress, uint256 blockTime)\\n        internal view\\n        returns (\\n            uint256 totalSupply,\\n            uint256 accumulatedNOTEPerNToken,\\n            uint256 lastAccumulatedTime\\n        )\\n    {\\n        (\\n            totalSupply,\\n            accumulatedNOTEPerNToken,\\n            lastAccumulatedTime\\n        ) = getStoredNTokenSupplyFactors(tokenAddress);\\n\\n        // nToken totalSupply is never allowed to drop to zero but we check this here to avoid\\n        // divide by zero errors during initialization. Also ensure that lastAccumulatedTime is not\\n        // zero to avoid a massive accumulation amount on initialization.\\n        if (blockTime > lastAccumulatedTime && lastAccumulatedTime > 0 && totalSupply > 0) {\\n            // prettier-ignore\\n            (\\n                /* currencyId */,\\n                uint256 emissionRatePerYear,\\n                /* initializedTime */,\\n                /* assetArrayLength */,\\n                /* parameters */\\n            ) = nTokenHandler.getNTokenContext(tokenAddress);\\n\\n            uint256 additionalNOTEAccumulatedPerNToken = _calculateAdditionalNOTE(\\n                // Emission rate is denominated in whole tokens, scale to 1e8 decimals here\\n                emissionRatePerYear.mul(uint256(Constants.INTERNAL_TOKEN_PRECISION)),\\n                // Time since last accumulation (overflow checked above)\\n                blockTime - lastAccumulatedTime,\\n                totalSupply\\n            );\\n\\n            accumulatedNOTEPerNToken = accumulatedNOTEPerNToken.add(additionalNOTEAccumulatedPerNToken);\\n            require(accumulatedNOTEPerNToken < type(uint128).max); // dev: accumulated NOTE overflow\\n        }\\n    }\\n\\n    /// @notice additionalNOTEPerNToken accumulated since last accumulation time in 1e18 precision\\n    function _calculateAdditionalNOTE(\\n        uint256 emissionRatePerYear,\\n        uint256 timeSinceLastAccumulation,\\n        uint256 totalSupply\\n    )\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        // If we use 18 decimal places as the accumulation precision then we will overflow uint128 when\\n        // a single nToken has accumulated 3.4 x 10^20 NOTE tokens. This isn't possible since the max\\n        // NOTE that can accumulate is 10^16 (100 million NOTE in 1e8 precision) so we should be safe\\n        // using 18 decimal places and uint128 storage slot\\n\\n        // timeSinceLastAccumulation (SECONDS)\\n        // accumulatedNOTEPerSharePrecision (1e18)\\n        // emissionRatePerYear (INTERNAL_TOKEN_PRECISION)\\n        // DIVIDE BY\\n        // YEAR (SECONDS)\\n        // totalSupply (INTERNAL_TOKEN_PRECISION)\\n        return timeSinceLastAccumulation\\n            .mul(Constants.INCENTIVE_ACCUMULATION_PRECISION)\\n            .mul(emissionRatePerYear)\\n            .div(Constants.YEAR)\\n            // totalSupply > 0 is checked in the calling function\\n            .div(totalSupply);\\n    }\\n\\n    /// @notice Updates the nToken token supply amount when minting or redeeming.\\n    /// @param tokenAddress address of the nToken\\n    /// @param netChange positive or negative change to the total nToken supply\\n    /// @param blockTime current block time\\n    /// @return accumulatedNOTEPerNToken updated to the given block time\\n    function changeNTokenSupply(\\n        address tokenAddress,\\n        int256 netChange,\\n        uint256 blockTime\\n    ) internal returns (uint256) {\\n        (\\n            uint256 totalSupply,\\n            uint256 accumulatedNOTEPerNToken,\\n            /* uint256 lastAccumulatedTime */\\n        ) = getUpdatedAccumulatedNOTEPerNToken(tokenAddress, blockTime);\\n\\n        // Update storage variables\\n        mapping(address => nTokenTotalSupplyStorage) storage store = LibStorage.getNTokenTotalSupplyStorage();\\n        nTokenTotalSupplyStorage storage nTokenStorage = store[tokenAddress];\\n\\n        int256 newTotalSupply = int256(totalSupply).add(netChange);\\n        // We allow newTotalSupply to equal zero here even though it is prevented from being redeemed down to\\n        // exactly zero by other internal logic inside nTokenRedeem. This is meant to be purely an overflow check.\\n        require(0 <= newTotalSupply && uint256(newTotalSupply) < type(uint96).max); // dev: nToken supply overflow\\n\\n        nTokenStorage.totalSupply = uint96(newTotalSupply);\\n        // NOTE: overflow checked inside getUpdatedAccumulatedNOTEPerNToken so that behavior here mirrors what\\n        // the user would see if querying the view function\\n        nTokenStorage.accumulatedNOTEPerNToken = uint128(accumulatedNOTEPerNToken);\\n\\n        require(blockTime < type(uint32).max); // dev: block time overflow\\n        nTokenStorage.lastAccumulatedTime = uint32(blockTime);\\n\\n        return accumulatedNOTEPerNToken;\\n    }\\n\\n    /// @notice Called by governance to set the new emission rate\\n    function setIncentiveEmissionRate(address tokenAddress, uint32 newEmissionsRate, uint256 blockTime) internal {\\n        // Ensure that the accumulatedNOTEPerNToken updates to the current block time before we update the\\n        // emission rate\\n        changeNTokenSupply(tokenAddress, 0, blockTime);\\n\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\n        nTokenContext storage context = store[tokenAddress];\\n        context.incentiveAnnualEmissionRate = newEmissionsRate;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/internal/portfolio/BitmapAssetsHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../AccountContextHandler.sol\\\";\\nimport \\\"../markets/CashGroup.sol\\\";\\nimport \\\"../valuation/AssetHandler.sol\\\";\\nimport \\\"../../math/Bitmap.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"../../global/LibStorage.sol\\\";\\nimport \\\"../../global/Constants.sol\\\";\\nimport \\\"../../global/Types.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary BitmapAssetsHandler {\\n    using SafeMath for uint256;\\n    using SafeInt256 for int256;\\n    using Bitmap for bytes32;\\n    using CashGroup for CashGroupParameters;\\n    using AccountContextHandler for AccountContext;\\n\\n    function getAssetsBitmap(address account, uint256 currencyId) internal view returns (bytes32 assetsBitmap) {\\n        mapping(address => mapping(uint256 => bytes32)) storage store = LibStorage.getAssetsBitmapStorage();\\n        return store[account][currencyId];\\n    }\\n\\n    function setAssetsBitmap(\\n        address account,\\n        uint256 currencyId,\\n        bytes32 assetsBitmap\\n    ) internal {\\n        require(assetsBitmap.totalBitsSet() <= Constants.MAX_BITMAP_ASSETS, \\\"Over max assets\\\");\\n        mapping(address => mapping(uint256 => bytes32)) storage store = LibStorage.getAssetsBitmapStorage();\\n        store[account][currencyId] = assetsBitmap;\\n    }\\n\\n    function getifCashNotional(\\n        address account,\\n        uint256 currencyId,\\n        uint256 maturity\\n    ) internal view returns (int256 notional) {\\n        mapping(address => mapping(uint256 =>\\n            mapping(uint256 => ifCashStorage))) storage store = LibStorage.getifCashBitmapStorage();\\n        return store[account][currencyId][maturity].notional;\\n    }\\n\\n    /// @notice Adds multiple assets to a bitmap portfolio\\n    function addMultipleifCashAssets(\\n        address account,\\n        AccountContext memory accountContext,\\n        PortfolioAsset[] memory assets\\n    ) internal {\\n        require(accountContext.isBitmapEnabled()); // dev: bitmap currency not set\\n        uint256 currencyId = accountContext.bitmapCurrencyId;\\n\\n        for (uint256 i; i < assets.length; i++) {\\n            PortfolioAsset memory asset = assets[i];\\n            if (asset.notional == 0) continue;\\n\\n            require(asset.currencyId == currencyId); // dev: invalid asset in set ifcash assets\\n            require(asset.assetType == Constants.FCASH_ASSET_TYPE); // dev: invalid asset in set ifcash assets\\n            int256 finalNotional;\\n\\n            finalNotional = addifCashAsset(\\n                account,\\n                currencyId,\\n                asset.maturity,\\n                accountContext.nextSettleTime,\\n                asset.notional\\n            );\\n\\n            if (finalNotional < 0)\\n                accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_ASSET_DEBT;\\n        }\\n    }\\n\\n    /// @notice Add an ifCash asset in the bitmap and mapping. Updates the bitmap in memory\\n    /// but not in storage.\\n    /// @return the updated assets bitmap and the final notional amount\\n    function addifCashAsset(\\n        address account,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 nextSettleTime,\\n        int256 notional\\n    ) internal returns (int256) {\\n        bytes32 assetsBitmap = getAssetsBitmap(account, currencyId);\\n        mapping(address => mapping(uint256 =>\\n            mapping(uint256 => ifCashStorage))) storage store = LibStorage.getifCashBitmapStorage();\\n        ifCashStorage storage fCashSlot = store[account][currencyId][maturity];\\n        (uint256 bitNum, bool isExact) = DateTime.getBitNumFromMaturity(nextSettleTime, maturity);\\n        require(isExact); // dev: invalid maturity in set ifcash asset\\n\\n        if (assetsBitmap.isBitSet(bitNum)) {\\n            // Bit is set so we read and update the notional amount\\n            int256 finalNotional = notional.add(fCashSlot.notional);\\n            require(type(int128).min <= finalNotional && finalNotional <= type(int128).max); // dev: bitmap notional overflow\\n            fCashSlot.notional = int128(finalNotional);\\n\\n            // If the new notional is zero then turn off the bit\\n            if (finalNotional == 0) {\\n                assetsBitmap = assetsBitmap.setBit(bitNum, false);\\n            }\\n\\n            setAssetsBitmap(account, currencyId, assetsBitmap);\\n            return finalNotional;\\n        }\\n\\n        if (notional != 0) {\\n            // Bit is not set so we turn it on and update the mapping directly, no read required.\\n            require(type(int128).min <= notional && notional <= type(int128).max); // dev: bitmap notional overflow\\n            fCashSlot.notional = int128(notional);\\n\\n            assetsBitmap = assetsBitmap.setBit(bitNum, true);\\n            setAssetsBitmap(account, currencyId, assetsBitmap);\\n        }\\n\\n        return notional;\\n    }\\n\\n    /// @notice Returns the present value of an asset\\n    function getPresentValue(\\n        address account,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 blockTime,\\n        CashGroupParameters memory cashGroup,\\n        bool riskAdjusted\\n    ) internal view returns (int256) {\\n        int256 notional = getifCashNotional(account, currencyId, maturity);\\n\\n        // In this case the asset has matured and the total value is just the notional amount\\n        if (maturity <= blockTime) {\\n            return notional;\\n        } else {\\n            uint256 oracleRate = cashGroup.calculateOracleRate(maturity, blockTime);\\n            if (riskAdjusted) {\\n                return AssetHandler.getRiskAdjustedPresentfCashValue(\\n                    cashGroup,\\n                    notional,\\n                    maturity,\\n                    blockTime,\\n                    oracleRate\\n                );\\n            } else {\\n                return AssetHandler.getPresentfCashValue(\\n                    notional,\\n                    maturity,\\n                    blockTime,\\n                    oracleRate\\n                );\\n            }\\n        }\\n    }\\n\\n    function getNetPresentValueFromBitmap(\\n        address account,\\n        uint256 currencyId,\\n        uint256 nextSettleTime,\\n        uint256 blockTime,\\n        CashGroupParameters memory cashGroup,\\n        bool riskAdjusted,\\n        bytes32 assetsBitmap\\n    ) internal view returns (int256 totalValueUnderlying, bool hasDebt) {\\n        uint256 bitNum = assetsBitmap.getNextBitNum();\\n\\n        while (bitNum != 0) {\\n            uint256 maturity = DateTime.getMaturityFromBitNum(nextSettleTime, bitNum);\\n            int256 pv = getPresentValue(\\n                account,\\n                currencyId,\\n                maturity,\\n                blockTime,\\n                cashGroup,\\n                riskAdjusted\\n            );\\n            totalValueUnderlying = totalValueUnderlying.add(pv);\\n\\n            if (pv < 0) hasDebt = true;\\n\\n            // Turn off the bit and look for the next one\\n            assetsBitmap = assetsBitmap.setBit(bitNum, false);\\n            bitNum = assetsBitmap.getNextBitNum();\\n        }\\n    }\\n\\n    /// @notice Get the net present value of all the ifCash assets\\n    function getifCashNetPresentValue(\\n        address account,\\n        uint256 currencyId,\\n        uint256 nextSettleTime,\\n        uint256 blockTime,\\n        CashGroupParameters memory cashGroup,\\n        bool riskAdjusted\\n    ) internal view returns (int256 totalValueUnderlying, bool hasDebt) {\\n        bytes32 assetsBitmap = getAssetsBitmap(account, currencyId);\\n        return getNetPresentValueFromBitmap(\\n            account,\\n            currencyId,\\n            nextSettleTime,\\n            blockTime,\\n            cashGroup,\\n            riskAdjusted,\\n            assetsBitmap\\n        );\\n    }\\n\\n    /// @notice Returns the ifCash assets as an array\\n    function getifCashArray(\\n        address account,\\n        uint256 currencyId,\\n        uint256 nextSettleTime\\n    ) internal view returns (PortfolioAsset[] memory) {\\n        bytes32 assetsBitmap = getAssetsBitmap(account, currencyId);\\n        uint256 index = assetsBitmap.totalBitsSet();\\n        PortfolioAsset[] memory assets = new PortfolioAsset[](index);\\n        index = 0;\\n\\n        uint256 bitNum = assetsBitmap.getNextBitNum();\\n        while (bitNum != 0) {\\n            uint256 maturity = DateTime.getMaturityFromBitNum(nextSettleTime, bitNum);\\n            int256 notional = getifCashNotional(account, currencyId, maturity);\\n\\n            PortfolioAsset memory asset = assets[index];\\n            asset.currencyId = currencyId;\\n            asset.maturity = maturity;\\n            asset.assetType = Constants.FCASH_ASSET_TYPE;\\n            asset.notional = notional;\\n            index += 1;\\n\\n            // Turn off the bit and look for the next one\\n            assetsBitmap = assetsBitmap.setBit(bitNum, false);\\n            bitNum = assetsBitmap.getNextBitNum();\\n        }\\n\\n        return assets;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/internal/portfolio/PortfolioHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./TransferAssets.sol\\\";\\nimport \\\"../valuation/AssetHandler.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"../../global/LibStorage.sol\\\";\\n\\n/// @notice Handles the management of an array of assets including reading from storage, inserting\\n/// updating, deleting and writing back to storage.\\nlibrary PortfolioHandler {\\n    using SafeInt256 for int256;\\n    using AssetHandler for PortfolioAsset;\\n\\n    // Mirror of LibStorage.MAX_PORTFOLIO_ASSETS\\n    uint256 private constant MAX_PORTFOLIO_ASSETS = 16;\\n\\n    /// @notice Primarily used by the TransferAssets library\\n    function addMultipleAssets(PortfolioState memory portfolioState, PortfolioAsset[] memory assets)\\n        internal\\n        pure\\n    {\\n        for (uint256 i = 0; i < assets.length; i++) {\\n            PortfolioAsset memory asset = assets[i];\\n            if (asset.notional == 0) continue;\\n\\n            addAsset(\\n                portfolioState,\\n                asset.currencyId,\\n                asset.maturity,\\n                asset.assetType,\\n                asset.notional\\n            );\\n        }\\n    }\\n\\n    function _mergeAssetIntoArray(\\n        PortfolioAsset[] memory assetArray,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 assetType,\\n        int256 notional\\n    ) private pure returns (bool) {\\n        for (uint256 i = 0; i < assetArray.length; i++) {\\n            PortfolioAsset memory asset = assetArray[i];\\n            if (\\n                asset.assetType != assetType ||\\n                asset.currencyId != currencyId ||\\n                asset.maturity != maturity\\n            ) continue;\\n\\n            // Either of these storage states mean that some error in logic has occurred, we cannot\\n            // store this portfolio\\n            require(\\n                asset.storageState != AssetStorageState.Delete &&\\n                asset.storageState != AssetStorageState.RevertIfStored\\n            ); // dev: portfolio handler deleted storage\\n\\n            int256 newNotional = asset.notional.add(notional);\\n            // Liquidity tokens cannot be reduced below zero.\\n            if (AssetHandler.isLiquidityToken(assetType)) {\\n                require(newNotional >= 0); // dev: portfolio handler negative liquidity token balance\\n            }\\n\\n            require(newNotional >= type(int88).min && newNotional <= type(int88).max); // dev: portfolio handler notional overflow\\n\\n            asset.notional = newNotional;\\n            asset.storageState = AssetStorageState.Update;\\n\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @notice Adds an asset to a portfolio state in memory (does not write to storage)\\n    /// @dev Ensures that only one version of an asset exists in a portfolio (i.e. does not allow two fCash assets of the same maturity\\n    /// to exist in a single portfolio). Also ensures that liquidity tokens do not have a negative notional.\\n    function addAsset(\\n        PortfolioState memory portfolioState,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 assetType,\\n        int256 notional\\n    ) internal pure {\\n        if (\\n            // Will return true if merged\\n            _mergeAssetIntoArray(\\n                portfolioState.storedAssets,\\n                currencyId,\\n                maturity,\\n                assetType,\\n                notional\\n            )\\n        ) return;\\n\\n        if (portfolioState.lastNewAssetIndex > 0) {\\n            bool merged = _mergeAssetIntoArray(\\n                portfolioState.newAssets,\\n                currencyId,\\n                maturity,\\n                assetType,\\n                notional\\n            );\\n            if (merged) return;\\n        }\\n\\n        // At this point if we have not merged the asset then append to the array\\n        // Cannot remove liquidity that the portfolio does not have\\n        if (AssetHandler.isLiquidityToken(assetType)) {\\n            require(notional >= 0); // dev: portfolio handler negative liquidity token balance\\n        }\\n        require(notional >= type(int88).min && notional <= type(int88).max); // dev: portfolio handler notional overflow\\n\\n        // Need to provision a new array at this point\\n        if (portfolioState.lastNewAssetIndex == portfolioState.newAssets.length) {\\n            portfolioState.newAssets = _extendNewAssetArray(portfolioState.newAssets);\\n        }\\n\\n        // Otherwise add to the new assets array. It should not be possible to add matching assets in a single transaction, we will\\n        // check this again when we write to storage. Assigning to memory directly here, do not allocate new memory via struct.\\n        PortfolioAsset memory newAsset = portfolioState.newAssets[portfolioState.lastNewAssetIndex];\\n        newAsset.currencyId = currencyId;\\n        newAsset.maturity = maturity;\\n        newAsset.assetType = assetType;\\n        newAsset.notional = notional;\\n        newAsset.storageState = AssetStorageState.NoChange;\\n        portfolioState.lastNewAssetIndex += 1;\\n    }\\n\\n    /// @dev Extends the new asset array if it is not large enough, this is likely to get a bit expensive if we do\\n    /// it too much\\n    function _extendNewAssetArray(PortfolioAsset[] memory newAssets)\\n        private\\n        pure\\n        returns (PortfolioAsset[] memory)\\n    {\\n        // Double the size of the new asset array every time we have to extend to reduce the number of times\\n        // that we have to extend it. This will go: 0, 1, 2, 4, 8 (probably stops there).\\n        uint256 newLength = newAssets.length == 0 ? 1 : newAssets.length * 2;\\n        PortfolioAsset[] memory extendedArray = new PortfolioAsset[](newLength);\\n        for (uint256 i = 0; i < newAssets.length; i++) {\\n            extendedArray[i] = newAssets[i];\\n        }\\n\\n        return extendedArray;\\n    }\\n\\n    /// @notice Takes a portfolio state and writes it to storage.\\n    /// @dev This method should only be called directly by the nToken. Account updates to portfolios should happen via\\n    /// the storeAssetsAndUpdateContext call in the AccountContextHandler.sol library.\\n    /// @return updated variables to update the account context with\\n    ///     hasDebt: whether or not the portfolio has negative fCash assets\\n    ///     portfolioActiveCurrencies: a byte32 word with all the currencies in the portfolio\\n    ///     uint8: the length of the storage array\\n    ///     uint40: the new nextSettleTime for the portfolio\\n    function storeAssets(PortfolioState memory portfolioState, address account)\\n        internal\\n        returns (\\n            bool,\\n            bytes32,\\n            uint8,\\n            uint40\\n        )\\n    {\\n        bool hasDebt;\\n        // NOTE: cannot have more than 16 assets or this byte object will overflow. Max assets is\\n        // set to 7 and the worst case during liquidation would be 7 liquidity tokens that generate\\n        // 7 additional fCash assets for a total of 14 assets. Although even in this case all assets\\n        // would be of the same currency so it would not change the end result of the active currency\\n        // calculation.\\n        bytes32 portfolioActiveCurrencies;\\n        uint256 nextSettleTime;\\n\\n        for (uint256 i = 0; i < portfolioState.storedAssets.length; i++) {\\n            PortfolioAsset memory asset = portfolioState.storedAssets[i];\\n            // NOTE: this is to prevent the storage of assets that have been modified in the AssetHandler\\n            // during valuation.\\n            require(asset.storageState != AssetStorageState.RevertIfStored);\\n\\n            // Mark any zero notional assets as deleted\\n            if (asset.storageState != AssetStorageState.Delete && asset.notional == 0) {\\n                deleteAsset(portfolioState, i);\\n            }\\n        }\\n\\n        // First delete assets from asset storage to maintain asset storage indexes\\n        for (uint256 i = 0; i < portfolioState.storedAssets.length; i++) {\\n            PortfolioAsset memory asset = portfolioState.storedAssets[i];\\n\\n            if (asset.storageState == AssetStorageState.Delete) {\\n                // Delete asset from storage\\n                uint256 currentSlot = asset.storageSlot;\\n                assembly {\\n                    sstore(currentSlot, 0x00)\\n                }\\n            } else {\\n                if (asset.storageState == AssetStorageState.Update) {\\n                    PortfolioAssetStorage storage assetStorage;\\n                    uint256 currentSlot = asset.storageSlot;\\n                    assembly {\\n                        assetStorage.slot := currentSlot\\n                    }\\n\\n                    _storeAsset(asset, assetStorage);\\n                }\\n\\n                // Update portfolio context for every asset that is in storage, whether it is\\n                // updated in storage or not.\\n                (hasDebt, portfolioActiveCurrencies, nextSettleTime) = _updatePortfolioContext(\\n                    asset,\\n                    hasDebt,\\n                    portfolioActiveCurrencies,\\n                    nextSettleTime\\n                );\\n            }\\n        }\\n\\n        // Add new assets\\n        uint256 assetStorageLength = portfolioState.storedAssetLength;\\n        mapping(address => \\n            PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS]) storage store = LibStorage.getPortfolioArrayStorage();\\n        PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS] storage storageArray = store[account];\\n        for (uint256 i = 0; i < portfolioState.newAssets.length; i++) {\\n            PortfolioAsset memory asset = portfolioState.newAssets[i];\\n            if (asset.notional == 0) continue;\\n            require(\\n                asset.storageState != AssetStorageState.Delete &&\\n                asset.storageState != AssetStorageState.RevertIfStored\\n            ); // dev: store assets deleted storage\\n\\n            (hasDebt, portfolioActiveCurrencies, nextSettleTime) = _updatePortfolioContext(\\n                asset,\\n                hasDebt,\\n                portfolioActiveCurrencies,\\n                nextSettleTime\\n            );\\n\\n            _storeAsset(asset, storageArray[assetStorageLength]);\\n            assetStorageLength += 1;\\n        }\\n\\n        // 16 is the maximum number of assets or portfolio active currencies will overflow at 32 bytes with\\n        // 2 bytes per currency\\n        require(assetStorageLength <= 16 && nextSettleTime <= type(uint40).max); // dev: portfolio return value overflow\\n        return (\\n            hasDebt,\\n            portfolioActiveCurrencies,\\n            uint8(assetStorageLength),\\n            uint40(nextSettleTime)\\n        );\\n    }\\n\\n    /// @notice Updates context information during the store assets method\\n    function _updatePortfolioContext(\\n        PortfolioAsset memory asset,\\n        bool hasDebt,\\n        bytes32 portfolioActiveCurrencies,\\n        uint256 nextSettleTime\\n    )\\n        private\\n        pure\\n        returns (\\n            bool,\\n            bytes32,\\n            uint256\\n        )\\n    {\\n        uint256 settlementDate = asset.getSettlementDate();\\n        // Tis will set it to the minimum settlement date\\n        if (nextSettleTime == 0 || nextSettleTime > settlementDate) {\\n            nextSettleTime = settlementDate;\\n        }\\n        hasDebt = hasDebt || asset.notional < 0;\\n\\n        require(uint16(uint256(portfolioActiveCurrencies)) == 0); // dev: portfolio active currencies overflow\\n        portfolioActiveCurrencies = (portfolioActiveCurrencies >> 16) | (bytes32(asset.currencyId) << 240);\\n\\n        return (hasDebt, portfolioActiveCurrencies, nextSettleTime);\\n    }\\n\\n    /// @dev Encodes assets for storage\\n    function _storeAsset(\\n        PortfolioAsset memory asset,\\n        PortfolioAssetStorage storage assetStorage\\n    ) internal {\\n        require(0 < asset.currencyId && asset.currencyId <= Constants.MAX_CURRENCIES); // dev: encode asset currency id overflow\\n        require(0 < asset.maturity && asset.maturity <= type(uint40).max); // dev: encode asset maturity overflow\\n        require(0 < asset.assetType && asset.assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX); // dev: encode asset type invalid\\n        require(type(int88).min <= asset.notional && asset.notional <= type(int88).max); // dev: encode asset notional overflow\\n\\n        assetStorage.currencyId = uint16(asset.currencyId);\\n        assetStorage.maturity = uint40(asset.maturity);\\n        assetStorage.assetType = uint8(asset.assetType);\\n        assetStorage.notional = int88(asset.notional);\\n    }\\n\\n    /// @notice Deletes an asset from a portfolio\\n    /// @dev This method should only be called during settlement, assets can only be removed from a portfolio before settlement\\n    /// by adding the offsetting negative position\\n    function deleteAsset(PortfolioState memory portfolioState, uint256 index) internal pure {\\n        require(index < portfolioState.storedAssets.length); // dev: stored assets bounds\\n        require(portfolioState.storedAssetLength > 0); // dev: stored assets length is zero\\n        PortfolioAsset memory assetToDelete = portfolioState.storedAssets[index];\\n        require(\\n            assetToDelete.storageState != AssetStorageState.Delete &&\\n            assetToDelete.storageState != AssetStorageState.RevertIfStored\\n        ); // dev: cannot delete asset\\n\\n        portfolioState.storedAssetLength -= 1;\\n\\n        uint256 maxActiveSlotIndex;\\n        uint256 maxActiveSlot;\\n        // The max active slot is the last storage slot where an asset exists, it's not clear where this will be in the\\n        // array so we search for it here.\\n        for (uint256 i; i < portfolioState.storedAssets.length; i++) {\\n            PortfolioAsset memory a = portfolioState.storedAssets[i];\\n            if (a.storageSlot > maxActiveSlot && a.storageState != AssetStorageState.Delete) {\\n                maxActiveSlot = a.storageSlot;\\n                maxActiveSlotIndex = i;\\n            }\\n        }\\n\\n        if (index == maxActiveSlotIndex) {\\n            // In this case we are deleting the asset with the max storage slot so no swap is necessary.\\n            assetToDelete.storageState = AssetStorageState.Delete;\\n            return;\\n        }\\n\\n        // Swap the storage slots of the deleted asset with the last non-deleted asset in the array. Mark them accordingly\\n        // so that when we call store assets they will be updated appropriately\\n        PortfolioAsset memory assetToSwap = portfolioState.storedAssets[maxActiveSlotIndex];\\n        (\\n            assetToSwap.storageSlot,\\n            assetToDelete.storageSlot\\n        ) = (\\n            assetToDelete.storageSlot,\\n            assetToSwap.storageSlot\\n        );\\n        assetToSwap.storageState = AssetStorageState.Update;\\n        assetToDelete.storageState = AssetStorageState.Delete;\\n    }\\n\\n    /// @notice Returns a portfolio array, will be sorted\\n    function getSortedPortfolio(address account, uint8 assetArrayLength)\\n        internal\\n        view\\n        returns (PortfolioAsset[] memory)\\n    {\\n        PortfolioAsset[] memory assets = _loadAssetArray(account, assetArrayLength);\\n        // No sorting required for length of 1\\n        if (assets.length <= 1) return assets;\\n\\n        _sortInPlace(assets);\\n        return assets;\\n    }\\n\\n    /// @notice Builds a portfolio array from storage. The new assets hint parameter will\\n    /// be used to provision a new array for the new assets. This will increase gas efficiency\\n    /// so that we don't have to make copies when we extend the array.\\n    function buildPortfolioState(\\n        address account,\\n        uint8 assetArrayLength,\\n        uint256 newAssetsHint\\n    ) internal view returns (PortfolioState memory) {\\n        PortfolioState memory state;\\n        if (assetArrayLength == 0) return state;\\n\\n        state.storedAssets = getSortedPortfolio(account, assetArrayLength);\\n        state.storedAssetLength = assetArrayLength;\\n        state.newAssets = new PortfolioAsset[](newAssetsHint);\\n\\n        return state;\\n    }\\n\\n    function _sortInPlace(PortfolioAsset[] memory assets) private pure {\\n        uint256 length = assets.length;\\n        uint256[] memory ids = new uint256[](length);\\n        for (uint256 k; k < length; k++) {\\n            PortfolioAsset memory asset = assets[k];\\n            // Prepopulate the ids to calculate just once\\n            ids[k] = TransferAssets.encodeAssetId(asset.currencyId, asset.maturity, asset.assetType);\\n        }\\n\\n        // Uses insertion sort \\n        uint256 i = 1;\\n        while (i < length) {\\n            uint256 j = i;\\n            while (j > 0 && ids[j - 1] > ids[j]) {\\n                // Swap j - 1 and j\\n                (ids[j - 1], ids[j]) = (ids[j], ids[j - 1]);\\n                (assets[j - 1], assets[j]) = (assets[j], assets[j - 1]);\\n                j--;\\n            }\\n            i++;\\n        }\\n    }\\n\\n    function _loadAssetArray(address account, uint8 length)\\n        private\\n        view\\n        returns (PortfolioAsset[] memory)\\n    {\\n        // This will overflow the storage pointer\\n        require(length <= MAX_PORTFOLIO_ASSETS);\\n\\n        mapping(address => \\n            PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS]) storage store = LibStorage.getPortfolioArrayStorage();\\n        PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS] storage storageArray = store[account];\\n        PortfolioAsset[] memory assets = new PortfolioAsset[](length);\\n\\n        for (uint256 i = 0; i < length; i++) {\\n            PortfolioAssetStorage storage assetStorage = storageArray[i];\\n            PortfolioAsset memory asset = assets[i];\\n            uint256 slot;\\n            assembly {\\n                slot := assetStorage.slot\\n            }\\n\\n            asset.currencyId = assetStorage.currencyId;\\n            asset.maturity = assetStorage.maturity;\\n            asset.assetType = assetStorage.assetType;\\n            asset.notional = assetStorage.notional;\\n            asset.storageSlot = slot;\\n        }\\n\\n        return assets;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/portfolio/TransferAssets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./PortfolioHandler.sol\\\";\\nimport \\\"./BitmapAssetsHandler.sol\\\";\\nimport \\\"../AccountContextHandler.sol\\\";\\nimport \\\"../../global/Types.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\n\\n/// @notice Helper library for transferring assets from one portfolio to another\\nlibrary TransferAssets {\\n    using AccountContextHandler for AccountContext;\\n    using PortfolioHandler for PortfolioState;\\n    using SafeInt256 for int256;\\n\\n    /// @notice Decodes asset ids\\n    function decodeAssetId(uint256 id)\\n        internal\\n        pure\\n        returns (\\n            uint256 currencyId,\\n            uint256 maturity,\\n            uint256 assetType\\n        )\\n    {\\n        assetType = uint8(id);\\n        maturity = uint40(id >> 8);\\n        currencyId = uint16(id >> 48);\\n    }\\n\\n    /// @notice Encodes asset ids\\n    function encodeAssetId(\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 assetType\\n    ) internal pure returns (uint256) {\\n        require(currencyId <= Constants.MAX_CURRENCIES);\\n        require(maturity <= type(uint40).max);\\n        require(assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX);\\n\\n        return\\n            uint256(\\n                (bytes32(uint256(uint16(currencyId))) << 48) |\\n                    (bytes32(uint256(uint40(maturity))) << 8) |\\n                    bytes32(uint256(uint8(assetType)))\\n            );\\n    }\\n\\n    /// @dev Used to flip the sign of assets to decrement the `from` account that is sending assets\\n    function invertNotionalAmountsInPlace(PortfolioAsset[] memory assets) internal pure {\\n        for (uint256 i; i < assets.length; i++) {\\n            assets[i].notional = assets[i].notional.neg();\\n        }\\n    }\\n\\n    /// @dev Useful method for hiding the logic of updating an account. WARNING: the account\\n    /// context returned from this method may not be the same memory location as the account\\n    /// context provided if the account is settled.\\n    function placeAssetsInAccount(\\n        address account,\\n        AccountContext memory accountContext,\\n        PortfolioAsset[] memory assets\\n    ) internal returns (AccountContext memory) {\\n        // If an account has assets that require settlement then placing assets inside it\\n        // may cause issues.\\n        require(!accountContext.mustSettleAssets(), \\\"Account must settle\\\");\\n\\n        if (accountContext.isBitmapEnabled()) {\\n            // Adds fCash assets into the account and finalized storage\\n            BitmapAssetsHandler.addMultipleifCashAssets(account, accountContext, assets);\\n        } else {\\n            PortfolioState memory portfolioState = PortfolioHandler.buildPortfolioState(\\n                account,\\n                accountContext.assetArrayLength,\\n                assets.length\\n            );\\n            // This will add assets in memory\\n            portfolioState.addMultipleAssets(assets);\\n            // This will store assets and update the account context in memory\\n            accountContext.storeAssetsAndUpdateContext(account, portfolioState, false);\\n        }\\n\\n        return accountContext;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/settlement/SettleBitmapAssets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../markets/AssetRate.sol\\\";\\nimport \\\"../../global/LibStorage.sol\\\";\\nimport \\\"../portfolio/BitmapAssetsHandler.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"../../math/Bitmap.sol\\\";\\nimport \\\"../../global/Constants.sol\\\";\\nimport \\\"../../global/Types.sol\\\";\\n\\n/**\\n * Settles a bitmap portfolio by checking for all matured fCash assets and turning them into cash\\n * at the prevailing settlement rate. It will also update the asset bitmap to ensure that it continues\\n * to correctly reference all actual maturities. fCash asset notional values are stored in *absolute* \\n * time terms and bitmap bits are *relative* time terms based on the bitNumber and the stored oldSettleTime.\\n * Remapping bits requires converting the old relative bit numbers to new relative bit numbers based on\\n * newSettleTime and the absolute times (maturities) that the previous bitmap references.\\n */\\nlibrary SettleBitmapAssets {\\n    using SafeInt256 for int256;\\n    using AssetRate for AssetRateParameters;\\n    using Bitmap for bytes32;\\n\\n    /// @notice Given a bitmap for a cash group and timestamps, will settle all assets\\n    /// that have matured and remap the bitmap to correspond to the current time.\\n    function settleBitmappedCashGroup(\\n        address account,\\n        uint256 currencyId,\\n        uint256 oldSettleTime,\\n        uint256 blockTime\\n    ) internal returns (int256 totalAssetCash, uint256 newSettleTime) {\\n        bytes32 bitmap = BitmapAssetsHandler.getAssetsBitmap(account, currencyId);\\n\\n        // This newSettleTime will be set to the new `oldSettleTime`. The bits between 1 and\\n        // `lastSettleBit` (inclusive) will be shifted out of the bitmap and settled. The reason\\n        // that lastSettleBit is inclusive is that it refers to newSettleTime which always less\\n        // than the current block time.\\n        newSettleTime = DateTime.getTimeUTC0(blockTime);\\n        // If newSettleTime == oldSettleTime lastSettleBit will be zero\\n        require(newSettleTime >= oldSettleTime); // dev: new settle time before previous\\n\\n        // Do not need to worry about validity, if newSettleTime is not on an exact bit we will settle up until\\n        // the closest maturity that is less than newSettleTime.\\n        (uint256 lastSettleBit, /* isValid */) = DateTime.getBitNumFromMaturity(oldSettleTime, newSettleTime);\\n        if (lastSettleBit == 0) return (totalAssetCash, newSettleTime);\\n\\n        // Returns the next bit that is set in the bitmap\\n        uint256 nextBitNum = bitmap.getNextBitNum();\\n        while (nextBitNum != 0 && nextBitNum <= lastSettleBit) {\\n            uint256 maturity = DateTime.getMaturityFromBitNum(oldSettleTime, nextBitNum);\\n            totalAssetCash = totalAssetCash.add(\\n                _settlefCashAsset(account, currencyId, maturity, blockTime)\\n            );\\n\\n            // Turn the bit off now that it is settled\\n            bitmap = bitmap.setBit(nextBitNum, false);\\n            nextBitNum = bitmap.getNextBitNum();\\n        }\\n\\n        bytes32 newBitmap;\\n        while (nextBitNum != 0) {\\n            uint256 maturity = DateTime.getMaturityFromBitNum(oldSettleTime, nextBitNum);\\n            (uint256 newBitNum, bool isValid) = DateTime.getBitNumFromMaturity(newSettleTime, maturity);\\n            require(isValid); // dev: invalid new bit num\\n\\n            newBitmap = newBitmap.setBit(newBitNum, true);\\n\\n            // Turn the bit off now that it is remapped\\n            bitmap = bitmap.setBit(nextBitNum, false);\\n            nextBitNum = bitmap.getNextBitNum();\\n        }\\n\\n        BitmapAssetsHandler.setAssetsBitmap(account, currencyId, newBitmap);\\n    }\\n\\n    /// @dev Stateful settlement function to settle a bitmapped asset. Deletes the\\n    /// asset from storage after calculating it.\\n    function _settlefCashAsset(\\n        address account,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) private returns (int256 assetCash) {\\n        mapping(address => mapping(uint256 =>\\n            mapping(uint256 => ifCashStorage))) storage store = LibStorage.getifCashBitmapStorage();\\n        int256 notional = store[account][currencyId][maturity].notional;\\n        \\n        // Gets the current settlement rate or will store a new settlement rate if it does not\\n        // yet exist.\\n        AssetRateParameters memory rate =\\n            AssetRate.buildSettlementRateStateful(currencyId, maturity, blockTime);\\n        assetCash = rate.convertFromUnderlying(notional);\\n\\n        delete store[account][currencyId][maturity];\\n\\n        return assetCash;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/settlement/SettlePortfolioAssets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../valuation/AssetHandler.sol\\\";\\nimport \\\"../markets/Market.sol\\\";\\nimport \\\"../markets/AssetRate.sol\\\";\\nimport \\\"../portfolio/PortfolioHandler.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"../../global/Constants.sol\\\";\\nimport \\\"../../global/Types.sol\\\";\\n\\nlibrary SettlePortfolioAssets {\\n    using SafeInt256 for int256;\\n    using AssetRate for AssetRateParameters;\\n    using Market for MarketParameters;\\n    using PortfolioHandler for PortfolioState;\\n    using AssetHandler for PortfolioAsset;\\n\\n    /// @dev Returns a SettleAmount array for the assets that will be settled\\n    function _getSettleAmountArray(PortfolioState memory portfolioState, uint256 blockTime)\\n        private\\n        pure\\n        returns (SettleAmount[] memory)\\n    {\\n        uint256 currenciesSettled;\\n        uint256 lastCurrencyId = 0;\\n        if (portfolioState.storedAssets.length == 0) return new SettleAmount[](0);\\n\\n        // Loop backwards so \\\"lastCurrencyId\\\" will be set to the first currency in the portfolio\\n        // NOTE: if this contract is ever upgraded to Solidity 0.8+ then this i-- will underflow and cause\\n        // a revert, must wrap in an unchecked.\\n        for (uint256 i = portfolioState.storedAssets.length; (i--) > 0;) {\\n            PortfolioAsset memory asset = portfolioState.storedAssets[i];\\n            // Assets settle on exactly blockTime\\n            if (asset.getSettlementDate() > blockTime) continue;\\n\\n            // Assume that this is sorted by cash group and maturity, currencyId = 0 is unused so this\\n            // will work for the first asset\\n            if (lastCurrencyId != asset.currencyId) {\\n                lastCurrencyId = asset.currencyId;\\n                currenciesSettled++;\\n            }\\n        }\\n\\n        // Actual currency ids will be set as we loop through the portfolio and settle assets\\n        SettleAmount[] memory settleAmounts = new SettleAmount[](currenciesSettled);\\n        if (currenciesSettled > 0) settleAmounts[0].currencyId = lastCurrencyId;\\n        return settleAmounts;\\n    }\\n\\n    /// @notice Settles a portfolio array\\n    function settlePortfolio(PortfolioState memory portfolioState, uint256 blockTime)\\n        internal\\n        returns (SettleAmount[] memory)\\n    {\\n        AssetRateParameters memory settlementRate;\\n        SettleAmount[] memory settleAmounts = _getSettleAmountArray(portfolioState, blockTime);\\n        MarketParameters memory market;\\n        if (settleAmounts.length == 0) return settleAmounts;\\n        uint256 settleAmountIndex;\\n\\n        for (uint256 i; i < portfolioState.storedAssets.length; i++) {\\n            PortfolioAsset memory asset = portfolioState.storedAssets[i];\\n            uint256 settleDate = asset.getSettlementDate();\\n            // Settlement date is on block time exactly\\n            if (settleDate > blockTime) continue;\\n\\n            // On the first loop the lastCurrencyId is already set.\\n            if (settleAmounts[settleAmountIndex].currencyId != asset.currencyId) {\\n                // New currency in the portfolio\\n                settleAmountIndex += 1;\\n                settleAmounts[settleAmountIndex].currencyId = asset.currencyId;\\n            }\\n\\n            int256 assetCash;\\n            if (asset.assetType == Constants.FCASH_ASSET_TYPE) {\\n                // Gets or sets the settlement rate, only do this before settling fCash\\n                settlementRate = AssetRate.buildSettlementRateStateful(\\n                    asset.currencyId,\\n                    asset.maturity,\\n                    blockTime\\n                );\\n\\n                assetCash = settlementRate.convertFromUnderlying(asset.notional);\\n                portfolioState.deleteAsset(i);\\n            } else if (AssetHandler.isLiquidityToken(asset.assetType)) {\\n                Market.loadSettlementMarket(market, asset.currencyId, asset.maturity, settleDate);\\n                int256 fCash;\\n                (assetCash, fCash) = market.removeLiquidity(asset.notional);\\n\\n                // Assets mature exactly on block time\\n                if (asset.maturity > blockTime) {\\n                    // If fCash has not yet matured then add it to the portfolio\\n                    _settleLiquidityTokenTofCash(portfolioState, i, fCash);\\n                } else {\\n                    // Gets or sets the settlement rate, only do this before settling fCash\\n                    settlementRate = AssetRate.buildSettlementRateStateful(\\n                        asset.currencyId,\\n                        asset.maturity,\\n                        blockTime\\n                    );\\n\\n                    // If asset has matured then settle fCash to asset cash\\n                    assetCash = assetCash.add(settlementRate.convertFromUnderlying(fCash));\\n                    portfolioState.deleteAsset(i);\\n                }\\n            }\\n            settleAmounts[settleAmountIndex].netCashChange = settleAmounts[settleAmountIndex]\\n                .netCashChange\\n                .add(assetCash);\\n        }\\n\\n        return settleAmounts;\\n    }\\n\\n    /// @notice Settles a liquidity token to idiosyncratic fCash, this occurs when the maturity is still in the future\\n    function _settleLiquidityTokenTofCash(\\n        PortfolioState memory portfolioState,\\n        uint256 index,\\n        int256 fCash\\n    ) private pure {\\n        PortfolioAsset memory liquidityToken = portfolioState.storedAssets[index];\\n        // If the liquidity token's maturity is still in the future then we change the entry to be\\n        // an idiosyncratic fCash entry with the net fCash amount.\\n        if (index != 0) {\\n            // Check to see if the previous index is the matching fCash asset, this will be the case when the\\n            // portfolio is sorted\\n            PortfolioAsset memory fCashAsset = portfolioState.storedAssets[index - 1];\\n\\n            if (\\n                fCashAsset.currencyId == liquidityToken.currencyId &&\\n                fCashAsset.maturity == liquidityToken.maturity &&\\n                fCashAsset.assetType == Constants.FCASH_ASSET_TYPE\\n            ) {\\n                // This fCash asset has not matured if we are settling to fCash\\n                fCashAsset.notional = fCashAsset.notional.add(fCash);\\n                fCashAsset.storageState = AssetStorageState.Update;\\n                portfolioState.deleteAsset(index);\\n            }\\n        }\\n\\n        // We are going to delete this asset anyway, convert to an fCash position\\n        liquidityToken.assetType = Constants.FCASH_ASSET_TYPE;\\n        liquidityToken.notional = fCash;\\n        liquidityToken.storageState = AssetStorageState.Update;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/valuation/AssetHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../../global/Types.sol\\\";\\nimport \\\"../../global/Constants.sol\\\";\\nimport \\\"../markets/CashGroup.sol\\\";\\nimport \\\"../markets/AssetRate.sol\\\";\\nimport \\\"../markets/DateTime.sol\\\";\\nimport \\\"../portfolio/PortfolioHandler.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"../../math/ABDKMath64x64.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary AssetHandler {\\n    using SafeMath for uint256;\\n    using SafeInt256 for int256;\\n    using CashGroup for CashGroupParameters;\\n    using AssetRate for AssetRateParameters;\\n\\n    function isLiquidityToken(uint256 assetType) internal pure returns (bool) {\\n        return\\n            assetType >= Constants.MIN_LIQUIDITY_TOKEN_INDEX &&\\n            assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX;\\n    }\\n\\n    /// @notice Liquidity tokens settle every 90 days (not at the designated maturity). This method\\n    /// calculates the settlement date for any PortfolioAsset.\\n    function getSettlementDate(PortfolioAsset memory asset) internal pure returns (uint256) {\\n        require(asset.assetType > 0 && asset.assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX); // dev: settlement date invalid asset type\\n        // 3 month tokens and fCash tokens settle at maturity\\n        if (asset.assetType <= Constants.MIN_LIQUIDITY_TOKEN_INDEX) return asset.maturity;\\n\\n        uint256 marketLength = DateTime.getTradedMarket(asset.assetType - 1);\\n        // Liquidity tokens settle at tRef + 90 days. The formula to get a maturity is:\\n        // maturity = tRef + marketLength\\n        // Here we calculate:\\n        // tRef = (maturity - marketLength) + 90 days\\n        return asset.maturity.sub(marketLength).add(Constants.QUARTER);\\n    }\\n\\n    /// @notice Returns the continuously compounded discount rate given an oracle rate and a time to maturity.\\n    /// The formula is: e^(-rate * timeToMaturity).\\n    function getDiscountFactor(uint256 timeToMaturity, uint256 oracleRate)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        int128 expValue =\\n            ABDKMath64x64.fromUInt(oracleRate.mul(timeToMaturity).div(Constants.IMPLIED_RATE_TIME));\\n        expValue = ABDKMath64x64.div(expValue, Constants.RATE_PRECISION_64x64);\\n        expValue = ABDKMath64x64.exp(ABDKMath64x64.neg(expValue));\\n        expValue = ABDKMath64x64.mul(expValue, Constants.RATE_PRECISION_64x64);\\n        int256 discountFactor = ABDKMath64x64.toInt(expValue);\\n\\n        return discountFactor;\\n    }\\n\\n    /// @notice Present value of an fCash asset without any risk adjustments.\\n    function getPresentfCashValue(\\n        int256 notional,\\n        uint256 maturity,\\n        uint256 blockTime,\\n        uint256 oracleRate\\n    ) internal pure returns (int256) {\\n        if (notional == 0) return 0;\\n\\n        // NOTE: this will revert if maturity < blockTime. That is the correct behavior because we cannot\\n        // discount matured assets.\\n        uint256 timeToMaturity = maturity.sub(blockTime);\\n        int256 discountFactor = getDiscountFactor(timeToMaturity, oracleRate);\\n\\n        require(discountFactor <= Constants.RATE_PRECISION); // dev: get present value invalid discount factor\\n        return notional.mulInRatePrecision(discountFactor);\\n    }\\n\\n    /// @notice Present value of an fCash asset with risk adjustments. Positive fCash value will be discounted more\\n    /// heavily than the oracle rate given and vice versa for negative fCash.\\n    function getRiskAdjustedPresentfCashValue(\\n        CashGroupParameters memory cashGroup,\\n        int256 notional,\\n        uint256 maturity,\\n        uint256 blockTime,\\n        uint256 oracleRate\\n    ) internal pure returns (int256) {\\n        if (notional == 0) return 0;\\n        // NOTE: this will revert if maturity < blockTime. That is the correct behavior because we cannot\\n        // discount matured assets.\\n        uint256 timeToMaturity = maturity.sub(blockTime);\\n\\n        int256 discountFactor;\\n        if (notional > 0) {\\n            // If fCash is positive then discounting by a higher rate will result in a smaller\\n            // discount factor (e ^ -x), meaning a lower positive fCash value.\\n            discountFactor = getDiscountFactor(\\n                timeToMaturity,\\n                oracleRate.add(cashGroup.getfCashHaircut())\\n            );\\n        } else {\\n            uint256 debtBuffer = cashGroup.getDebtBuffer();\\n            // If the adjustment exceeds the oracle rate we floor the value of the fCash\\n            // at the notional value. We don't want to require the account to hold more than\\n            // absolutely required.\\n            if (debtBuffer >= oracleRate) return notional;\\n\\n            discountFactor = getDiscountFactor(timeToMaturity, oracleRate - debtBuffer);\\n        }\\n\\n        require(discountFactor <= Constants.RATE_PRECISION); // dev: get risk adjusted pv, invalid discount factor\\n        return notional.mulInRatePrecision(discountFactor);\\n    }\\n\\n    /// @notice Returns the non haircut claims on cash and fCash by the liquidity token.\\n    function getCashClaims(PortfolioAsset memory token, MarketParameters memory market)\\n        internal\\n        pure\\n        returns (int256 assetCash, int256 fCash)\\n    {\\n        require(isLiquidityToken(token.assetType) && token.notional >= 0); // dev: invalid asset, get cash claims\\n\\n        assetCash = market.totalAssetCash.mul(token.notional).div(market.totalLiquidity);\\n        fCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity);\\n    }\\n\\n    /// @notice Returns the haircut claims on cash and fCash\\n    function getHaircutCashClaims(\\n        PortfolioAsset memory token,\\n        MarketParameters memory market,\\n        CashGroupParameters memory cashGroup\\n    ) internal pure returns (int256 assetCash, int256 fCash) {\\n        require(isLiquidityToken(token.assetType) && token.notional >= 0); // dev: invalid asset get haircut cash claims\\n\\n        require(token.currencyId == cashGroup.currencyId); // dev: haircut cash claims, currency id mismatch\\n        // This won't overflow, the liquidity token haircut is stored as an uint8\\n        int256 haircut = int256(cashGroup.getLiquidityHaircut(token.assetType));\\n\\n        assetCash =\\n            _calcToken(market.totalAssetCash, token.notional, haircut, market.totalLiquidity);\\n\\n        fCash =\\n            _calcToken(market.totalfCash, token.notional, haircut, market.totalLiquidity);\\n\\n        return (assetCash, fCash);\\n    }\\n\\n    /// @dev This is here to clean up the stack in getHaircutCashClaims\\n    function _calcToken(\\n        int256 numerator,\\n        int256 tokens,\\n        int256 haircut,\\n        int256 liquidity\\n    ) private pure returns (int256) {\\n        return numerator.mul(tokens).mul(haircut).div(Constants.PERCENTAGE_DECIMALS).div(liquidity);\\n    }\\n\\n    /// @notice Returns the asset cash claim and the present value of the fCash asset (if it exists)\\n    function getLiquidityTokenValue(\\n        uint256 index,\\n        CashGroupParameters memory cashGroup,\\n        MarketParameters memory market,\\n        PortfolioAsset[] memory assets,\\n        uint256 blockTime,\\n        bool riskAdjusted\\n    ) internal view returns (int256, int256) {\\n        PortfolioAsset memory liquidityToken = assets[index];\\n\\n        {\\n            (uint256 marketIndex, bool idiosyncratic) =\\n                DateTime.getMarketIndex(\\n                    cashGroup.maxMarketIndex,\\n                    liquidityToken.maturity,\\n                    blockTime\\n                );\\n            // Liquidity tokens can never be idiosyncratic\\n            require(!idiosyncratic); // dev: idiosyncratic liquidity token\\n\\n            // This market will always be initialized, if a liquidity token exists that means the\\n            // market has some liquidity in it.\\n            cashGroup.loadMarket(market, marketIndex, true, blockTime);\\n        }\\n\\n        int256 assetCashClaim;\\n        int256 fCashClaim;\\n        if (riskAdjusted) {\\n            (assetCashClaim, fCashClaim) = getHaircutCashClaims(liquidityToken, market, cashGroup);\\n        } else {\\n            (assetCashClaim, fCashClaim) = getCashClaims(liquidityToken, market);\\n        }\\n\\n        // Find the matching fCash asset and net off the value, assumes that the portfolio is sorted and\\n        // in that case we know the previous asset will be the matching fCash asset\\n        if (index > 0) {\\n            PortfolioAsset memory maybefCash = assets[index - 1];\\n            if (\\n                maybefCash.assetType == Constants.FCASH_ASSET_TYPE &&\\n                maybefCash.currencyId == liquidityToken.currencyId &&\\n                maybefCash.maturity == liquidityToken.maturity\\n            ) {\\n                // Net off the fCashClaim here and we will discount it to present value in the second pass.\\n                // WARNING: this modifies the portfolio in memory and therefore we cannot store this portfolio!\\n                maybefCash.notional = maybefCash.notional.add(fCashClaim);\\n                // This state will prevent the fCash asset from being stored.\\n                maybefCash.storageState = AssetStorageState.RevertIfStored;\\n                return (assetCashClaim, 0);\\n            }\\n        }\\n\\n        // If not matching fCash asset found then get the pv directly\\n        if (riskAdjusted) {\\n            int256 pv =\\n                getRiskAdjustedPresentfCashValue(\\n                    cashGroup,\\n                    fCashClaim,\\n                    liquidityToken.maturity,\\n                    blockTime,\\n                    market.oracleRate\\n                );\\n\\n            return (assetCashClaim, pv);\\n        } else {\\n            int256 pv =\\n                getPresentfCashValue(fCashClaim, liquidityToken.maturity, blockTime, market.oracleRate);\\n\\n            return (assetCashClaim, pv);\\n        }\\n    }\\n\\n    /// @notice Returns present value of all assets in the cash group as asset cash and the updated\\n    /// portfolio index where the function has ended.\\n    /// @return the value of the cash group in asset cash\\n    function getNetCashGroupValue(\\n        PortfolioAsset[] memory assets,\\n        CashGroupParameters memory cashGroup,\\n        MarketParameters memory market,\\n        uint256 blockTime,\\n        uint256 portfolioIndex\\n    ) internal view returns (int256, uint256) {\\n        int256 presentValueAsset;\\n        int256 presentValueUnderlying;\\n\\n        // First calculate value of liquidity tokens because we need to net off fCash value\\n        // before discounting to present value\\n        for (uint256 i = portfolioIndex; i < assets.length; i++) {\\n            if (!isLiquidityToken(assets[i].assetType)) continue;\\n            if (assets[i].currencyId != cashGroup.currencyId) break;\\n\\n            (int256 assetCashClaim, int256 pv) =\\n                getLiquidityTokenValue(\\n                    i,\\n                    cashGroup,\\n                    market,\\n                    assets,\\n                    blockTime,\\n                    true // risk adjusted\\n                );\\n\\n            presentValueAsset = presentValueAsset.add(assetCashClaim);\\n            presentValueUnderlying = presentValueUnderlying.add(pv);\\n        }\\n\\n        uint256 j = portfolioIndex;\\n        for (; j < assets.length; j++) {\\n            PortfolioAsset memory a = assets[j];\\n            if (a.assetType != Constants.FCASH_ASSET_TYPE) continue;\\n            // If we hit a different currency id then we've accounted for all assets in this currency\\n            // j will mark the index where we don't have this currency anymore\\n            if (a.currencyId != cashGroup.currencyId) break;\\n\\n            uint256 oracleRate = cashGroup.calculateOracleRate(a.maturity, blockTime);\\n\\n            int256 pv =\\n                getRiskAdjustedPresentfCashValue(\\n                    cashGroup,\\n                    a.notional,\\n                    a.maturity,\\n                    blockTime,\\n                    oracleRate\\n                );\\n            presentValueUnderlying = presentValueUnderlying.add(pv);\\n        }\\n\\n        presentValueAsset = presentValueAsset.add(\\n            cashGroup.assetRate.convertFromUnderlying(presentValueUnderlying)\\n        );\\n\\n        return (presentValueAsset, j);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/valuation/ExchangeRate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../balances/TokenHandler.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"../../../interfaces/chainlink/AggregatorV2V3Interface.sol\\\";\\n\\nlibrary ExchangeRate {\\n    using SafeInt256 for int256;\\n\\n    /// @notice Converts a balance to ETH from a base currency. Buffers or haircuts are\\n    /// always applied in this method.\\n    /// @param er exchange rate object from base to ETH\\n    /// @return the converted balance denominated in ETH with Constants.INTERNAL_TOKEN_PRECISION\\n    function convertToETH(ETHRate memory er, int256 balance) internal pure returns (int256) {\\n        int256 multiplier = balance > 0 ? er.haircut : er.buffer;\\n\\n        // We are converting internal balances here so we know they have INTERNAL_TOKEN_PRECISION decimals\\n        // internalDecimals * rateDecimals * multiplier /  (rateDecimals * multiplierDecimals)\\n        // Therefore the result is in ethDecimals\\n        int256 result =\\n            balance.mul(er.rate).mul(multiplier).div(Constants.PERCENTAGE_DECIMALS).div(\\n                er.rateDecimals\\n            );\\n\\n        return result;\\n    }\\n\\n    /// @notice Converts the balance denominated in ETH to the equivalent value in a base currency.\\n    /// Buffers and haircuts ARE NOT applied in this method.\\n    /// @param er exchange rate object from base to ETH\\n    /// @param balance amount (denominated in ETH) to convert\\n    function convertETHTo(ETHRate memory er, int256 balance) internal pure returns (int256) {\\n        // We are converting internal balances here so we know they have INTERNAL_TOKEN_PRECISION decimals\\n        // internalDecimals * rateDecimals / rateDecimals\\n        int256 result = balance.mul(er.rateDecimals).div(er.rate);\\n\\n        return result;\\n    }\\n\\n    /// @notice Calculates the exchange rate between two currencies via ETH. Returns the rate denominated in\\n    /// base exchange rate decimals: (baseRateDecimals * quoteRateDecimals) / quoteRateDecimals\\n    /// @param baseER base exchange rate struct\\n    /// @param quoteER quote exchange rate struct\\n    function exchangeRate(ETHRate memory baseER, ETHRate memory quoteER)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        return baseER.rate.mul(quoteER.rateDecimals).div(quoteER.rate);\\n    }\\n\\n    /// @notice Returns an ETHRate object used to calculate free collateral\\n    function buildExchangeRate(uint256 currencyId) internal view returns (ETHRate memory) {\\n        mapping(uint256 => ETHRateStorage) storage store = LibStorage.getExchangeRateStorage();\\n        ETHRateStorage storage ethStorage = store[currencyId];\\n\\n        int256 rateDecimals;\\n        int256 rate;\\n        if (currencyId == Constants.ETH_CURRENCY_ID) {\\n            // ETH rates will just be 1e18, but will still have buffers, haircuts,\\n            // and liquidation discounts\\n            rateDecimals = Constants.ETH_DECIMALS;\\n            rate = Constants.ETH_DECIMALS;\\n        } else {\\n            // prettier-ignore\\n            (\\n                /* roundId */,\\n                rate,\\n                /* uint256 startedAt */,\\n                /* updatedAt */,\\n                /* answeredInRound */\\n            ) = ethStorage.rateOracle.latestRoundData();\\n            require(rate > 0, \\\"Invalid rate\\\");\\n\\n            // No overflow, restricted on storage\\n            rateDecimals = int256(10**ethStorage.rateDecimalPlaces);\\n            if (ethStorage.mustInvert) {\\n                rate = rateDecimals.mul(rateDecimals).div(rate);\\n            }\\n        }\\n\\n        return\\n            ETHRate({\\n                rateDecimals: rateDecimals,\\n                rate: rate,\\n                buffer: ethStorage.buffer,\\n                haircut: ethStorage.haircut,\\n                liquidationDiscount: ethStorage.liquidationDiscount\\n            });\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/valuation/FreeCollateral.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./AssetHandler.sol\\\";\\nimport \\\"./ExchangeRate.sol\\\";\\nimport \\\"../markets/CashGroup.sol\\\";\\nimport \\\"../AccountContextHandler.sol\\\";\\nimport \\\"../balances/BalanceHandler.sol\\\";\\nimport \\\"../portfolio/PortfolioHandler.sol\\\";\\nimport \\\"../nToken/nTokenHandler.sol\\\";\\nimport \\\"../nToken/nTokenCalculations.sol\\\";\\nimport \\\"../../math/SafeInt256.sol\\\";\\n\\nlibrary FreeCollateral {\\n    using SafeInt256 for int256;\\n    using Bitmap for bytes;\\n    using ExchangeRate for ETHRate;\\n    using AssetRate for AssetRateParameters;\\n    using AccountContextHandler for AccountContext;\\n    using nTokenHandler for nTokenPortfolio;\\n\\n    /// @dev This is only used within the library to clean up the stack\\n    struct FreeCollateralFactors {\\n        int256 netETHValue;\\n        bool updateContext;\\n        uint256 portfolioIndex;\\n        CashGroupParameters cashGroup;\\n        MarketParameters market;\\n        PortfolioAsset[] portfolio;\\n        AssetRateParameters assetRate;\\n        nTokenPortfolio nToken;\\n    }\\n\\n    /// @notice Checks if an asset is active in the portfolio\\n    function _isActiveInPortfolio(bytes2 currencyBytes) private pure returns (bool) {\\n        return currencyBytes & Constants.ACTIVE_IN_PORTFOLIO == Constants.ACTIVE_IN_PORTFOLIO;\\n    }\\n\\n    /// @notice Checks if currency balances are active in the account returns them if true\\n    /// @return cash balance, nTokenBalance\\n    function _getCurrencyBalances(address account, bytes2 currencyBytes)\\n        private\\n        view\\n        returns (int256, int256)\\n    {\\n        if (currencyBytes & Constants.ACTIVE_IN_BALANCES == Constants.ACTIVE_IN_BALANCES) {\\n            uint256 currencyId = uint16(currencyBytes & Constants.UNMASK_FLAGS);\\n            // prettier-ignore\\n            (\\n                int256 cashBalance,\\n                int256 nTokenBalance,\\n                /* lastClaimTime */,\\n                /* accountIncentiveDebt */\\n            ) = BalanceHandler.getBalanceStorage(account, currencyId);\\n\\n            return (cashBalance, nTokenBalance);\\n        }\\n\\n        return (0, 0);\\n    }\\n\\n    /// @notice Calculates the nToken asset value with a haircut set by governance\\n    /// @return the value of the account's nTokens after haircut, the nToken parameters\\n    function _getNTokenHaircutAssetPV(\\n        CashGroupParameters memory cashGroup,\\n        nTokenPortfolio memory nToken,\\n        int256 tokenBalance,\\n        uint256 blockTime\\n    ) internal view returns (int256, bytes6) {\\n        nToken.loadNTokenPortfolioNoCashGroup(cashGroup.currencyId);\\n        nToken.cashGroup = cashGroup;\\n\\n        int256 nTokenAssetPV = nTokenCalculations.getNTokenAssetPV(nToken, blockTime);\\n\\n        // (tokenBalance * nTokenValue * haircut) / totalSupply\\n        int256 nTokenHaircutAssetPV =\\n            tokenBalance\\n                .mul(nTokenAssetPV)\\n                .mul(uint8(nToken.parameters[Constants.PV_HAIRCUT_PERCENTAGE]))\\n                .div(Constants.PERCENTAGE_DECIMALS)\\n                .div(nToken.totalSupply);\\n\\n        // nToken.parameters is returned for use in liquidation\\n        return (nTokenHaircutAssetPV, nToken.parameters);\\n    }\\n\\n    /// @notice Calculates portfolio and/or nToken values while using the supplied cash groups and\\n    /// markets. The reason these are grouped together is because they both require storage reads of the same\\n    /// values.\\n    function _getPortfolioAndNTokenAssetValue(\\n        FreeCollateralFactors memory factors,\\n        int256 nTokenBalance,\\n        uint256 blockTime\\n    )\\n        private\\n        view\\n        returns (\\n            int256 netPortfolioValue,\\n            int256 nTokenHaircutAssetValue,\\n            bytes6 nTokenParameters\\n        )\\n    {\\n        // If the next asset matches the currency id then we need to calculate the cash group value\\n        if (\\n            factors.portfolioIndex < factors.portfolio.length &&\\n            factors.portfolio[factors.portfolioIndex].currencyId == factors.cashGroup.currencyId\\n        ) {\\n            // netPortfolioValue is in asset cash\\n            (netPortfolioValue, factors.portfolioIndex) = AssetHandler.getNetCashGroupValue(\\n                factors.portfolio,\\n                factors.cashGroup,\\n                factors.market,\\n                blockTime,\\n                factors.portfolioIndex\\n            );\\n        } else {\\n            netPortfolioValue = 0;\\n        }\\n\\n        if (nTokenBalance > 0) {\\n            (nTokenHaircutAssetValue, nTokenParameters) = _getNTokenHaircutAssetPV(\\n                factors.cashGroup,\\n                factors.nToken,\\n                nTokenBalance,\\n                blockTime\\n            );\\n        } else {\\n            nTokenHaircutAssetValue = 0;\\n            nTokenParameters = 0;\\n        }\\n    }\\n\\n    /// @notice Returns balance values for the bitmapped currency\\n    function _getBitmapBalanceValue(\\n        address account,\\n        uint256 blockTime,\\n        AccountContext memory accountContext,\\n        FreeCollateralFactors memory factors\\n    )\\n        private\\n        view\\n        returns (\\n            int256 cashBalance,\\n            int256 nTokenHaircutAssetValue,\\n            bytes6 nTokenParameters\\n        )\\n    {\\n        int256 nTokenBalance;\\n        // prettier-ignore\\n        (\\n            cashBalance,\\n            nTokenBalance, \\n            /* lastClaimTime */,\\n            /* accountIncentiveDebt */\\n        ) = BalanceHandler.getBalanceStorage(account, accountContext.bitmapCurrencyId);\\n\\n        if (nTokenBalance > 0) {\\n            (nTokenHaircutAssetValue, nTokenParameters) = _getNTokenHaircutAssetPV(\\n                factors.cashGroup,\\n                factors.nToken,\\n                nTokenBalance,\\n                blockTime\\n            );\\n        } else {\\n            nTokenHaircutAssetValue = 0;\\n        }\\n    }\\n\\n    /// @notice Returns portfolio value for the bitmapped currency\\n    function _getBitmapPortfolioValue(\\n        address account,\\n        uint256 blockTime,\\n        AccountContext memory accountContext,\\n        FreeCollateralFactors memory factors\\n    ) private view returns (int256) {\\n        (int256 netPortfolioValueUnderlying, bool bitmapHasDebt) =\\n            BitmapAssetsHandler.getifCashNetPresentValue(\\n                account,\\n                accountContext.bitmapCurrencyId,\\n                accountContext.nextSettleTime,\\n                blockTime,\\n                factors.cashGroup,\\n                true // risk adjusted\\n            );\\n\\n        // Turns off has debt flag if it has changed\\n        bool contextHasAssetDebt =\\n            accountContext.hasDebt & Constants.HAS_ASSET_DEBT == Constants.HAS_ASSET_DEBT;\\n        if (bitmapHasDebt && !contextHasAssetDebt) {\\n            // Turn on has debt\\n            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_ASSET_DEBT;\\n            factors.updateContext = true;\\n        } else if (!bitmapHasDebt && contextHasAssetDebt) {\\n            // Turn off has debt\\n            accountContext.hasDebt = accountContext.hasDebt & ~Constants.HAS_ASSET_DEBT;\\n            factors.updateContext = true;\\n        }\\n\\n        // Return asset cash value\\n        return factors.cashGroup.assetRate.convertFromUnderlying(netPortfolioValueUnderlying);\\n    }\\n\\n    function _updateNetETHValue(\\n        uint256 currencyId,\\n        int256 netLocalAssetValue,\\n        FreeCollateralFactors memory factors\\n    ) private view returns (ETHRate memory) {\\n        ETHRate memory ethRate = ExchangeRate.buildExchangeRate(currencyId);\\n        // Converts to underlying first, ETH exchange rates are in underlying\\n        factors.netETHValue = factors.netETHValue.add(\\n            ethRate.convertToETH(factors.assetRate.convertToUnderlying(netLocalAssetValue))\\n        );\\n\\n        return ethRate;\\n    }\\n\\n    /// @notice Stateful version of get free collateral, returns the total net ETH value and true or false if the account\\n    /// context needs to be updated.\\n    function getFreeCollateralStateful(\\n        address account,\\n        AccountContext memory accountContext,\\n        uint256 blockTime\\n    ) internal returns (int256, bool) {\\n        FreeCollateralFactors memory factors;\\n        bool hasCashDebt;\\n\\n        if (accountContext.isBitmapEnabled()) {\\n            factors.cashGroup = CashGroup.buildCashGroupStateful(accountContext.bitmapCurrencyId);\\n\\n            // prettier-ignore\\n            (\\n                int256 netCashBalance,\\n                int256 nTokenHaircutAssetValue,\\n                /* nTokenParameters */\\n            ) = _getBitmapBalanceValue(account, blockTime, accountContext, factors);\\n            if (netCashBalance < 0) hasCashDebt = true;\\n\\n            int256 portfolioAssetValue =\\n                _getBitmapPortfolioValue(account, blockTime, accountContext, factors);\\n            int256 netLocalAssetValue =\\n                netCashBalance.add(nTokenHaircutAssetValue).add(portfolioAssetValue);\\n\\n            factors.assetRate = factors.cashGroup.assetRate;\\n            _updateNetETHValue(accountContext.bitmapCurrencyId, netLocalAssetValue, factors);\\n        } else {\\n            factors.portfolio = PortfolioHandler.getSortedPortfolio(\\n                account,\\n                accountContext.assetArrayLength\\n            );\\n        }\\n\\n        bytes18 currencies = accountContext.activeCurrencies;\\n        while (currencies != 0) {\\n            bytes2 currencyBytes = bytes2(currencies);\\n            uint16 currencyId = uint16(currencyBytes & Constants.UNMASK_FLAGS);\\n            // Explicitly ensures that bitmap currency cannot be double counted\\n            require(currencyId != accountContext.bitmapCurrencyId);\\n\\n            (int256 netLocalAssetValue, int256 nTokenBalance) =\\n                _getCurrencyBalances(account, currencyBytes);\\n            if (netLocalAssetValue < 0) hasCashDebt = true;\\n\\n            if (_isActiveInPortfolio(currencyBytes) || nTokenBalance > 0) {\\n                factors.cashGroup = CashGroup.buildCashGroupStateful(currencyId);\\n\\n                // prettier-ignore\\n                (\\n                    int256 netPortfolioAssetValue,\\n                    int256 nTokenHaircutAssetValue,\\n                    /* nTokenParameters */\\n                ) = _getPortfolioAndNTokenAssetValue(factors, nTokenBalance, blockTime);\\n                netLocalAssetValue = netLocalAssetValue\\n                    .add(netPortfolioAssetValue)\\n                    .add(nTokenHaircutAssetValue);\\n                factors.assetRate = factors.cashGroup.assetRate;\\n            } else {\\n                // NOTE: we must set the proper assetRate when we updateNetETHValue\\n                factors.assetRate = AssetRate.buildAssetRateStateful(currencyId);\\n            }\\n\\n            _updateNetETHValue(currencyId, netLocalAssetValue, factors);\\n            currencies = currencies << 16;\\n        }\\n\\n        // Free collateral is the only method that examines all cash balances for an account at once. If there is no cash debt (i.e.\\n        // they have been repaid or settled via more debt) then this will turn off the flag. It's possible that this flag is out of\\n        // sync temporarily after a cash settlement and before the next free collateral check. The only downside for that is forcing\\n        // an account to do an extra free collateral check to turn off this setting.\\n        if (\\n            accountContext.hasDebt & Constants.HAS_CASH_DEBT == Constants.HAS_CASH_DEBT &&\\n            !hasCashDebt\\n        ) {\\n            accountContext.hasDebt = accountContext.hasDebt & ~Constants.HAS_CASH_DEBT;\\n            factors.updateContext = true;\\n        }\\n\\n        return (factors.netETHValue, factors.updateContext);\\n    }\\n\\n    /// @notice View version of getFreeCollateral, does not use the stateful version of build cash group and skips\\n    /// all the update context logic.\\n    function getFreeCollateralView(\\n        address account,\\n        AccountContext memory accountContext,\\n        uint256 blockTime\\n    ) internal view returns (int256, int256[] memory) {\\n        FreeCollateralFactors memory factors;\\n        uint256 netLocalIndex;\\n        int256[] memory netLocalAssetValues = new int256[](10);\\n\\n        if (accountContext.isBitmapEnabled()) {\\n            factors.cashGroup = CashGroup.buildCashGroupView(accountContext.bitmapCurrencyId);\\n\\n            // prettier-ignore\\n            (\\n                int256 netCashBalance,\\n                int256 nTokenHaircutAssetValue,\\n                /* nTokenParameters */\\n            ) = _getBitmapBalanceValue(account, blockTime, accountContext, factors);\\n            int256 portfolioAssetValue =\\n                _getBitmapPortfolioValue(account, blockTime, accountContext, factors);\\n\\n            netLocalAssetValues[netLocalIndex] = netCashBalance\\n                .add(nTokenHaircutAssetValue)\\n                .add(portfolioAssetValue);\\n            factors.assetRate = factors.cashGroup.assetRate;\\n            _updateNetETHValue(\\n                accountContext.bitmapCurrencyId,\\n                netLocalAssetValues[netLocalIndex],\\n                factors\\n            );\\n\\n            netLocalIndex++;\\n        } else {\\n            factors.portfolio = PortfolioHandler.getSortedPortfolio(\\n                account,\\n                accountContext.assetArrayLength\\n            );\\n        }\\n\\n        bytes18 currencies = accountContext.activeCurrencies;\\n        while (currencies != 0) {\\n            bytes2 currencyBytes = bytes2(currencies);\\n            uint16 currencyId = uint16(currencyBytes & Constants.UNMASK_FLAGS);\\n            // Explicitly ensures that bitmap currency cannot be double counted\\n            require(currencyId != accountContext.bitmapCurrencyId);\\n            int256 nTokenBalance;\\n            (netLocalAssetValues[netLocalIndex], nTokenBalance) = _getCurrencyBalances(\\n                account,\\n                currencyBytes\\n            );\\n\\n            if (_isActiveInPortfolio(currencyBytes) || nTokenBalance > 0) {\\n                factors.cashGroup = CashGroup.buildCashGroupView(currencyId);\\n                // prettier-ignore\\n                (\\n                    int256 netPortfolioValue,\\n                    int256 nTokenHaircutAssetValue,\\n                    /* nTokenParameters */\\n                ) = _getPortfolioAndNTokenAssetValue(factors, nTokenBalance, blockTime);\\n\\n                netLocalAssetValues[netLocalIndex] = netLocalAssetValues[netLocalIndex]\\n                    .add(netPortfolioValue)\\n                    .add(nTokenHaircutAssetValue);\\n                factors.assetRate = factors.cashGroup.assetRate;\\n            } else {\\n                factors.assetRate = AssetRate.buildAssetRateView(currencyId);\\n            }\\n\\n            _updateNetETHValue(currencyId, netLocalAssetValues[netLocalIndex], factors);\\n            netLocalIndex++;\\n            currencies = currencies << 16;\\n        }\\n\\n        return (factors.netETHValue, netLocalAssetValues);\\n    }\\n\\n    /// @notice Calculates the net value of a currency within a portfolio, this is a bit\\n    /// convoluted to fit into the stack frame\\n    function _calculateLiquidationAssetValue(\\n        FreeCollateralFactors memory factors,\\n        LiquidationFactors memory liquidationFactors,\\n        bytes2 currencyBytes,\\n        bool setLiquidationFactors,\\n        uint256 blockTime\\n    ) private returns (int256) {\\n        uint16 currencyId = uint16(currencyBytes & Constants.UNMASK_FLAGS);\\n        (int256 netLocalAssetValue, int256 nTokenBalance) =\\n            _getCurrencyBalances(liquidationFactors.account, currencyBytes);\\n\\n        if (_isActiveInPortfolio(currencyBytes) || nTokenBalance > 0) {\\n            factors.cashGroup = CashGroup.buildCashGroupStateful(currencyId);\\n            (int256 netPortfolioValue, int256 nTokenHaircutAssetValue, bytes6 nTokenParameters) =\\n                _getPortfolioAndNTokenAssetValue(factors, nTokenBalance, blockTime);\\n\\n            netLocalAssetValue = netLocalAssetValue\\n                .add(netPortfolioValue)\\n                .add(nTokenHaircutAssetValue);\\n            factors.assetRate = factors.cashGroup.assetRate;\\n\\n            // If collateralCurrencyId is set to zero then this is a local currency liquidation\\n            if (setLiquidationFactors) {\\n                liquidationFactors.collateralCashGroup = factors.cashGroup;\\n                liquidationFactors.nTokenParameters = nTokenParameters;\\n                liquidationFactors.nTokenHaircutAssetValue = nTokenHaircutAssetValue;\\n            }\\n        } else {\\n            factors.assetRate = AssetRate.buildAssetRateStateful(currencyId);\\n        }\\n\\n        return netLocalAssetValue;\\n    }\\n\\n    /// @notice A version of getFreeCollateral used during liquidation to save off necessary additional information.\\n    function getLiquidationFactors(\\n        address account,\\n        AccountContext memory accountContext,\\n        uint256 blockTime,\\n        uint256 localCurrencyId,\\n        uint256 collateralCurrencyId\\n    ) internal returns (LiquidationFactors memory, PortfolioAsset[] memory) {\\n        FreeCollateralFactors memory factors;\\n        LiquidationFactors memory liquidationFactors;\\n        // This is only set to reduce the stack size\\n        liquidationFactors.account = account;\\n\\n        if (accountContext.isBitmapEnabled()) {\\n            factors.cashGroup = CashGroup.buildCashGroupStateful(accountContext.bitmapCurrencyId);\\n            (int256 netCashBalance, int256 nTokenHaircutAssetValue, bytes6 nTokenParameters) =\\n                _getBitmapBalanceValue(account, blockTime, accountContext, factors);\\n            int256 portfolioBalance =\\n                _getBitmapPortfolioValue(account, blockTime, accountContext, factors);\\n\\n            int256 netLocalAssetValue =\\n                netCashBalance.add(nTokenHaircutAssetValue).add(portfolioBalance);\\n            factors.assetRate = factors.cashGroup.assetRate;\\n            ETHRate memory ethRate =\\n                _updateNetETHValue(accountContext.bitmapCurrencyId, netLocalAssetValue, factors);\\n\\n            // If the bitmap currency id can only ever be the local currency where debt is held.\\n            // During enable bitmap we check that the account has no assets in their portfolio and\\n            // no cash debts.\\n            if (accountContext.bitmapCurrencyId == localCurrencyId) {\\n                liquidationFactors.localAssetAvailable = netLocalAssetValue;\\n                liquidationFactors.localETHRate = ethRate;\\n                liquidationFactors.localAssetRate = factors.assetRate;\\n\\n                // This will be the case during local currency or local fCash liquidation\\n                if (collateralCurrencyId == 0) {\\n                    // If this is local fCash liquidation, the cash group information is required\\n                    // to calculate fCash haircuts and buffers.\\n                    liquidationFactors.collateralCashGroup = factors.cashGroup;\\n                    liquidationFactors.nTokenHaircutAssetValue = nTokenHaircutAssetValue;\\n                    liquidationFactors.nTokenParameters = nTokenParameters;\\n                }\\n            }\\n        } else {\\n            factors.portfolio = PortfolioHandler.getSortedPortfolio(\\n                account,\\n                accountContext.assetArrayLength\\n            );\\n        }\\n\\n        bytes18 currencies = accountContext.activeCurrencies;\\n        while (currencies != 0) {\\n            bytes2 currencyBytes = bytes2(currencies);\\n\\n            // This next bit of code here is annoyingly structured to get around stack size issues\\n            bool setLiquidationFactors;\\n            {\\n                uint256 tempId = uint256(uint16(currencyBytes & Constants.UNMASK_FLAGS));\\n                // Explicitly ensures that bitmap currency cannot be double counted\\n                require(tempId != accountContext.bitmapCurrencyId);\\n                setLiquidationFactors =\\n                    (tempId == localCurrencyId && collateralCurrencyId == 0) ||\\n                    tempId == collateralCurrencyId;\\n            }\\n            int256 netLocalAssetValue =\\n                _calculateLiquidationAssetValue(\\n                    factors,\\n                    liquidationFactors,\\n                    currencyBytes,\\n                    setLiquidationFactors,\\n                    blockTime\\n                );\\n\\n            uint256 currencyId = uint256(uint16(currencyBytes & Constants.UNMASK_FLAGS));\\n            ETHRate memory ethRate = _updateNetETHValue(currencyId, netLocalAssetValue, factors);\\n\\n            if (currencyId == collateralCurrencyId) {\\n                // Ensure that this is set even if the cash group is not loaded, it will not be\\n                // loaded if the account only has a cash balance and no nTokens or assets\\n                liquidationFactors.collateralCashGroup.assetRate = factors.assetRate;\\n                liquidationFactors.collateralAssetAvailable = netLocalAssetValue;\\n                liquidationFactors.collateralETHRate = ethRate;\\n            } else if (currencyId == localCurrencyId) {\\n                // This branch will not be entered if bitmap is enabled\\n                liquidationFactors.localAssetAvailable = netLocalAssetValue;\\n                liquidationFactors.localETHRate = ethRate;\\n                liquidationFactors.localAssetRate = factors.assetRate;\\n                // If this is local fCash liquidation, the cash group information is required\\n                // to calculate fCash haircuts and buffers and it will have been set in\\n                // _calculateLiquidationAssetValue above because the account must have fCash assets,\\n                // there is no need to set cash group in this branch.\\n            }\\n\\n            currencies = currencies << 16;\\n        }\\n\\n        liquidationFactors.netETHValue = factors.netETHValue;\\n        require(liquidationFactors.netETHValue < 0, \\\"Sufficient collateral\\\");\\n\\n        // Refetch the portfolio if it exists, AssetHandler.getNetCashValue updates values in memory to do fCash\\n        // netting which will make further calculations incorrect.\\n        if (accountContext.assetArrayLength > 0) {\\n            factors.portfolio = PortfolioHandler.getSortedPortfolio(\\n                account,\\n                accountContext.assetArrayLength\\n            );\\n        }\\n\\n        return (liquidationFactors, factors.portfolio);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/math/ABDKMath64x64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math 64.64 Smart Contract Library.  Copyright \u00a9 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.5.0 || ^0.6.0 || ^0.7.0;\\n\\n/**\\n * Smart contract library of mathematical functions operating with signed\\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\\n * basically a simple fraction whose numerator is signed 128-bit integer and\\n * denominator is 2^64.  As long as denominator is always the same, there is no\\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\\n * represented by int128 type holding only the numerator.\\n */\\nlibrary ABDKMath64x64 {\\n  /*\\n   * Minimum value signed 64.64-bit fixed point number may have. \\n   */\\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\\n\\n  /*\\n   * Maximum value signed 64.64-bit fixed point number may have. \\n   */\\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n  /**\\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function fromInt (int256 x) internal pure returns (int128) {\\n    require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\\n    return int128 (x << 64);\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\\n   * rounding down.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64-bit integer number\\n   */\\n  function toInt (int128 x) internal pure returns (int64) {\\n    return int64 (x >> 64);\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function fromUInt (uint256 x) internal pure returns (int128) {\\n    require (x <= 0x7FFFFFFFFFFFFFFF);\\n    return int128 (x << 64);\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\\n   * number rounding down.  Revert on underflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return unsigned 64-bit integer number\\n   */\\n  function toUInt (int128 x) internal pure returns (uint64) {\\n    require (x >= 0);\\n    return uint64 (x >> 64);\\n  }\\n\\n  /**\\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\\n   * number rounding down.  Revert on overflow.\\n   *\\n   * @param x signed 128.128-bin fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function from128x128 (int256 x) internal pure returns (int128) {\\n    int256 result = x >> 64;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\\n   * number.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 128.128 fixed point number\\n   */\\n  function to128x128 (int128 x) internal pure returns (int256) {\\n    return int256 (x) << 64;\\n  }\\n\\n  /**\\n   * Calculate x + y.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function add (int128 x, int128 y) internal pure returns (int128) {\\n    int256 result = int256(x) + y;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x - y.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function sub (int128 x, int128 y) internal pure returns (int128) {\\n    int256 result = int256(x) - y;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x * y rounding down.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function mul (int128 x, int128 y) internal pure returns (int128) {\\n    int256 result = int256(x) * y >> 64;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\\n   * number and y is signed 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64 fixed point number\\n   * @param y signed 256-bit integer number\\n   * @return signed 256-bit integer number\\n   */\\n  function muli (int128 x, int256 y) internal pure returns (int256) {\\n    if (x == MIN_64x64) {\\n      require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\\n        y <= 0x1000000000000000000000000000000000000000000000000);\\n      return -y << 63;\\n    } else {\\n      bool negativeResult = false;\\n      if (x < 0) {\\n        x = -x;\\n        negativeResult = true;\\n      }\\n      if (y < 0) {\\n        y = -y; // We rely on overflow behavior here\\n        negativeResult = !negativeResult;\\n      }\\n      uint256 absoluteResult = mulu (x, uint256 (y));\\n      if (negativeResult) {\\n        require (absoluteResult <=\\n          0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (absoluteResult); // We rely on overflow behavior here\\n      } else {\\n        require (absoluteResult <=\\n          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (absoluteResult);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64 fixed point number\\n   * @param y unsigned 256-bit integer number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\\n    if (y == 0) return 0;\\n\\n    require (x >= 0);\\n\\n    uint256 lo = (uint256 (x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\\n    uint256 hi = uint256 (x) * (y >> 128);\\n\\n    require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n    hi <<= 64;\\n\\n    require (hi <=\\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\\n    return hi + lo;\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\\n   * zero.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function div (int128 x, int128 y) internal pure returns (int128) {\\n    require (y != 0);\\n    int256 result = (int256 (x) << 64) / y;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @param y signed 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function divi (int256 x, int256 y) internal pure returns (int128) {\\n    require (y != 0);\\n\\n    bool negativeResult = false;\\n    if (x < 0) {\\n      x = -x; // We rely on overflow behavior here\\n      negativeResult = true;\\n    }\\n    if (y < 0) {\\n      y = -y; // We rely on overflow behavior here\\n      negativeResult = !negativeResult;\\n    }\\n    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\\n    if (negativeResult) {\\n      require (absoluteResult <= 0x80000000000000000000000000000000);\\n      return -int128 (absoluteResult); // We rely on overflow behavior here\\n    } else {\\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n      return int128 (absoluteResult); // We rely on overflow behavior here\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @param y unsigned 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\\n    require (y != 0);\\n    uint128 result = divuu (x, y);\\n    require (result <= uint128 (MAX_64x64));\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate -x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function neg (int128 x) internal pure returns (int128) {\\n    require (x != MIN_64x64);\\n    return -x;\\n  }\\n\\n  /**\\n   * Calculate |x|.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function abs (int128 x) internal pure returns (int128) {\\n    require (x != MIN_64x64);\\n    return x < 0 ? -x : x;\\n  }\\n\\n  /**\\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\\n   * zero.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function inv (int128 x) internal pure returns (int128) {\\n    require (x != 0);\\n    int256 result = int256 (0x100000000000000000000000000000000) / x;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function avg (int128 x, int128 y) internal pure returns (int128) {\\n    return int128 ((int256 (x) + int256 (y)) >> 1);\\n  }\\n\\n  /**\\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\\n   * Revert on overflow or in case x * y is negative.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\\n    int256 m = int256 (x) * int256 (y);\\n    require (m >= 0);\\n    require (m <\\n        0x4000000000000000000000000000000000000000000000000000000000000000);\\n    return int128 (sqrtu (uint256 (m)));\\n  }\\n\\n  /**\\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y uint256 value\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\\n    bool negative = x < 0 && y & 1 == 1;\\n\\n    uint256 absX = uint128 (x < 0 ? -x : x);\\n    uint256 absResult;\\n    absResult = 0x100000000000000000000000000000000;\\n\\n    if (absX <= 0x10000000000000000) {\\n      absX <<= 63;\\n      while (y != 0) {\\n        if (y & 0x1 != 0) {\\n          absResult = absResult * absX >> 127;\\n        }\\n        absX = absX * absX >> 127;\\n\\n        if (y & 0x2 != 0) {\\n          absResult = absResult * absX >> 127;\\n        }\\n        absX = absX * absX >> 127;\\n\\n        if (y & 0x4 != 0) {\\n          absResult = absResult * absX >> 127;\\n        }\\n        absX = absX * absX >> 127;\\n\\n        if (y & 0x8 != 0) {\\n          absResult = absResult * absX >> 127;\\n        }\\n        absX = absX * absX >> 127;\\n\\n        y >>= 4;\\n      }\\n\\n      absResult >>= 64;\\n    } else {\\n      uint256 absXShift = 63;\\n      if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\\n      if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\\n      if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\\n      if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\\n      if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\\n      if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\\n\\n      uint256 resultShift = 0;\\n      while (y != 0) {\\n        require (absXShift < 64);\\n\\n        if (y & 0x1 != 0) {\\n          absResult = absResult * absX >> 127;\\n          resultShift += absXShift;\\n          if (absResult > 0x100000000000000000000000000000000) {\\n            absResult >>= 1;\\n            resultShift += 1;\\n          }\\n        }\\n        absX = absX * absX >> 127;\\n        absXShift <<= 1;\\n        if (absX >= 0x100000000000000000000000000000000) {\\n            absX >>= 1;\\n            absXShift += 1;\\n        }\\n\\n        y >>= 1;\\n      }\\n\\n      require (resultShift < 64);\\n      absResult >>= 64 - resultShift;\\n    }\\n    int256 result = negative ? -int256 (absResult) : int256 (absResult);\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function sqrt (int128 x) internal pure returns (int128) {\\n    require (x >= 0);\\n    return int128 (sqrtu (uint256 (x) << 64));\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Revert if x <= 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function log_2 (int128 x) internal pure returns (int128) {\\n    require (x > 0);\\n\\n    int256 msb = 0;\\n    int256 xc = x;\\n    if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\\n    if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n    if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n    if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n    if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n    if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n    if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n    int256 result = msb - 64 << 64;\\n    uint256 ux = uint256 (x) << uint256 (127 - msb);\\n    for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\\n      ux *= ux;\\n      uint256 b = ux >> 255;\\n      ux >>= 127 + b;\\n      result += bit * int256 (b);\\n    }\\n\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Revert if x <= 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function ln (int128 x) internal pure returns (int128) {\\n    require (x > 0);\\n\\n    return int128 (\\n        uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128);\\n  }\\n\\n  /**\\n   * Calculate binary exponent of x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function exp_2 (int128 x) internal pure returns (int128) {\\n    require (x < 0x400000000000000000); // Overflow\\n\\n    if (x < -0x400000000000000000) return 0; // Underflow\\n\\n    uint256 result = 0x80000000000000000000000000000000;\\n\\n    if (x & 0x8000000000000000 > 0)\\n      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\n    if (x & 0x4000000000000000 > 0)\\n      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\n    if (x & 0x2000000000000000 > 0)\\n      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\n    if (x & 0x1000000000000000 > 0)\\n      result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\n    if (x & 0x800000000000000 > 0)\\n      result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\n    if (x & 0x400000000000000 > 0)\\n      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\n    if (x & 0x200000000000000 > 0)\\n      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\n    if (x & 0x100000000000000 > 0)\\n      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\n    if (x & 0x80000000000000 > 0)\\n      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\n    if (x & 0x40000000000000 > 0)\\n      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\n    if (x & 0x20000000000000 > 0)\\n      result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\n    if (x & 0x10000000000000 > 0)\\n      result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\n    if (x & 0x8000000000000 > 0)\\n      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\n    if (x & 0x4000000000000 > 0)\\n      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\n    if (x & 0x2000000000000 > 0)\\n      result = result * 0x1000162E525EE054754457D5995292026 >> 128;\\n    if (x & 0x1000000000000 > 0)\\n      result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\n    if (x & 0x800000000000 > 0)\\n      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\n    if (x & 0x400000000000 > 0)\\n      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\n    if (x & 0x200000000000 > 0)\\n      result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\n    if (x & 0x100000000000 > 0)\\n      result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\n    if (x & 0x80000000000 > 0)\\n      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\n    if (x & 0x40000000000 > 0)\\n      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\n    if (x & 0x20000000000 > 0)\\n      result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\n    if (x & 0x10000000000 > 0)\\n      result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\n    if (x & 0x8000000000 > 0)\\n      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\n    if (x & 0x4000000000 > 0)\\n      result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\n    if (x & 0x2000000000 > 0)\\n      result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\n    if (x & 0x1000000000 > 0)\\n      result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\n    if (x & 0x800000000 > 0)\\n      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\n    if (x & 0x400000000 > 0)\\n      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\n    if (x & 0x200000000 > 0)\\n      result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\n    if (x & 0x100000000 > 0)\\n      result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\n    if (x & 0x80000000 > 0)\\n      result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\n    if (x & 0x40000000 > 0)\\n      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\n    if (x & 0x20000000 > 0)\\n      result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\n    if (x & 0x10000000 > 0)\\n      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\n    if (x & 0x8000000 > 0)\\n      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\n    if (x & 0x4000000 > 0)\\n      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\n    if (x & 0x2000000 > 0)\\n      result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\n    if (x & 0x1000000 > 0)\\n      result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\n    if (x & 0x800000 > 0)\\n      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\n    if (x & 0x400000 > 0)\\n      result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\\n    if (x & 0x200000 > 0)\\n      result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\\n    if (x & 0x100000 > 0)\\n      result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\\n    if (x & 0x80000 > 0)\\n      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\n    if (x & 0x40000 > 0)\\n      result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\n    if (x & 0x20000 > 0)\\n      result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\n    if (x & 0x10000 > 0)\\n      result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\n    if (x & 0x8000 > 0)\\n      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\n    if (x & 0x4000 > 0)\\n      result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\n    if (x & 0x2000 > 0)\\n      result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\\n    if (x & 0x1000 > 0)\\n      result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\n    if (x & 0x800 > 0)\\n      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\n    if (x & 0x400 > 0)\\n      result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\\n    if (x & 0x200 > 0)\\n      result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\n    if (x & 0x100 > 0)\\n      result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\\n    if (x & 0x80 > 0)\\n      result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\n    if (x & 0x40 > 0)\\n      result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\n    if (x & 0x20 > 0)\\n      result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\\n    if (x & 0x10 > 0)\\n      result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\n    if (x & 0x8 > 0)\\n      result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\n    if (x & 0x4 > 0)\\n      result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\n    if (x & 0x2 > 0)\\n      result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\\n    if (x & 0x1 > 0)\\n      result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\\n\\n    result >>= uint256 (63 - (x >> 64));\\n    require (result <= uint256 (MAX_64x64));\\n\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate natural exponent of x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function exp (int128 x) internal pure returns (int128) {\\n    require (x < 0x400000000000000000); // Overflow\\n\\n    if (x < -0x400000000000000000) return 0; // Underflow\\n\\n    return exp_2 (\\n        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @param y unsigned 256-bit integer number\\n   * @return unsigned 64.64-bit fixed point number\\n   */\\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\\n    require (y != 0);\\n\\n    uint256 result;\\n\\n    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n      result = (x << 64) / y;\\n    else {\\n      uint256 msb = 192;\\n      uint256 xc = x >> 192;\\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n      result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n      uint256 hi = result * (y >> 128);\\n      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n      uint256 xh = x >> 192;\\n      uint256 xl = x << 64;\\n\\n      if (xl < lo) xh -= 1;\\n      xl -= lo; // We rely on overflow behavior here\\n      lo = hi << 128;\\n      if (xl < lo) xh -= 1;\\n      xl -= lo; // We rely on overflow behavior here\\n\\n      assert (xh == hi >> 128);\\n\\n      result += xl / y;\\n    }\\n\\n    require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n    return uint128 (result);\\n  }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\\n   * number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return unsigned 128-bit integer number\\n   */\\n  function sqrtu (uint256 x) private pure returns (uint128) {\\n    if (x == 0) return 0;\\n    else {\\n      uint256 xx = x;\\n      uint256 r = 1;\\n      if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\\n      if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\\n      if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\\n      if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\\n      if (xx >= 0x100) { xx >>= 8; r <<= 4; }\\n      if (xx >= 0x10) { xx >>= 4; r <<= 2; }\\n      if (xx >= 0x8) { r <<= 1; }\\n      r = (r + x / r) >> 1;\\n      r = (r + x / r) >> 1;\\n      r = (r + x / r) >> 1;\\n      r = (r + x / r) >> 1;\\n      r = (r + x / r) >> 1;\\n      r = (r + x / r) >> 1;\\n      r = (r + x / r) >> 1; // Seven iterations should be enough\\n      uint256 r1 = x / r;\\n      return uint128 (r < r1 ? r : r1);\\n    }\\n  }\\n}\"\r\n    },\r\n    \"contracts/math/Bitmap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../global/Types.sol\\\";\\nimport \\\"../global/Constants.sol\\\";\\n\\n/// @notice Helper methods for bitmaps, they are big-endian and 1-indexed.\\nlibrary Bitmap {\\n\\n    /// @notice Set a bit on or off in a bitmap, index is 1-indexed\\n    function setBit(\\n        bytes32 bitmap,\\n        uint256 index,\\n        bool setOn\\n    ) internal pure returns (bytes32) {\\n        require(index >= 1 && index <= 256); // dev: set bit index bounds\\n\\n        if (setOn) {\\n            return bitmap | (Constants.MSB >> (index - 1));\\n        } else {\\n            return bitmap & ~(Constants.MSB >> (index - 1));\\n        }\\n    }\\n\\n    /// @notice Check if a bit is set\\n    function isBitSet(bytes32 bitmap, uint256 index) internal pure returns (bool) {\\n        require(index >= 1 && index <= 256); // dev: set bit index bounds\\n        return ((bitmap << (index - 1)) & Constants.MSB) == Constants.MSB;\\n    }\\n\\n    /// @notice Count the total bits set\\n    function totalBitsSet(bytes32 bitmap) internal pure returns (uint256) {\\n        uint256 x = uint256(bitmap);\\n        x = (x & 0x5555555555555555555555555555555555555555555555555555555555555555) + (x >> 1 & 0x5555555555555555555555555555555555555555555555555555555555555555);\\n        x = (x & 0x3333333333333333333333333333333333333333333333333333333333333333) + (x >> 2 & 0x3333333333333333333333333333333333333333333333333333333333333333);\\n        x = (x & 0x0707070707070707070707070707070707070707070707070707070707070707) + (x >> 4);\\n        x = (x & 0x000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F) + (x >> 8 & 0x000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F);\\n        x = x + (x >> 16);\\n        x = x + (x >> 32);\\n        x = x  + (x >> 64);\\n        return (x & 0xFF) + (x >> 128 & 0xFF);\\n    }\\n\\n    // Does a binary search over x to get the position of the most significant bit\\n    function getMSB(uint256 x) internal pure returns (uint256 msb) {\\n        // If x == 0 then there is no MSB and this method will return zero. That would\\n        // be the same as the return value when x == 1 (MSB is zero indexed), so instead\\n        // we have this require here to ensure that the values don't get mixed up.\\n        require(x != 0); // dev: get msb zero value\\n        if (x >= 0x100000000000000000000000000000000) {\\n            x >>= 128;\\n            msb += 128;\\n        }\\n        if (x >= 0x10000000000000000) {\\n            x >>= 64;\\n            msb += 64;\\n        }\\n        if (x >= 0x100000000) {\\n            x >>= 32;\\n            msb += 32;\\n        }\\n        if (x >= 0x10000) {\\n            x >>= 16;\\n            msb += 16;\\n        }\\n        if (x >= 0x100) {\\n            x >>= 8;\\n            msb += 8;\\n        }\\n        if (x >= 0x10) {\\n            x >>= 4;\\n            msb += 4;\\n        }\\n        if (x >= 0x4) {\\n            x >>= 2;\\n            msb += 2;\\n        }\\n        if (x >= 0x2) msb += 1; // No need to shift xc anymore\\n    }\\n\\n    /// @dev getMSB returns a zero indexed bit number where zero is the first bit counting\\n    /// from the right (little endian). Asset Bitmaps are counted from the left (big endian)\\n    /// and one indexed.\\n    function getNextBitNum(bytes32 bitmap) internal pure returns (uint256 bitNum) {\\n        // Short circuit the search if bitmap is all zeros\\n        if (bitmap == 0x00) return 0;\\n\\n        return 255 - getMSB(uint256(bitmap)) + 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/math/FloatingPoint56.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\n\\nimport \\\"./Bitmap.sol\\\";\\n\\n/**\\n * Packs an uint value into a \\\"floating point\\\" storage slot. Used for storing\\n * lastClaimIntegralSupply values in balance storage. For these values, we don't need\\n * to maintain exact precision but we don't want to be limited by storage size overflows.\\n *\\n * A floating point value is defined by the 48 most significant bits and an 8 bit number\\n * of bit shifts required to restore its precision. The unpacked value will always be less\\n * than the packed value with a maximum absolute loss of precision of (2 ** bitShift) - 1.\\n */\\nlibrary FloatingPoint56 {\\n\\n    function packTo56Bits(uint256 value) internal pure returns (uint56) {\\n        uint256 bitShift;\\n        // If the value is over the uint48 max value then we will shift it down\\n        // given the index of the most significant bit. We store this bit shift \\n        // in the least significant byte of the 56 bit slot available.\\n        if (value > type(uint48).max) bitShift = (Bitmap.getMSB(value) - 47);\\n\\n        uint256 shiftedValue = value >> bitShift;\\n        return uint56((shiftedValue << 8) | bitShift);\\n    }\\n\\n    function unpackFrom56Bits(uint256 value) internal pure returns (uint256) {\\n        // The least significant 8 bits will be the amount to bit shift\\n        uint256 bitShift = uint256(uint8(value));\\n        return ((value >> 8) << bitShift);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/math/SafeInt256.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity =0.7.6;\\n\\nimport \\\"../global/Constants.sol\\\";\\n\\nlibrary SafeInt256 {\\n    int256 private constant _INT256_MIN = type(int256).min;\\n\\n    /// @dev Returns the multiplication of two signed integers, reverting on\\n    /// overflow.\\n\\n    /// Counterpart to Solidity's `*` operator.\\n\\n    /// Requirements:\\n\\n    /// - Multiplication cannot overflow.\\n\\n    function mul(int256 a, int256 b) internal pure returns (int256 c) {\\n        c = a * b;\\n        if (a == -1) require (b == 0 || c / b == a);\\n        else require (a == 0 || c / a == b);\\n    }\\n\\n    /// @dev Returns the integer division of two signed integers. Reverts on\\n    /// division by zero. The result is rounded towards zero.\\n\\n    /// Counterpart to Solidity's `/` operator. Note: this function uses a\\n    /// `revert` opcode (which leaves remaining gas untouched) while Solidity\\n    /// uses an invalid opcode to revert (consuming all remaining gas).\\n\\n    /// Requirements:\\n\\n    /// - The divisor cannot be zero.\\n\\n    function div(int256 a, int256 b) internal pure returns (int256 c) {\\n        require(!(b == -1 && a == _INT256_MIN)); // dev: int256 div overflow\\n        // NOTE: solidity will automatically revert on divide by zero\\n        c = a / b;\\n    }\\n\\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\\n        //  taken from uniswap v3\\n        require((z = x - y) <= x == (y >= 0));\\n    }\\n\\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\\n        require((z = x + y) >= x == (y >= 0));\\n    }\\n\\n    function neg(int256 x) internal pure returns (int256 y) {\\n        return mul(-1, x);\\n    }\\n\\n    function abs(int256 x) internal pure returns (int256) {\\n        if (x < 0) return neg(x);\\n        else return x;\\n    }\\n\\n    function subNoNeg(int256 x, int256 y) internal pure returns (int256 z) {\\n        z = sub(x, y);\\n        require(z >= 0); // dev: int256 sub to negative\\n\\n        return z;\\n    }\\n\\n    /// @dev Calculates x * RATE_PRECISION / y while checking overflows\\n    function divInRatePrecision(int256 x, int256 y) internal pure returns (int256) {\\n        return div(mul(x, Constants.RATE_PRECISION), y);\\n    }\\n\\n    /// @dev Calculates x * y / RATE_PRECISION while checking overflows\\n    function mulInRatePrecision(int256 x, int256 y) internal pure returns (int256) {\\n        return div(mul(x, y), Constants.RATE_PRECISION);\\n    }\\n\\n    function toUint(int256 x) internal pure returns (uint256) {\\n        require(x >= 0);\\n        return uint256(x);\\n    }\\n\\n    function toInt(uint256 x) internal pure returns (int256) {\\n        require (x <= uint256(type(int256).max)); // dev: toInt overflow\\n        return int256(x);\\n    }\\n\\n    function toInt80(int256 x) internal pure returns (int80) {\\n        require (int256(type(int80).min) <= x && x <= int256(type(int80).max)); // dev: toInt overflow\\n        return int80(x);\\n    }\\n\\n    function max(int256 x, int256 y) internal pure returns (int256) {\\n        return x > y ? x : y;\\n    }\\n\\n    function min(int256 x, int256 y) internal pure returns (int256) {\\n        return x < y ? x : y;\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/aave/IAToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >=0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IAToken {\\n    /**\\n    * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\\n    * updated stored balance divided by the reserve's liquidity index at the moment of the update\\n    * @param user The user whose balance is calculated\\n    * @return The scaled balance of the user\\n    **/\\n    function scaledBalanceOf(address user) external view returns (uint256);\\n\\n    function UNDERLYING_ASSET_ADDRESS() external view returns (address);\\n\\n    function symbol() external view returns (string memory);\\n}\\n\\ninterface IScaledBalanceToken {\\n    /**\\n    * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\\n    * updated stored balance divided by the reserve's liquidity index at the moment of the update\\n    * @param user The user whose balance is calculated\\n    * @return The scaled balance of the user\\n    **/\\n    function scaledBalanceOf(address user) external view returns (uint256);\\n\\n    /**\\n    * @dev Returns the scaled balance of the user and the scaled total supply.\\n    * @param user The address of the user\\n    * @return The scaled balance of the user\\n    * @return The scaled balance and the scaled total supply\\n    **/\\n    function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\\n\\n    /**\\n    * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\\n    * @return The scaled total supply\\n    **/\\n    function scaledTotalSupply() external view returns (uint256);\\n}\\n\\ninterface IATokenFull is IScaledBalanceToken, IERC20 { \\n    function decimals() external view returns (uint8);\\n}\"\r\n    },\r\n    \"interfaces/aave/ILendingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >=0.7.6;\\npragma abicoder v2;\\n\\nstruct LendingPoolStorage {\\n  ILendingPool lendingPool;\\n}\\n\\ninterface ILendingPool {\\n\\n  /**\\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\\n   * @param asset The address of the underlying asset to deposit\\n   * @param amount The amount to be deposited\\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n   *   is a different wallet\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   **/\\n  function deposit(\\n    address asset,\\n    uint256 amount,\\n    address onBehalfOf,\\n    uint16 referralCode\\n  ) external;\\n\\n  /**\\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\n   * @param asset The address of the underlying asset to withdraw\\n   * @param amount The underlying amount to be withdrawn\\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\n   * @param to Address that will receive the underlying, same as msg.sender if the user\\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n   *   different wallet\\n   * @return The final amount withdrawn\\n   **/\\n  function withdraw(\\n    address asset,\\n    uint256 amount,\\n    address to\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Returns the normalized income normalized income of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The reserve's normalized income\\n   */\\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\\n\\n    /**\\n   * @dev Returns the state and configuration of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The state of the reserve\\n   **/\\n  function getReserveData(address asset) external view returns (ReserveData memory);\\n\\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\\n  struct ReserveData {\\n    //stores the reserve configuration\\n    ReserveConfigurationMap configuration;\\n    //the liquidity index. Expressed in ray\\n    uint128 liquidityIndex;\\n    //variable borrow index. Expressed in ray\\n    uint128 variableBorrowIndex;\\n    //the current supply rate. Expressed in ray\\n    uint128 currentLiquidityRate;\\n    //the current variable borrow rate. Expressed in ray\\n    uint128 currentVariableBorrowRate;\\n    //the current stable borrow rate. Expressed in ray\\n    uint128 currentStableBorrowRate;\\n    uint40 lastUpdateTimestamp;\\n    //tokens addresses\\n    address aTokenAddress;\\n    address stableDebtTokenAddress;\\n    address variableDebtTokenAddress;\\n    //address of the interest rate strategy\\n    address interestRateStrategyAddress;\\n    //the id of the reserve. Represents the position in the list of the active reserves\\n    uint8 id;\\n  }\\n\\n  struct ReserveConfigurationMap {\\n    //bit 0-15: LTV\\n    //bit 16-31: Liq. threshold\\n    //bit 32-47: Liq. bonus\\n    //bit 48-55: Decimals\\n    //bit 56: Reserve is active\\n    //bit 57: reserve is frozen\\n    //bit 58: borrowing is enabled\\n    //bit 59: stable rate borrowing enabled\\n    //bit 60-63: reserved\\n    //bit 64-79: reserve factor\\n    uint256 data;\\n  }\\n\\n  struct UserConfigurationMap {\\n    uint256 data;\\n  }\\n\\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\\n}\\n\"\r\n    },\r\n    \"interfaces/chainlink/AggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer() external view returns (int256);\\n  function latestTimestamp() external view returns (uint256);\\n  function latestRound() external view returns (uint256);\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\"\r\n    },\r\n    \"interfaces/chainlink/AggregatorV2V3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface\\n{\\n}\"\r\n    },\r\n    \"interfaces/chainlink/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\"\r\n    },\r\n    \"interfaces/compound/CErc20Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity >=0.7.6;\\n\\nimport \\\"./CTokenInterface.sol\\\";\\n\\ninterface CErc20Interface {\\n\\n    /*** User Interface ***/\\n\\n    function mint(uint mintAmount) external returns (uint);\\n    function redeem(uint redeemTokens) external returns (uint);\\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\\n    function borrow(uint borrowAmount) external returns (uint);\\n    function repayBorrow(uint repayAmount) external returns (uint);\\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) external returns (uint);\\n}\\n\"\r\n    },\r\n    \"interfaces/compound/CEtherInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity >=0.7.6;\\n\\ninterface CEtherInterface {\\n    function mint() external payable;\\n}\"\r\n    },\r\n    \"interfaces/compound/CTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity >=0.7.6;\\n\\ninterface CTokenInterface {\\n\\n    /*** User Interface ***/\\n\\n    function underlying() external view returns (address);\\n    function totalSupply() external view returns (uint256);\\n    function transfer(address dst, uint amount) external returns (bool);\\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\\n    function approve(address spender, uint amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function balanceOfUnderlying(address owner) external returns (uint);\\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\\n    function borrowRatePerBlock() external view returns (uint);\\n    function supplyRatePerBlock() external view returns (uint);\\n    function totalBorrowsCurrent() external returns (uint);\\n    function borrowBalanceCurrent(address account) external returns (uint);\\n    function borrowBalanceStored(address account) external view returns (uint);\\n    function exchangeRateCurrent() external returns (uint);\\n    function exchangeRateStored() external view returns (uint);\\n    function getCash() external view returns (uint);\\n    function accrueInterest() external returns (uint);\\n    function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint);\\n    function accrualBlockNumber() external view returns (uint256);\\n    function totalBorrows() external view returns (uint256);\\n    function totalReserves() external view returns (uint256);\\n    function interestRateModel() external view returns (address);\\n    function reserveFactorMantissa() external view returns (uint256);\\n    function initialExchangeRateMantissa() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"interfaces/IEIP20NonStandard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >=0.7.6;\\n\\n/**\\n * @title EIP20NonStandardInterface\\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n */\\ninterface IEIP20NonStandard {\\n\\n    /**\\n     * @notice Get the total number of tokens in circulation\\n     * @return The supply of tokens\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the balance of the specified address\\n     * @param owner The address from which the balance will be retrieved\\n     * @return balance\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    ///\\n    /// !!!!!!!!!!!!!!\\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\\n    /// !!!!!!!!!!!!!!\\n    ///\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      */\\n    function transfer(address dst, uint256 amount) external;\\n\\n    ///\\n    /// !!!!!!!!!!!!!!\\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\\n    /// !!!!!!!!!!!!!!\\n    ///\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `src` to `dst`\\n      * @param src The address of the source account\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      */\\n    function transferFrom(address src, address dst, uint256 amount) external;\\n\\n    ///\\n    /// !!!!!!!!!!!!!!\\n    /// !!! NOTICE !!! `approve` does not return a value, in violation of the ERC-20 specification\\n    /// !!!!!!!!!!!!!!\\n    ///\\n\\n    /**\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\n      * @dev This will overwrite the approval amount for `spender`\\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n      * @param spender The address of the account which may transfer tokens\\n      * @param amount The number of tokens that are approved\\n      */\\n    function approve(address spender, uint256 amount) external;\\n\\n    /**\\n      * @notice Get the current allowance from `owner` for `spender`\\n      * @param owner The address of the account which owns the tokens to be spent\\n      * @param spender The address of the account which may transfer tokens\\n      * @return remaining The number of tokens allowed to be spent\\n      */\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n}\"\r\n    },\r\n    \"interfaces/notional/AssetRateAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-v3\\npragma solidity >=0.7.0;\\n\\n/// @notice Used as a wrapper for tokens that are interest bearing for an\\n/// underlying token. Follows the cToken interface, however, can be adapted\\n/// for other interest bearing tokens.\\ninterface AssetRateAdapter {\\n    function token() external view returns (address);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function description() external view returns (string memory);\\n\\n    function version() external view returns (uint256);\\n\\n    function underlying() external view returns (address);\\n\\n    function getExchangeRateStateful() external returns (int256);\\n\\n    function getExchangeRateView() external view returns (int256);\\n\\n    function getAnnualizedSupplyRate() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"interfaces/notional/IRewarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >=0.7.6;\\n\\ninterface IRewarder {\\n    function claimRewards(\\n        address account,\\n        uint16 currencyId,\\n        uint256 nTokenBalanceBefore,\\n        uint256 nTokenBalanceAfter,\\n        int256  netNTokenSupplyChange,\\n        uint256 NOTETokensClaimed\\n    ) external;\\n}\"\r\n    },\r\n    \"interfaces/notional/NotionalCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >=0.7.6;\\n\\ninterface NotionalCallback {\\n    function notionalCallback(address sender, address account, bytes calldata callbackdata) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/external/FreeCollateralExternal.sol\": {\r\n        \"FreeCollateralExternal\": \"0xd256186ae98c81a3b54b1ef9108f60a263ecd417\"\r\n      },\r\n      \"contracts/external/MigrateIncentives.sol\": {\r\n        \"MigrateIncentives\": \"0x244321a0c5ee55df1f4d31c71570cbe0236c1864\"\r\n      },\r\n      \"contracts/external/SettleAssetsExternal.sol\": {\r\n        \"SettleAssetsExternal\": \"0x01713633a1b85a4a3d2f9430c68bd4392c4a90ea\"\r\n      },\r\n      \"contracts/external/actions/TradingAction.sol\": {\r\n        \"TradingAction\": \"0x9f2ef160cf02a02e60e4b17183343292b28d3466\"\r\n      },\r\n      \"contracts/external/actions/nTokenMintAction.sol\": {\r\n        \"nTokenMintAction\": \"0xc3f1ff56673d423ee4c4cafdbd7f94f0dd8f24d0\"\r\n      },\r\n      \"contracts/external/actions/nTokenRedeemAction.sol\": {\r\n        \"nTokenRedeemAction\": \"0x2f77cdd140d0ec7db9306b91959003872a7ceb92\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum DepositActionType\",\"name\":\"actionType\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"depositActionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmountInternalPrecision\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withdrawEntireCashBalance\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"redeemToUnderlying\",\"type\":\"bool\"}],\"internalType\":\"struct BalanceAction[]\",\"name\":\"actions\",\"type\":\"tuple[]\"}],\"name\":\"batchBalanceAction\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum DepositActionType\",\"name\":\"actionType\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"depositActionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmountInternalPrecision\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withdrawEntireCashBalance\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"redeemToUnderlying\",\"type\":\"bool\"},{\"internalType\":\"bytes32[]\",\"name\":\"trades\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct BalanceActionWithTrades[]\",\"name\":\"actions\",\"type\":\"tuple[]\"}],\"name\":\"batchBalanceAndTradeAction\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum DepositActionType\",\"name\":\"actionType\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"depositActionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmountInternalPrecision\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withdrawEntireCashBalance\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"redeemToUnderlying\",\"type\":\"bool\"},{\"internalType\":\"bytes32[]\",\"name\":\"trades\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct BalanceActionWithTrades[]\",\"name\":\"actions\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"callbackData\",\"type\":\"bytes\"}],\"name\":\"batchBalanceAndTradeActionWithCallback\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"depositUnderlying\",\"type\":\"bool\"},{\"internalType\":\"bytes32[]\",\"name\":\"trades\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct BatchLend[]\",\"name\":\"actions\",\"type\":\"tuple[]\"}],\"name\":\"batchLend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLibInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseGuardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BatchAction", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}