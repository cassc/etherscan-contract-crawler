{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/LynxStaking.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport \\\"./interfaces/ILynxStaking.sol\\\";\\nimport \\\"./interfaces/ILynxVault.sol\\\";\\nimport \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\nimport \\\"openzeppelin/security/ReentrancyGuard.sol\\\";\\n\\nerror LYNXStaking__InvalidDepositAmount();\\nerror LYNXStaking__InvalidAprSelected();\\nerror LYNXStaking__WithdrawLocked(uint lockEndTime);\\n\\ncontract LynxStaking is ILynxStaking, ReentrancyGuard {\\n    //--------------------------------------------------------------------\\n    // State Variables\\n    //--------------------------------------------------------------------\\n    mapping(address => Stake) public stake;\\n    uint256 private immutable apr;\\n    uint256 private immutable dur;\\n    AprConfig public aprConfig;\\n\\n    address[] public stakers;\\n    IERC20 public lynx;\\n    ILynxVault public vault;\\n    uint256 public totalStaked;\\n    uint256 public totalClaimed;\\n    uint256 public constant REWARD_APR_BASE = 100_00; // 100.00%\\n    uint256 public immutable LockStart;\\n\\n    //--------------------------------------------------------------------\\n    // Construtor\\n    //--------------------------------------------------------------------\\n    /**\\n     * @notice Constructor to set up the contract\\n     * @param weekStart - timestamp of when the weeks start\\n     * @param _lynx - address of lynx token.\\n     * @param _vault - address of vault that holds lynx to send/withdraw funds from\\n     * @param _apr - the expected APR to give back to users.\\n     * @param time_lock - the amount of weeks to lock tokens for\\n     */\\n    constructor(\\n        uint weekStart,\\n        address _lynx,\\n        address _vault,\\n        uint _apr,\\n        uint256 time_lock\\n    ) {\\n        time_lock = time_lock * 1 weeks;\\n        LockStart = weekStart;\\n        apr = _apr;\\n        dur = time_lock;\\n        aprConfig = AprConfig(true, _apr, time_lock);\\n        lynx = IERC20(_lynx);\\n        vault = ILynxVault(_vault);\\n    }\\n\\n    //--------------------------------------------------------------------\\n    // External / Public Functions\\n    //--------------------------------------------------------------------\\n    function deposit(uint amount) external nonReentrant {\\n        if (amount == 0) revert LYNXStaking__InvalidDepositAmount();\\n        Stake storage currentStake = stake[msg.sender];\\n        uint256 duration = dur;\\n\\n        if (currentStake.set) {\\n            uint reward = currentRewards(msg.sender);\\n            // IF reward time is over, claim rewards and reset the user\\n            if (currentStake.rewardEnd < block.timestamp) {\\n                // claim rewards\\n                totalClaimed += reward + currentStake.lockedRewards;\\n                currentStake.lockedRewards = 0;\\n                vault.withdrawTo(msg.sender, reward);\\n                emit ClaimRewards(msg.sender, reward);\\n            }\\n            // ELSE\\n            else {\\n                // lock rewards accrued so far and add the new deposit to the existing one\\n                currentStake.lockedRewards += reward;\\n                emit LockedRewards(msg.sender, reward);\\n            }\\n            currentStake.depositAmount += amount;\\n        } else {\\n            currentStake.depositAmount = amount;\\n            currentStake.posIndex = stakers.length;\\n            currentStake.set = true;\\n            stakers.push(msg.sender);\\n        }\\n        totalStaked += amount;\\n        currentStake.startStake = block.timestamp;\\n        currentStake.rewardEnd = calculateEndTime(duration);\\n        // Transfer Deposit amounts to Vault\\n        lynx.transferFrom(msg.sender, address(vault), amount);\\n        emit Deposit(msg.sender, amount, duration, currentStake.rewardEnd);\\n    }\\n\\n    function withdraw() external nonReentrant {\\n        Stake storage currentStake = stake[msg.sender];\\n        if (block.timestamp < currentStake.rewardEnd)\\n            revert LYNXStaking__WithdrawLocked(currentStake.rewardEnd);\\n\\n        // Claim rewards\\n        uint reward = currentRewards(msg.sender);\\n        reward += currentStake.lockedRewards;\\n        emit ClaimRewards(msg.sender, reward);\\n        reward += currentStake.depositAmount;\\n        emit Withdraw(msg.sender, currentStake.depositAmount);\\n        // remove user from stake list\\n        address lastIdxUser = stakers[stakers.length - 1];\\n        stakers[currentStake.posIndex] = lastIdxUser;\\n        stake[lastIdxUser].posIndex = currentStake.posIndex;\\n        stakers.pop();\\n        totalStaked -= currentStake.depositAmount;\\n        // reset the user\\n        stake[msg.sender] = Stake(0, 0, 0, 0, 0, false);\\n        vault.withdrawTo(msg.sender, reward);\\n    }\\n\\n    function currentRewards(address user) public view returns (uint256) {\\n        Stake storage currentStake = stake[user];\\n\\n        if (currentStake.depositAmount == 0 || !currentStake.set) return 0;\\n\\n        uint256 rewardEnd = currentStake.rewardEnd;\\n        uint256 rewardAmount = 0;\\n\\n        if (block.timestamp > rewardEnd) {\\n            rewardAmount = rewardEnd - currentStake.startStake;\\n        } else {\\n            rewardAmount = block.timestamp - currentStake.startStake;\\n        }\\n\\n        rewardAmount =\\n            (currentStake.depositAmount * rewardAmount * apr) /\\n            (REWARD_APR_BASE * 365 days);\\n\\n        return rewardAmount;\\n    }\\n\\n    function calculateEndTime(uint256 duration) public view returns (uint256) {\\n        uint currentWeek = (block.timestamp - LockStart) / 1 weeks;\\n        return LockStart + (currentWeek * 1 weeks) + duration + 1 weeks;\\n    }\\n\\n    function getStakers()\\n        external\\n        view\\n        returns (address[] memory users, uint256[] memory balances)\\n    {\\n        users = new address[](stakers.length);\\n        balances = new uint256[](stakers.length);\\n        for (uint i = 0; i < stakers.length; i++) {\\n            users[i] = stakers[i];\\n            balances[i] = stake[stakers[i]].depositAmount;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILynxStaking.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\ninterface ILynxStaking {\\n    struct Stake {\\n        uint256 depositAmount;\\n        uint256 startStake;\\n        uint256 rewardEnd;\\n        uint256 posIndex;\\n        uint256 lockedRewards;\\n        bool set;\\n    }\\n\\n    struct AprConfig {\\n        bool setup; // This is a flag to indicate if the APR has been set up\\n        uint256 apr; // This is the APR for the staking - this has to be in the format XX_00 since there are 2 decimals in the APR value;\\n        uint256 duration; // This is the duration in weeks of when the staking should end\\n    }\\n\\n    /**\\n     * Deposit tokens in the Staking pool and start earning rewards while the tokens are locked.\\n     * @param amount The amount of LYNX to deposit\\n     * @dev if the user is already staked in, claim the current rewards and add the new deposit to the existing one, then relock the tokens for duration.\\n     */\\n    function deposit(uint amount) external;\\n\\n    /**\\n     * Withdraw tokens from the Staking pool along with the rewards earned.\\n     */\\n    function withdraw() external;\\n\\n    /**\\n     * Gives the current reward amount for the user.\\n     * @param user The address of the user to check\\n     * @return The amount of LYNX the user has been rewarded with\\n     * @dev If the user is staked for longer than the lock amount, no additional rewards are given.\\n     */\\n    function currentRewards(address user) external view returns (uint256);\\n\\n    event Deposit(\\n        address indexed user,\\n        uint256 amount,\\n        uint256 duration,\\n        uint256 rewardEnd\\n    );\\n\\n    event ClaimRewards(address indexed user, uint256 amount);\\n    event LockedRewards(address indexed user, uint256 amount);\\n    event Withdraw(address indexed user, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILynxVault.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\ninterface ILynxVault {\\n    function withdraw(uint amount) external;\\n\\n    function withdrawTo(address _address, uint amount) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"weekStart\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_lynx\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_apr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time_lock\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"LYNXStaking__InvalidDepositAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lockEndTime\",\"type\":\"uint256\"}],\"name\":\"LYNXStaking__WithdrawLocked\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardEnd\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LockedRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LockStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARD_APR_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aprConfig\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"setup\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"apr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"calculateEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"currentRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lynx\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"posIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedRewards\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"set\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract ILynxVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LynxStaking", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000657ce88000000000000000000000000080d186b4c786ea66592b2c52e2004ab10cfe4cf3000000000000000000000000cf3fdd93bd43f24c84aa1002735f07ee83e194ec00000000000000000000000000000000000000000000000000000000000007070000000000000000000000000000000000000000000000000000000000000002", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}