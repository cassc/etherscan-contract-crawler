{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Babylonian.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.23;\\n\\nlibrary Babylonian {\\n\\n    function sqrt(\\n        uint256 x\\n    )\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (x == 0) return 0;\\n\\n        uint256 xx = x;\\n        uint256 r = 1;\\n        if (xx >= 0x100000000000000000000000000000000) {\\n            xx >>= 128;\\n            r <<= 64;\\n        }\\n        if (xx >= 0x10000000000000000) {\\n            xx >>= 64;\\n            r <<= 32;\\n        }\\n        if (xx >= 0x100000000) {\\n            xx >>= 32;\\n            r <<= 16;\\n        }\\n        if (xx >= 0x10000) {\\n            xx >>= 16;\\n            r <<= 8;\\n        }\\n        if (xx >= 0x100) {\\n            xx >>= 8;\\n            r <<= 4;\\n        }\\n        if (xx >= 0x10) {\\n            xx >>= 4;\\n            r <<= 2;\\n        }\\n        if (xx >= 0x8) {\\n            r <<= 1;\\n        }\\n        r = (r + (x / r)) >> 1;\\n        r = (r + (x / r)) >> 1;\\n        r = (r + (x / r)) >> 1;\\n        r = (r + (x / r)) >> 1;\\n        r = (r + (x / r)) >> 1;\\n        r = (r + (x / r)) >> 1;\\n        r = (r + (x / r)) >> 1;\\n\\n        uint256 r1 = x / r;\\n        return (r < r1 ? r : r1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/InterfaceHub/IAaveHubLite.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.23;\\n\\ninterface IAaveHubLite {\\n\\n    function sendingProgressAaveHub()\\n        external\\n        view\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/InterfaceHub/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.23;\\n\\ninterface IERC20 {\\n\\n    function totalSupply()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function balanceOf(\\n        address _account\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function transferFrom(\\n        address _sender,\\n        address _recipient,\\n        uint256 _amount\\n    )\\n        external\\n        returns (bool);\\n\\n    function transfer(\\n        address _recipient,\\n        uint256 _amount\\n    )\\n        external\\n        returns (bool);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(\\n        address _spender,\\n        uint256 _amount\\n    )\\n        external\\n        returns (bool);\\n\\n    function decimals()\\n        external\\n        view\\n        returns (uint8);\\n\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 value\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    event  Deposit(\\n        address indexed dst,\\n        uint wad\\n    );\\n\\n    event  Withdrawal(\\n        address indexed src,\\n        uint wad\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/InterfaceHub/IFeeManagerLight.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.23;\\n\\ninterface IFeeManagerLight {\\n    function addPoolTokenAddress(\\n        address _poolToken\\n    )\\n        external;\\n}\\n\"\r\n    },\r\n    \"contracts/InterfaceHub/IPositionNFTs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.23;\\n\\ninterface IPositionNFTs {\\n\\n    function ownerOf(\\n        uint256 _nftId\\n    )\\n        external\\n        view\\n        returns (address);\\n\\n    function getOwner(\\n        uint256 _nftId\\n    )\\n        external\\n        view\\n        returns (address);\\n\\n    function totalSupply()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function reserved(\\n        address _owner\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function reservePosition()\\n        external;\\n\\n    function mintPosition()\\n        external\\n        returns (uint256);\\n\\n    function tokenOfOwnerByIndex(\\n        address _owner,\\n        uint256 _index\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function walletOfOwner(\\n        address _owner\\n    )\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    function mintPositionForUser(\\n        address _user\\n    )\\n        external\\n        returns (uint256);\\n\\n    function reservePositionForUser(\\n        address _user\\n    )\\n        external\\n        returns (uint256);\\n\\n    function getApproved(\\n        uint256 _nftId\\n    )\\n        external\\n        view\\n        returns (address);\\n\\n    function approve(\\n        address _to,\\n        uint256 _nftId\\n    )\\n        external;\\n\\n    function isOwner(\\n        uint256 _nftId,\\n        address _caller\\n    )\\n        external\\n        view\\n        returns (bool);\\n\\n    function FEE_MANAGER_NFT()\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/InterfaceHub/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.23;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n\\n    function deposit()\\n        external\\n        payable;\\n\\n    function withdraw(\\n        uint256\\n    )\\n        external;\\n}\\n\"\r\n    },\r\n    \"contracts/InterfaceHub/IWiseOracleHub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.23;\\n\\ninterface IWiseOracleHub {\\n\\n    function getTokensPriceFromUSD(\\n        address _tokenAddress,\\n        uint256 _usdValue\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getTokensPriceInUSD(\\n        address _tokenAddress,\\n        uint256 _tokenAmount\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function latestResolver(\\n        address _tokenAddress\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getTokensFromUSD(\\n        address _tokenAddress,\\n        uint256 _usdValue\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getTokensFromETH(\\n        address _tokenAddress,\\n        uint256 _ethValue\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getTokensInUSD(\\n        address _tokenAddress,\\n        uint256 _amount\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getTokensInETH(\\n        address _tokenAddress,\\n        uint256 _tokenAmount\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function chainLinkIsDead(\\n        address _tokenAddress\\n    )\\n        external\\n        view\\n        returns (bool);\\n\\n    function decimalsUSD()\\n        external\\n        pure\\n        returns (uint8);\\n\\n    function addOracle(\\n        address _tokenAddress,\\n        address _priceFeedAddress,\\n        address[] calldata _underlyingFeedTokens\\n    )\\n        external;\\n\\n    function recalibrate(\\n        address _tokenAddress\\n    )\\n        external;\\n\\n    function WETH_ADDRESS()\\n        external\\n        view\\n        returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/InterfaceHub/IWiseSecurity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.23;\\n\\nstruct CurveSwapStructToken {\\n    uint256 curvePoolTokenIndexFrom;\\n    uint256 curvePoolTokenIndexTo;\\n    uint256 curveMetaPoolTokenIndexFrom;\\n    uint256 curveMetaPoolTokenIndexTo;\\n}\\n\\nstruct CurveSwapStructData {\\n    address curvePool;\\n    address curveMetaPool;\\n    bytes swapBytesPool;\\n    bytes swapBytesMeta;\\n}\\n\\ninterface IWiseSecurity {\\n\\n    function overallETHBorrowHeartbeat(\\n        uint256 _nftId\\n    )\\n        external\\n        view\\n        returns (uint256 buffer);\\n\\n    function checkBadDebt(\\n        uint256 _nftId\\n    )\\n        external;\\n\\n    function checksLiquidation(\\n        uint256 _nftIdLiquidate,\\n        address _tokenToPayback,\\n        uint256 _shareAmountToPay\\n    )\\n        external\\n        view;\\n\\n    function getPositionBorrowAmount(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getPositionLendingAmount(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getLiveDebtRatio(\\n        uint256 _nftId\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function overallUSDCollateralsBare(\\n        uint256 _nftId\\n    )\\n        external\\n        view\\n        returns (uint256 amount);\\n\\n    function overallETHCollateralsBare(\\n        uint256 _nftId\\n    )\\n        external\\n        view\\n        returns (uint256 amount);\\n\\n    function FEE_MANAGER()\\n        external\\n        view\\n        returns (address);\\n\\n    function AAVE_HUB()\\n        external\\n        view\\n        returns (address);\\n\\n    function curveSecurityCheck(\\n        address _poolAddress\\n    )\\n        external;\\n\\n    function prepareCurvePools(\\n        address _poolToken,\\n        CurveSwapStructData calldata _curveSwapStructData,\\n        CurveSwapStructToken calldata _curveSwapStructToken\\n    )\\n        external;\\n\\n    function checksWithdraw(\\n        uint256 _nftId,\\n        address _caller,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        external\\n        view;\\n\\n    function checksBorrow(\\n        uint256 _nftId,\\n        address _caller,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        external\\n        view;\\n\\n    function checksSolelyWithdraw(\\n        uint256 _nftId,\\n        address _caller,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        external\\n        view;\\n\\n    function checkOwnerPosition(\\n        uint256 _nftId,\\n        address _caller\\n    )\\n        external\\n        view;\\n\\n    function checksCollateralizeDeposit(\\n        uint256 _nftIdCaller,\\n        address _caller,\\n        address _poolAddress\\n    )\\n        external\\n        view;\\n\\n    function calculateWishPercentage(\\n        uint256 _nftId,\\n        address _receiveToken,\\n        uint256 _paybackETH,\\n        uint256 _maxFeeETH,\\n        uint256 _baseRewardLiquidation\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    function checkUncollateralizedDeposit(\\n        uint256 _nftIdCaller,\\n        address _poolToken\\n    )\\n        external\\n        view;\\n\\n    function checkPositionLocked(\\n        uint256 _nftId,\\n        address _caller\\n    )\\n        external\\n        view;\\n\\n    function maxFeeETH()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function maxFeeFarmETH()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function baseRewardLiquidation()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function baseRewardLiquidationFarm()\\n        external\\n        view\\n        returns (uint256);\\n\\n    function checksRegister(\\n        uint256 _nftId,\\n        address _caller\\n    )\\n        external\\n        view;\\n\\n    function getLendingRate(\\n        address _poolToken\\n    )\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/MainHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.23;\\n\\nimport \\\"./WiseLowLevelHelper.sol\\\";\\n\\nabstract contract MainHelper is WiseLowLevelHelper {\\n\\n    /**\\n     * @dev Internal helper function for reservating a\\n     * position NFT id.\\n     */\\n    function _reservePosition()\\n        internal\\n        returns (uint256)\\n    {\\n        return POSITION_NFT.reservePositionForUser(\\n            msg.sender\\n        );\\n    }\\n\\n    /**\\n     * @dev Helper function to convert {_amount}\\n     * of a certain pool with {_poolToken}\\n     * into lending shares. Includes devison\\n     * by zero and share security checks.\\n     * Needs latest pseudo amount for accurate\\n     * result.\\n     */\\n    function calculateLendingShares(\\n        address _poolToken,\\n        uint256 _amount,\\n        bool _maxSharePrice\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _calculateShares(\\n            lendingPoolData[_poolToken].totalDepositShares * _amount,\\n            lendingPoolData[_poolToken].pseudoTotalPool,\\n            _maxSharePrice\\n        );\\n    }\\n\\n    function _calculateShares(\\n        uint256 _product,\\n        uint256 _pseudo,\\n        bool _maxSharePrice\\n    )\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        return _maxSharePrice == true\\n            ? _product % _pseudo == 0\\n                ? _product / _pseudo\\n                : _product / _pseudo + 1\\n            : _product / _pseudo;\\n    }\\n\\n    /**\\n     * @dev Helper function to convert {_amount}\\n     * of a certain pool with {_poolToken}\\n     * into borrow shares. Includes devison\\n     * by zero and share security checks.\\n     * Needs latest pseudo amount for accurate\\n     * result.\\n     */\\n    function calculateBorrowShares(\\n        address _poolToken,\\n        uint256 _amount,\\n        bool _maxSharePrice\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _calculateShares(\\n            borrowPoolData[_poolToken].totalBorrowShares * _amount,\\n            borrowPoolData[_poolToken].pseudoTotalBorrowAmount,\\n            _maxSharePrice\\n        );\\n    }\\n\\n    /**\\n     * @dev Helper function to convert {_shares}\\n     * of a certain pool with {_poolToken}\\n     * into lending token. Includes devison\\n     * by zero and share security checks.\\n     * Needs latest pseudo amount for accurate\\n     * result.\\n     */\\n    function cashoutAmount(\\n        address _poolToken,\\n        uint256 _shares\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _shares\\n            * lendingPoolData[_poolToken].pseudoTotalPool\\n            / lendingPoolData[_poolToken].totalDepositShares;\\n    }\\n\\n    /**\\n     * @dev Helper function to convert {_shares}\\n     * of a certain pool with {_poolToken}\\n     * into borrow token. Includes devison\\n     * by zero and share security checks.\\n     * Needs latest pseudo amount for accurate\\n     * result.\\n     */\\n    function paybackAmount(\\n        address _poolToken,\\n        uint256 _shares\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 product = _shares\\n            * borrowPoolData[_poolToken].pseudoTotalBorrowAmount;\\n\\n        uint256 totalBorrowShares = borrowPoolData[_poolToken].totalBorrowShares;\\n\\n        return product % totalBorrowShares == 0\\n            ? product / totalBorrowShares\\n            : product / totalBorrowShares + 1;\\n    }\\n\\n    /**\\n     * @dev Internal helper combining one\\n     * security check with lending share\\n     * calculation for withdraw.\\n     */\\n    function _preparationsWithdraw(\\n        uint256 _nftId,\\n        address _caller,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        _checkOwnerPosition(\\n            _nftId,\\n            _caller\\n        );\\n\\n        return calculateLendingShares(\\n            {\\n                _poolToken: _poolToken,\\n                _amount: _amount,\\n                _maxSharePrice: true\\n            }\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal helper calculating {_poolToken}\\n     * utilization. Includes math underflow check.\\n     */\\n    function _getValueUtilization(\\n        address _poolToken\\n    )\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        uint256 totalPool = globalPoolData[_poolToken].totalPool;\\n        uint256 pseudoPool = lendingPoolData[_poolToken].pseudoTotalPool;\\n\\n        if (totalPool >= pseudoPool) {\\n            return 0;\\n        }\\n\\n        return PRECISION_FACTOR_E18 - (PRECISION_FACTOR_E18\\n            * totalPool\\n            / pseudoPool\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal helper function setting new pool\\n     * utilization by calling {_getValueUtilization}.\\n     */\\n    function _updateUtilization(\\n        address _poolToken\\n    )\\n        private\\n    {\\n        globalPoolData[_poolToken].utilization = _getValueUtilization(\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal helper function checking if\\n     * cleanup gathered new token to save into\\n     * pool variables.\\n     */\\n    function _checkCleanUp(\\n        uint256 _amountContract,\\n        uint256 _totalPool,\\n        uint256 _bareAmount\\n    )\\n        private\\n        pure\\n        returns (bool)\\n    {\\n        return _bareAmount + _totalPool >= _amountContract;\\n    }\\n\\n    function _getBalance(\\n        address _tokenAddress\\n    )\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return IERC20(_tokenAddress).balanceOf(\\n            address(this)\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal helper function checking if falsely\\n     * sent token are inside the contract for the pool with\\n     * {_poolToken}. If this is the case it adds those token\\n     * to the pool by increasing pseudo and total amount.\\n     * In context of aToken from aave pools it gathers the\\n     * rebase amount from supply APY of aave pools.\\n     */\\n    function _cleanUp(\\n        address _poolToken\\n    )\\n        internal\\n    {\\n        if (lendingPoolData[_poolToken].totalDepositShares == 0) {\\n            revert InvalidAction();\\n        }\\n\\n        uint256 amountContract = _getBalance(\\n            _poolToken\\n        );\\n\\n        uint256 totalPool = globalPoolData[_poolToken].totalPool;\\n        uint256 bareToken = globalPoolData[_poolToken].totalBareToken;\\n\\n        if (_checkCleanUp(amountContract, totalPool, bareToken)) {\\n            return;\\n        }\\n\\n        unchecked {\\n\\n            uint256 difference = amountContract - (\\n                totalPool + bareToken\\n            );\\n\\n            uint256 allowedDifference = _getAllowedDifference(\\n                _poolToken\\n            );\\n\\n            if (difference > allowedDifference) {\\n\\n                _increaseTotalAndPseudoTotalPool(\\n                    _poolToken,\\n                    allowedDifference\\n                );\\n\\n                return;\\n            }\\n\\n            _increaseTotalAndPseudoTotalPool(\\n                _poolToken,\\n                difference\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal helper function calculating\\n     * allowed increase of pseudoTotalPool to\\n     * contain shareprice increase reasoanbly.\\n    */\\n    function _getAllowedDifference(\\n        address _poolToken\\n    )\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 timeDifference = block.timestamp\\n            - timestampsPoolData[_poolToken].timeStamp;\\n\\n        return timeDifference\\n            * lendingPoolData[_poolToken].pseudoTotalPool\\n            * PRECISION_FACTOR_E18\\n            / PRECISION_FACTOR_YEAR;\\n    }\\n\\n    /**\\n     * @dev External wrapper for {_preparePole}\\n     * Only callable by powerFarms, feeManager\\n     * and aaveHub.\\n     */\\n    function preparePool(\\n        address _poolToken\\n    )\\n        external\\n        onlyAllowedContracts\\n    {\\n        _preparePool(\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev External wrapper for {_newBorrowRate}\\n     * Only callable by powerFarms, feeManager\\n     * and aaveHub.\\n     */\\n    function newBorrowRate(\\n        address _poolToken\\n    )\\n        external\\n        onlyAllowedContracts\\n    {\\n        _newBorrowRate(\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal helper function for\\n     * updating pools and calling {_cleanUp}.\\n     * Also includes re-entrancy guard for\\n     * curve pools security checks.\\n     */\\n    function _preparePool(\\n        address _poolToken\\n    )\\n        internal\\n    {\\n        _cleanUp(\\n            _poolToken\\n        );\\n\\n        _updatePseudoTotalAmounts(\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal helper function for\\n     * updating all lending tokens of a\\n     * position.\\n     */\\n    function _preparationTokens(\\n        mapping(uint256 => address[]) storage _userTokenData,\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        internal\\n        returns (address[] memory)\\n    {\\n        address[] memory tokens = _userTokenData[\\n            _nftId\\n        ];\\n\\n        _prepareTokens(\\n            _poolToken,\\n            tokens\\n        );\\n\\n        return tokens;\\n    }\\n\\n    /**\\n     * @dev Internal helper function for\\n     * updating pseudo amounts of a pool\\n     * inside {tokens} array and sets new\\n     * borrow rates.\\n     */\\n    function _prepareTokens(\\n        address _poolToken,\\n        address[] memory _tokens\\n    )\\n        private\\n    {\\n        address currentAddress;\\n\\n        uint256 i;\\n        uint256 l = _tokens.length;\\n\\n        while (i < l) {\\n\\n            currentAddress = _tokens[i];\\n\\n            unchecked {\\n                ++i;\\n            }\\n\\n            if (currentAddress == _poolToken) {\\n                continue;\\n            }\\n\\n            _preparePool(\\n                currentAddress\\n            );\\n\\n            _newBorrowRate(\\n                currentAddress\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal helper function for iterating\\n     * over all tokens which may contain curvePools.\\n     */\\n    function _curveSecurityChecks(\\n        address[] memory _lendTokens,\\n        address[] memory _borrowTokens\\n    )\\n        internal\\n    {\\n        _whileLoopCurveSecurity(\\n            _lendTokens\\n        );\\n\\n        _whileLoopCurveSecurity(\\n            _borrowTokens\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal helper function for executing while loops\\n     * iterating over all tokens which may contain curvePools.\\n     */\\n    function _whileLoopCurveSecurity(\\n        address[] memory _tokens\\n    )\\n        private\\n    {\\n        uint256 i;\\n        uint256 l = _tokens.length;\\n\\n        while (i < l) {\\n\\n            WISE_SECURITY.curveSecurityCheck(\\n                _tokens[i]\\n            );\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal helper function\\n     * updating pseudo amounts and\\n     * printing fee shares for the\\n     * feeManager proportional to the\\n     * fee percentage of the pool.\\n     */\\n    function _updatePseudoTotalAmounts(\\n        address _poolToken\\n    )\\n        private\\n    {\\n        uint256 currentTime = block.timestamp;\\n\\n        uint256 bareIncrease = borrowPoolData[_poolToken].borrowRate\\n            * (currentTime - timestampsPoolData[_poolToken].timeStamp)\\n            * borrowPoolData[_poolToken].pseudoTotalBorrowAmount\\n            + bufferIncrease[_poolToken];\\n\\n        if (bareIncrease < PRECISION_FACTOR_YEAR) {\\n            bufferIncrease[_poolToken] = bareIncrease;\\n\\n            _setTimeStamp(\\n                _poolToken,\\n                currentTime\\n            );\\n\\n            return;\\n        }\\n\\n        delete bufferIncrease[_poolToken];\\n\\n        uint256 amountInterest = bareIncrease\\n            / PRECISION_FACTOR_YEAR;\\n\\n        uint256 feeAmount = amountInterest\\n            * globalPoolData[_poolToken].poolFee\\n            / PRECISION_FACTOR_E18;\\n\\n        _increasePseudoTotalBorrowAmount(\\n            _poolToken,\\n            amountInterest\\n        );\\n\\n        _increasePseudoTotalPool(\\n            _poolToken,\\n            amountInterest\\n        );\\n\\n        if (feeAmount == 0) {\\n            _setTimeStamp(\\n                _poolToken,\\n                currentTime\\n            );\\n            return;\\n        }\\n\\n        uint256 feeShares = feeAmount\\n            * lendingPoolData[_poolToken].totalDepositShares\\n            / (lendingPoolData[_poolToken].pseudoTotalPool - feeAmount);\\n\\n        if (feeShares == 0) {\\n            _setTimeStamp(\\n                _poolToken,\\n                currentTime\\n            );\\n            return;\\n        }\\n\\n        _increasePositionLendingDeposit(\\n            FEE_MANAGER_NFT,\\n            _poolToken,\\n            feeShares\\n        );\\n\\n        _increaseTotalDepositShares(\\n            _poolToken,\\n            feeShares\\n        );\\n\\n        _setTimeStamp(\\n            _poolToken,\\n            currentTime\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal increas function for\\n     * lending shares of a postion {_nftId}\\n     * and {_poolToken}.\\n     */\\n    function _increasePositionLendingDeposit(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _shares\\n    )\\n        internal\\n    {\\n        userLendingData[_nftId][_poolToken].shares += _shares;\\n    }\\n\\n    /**\\n     * @dev Internal decrease function for\\n     * lending shares of a postion {_nftId}\\n     * and {_poolToken}.\\n     */\\n    function _decreaseLendingShares(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _shares\\n    )\\n        internal\\n    {\\n        userLendingData[_nftId][_poolToken].shares -= _shares;\\n    }\\n\\n    /**\\n     * @dev Internal helper function adding a new\\n     * {_poolToken} token to {userTokenData} if needed.\\n     * Check is done by using hash maps.\\n     */\\n    function _addPositionTokenData(\\n        uint256 _nftId,\\n        address _poolToken,\\n        mapping(bytes32 => bool) storage hashMap,\\n        mapping(uint256 => address[]) storage userTokenData\\n    )\\n        internal\\n    {\\n        bytes32 hashData = _getHash(\\n            _nftId,\\n            _poolToken\\n        );\\n\\n        if (hashMap[hashData] == true) {\\n            return;\\n        }\\n\\n        hashMap[hashData] = true;\\n\\n        userTokenData[_nftId].push(\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal helper calculating\\n     * a hash out of {_nftId} and {_poolToken}\\n     * using keccak256.\\n     */\\n    function _getHash(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        private\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(\\n            abi.encodePacked(\\n                _nftId,\\n                _poolToken\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal helper function deleting an\\n     * entry in {_deleteLastPositionData}.\\n     */\\n    function _removePositionData(\\n        uint256 _nftId,\\n        address _poolToken,\\n        function(uint256) view returns (uint256) _getPositionTokenLength,\\n        function(uint256, uint256) view returns (address) _getPositionTokenByIndex,\\n        function(uint256, address) internal _deleteLastPositionData,\\n        bool isLending\\n    )\\n        internal\\n    {\\n        uint256 length = _getPositionTokenLength(\\n            _nftId\\n        );\\n\\n        if (length == 1) {\\n            _deleteLastPositionData(\\n                _nftId,\\n                _poolToken\\n            );\\n\\n            return;\\n        }\\n\\n        uint8 i;\\n        uint256 endPosition = length - 1;\\n\\n        while (i < length) {\\n\\n            if (i == endPosition) {\\n                _deleteLastPositionData(\\n                    _nftId,\\n                    _poolToken\\n                );\\n\\n                break;\\n            }\\n\\n            if (_getPositionTokenByIndex(_nftId, i) != _poolToken) {\\n                unchecked {\\n                    ++i;\\n                }\\n                continue;\\n            }\\n\\n            address poolToken = _getPositionTokenByIndex(\\n                _nftId,\\n                endPosition\\n            );\\n\\n            isLending == true\\n                ? positionLendTokenData[_nftId][i] = poolToken\\n                : positionBorrowTokenData[_nftId][i] = poolToken;\\n\\n            _deleteLastPositionData(\\n                _nftId,\\n                _poolToken\\n            );\\n\\n            break;\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal helper deleting last entry\\n     * of postion lending data.\\n     */\\n    function _deleteLastPositionLendingData(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        private\\n    {\\n        positionLendTokenData[_nftId].pop();\\n        hashMapPositionLending[\\n            _getHash(\\n                _nftId,\\n                _poolToken\\n            )\\n        ] = false;\\n    }\\n\\n\\n    /**\\n     * @dev Core function combining payback\\n     * logic with security checks.\\n     */\\n    function _corePayback(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount,\\n        uint256 _shares\\n    )\\n        internal\\n    {\\n        _updatePoolStorage(\\n            _poolToken,\\n            _amount,\\n            _shares,\\n            _increaseTotalPool,\\n            _decreasePseudoTotalBorrowAmount,\\n            _decreaseTotalBorrowShares\\n        );\\n\\n        _decreasePositionMappingValue(\\n            userBorrowShares,\\n            _nftId,\\n            _poolToken,\\n            _shares\\n        );\\n\\n        if (userBorrowShares[_nftId][_poolToken] > 0) {\\n            return;\\n        }\\n\\n        _removePositionData({\\n            _nftId: _nftId,\\n            _poolToken: _poolToken,\\n            _getPositionTokenLength: getPositionBorrowTokenLength,\\n            _getPositionTokenByIndex: getPositionBorrowTokenByIndex,\\n            _deleteLastPositionData: _deleteLastPositionBorrowData,\\n            isLending: false\\n        });\\n    }\\n\\n    /**\\n     * @dev Internal helper deleting last entry\\n     * of postion borrow data.\\n     */\\n    function _deleteLastPositionBorrowData(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        private\\n    {\\n        positionBorrowTokenData[_nftId].pop();\\n        hashMapPositionBorrow[\\n            _getHash(\\n                _nftId,\\n                _poolToken\\n            )\\n        ] = false;\\n    }\\n\\n    /**\\n     * @dev Internal helper function calculating\\n     * returning if a {_poolToken} of a {_nftId}\\n     * is uncollateralized.\\n     */\\n    function isUncollateralized(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return userLendingData[_nftId][_poolToken].unCollateralized;\\n    }\\n\\n    /**\\n     * @dev Internal helper function\\n     * checking if {_nftId} as no\\n     * {_poolToken} left.\\n     */\\n    function _checkLendingDataEmpty(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return userLendingData[_nftId][_poolToken].shares == 0\\n            && pureCollateralAmount[_nftId][_poolToken] == 0;\\n    }\\n\\n    /**\\n     * @dev Internal helper function\\n     * calculating new borrow rates\\n     * for {_poolToken}. Uses smooth\\n     * functions of the form\\n     * f(x) = a * x /(p(p-x)) with\\n     * p > 1E18 the {pole} and\\n     * a the {mulFactor}.\\n     */\\n    function _calculateNewBorrowRate(\\n        address _poolToken\\n    )\\n        internal\\n    {\\n        uint256 pole = borrowRatesData[_poolToken].pole;\\n        uint256 utilization = globalPoolData[_poolToken].utilization;\\n\\n        uint256 baseDivider = pole\\n            * (pole - utilization);\\n\\n        borrowPoolData[_poolToken].borrowRate =\\n            borrowRatesData[_poolToken].multiplicativeFactor\\n                * PRECISION_FACTOR_E18\\n                * utilization\\n                / baseDivider;\\n    }\\n\\n    /**\\n     * @dev Internal helper function\\n     * updating utilization of the pool\\n     * with {_poolToken}, calculating the\\n     * new borrow rate and running LASA if\\n     * the time intervall of three hours has\\n     * passed.\\n     */\\n    function _newBorrowRate(\\n        address _poolToken\\n    )\\n        internal\\n    {\\n        _updateUtilization(\\n            _poolToken\\n        );\\n\\n        _calculateNewBorrowRate(\\n            _poolToken\\n        );\\n\\n        if (_aboveThreshold(_poolToken) == false) {\\n            return;\\n        }\\n\\n        _scalingAlgorithm(\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal helper function\\n     * checking if time interval for\\n     * next LASA call has passed.\\n     */\\n    function _aboveThreshold(\\n        address _poolToken\\n    )\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return block.timestamp - timestampsPoolData[_poolToken].timeStampScaling >= THREE_HOURS;\\n    }\\n\\n    /**\\n     * @dev function that tries to maximise totalDepositShares of the pool.\\n     * Reacting to negative and positive feedback by changing the resonance\\n     * factor of the pool. Method similar to one parameter monte-carlo methods\\n     */\\n    function _scalingAlgorithm(\\n        address _poolToken\\n    )\\n        private\\n    {\\n        uint256 totalShares = lendingPoolData[_poolToken].totalDepositShares;\\n\\n        if (algorithmData[_poolToken].maxValue <= totalShares) {\\n\\n            _newMaxPoolShares(\\n                _poolToken,\\n                totalShares\\n            );\\n\\n            _saveUp(\\n                _poolToken,\\n                totalShares\\n            );\\n\\n            return;\\n        }\\n\\n        _resonanceOutcome(_poolToken, totalShares) == true\\n            ? _resetResonanceFactor(_poolToken, totalShares)\\n            : _updateResonanceFactor(_poolToken, totalShares);\\n\\n        _saveUp(\\n            _poolToken,\\n            totalShares\\n        );\\n    }\\n\\n    /**\\n     * @dev Sets the new max value in shares\\n     * and saves the corresponding resonance factor.\\n     */\\n    function _newMaxPoolShares(\\n        address _poolToken,\\n        uint256 _shareValue\\n    )\\n        private\\n    {\\n        _setMaxValue(\\n            _poolToken,\\n            _shareValue\\n        );\\n\\n        _setBestPole(\\n            _poolToken,\\n            borrowRatesData[_poolToken].pole\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal function setting {previousValue}\\n     * and {timestampScaling} for LASA of pool with\\n     * {_poolToken}.\\n     */\\n    function _saveUp(\\n        address _poolToken,\\n        uint256 _shareValue\\n    )\\n        private\\n    {\\n        algorithmData[_poolToken].previousValue = _shareValue;\\n\\n        _setTimeStampScaling(\\n            _poolToken,\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev Returns bool to determine if resonance\\n     * factor needs to be reset to last best value.\\n     */\\n    function _resonanceOutcome(\\n        address _poolToken,\\n        uint256 _shareValue\\n    )\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return _shareValue < THRESHOLD_RESET_RESONANCE_FACTOR\\n            * algorithmData[_poolToken].maxValue\\n            / PRECISION_FACTOR_E18;\\n    }\\n\\n    /**\\n     * @dev Resets resonance factor to old best value when system\\n     * evolves into too bad state and sets current totalDepositShares\\n     * amount to new maxPoolShares to exclude eternal loops and that\\n     * unorganic peaks do not set maxPoolShares forever.\\n     */\\n    function _resetResonanceFactor(\\n        address _poolToken,\\n        uint256 _shareValue\\n    )\\n        private\\n    {\\n        _setPole(\\n            _poolToken,\\n            algorithmData[_poolToken].bestPole\\n        );\\n\\n        _setMaxValue(\\n            _poolToken,\\n            _shareValue\\n        );\\n\\n        _revertDirectionState(\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev Reverts the flag for stepping direction from LASA.\\n     */\\n    function _revertDirectionState(\\n        address _poolToken\\n    )\\n        private\\n    {\\n        _setIncreasePole(\\n            _poolToken,\\n            !algorithmData[_poolToken].increasePole\\n        );\\n    }\\n\\n    /**\\n     * @dev Function combining all possible stepping scenarios.\\n     * Depending how share values has changed compared to last time.\\n     */\\n    function _updateResonanceFactor(\\n        address _poolToken,\\n        uint256 _shareValues\\n    )\\n        private\\n    {\\n        _shareValues < THRESHOLD_SWITCH_DIRECTION\\n            * algorithmData[_poolToken].previousValue\\n            / PRECISION_FACTOR_E18\\n            ? _reversedResonanceFactor(_poolToken)\\n            : _changingResonanceFactor(_poolToken);\\n    }\\n\\n    /**\\n     * @dev Does a revert stepping and swaps stepping state in opposite flag.\\n     */\\n    function _reversedResonanceFactor(\\n        address _poolToken\\n    )\\n        private\\n    {\\n        algorithmData[_poolToken].increasePole\\n            ? _decreaseResonanceFactor(_poolToken)\\n            : _increaseResonanceFactor(_poolToken);\\n\\n        _revertDirectionState(\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev Increasing or decresing resonance factor depending on flag value.\\n     */\\n    function _changingResonanceFactor(\\n        address _poolToken\\n    )\\n        private\\n    {\\n        algorithmData[_poolToken].increasePole\\n            ? _increaseResonanceFactor(_poolToken)\\n            : _decreaseResonanceFactor(_poolToken);\\n    }\\n\\n    /**\\n     * @dev stepping function increasing the resonance factor\\n     * depending on the time past in the last time interval.\\n     * Checks if current resonance factor is bigger than max value.\\n     * If this is the case sets current value to maximal value\\n     */\\n    function _increaseResonanceFactor(\\n        address _poolToken\\n    )\\n        private\\n    {\\n        BorrowRatesEntry memory borrowData = borrowRatesData[\\n            _poolToken\\n        ];\\n\\n        uint256 delta = borrowData.deltaPole\\n            * (block.timestamp - timestampsPoolData[_poolToken].timeStampScaling);\\n\\n        uint256 sum = delta\\n            + borrowData.pole;\\n\\n        uint256 setValue = sum > borrowData.maxPole\\n            ? borrowData.maxPole\\n            : sum;\\n\\n        _setPole(\\n            _poolToken,\\n            setValue\\n        );\\n    }\\n\\n    /**\\n     * @dev Stepping function decresing the resonance factor\\n     * depending on the time past in the last time interval.\\n     * Checks if current resonance factor undergoes the min value,\\n     * if this is the case sets current value to minimal value.\\n     */\\n    function _decreaseResonanceFactor(\\n        address _poolToken\\n    )\\n        private\\n    {\\n        uint256 minValue = borrowRatesData[_poolToken].minPole;\\n\\n        uint256 delta = borrowRatesData[_poolToken].deltaPole\\n            * (block.timestamp - timestampsPoolData[_poolToken].timeStampScaling);\\n\\n        uint256 sub = borrowRatesData[_poolToken].pole > delta\\n            ? borrowRatesData[_poolToken].pole - delta\\n            : 0;\\n\\n        uint256 setValue = sub < minValue\\n            ? minValue\\n            : sub;\\n\\n        _setPole(\\n            _poolToken,\\n            setValue\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal helper function for removing token address\\n     * from lending data array if all shares are removed. When\\n     * feeManager (nftId = 0) is calling this function is skipped\\n     * to save gas for continues fee accounting.\\n     */\\n    function _removeEmptyLendingData(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        internal\\n    {\\n        if (_nftId == 0) {\\n            return;\\n        }\\n\\n        if (_checkLendingDataEmpty(_nftId, _poolToken) == false) {\\n            return;\\n        }\\n\\n        _removePositionData({\\n            _nftId: _nftId,\\n            _poolToken: _poolToken,\\n            _getPositionTokenLength: getPositionLendingTokenLength,\\n            _getPositionTokenByIndex: getPositionLendingTokenByIndex,\\n            _deleteLastPositionData: _deleteLastPositionLendingData,\\n            isLending: true\\n        });\\n    }\\n\\n    /**\\n     * @dev Internal helper function grouping several function\\n     * calls into one function for refactoring and code size\\n     * reduction.\\n     */\\n    function _updatePoolStorage(\\n        address _poolToken,\\n        uint256 _amount,\\n        uint256 _shares,\\n        function(address, uint256) functionAmountA,\\n        function(address, uint256) functionAmountB,\\n        function(address, uint256) functionSharesA\\n    )\\n        internal\\n    {\\n        functionAmountA(\\n            _poolToken,\\n            _amount\\n        );\\n\\n        functionAmountB(\\n            _poolToken,\\n            _amount\\n        );\\n\\n        functionSharesA(\\n            _poolToken,\\n            _shares\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/OwnableMaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.23;\\n\\nerror NoValue();\\nerror NotMaster();\\nerror NotProposed();\\n\\ncontract OwnableMaster {\\n\\n    address public master;\\n    address private proposedMaster;\\n\\n    address internal constant ZERO_ADDRESS = address(0x0);\\n\\n    modifier onlyProposed() {\\n        _onlyProposed();\\n        _;\\n    }\\n\\n    function _onlyMaster()\\n        private\\n        view\\n    {\\n        if (msg.sender == master) {\\n            return;\\n        }\\n\\n        revert NotMaster();\\n    }\\n\\n    modifier onlyMaster() {\\n        _onlyMaster();\\n        _;\\n    }\\n\\n    function _onlyProposed()\\n        private\\n        view\\n    {\\n        if (msg.sender == proposedMaster) {\\n            return;\\n        }\\n\\n        revert NotProposed();\\n    }\\n\\n    event MasterProposed(\\n        address indexed proposer,\\n        address indexed proposedMaster\\n    );\\n\\n    event ClaimedOwnership(\\n        address indexed newMaster,\\n        address indexed previousMaster\\n    );\\n\\n    event RenouncedOwnership(\\n        address indexed previousMaster\\n    );\\n\\n    constructor(\\n        address _master\\n    ) {\\n        if (_master == ZERO_ADDRESS) {\\n            revert NoValue();\\n        }\\n        master = _master;\\n    }\\n\\n    /**\\n     * @dev Allows to propose next master.\\n     * Must be claimed by proposer.\\n     */\\n    function proposeOwner(\\n        address _proposedOwner\\n    )\\n        external\\n        onlyMaster\\n    {\\n        if (_proposedOwner == ZERO_ADDRESS) {\\n            revert NoValue();\\n        }\\n\\n        proposedMaster = _proposedOwner;\\n\\n        emit MasterProposed(\\n            msg.sender,\\n            _proposedOwner\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows to claim master role.\\n     * Must be called by proposer.\\n     */\\n    function claimOwnership()\\n        external\\n        onlyProposed\\n    {\\n        master = proposedMaster;\\n\\n        emit ClaimedOwnership(\\n            master,\\n            msg.sender\\n        );\\n    }\\n\\n    /**\\n     * @dev Removes master role.\\n     * No ability to be in control.\\n     */\\n    function renounceOwnership()\\n        external\\n        onlyMaster\\n    {\\n        master = ZERO_ADDRESS;\\n        proposedMaster = ZERO_ADDRESS;\\n\\n        emit RenouncedOwnership(\\n            msg.sender\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PoolManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.23;\\n\\nimport \\\"./WiseCore.sol\\\";\\nimport \\\"./Babylonian.sol\\\";\\n\\nabstract contract PoolManager is WiseCore {\\n\\n    using Babylonian for uint256;\\n\\n    struct CreatePool {\\n        bool allowBorrow;\\n        address poolToken;\\n        uint256 poolMulFactor;\\n        uint256 poolCollFactor;\\n        uint256 maxDepositAmount;\\n    }\\n\\n    struct CurvePoolSettings {\\n        CurveSwapStructData curveSecuritySwapsData;\\n        CurveSwapStructToken curveSecuritySwapsToken;\\n    }\\n\\n    function setParamsLASA(\\n        address _poolToken,\\n        uint256 _poolMulFactor,\\n        uint256 _upperBoundMaxRate,\\n        uint256 _lowerBoundMaxRate,\\n        bool _steppingDirection,\\n        bool _isFinal\\n    )\\n        external\\n        onlyMaster\\n    {\\n        if (parametersLocked[_poolToken] == true) {\\n            revert InvalidAction();\\n        }\\n\\n        parametersLocked[_poolToken] = _isFinal;\\n\\n        AlgorithmEntry storage algoData = algorithmData[\\n            _poolToken\\n        ];\\n\\n        algoData.increasePole = _steppingDirection;\\n\\n        uint256 staticMinPole = _getPoleValue(\\n            _poolMulFactor,\\n            _upperBoundMaxRate\\n        );\\n\\n        uint256 staticMaxPole = _getPoleValue(\\n            _poolMulFactor,\\n            _lowerBoundMaxRate\\n        );\\n\\n        uint256 staticDeltaPole = _getDeltaPole(\\n            staticMaxPole,\\n            staticMinPole\\n        );\\n\\n        uint256 startValuePole = _getStartValue(\\n            staticMaxPole,\\n            staticMinPole\\n        );\\n\\n        borrowRatesData[_poolToken] = BorrowRatesEntry(\\n            startValuePole,\\n            staticDeltaPole,\\n            staticMinPole,\\n            staticMaxPole,\\n            _poolMulFactor\\n        );\\n\\n        algoData.bestPole = startValuePole;\\n        algoData.maxValue = lendingPoolData[_poolToken].totalDepositShares;\\n    }\\n\\n    function setPoolParameters(\\n        address _poolToken,\\n        uint256 _collateralFactor,\\n        uint256 _maximumDeposit\\n    )\\n        external\\n        onlyMaster\\n    {\\n        if (_maximumDeposit > 0) {\\n            maxDepositValueToken[_poolToken] = _maximumDeposit;\\n        }\\n\\n        if (_collateralFactor > 0) {\\n            lendingPoolData[_poolToken].collateralFactor = _collateralFactor;\\n        }\\n\\n        if (_collateralFactor > PRECISION_FACTOR_E18) {\\n            revert InvalidAction();\\n        }\\n    }\\n\\n    /**\\n     * @dev Allow to verify isolation pool.\\n     */\\n    function setVerifiedIsolationPool(\\n        address _isolationPool,\\n        bool _state\\n    )\\n        external\\n        onlyMaster\\n    {\\n        verifiedIsolationPool[_isolationPool] = _state;\\n    }\\n\\n    function createPool(\\n        CreatePool calldata _params\\n    )\\n        external\\n        onlyMaster\\n    {\\n        _createPool(\\n            _params\\n        );\\n    }\\n\\n    function createCurvePool(\\n        CreatePool calldata _params,\\n        CurvePoolSettings calldata _settings\\n    )\\n        external\\n        onlyMaster\\n    {\\n        _createPool(\\n            _params\\n        );\\n\\n        WISE_SECURITY.prepareCurvePools(\\n            _params.poolToken,\\n            _settings.curveSecuritySwapsData,\\n            _settings.curveSecuritySwapsToken\\n        );\\n    }\\n\\n    function _createPool(\\n        CreatePool calldata _params\\n    )\\n        private\\n    {\\n        if (timestampsPoolData[_params.poolToken].timeStamp > 0) {\\n            revert InvalidAction();\\n        }\\n\\n        // Calculating lower bound for the pole\\n        uint256 staticMinPole = _getPoleValue(\\n            _params.poolMulFactor,\\n            UPPER_BOUND_MAX_RATE\\n        );\\n\\n        // Calculating upper bound for the pole\\n        uint256 staticMaxPole = _getPoleValue(\\n            _params.poolMulFactor,\\n            LOWER_BOUND_MAX_RATE\\n        );\\n\\n        // Calculating fraction for algorithm step\\n        uint256 staticDeltaPole = _getDeltaPole(\\n            staticMaxPole,\\n            staticMinPole\\n        );\\n\\n        maxDepositValueToken[_params.poolToken] = _params.maxDepositAmount;\\n\\n        globalPoolData[_params.poolToken] = GlobalPoolEntry({\\n            totalPool: 0,\\n            utilization: 0,\\n            totalBareToken: 0,\\n            poolFee: 20 * PRECISION_FACTOR_E16\\n        });\\n\\n        // Setting start value as mean of min and max value\\n        uint256 startValuePole = _getStartValue(\\n            staticMaxPole,\\n            staticMinPole\\n        );\\n\\n        // Rates Pool Data\\n        borrowRatesData[_params.poolToken] = BorrowRatesEntry(\\n            startValuePole,\\n            staticDeltaPole,\\n            staticMinPole,\\n            staticMaxPole,\\n            _params.poolMulFactor\\n        );\\n\\n        // Borrow Pool Data\\n        borrowPoolData[_params.poolToken] = BorrowPoolEntry({\\n            allowBorrow: _params.allowBorrow,\\n            pseudoTotalBorrowAmount: 1,\\n            totalBorrowShares: 1,\\n            borrowRate: 0\\n        });\\n\\n        // Algorithm Pool Data\\n        algorithmData[_params.poolToken] = AlgorithmEntry({\\n            bestPole: startValuePole,\\n            maxValue: 0,\\n            previousValue: 0,\\n            increasePole: false\\n        });\\n\\n        // Lending Pool Data\\n        lendingPoolData[_params.poolToken] = LendingPoolEntry({\\n            pseudoTotalPool: 1,\\n            totalDepositShares: 1,\\n            collateralFactor: _params.poolCollFactor\\n        });\\n\\n        // Timestamp Pool Data\\n        timestampsPoolData[_params.poolToken] = TimestampsPoolEntry({\\n            timeStamp: block.timestamp,\\n            timeStampScaling: block.timestamp\\n        });\\n\\n        FEE_MANAGER.addPoolTokenAddress(\\n            _params.poolToken\\n        );\\n\\n        uint256 fetchBalance = _getBalance(\\n            _params.poolToken\\n        );\\n\\n        if (fetchBalance > 0) {\\n            _safeTransfer(\\n                _params.poolToken,\\n                master,\\n                fetchBalance\\n            );\\n        }\\n    }\\n\\n    function _getPoleValue(\\n        uint256 _poolMulFactor,\\n        uint256 _poleBoundRate\\n    )\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        return PRECISION_FACTOR_E18 / 2\\n            + (PRECISION_FACTOR_E36 / 4\\n                + _poolMulFactor\\n                    * PRECISION_FACTOR_E36\\n                    / _poleBoundRate\\n            ).sqrt();\\n    }\\n\\n    function _getDeltaPole(\\n        uint256 _maxPole,\\n        uint256 _minPole\\n    )\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        return (_maxPole - _minPole) / NORMALISATION_FACTOR;\\n    }\\n\\n    function _getStartValue(\\n        uint256 _maxPole,\\n        uint256 _minPole\\n    )\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        return (_maxPole + _minPole) / 2;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TransferHub/CallOptionalReturn.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.23;\\n\\nimport \\\"../InterfaceHub/IERC20.sol\\\";\\n\\ncontract CallOptionalReturn {\\n\\n    /**\\n     * @dev Helper function to do low-level call\\n     */\\n    function _callOptionalReturn(\\n        address token,\\n        bytes memory data\\n    )\\n        internal\\n        returns (bool call)\\n    {\\n        (\\n            bool success,\\n            bytes memory returndata\\n        ) = token.call(\\n            data\\n        );\\n\\n        bool results = returndata.length == 0 || abi.decode(\\n            returndata,\\n            (bool)\\n        );\\n\\n        if (success == false) {\\n            revert();\\n        }\\n\\n        call = success\\n            && results\\n            && token.code.length > 0;\\n    }\\n}\"\r\n    },\r\n    \"contracts/TransferHub/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.23;\\n\\nimport \\\"./CallOptionalReturn.sol\\\";\\n\\ncontract TransferHelper is CallOptionalReturn {\\n\\n    /**\\n     * @dev\\n     * Allows to execute safe transfer for a token\\n     */\\n    function _safeTransfer(\\n        address _token,\\n        address _to,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        _callOptionalReturn(\\n            _token,\\n            abi.encodeWithSelector(\\n                IERC20.transfer.selector,\\n                _to,\\n                _value\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev\\n     * Allows to execute safe transferFrom for a token\\n     */\\n    function _safeTransferFrom(\\n        address _token,\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        _callOptionalReturn(\\n            _token,\\n            abi.encodeWithSelector(\\n                IERC20.transferFrom.selector,\\n                _from,\\n                _to,\\n                _value\\n            )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/WiseCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.23;\\n\\nimport \\\"./MainHelper.sol\\\";\\nimport \\\"./TransferHub/TransferHelper.sol\\\";\\n\\nabstract contract WiseCore is MainHelper, TransferHelper {\\n\\n    /**\\n     * @dev Wrapper function combining pool\\n     * preparations for borrow and collaterals.\\n     * Bypassed when called by powerFarms or aaveHub.\\n     */\\n    function _prepareAssociatedTokens(\\n        uint256 _nftId,\\n        address _poolTokenLend,\\n        address _poolTokenBorrow\\n    )\\n        internal\\n        returns (\\n            address[] memory,\\n            address[] memory\\n        )\\n    {\\n        if (_byPassCase(msg.sender) == true) {\\n            return (\\n                new address[](0),\\n                new address[](0)\\n            );\\n        }\\n\\n        return (\\n            _preparationTokens(\\n                positionLendTokenData,\\n                _nftId,\\n                _poolTokenLend\\n            ),\\n            _preparationTokens(\\n                positionBorrowTokenData,\\n                _nftId,\\n                _poolTokenBorrow\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev Core function combining withdraw\\n     * logic and security checks.\\n     */\\n    function _coreWithdrawToken(\\n        address _caller,\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount,\\n        uint256 _shares,\\n        bool _onBehalf\\n    )\\n        internal\\n    {\\n        (\\n            address[] memory lendTokens,\\n            address[] memory borrowTokens\\n        ) = _prepareAssociatedTokens(\\n            _nftId,\\n            _poolToken,\\n            ZERO_ADDRESS\\n        );\\n\\n        WISE_SECURITY.checksWithdraw(\\n            _nftId,\\n            _caller,\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _coreWithdrawBare(\\n            _nftId,\\n            _poolToken,\\n            _amount,\\n            _shares\\n        );\\n\\n        if (_onBehalf == true) {\\n            emit FundsWithdrawnOnBehalf(\\n                _caller,\\n                _nftId,\\n                _poolToken,\\n                _amount,\\n                _shares,\\n                block.timestamp\\n            );\\n        } else {\\n            emit FundsWithdrawn(\\n                _caller,\\n                _nftId,\\n                _poolToken,\\n                _amount,\\n                _shares,\\n                block.timestamp\\n            );\\n        }\\n\\n        _curveSecurityChecks(\\n            lendTokens,\\n            borrowTokens\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal function combining deposit\\n     * logic, security checks and event emit.\\n     */\\n    function _handleDeposit(\\n        address _caller,\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n        returns (uint256)\\n    {\\n        uint256 shareAmount = calculateLendingShares(\\n            {\\n                _poolToken: _poolToken,\\n                _amount: _amount,\\n                _maxSharePrice: false\\n            }\\n        );\\n\\n        if (shareAmount == 0) {\\n            revert ZeroSharesAssigned();\\n        }\\n\\n        _checkDeposit(\\n            _nftId,\\n            _caller,\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _increasePositionLendingDeposit(\\n            _nftId,\\n            _poolToken,\\n            shareAmount\\n        );\\n\\n        _updatePoolStorage(\\n            _poolToken,\\n            _amount,\\n            shareAmount,\\n            _increaseTotalPool,\\n            _increasePseudoTotalPool,\\n            _increaseTotalDepositShares\\n        );\\n\\n        _addPositionTokenData(\\n            _nftId,\\n            _poolToken,\\n            hashMapPositionLending,\\n            positionLendTokenData\\n        );\\n\\n        emit FundsDeposited(\\n            _caller,\\n            _nftId,\\n            _poolToken,\\n            _amount,\\n            shareAmount,\\n            block.timestamp\\n        );\\n\\n        return shareAmount;\\n    }\\n\\n    /**\\n     * @dev External wrapper for\\n     * {_checkPositionLocked}.\\n     */\\n    function checkPositionLocked(\\n        uint256 _nftId,\\n        address _caller\\n    )\\n        external\\n        view\\n    {\\n        _checkPositionLocked(\\n            _nftId,\\n            _caller\\n        );\\n    }\\n\\n    /**\\n     * @dev Checks if a postion is locked\\n     * for powerFarms. Get skipped when\\n     * aaveHub or a powerFarm itself is\\n     * the {msg.sender}.\\n     */\\n    function _checkPositionLocked(\\n        uint256 _nftId,\\n        address _caller\\n    )\\n        internal\\n        view\\n    {\\n        if (_byPassCase(_caller) == true) {\\n            return;\\n        }\\n\\n        if (positionLocked[_nftId] == false) {\\n            return;\\n        }\\n\\n        revert PositionLocked();\\n    }\\n\\n    /**\\n     * @dev External wrapper for\\n     * {_checkDeposit}.\\n     */\\n    function checkDeposit(\\n        uint256 _nftId,\\n        address _caller,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        external\\n        view\\n    {\\n        _checkDeposit(\\n            _nftId,\\n            _caller,\\n            _poolToken,\\n            _amount\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal function including\\n     * security checks for deposit logic.\\n     */\\n    function _checkDeposit(\\n        uint256 _nftId,\\n        address _caller,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n        view\\n    {\\n        _checkPositionLocked(\\n            _nftId,\\n            _caller\\n        );\\n\\n        if (WISE_ORACLE.chainLinkIsDead(_poolToken) == true) {\\n            revert DeadOracle();\\n        }\\n\\n        _checkMaxDepositValue(\\n            _poolToken,\\n            _amount\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal function checking\\n     * if the deposit amount for the\\n     * pool token is reached.\\n     */\\n    function _checkMaxDepositValue(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n        view\\n    {\\n        bool state = maxDepositValueToken[_poolToken]\\n            < globalPoolData[_poolToken].totalBareToken\\n            + lendingPoolData[_poolToken].pseudoTotalPool\\n            + _amount;\\n\\n        if (state == true) {\\n            revert InvalidAction();\\n        }\\n    }\\n\\n    /**\\n     * @dev Low level core function combining\\n     * pure withdraw math (without security\\n     * checks).\\n     */\\n    function _coreWithdrawBare(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount,\\n        uint256 _shares\\n    )\\n        private\\n    {\\n        _updatePoolStorage(\\n            _poolToken,\\n            _amount,\\n            _shares,\\n            _decreaseTotalPool,\\n            _decreasePseudoTotalPool,\\n            _decreaseTotalDepositShares\\n        );\\n\\n        _decreaseLendingShares(\\n            _nftId,\\n            _poolToken,\\n            _shares\\n        );\\n\\n        _removeEmptyLendingData(\\n            _nftId,\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev Core function combining borrow\\n     * logic with security checks.\\n     */\\n    function _coreBorrowTokens(\\n        address _caller,\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount,\\n        uint256 _shares,\\n        bool _onBehalf\\n    )\\n        internal\\n    {\\n        (\\n            address[] memory lendTokens,\\n            address[] memory borrowTokens\\n        ) = _prepareAssociatedTokens(\\n            _nftId,\\n            ZERO_ADDRESS,\\n            _poolToken\\n        );\\n\\n        WISE_SECURITY.checksBorrow(\\n            _nftId,\\n            _caller,\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _updatePoolStorage(\\n            _poolToken,\\n            _amount,\\n            _shares,\\n            _increasePseudoTotalBorrowAmount,\\n            _decreaseTotalPool,\\n            _increaseTotalBorrowShares\\n        );\\n\\n        _increaseMappingValue(\\n            userBorrowShares,\\n            _nftId,\\n            _poolToken,\\n            _shares\\n        );\\n\\n        _addPositionTokenData(\\n            _nftId,\\n            _poolToken,\\n            hashMapPositionBorrow,\\n            positionBorrowTokenData\\n        );\\n\\n        if (_onBehalf == true) {\\n            emit FundsBorrowedOnBehalf(\\n                _caller,\\n                _nftId,\\n                _poolToken,\\n                _amount,\\n                _shares,\\n                block.timestamp\\n            );\\n        } else {\\n            emit FundsBorrowed(\\n                _caller,\\n                _nftId,\\n                _poolToken,\\n                _amount,\\n                _shares,\\n                block.timestamp\\n            );\\n        }\\n\\n        _curveSecurityChecks(\\n            lendTokens,\\n            borrowTokens\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal math function for liquidation logic\\n     * caluclating amount to withdraw from pure\\n     * collateral for liquidation.\\n     */\\n    function _withdrawPureCollateralLiquidation(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _percentLiquidation\\n    )\\n        private\\n        returns (uint256 transferAmount)\\n    {\\n        transferAmount = _percentLiquidation\\n            * pureCollateralAmount[_nftId][_poolToken]\\n            / PRECISION_FACTOR_E18;\\n\\n        _decreasePositionMappingValue(\\n            pureCollateralAmount,\\n            _nftId,\\n            _poolToken,\\n            transferAmount\\n        );\\n\\n        _decreaseTotalBareToken(\\n            _poolToken,\\n            transferAmount\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal math function for liquidation logic\\n     * which checks if pool has enough token to pay out\\n     * liquidator. If not, liquidator get corresponding\\n     * shares for later withdraw.\\n     */\\n    function _withdrawOrAllocateSharesLiquidation(\\n        uint256 _nftId,\\n        uint256 _nftIdLiquidator,\\n        address _poolToken,\\n        uint256 _percentWishCollateral\\n    )\\n        private\\n        returns (uint256)\\n    {\\n        uint256 cashoutShares = _percentWishCollateral\\n            * userLendingData[_nftId][_poolToken].shares\\n            / PRECISION_FACTOR_E18;\\n\\n        uint256 withdrawAmount = cashoutAmount(\\n            _poolToken,\\n            cashoutShares\\n        );\\n\\n        uint256 totalPoolToken = globalPoolData[_poolToken].totalPool;\\n\\n        if (withdrawAmount <= totalPoolToken) {\\n\\n            _coreWithdrawBare(\\n                _nftId,\\n                _poolToken,\\n                withdrawAmount,\\n                cashoutShares\\n            );\\n\\n            return withdrawAmount;\\n        }\\n\\n        uint256 totalPoolInShares = calculateLendingShares(\\n            {\\n                _poolToken: _poolToken,\\n                _amount: totalPoolToken,\\n                _maxSharePrice: true\\n            }\\n        );\\n\\n        uint256 shareDifference = cashoutShares\\n            - totalPoolInShares;\\n\\n        _coreWithdrawBare(\\n            _nftId,\\n            _poolToken,\\n            totalPoolToken,\\n            totalPoolInShares\\n        );\\n\\n        _decreaseLendingShares(\\n            _nftId,\\n            _poolToken,\\n            shareDifference\\n        );\\n\\n        _increasePositionLendingDeposit(\\n            _nftIdLiquidator,\\n            _poolToken,\\n            shareDifference\\n        );\\n\\n        _addPositionTokenData(\\n            _nftId,\\n            _poolToken,\\n            hashMapPositionLending,\\n            positionLendTokenData\\n        );\\n\\n        return totalPoolToken;\\n    }\\n\\n    /**\\n     * @dev Internal math function combining functionallity\\n     * of {_withdrawPureCollateralLiquidation} and\\n     * {_withdrawOrAllocateSharesLiquidation}.\\n     */\\n    function _calculateReceiveAmount(\\n        uint256 _nftId,\\n        uint256 _nftIdLiquidator,\\n        address _receiveTokens,\\n        uint256 _removePercentage\\n    )\\n        private\\n        returns (uint256)\\n    {\\n        uint256 receiveAmount = _withdrawPureCollateralLiquidation(\\n            _nftId,\\n            _receiveTokens,\\n            _removePercentage\\n        );\\n\\n        if (userLendingData[_nftId][_receiveTokens].unCollateralized == true) {\\n            return receiveAmount;\\n        }\\n\\n        return _withdrawOrAllocateSharesLiquidation(\\n            _nftId,\\n            _nftIdLiquidator,\\n            _receiveTokens,\\n            _removePercentage\\n        ) + receiveAmount;\\n    }\\n\\n    /**\\n     * @dev Core liquidation function for\\n     * security checks and liquidation math.\\n     */\\n    function _coreLiquidation(\\n        CoreLiquidationStruct memory _data\\n    )\\n        internal\\n        returns (uint256 receiveAmount)\\n    {\\n        uint256 collateralPercentage = WISE_SECURITY.calculateWishPercentage(\\n            _data.nftId,\\n            _data.tokenToRecieve,\\n            WISE_ORACLE.getTokensInETH(\\n                _data.tokenToPayback,\\n                _data.paybackAmount\\n            ),\\n            _data.maxFeeETH,\\n            _data.baseRewardLiquidation\\n        );\\n\\n        if (collateralPercentage > PRECISION_FACTOR_E18) {\\n            revert CollateralTooSmall();\\n        }\\n\\n        _corePayback(\\n            _data.nftId,\\n            _data.tokenToPayback,\\n            _data.paybackAmount,\\n            _data.shareAmountToPay\\n        );\\n\\n        receiveAmount = _calculateReceiveAmount(\\n            _data.nftId,\\n            _data.nftIdLiquidator,\\n            _data.tokenToRecieve,\\n            collateralPercentage\\n        );\\n\\n        WISE_SECURITY.checkBadDebt(\\n            _data.nftId\\n        );\\n\\n        _curveSecurityChecks(\\n            _data.lendTokens,\\n            _data.borrowTokens\\n        );\\n\\n        _safeTransferFrom(\\n            _data.tokenToPayback,\\n            _data.caller,\\n            address(this),\\n            _data.paybackAmount\\n        );\\n\\n        _safeTransfer(\\n            _data.tokenToRecieve,\\n            _data.receiver,\\n            receiveAmount\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/WiseLending.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.23;\\n\\n/**\\n * @author Ren\u00e9 Hochmuth\\n * @author Christoph Krpoun\\n * @author Vitally Marinchenko\\n */\\n\\nimport \\\"./PoolManager.sol\\\";\\n\\n/**\\n * @dev WISE lending is an automated lending platform on which users can collateralize\\n * their assets and borrow tokens against them.\\n *\\n * Users need to pay borrow rates for debt tokens, which are reflected in a borrow APY for\\n * each asset type (pool). This borrow rate is variable over time and determined through the\\n * utilization of the pool. The bounding curve is a family of different bonding curves adjusted\\n * automatically by LASA (Lending Automated Scaling Algorithm). For more information, see:\\n * [https://wisesoft.gitbook.io/wise/wise-lending-protocol/lasa-ai]\\n *\\n * In addition to normal deposit, withdraw, borrow, and payback functions, there are other\\n * interacting modes:\\n *\\n * - Solely deposit and withdraw allows the user to keep their funds private, enabling\\n *    them to withdraw even when the pools are borrowed empty.\\n *\\n * - Aave pools  allow for maximal capital efficiency by earning aave supply APY for not\\n *   borrowed funds.\\n *\\n * - Special curve pools nside beefy farms can be used as collateral, opening up new usage\\n *   possibilities for these asset types.\\n *\\n * - Users can pay back their borrow with lending shares of the same asset type, making it\\n *   easier to manage their positions.\\n *\\n * - Users save their collaterals and borrows inside a position NFT, making it possible\\n *   to trade their whole positions or use them in second-layer contracts\\n *   (e.g., spot trading with PTP NFT trading platforms).\\n */\\n\\ncontract WiseLending is PoolManager {\\n\\n    /**\\n     * @dev Standard receive functions forwarding\\n     * directly send ETH to the master address.\\n     */\\n    receive()\\n        external\\n        payable\\n    {\\n        if (msg.sender == WETH_ADDRESS) {\\n            return;\\n        }\\n\\n        _sendValue(\\n            master,\\n            msg.value\\n        );\\n    }\\n\\n    /**\\n     * @dev Runs the LASA algorithm known as\\n     * Lending Automated Scaling Algorithm\\n     * and updates pool data based on token\\n     */\\n    modifier syncPool(\\n        address _poolToken\\n    ) {\\n        _syncPoolBeforeCodeExecution(\\n            _poolToken\\n        );\\n\\n        (\\n            uint256 lendSharePrice,\\n            uint256 borrowSharePrice\\n        ) = _getSharePrice(\\n            _poolToken\\n        );\\n\\n        _;\\n\\n        _syncPoolAfterCodeExecution(\\n            _poolToken,\\n            lendSharePrice,\\n            borrowSharePrice\\n        );\\n    }\\n\\n    constructor(\\n        address _master,\\n        address _wiseOracleHubAddress,\\n        address _nftContract\\n    )\\n        WiseLendingDeclaration(\\n            _master,\\n            _wiseOracleHubAddress,\\n            _nftContract\\n        )\\n    {}\\n\\n    /**\\n    * @dev Transfers tokens to master which were sent to contract where pools exist\\n    * @param _poolToken Address of the pool token.\\n    * @return Amount of tokens skimmed.\\n    */\\n    function skim(\\n        address _poolToken\\n    )\\n        external\\n        syncPool(_poolToken)\\n        returns (uint256)\\n    {\\n        uint256 amountContract = _getBalance(\\n            _poolToken\\n        );\\n\\n        uint256 insidePool = globalPoolData[_poolToken].totalPool\\n            + globalPoolData[_poolToken].totalBareToken;\\n\\n        if (amountContract > insidePool) {\\n\\n            uint256 difference = amountContract\\n                - insidePool;\\n\\n            uint256 allowedDifference = _getAllowedDifference(\\n                _poolToken\\n            );\\n\\n            if (difference > allowedDifference) {\\n                uint256 amountToSend = difference\\n                    - allowedDifference;\\n\\n                _safeTransfer(\\n                    _poolToken,\\n                    master,\\n                    amountToSend\\n                );\\n\\n                return amountToSend;\\n            }\\n        }\\n\\n        revert InvalidAction();\\n    }\\n\\n    function _emitFundsSolelyWithdrawn(\\n        address _caller,\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        private\\n    {\\n        emit FundsSolelyWithdrawn(\\n            _caller,\\n            _nftId,\\n            _poolToken,\\n            _amount,\\n            block.timestamp\\n        );\\n    }\\n\\n    function _emitFundsSolelyDeposited(\\n        address _caller,\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        private\\n    {\\n        emit FundsSolelyDeposited(\\n            _caller,\\n            _nftId,\\n            _poolToken,\\n            _amount,\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev Fetches share price of lending shares.\\n     */\\n    function _getSharePrice(\\n        address _poolToken\\n    )\\n        private\\n        view\\n        returns (\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return (\\n            lendingPoolData[_poolToken].pseudoTotalPool\\n                * PRECISION_FACTOR_E18\\n                / lendingPoolData[_poolToken].totalDepositShares,\\n            borrowPoolData[_poolToken].pseudoTotalBorrowAmount\\n                * PRECISION_FACTOR_E18\\n                / borrowPoolData[_poolToken].totalBorrowShares\\n        );\\n    }\\n\\n    /**\\n     * @dev Compares share prices before and after\\n     * execution. If borrow share price increased\\n     * or lending share price decreased, revert.\\n     */\\n    function _compareSharePrice(\\n        address _poolToken,\\n        uint256 _lendSharePriceBefore,\\n        uint256 _borrowSharePriceBefore\\n    )\\n        private\\n        view\\n    {\\n        (\\n            uint256 lendSharePriceAfter,\\n            uint256 borrowSharePriceAfter\\n        ) = _getSharePrice(_poolToken);\\n\\n        if (lendSharePriceAfter < _lendSharePriceBefore) {\\n            revert SharePriceDecreased();\\n        }\\n\\n        if (borrowSharePriceAfter > _borrowSharePriceBefore) {\\n            revert SharePriceIncreased();\\n        }\\n    }\\n\\n    /**\\n     * @dev First part of pool sync updating pseudo\\n     * amounts. Is skipped when powerFarms or aaveHub\\n     * is calling the function.\\n     */\\n    function _syncPoolBeforeCodeExecution(\\n        address _poolToken\\n    )\\n        private\\n    {\\n        _checkReentrancy();\\n\\n        if (_byPassCase(msg.sender) == true) {\\n            return;\\n        }\\n\\n        _preparePool(\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev Second part of pool sync updating\\n     * the borrow pool rate and share price.\\n     */\\n    function _syncPoolAfterCodeExecution(\\n        address _poolToken,\\n        uint256 _lendSharePriceBefore,\\n        uint256 _borrowSharePriceBefore\\n    )\\n        private\\n    {\\n        _newBorrowRate(\\n            _poolToken\\n        );\\n\\n        _compareSharePrice(\\n            _poolToken,\\n            _lendSharePriceBefore,\\n            _borrowSharePriceBefore\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows to give permission for onBehalf function\\n     * execution, allowing 3rd party to perform actions such as\\n     * borrowOnBehalf and withdrawOnBehalf with amount limit\\n     */\\n    function approve(\\n        address _spender,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        external\\n        syncPool(_poolToken)\\n    {\\n        allowance[msg.sender][_poolToken][_spender] = _amount;\\n    }\\n\\n    /**\\n     * @dev Enables _poolToken to be used as a collateral.\\n     */\\n    function collateralizeDeposit(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        external\\n        syncPool(_poolToken)\\n    {\\n        WISE_SECURITY.checksCollateralizeDeposit(\\n            _nftId,\\n            msg.sender,\\n            _poolToken\\n        );\\n\\n        userLendingData[_nftId][_poolToken].unCollateralized = false;\\n    }\\n\\n    /**\\n     * @dev Disables _poolToken to be used as a collateral.\\n     */\\n    function unCollateralizeDeposit(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        external\\n        syncPool(_poolToken)\\n    {\\n        _checkOwnerPosition(\\n            _nftId,\\n            msg.sender\\n        );\\n\\n        _prepareAssociatedTokens(\\n            _nftId,\\n            _poolToken,\\n            ZERO_ADDRESS\\n        );\\n\\n        userLendingData[_nftId][_poolToken].unCollateralized = true;\\n\\n        WISE_SECURITY.checkUncollateralizedDeposit(\\n            _nftId,\\n            _poolToken\\n        );\\n    }\\n\\n    // --------------- Deposit Functions -------------\\n\\n    /**\\n     * @dev Allows to supply funds using ETH.\\n     * Without converting to WETH, use ETH directly.\\n     */\\n    function depositExactAmountETH(\\n        uint256 _nftId\\n    )\\n        external\\n        payable\\n        syncPool(WETH_ADDRESS)\\n        returns (uint256)\\n    {\\n        return _depositExactAmountETH(\\n            _nftId\\n        );\\n    }\\n\\n    function _depositExactAmountETH(\\n        uint256 _nftId\\n    )\\n        internal\\n        returns (uint256)\\n    {\\n        uint256 shareAmount = _handleDeposit(\\n            msg.sender,\\n            _nftId,\\n            WETH_ADDRESS,\\n            msg.value\\n        );\\n\\n        _wrapETH(\\n            msg.value\\n        );\\n\\n        return shareAmount;\\n    }\\n\\n    /**\\n     * @dev Allows to supply funds using ETH.\\n     * Without converting to WETH, use ETH directly,\\n     * also mints position to avoid extra transaction.\\n     */\\n    function depositExactAmountETHMint()\\n        external\\n        payable\\n        returns (uint256)\\n    {\\n        return _depositExactAmountETH(\\n            _reservePosition()\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows to supply _poolToken and user\\n     * can decide if _poolToken should be collateralized,\\n     * also mints position to avoid extra transaction.\\n     */\\n    function depositExactAmountMint(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        external\\n        returns (uint256)\\n    {\\n        return depositExactAmount(\\n            _reservePosition(),\\n            _poolToken,\\n            _amount\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows to supply _poolToken and user\\n     * can decide if _poolToken should be collateralized.\\n     */\\n    function depositExactAmount(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        public\\n        syncPool(_poolToken)\\n        returns (uint256)\\n    {\\n        uint256 shareAmount = _handleDeposit(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _safeTransferFrom(\\n            _poolToken,\\n            msg.sender,\\n            address(this),\\n            _amount\\n        );\\n\\n        return shareAmount;\\n    }\\n\\n    /**\\n     * @dev Allows to supply funds using ETH in solely mode,\\n     * which does not earn APY, but keeps the funds private.\\n     * Other users are restricted from borrowing these funds,\\n     * owner can always withdraw even if all funds are borrowed.\\n     * Also mints position to avoid extra transaction.\\n     */\\n    function solelyDepositETHMint()\\n        external\\n        payable\\n    {\\n        solelyDepositETH(\\n            _reservePosition()\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows to supply funds using ETH in solely mode,\\n     * which does not earn APY, but keeps the funds private.\\n     * Other users are restricted from borrowing these funds,\\n     * owner can always withdraw even if all funds are borrowed.\\n     */\\n    function solelyDepositETH(\\n        uint256 _nftId\\n    )\\n        public\\n        payable\\n        syncPool(WETH_ADDRESS)\\n    {\\n        _handleSolelyDeposit(\\n            msg.sender,\\n            _nftId,\\n            WETH_ADDRESS,\\n            msg.value\\n        );\\n\\n        _wrapETH(\\n            msg.value\\n        );\\n\\n        _emitFundsSolelyDeposited(\\n            msg.sender,\\n            _nftId,\\n            WETH_ADDRESS,\\n            msg.value\\n        );\\n    }\\n\\n    /**\\n     * @dev Core function combining\\n     * supply logic with security\\n     * checks for solely deposit.\\n     */\\n    function _handleSolelyDeposit(\\n        address _caller,\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        private\\n    {\\n        _checkDeposit(\\n            _nftId,\\n            _caller,\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _increaseMappingValue(\\n            pureCollateralAmount,\\n            _nftId,\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _increaseTotalBareToken(\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _addPositionTokenData(\\n            _nftId,\\n            _poolToken,\\n            hashMapPositionLending,\\n            positionLendTokenData\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows to supply funds using ERC20 in solely mode,\\n     * which does not earn APY, but keeps the funds private.\\n     * Other users are restricted from borrowing these funds,\\n     * owner can always withdraw even if all funds are borrowed.\\n     * Also mints position to avoid extra transaction.\\n     */\\n    function solelyDepositMint(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        external\\n    {\\n        solelyDeposit(\\n            _reservePosition(),\\n            _poolToken,\\n            _amount\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows to supply funds using ERC20 in solely mode,\\n     * which does not earn APY, but keeps the funds private.\\n     * Other users are restricted from borrowing these funds,\\n     * owner can always withdraw even if all funds are borrowed.\\n     */\\n    function solelyDeposit(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        public\\n        syncPool(_poolToken)\\n    {\\n        _handleSolelyDeposit(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _emitFundsSolelyDeposited(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _safeTransferFrom(\\n            _poolToken,\\n            msg.sender,\\n            address(this),\\n            _amount\\n        );\\n    }\\n\\n    // --------------- Withdraw Functions -------------\\n\\n    /**\\n     * @dev Allows to withdraw publicly\\n     * deposited ETH funds using exact amount.\\n     */\\n    function withdrawExactAmountETH(\\n        uint256 _nftId,\\n        uint256 _amount\\n    )\\n        external\\n        syncPool(WETH_ADDRESS)\\n        returns (uint256)\\n    {\\n        uint256 withdrawShares = _preparationsWithdraw(\\n            _nftId,\\n            msg.sender,\\n            WETH_ADDRESS,\\n            _amount\\n        );\\n\\n        _coreWithdrawToken(\\n            {\\n                _caller: msg.sender,\\n                _nftId: _nftId,\\n                _poolToken: WETH_ADDRESS,\\n                _amount: _amount,\\n                _shares: withdrawShares,\\n                _onBehalf: false\\n            }\\n        );\\n\\n        _unwrapETH(\\n            _amount\\n        );\\n\\n        _sendValue(\\n            msg.sender,\\n            _amount\\n        );\\n\\n        return withdrawShares;\\n    }\\n\\n    /**\\n     * @dev Allows to withdraw publicly\\n     * deposited ETH funds using exact shares.\\n     */\\n    function withdrawExactSharesETH(\\n        uint256 _nftId,\\n        uint256 _shares\\n    )\\n        external\\n        syncPool(WETH_ADDRESS)\\n        returns (uint256)\\n    {\\n        _checkOwnerPosition(\\n            _nftId,\\n            msg.sender\\n        );\\n\\n        uint256 withdrawAmount = cashoutAmount(\\n            WETH_ADDRESS,\\n            _shares\\n        );\\n\\n        _coreWithdrawToken(\\n            {\\n                _caller: msg.sender,\\n                _nftId: _nftId,\\n                _poolToken: WETH_ADDRESS,\\n                _amount: withdrawAmount,\\n                _shares: _shares,\\n                _onBehalf: false\\n            }\\n        );\\n\\n        _unwrapETH(\\n            withdrawAmount\\n        );\\n\\n        _sendValue(\\n            msg.sender,\\n            withdrawAmount\\n        );\\n\\n        return withdrawAmount;\\n    }\\n\\n    /**\\n     * @dev Allows to withdraw publicly\\n     * deposited ERC20 funds using exact amount.\\n     */\\n    function withdrawExactAmount(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _withdrawAmount\\n    )\\n        external\\n        syncPool(_poolToken)\\n        returns (uint256)\\n    {\\n        uint256 withdrawShares = _preparationsWithdraw(\\n            _nftId,\\n            msg.sender,\\n            _poolToken,\\n            _withdrawAmount\\n        );\\n\\n        _coreWithdrawToken(\\n            {\\n                _caller: msg.sender,\\n                _nftId: _nftId,\\n                _poolToken: _poolToken,\\n                _amount: _withdrawAmount,\\n                _shares: withdrawShares,\\n                _onBehalf: false\\n            }\\n        );\\n\\n        _safeTransfer(\\n            _poolToken,\\n            msg.sender,\\n            _withdrawAmount\\n        );\\n\\n        return withdrawShares;\\n    }\\n\\n    /**\\n     * @dev Allows to withdraw privately\\n     * deposited ETH funds using input amount.\\n     */\\n    function solelyWithdrawETH(\\n        uint256 _nftId,\\n        uint256 withdrawAmount\\n    )\\n        external\\n        syncPool(WETH_ADDRESS)\\n    {\\n        _checkOwnerPosition(\\n            _nftId,\\n            msg.sender\\n        );\\n\\n        _coreSolelyWithdraw(\\n            msg.sender,\\n            _nftId,\\n            WETH_ADDRESS,\\n            withdrawAmount\\n        );\\n\\n        _unwrapETH(\\n            withdrawAmount\\n        );\\n\\n        _emitFundsSolelyWithdrawn(\\n            msg.sender,\\n            _nftId,\\n            WETH_ADDRESS,\\n            withdrawAmount\\n        );\\n\\n        _sendValue(\\n            msg.sender,\\n            withdrawAmount\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows to withdraw privately\\n     * deposited ERC20 funds using input amount.\\n     */\\n    function solelyWithdraw(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _withdrawAmount\\n    )\\n        external\\n        syncPool(_poolToken)\\n    {\\n        _checkOwnerPosition(\\n            _nftId,\\n            msg.sender\\n        );\\n\\n        _coreSolelyWithdraw(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _withdrawAmount\\n        );\\n\\n        _emitFundsSolelyWithdrawn(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _withdrawAmount\\n        );\\n\\n        _safeTransfer(\\n            _poolToken,\\n            msg.sender,\\n            _withdrawAmount\\n        );\\n    }\\n\\n    /**\\n     * @dev Core function combining\\n     * withdraw logic for solely\\n     * withdraw with security checks.\\n     */\\n    function _coreSolelyWithdraw(\\n        address _caller,\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        private\\n    {\\n        WISE_SECURITY.checksSolelyWithdraw(\\n            _nftId,\\n            _caller,\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _decreasePositionMappingValue(\\n            pureCollateralAmount,\\n            _nftId,\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _decreaseTotalBareToken(\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _removeEmptyLendingData(\\n            _nftId,\\n            _poolToken\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows to withdraw privately\\n     * deposited ERC20 on behalf of owner.\\n     * Requires approval by _nftId owner.\\n     */\\n    function solelyWithdrawOnBehalf(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _withdrawAmount\\n    )\\n        external\\n        onlyWhiteList\\n        syncPool(_poolToken)\\n    {\\n        _reduceAllowance(\\n            _nftId,\\n            _poolToken,\\n            msg.sender,\\n            _withdrawAmount\\n        );\\n\\n        _coreSolelyWithdraw(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _withdrawAmount\\n        );\\n\\n        emit FundsSolelyWithdrawnOnBehalf(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _withdrawAmount,\\n            block.timestamp\\n        );\\n\\n        _safeTransfer(\\n            _poolToken,\\n            msg.sender,\\n            _withdrawAmount\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows to withdraw privately\\n     * deposited ERC20 on behalf of owner.\\n     * Requires approval by _nftId owner.\\n     */\\n    function withdrawOnBehalfExactAmount(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _withdrawAmount\\n    )\\n        external\\n        onlyWhiteList\\n        syncPool(_poolToken)\\n        returns (uint256)\\n    {\\n        _reduceAllowance(\\n            _nftId,\\n            _poolToken,\\n            msg.sender,\\n            _withdrawAmount\\n        );\\n\\n        uint256 withdrawShares = calculateLendingShares(\\n            {\\n                _poolToken: _poolToken,\\n                _amount: _withdrawAmount,\\n                _maxSharePrice: true\\n            }\\n        );\\n\\n        _coreWithdrawToken(\\n            {\\n                _caller: msg.sender,\\n                _nftId: _nftId,\\n                _poolToken: _poolToken,\\n                _amount: _withdrawAmount,\\n                _shares: withdrawShares,\\n                _onBehalf: true\\n            }\\n        );\\n\\n        _safeTransfer(\\n            _poolToken,\\n            msg.sender,\\n            _withdrawAmount\\n        );\\n\\n        return withdrawShares;\\n    }\\n\\n    function _reduceAllowance(\\n        uint256 _nftId,\\n        address _poolToken,\\n        address _spender,\\n        uint256 _amount\\n    )\\n        private\\n    {\\n        if (POSITION_NFT.getApproved(_nftId) == _spender) {\\n            return;\\n        }\\n\\n        address owner = POSITION_NFT.ownerOf(\\n            _nftId\\n        );\\n\\n        if (allowance[owner][_poolToken][_spender] != type(uint256).max) {\\n            allowance[owner][_poolToken][_spender] -= _amount;\\n        }\\n    }\\n\\n    /**\\n     * @dev Allows to withdraw ERC20\\n     * funds using shares as input value\\n     */\\n    function withdrawExactShares(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _shares\\n    )\\n        external\\n        syncPool(_poolToken)\\n        returns (uint256)\\n    {\\n        _checkOwnerPosition(\\n            _nftId,\\n            msg.sender\\n        );\\n\\n        uint256 withdrawAmount = cashoutAmount(\\n            _poolToken,\\n            _shares\\n        );\\n\\n        _coreWithdrawToken(\\n            {\\n                _caller: msg.sender,\\n                _nftId: _nftId,\\n                _poolToken: _poolToken,\\n                _amount: withdrawAmount,\\n                _shares: _shares,\\n                _onBehalf: false\\n            }\\n        );\\n\\n        _safeTransfer(\\n            _poolToken,\\n            msg.sender,\\n            withdrawAmount\\n        );\\n\\n        return withdrawAmount;\\n    }\\n\\n    /**\\n     * @dev Withdraws ERC20 funds on behalf\\n     * of _nftId owner, requires approval.\\n     */\\n    function withdrawOnBehalfExactShares(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _shares\\n    )\\n        external\\n        onlyWhiteList\\n        syncPool(_poolToken)\\n        returns (uint256)\\n    {\\n        uint256 withdrawAmount = cashoutAmount(\\n            _poolToken,\\n            _shares\\n        );\\n\\n        _reduceAllowance(\\n            _nftId,\\n            _poolToken,\\n            msg.sender,\\n            withdrawAmount\\n        );\\n\\n        _coreWithdrawToken(\\n            {\\n                _caller: msg.sender,\\n                _nftId: _nftId,\\n                _poolToken: _poolToken,\\n                _amount: withdrawAmount,\\n                _shares: _shares,\\n                _onBehalf: true\\n            }\\n        );\\n\\n        _safeTransfer(\\n            _poolToken,\\n            msg.sender,\\n            withdrawAmount\\n        );\\n\\n        return withdrawAmount;\\n    }\\n\\n    // --------------- Borrow Functions -------------\\n\\n    /**\\n     * @dev Allows to borrow ETH funds\\n     * Requires user to have collateral.\\n     */\\n    function borrowExactAmountETH(\\n        uint256 _nftId,\\n        uint256 _amount\\n    )\\n        external\\n        syncPool(WETH_ADDRESS)\\n        returns (uint256)\\n    {\\n        _checkOwnerPosition(\\n            _nftId,\\n            msg.sender\\n        );\\n\\n        uint256 shares = calculateBorrowShares(\\n            {\\n                _poolToken: WETH_ADDRESS,\\n                _amount: _amount,\\n                _maxSharePrice: true\\n            }\\n        );\\n\\n        _coreBorrowTokens(\\n            {\\n                _caller: msg.sender,\\n                _nftId: _nftId,\\n                _poolToken: WETH_ADDRESS,\\n                _amount: _amount,\\n                _shares: shares,\\n                _onBehalf: false\\n            }\\n        );\\n\\n        _unwrapETH(\\n            _amount\\n        );\\n\\n        _sendValue(\\n            msg.sender,\\n            _amount\\n        );\\n\\n        return shares;\\n    }\\n\\n    /**\\n     * @dev Allows to borrow ERC20 funds\\n     * Requires user to have collateral.\\n     */\\n    function borrowExactAmount(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        external\\n        syncPool(_poolToken)\\n        returns (uint256)\\n    {\\n        _checkOwnerPosition(\\n            _nftId,\\n            msg.sender\\n        );\\n\\n        uint256 shares = calculateBorrowShares(\\n            {\\n                _poolToken: _poolToken,\\n                _amount: _amount,\\n                _maxSharePrice: true\\n            }\\n        );\\n\\n        _coreBorrowTokens(\\n            {\\n                _caller: msg.sender,\\n                _nftId: _nftId,\\n                _poolToken: _poolToken,\\n                _amount: _amount,\\n                _shares: shares,\\n                _onBehalf: false\\n            }\\n        );\\n\\n        _safeTransfer(\\n            _poolToken,\\n            msg.sender,\\n            _amount\\n        );\\n\\n        return shares;\\n    }\\n\\n    /**\\n     * @dev Allows to borrow ERC20 funds\\n     * on behalf of _nftId owner, if approved.\\n     */\\n    function borrowOnBehalfExactAmount(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        external\\n        onlyWhiteList\\n        syncPool(_poolToken)\\n        returns (uint256)\\n    {\\n        _reduceAllowance(\\n            _nftId,\\n            _poolToken,\\n            msg.sender,\\n            _amount\\n        );\\n\\n        uint256 shares = calculateBorrowShares(\\n            {\\n                _poolToken: _poolToken,\\n                _amount: _amount,\\n                _maxSharePrice: true\\n            }\\n        );\\n\\n        _coreBorrowTokens(\\n            {\\n                _caller: msg.sender,\\n                _nftId: _nftId,\\n                _poolToken: _poolToken,\\n                _amount: _amount,\\n                _shares: shares,\\n                _onBehalf: true\\n            }\\n        );\\n\\n        _safeTransfer(\\n            _poolToken,\\n            msg.sender,\\n            _amount\\n        );\\n\\n        return shares;\\n    }\\n\\n    // --------------- Payback Functions ------------\\n\\n    /**\\n     * @dev Ability to payback ETH loans\\n     * by providing exact payback amount.\\n     */\\n    function paybackExactAmountETH(\\n        uint256 _nftId\\n    )\\n        external\\n        payable\\n        syncPool(WETH_ADDRESS)\\n        returns (uint256)\\n    {\\n        _checkPositionLocked(\\n            _nftId,\\n            msg.sender\\n        );\\n\\n        uint256 maxBorrowShares = userBorrowShares[_nftId][WETH_ADDRESS];\\n\\n        uint256 maxPaybackAmount = paybackAmount(\\n            WETH_ADDRESS,\\n            maxBorrowShares\\n        );\\n\\n        uint256 paybackShares = calculateBorrowShares(\\n            {\\n                _poolToken: WETH_ADDRESS,\\n                _amount: msg.value,\\n                _maxSharePrice: false\\n            }\\n        );\\n\\n        uint256 refundAmount;\\n        uint256 requiredAmount = msg.value;\\n\\n        if (msg.value > maxPaybackAmount) {\\n\\n            unchecked {\\n                refundAmount = msg.value\\n                    - maxPaybackAmount;\\n            }\\n\\n            requiredAmount = requiredAmount\\n                - refundAmount;\\n\\n            paybackShares = maxBorrowShares;\\n        }\\n\\n        _handlePayback(\\n            msg.sender,\\n            _nftId,\\n            WETH_ADDRESS,\\n            requiredAmount,\\n            paybackShares\\n        );\\n\\n        _wrapETH(\\n            requiredAmount\\n        );\\n\\n        if (refundAmount > 0) {\\n            _sendValue(\\n                msg.sender,\\n                refundAmount\\n            );\\n        }\\n\\n        return paybackShares;\\n    }\\n\\n    /**\\n     * @dev Ability to payback ERC20 loans\\n     * by providing exact payback amount.\\n     */\\n    function paybackExactAmount(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        external\\n        syncPool(_poolToken)\\n        returns (uint256)\\n    {\\n        _checkPositionLocked(\\n            _nftId,\\n            msg.sender\\n        );\\n\\n        uint256 paybackShares = calculateBorrowShares(\\n            {\\n                _poolToken: _poolToken,\\n                _amount: _amount,\\n                _maxSharePrice: false\\n            }\\n        );\\n\\n        _handlePayback(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            _amount,\\n            paybackShares\\n        );\\n\\n        _safeTransferFrom(\\n            _poolToken,\\n            msg.sender,\\n            address(this),\\n            _amount\\n        );\\n\\n        return paybackShares;\\n    }\\n\\n    /**\\n     * @dev Ability to payback ERC20 loans\\n     * by providing exact payback shares.\\n     */\\n    function paybackExactShares(\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _shares\\n    )\\n        external\\n        syncPool(_poolToken)\\n        returns (uint256)\\n    {\\n        _checkPositionLocked(\\n            _nftId,\\n            msg.sender\\n        );\\n\\n        uint256 repaymentAmount = paybackAmount(\\n            _poolToken,\\n            _shares\\n        );\\n\\n        _handlePayback(\\n            msg.sender,\\n            _nftId,\\n            _poolToken,\\n            repaymentAmount,\\n            _shares\\n        );\\n\\n        _safeTransferFrom(\\n            _poolToken,\\n            msg.sender,\\n            address(this),\\n            repaymentAmount\\n        );\\n\\n        return repaymentAmount;\\n    }\\n\\n    // --------------- Liquidation Functions ------------\\n\\n    /**\\n     * @dev Function to liquidate a postion which reaches\\n     * a debt ratio greater than 100%. The liquidator can choose\\n     * token to payback and receive. (Both can differ!). The\\n     * amount is in shares of the payback token. The liquidator\\n     * gets an incentive which is calculated inside the liquidation\\n     * logic.\\n     */\\n    function liquidatePartiallyFromTokens(\\n        uint256 _nftId,\\n        uint256 _nftIdLiquidator,\\n        address _paybackToken,\\n        address _receiveToken,\\n        uint256 _shareAmountToPay\\n    )\\n        external\\n        syncPool(_paybackToken)\\n        syncPool(_receiveToken)\\n        returns (uint256)\\n    {\\n        CoreLiquidationStruct memory data;\\n\\n        data.nftId = _nftId;\\n        data.nftIdLiquidator = _nftIdLiquidator;\\n\\n        data.caller = msg.sender;\\n        data.receiver = msg.sender;\\n\\n        data.tokenToPayback = _paybackToken;\\n        data.tokenToRecieve = _receiveToken;\\n        data.shareAmountToPay = _shareAmountToPay;\\n\\n        data.maxFeeETH = WISE_SECURITY.maxFeeETH();\\n        data.baseRewardLiquidation = WISE_SECURITY.baseRewardLiquidation();\\n\\n        (\\n            data.lendTokens,\\n            data.borrowTokens\\n        ) = _prepareAssociatedTokens(\\n            _nftId,\\n            _receiveToken,\\n            _paybackToken\\n        );\\n\\n        data.paybackAmount = paybackAmount(\\n            _paybackToken,\\n            _shareAmountToPay\\n        );\\n\\n        _checkPositionLocked(\\n            _nftId,\\n            msg.sender\\n        );\\n\\n        WISE_SECURITY.checksLiquidation(\\n            _nftId,\\n            _paybackToken,\\n            _shareAmountToPay\\n        );\\n\\n        return _coreLiquidation(\\n            data\\n        );\\n    }\\n\\n    /**\\n     * @dev Wrapper function for liqudaiton flow\\n     */\\n    function coreLiquidationIsolationPools(\\n        uint256 _nftId,\\n        uint256 _nftIdLiquidator,\\n        address _caller,\\n        address _receiver,\\n        address _paybackToken,\\n        address _receiveToken,\\n        uint256 _paybackAmount,\\n        uint256 _shareAmountToPay\\n    )\\n        external\\n        syncPool(_paybackToken)\\n        syncPool(_receiveToken)\\n        returns (uint256)\\n    {\\n        _onlyIsolationPool(\\n            msg.sender\\n        );\\n\\n        CoreLiquidationStruct memory data;\\n\\n        data.nftId = _nftId;\\n        data.nftIdLiquidator = _nftIdLiquidator;\\n\\n        data.caller = _caller;\\n        data.receiver = _receiver;\\n\\n        data.paybackAmount = _paybackAmount;\\n        data.tokenToPayback = _paybackToken;\\n        data.tokenToRecieve = _receiveToken;\\n        data.shareAmountToPay = _shareAmountToPay;\\n\\n        data.maxFeeETH = WISE_SECURITY.maxFeeFarmETH();\\n        data.baseRewardLiquidation = WISE_SECURITY.baseRewardLiquidationFarm();\\n\\n        (\\n            data.lendTokens,\\n            data.borrowTokens\\n        ) = _prepareAssociatedTokens(\\n            data.nftId,\\n            data.tokenToRecieve,\\n            data.tokenToPayback\\n        );\\n\\n        return _coreLiquidation(\\n            data\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows to sync pool manually\\n     * so that the pool is up to date.\\n     */\\n    function syncManually(\\n        address _poolToken\\n    )\\n        external\\n        syncPool(_poolToken)\\n    {\\n\\n        address[] memory tokens = new address[](1);\\n        tokens[0] = _poolToken;\\n\\n        _curveSecurityChecks(\\n            new address[](0),\\n            tokens\\n        );\\n    }\\n\\n    /**\\n     * @dev Registers position _nftId\\n     * for isolation pool functionality\\n     */\\n    function setRegistrationIsolationPool(\\n        uint256 _nftId,\\n        bool _registerState\\n    )\\n        external\\n    {\\n        _onlyIsolationPool(\\n            msg.sender\\n        );\\n\\n        positionLocked[_nftId] = _registerState;\\n    }\\n\\n    /**\\n    * @dev External wrapper for\\n    * {_corePayback} logic callable\\n    * by feeMananger.\\n    */\\n    function corePaybackFeeManager(\\n        address _poolToken,\\n        uint256 _nftId,\\n        uint256 _amount,\\n        uint256 _shares\\n    )\\n        external\\n        onlyFeeManager\\n        syncPool(_poolToken)\\n    {\\n        _corePayback(\\n            _nftId,\\n            _poolToken,\\n            _amount,\\n            _shares\\n        );\\n    }\\n\\n    /**\\n     * @dev Internal function combining payback\\n     * logic and emit of an event.\\n     */\\n    function _handlePayback(\\n        address _caller,\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount,\\n        uint256 _shares\\n    )\\n        private\\n    {\\n        _corePayback(\\n            _nftId,\\n            _poolToken,\\n            _amount,\\n            _shares\\n        );\\n\\n        emit FundsReturned(\\n            _caller,\\n            _poolToken,\\n            _nftId,\\n            _amount,\\n            _shares,\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev Wrapper for isolation pool check.\\n     */\\n    function _onlyIsolationPool(\\n        address _poolAddress\\n    )\\n        private\\n        view\\n    {\\n        if (verifiedIsolationPool[_poolAddress] == false) {\\n            revert InvalidAction();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/WiseLendingDeclaration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.23;\\n\\nimport \\\"./OwnableMaster.sol\\\";\\n\\nimport \\\"./InterfaceHub/IWETH.sol\\\";\\nimport \\\"./InterfaceHub/IAaveHubLite.sol\\\";\\nimport \\\"./InterfaceHub/IPositionNFTs.sol\\\";\\nimport \\\"./InterfaceHub/IWiseSecurity.sol\\\";\\nimport \\\"./InterfaceHub/IWiseOracleHub.sol\\\";\\nimport \\\"./InterfaceHub/IFeeManagerLight.sol\\\";\\n\\nerror DeadOracle();\\nerror InvalidAction();\\nerror InvalidCaller();\\nerror PositionLocked();\\nerror CollateralTooSmall();\\nerror ZeroSharesAssigned();\\nerror SharePriceDecreased();\\nerror SharePriceIncreased();\\n\\ncontract WiseLendingDeclaration is OwnableMaster {\\n\\n    event FundsDeposited(\\n        address indexed sender,\\n        uint256 indexed nftId,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares,\\n        uint256 timestamp\\n    );\\n\\n    event FundsSolelyDeposited(\\n        address indexed sender,\\n        uint256 indexed nftId,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 timestamp\\n    );\\n\\n    event FundsWithdrawn(\\n        address indexed sender,\\n        uint256 indexed nftId,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares,\\n        uint256 timestamp\\n    );\\n\\n    event FundsWithdrawnOnBehalf(\\n        address indexed sender,\\n        uint256 indexed nftId,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares,\\n        uint256 timestamp\\n    );\\n\\n    event FundsSolelyWithdrawn(\\n        address indexed sender,\\n        uint256 indexed nftId,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 timestamp\\n    );\\n\\n    event FundsSolelyWithdrawnOnBehalf(\\n        address indexed sender,\\n        uint256 indexed nftId,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 timestamp\\n    );\\n\\n    event FundsBorrowed(\\n        address indexed borrower,\\n        uint256 indexed nftId,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares,\\n        uint256 timestamp\\n    );\\n\\n    event FundsBorrowedOnBehalf(\\n        address indexed sender,\\n        uint256 indexed nftId,\\n        address indexed token,\\n        uint256 amount,\\n        uint256 shares,\\n        uint256 timestamp\\n    );\\n\\n    event FundsReturned(\\n        address indexed sender,\\n        address indexed token,\\n        uint256 indexed nftId,\\n        uint256 totalPayment,\\n        uint256 totalPaymentShares,\\n        uint256 timestamp\\n    );\\n\\n    constructor(\\n        address _master,\\n        address _wiseOracleHub,\\n        address _nftContract\\n    )\\n        OwnableMaster(\\n            _master\\n        )\\n    {\\n        if (_wiseOracleHub == ZERO_ADDRESS) {\\n            revert NoValue();\\n        }\\n\\n        if (_nftContract == ZERO_ADDRESS) {\\n            revert NoValue();\\n        }\\n\\n        WISE_ORACLE = IWiseOracleHub(\\n            _wiseOracleHub\\n        );\\n\\n        WETH_ADDRESS = WISE_ORACLE.WETH_ADDRESS();\\n\\n        WETH = IWETH(\\n            WETH_ADDRESS\\n        );\\n\\n        POSITION_NFT = IPositionNFTs(\\n            _nftContract\\n        );\\n\\n        FEE_MANAGER_NFT = POSITION_NFT.FEE_MANAGER_NFT();\\n    }\\n\\n    function setSecurity(\\n        address _wiseSecurity\\n    )\\n        external\\n        onlyMaster\\n    {\\n        if (address(WISE_SECURITY) > ZERO_ADDRESS) {\\n            revert InvalidAction();\\n        }\\n\\n        WISE_SECURITY = IWiseSecurity(\\n            _wiseSecurity\\n        );\\n\\n        FEE_MANAGER = IFeeManagerLight(\\n            WISE_SECURITY.FEE_MANAGER()\\n        );\\n\\n        AAVE_HUB_ADDRESS = WISE_SECURITY.AAVE_HUB();\\n\\n        whiteListOnBehalf[AAVE_HUB_ADDRESS] = true;\\n    }\\n\\n    /**\\n     * @dev Wrapper for wrapping\\n     * ETH call.\\n     */\\n    function _wrapETH(\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        WETH.deposit{\\n            value: _value\\n        }();\\n    }\\n\\n    /**\\n     * @dev Wrapper for unwrapping\\n     * ETH call.\\n     */\\n    function _unwrapETH(\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        WETH.withdraw(\\n            _value\\n        );\\n    }\\n\\n    function _sendValue(\\n        address _recipient,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        if (address(this).balance < _amount) {\\n            revert InvalidAction();\\n        }\\n\\n        sendingProgress = true;\\n\\n        (bool success, ) = payable(_recipient).call{\\n            value: _amount\\n        }(\\\"\\\");\\n\\n        sendingProgress = false;\\n\\n        if (success == false) {\\n            revert InvalidAction();\\n        }\\n    }\\n\\n    // AaveHub address\\n    address internal AAVE_HUB_ADDRESS;\\n\\n    // Wrapped ETH address\\n    address public immutable WETH_ADDRESS;\\n\\n    // Wrapped ETH interface\\n    IWETH internal immutable WETH;\\n\\n    // Nft id for feeManager\\n    uint256 immutable FEE_MANAGER_NFT;\\n\\n    // WiseSecurity interface\\n    IWiseSecurity public WISE_SECURITY;\\n\\n    // FeeManager interface\\n    IFeeManagerLight internal FEE_MANAGER;\\n\\n    // NFT contract interface for positions\\n    IPositionNFTs public immutable POSITION_NFT;\\n\\n    // OraceHub interface\\n    IWiseOracleHub public immutable WISE_ORACLE;\\n\\n    // Structs ------------------------------------------\\n\\n    struct LendingEntry {\\n        bool unCollateralized;\\n        uint256 shares;\\n    }\\n\\n    struct BorrowRatesEntry {\\n        uint256 pole;\\n        uint256 deltaPole;\\n        uint256 minPole;\\n        uint256 maxPole;\\n        uint256 multiplicativeFactor;\\n    }\\n\\n    struct AlgorithmEntry {\\n        bool increasePole;\\n        uint256 bestPole;\\n        uint256 maxValue;\\n        uint256 previousValue;\\n    }\\n\\n    struct GlobalPoolEntry {\\n        uint256 totalPool;\\n        uint256 utilization;\\n        uint256 totalBareToken;\\n        uint256 poolFee;\\n    }\\n\\n    struct LendingPoolEntry {\\n        uint256 pseudoTotalPool;\\n        uint256 totalDepositShares;\\n        uint256 collateralFactor;\\n    }\\n\\n    struct BorrowPoolEntry {\\n        bool allowBorrow;\\n        uint256 pseudoTotalBorrowAmount;\\n        uint256 totalBorrowShares;\\n        uint256 borrowRate;\\n    }\\n\\n    struct TimestampsPoolEntry {\\n        uint256 timeStamp;\\n        uint256 timeStampScaling;\\n    }\\n\\n    struct CoreLiquidationStruct {\\n        uint256 nftId;\\n        uint256 nftIdLiquidator;\\n        address caller;\\n        address receiver;\\n        address tokenToPayback;\\n        address tokenToRecieve;\\n        uint256 paybackAmount;\\n        uint256 shareAmountToPay;\\n        uint256 maxFeeETH;\\n        uint256 baseRewardLiquidation;\\n        address[] lendTokens;\\n        address[] borrowTokens;\\n    }\\n\\n    modifier onlyWhiteList() {\\n        _onlyWhiteList();\\n        _;\\n    }\\n\\n    function _onlyWhiteList()\\n        private\\n        view\\n    {\\n        if (whiteListOnBehalf[msg.sender] == false) {\\n            revert InvalidCaller();\\n        }\\n    }\\n\\n    /**\\n     * Allows to set whitelist contract\\n     */\\n    function setOnBehalf(\\n        address _contract,\\n        bool _status\\n    )\\n        external\\n        onlyMaster\\n    {\\n        whiteListOnBehalf[_contract] = _status;\\n    }\\n\\n    // Reentrancy check - public for layer2's\\n    bool public sendingProgress;\\n\\n    // Position mappings ------------------------------------------\\n    mapping(address => bool) internal whiteListOnBehalf;\\n    mapping(address => uint256) internal bufferIncrease;\\n    mapping(address => uint256) public maxDepositValueToken;\\n\\n    mapping(uint256 => address[]) public positionLendTokenData;\\n    mapping(uint256 => address[]) public positionBorrowTokenData;\\n\\n    mapping(uint256 => mapping(address => uint256)) public userBorrowShares;\\n    mapping(uint256 => mapping(address => uint256)) public pureCollateralAmount;\\n    mapping(uint256 => mapping(address => LendingEntry)) public userLendingData;\\n\\n    // Owner -> PoolToken -> Spender -> Allowance Value\\n    mapping(address => mapping(address => mapping(address => uint256))) public allowance;\\n\\n    // Struct mappings -------------------------------------\\n    mapping(address => BorrowRatesEntry) public borrowRatesData;\\n    mapping(address => AlgorithmEntry) public algorithmData;\\n    mapping(address => GlobalPoolEntry) public globalPoolData;\\n    mapping(address => LendingPoolEntry) public lendingPoolData;\\n    mapping(address => BorrowPoolEntry) public borrowPoolData;\\n    mapping(address => TimestampsPoolEntry) public timestampsPoolData;\\n\\n    // Bool mappings -------------------------------------\\n    mapping(uint256 => bool) public positionLocked;\\n    mapping(address => bool) internal parametersLocked;\\n    mapping(address => bool) public verifiedIsolationPool;\\n\\n    // Hash mappings -------------------------------------\\n    mapping(bytes32 => bool) internal hashMapPositionBorrow;\\n    mapping(bytes32 => bool) internal hashMapPositionLending;\\n\\n    // PRECISION FACTORS ------------------------------------\\n    uint256 internal constant PRECISION_FACTOR_E16 = 1E16;\\n    uint256 internal constant PRECISION_FACTOR_E18 = 1E18;\\n    uint256 internal constant PRECISION_FACTOR_E36 = PRECISION_FACTOR_E18 * PRECISION_FACTOR_E18;\\n\\n    // TIME CONSTANTS --------------------------------------\\n    uint256 internal constant ONE_YEAR = 52 weeks;\\n    uint256 internal constant THREE_HOURS = 3 hours;\\n    uint256 internal constant PRECISION_FACTOR_YEAR = PRECISION_FACTOR_E18 * ONE_YEAR;\\n\\n    // Two months in seconds:\\n    // Norming change in pole value that it steps from min to max value\\n    // within two month (if nothing changes)\\n    uint256 internal constant NORMALISATION_FACTOR = 4838400;\\n\\n    // Default boundary values for pool creation.\\n    uint256 internal constant LOWER_BOUND_MAX_RATE = 100 * PRECISION_FACTOR_E16;\\n    uint256 internal constant UPPER_BOUND_MAX_RATE = 300 * PRECISION_FACTOR_E16;\\n\\n    // LASA CONSTANTS -------------------------\\n    uint256 internal constant THRESHOLD_SWITCH_DIRECTION = 90 * PRECISION_FACTOR_E16;\\n    uint256 internal constant THRESHOLD_RESET_RESONANCE_FACTOR = 75 * PRECISION_FACTOR_E16;\\n}\\n\"\r\n    },\r\n    \"contracts/WiseLowLevelHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: -- WISE --\\n\\npragma solidity =0.8.23;\\n\\nimport \\\"./WiseLendingDeclaration.sol\\\";\\n\\nabstract contract WiseLowLevelHelper is WiseLendingDeclaration {\\n\\n    modifier onlyFeeManager() {\\n        _onlyFeeManager();\\n        _;\\n    }\\n\\n    function _onlyFeeManager()\\n        private\\n        view\\n    {\\n        if (msg.sender == address(FEE_MANAGER)) {\\n            return;\\n        }\\n\\n        revert InvalidCaller();\\n    }\\n\\n    modifier onlyAllowedContracts() {\\n        _onlyAllowedContracts();\\n        _;\\n    }\\n\\n    function _onlyAllowedContracts()\\n        private\\n        view\\n    {\\n        if (_byPassCase(msg.sender) == true) {\\n            return;\\n        }\\n\\n        if (msg.sender == address(FEE_MANAGER)) {\\n            return;\\n        }\\n\\n        revert InvalidCaller();\\n    }\\n\\n    // --- Basic Public Views Functions ----\\n\\n    function getTotalPool(\\n        address _poolToken\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return globalPoolData[_poolToken].totalPool;\\n    }\\n\\n    function getPseudoTotalPool(\\n        address _poolToken\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return lendingPoolData[_poolToken].pseudoTotalPool;\\n    }\\n\\n    function getTotalBareToken(\\n        address _poolToken\\n    )\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return globalPoolData[_poolToken].totalBareToken;\\n    }\\n\\n    function getPseudoTotalBorrowAmount(\\n        address _poolToken\\n    )\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return borrowPoolData[_poolToken].pseudoTotalBorrowAmount;\\n    }\\n\\n    function getTotalDepositShares(\\n        address _poolToken\\n    )\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return lendingPoolData[_poolToken].totalDepositShares;\\n    }\\n\\n    function getTotalBorrowShares(\\n        address _poolToken\\n    )\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return borrowPoolData[_poolToken].totalBorrowShares;\\n    }\\n\\n    function getPositionLendingShares(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return userLendingData[_nftId][_poolToken].shares;\\n    }\\n\\n    function getPositionBorrowShares(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return userBorrowShares[_nftId][_poolToken];\\n    }\\n\\n    function getPureCollateralAmount(\\n        uint256 _nftId,\\n        address _poolToken\\n    )\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return pureCollateralAmount[_nftId][_poolToken];\\n    }\\n\\n    // --- Basic Internal Get Functions ----\\n\\n    function getTimeStamp(\\n        address _poolToken\\n    )\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return timestampsPoolData[_poolToken].timeStamp;\\n    }\\n\\n    function getPositionLendingTokenByIndex(\\n        uint256 _nftId,\\n        uint256 _index\\n    )\\n        public\\n        view\\n        returns (address)\\n    {\\n        return positionLendTokenData[_nftId][_index];\\n    }\\n\\n    function getPositionLendingTokenLength(\\n        uint256 _nftId\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return positionLendTokenData[_nftId].length;\\n    }\\n\\n    function getPositionBorrowTokenByIndex(\\n        uint256 _nftId,\\n        uint256 _index\\n    )\\n        public\\n        view\\n        returns (address)\\n    {\\n        return positionBorrowTokenData[_nftId][_index];\\n    }\\n\\n    function getPositionBorrowTokenLength(\\n        uint256 _nftId\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return positionBorrowTokenData[_nftId].length;\\n    }\\n\\n    // --- Basic Internal Set Functions ----\\n\\n    function _setMaxValue(\\n        address _poolToken,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        algorithmData[_poolToken].maxValue = _value;\\n    }\\n\\n    function _setBestPole(\\n        address _poolToken,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        algorithmData[_poolToken].bestPole = _value;\\n    }\\n\\n    function _setIncreasePole(\\n        address _poolToken,\\n        bool _state\\n    )\\n        internal\\n    {\\n        algorithmData[_poolToken].increasePole = _state;\\n    }\\n\\n    function _setPole(\\n        address _poolToken,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        borrowRatesData[_poolToken].pole = _value;\\n    }\\n\\n    function _increaseTotalPool(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        globalPoolData[_poolToken].totalPool += _amount;\\n    }\\n\\n    function _decreaseTotalPool(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        globalPoolData[_poolToken].totalPool -= _amount;\\n    }\\n\\n    function _increaseTotalDepositShares(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        lendingPoolData[_poolToken].totalDepositShares += _amount;\\n    }\\n\\n    function _decreaseTotalDepositShares(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        lendingPoolData[_poolToken].totalDepositShares -= _amount;\\n    }\\n\\n    function _increasePseudoTotalBorrowAmount(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        borrowPoolData[_poolToken].pseudoTotalBorrowAmount += _amount;\\n    }\\n\\n    function _decreasePseudoTotalBorrowAmount(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        borrowPoolData[_poolToken].pseudoTotalBorrowAmount -= _amount;\\n    }\\n\\n    function _increaseTotalBorrowShares(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        borrowPoolData[_poolToken].totalBorrowShares += _amount;\\n    }\\n\\n    function _decreaseTotalBorrowShares(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        borrowPoolData[_poolToken].totalBorrowShares -= _amount;\\n    }\\n\\n    function _increasePseudoTotalPool(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        lendingPoolData[_poolToken].pseudoTotalPool += _amount;\\n    }\\n\\n    function _decreasePseudoTotalPool(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        lendingPoolData[_poolToken].pseudoTotalPool -= _amount;\\n    }\\n\\n    function _setTimeStamp(\\n        address _poolToken,\\n        uint256 _time\\n    )\\n        internal\\n    {\\n        timestampsPoolData[_poolToken].timeStamp = _time;\\n    }\\n\\n    function _setTimeStampScaling(\\n        address _poolToken,\\n        uint256 _time\\n    )\\n        internal\\n    {\\n        timestampsPoolData[_poolToken].timeStampScaling = _time;\\n    }\\n\\n    function _increaseTotalBareToken(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        globalPoolData[_poolToken].totalBareToken += _amount;\\n    }\\n\\n    function _decreaseTotalBareToken(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        globalPoolData[_poolToken].totalBareToken -= _amount;\\n    }\\n\\n    function _checkReentrancy()\\n        internal\\n        view\\n    {\\n        if (sendingProgress == true) {\\n            revert InvalidAction();\\n        }\\n\\n        if (IAaveHubLite(AAVE_HUB_ADDRESS).sendingProgressAaveHub() == true) {\\n            revert InvalidAction();\\n        }\\n    }\\n\\n    function _decreasePositionMappingValue(\\n        mapping(uint256 => mapping(address => uint256)) storage userMapping,\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        userMapping[_nftId][_poolToken] -= _amount;\\n    }\\n\\n    function _increaseMappingValue(\\n        mapping(uint256 => mapping(address => uint256)) storage userMapping,\\n        uint256 _nftId,\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        userMapping[_nftId][_poolToken] += _amount;\\n    }\\n\\n    function _byPassCase(\\n        address _sender\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        if (_sender == AAVE_HUB_ADDRESS) {\\n            return true;\\n        }\\n\\n        if (verifiedIsolationPool[_sender] == true) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    function _increaseTotalAndPseudoTotalPool(\\n        address _poolToken,\\n        uint256 _amount\\n    )\\n        internal\\n    {\\n        _increasePseudoTotalPool(\\n            _poolToken,\\n            _amount\\n        );\\n\\n        _increaseTotalPool(\\n            _poolToken,\\n            _amount\\n        );\\n    }\\n\\n    function setPoolFee(\\n        address _poolToken,\\n        uint256 _newFee\\n    )\\n        external\\n        onlyFeeManager\\n    {\\n        globalPoolData[_poolToken].poolFee = _newFee;\\n    }\\n\\n    function _checkOwnerPosition(\\n        uint256 _nftId,\\n        address _msgSender\\n    )\\n        internal\\n        view\\n    {\\n        WISE_SECURITY.checkOwnerPosition(\\n            _nftId,\\n            _msgSender\\n        );\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 280\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"remappings\": [\r\n      \":@balancer-labs/=node_modules/@balancer-labs/\",\r\n      \":@chainlink/=node_modules/@chainlink/\",\r\n      \":@ensdomains/=node_modules/@ensdomains/\",\r\n      \":@eth-optimism/=node_modules/@eth-optimism/\",\r\n      \":@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \":@pendle/=node_modules/@pendle/\",\r\n      \":@uniswap/=node_modules/@uniswap/\",\r\n      \":base64-sol/=node_modules/base64-sol/\",\r\n      \":ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \":eth-gas-reporter/=node_modules/eth-gas-reporter/\",\r\n      \":forge-std/=lib/forge-std/src/\",\r\n      \":hardhat/=node_modules/hardhat/\"\r\n    ],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_master\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wiseOracleHubAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nftContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CollateralTooSmall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DeadOracle\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAction\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotMaster\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotProposed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PositionLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SharePriceDecreased\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SharePriceIncreased\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroSharesAssigned\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newMaster\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousMaster\",\"type\":\"address\"}],\"name\":\"ClaimedOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"FundsBorrowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"FundsBorrowedOnBehalf\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"FundsDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalPayment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalPaymentShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"FundsReturned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"FundsSolelyDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"FundsSolelyWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"FundsSolelyWithdrawnOnBehalf\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawnOnBehalf\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposedMaster\",\"type\":\"address\"}],\"name\":\"MasterProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousMaster\",\"type\":\"address\"}],\"name\":\"RenouncedOwnership\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"POSITION_NFT\",\"outputs\":[{\"internalType\":\"contract IPositionNFTs\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WISE_ORACLE\",\"outputs\":[{\"internalType\":\"contract IWiseOracleHub\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WISE_SECURITY\",\"outputs\":[{\"internalType\":\"contract IWiseSecurity\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"algorithmData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"increasePole\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"bestPole\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"previousValue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"borrowExactAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"borrowExactAmountETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"borrowOnBehalfExactAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"borrowPoolData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"allowBorrow\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pseudoTotalBorrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"borrowRatesData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pole\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deltaPole\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPole\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPole\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multiplicativeFactor\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_maxSharePrice\",\"type\":\"bool\"}],\"name\":\"calculateBorrowShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_maxSharePrice\",\"type\":\"bool\"}],\"name\":\"calculateLendingShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"cashoutAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"checkDeposit\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"checkPositionLocked\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"collateralizeDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nftIdLiquidator\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_paybackToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiveToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_paybackAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_shareAmountToPay\",\"type\":\"uint256\"}],\"name\":\"coreLiquidationIsolationPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"corePaybackFeeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"allowBorrow\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolMulFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolCollFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDepositAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolManager.CreatePool\",\"name\":\"_params\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"curvePool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"curveMetaPool\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapBytesPool\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"swapBytesMeta\",\"type\":\"bytes\"}],\"internalType\":\"struct CurveSwapStructData\",\"name\":\"curveSecuritySwapsData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"curvePoolTokenIndexFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"curvePoolTokenIndexTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"curveMetaPoolTokenIndexFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"curveMetaPoolTokenIndexTo\",\"type\":\"uint256\"}],\"internalType\":\"struct CurveSwapStructToken\",\"name\":\"curveSecuritySwapsToken\",\"type\":\"tuple\"}],\"internalType\":\"struct PoolManager.CurvePoolSettings\",\"name\":\"_settings\",\"type\":\"tuple\"}],\"name\":\"createCurvePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"allowBorrow\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolMulFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolCollFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDepositAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolManager.CreatePool\",\"name\":\"_params\",\"type\":\"tuple\"}],\"name\":\"createPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositExactAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"depositExactAmountETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositExactAmountETHMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositExactAmountMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"getPositionBorrowShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getPositionBorrowTokenByIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"getPositionBorrowTokenLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"getPositionLendingShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getPositionLendingTokenByIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"getPositionLendingTokenLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"getPseudoTotalBorrowAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"getPseudoTotalPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"getPureCollateralAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"getTimeStamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"getTotalBareToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"getTotalBorrowShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"getTotalDepositShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"getTotalPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"globalPoolData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilization\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBareToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"isUncollateralized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lendingPoolData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pseudoTotalPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDepositShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralFactor\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nftIdLiquidator\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_paybackToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiveToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_shareAmountToPay\",\"type\":\"uint256\"}],\"name\":\"liquidatePartiallyFromTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"master\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxDepositValueToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"newBorrowRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"paybackAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"paybackExactAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"paybackExactAmountETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"paybackExactShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"positionBorrowTokenData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"positionLendTokenData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"positionLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"preparePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proposedOwner\",\"type\":\"address\"}],\"name\":\"proposeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pureCollateralAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sendingProgress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setOnBehalf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_poolMulFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_upperBoundMaxRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lowerBoundMaxRate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_steppingDirection\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isFinal\",\"type\":\"bool\"}],\"name\":\"setParamsLASA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newFee\",\"type\":\"uint256\"}],\"name\":\"setPoolFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collateralFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maximumDeposit\",\"type\":\"uint256\"}],\"name\":\"setPoolParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_registerState\",\"type\":\"bool\"}],\"name\":\"setRegistrationIsolationPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wiseSecurity\",\"type\":\"address\"}],\"name\":\"setSecurity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_isolationPool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setVerifiedIsolationPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"skim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"solelyDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"solelyDepositETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"solelyDepositETHMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"solelyDepositMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"solelyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"solelyWithdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"solelyWithdrawOnBehalf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"syncManually\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"timestampsPoolData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timeStamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeStampScaling\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"}],\"name\":\"unCollateralizeDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userBorrowShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLendingData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"unCollateralized\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"verifiedIsolationPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawExactAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawExactAmountETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"withdrawExactShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"withdrawExactSharesETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawOnBehalfExactAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"withdrawOnBehalfExactShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "WiseLending", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "280", "ConstructorArguments": "000000000000000000000000641ad78baca220c5bd28b51ce8e0f495e85fe689000000000000000000000000f8a8eae0206d36b9ac87eaa9a229047085af017800000000000000000000000032e0a7f7c4b1a19594d25bd9b63eba912b1a5f61", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}