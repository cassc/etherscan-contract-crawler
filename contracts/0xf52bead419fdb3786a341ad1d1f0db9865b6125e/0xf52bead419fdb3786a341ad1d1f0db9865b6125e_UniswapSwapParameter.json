{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IParameterChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface IParameterChecker {\\r\\n\\r\\n    /**\\r\\n     * @dev Return [] on error, return [ 'to' ] if no address to return\\r\\n     * @param to Destination address of the transaction\\r\\n     * @param selector Selector of the transaction\\r\\n     * @param data Data payload of the transaction\\r\\n     * @return addressList Array of address to be checked with the whitelist\\r\\n     */\\r\\n    function getAddressListForChecking(address to, bytes4 selector, bytes memory data) external view returns (address[] memory);\\r\\n}\"\r\n    },\r\n    \"contracts/parameterChecker/UniswapSwapParameterChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"../interfaces/IParameterChecker.sol\\\";\\r\\n\\r\\ncontract UniswapSwapParameterChecker is IParameterChecker {\\r\\n    \\r\\n    function getAddressListForChecking(\\r\\n        address to,\\r\\n        bytes4 selector,\\r\\n        bytes calldata data\\r\\n    ) external override view returns (address[] memory) {\\r\\n\\r\\n        if (selector == 0x24856bc3 // execute(commands:bytes,inputs:bytes[])\\r\\n          || selector == 0x3593564c // execute(commands:bytes,inputs:bytes[],deadline:uint256)\\r\\n         ) {    \\r\\n            bytes calldata commands;\\r\\n            bytes[] calldata inputs;\\r\\n            assembly{\\r\\n                let dataOffset := add(data.offset, 4)\\r\\n\\r\\n                let commandsOffset := calldataload(dataOffset)\\r\\n                commands.offset := add(add(dataOffset, commandsOffset), 0x20)\\r\\n                commands.length := calldataload(add(dataOffset, commandsOffset))\\r\\n                \\r\\n                let inputsOffset := calldataload(add(dataOffset, 0x20))\\r\\n                inputs.offset := add(add(dataOffset, inputsOffset), 0x20)\\r\\n                inputs.length := calldataload(add(dataOffset, inputsOffset))                \\r\\n            }            \\r\\n\\r\\n            address[] memory rv = getAddressArrayFromExecute(commands, inputs, to);\\r\\n            if (rv.length == 0){\\r\\n                // in case all check is valid but no address to check, we return \\\"to\\\" instead of empty array\\r\\n                rv = new address[](1);\\r\\n                rv[0] = to;\\r\\n            }\\r\\n            return rv;\\r\\n        }\\r\\n        return new address[](0);\\r\\n    }\\r\\n\\r\\n    function getAddressArrayFromExecute(bytes calldata commands, bytes[] calldata inputs, address to) internal view returns (address[] memory) {\\r\\n        address[][] memory _addressArrays = new address[][](commands.length);\\r\\n        uint256 _addressCount = 0;\\r\\n        for (uint256 i = 0; i < commands.length; i++) {\\r\\n            address[] memory _addressArray = dispatch(commands[i], inputs[i]);\\r\\n            _addressCount += _addressArray.length;\\r\\n            _addressArrays[i] = _addressArray;\\r\\n        }\\r\\n        \\r\\n        address[] memory rv = new address[](_addressCount);\\r\\n        uint256 x = 0;\\r\\n        for (uint256 i = 0; i < _addressArrays.length; i++) {\\r\\n            for (uint256 j = 0; j < _addressArrays[i].length; j++) {\\r\\n                rv[x++] = map(_addressArrays[i][j], to);\\r\\n            }\\r\\n        }\\r\\n        return rv;\\r\\n    }\\r\\n\\r\\n    function dispatch(bytes1 commandType, bytes calldata inputs) internal pure returns (address[] memory rv) {\\r\\n        uint256 command = uint8(commandType & Commands.COMMAND_TYPE_MASK);\\r\\n\\r\\n        if (command == Commands.V3_SWAP_EXACT_IN) {\\r\\n            // equivalent: abi.decode(inputs, (address, uint256, uint256, bytes, bool))\\r\\n            address recipient;\\r\\n            bool payerIsUser;\\r\\n            assembly {\\r\\n                recipient := calldataload(inputs.offset)\\r\\n                payerIsUser := calldataload(add(inputs.offset, 0x80))\\r\\n            }\\r\\n            bytes calldata path = toBytes(inputs, 3);\\r\\n            (address token0, address token1) = toPathTokensV3(path);\\r\\n            if (!payerIsUser) {\\r\\n                rv = new address[](2);\\r\\n                rv[0] = recipient;\\r\\n                rv[1] = token1;\\r\\n            } else if (recipient == address(2)) {\\r\\n                rv = new address[](1);\\r\\n                rv[0] = token0;\\r\\n            } else {\\r\\n                rv = new address[](3);\\r\\n                rv[0] = recipient;\\r\\n                rv[1] = token0;\\r\\n                rv[2] = token1;\\r\\n            }\\r\\n            return rv;\\r\\n        } else if (command == Commands.V2_SWAP_EXACT_IN) {\\r\\n            // equivalent: abi.decode(inputs, (address, uint256, uint256, bytes, bool))\\r\\n            address recipient;\\r\\n            bool payerIsUser;\\r\\n            assembly {\\r\\n                recipient := calldataload(inputs.offset)\\r\\n                payerIsUser := calldataload(add(inputs.offset, 0x80))\\r\\n            }\\r\\n            bytes calldata path = toBytes(inputs, 3);\\r\\n            (address token0, address token1) = toPathTokensV2(path);\\r\\n            if (!payerIsUser) {\\r\\n                rv = new address[](2);\\r\\n                rv[0] = recipient;\\r\\n                rv[1] = token1;\\r\\n            } else if (recipient == address(2)) {\\r\\n                rv = new address[](1);\\r\\n                rv[0] = token0;\\r\\n            } else {\\r\\n                rv = new address[](3);\\r\\n                rv[0] = recipient;\\r\\n                rv[1] = token0;\\r\\n                rv[2] = token1;\\r\\n            }\\r\\n            return rv;\\r\\n        } else if (command == Commands.V3_SWAP_EXACT_OUT) {\\r\\n            // equivalent: abi.decode(inputs, (address, uint256, uint256, bytes, bool))\\r\\n            address recipient;\\r\\n            bool payerIsUser;\\r\\n            assembly {\\r\\n                recipient := calldataload(inputs.offset)\\r\\n                payerIsUser := calldataload(add(inputs.offset, 0x80))\\r\\n            }\\r\\n            bytes calldata path = toBytes(inputs, 3);\\r\\n            (address token0, address token1) = toPathTokensV3(path);\\r\\n            if (!payerIsUser) {\\r\\n                rv = new address[](2);\\r\\n                rv[0] = recipient;\\r\\n                rv[1] = token0;\\r\\n            } else if (recipient == address(2)) {\\r\\n                rv = new address[](1);\\r\\n                rv[0] = token1;\\r\\n            } else {\\r\\n                rv = new address[](3);\\r\\n                rv[0] = recipient;\\r\\n                rv[1] = token0;\\r\\n                rv[2] = token1;\\r\\n            }\\r\\n            return rv;\\r\\n        }else if (command == Commands.V2_SWAP_EXACT_OUT) {\\r\\n            // equivalent: abi.decode(inputs, (address, uint256, uint256, bytes, bool))\\r\\n            address recipient;\\r\\n            bool payerIsUser;\\r\\n            assembly {\\r\\n                recipient := calldataload(inputs.offset)\\r\\n                payerIsUser := calldataload(add(inputs.offset, 0x80))\\r\\n            }\\r\\n            bytes calldata path = toBytes(inputs, 3);\\r\\n            (address token0, address token1) = toPathTokensV2(path);\\r\\n            if (!payerIsUser) {\\r\\n                rv = new address[](2);\\r\\n                rv[0] = recipient;\\r\\n                rv[1] = token0;\\r\\n            } else if (recipient == address(2)) {\\r\\n                rv = new address[](1);\\r\\n                rv[0] = token1;\\r\\n            } else {\\r\\n                rv = new address[](3);\\r\\n                rv[0] = recipient;\\r\\n                rv[1] = token0;\\r\\n                rv[2] = token1;\\r\\n            }\\r\\n            return rv;\\r\\n        } else if (command == Commands.PERMIT2_TRANSFER_FROM\\r\\n                || command == Commands.SWEEP\\r\\n                || command == Commands.TRANSFER\\r\\n                || command == Commands.PAY_PORTION\\r\\n        ) {\\r\\n            // equivalent:  abi.decode(inputs, (address, address, uintxxx))            \\r\\n            address token;\\r\\n            address recipient;\\r\\n            assembly {\\r\\n                token := calldataload(inputs.offset)\\r\\n                recipient := calldataload(add(inputs.offset, 0x20))\\r\\n            }\\r\\n            rv = new address[](2);\\r\\n            rv[0] = recipient;\\r\\n            rv[1] = token;\\r\\n            return rv;\\r\\n        } else if (command == Commands.PERMIT2_PERMIT_BATCH) { // To be implemented\\r\\n            (PermitBatch memory permitBatch,) = abi.decode(inputs, (PermitBatch, bytes));      \\r\\n            rv = new address[](permitBatch.details.length + 1);            \\r\\n            for (uint256 i = 0; i < permitBatch.details.length; i++)\\r\\n            {\\r\\n                rv[i] = permitBatch.details[i].token;                \\r\\n            }\\r\\n            rv[permitBatch.details.length] = permitBatch.spender;\\r\\n            return rv;\\r\\n        } else if (command == Commands.PERMIT2_PERMIT) {\\r\\n            // equivalent: abi.decode(inputs, (IAllowanceTransfer.PermitSingle, bytes))\\r\\n            PermitSingle calldata permitSingle;\\r\\n            assembly {\\r\\n                permitSingle := inputs.offset\\r\\n            }            \\r\\n            rv = new address[](2);\\r\\n            rv[0] = permitSingle.spender;\\r\\n            rv[1] = permitSingle.details.token;\\r\\n            return rv;\\r\\n        } else if (command == Commands.WRAP_ETH\\r\\n                || command == Commands.UNWRAP_WETH\\r\\n                ) {\\r\\n            // equivalent: abi.decode(inputs, (address, uint256))\\r\\n            address recipient;\\r\\n            assembly {\\r\\n                recipient := calldataload(inputs.offset)\\r\\n            }\\r\\n            rv = new address[](1);\\r\\n            rv[0] = recipient;\\r\\n            return rv;                        \\r\\n        } else if (command == Commands.WRAP_ETH\\r\\n                || command == Commands.UNWRAP_WETH\\r\\n                ) {\\r\\n            // equivalent: abi.decode(inputs, (address, uint256))\\r\\n            address recipient;\\r\\n            assembly {\\r\\n                recipient := calldataload(inputs.offset)\\r\\n            }\\r\\n            rv = new address[](1);\\r\\n            rv[0] = recipient;\\r\\n            return rv;                        \\r\\n        } else if (command == Commands.PERMIT2_TRANSFER_FROM_BATCH) {\\r\\n            (AllowanceTransferDetails[] memory batchDetails) = abi.decode(inputs, (AllowanceTransferDetails[]));            \\r\\n            rv = new address[](batchDetails.length * 2);\\r\\n            uint256 x = 0;\\r\\n            for (uint256 i = 0; i < batchDetails.length; i++)\\r\\n            {\\r\\n                rv[x++] = batchDetails[i].to;\\r\\n                rv[x++] = batchDetails[i].token;\\r\\n            }\\r\\n            return rv;                 \\r\\n        } else if (command == Commands.BALANCE_CHECK_ERC20) {\\r\\n            // equivalent: abi.decode(inputs, (address, address, uint256))                        \\r\\n            return new address[](0);\\r\\n        }\\r\\n        revert(\\\"unsupported comand\\\");\\r\\n    }\\r\\n\\r\\n\\r\\n    function toPathTokensV3(bytes calldata _bytes) internal pure returns (address token0, address token1) {\\r\\n        assembly {\\r\\n            let firstWord := calldataload(_bytes.offset)\\r\\n            token0 := shr(96, firstWord)\\r\\n            token1 := shr(96, calldataload(sub(add(_bytes.offset, _bytes.length), 20)))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function toPathTokensV2(bytes calldata _bytes) internal pure returns (address token0, address token1) {\\r\\n        assembly {\\r\\n            let firstWord := calldataload(_bytes.offset)\\r\\n            token0 := calldataload(_bytes.offset)\\r\\n            token1 := calldataload(add(_bytes.offset, shl(5, sub(_bytes.length, 1))))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function toBytes(bytes calldata _bytes, uint256 _arg) internal pure returns (bytes calldata res) {\\r\\n        assembly {\\r\\n            let lengthPtr := add(_bytes.offset, calldataload(add(_bytes.offset, shl(5, _arg))))            \\r\\n            res.length := calldataload(lengthPtr)\\r\\n            res.offset := add(lengthPtr, 0x20)\\r\\n        }\\r\\n    }    \\r\\n\\r\\n    function map(address recipient, address to) internal view returns (address) {\\r\\n        if (recipient == address(1)) {\\r\\n            return msg.sender;\\r\\n        } else if (recipient == address(2)) {\\r\\n            return to;\\r\\n        } else {\\r\\n            return recipient;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    struct PermitDetails {\\r\\n        // ERC20 token address\\r\\n        address token;\\r\\n        // the maximum amount allowed to spend\\r\\n        uint160 amount;\\r\\n        // timestamp at which a spender's token allowances become invalid\\r\\n        uint48 expiration;\\r\\n        // an incrementing value indexed per owner,token,and spender for each signature\\r\\n        uint48 nonce;\\r\\n    }\\r\\n\\r\\n    /// @notice The permit message signed for a single token allownce\\r\\n    struct PermitSingle {\\r\\n        // the permit data for a single token alownce\\r\\n        PermitDetails details;\\r\\n        // address permissioned on the allowed tokens\\r\\n        address spender;\\r\\n        // deadline on the permit signature\\r\\n        uint256 sigDeadline;\\r\\n    }\\r\\n\\r\\n    /// @notice The permit message signed for multiple token allowances\\r\\n    struct PermitBatch {\\r\\n        // the permit data for multiple token allowances\\r\\n        PermitDetails[] details;\\r\\n        // address permissioned on the allowed tokens\\r\\n        address spender;\\r\\n        // deadline on the permit signature\\r\\n        uint256 sigDeadline;\\r\\n    }\\r\\n        \\r\\n    struct AllowanceTransferDetails {\\r\\n        // the owner of the token\\r\\n        address from;\\r\\n        // the recipient of the token\\r\\n        address to;\\r\\n        // the amount of the token\\r\\n        uint160 amount;\\r\\n        // the token to be transferred\\r\\n        address token;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary Commands {\\r\\n    // Masks to extract certain bits of commands\\r\\n    bytes1 internal constant FLAG_ALLOW_REVERT = 0x80;\\r\\n    bytes1 internal constant COMMAND_TYPE_MASK = 0x3f;\\r\\n\\r\\n    // Command Types. Maximum supported command at this moment is 0x3f.\\r\\n\\r\\n    // Command Types where value<0x08, executed in the first nested-if block\\r\\n    uint256 constant V3_SWAP_EXACT_IN = 0x00;\\r\\n    uint256 constant V3_SWAP_EXACT_OUT = 0x01;\\r\\n    uint256 constant PERMIT2_TRANSFER_FROM = 0x02;\\r\\n    uint256 constant PERMIT2_PERMIT_BATCH = 0x03;\\r\\n    uint256 constant SWEEP = 0x04;\\r\\n    uint256 constant TRANSFER = 0x05;\\r\\n    uint256 constant PAY_PORTION = 0x06;\\r\\n    // COMMAND_PLACEHOLDER = 0x07;\\r\\n\\r\\n    // The commands are executed in nested if blocks to minimise gas consumption\\r\\n    // The following constant defines one of the boundaries where the if blocks split commands\\r\\n    uint256 constant FIRST_IF_BOUNDARY = 0x08;\\r\\n\\r\\n    // Command Types where 0x08<=value<=0x0f, executed in the second nested-if block\\r\\n    uint256 constant V2_SWAP_EXACT_IN = 0x08;\\r\\n    uint256 constant V2_SWAP_EXACT_OUT = 0x09;\\r\\n    uint256 constant PERMIT2_PERMIT = 0x0a;\\r\\n    uint256 constant WRAP_ETH = 0x0b;\\r\\n    uint256 constant UNWRAP_WETH = 0x0c;\\r\\n    uint256 constant PERMIT2_TRANSFER_FROM_BATCH = 0x0d;\\r\\n    uint256 constant BALANCE_CHECK_ERC20 = 0x0e;\\r\\n    // COMMAND_PLACEHOLDER = 0x0f;\\r\\n\\r\\n    // The commands are executed in nested if blocks to minimise gas consumption\\r\\n    // The following constant defines one of the boundaries where the if blocks split commands\\r\\n    uint256 constant SECOND_IF_BOUNDARY = 0x10;\\r\\n\\r\\n    // Command Types where 0x10<=value<0x18, executed in the third nested-if block\\r\\n    uint256 constant SEAPORT_V1_5 = 0x10;\\r\\n    uint256 constant LOOKS_RARE_V2 = 0x11;\\r\\n    uint256 constant NFTX = 0x12;\\r\\n    uint256 constant CRYPTOPUNKS = 0x13;\\r\\n    // 0x14;\\r\\n    uint256 constant OWNER_CHECK_721 = 0x15;\\r\\n    uint256 constant OWNER_CHECK_1155 = 0x16;\\r\\n    uint256 constant SWEEP_ERC721 = 0x17;\\r\\n\\r\\n    // The commands are executed in nested if blocks to minimise gas consumption\\r\\n    // The following constant defines one of the boundaries where the if blocks split commands\\r\\n    uint256 constant THIRD_IF_BOUNDARY = 0x18;\\r\\n\\r\\n    // Command Types where 0x18<=value<=0x1f, executed in the final nested-if block\\r\\n    uint256 constant X2Y2_721 = 0x18;\\r\\n    uint256 constant SUDOSWAP = 0x19;\\r\\n    uint256 constant NFT20 = 0x1a;\\r\\n    uint256 constant X2Y2_1155 = 0x1b;\\r\\n    uint256 constant FOUNDATION = 0x1c;\\r\\n    uint256 constant SWEEP_ERC1155 = 0x1d;\\r\\n    uint256 constant ELEMENT_MARKET = 0x1e;\\r\\n    // COMMAND_PLACEHOLDER = 0x1f;\\r\\n\\r\\n    // The commands are executed in nested if blocks to minimise gas consumption\\r\\n    // The following constant defines one of the boundaries where the if blocks split commands\\r\\n    uint256 constant FOURTH_IF_BOUNDARY = 0x20;\\r\\n\\r\\n    // Command Types where 0x20<=value\\r\\n    uint256 constant SEAPORT_V1_4 = 0x20;\\r\\n    uint256 constant EXECUTE_SUB_PLAN = 0x21;\\r\\n    uint256 constant APPROVE_ERC20 = 0x22;\\r\\n    // COMMAND_PLACEHOLDER for 0x23 to 0x3f (all unused)\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"getAddressListForChecking\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "UniswapSwapParameterChecker", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}