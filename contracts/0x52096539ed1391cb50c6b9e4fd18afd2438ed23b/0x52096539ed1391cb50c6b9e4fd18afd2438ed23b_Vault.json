{"SourceCode": "# @version 0.3.10\r\n\"\"\"\r\n@title Vault\r\n@notice ERC4626+ Vault for lending with crvUSD using LLAMMA algorithm\r\n@author Curve.Fi\r\n@license Copyright (c) Curve.Fi, 2020-2024 - all rights reserved\r\n\"\"\"\r\nfrom vyper.interfaces import ERC20 as ERC20Spec\r\nfrom vyper.interfaces import ERC20Detailed\r\n\r\n\r\nimplements: ERC20Spec\r\nimplements: ERC20Detailed\r\n\r\n\r\ninterface ERC20:\r\n    def transferFrom(_from: address, _to: address, _value: uint256) -> bool: nonpayable\r\n    def transfer(_to: address, _value: uint256) -> bool: nonpayable\r\n    def decimals() -> uint256: view\r\n    def balanceOf(_from: address) -> uint256: view\r\n    def symbol() -> String[32]: view\r\n    def name() -> String[64]: view\r\n\r\ninterface AMM:\r\n    def set_admin(_admin: address): nonpayable\r\n    def rate() -> uint256: view\r\n\r\ninterface Controller:\r\n    def total_debt() -> uint256: view\r\n    def minted() -> uint256: view\r\n    def redeemed() -> uint256: view\r\n    def monetary_policy() -> address: view\r\n    def check_lock() -> bool: view\r\n    def save_rate(): nonpayable\r\n\r\ninterface PriceOracle:\r\n    def price() -> uint256: view\r\n    def price_w() -> uint256: nonpayable\r\n\r\ninterface Factory:\r\n    def admin() -> address: view\r\n\r\n\r\n# ERC20 events\r\n\r\nevent Approval:\r\n    owner: indexed(address)\r\n    spender: indexed(address)\r\n    value: uint256\r\n\r\nevent Transfer:\r\n    sender: indexed(address)\r\n    receiver: indexed(address)\r\n    value: uint256\r\n\r\n# ERC4626 events\r\n\r\nevent Deposit:\r\n    sender: indexed(address)\r\n    owner: indexed(address)\r\n    assets: uint256\r\n    shares: uint256\r\n\r\nevent Withdraw:\r\n    sender: indexed(address)\r\n    receiver: indexed(address)\r\n    owner: indexed(address)\r\n    assets: uint256\r\n    shares: uint256\r\n\r\n\r\n# Limits\r\nMIN_A: constant(uint256) = 2\r\nMAX_A: constant(uint256) = 10000\r\nMIN_FEE: constant(uint256) = 10**6  # 1e-12, still needs to be above 0\r\nMAX_FEE: constant(uint256) = 10**17  # 10%\r\nMAX_LOAN_DISCOUNT: constant(uint256) = 5 * 10**17\r\nMIN_LIQUIDATION_DISCOUNT: constant(uint256) = 10**16\r\nADMIN_FEE: constant(uint256) = 0\r\n\r\n# These are virtual shares from method proposed by OpenZeppelin\r\n# see: https://blog.openzeppelin.com/a-novel-defense-against-erc4626-inflation-attacks\r\n# and\r\n# https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC4626.sol\r\nDEAD_SHARES: constant(uint256) = 1000\r\nMIN_ASSETS: constant(uint256) = 10000\r\n\r\nborrowed_token: public(ERC20)\r\ncollateral_token: public(ERC20)\r\n\r\nprice_oracle: public(PriceOracle)\r\namm: public(AMM)\r\ncontroller: public(Controller)\r\nfactory: public(Factory)\r\n\r\n\r\n# ERC20 publics\r\n\r\ndecimals: public(constant(uint8)) = 18\r\nname: public(String[64])\r\nsymbol: public(String[34])\r\n\r\nNAME_PREFIX: constant(String[16]) = 'Curve Vault for '\r\nSYMBOL_PREFIX: constant(String[2]) = 'cv'\r\n\r\nallowance: public(HashMap[address, HashMap[address, uint256]])\r\nbalanceOf: public(HashMap[address, uint256])\r\ntotalSupply: public(uint256)\r\n\r\nprecision: uint256\r\n\r\n\r\n@external\r\ndef __init__():\r\n    \"\"\"\r\n    @notice Template for Vault implementation\r\n    @param stablecoin Stablecoin address to test if it is borrowed or lent out token\r\n    \"\"\"\r\n    # The contract is made a \"normal\" template (not blueprint) so that we can get contract address before init\r\n    # This is needed if we want to create a rehypothecation dual-market with two vaults\r\n    # where vaults are collaterals of each other\r\n    self.borrowed_token = ERC20(0x0000000000000000000000000000000000000001)\r\n\r\n\r\n@internal\r\n@pure\r\ndef ln_int(_x: uint256) -> int256:\r\n    \"\"\"\r\n    @notice Logarithm ln() function based on log2. Not very gas-efficient but brief\r\n    \"\"\"\r\n    # adapted from: https://medium.com/coinmonks/9aef8515136e\r\n    # and vyper log implementation\r\n    # This can be much more optimal but that's not important here\r\n    x: uint256 = _x\r\n    res: uint256 = 0\r\n    for i in range(8):\r\n        t: uint256 = 2**(7 - i)\r\n        p: uint256 = 2**t\r\n        if x >= p * 10**18:\r\n            x /= p\r\n            res += t * 10**18\r\n    d: uint256 = 10**18\r\n    for i in range(59):  # 18 decimals: math.log2(10**10) == 59.7\r\n        if (x >= 2 * 10**18):\r\n            res += d\r\n            x /= 2\r\n        x = x * x / 10**18\r\n        d /= 2\r\n    # Now res = log2(x)\r\n    # ln(x) = log2(x) / log2(e)\r\n    return convert(res * 10**18 / 1442695040888963328, int256)\r\n\r\n\r\n@external\r\ndef initialize(\r\n        amm_impl: address,\r\n        controller_impl: address,\r\n        borrowed_token: ERC20,\r\n        collateral_token: ERC20,\r\n        A: uint256,\r\n        fee: uint256,\r\n        price_oracle: PriceOracle,  # Factory makes from template if needed, deploying with a from_pool()\r\n        monetary_policy: address,  # Standard monetary policy set in factory\r\n        loan_discount: uint256,\r\n        liquidation_discount: uint256\r\n    ) -> (address, address):\r\n    \"\"\"\r\n    @notice Initializer for vaults\r\n    @param amm_impl AMM implementation (blueprint)\r\n    @param controller_impl Controller implementation (blueprint)\r\n    @param borrowed_token Token which is being borrowed\r\n    @param collateral_token Token used for collateral\r\n    @param A Amplification coefficient: band size is ~1/A\r\n    @param fee Fee for swaps in AMM (for ETH markets found to be 0.6%)\r\n    @param price_oracle Already initialized price oracle\r\n    @param monetary_policy Already initialized monetary policy\r\n    @param loan_discount Maximum discount. LTV = sqrt(((A - 1) / A) ** 4) - loan_discount\r\n    @param liquidation_discount Liquidation discount. LT = sqrt(((A - 1) / A) ** 4) - liquidation_discount\r\n    \"\"\"\r\n    assert self.borrowed_token.address == empty(address)\r\n\r\n    self.borrowed_token = borrowed_token\r\n    self.collateral_token = collateral_token\r\n    self.price_oracle = price_oracle\r\n\r\n    assert A >= MIN_A and A <= MAX_A, \"Wrong A\"\r\n    assert fee <= MAX_FEE, \"Fee too high\"\r\n    assert fee >= MIN_FEE, \"Fee too low\"\r\n    assert liquidation_discount >= MIN_LIQUIDATION_DISCOUNT, \"Liquidation discount too low\"\r\n    assert loan_discount <= MAX_LOAN_DISCOUNT, \"Loan discount too high\"\r\n    assert loan_discount > liquidation_discount, \"need loan_discount>liquidation_discount\"\r\n\r\n    p: uint256 = price_oracle.price()  # This also validates price oracle ABI\r\n    assert p > 0\r\n    assert price_oracle.price_w() == p\r\n    A_ratio: uint256 = 10**18 * A / (A - 1)\r\n\r\n    borrowed_precision: uint256 = 10**(18 - borrowed_token.decimals())\r\n\r\n    amm: address = create_from_blueprint(\r\n        amm_impl,\r\n        borrowed_token.address, borrowed_precision,\r\n        collateral_token.address, 10**(18 - collateral_token.decimals()),\r\n        A, isqrt(A_ratio * 10**18), self.ln_int(A_ratio),\r\n        p, fee, ADMIN_FEE, price_oracle.address,\r\n        code_offset=3)\r\n    controller: address = create_from_blueprint(\r\n        controller_impl,\r\n        empty(address), monetary_policy, loan_discount, liquidation_discount, amm,\r\n        code_offset=3)\r\n    AMM(amm).set_admin(controller)\r\n\r\n    self.amm = AMM(amm)\r\n    self.controller = Controller(controller)\r\n    self.factory = Factory(msg.sender)\r\n\r\n    # ERC20 set up\r\n    self.precision = borrowed_precision\r\n    borrowed_symbol: String[32] = borrowed_token.symbol()\r\n    self.name = concat(NAME_PREFIX, borrowed_symbol)\r\n    # Symbol must be String[32], but we do String[34]. It doesn't affect contracts which read it (they will truncate)\r\n    # However this will be changed as soon as Vyper can *properly* manipulate strings\r\n    self.symbol = concat(SYMBOL_PREFIX, borrowed_symbol)\r\n\r\n    # No events because it's the only market we would ever create in this contract\r\n\r\n    return controller, amm\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef borrow_apr() -> uint256:\r\n    \"\"\"\r\n    @notice Borrow APR (annualized and 1e18-based)\r\n    \"\"\"\r\n    return self.amm.rate() * (365 * 86400)\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef lend_apr() -> uint256:\r\n    \"\"\"\r\n    @notice Lending APR (annualized and 1e18-based)\r\n    \"\"\"\r\n    debt: uint256 = self.controller.total_debt()\r\n    if debt == 0:\r\n        return 0\r\n    else:\r\n        return self.amm.rate() * (365 * 86400) * debt / self._total_assets()\r\n\r\n\r\n@external\r\n@view\r\ndef asset() -> ERC20:\r\n    \"\"\"\r\n    @notice Asset which is the same as borrowed_token\r\n    \"\"\"\r\n    return self.borrowed_token\r\n\r\n\r\n@internal\r\n@view\r\ndef _total_assets() -> uint256:\r\n    # admin fee should be accounted for here when enabled\r\n    self.controller.check_lock()\r\n    return self.borrowed_token.balanceOf(self.controller.address) + self.controller.total_debt()\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef totalAssets() -> uint256:\r\n    \"\"\"\r\n    @notice Total assets which can be lent out or be in reserve\r\n    \"\"\"\r\n    return self._total_assets()\r\n\r\n\r\n@internal\r\n@view\r\ndef _convert_to_shares(assets: uint256, is_floor: bool = True,\r\n                       _total_assets: uint256 = max_value(uint256)) -> uint256:\r\n    total_assets: uint256 = _total_assets\r\n    if total_assets == max_value(uint256):\r\n        total_assets = self._total_assets()\r\n    precision: uint256 = self.precision\r\n    numerator: uint256 = (self.totalSupply + DEAD_SHARES) * assets * precision\r\n    denominator: uint256 = (total_assets * precision + 1)\r\n    if is_floor:\r\n        return numerator / denominator\r\n    else:\r\n        return (numerator + denominator - 1) / denominator\r\n\r\n\r\n@internal\r\n@view\r\ndef _convert_to_assets(shares: uint256, is_floor: bool = True,\r\n                       _total_assets: uint256 = max_value(uint256)) -> uint256:\r\n    total_assets: uint256 = _total_assets\r\n    if total_assets == max_value(uint256):\r\n        total_assets = self._total_assets()\r\n    precision: uint256 = self.precision\r\n    numerator: uint256 = shares * (total_assets * precision + 1)\r\n    denominator: uint256 = (self.totalSupply + DEAD_SHARES) * precision\r\n    if is_floor:\r\n        return numerator / denominator\r\n    else:\r\n        return (numerator + denominator - 1) / denominator\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef pricePerShare(is_floor: bool = True) -> uint256:\r\n    \"\"\"\r\n    @notice Method which shows how much one pool share costs in asset tokens if they are normalized to 18 decimals\r\n    \"\"\"\r\n    supply: uint256 = self.totalSupply\r\n    if supply == 0:\r\n        return 10**18 / DEAD_SHARES\r\n    else:\r\n        precision: uint256 = self.precision\r\n        numerator: uint256 = 10**18 * (self._total_assets() * precision + 1)\r\n        denominator: uint256 = (supply + DEAD_SHARES)\r\n        pps: uint256 = 0\r\n        if is_floor:\r\n            pps = numerator / denominator\r\n        else:\r\n            pps = (numerator + denominator - 1) / denominator\r\n        assert pps > 0\r\n        return pps\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef convertToShares(assets: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Returns the amount of shares which the Vault would exchange for the given amount of shares provided\r\n    \"\"\"\r\n    return self._convert_to_shares(assets)\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef convertToAssets(shares: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Returns the amount of assets that the Vault would exchange for the amount of shares provided\r\n    \"\"\"\r\n    return self._convert_to_assets(shares)\r\n\r\n\r\n@external\r\n@view\r\ndef maxDeposit(receiver: address) -> uint256:\r\n    \"\"\"\r\n    @notice Maximum amount of assets which a given user can deposit (inf)\r\n    \"\"\"\r\n    return max_value(uint256)\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef previewDeposit(assets: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Returns the amount of shares which can be obtained upon depositing assets\r\n    \"\"\"\r\n    return self._convert_to_shares(assets)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef deposit(assets: uint256, receiver: address = msg.sender) -> uint256:\r\n    \"\"\"\r\n    @notice Deposit assets in return for whatever number of shares corresponds to the current conditions\r\n    @param assets Amount of assets to deposit\r\n    @param receiver Receiver of the shares who is optional. If not specified - receiver is the sender\r\n    \"\"\"\r\n    controller: Controller = self.controller\r\n    total_assets: uint256 = self._total_assets()\r\n    assert total_assets + assets >= MIN_ASSETS, \"Need more assets\"\r\n    to_mint: uint256 = self._convert_to_shares(assets, True, total_assets)\r\n    assert self.borrowed_token.transferFrom(msg.sender, controller.address, assets, default_return_value=True)\r\n    self._mint(receiver, to_mint)\r\n    controller.save_rate()\r\n    log Deposit(msg.sender, receiver, assets, to_mint)\r\n    return to_mint\r\n\r\n\r\n@external\r\n@view\r\ndef maxMint(receiver: address) -> uint256:\r\n    \"\"\"\r\n    @notice Return maximum amount of shares which a given user can mint (inf)\r\n    \"\"\"\r\n    return max_value(uint256)\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef previewMint(shares: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the amount of assets which is needed to exactly mint the given amount of shares\r\n    \"\"\"\r\n    return self._convert_to_assets(shares, False)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef mint(shares: uint256, receiver: address = msg.sender) -> uint256:\r\n    \"\"\"\r\n    @notice Mint given amount of shares taking whatever number of assets it requires\r\n    @param shares Number of sharess to mint\r\n    @param receiver Optional receiver for the shares. If not specified - it's the sender\r\n    \"\"\"\r\n    controller: Controller = self.controller\r\n    total_assets: uint256 = self._total_assets()\r\n    assets: uint256 = self._convert_to_assets(shares, False, total_assets)\r\n    assert total_assets + assets >= MIN_ASSETS, \"Need more assets\"\r\n    assert self.borrowed_token.transferFrom(msg.sender, controller.address, assets, default_return_value=True)\r\n    self._mint(receiver, shares)\r\n    controller.save_rate()\r\n    log Deposit(msg.sender, receiver, assets, shares)\r\n    return assets\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef maxWithdraw(owner: address) -> uint256:\r\n    \"\"\"\r\n    @notice Maximum amount of assets which a given user can withdraw. Aware of both user's balance and available liquidity\r\n    \"\"\"\r\n    return min(\r\n        self._convert_to_assets(self.balanceOf[owner]),\r\n        self.borrowed_token.balanceOf(self.controller.address))\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef previewWithdraw(assets: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate number of shares which gets burned when withdrawing given amount of asset\r\n    \"\"\"\r\n    assert assets <= self.borrowed_token.balanceOf(self.controller.address)\r\n    return self._convert_to_shares(assets, False)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef withdraw(assets: uint256, receiver: address = msg.sender, owner: address = msg.sender) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw given amount of asset and burn the corresponding amount of vault shares\r\n    @param assets Amount of assets to withdraw\r\n    @param receiver Receiver of the assets (optional, sender if not specified)\r\n    @param owner Owner who's shares the caller takes. Only can take those if owner gave the approval to the sender. Optional\r\n    \"\"\"\r\n    total_assets: uint256 = self._total_assets()\r\n    assert total_assets - assets >= MIN_ASSETS or total_assets == assets, \"Need more assets\"\r\n    shares: uint256 = self._convert_to_shares(assets, False, total_assets)\r\n    if owner != msg.sender:\r\n        allowance: uint256 = self.allowance[owner][msg.sender]\r\n        if allowance != max_value(uint256):\r\n            self._approve(owner, msg.sender, allowance - shares)\r\n\r\n    controller: Controller = self.controller\r\n    self._burn(owner, shares)\r\n    assert self.borrowed_token.transferFrom(controller.address, receiver, assets, default_return_value=True)\r\n    controller.save_rate()\r\n    log Withdraw(msg.sender, receiver, owner, assets, shares)\r\n    return shares\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef maxRedeem(owner: address) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate maximum amount of shares which a given user can redeem\r\n    \"\"\"\r\n    return min(\r\n        self._convert_to_shares(self.borrowed_token.balanceOf(self.controller.address), False),\r\n        self.balanceOf[owner])\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant('lock')\r\ndef previewRedeem(shares: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the amount of assets which can be obtained by redeeming the given amount of shares\r\n    \"\"\"\r\n    if self.totalSupply == 0:\r\n        assert shares == 0\r\n        return 0\r\n\r\n    else:\r\n        assets_to_redeem: uint256 = self._convert_to_assets(shares)\r\n        assert assets_to_redeem <= self.borrowed_token.balanceOf(self.controller.address)\r\n        return assets_to_redeem\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef redeem(shares: uint256, receiver: address = msg.sender, owner: address = msg.sender) -> uint256:\r\n    \"\"\"\r\n    @notice Burn given amount of shares and give corresponding assets to the user\r\n    @param shares Amount of shares to burn\r\n    @param receiver Optional receiver of the assets\r\n    @param owner Optional owner of the shares. Can only redeem if owner gave approval to the sender\r\n    \"\"\"\r\n    if owner != msg.sender:\r\n        allowance: uint256 = self.allowance[owner][msg.sender]\r\n        if allowance != max_value(uint256):\r\n            self._approve(owner, msg.sender, allowance - shares)\r\n\r\n    total_assets: uint256 = self._total_assets()\r\n    assets_to_redeem: uint256 = self._convert_to_assets(shares, True, total_assets)\r\n    if total_assets - assets_to_redeem < MIN_ASSETS:\r\n        if shares == self.totalSupply:\r\n            # This is the last withdrawal, so we can take everything\r\n            assets_to_redeem = total_assets\r\n        else:\r\n            raise \"Need more assets\"\r\n    self._burn(owner, shares)\r\n    controller: Controller = self.controller\r\n    assert self.borrowed_token.transferFrom(controller.address, receiver, assets_to_redeem, default_return_value=True)\r\n    controller.save_rate()\r\n    log Withdraw(msg.sender, receiver, owner, assets_to_redeem, shares)\r\n    return assets_to_redeem\r\n\r\n\r\n# ERC20 methods\r\n\r\n@internal\r\ndef _approve(_owner: address, _spender: address, _value: uint256):\r\n    self.allowance[_owner][_spender] = _value\r\n\r\n    log Approval(_owner, _spender, _value)\r\n\r\n\r\n@internal\r\ndef _burn(_from: address, _value: uint256):\r\n    self.balanceOf[_from] -= _value\r\n    self.totalSupply -= _value\r\n\r\n    log Transfer(_from, empty(address), _value)\r\n\r\n\r\n@internal\r\ndef _mint(_to: address, _value: uint256):\r\n    self.balanceOf[_to] += _value\r\n    self.totalSupply += _value\r\n\r\n    log Transfer(empty(address), _to, _value)\r\n\r\n\r\n@internal\r\ndef _transfer(_from: address, _to: address, _value: uint256):\r\n    assert _to not in [self, empty(address)]\r\n\r\n    self.balanceOf[_from] -= _value\r\n    self.balanceOf[_to] += _value\r\n\r\n    log Transfer(_from, _to, _value)\r\n\r\n\r\n@external\r\ndef transferFrom(_from: address, _to: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Transfer tokens from one account to another.\r\n    @dev The caller needs to have an allowance from account `_from` greater than or\r\n        equal to the value being transferred. An allowance equal to the uint256 type's\r\n        maximum, is considered infinite and does not decrease.\r\n    @param _from The account which tokens will be spent from.\r\n    @param _to The account which tokens will be sent to.\r\n    @param _value The amount of tokens to be transferred.\r\n    \"\"\"\r\n    allowance: uint256 = self.allowance[_from][msg.sender]\r\n    if allowance != max_value(uint256):\r\n        self._approve(_from, msg.sender, allowance - _value)\r\n\r\n    self._transfer(_from, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef transfer(_to: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Transfer tokens to `_to`.\r\n    @param _to The account to transfer tokens to.\r\n    @param _value The amount of tokens to transfer.\r\n    \"\"\"\r\n    self._transfer(msg.sender, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef approve(_spender: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Allow `_spender` to transfer up to `_value` amount of tokens from the caller's account.\r\n    @dev Non-zero to non-zero approvals are allowed, but should be used cautiously. The methods\r\n        increaseAllowance + decreaseAllowance are available to prevent any front-running that\r\n        may occur.\r\n    @param _spender The account permitted to spend up to `_value` amount of caller's funds.\r\n    @param _value The amount of tokens `_spender` is allowed to spend.\r\n    \"\"\"\r\n    self._approve(msg.sender, _spender, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef increaseAllowance(_spender: address, _add_value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Increase the allowance granted to `_spender`.\r\n    @dev This function will never overflow, and instead will bound\r\n        allowance to MAX_UINT256. This has the potential to grant an\r\n        infinite approval.\r\n    @param _spender The account to increase the allowance of.\r\n    @param _add_value The amount to increase the allowance by.\r\n    \"\"\"\r\n    cached_allowance: uint256 = self.allowance[msg.sender][_spender]\r\n    allowance: uint256 = unsafe_add(cached_allowance, _add_value)\r\n\r\n    # check for an overflow\r\n    if allowance < cached_allowance:\r\n        allowance = max_value(uint256)\r\n\r\n    if allowance != cached_allowance:\r\n        self._approve(msg.sender, _spender, allowance)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef decreaseAllowance(_spender: address, _sub_value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Decrease the allowance granted to `_spender`.\r\n    @dev This function will never underflow, and instead will bound\r\n        allowance to 0.\r\n    @param _spender The account to decrease the allowance of.\r\n    @param _sub_value The amount to decrease the allowance by.\r\n    \"\"\"\r\n    cached_allowance: uint256 = self.allowance[msg.sender][_spender]\r\n    allowance: uint256 = unsafe_sub(cached_allowance, _sub_value)\r\n\r\n    # check for an underflow\r\n    if cached_allowance < allowance:\r\n        allowance = 0\r\n\r\n    if allowance != cached_allowance:\r\n        self._approve(msg.sender, _spender, allowance)\r\n\r\n    return True\r\n\r\n\r\n@external\r\n@view\r\ndef admin() -> address:\r\n    return self.factory.admin()", "ABI": "[{\"name\":\"Approval\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"spender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Transfer\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Deposit\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"assets\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"shares\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Withdraw\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"assets\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"shares\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"initialize\",\"inputs\":[{\"name\":\"amm_impl\",\"type\":\"address\"},{\"name\":\"controller_impl\",\"type\":\"address\"},{\"name\":\"borrowed_token\",\"type\":\"address\"},{\"name\":\"collateral_token\",\"type\":\"address\"},{\"name\":\"A\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"price_oracle\",\"type\":\"address\"},{\"name\":\"monetary_policy\",\"type\":\"address\"},{\"name\":\"loan_discount\",\"type\":\"uint256\"},{\"name\":\"liquidation_discount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"borrow_apr\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lend_apr\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"asset\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalAssets\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pricePerShare\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pricePerShare\",\"inputs\":[{\"name\":\"is_floor\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"convertToShares\",\"inputs\":[{\"name\":\"assets\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"convertToAssets\",\"inputs\":[{\"name\":\"shares\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"maxDeposit\",\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"previewDeposit\",\"inputs\":[{\"name\":\"assets\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"assets\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"assets\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"maxMint\",\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"previewMint\",\"inputs\":[{\"name\":\"shares\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"mint\",\"inputs\":[{\"name\":\"shares\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"mint\",\"inputs\":[{\"name\":\"shares\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"maxWithdraw\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"previewWithdraw\",\"inputs\":[{\"name\":\"assets\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"assets\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"assets\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"assets\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"maxRedeem\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"previewRedeem\",\"inputs\":[{\"name\":\"shares\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"redeem\",\"inputs\":[{\"name\":\"shares\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"redeem\",\"inputs\":[{\"name\":\"shares\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"redeem\",\"inputs\":[{\"name\":\"shares\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transferFrom\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transfer\",\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"approve\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"increaseAllowance\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_add_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"decreaseAllowance\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_sub_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"borrowed_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"collateral_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"price_oracle\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"amm\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"controller\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"factory\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"decimals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allowance\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]", "ContractName": "Vault", "CompilerVersion": "vyper:0.3.10", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}