{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"ProjectFlute.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"https://github.com/nibbstack/erc721/src/contracts/tokens/nf-token-metadata.sol\\\";\\nimport \\\"https://github.com/nibbstack/erc721/src/contracts/tokens/nf-token-enumerable.sol\\\";\\nimport \\\"https://github.com/nibbstack/erc721/src/contracts/ownership/ownable.sol\\\";\\nimport \\\"Whitelist.sol\\\";\\n\\n\\n/**\\n * @dev This is an example contract implementation of NFToken with metadata extension.\\n */\\ncontract ProjectFlute is\\n  NFTokenEnumerable,\\n  NFTokenMetadata,\\n  ControlledAccess\\n{\\n    address creatorAccount;\\n\\n  /**\\n   * @dev Contract constructor. Sets metadata extension `name` and `symbol`.\\n   */\\n  constructor()\\n  {\\n    nftName = \\\"Reveries of Ymatar\\\";\\n    nftSymbol = \\\"RoY\\\";\\n    creatorAccount = 0x0786B0220Eab9e7fC5A4d5b6C65BE230858b77b4;\\n  }\\n\\n  uint256 public constant PRICE = 0.02 ether;\\n  /**\\n   * @dev Mints a new NFT.\\n   * @param _to The address that will own the minted NFT.\\n   * @param _tokenId of the NFT to be minted by the msg.sender.\\n   * @param _uri String representing RFC 3986 URI.\\n   */\\n  function mint(\\n    address _to,\\n    uint256 _tokenId,\\n    string calldata _uri,\\n    uint8 _v, \\n    bytes32 _r, \\n    bytes32 _s\\n  )\\n        onlyValidAccess(_v,_r,_s, _tokenId)\\n        public payable\\n    {\\n        require(msg.value >= PRICE, \\\"Price not 0.2 eth\\\");\\n        super._mint(_to, _tokenId);\\n        super._setTokenUri(_tokenId, _uri);\\n    }\\n    \\n    function withdrawMoney() public {\\n        require(creatorAccount == msg.sender);\\n        address payable to = payable(msg.sender);\\n        to.transfer(address(this).balance);\\n    }\\n\\n  /**\\n   * @dev Removes a NFT from owner.\\n   * @param _tokenId Which NFT we want to remove.\\n   */\\n  function burn(\\n    uint256 _tokenId\\n  )\\n    external\\n    onlyOwner\\n  {\\n    super._burn(_tokenId);\\n  }\\n\\n  /**\\n   * @dev Mints a new NFT.\\n   * @notice This is an internal function which should be called from user-implemented external\\n   * mint function. Its purpose is to show and properly initialize data structures when using this\\n   * implementation.\\n   * @param _to The address that will own the minted NFT.\\n   * @param _tokenId of the NFT to be minted by the msg.sender.\\n   */\\n  function _mint(\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    internal\\n    override(NFToken, NFTokenEnumerable)\\n    virtual\\n  {\\n    NFTokenEnumerable._mint(_to, _tokenId);\\n  }\\n\\n  /**\\n   * @dev Burns a NFT.\\n   * @notice This is an internal function which should be called from user-implemented external\\n   * burn function. Its purpose is to show and properly initialize data structures when using this\\n   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\\n   * NFT.\\n   * @param _tokenId ID of the NFT to be burned.\\n   */\\n  function _burn(\\n    uint256 _tokenId\\n  )\\n    internal\\n    override(NFTokenMetadata, NFTokenEnumerable)\\n    virtual\\n  {\\n    NFTokenEnumerable._burn(_tokenId);\\n    if (bytes(idToUri[_tokenId]).length != 0)\\n    {\\n      delete idToUri[_tokenId];\\n    }\\n  }\\n\\n  /**\\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\\n   * @dev Removes a NFT from an address.\\n   * @param _from Address from wich we want to remove the NFT.\\n   * @param _tokenId Which NFT we want to remove.\\n   */\\n  function _removeNFToken(\\n    address _from,\\n    uint256 _tokenId\\n  )\\n    internal\\n    override(NFToken, NFTokenEnumerable)\\n  {\\n    NFTokenEnumerable._removeNFToken(_from, _tokenId);\\n  }\\n\\n  /**\\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\\n   * @dev Assigns a new NFT to an address.\\n   * @param _to Address to wich we want to add the NFT.\\n   * @param _tokenId Which NFT we want to add.\\n   */\\n  function _addNFToken(\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    internal\\n    override(NFToken, NFTokenEnumerable)\\n  {\\n    NFTokenEnumerable._addNFToken(_to, _tokenId);\\n  }\\n\\n   /**\\n   * @dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\\n   * extension to remove double storage(gas optimization) of owner nft count.\\n   * @param _owner Address for whom to query the count.\\n   * @return Number of _owner NFTs.\\n   */\\n  function _getOwnerNFTCount(\\n    address _owner\\n  )\\n    internal\\n    override(NFToken, NFTokenEnumerable)\\n    view\\n    returns (uint256)\\n  {\\n    return NFTokenEnumerable._getOwnerNFTCount(_owner);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"Whitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"https://github.com/nibbstack/erc721/src/contracts/ownership/ownable.sol\\\";\\n\\ncontract ControlledAccess is Ownable {\\n    \\n    \\n   /* \\n    * @dev Requires msg.sender to have valid access message.\\n    * @param _v ECDSA signature parameter v.\\n    * @param _r ECDSA signature parameters r.\\n    * @param _s ECDSA signature parameters s.\\n    */\\n    modifier onlyValidAccess(uint8 _v, bytes32 _r, bytes32 _s, uint256 tokenId) \\n    {\\n        require( isValidAccessMessage(msg.sender,_v,_r,_s, tokenId));\\n        _;\\n    }\\n \\n    /* \\n    * @dev Verifies if message was signed by owner to give access to _add for this contract.\\n    *      Assumes Geth signature prefix.\\n    * @param _add Address of agent with access\\n    * @param _v ECDSA signature parameter v.\\n    * @param _r ECDSA signature parameters r.\\n    * @param _s ECDSA signature parameters s.\\n    * @return Validity of access message for a given address.\\n    */\\n    function isValidAccessMessage(\\n        address _add,\\n        uint8 _v, \\n        bytes32 _r, \\n        bytes32 _s,\\n        uint256 tokenId) \\n        view public returns (bool)\\n    {\\n        bytes32 hash = keccak256(abi.encodePacked(address(this), tokenId, _add));\\n        return owner == ecrecover(\\n            keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash)),\\n            _v,\\n            _r,\\n            _s\\n        );\\n    }\\n}\"\r\n    },\r\n    \"https://github.com/nibbstack/erc721/src/contracts/ownership/ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev The contract has an owner address, and provides basic authorization control whitch\\n * simplifies the implementation of user permissions. This contract is based on the source code at:\\n * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\\n */\\ncontract Ownable\\n{\\n\\n  /**\\n   * @dev Error constants.\\n   */\\n  string public constant NOT_CURRENT_OWNER = \\\"018001\\\";\\n  string public constant CANNOT_TRANSFER_TO_ZERO_ADDRESS = \\\"018002\\\";\\n\\n  /**\\n   * @dev Current owner address.\\n   */\\n  address public owner;\\n\\n  /**\\n   * @dev An event which is triggered when the owner is changed.\\n   * @param previousOwner The address of the previous owner.\\n   * @param newOwner The address of the new owner.\\n   */\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n  /**\\n   * @dev The constructor sets the original `owner` of the contract to the sender account.\\n   */\\n  constructor()\\n  {\\n    owner = msg.sender;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner()\\n  {\\n    require(msg.sender == owner, NOT_CURRENT_OWNER);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   * @param _newOwner The address to transfer ownership to.\\n   */\\n  function transferOwnership(\\n    address _newOwner\\n  )\\n    public\\n    onlyOwner\\n  {\\n    require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);\\n    emit OwnershipTransferred(owner, _newOwner);\\n    owner = _newOwner;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"https://github.com/nibbstack/erc721/src/contracts/tokens/nf-token-enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./nf-token.sol\\\";\\nimport \\\"./erc721-enumerable.sol\\\";\\n\\n/**\\n * @dev Optional enumeration implementation for ERC-721 non-fungible token standard.\\n */\\ncontract NFTokenEnumerable is\\n  NFToken,\\n  ERC721Enumerable\\n{\\n\\n  /**\\n   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.\\n   * Based on 0xcert framework error codes.\\n   */\\n  string constant INVALID_INDEX = \\\"005007\\\";\\n\\n  /**\\n   * @dev Array of all NFT IDs.\\n   */\\n  uint256[] internal tokens;\\n\\n  /**\\n   * @dev Mapping from token ID to its index in global tokens array.\\n   */\\n  mapping(uint256 => uint256) internal idToIndex;\\n\\n  /**\\n   * @dev Mapping from owner to list of owned NFT IDs.\\n   */\\n  mapping(address => uint256[]) internal ownerToIds;\\n\\n  /**\\n   * @dev Mapping from NFT ID to its index in the owner tokens list.\\n   */\\n  mapping(uint256 => uint256) internal idToOwnerIndex;\\n\\n  /**\\n   * @dev Contract constructor.\\n   */\\n  constructor()\\n  {\\n    supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\\n  }\\n\\n  /**\\n   * @dev Returns the count of all existing NFTokens.\\n   * @return Total supply of NFTs.\\n   */\\n  function totalSupply()\\n    external\\n    override\\n    view\\n    returns (uint256)\\n  {\\n    return tokens.length;\\n  }\\n\\n  /**\\n   * @dev Returns NFT ID by its index.\\n   * @param _index A counter less than `totalSupply()`.\\n   * @return Token id.\\n   */\\n  function tokenByIndex(\\n    uint256 _index\\n  )\\n    external\\n    override\\n    view\\n    returns (uint256)\\n  {\\n    require(_index < tokens.length, INVALID_INDEX);\\n    return tokens[_index];\\n  }\\n\\n  /**\\n   * @dev returns the n-th NFT ID from a list of owner's tokens.\\n   * @param _owner Token owner's address.\\n   * @param _index Index number representing n-th token in owner's list of tokens.\\n   * @return Token id.\\n   */\\n  function tokenOfOwnerByIndex(\\n    address _owner,\\n    uint256 _index\\n  )\\n    external\\n    override\\n    view\\n    returns (uint256)\\n  {\\n    require(_index < ownerToIds[_owner].length, INVALID_INDEX);\\n    return ownerToIds[_owner][_index];\\n  }\\n\\n  /**\\n   * @notice This is an internal function which should be called from user-implemented external\\n   * mint function. Its purpose is to show and properly initialize data structures when using this\\n   * implementation.\\n   * @dev Mints a new NFT.\\n   * @param _to The address that will own the minted NFT.\\n   * @param _tokenId of the NFT to be minted by the msg.sender.\\n   */\\n  function _mint(\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    internal\\n    override\\n    virtual\\n  {\\n    super._mint(_to, _tokenId);\\n    tokens.push(_tokenId);\\n    idToIndex[_tokenId] = tokens.length - 1;\\n  }\\n\\n  /**\\n   * @notice This is an internal function which should be called from user-implemented external\\n   * burn function. Its purpose is to show and properly initialize data structures when using this\\n   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\\n   * NFT.\\n   * @dev Burns a NFT.\\n   * @param _tokenId ID of the NFT to be burned.\\n   */\\n  function _burn(\\n    uint256 _tokenId\\n  )\\n    internal\\n    override\\n    virtual\\n  {\\n    super._burn(_tokenId);\\n\\n    uint256 tokenIndex = idToIndex[_tokenId];\\n    uint256 lastTokenIndex = tokens.length - 1;\\n    uint256 lastToken = tokens[lastTokenIndex];\\n\\n    tokens[tokenIndex] = lastToken;\\n\\n    tokens.pop();\\n    // This wastes gas if you are burning the last token but saves a little gas if you are not.\\n    idToIndex[lastToken] = tokenIndex;\\n    idToIndex[_tokenId] = 0;\\n  }\\n\\n  /**\\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\\n   * @dev Removes a NFT from an address.\\n   * @param _from Address from wich we want to remove the NFT.\\n   * @param _tokenId Which NFT we want to remove.\\n   */\\n  function _removeNFToken(\\n    address _from,\\n    uint256 _tokenId\\n  )\\n    internal\\n    override\\n    virtual\\n  {\\n    require(idToOwner[_tokenId] == _from, NOT_OWNER);\\n    delete idToOwner[_tokenId];\\n\\n    uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\\n    uint256 lastTokenIndex = ownerToIds[_from].length - 1;\\n\\n    if (lastTokenIndex != tokenToRemoveIndex)\\n    {\\n      uint256 lastToken = ownerToIds[_from][lastTokenIndex];\\n      ownerToIds[_from][tokenToRemoveIndex] = lastToken;\\n      idToOwnerIndex[lastToken] = tokenToRemoveIndex;\\n    }\\n\\n    ownerToIds[_from].pop();\\n  }\\n\\n  /**\\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\\n   * @dev Assigns a new NFT to an address.\\n   * @param _to Address to wich we want to add the NFT.\\n   * @param _tokenId Which NFT we want to add.\\n   */\\n  function _addNFToken(\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    internal\\n    override\\n    virtual\\n  {\\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\\n    idToOwner[_tokenId] = _to;\\n\\n    ownerToIds[_to].push(_tokenId);\\n    idToOwnerIndex[_tokenId] = ownerToIds[_to].length - 1;\\n  }\\n\\n  /**\\n   *\u00a0@dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\\n   * extension to remove double storage(gas optimization) of owner NFT count.\\n   * @param _owner Address for whom to query the count.\\n   * @return Number of _owner NFTs.\\n   */\\n  function _getOwnerNFTCount(\\n    address _owner\\n  )\\n    internal\\n    override\\n    virtual\\n    view\\n    returns (uint256)\\n  {\\n    return ownerToIds[_owner].length;\\n  }\\n}\\n\"\r\n    },\r\n    \"https://github.com/nibbstack/erc721/src/contracts/tokens/nf-token-metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./nf-token.sol\\\";\\nimport \\\"./erc721-metadata.sol\\\";\\n\\n/**\\n * @dev Optional metadata implementation for ERC-721 non-fungible token standard.\\n */\\ncontract NFTokenMetadata is\\n  NFToken,\\n  ERC721Metadata\\n{\\n\\n  /**\\n   * @dev A descriptive name for a collection of NFTs.\\n   */\\n  string internal nftName;\\n\\n  /**\\n   * @dev An abbreviated name for NFTokens.\\n   */\\n  string internal nftSymbol;\\n\\n  /**\\n   * @dev Mapping from NFT ID to metadata uri.\\n   */\\n  mapping (uint256 => string) internal idToUri;\\n\\n  /**\\n   * @notice When implementing this contract don't forget to set nftName and nftSymbol.\\n   * @dev Contract constructor.\\n   */\\n  constructor()\\n  {\\n    supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\\n  }\\n\\n  /**\\n   * @dev Returns a descriptive name for a collection of NFTokens.\\n   * @return _name Representing name.\\n   */\\n  function name()\\n    external\\n    override\\n    view\\n    returns (string memory _name)\\n  {\\n    _name = nftName;\\n  }\\n\\n  /**\\n   * @dev Returns an abbreviated name for NFTokens.\\n   * @return _symbol Representing symbol.\\n   */\\n  function symbol()\\n    external\\n    override\\n    view\\n    returns (string memory _symbol)\\n  {\\n    _symbol = nftSymbol;\\n  }\\n\\n  /**\\n   * @dev A distinct URI (RFC 3986) for a given NFT.\\n   * @param _tokenId Id for which we want uri.\\n   * @return URI of _tokenId.\\n   */\\n  function tokenURI(\\n    uint256 _tokenId\\n  )\\n    external\\n    override\\n    view\\n    validNFToken(_tokenId)\\n    returns (string memory)\\n  {\\n    return _tokenURI(_tokenId);\\n  }\\n\\n  /**\\n   * @notice This is an internal function that can be overriden if you want to implement a different\\n   * way to generate token URI.\\n   * @param _tokenId Id for which we want uri.\\n   * @return URI of _tokenId.\\n   */\\n  function _tokenURI(\\n    uint256 _tokenId\\n  )\\n    internal\\n    virtual\\n    view\\n    returns (string memory)\\n  {\\n    return idToUri[_tokenId];\\n  }\\n\\n  /**\\n   * @notice This is an internal function which should be called from user-implemented external\\n   * burn function. Its purpose is to show and properly initialize data structures when using this\\n   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\\n   * NFT.\\n   * @dev Burns a NFT.\\n   * @param _tokenId ID of the NFT to be burned.\\n   */\\n  function _burn(\\n    uint256 _tokenId\\n  )\\n    internal\\n    override\\n    virtual\\n  {\\n    super._burn(_tokenId);\\n\\n    delete idToUri[_tokenId];\\n  }\\n\\n  /**\\n   * @notice This is an internal function which should be called from user-implemented external\\n   * function. Its purpose is to show and properly initialize data structures when using this\\n   * implementation.\\n   * @dev Set a distinct URI (RFC 3986) for a given NFT ID.\\n   * @param _tokenId Id for which we want URI.\\n   * @param _uri String representing RFC 3986 URI.\\n   */\\n  function _setTokenUri(\\n    uint256 _tokenId,\\n    string memory _uri\\n  )\\n    internal\\n    validNFToken(_tokenId)\\n  {\\n    idToUri[_tokenId] = _uri;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"https://github.com/nibbstack/erc721/src/contracts/tokens/erc721-metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Optional metadata extension for ERC-721 non-fungible token standard.\\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\\n */\\ninterface ERC721Metadata\\n{\\n\\n  /**\\n   * @dev Returns a descriptive name for a collection of NFTs in this contract.\\n   * @return _name Representing name.\\n   */\\n  function name()\\n    external\\n    view\\n    returns (string memory _name);\\n\\n  /**\\n   * @dev Returns a abbreviated name for a collection of NFTs in this contract.\\n   * @return _symbol Representing symbol.\\n   */\\n  function symbol()\\n    external\\n    view\\n    returns (string memory _symbol);\\n\\n  /**\\n   * @dev Returns a distinct Uniform Resource Identifier (URI) for a given asset. It Throws if\\n   * `_tokenId` is not a valid NFT. URIs are defined in RFC3986. The URI may point to a JSON file\\n   * that conforms to the \\\"ERC721 Metadata JSON Schema\\\".\\n   * @return URI of _tokenId.\\n   */\\n  function tokenURI(uint256 _tokenId)\\n    external\\n    view\\n    returns (string memory);\\n\\n}\\n\"\r\n    },\r\n    \"https://github.com/nibbstack/erc721/src/contracts/tokens/nf-token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./erc721.sol\\\";\\nimport \\\"./erc721-token-receiver.sol\\\";\\nimport \\\"../utils/supports-interface.sol\\\";\\nimport \\\"../utils/address-utils.sol\\\";\\n\\n/**\\n * @dev Implementation of ERC-721 non-fungible token standard.\\n */\\ncontract NFToken is\\n  ERC721,\\n  SupportsInterface\\n{\\n  using AddressUtils for address;\\n\\n  /**\\n   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.\\n   * Based on 0xcert framework error codes.\\n   */\\n  string constant ZERO_ADDRESS = \\\"003001\\\";\\n  string constant NOT_VALID_NFT = \\\"003002\\\";\\n  string constant NOT_OWNER_OR_OPERATOR = \\\"003003\\\";\\n  string constant NOT_OWNER_APPROVED_OR_OPERATOR = \\\"003004\\\";\\n  string constant NOT_ABLE_TO_RECEIVE_NFT = \\\"003005\\\";\\n  string constant NFT_ALREADY_EXISTS = \\\"003006\\\";\\n  string constant NOT_OWNER = \\\"003007\\\";\\n  string constant IS_OWNER = \\\"003008\\\";\\n\\n  /**\\n   * @dev Magic value of a smart contract that can receive NFT.\\n   * Equal to: bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\")).\\n   */\\n  bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\\n\\n  /**\\n   * @dev A mapping from NFT ID to the address that owns it.\\n   */\\n  mapping (uint256 => address) internal idToOwner;\\n\\n  /**\\n   * @dev Mapping from NFT ID to approved address.\\n   */\\n  mapping (uint256 => address) internal idToApproval;\\n\\n   /**\\n   * @dev Mapping from owner address to count of their tokens.\\n   */\\n  mapping (address => uint256) private ownerToNFTokenCount;\\n\\n  /**\\n   * @dev Mapping from owner address to mapping of operator addresses.\\n   */\\n  mapping (address => mapping (address => bool)) internal ownerToOperators;\\n\\n  /**\\n   * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\\n   * @param _tokenId ID of the NFT to validate.\\n   */\\n  modifier canOperate(\\n    uint256 _tokenId\\n  )\\n  {\\n    address tokenOwner = idToOwner[_tokenId];\\n    require(\\n      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],\\n      NOT_OWNER_OR_OPERATOR\\n    );\\n    _;\\n  }\\n\\n  /**\\n   * @dev Guarantees that the msg.sender is allowed to transfer NFT.\\n   * @param _tokenId ID of the NFT to transfer.\\n   */\\n  modifier canTransfer(\\n    uint256 _tokenId\\n  )\\n  {\\n    address tokenOwner = idToOwner[_tokenId];\\n    require(\\n      tokenOwner == msg.sender\\n      || idToApproval[_tokenId] == msg.sender\\n      || ownerToOperators[tokenOwner][msg.sender],\\n      NOT_OWNER_APPROVED_OR_OPERATOR\\n    );\\n    _;\\n  }\\n\\n  /**\\n   * @dev Guarantees that _tokenId is a valid Token.\\n   * @param _tokenId ID of the NFT to validate.\\n   */\\n  modifier validNFToken(\\n    uint256 _tokenId\\n  )\\n  {\\n    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Contract constructor.\\n   */\\n  constructor()\\n  {\\n    supportedInterfaces[0x80ac58cd] = true; // ERC721\\n  }\\n\\n  /**\\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\\n   * function checks if `_to` is a smart contract (code size > 0). If so, it calls\\n   * `onERC721Received` on `_to` and throws if the return value is not\\n   * `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`.\\n   * @dev Transfers the ownership of an NFT from one address to another address. This function can\\n   * be changed to payable.\\n   * @param _from The current owner of the NFT.\\n   * @param _to The new owner.\\n   * @param _tokenId The NFT to transfer.\\n   * @param _data Additional data with no specified format, sent in call to `_to`.\\n   */\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId,\\n    bytes calldata _data\\n  )\\n    external\\n    override\\n  {\\n    _safeTransferFrom(_from, _to, _tokenId, _data);\\n  }\\n\\n  /**\\n   * @notice This works identically to the other function with an extra data parameter, except this\\n   * function just sets data to \\\"\\\".\\n   * @dev Transfers the ownership of an NFT from one address to another address. This function can\\n   * be changed to payable.\\n   * @param _from The current owner of the NFT.\\n   * @param _to The new owner.\\n   * @param _tokenId The NFT to transfer.\\n   */\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    external\\n    override\\n  {\\n    _safeTransferFrom(_from, _to, _tokenId, \\\"\\\");\\n  }\\n\\n  /**\\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\\n   * they may be permanently lost.\\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\\n   * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.\\n   * @param _from The current owner of the NFT.\\n   * @param _to The new owner.\\n   * @param _tokenId The NFT to transfer.\\n   */\\n  function transferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    external\\n    override\\n    canTransfer(_tokenId)\\n    validNFToken(_tokenId)\\n  {\\n    address tokenOwner = idToOwner[_tokenId];\\n    require(tokenOwner == _from, NOT_OWNER);\\n    require(_to != address(0), ZERO_ADDRESS);\\n\\n    _transfer(_to, _tokenId);\\n  }\\n\\n  /**\\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\\n   * the current NFT owner, or an authorized operator of the current owner.\\n   * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.\\n   * @param _approved Address to be approved for the given NFT ID.\\n   * @param _tokenId ID of the token to be approved.\\n   */\\n  function approve(\\n    address _approved,\\n    uint256 _tokenId\\n  )\\n    external\\n    override\\n    canOperate(_tokenId)\\n    validNFToken(_tokenId)\\n  {\\n    address tokenOwner = idToOwner[_tokenId];\\n    require(_approved != tokenOwner, IS_OWNER);\\n\\n    idToApproval[_tokenId] = _approved;\\n    emit Approval(tokenOwner, _approved, _tokenId);\\n  }\\n\\n  /**\\n   * @notice This works even if sender doesn't own any tokens at the time.\\n   * @dev Enables or disables approval for a third party (\\\"operator\\\") to manage all of\\n   * `msg.sender`'s assets. It also emits the ApprovalForAll event.\\n   * @param _operator Address to add to the set of authorized operators.\\n   * @param _approved True if the operators is approved, false to revoke approval.\\n   */\\n  function setApprovalForAll(\\n    address _operator,\\n    bool _approved\\n  )\\n    external\\n    override\\n  {\\n    ownerToOperators[msg.sender][_operator] = _approved;\\n    emit ApprovalForAll(msg.sender, _operator, _approved);\\n  }\\n\\n  /**\\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\\n   * considered invalid, and this function throws for queries about the zero address.\\n   * @param _owner Address for whom to query the balance.\\n   * @return Balance of _owner.\\n   */\\n  function balanceOf(\\n    address _owner\\n  )\\n    external\\n    override\\n    view\\n    returns (uint256)\\n  {\\n    require(_owner != address(0), ZERO_ADDRESS);\\n    return _getOwnerNFTCount(_owner);\\n  }\\n\\n  /**\\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are\\n   * considered invalid, and queries about them do throw.\\n   * @param _tokenId The identifier for an NFT.\\n   * @return _owner Address of _tokenId owner.\\n   */\\n  function ownerOf(\\n    uint256 _tokenId\\n  )\\n    external\\n    override\\n    view\\n    returns (address _owner)\\n  {\\n    _owner = idToOwner[_tokenId];\\n    require(_owner != address(0), NOT_VALID_NFT);\\n  }\\n\\n  /**\\n   * @notice Throws if `_tokenId` is not a valid NFT.\\n   * @dev Get the approved address for a single NFT.\\n   * @param _tokenId ID of the NFT to query the approval of.\\n   * @return Address that _tokenId is approved for.\\n   */\\n  function getApproved(\\n    uint256 _tokenId\\n  )\\n    external\\n    override\\n    view\\n    validNFToken(_tokenId)\\n    returns (address)\\n  {\\n    return idToApproval[_tokenId];\\n  }\\n\\n  /**\\n   * @dev Checks if `_operator` is an approved operator for `_owner`.\\n   * @param _owner The address that owns the NFTs.\\n   * @param _operator The address that acts on behalf of the owner.\\n   * @return True if approved for all, false otherwise.\\n   */\\n  function isApprovedForAll(\\n    address _owner,\\n    address _operator\\n  )\\n    external\\n    override\\n    view\\n    returns (bool)\\n  {\\n    return ownerToOperators[_owner][_operator];\\n  }\\n\\n  /**\\n   * @notice Does NO checks.\\n   * @dev Actually performs the transfer.\\n   * @param _to Address of a new owner.\\n   * @param _tokenId The NFT that is being transferred.\\n   */\\n  function _transfer(\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    internal\\n    virtual\\n  {\\n    address from = idToOwner[_tokenId];\\n    _clearApproval(_tokenId);\\n\\n    _removeNFToken(from, _tokenId);\\n    _addNFToken(_to, _tokenId);\\n\\n    emit Transfer(from, _to, _tokenId);\\n  }\\n\\n  /**\\n   * @notice This is an internal function which should be called from user-implemented external\\n   * mint function. Its purpose is to show and properly initialize data structures when using this\\n   * implementation.\\n   * @dev Mints a new NFT.\\n   * @param _to The address that will own the minted NFT.\\n   * @param _tokenId of the NFT to be minted by the msg.sender.\\n   */\\n  function _mint(\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    internal\\n    virtual\\n  {\\n    require(_to != address(0), ZERO_ADDRESS);\\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\\n\\n    _addNFToken(_to, _tokenId);\\n\\n    emit Transfer(address(0), _to, _tokenId);\\n  }\\n\\n  /**\\n   * @notice This is an internal function which should be called from user-implemented external burn\\n   * function. Its purpose is to show and properly initialize data structures when using this\\n   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\\n   * NFT.\\n   * @dev Burns a NFT.\\n   * @param _tokenId ID of the NFT to be burned.\\n   */\\n  function _burn(\\n    uint256 _tokenId\\n  )\\n    internal\\n    virtual\\n    validNFToken(_tokenId)\\n  {\\n    address tokenOwner = idToOwner[_tokenId];\\n    _clearApproval(_tokenId);\\n    _removeNFToken(tokenOwner, _tokenId);\\n    emit Transfer(tokenOwner, address(0), _tokenId);\\n  }\\n\\n  /**\\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\\n   * @dev Removes a NFT from owner.\\n   * @param _from Address from which we want to remove the NFT.\\n   * @param _tokenId Which NFT we want to remove.\\n   */\\n  function _removeNFToken(\\n    address _from,\\n    uint256 _tokenId\\n  )\\n    internal\\n    virtual\\n  {\\n    require(idToOwner[_tokenId] == _from, NOT_OWNER);\\n    ownerToNFTokenCount[_from] -= 1;\\n    delete idToOwner[_tokenId];\\n  }\\n\\n  /**\\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\\n   * @dev Assigns a new NFT to owner.\\n   * @param _to Address to which we want to add the NFT.\\n   * @param _tokenId Which NFT we want to add.\\n   */\\n  function _addNFToken(\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    internal\\n    virtual\\n  {\\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\\n\\n    idToOwner[_tokenId] = _to;\\n    ownerToNFTokenCount[_to] += 1;\\n  }\\n\\n  /**\\n   *\u00a0@dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\\n   * extension to remove double storage (gas optimization) of owner NFT count.\\n   * @param _owner Address for whom to query the count.\\n   * @return Number of _owner NFTs.\\n   */\\n  function _getOwnerNFTCount(\\n    address _owner\\n  )\\n    internal\\n    virtual\\n    view\\n    returns (uint256)\\n  {\\n    return ownerToNFTokenCount[_owner];\\n  }\\n\\n  /**\\n   * @dev Actually perform the safeTransferFrom.\\n   * @param _from The current owner of the NFT.\\n   * @param _to The new owner.\\n   * @param _tokenId The NFT to transfer.\\n   * @param _data Additional data with no specified format, sent in call to `_to`.\\n   */\\n  function _safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId,\\n    bytes memory _data\\n  )\\n    private\\n    canTransfer(_tokenId)\\n    validNFToken(_tokenId)\\n  {\\n    address tokenOwner = idToOwner[_tokenId];\\n    require(tokenOwner == _from, NOT_OWNER);\\n    require(_to != address(0), ZERO_ADDRESS);\\n\\n    _transfer(_to, _tokenId);\\n\\n    if (_to.isContract())\\n    {\\n      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\\n      require(retval == MAGIC_ON_ERC721_RECEIVED, NOT_ABLE_TO_RECEIVE_NFT);\\n    }\\n  }\\n\\n  /**\\n   * @dev Clears the current approval of a given NFT ID.\\n   * @param _tokenId ID of the NFT to be transferred.\\n   */\\n  function _clearApproval(\\n    uint256 _tokenId\\n  )\\n    private\\n  {\\n    delete idToApproval[_tokenId];\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"https://github.com/nibbstack/erc721/src/contracts/tokens/erc721-enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Optional enumeration extension for ERC-721 non-fungible token standard.\\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\\n */\\ninterface ERC721Enumerable\\n{\\n\\n  /**\\n   * @dev Returns a count of valid NFTs tracked by this contract, where each one of them has an\\n   * assigned and queryable owner not equal to the zero address.\\n   * @return Total supply of NFTs.\\n   */\\n  function totalSupply()\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Returns the token identifier for the `_index`th NFT. Sort order is not specified.\\n   * @param _index A counter less than `totalSupply()`.\\n   * @return Token id.\\n   */\\n  function tokenByIndex(\\n    uint256 _index\\n  )\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Returns the token identifier for the `_index`th NFT assigned to `_owner`. Sort order is\\n   * not specified. It throws if `_index` >= `balanceOf(_owner)` or if `_owner` is the zero address,\\n   * representing invalid NFTs.\\n   * @param _owner An address where we are interested in NFTs owned by them.\\n   * @param _index A counter less than `balanceOf(_owner)`.\\n   * @return Token id.\\n   */\\n  function tokenOfOwnerByIndex(\\n    address _owner,\\n    uint256 _index\\n  )\\n    external\\n    view\\n    returns (uint256);\\n\\n}\\n\"\r\n    },\r\n    \"https://github.com/nibbstack/erc721/src/contracts/utils/address-utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Based on:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\\n * Requires EIP-1052.\\n * @dev Utility library of inline functions on addresses.\\n */\\nlibrary AddressUtils\\n{\\n\\n  /**\\n   * @dev Returns whether the target address is a contract.\\n   * @param _addr Address to check.\\n   * @return addressCheck True if _addr is a contract, false if not.\\n   */\\n  function isContract(\\n    address _addr\\n  )\\n    internal\\n    view\\n    returns (bool addressCheck)\\n  {\\n    // This method relies in extcodesize, which returns 0 for contracts in\\n    // construction, since the code is only stored at the end of the\\n    // constructor execution.\\n\\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n    // for accounts without code, i.e. `keccak256('')`\\n    bytes32 codehash;\\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n    assembly { codehash := extcodehash(_addr) } // solhint-disable-line\\n    addressCheck = (codehash != 0x0 && codehash != accountHash);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"https://github.com/nibbstack/erc721/src/contracts/utils/supports-interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./erc165.sol\\\";\\n\\n/**\\n * @dev Implementation of standard for detect smart contract interfaces.\\n */\\ncontract SupportsInterface is\\n  ERC165\\n{\\n\\n  /**\\n   * @dev Mapping of supported intefraces. You must not set element 0xffffffff to true.\\n   */\\n  mapping(bytes4 => bool) internal supportedInterfaces;\\n\\n  /**\\n   * @dev Contract constructor.\\n   */\\n  constructor()\\n  {\\n    supportedInterfaces[0x01ffc9a7] = true; // ERC165\\n  }\\n\\n  /**\\n   * @dev Function to check which interfaces are suported by this contract.\\n   * @param _interfaceID Id of the interface.\\n   * @return True if _interfaceID is supported, false otherwise.\\n   */\\n  function supportsInterface(\\n    bytes4 _interfaceID\\n  )\\n    external\\n    override\\n    view\\n    returns (bool)\\n  {\\n    return supportedInterfaces[_interfaceID];\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"https://github.com/nibbstack/erc721/src/contracts/tokens/erc721-token-receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC-721 interface for accepting safe transfers.\\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\\n */\\ninterface ERC721TokenReceiver\\n{\\n\\n  /**\\n   * @notice The contract address is always the message sender. A wallet/broker/auction application\\n   * MUST implement the wallet interface if it will accept safe transfers.\\n   * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\\n   * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\\n   * of other than the magic value MUST result in the transaction being reverted.\\n   * Returns `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))` unless throwing.\\n   * @param _operator The address which called `safeTransferFrom` function.\\n   * @param _from The address which previously owned the token.\\n   * @param _tokenId The NFT identifier which is being transferred.\\n   * @param _data Additional data with no specified format.\\n   * @return Returns `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n   */\\n  function onERC721Received(\\n    address _operator,\\n    address _from,\\n    uint256 _tokenId,\\n    bytes calldata _data\\n  )\\n    external\\n    returns(bytes4);\\n\\n}\\n\"\r\n    },\r\n    \"https://github.com/nibbstack/erc721/src/contracts/tokens/erc721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC-721 non-fungible token standard.\\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\\n */\\ninterface ERC721\\n{\\n\\n  /**\\n   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\\n   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\\n   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\\n   * transfer, the approved address for that NFT (if any) is reset to none.\\n   */\\n  event Transfer(\\n    address indexed _from,\\n    address indexed _to,\\n    uint256 indexed _tokenId\\n  );\\n\\n  /**\\n   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\\n   * address indicates there is no approved address. When a Transfer event emits, this also\\n   * indicates that the approved address for that NFT (if any) is reset to none.\\n   */\\n  event Approval(\\n    address indexed _owner,\\n    address indexed _approved,\\n    uint256 indexed _tokenId\\n  );\\n\\n  /**\\n   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\\n   * all NFTs of the owner.\\n   */\\n  event ApprovalForAll(\\n    address indexed _owner,\\n    address indexed _operator,\\n    bool _approved\\n  );\\n\\n  /**\\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\\n   * function checks if `_to` is a smart contract (code size > 0). If so, it calls\\n   * `onERC721Received` on `_to` and throws if the return value is not\\n   * `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`.\\n   * @dev Transfers the ownership of an NFT from one address to another address. This function can\\n   * be changed to payable.\\n   * @param _from The current owner of the NFT.\\n   * @param _to The new owner.\\n   * @param _tokenId The NFT to transfer.\\n   * @param _data Additional data with no specified format, sent in call to `_to`.\\n   */\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId,\\n    bytes calldata _data\\n  )\\n    external;\\n\\n  /**\\n   * @notice This works identically to the other function with an extra data parameter, except this\\n   * function just sets data to \\\"\\\"\\n   * @dev Transfers the ownership of an NFT from one address to another address. This function can\\n   * be changed to payable.\\n   * @param _from The current owner of the NFT.\\n   * @param _to The new owner.\\n   * @param _tokenId The NFT to transfer.\\n   */\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    external;\\n\\n  /**\\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\\n   * they may be permanently lost.\\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\\n   * address. Throws if `_tokenId` is not a valid NFT.  This function can be changed to payable.\\n   * @param _from The current owner of the NFT.\\n   * @param _to The new owner.\\n   * @param _tokenId The NFT to transfer.\\n   */\\n  function transferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    external;\\n\\n  /**\\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\\n   * the current NFT owner, or an authorized operator of the current owner.\\n   * @param _approved The new approved NFT controller.\\n   * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.\\n   * @param _tokenId The NFT to approve.\\n   */\\n  function approve(\\n    address _approved,\\n    uint256 _tokenId\\n  )\\n    external;\\n\\n  /**\\n   * @notice The contract MUST allow multiple operators per owner.\\n   * @dev Enables or disables approval for a third party (\\\"operator\\\") to manage all of\\n   * `msg.sender`'s assets. It also emits the ApprovalForAll event.\\n   * @param _operator Address to add to the set of authorized operators.\\n   * @param _approved True if the operators is approved, false to revoke approval.\\n   */\\n  function setApprovalForAll(\\n    address _operator,\\n    bool _approved\\n  )\\n    external;\\n\\n  /**\\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\\n   * considered invalid, and this function throws for queries about the zero address.\\n   * @notice Count all NFTs assigned to an owner.\\n   * @param _owner Address for whom to query the balance.\\n   * @return Balance of _owner.\\n   */\\n  function balanceOf(\\n    address _owner\\n  )\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @notice Find the owner of an NFT.\\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are\\n   * considered invalid, and queries about them do throw.\\n   * @param _tokenId The identifier for an NFT.\\n   * @return Address of _tokenId owner.\\n   */\\n  function ownerOf(\\n    uint256 _tokenId\\n  )\\n    external\\n    view\\n    returns (address);\\n\\n  /**\\n   * @notice Throws if `_tokenId` is not a valid NFT.\\n   * @dev Get the approved address for a single NFT.\\n   * @param _tokenId The NFT to find the approved address for.\\n   * @return Address that _tokenId is approved for.\\n   */\\n  function getApproved(\\n    uint256 _tokenId\\n  )\\n    external\\n    view\\n    returns (address);\\n\\n  /**\\n   * @notice Query if an address is an authorized operator for another address.\\n   * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\\n   * @param _owner The address that owns the NFTs.\\n   * @param _operator The address that acts on behalf of the owner.\\n   * @return True if approved for all, false otherwise.\\n   */\\n  function isApprovedForAll(\\n    address _owner,\\n    address _operator\\n  )\\n    external\\n    view\\n    returns (bool);\\n\\n}\\n\"\r\n    },\r\n    \"https://github.com/nibbstack/erc721/src/contracts/utils/erc165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev A standard for detecting smart contract interfaces. \\n * See: https://eips.ethereum.org/EIPS/eip-165.\\n */\\ninterface ERC165\\n{\\n\\n  /**\\n   * @dev Checks if the smart contract includes a specific interface.\\n   * This function uses less than 30,000 gas.\\n   * @param _interfaceID The interface identifier, as specified in ERC-165.\\n   * @return True if _interfaceID is supported, false otherwise.\\n   */\\n  function supportsInterface(\\n    bytes4 _interfaceID\\n  )\\n    external\\n    view\\n    returns (bool);\\n    \\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CANNOT_TRANSFER_TO_ZERO_ADDRESS\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NOT_CURRENT_OWNER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isValidAccessMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawMoney\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ProjectFlute", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}