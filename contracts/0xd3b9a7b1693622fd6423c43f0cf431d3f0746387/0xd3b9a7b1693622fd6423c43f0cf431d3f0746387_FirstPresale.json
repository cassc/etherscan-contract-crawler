{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.14;\r\n// Imports\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n */\r\nabstract contract ReentrancyGuard {\r\n\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract FirstPresale is ReentrancyGuard {\r\n    address public owner = 0xBEED5427b0E728AC7EfAaD279c51d511472f9ee2; // owner\r\n    IERC20 public token; //  Token.\r\n    bool private tokenAvailable = false;\r\n    uint public tokensPerETH = 35000; // token per ETH\r\n    uint public ending; // sale end time\r\n    bool public presaleStarted = false; //started or not\r\n    address public deadWallet = 0x000000000000000000000000000000000000dEaD; \r\n    uint public cooldownTime = 10 days; // time between withdrawals of token\r\n    uint public tokensSold;\r\n    uint256 internal balance;\r\n    uint256 public ContractBalance = 1500000*10**18; \r\n\r\n\r\n    mapping(address => bool) public whitelist; // Whitelist for presale.\r\n    mapping(address => uint) public invested; // how much a person invested.\r\n    mapping(address => uint) public investorBalance;//their current balance\r\n    mapping(address => uint) public withdrawableBalance;//how much they can take out of tha platform\r\n    mapping(address => uint) public claimReady;//is it time for that to happen\r\n\r\n    constructor() {\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, 'You must be the owner.');\r\n        _;\r\n    }\r\n\r\n    function transferOwnership (address newOwner) public onlyOwner{\r\n        //check if not empty\r\n        if (newOwner != 0x0000000000000000000000000000000000000000){\r\n        owner = newOwner;\r\n        }\r\n    }\r\n\r\n   //token insertion can only happen 1 time\r\n    function setToken(IERC20 _token) public onlyOwner {\r\n        require(!tokenAvailable, \"Token is already inserted.\");\r\n        token = _token;\r\n        tokenAvailable = true;\r\n    }\r\n\r\n    function multiAddToWhitelist(address[] memory _investor) public onlyOwner {\r\n        for (uint _i = 0; _i < _investor.length; _i++) {\r\n            require(_investor[_i] != address(0), 'Invalid address.');\r\n            address _investorAddress = _investor[_i];\r\n            whitelist[_investorAddress] = true;\r\n        }\r\n    }\r\n\r\n    //add to whitelist\r\n    function addToWhitelist(address _investor) public onlyOwner {\r\n            require(_investor != address(0), 'Invalid address.');\r\n            address _investorAddress = _investor;\r\n            whitelist[_investorAddress] = true;        \r\n    }\r\n\r\n    function setPrice(uint _priceTPETH) public onlyOwner {\r\n        require(presaleStarted, \"Presale not started.\");\r\n        require(block.timestamp <  ending, \"Presale finished.\");\r\n        tokensPerETH = _priceTPETH;\r\n    }\r\n\r\n    function startPsale(uint _presaleTime) public onlyOwner {\r\n        require(tokenAvailable, \"Token is not set.\");\r\n        require(!presaleStarted, \"Presale already started.\");\r\n        ending = block.timestamp + _presaleTime;\r\n        presaleStarted = true;\r\n    }\r\n\r\n    function invest() public payable nonReentrant {\r\n        require(whitelist[msg.sender], \"You must be on the whitelist.\");\r\n        require(presaleStarted, \"Presale must have started.\");\r\n        require(block.timestamp <= ending, \"Presale finished.\");\r\n        invested[msg.sender] += msg.value; // update investors balance\r\n        require(invested[msg.sender] >= 0.05 ether, \"Your investment should be more than 0.05 ETH.\");\r\n        require(invested[msg.sender] <= 2.5 ether, \"Your investment cannot exceed 2.5 ETH.\");\r\n\r\n        uint _investorTokens = msg.value * tokensPerETH; // how many tokens they will receive\r\n        investorBalance[msg.sender] += _investorTokens;//do the swap\r\n        withdrawableBalance[msg.sender] += _investorTokens;//update the necesary balances\r\n        tokensSold += _investorTokens;\r\n    }\r\n\r\n    //% calculation\r\n    function mulScale (uint x, uint y, uint128 scale) internal pure returns (uint) {\r\n        uint a = x / scale;\r\n        uint b = x % scale;\r\n        uint c = y / scale;\r\n        uint d = y % scale;\r\n\r\n        return a * c * scale + a * d + b * c + b * d / scale;\r\n    }\r\n    //investors claim function - they claim tokens at the end of the presale \r\n\r\n    //it means a buyer who buys 1000 tokens can take 100 a week every week for x weeks\r\n    function withdrawTokens() public nonReentrant {\r\n        require(whitelist[msg.sender], \"You must be on the whitelist.\");\r\n        require(block.timestamp > ending, \"Presale must have finished.\");\r\n        require(claimReady[msg.sender] <= block.timestamp, \"You can't claim now.\");\r\n        require(ContractBalance > 0, \"Insufficient contract balance.\");\r\n        require(investorBalance[msg.sender] > 0, \"Insufficient investor balance.\");\r\n\r\n        uint _withdrawableTokensBalance = mulScale(investorBalance[msg.sender], 1000, 10000); // 1000 basis points = 10%.\r\n\r\n        if(withdrawableBalance[msg.sender] <= _withdrawableTokensBalance) {\r\n            token.transfer(msg.sender, withdrawableBalance[msg.sender]);\r\n            investorBalance[msg.sender] = 0;\r\n            withdrawableBalance[msg.sender] = 0;\r\n        } else {\r\n            claimReady[msg.sender] = block.timestamp + cooldownTime; // update next claim time\r\n            withdrawableBalance[msg.sender] -= _withdrawableTokensBalance; // update withdrawable balance\r\n            token.transfer(msg.sender, _withdrawableTokensBalance); // transfer the tokens\r\n        }\r\n    }\r\n\r\n    //burn left over tokens\r\n    function burnTokens() public onlyOwner {\r\n        require(block.timestamp > ending, \"Presale must have finished.\");        \r\n        uint _burnBalance = ContractBalance - tokensSold;\r\n        token.transfer(deadWallet, _burnBalance);\r\n    }\r\n\r\n    function BalanceOut() public onlyOwner {\r\n        uint _Balance = address(this).balance;\r\n        payable (owner).transfer(_Balance);\r\n    }\r\n\r\n    receive() external payable{\r\n        balance += msg.value;\r\n    }\r\n\r\n    fallback() external payable{\r\n        balance += msg.value;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function onERC20Received(address _operator, address _from, uint256 _value, bytes calldata _data) external returns(bytes4);\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"BalanceOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimReady\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cooldownTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"invested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"investorBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_investor\",\"type\":\"address[]\"}],\"name\":\"multiAddToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presaleStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_priceTPETH\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_presaleTime\",\"type\":\"uint256\"}],\"name\":\"startPsale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensPerETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawableBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "FirstPresale", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c99db29792b4631bb961b0f708d3fd0ddcfe874c8ffeeb38ac8f025ca55a5f0c"}