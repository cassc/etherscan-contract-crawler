{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/infiniteProxy/events.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\ncontract Events {\\n    event setAdminLog(address oldAdmin_, address newAdmin_);\\n\\n    event setDummyImplementationLog(address oldDummyImplementation_, address newDummyImplementation_);\\n\\n    event setImplementationLog(address implementation_, bytes4[] sigs_);\\n\\n    event removeImplementationLog(address implementation_);\\n}\\n\"\r\n    },\r\n    \"contracts/infiniteProxy/proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./events.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`.\\n */\\ncontract Internals is Events {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct SigsSlot {\\n        bytes4[] value;\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Storage slot with the address of the current dummy-implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _DUMMY_IMPLEMENTATION_SLOT =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the storage slot which stores the sigs array set for the implementation.\\n     */\\n    function _getImplSigsSlot(address implementation_) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\\"eip1967.proxy.implementation\\\", implementation_));\\n    }\\n\\n    /**\\n     * @dev Returns the storage slot which stores the implementation address for the function sig.\\n     */\\n    function _getSigsImplSlot(bytes4 sig_) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\\"eip1967.proxy.implementation\\\", sig_));\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot_) internal pure returns (AddressSlot storage _r) {\\n        assembly {\\n            _r.slot := slot_\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `SigsSlot` with member `value` located at `slot`.\\n     */\\n    function getSigsSlot(bytes32 slot_) internal pure returns (SigsSlot storage _r) {\\n        assembly {\\n            _r.slot := slot_\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets new implementation and adds mapping from implementation to sigs and sig to implementation.\\n     */\\n    function _setImplementationSigs(address implementation_, bytes4[] memory sigs_) internal {\\n        require(sigs_.length != 0, \\\"no-sigs\\\");\\n        bytes32 slot_ = _getImplSigsSlot(implementation_);\\n        bytes4[] memory sigsCheck_ = getSigsSlot(slot_).value;\\n        require(sigsCheck_.length == 0, \\\"implementation-already-exist\\\");\\n        for (uint256 i = 0; i < sigs_.length; i++) {\\n            bytes32 sigSlot_ = _getSigsImplSlot(sigs_[i]);\\n            require(getAddressSlot(sigSlot_).value == address(0), \\\"sig-already-exist\\\");\\n            getAddressSlot(sigSlot_).value = implementation_;\\n        }\\n        getSigsSlot(slot_).value = sigs_;\\n        emit setImplementationLog(implementation_, sigs_);\\n    }\\n\\n    /**\\n     * @dev Removes implementation and the mappings corresponding to it.\\n     */\\n    function _removeImplementationSigs(address implementation_) internal {\\n        bytes32 slot_ = _getImplSigsSlot(implementation_);\\n        bytes4[] memory sigs_ = getSigsSlot(slot_).value;\\n        require(sigs_.length != 0, \\\"implementation-not-exist\\\");\\n        for (uint256 i = 0; i < sigs_.length; i++) {\\n            bytes32 sigSlot_ = _getSigsImplSlot(sigs_[i]);\\n            delete getAddressSlot(sigSlot_).value;\\n        }\\n        delete getSigsSlot(slot_).value;\\n        emit removeImplementationLog(implementation_);\\n    }\\n\\n    /**\\n     * @dev Returns bytes4[] sigs from implementation address. If implemenatation is not registered then returns empty array.\\n     */\\n    function _getImplementationSigs(address implementation_) internal view returns (bytes4[] memory) {\\n        bytes32 slot_ = _getImplSigsSlot(implementation_);\\n        return getSigsSlot(slot_).value;\\n    }\\n\\n    /**\\n     * @dev Returns implementation address from bytes4 sig. If sig is not registered then returns address(0).\\n     */\\n    function _getSigImplementation(bytes4 sig_) internal view returns (address implementation_) {\\n        bytes32 slot_ = _getSigsImplSlot(sig_);\\n        return getAddressSlot(slot_).value;\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Returns the current dummy-implementation.\\n     */\\n    function _getDummyImplementation() internal view returns (address) {\\n        return getAddressSlot(_DUMMY_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin_) internal {\\n        address oldAdmin_ = _getAdmin();\\n        require(newAdmin_ != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        getAddressSlot(_ADMIN_SLOT).value = newAdmin_;\\n        emit setAdminLog(oldAdmin_, newAdmin_);\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setDummyImplementation(address newDummyImplementation_) internal {\\n        address oldDummyImplementation_ = _getDummyImplementation();\\n        getAddressSlot(_DUMMY_IMPLEMENTATION_SLOT).value = newDummyImplementation_;\\n        emit setDummyImplementationLog(oldDummyImplementation_, newDummyImplementation_);\\n    }\\n\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation_) internal {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation_, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 { revert(0, returndatasize()) }\\n            default { return(0, returndatasize()) }\\n        }\\n    }\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by Implementations registry.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback(bytes4 sig_) internal {\\n        address implementation_ = _getSigImplementation(sig_);\\n        require(implementation_ != address(0), \\\"Liquidity: Not able to find implementation_\\\");\\n        _delegate(implementation_);\\n    }\\n}\\n\\ncontract AdminStuff is Internals {\\n    /**\\n     * @dev Only admin gaurd.\\n     */\\n    modifier onlyAdmin() {\\n        require(msg.sender == _getAdmin(), \\\"not-the-admin\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Sets new admin.\\n     */\\n    function setAdmin(address newAdmin_) external onlyAdmin {\\n        _setAdmin(newAdmin_);\\n    }\\n\\n    /**\\n     * @dev Sets new dummy-implementation.\\n     */\\n    function setDummyImplementation(address newDummyImplementation_) external onlyAdmin {\\n        _setDummyImplementation(newDummyImplementation_);\\n    }\\n\\n    /**\\n     * @dev Adds new implementation address.\\n     */\\n    function addImplementation(address implementation_, bytes4[] calldata sigs_) external onlyAdmin {\\n        _setImplementationSigs(implementation_, sigs_);\\n    }\\n\\n    /**\\n     * @dev Removes an existing implementation address.\\n     */\\n    function removeImplementation(address implementation_) external onlyAdmin {\\n        _removeImplementationSigs(implementation_);\\n    }\\n\\n    constructor(address admin_, address dummyImplementation_) {\\n        _setAdmin(admin_);\\n        _setDummyImplementation(dummyImplementation_);\\n    }\\n}\\n\\nabstract contract Proxy is AdminStuff {\\n    constructor(address admin_, address dummyImplementation_) AdminStuff(admin_, dummyImplementation_) {}\\n\\n    /**\\n     * @dev Returns admin's address.\\n     */\\n    function getAdmin() external view returns (address) {\\n        return _getAdmin();\\n    }\\n\\n    /**\\n     * @dev Returns dummy-implementations's address.\\n     */\\n    function getDummyImplementation() external view returns (address) {\\n        return _getDummyImplementation();\\n    }\\n\\n    /**\\n     * @dev Returns bytes4[] sigs from implementation address If not registered then returns empty array.\\n     */\\n    function getImplementationSigs(address impl_) external view returns (bytes4[] memory) {\\n        return _getImplementationSigs(impl_);\\n    }\\n\\n    /**\\n     * @dev Returns implementation address from bytes4 sig. If sig is not registered then returns address(0).\\n     */\\n    function getSigsImplementation(bytes4 sig_) external view returns (address) {\\n        return _getSigImplementation(sig_);\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by Implementations registry.\\n     */\\n    fallback() external payable {\\n        _fallback(msg.sig);\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by Implementations registry.\\n     */\\n    receive() external payable {\\n        if (msg.sig != 0x00000000) {\\n            _fallback(msg.sig);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/main/StrategyProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../infiniteProxy/proxy.sol\\\";\\n\\ncontract StrategyProxy is Proxy {\\n    constructor(address _admin, address _dummyImplementation) Proxy(_admin, _dummyImplementation) {}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dummyImplementation\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"}],\"name\":\"removeImplementationLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin_\",\"type\":\"address\"}],\"name\":\"setAdminLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldDummyImplementation_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDummyImplementation_\",\"type\":\"address\"}],\"name\":\"setDummyImplementationLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4[]\",\"name\":\"sigs_\",\"type\":\"bytes4[]\"}],\"name\":\"setImplementationLog\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"sigs_\",\"type\":\"bytes4[]\"}],\"name\":\"addImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDummyImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"impl_\",\"type\":\"address\"}],\"name\":\"getImplementationSigs\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"sig_\",\"type\":\"bytes4\"}],\"name\":\"getSigsImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"}],\"name\":\"removeImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin_\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDummyImplementation_\",\"type\":\"address\"}],\"name\":\"setDummyImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "StrategyProxy", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "0000000000000000000000008fa9aa69a6e94c1cd49fbf214c833b2911d025530000000000000000000000009ae1caf549a8889c6dad3077339f7d6393976151", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0x9ae1caf549a8889c6dad3077339f7d6393976151", "SwarmSource": ""}