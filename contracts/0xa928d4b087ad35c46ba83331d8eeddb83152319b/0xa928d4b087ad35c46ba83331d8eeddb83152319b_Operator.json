{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.7/AuthorizedReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./interfaces/AuthorizedReceiverInterface.sol\\\";\\n\\nabstract contract AuthorizedReceiver is AuthorizedReceiverInterface {\\n  mapping(address => bool) private s_authorizedSenders;\\n  address[] private s_authorizedSenderList;\\n\\n  event AuthorizedSendersChanged(address[] senders, address changedBy);\\n\\n  /**\\n   * @notice Sets the fulfillment permission for a given node. Use `true` to allow, `false` to disallow.\\n   * @param senders The addresses of the authorized Chainlink node\\n   */\\n  function setAuthorizedSenders(address[] calldata senders) external override validateAuthorizedSenderSetter {\\n    require(senders.length > 0, \\\"Must have at least 1 authorized sender\\\");\\n    // Set previous authorized senders to false\\n    uint256 authorizedSendersLength = s_authorizedSenderList.length;\\n    for (uint256 i = 0; i < authorizedSendersLength; i++) {\\n      s_authorizedSenders[s_authorizedSenderList[i]] = false;\\n    }\\n    // Set new to true\\n    for (uint256 i = 0; i < senders.length; i++) {\\n      s_authorizedSenders[senders[i]] = true;\\n    }\\n    // Replace list\\n    s_authorizedSenderList = senders;\\n    emit AuthorizedSendersChanged(senders, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Retrieve a list of authorized senders\\n   * @return array of addresses\\n   */\\n  function getAuthorizedSenders() external view override returns (address[] memory) {\\n    return s_authorizedSenderList;\\n  }\\n\\n  /**\\n   * @notice Use this to check if a node is authorized for fulfilling requests\\n   * @param sender The address of the Chainlink node\\n   * @return The authorization status of the node\\n   */\\n  function isAuthorizedSender(address sender) public view override returns (bool) {\\n    return s_authorizedSenders[sender];\\n  }\\n\\n  /**\\n   * @notice customizable guard of who can update the authorized sender list\\n   * @return bool whether sender can update authorized sender list\\n   */\\n  function _canSetAuthorizedSenders() internal virtual returns (bool);\\n\\n  /**\\n   * @notice validates the sender is an authorized sender\\n   */\\n  function _validateIsAuthorizedSender() internal view {\\n    require(isAuthorizedSender(msg.sender), \\\"Not authorized sender\\\");\\n  }\\n\\n  /**\\n   * @notice prevents non-authorized addresses from calling this method\\n   */\\n  modifier validateAuthorizedSender() {\\n    _validateIsAuthorizedSender();\\n    _;\\n  }\\n\\n  /**\\n   * @notice prevents non-authorized addresses from calling this method\\n   */\\n  modifier validateAuthorizedSenderSetter() {\\n    require(_canSetAuthorizedSenders(), \\\"Cannot set authorized senders\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/ConfirmedOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./ConfirmedOwnerWithProposal.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/ConfirmedOwnerWithProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./interfaces/OwnableInterface.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    require(newOwner != address(0), \\\"Cannot set owner to zero\\\");\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(address to) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /**\\n   * @notice Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership() external override {\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Get the current owner\\n   */\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice validate, transfer ownership, and emit relevant events\\n   */\\n  function _transferOwnership(address to) private {\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /**\\n   * @notice validate access\\n   */\\n  function _validateOwnership() internal view {\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n  }\\n\\n  /**\\n   * @notice Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/interfaces/AuthorizedReceiverInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface AuthorizedReceiverInterface {\\n  function isAuthorizedSender(address sender) external view returns (bool);\\n\\n  function getAuthorizedSenders() external returns (address[] memory);\\n\\n  function setAuthorizedSenders(address[] calldata senders) external;\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/interfaces/ChainlinkRequestInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface ChainlinkRequestInterface {\\n  function oracleRequest(\\n    address sender,\\n    uint256 requestPrice,\\n    bytes32 serviceAgreementID,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 nonce,\\n    uint256 dataVersion,\\n    bytes calldata data\\n  ) external;\\n\\n  function cancelOracleRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/interfaces/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface LinkTokenInterface {\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n  function approve(address spender, uint256 value) external returns (bool success);\\n\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  function decimals() external view returns (uint8 decimalPlaces);\\n\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\n\\n  function name() external view returns (string memory tokenName);\\n\\n  function symbol() external view returns (string memory tokenSymbol);\\n\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\n\\n  function transfer(address to, uint256 value) external returns (bool success);\\n\\n  function transferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external returns (bool success);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/interfaces/OperatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./ChainlinkRequestInterface.sol\\\";\\nimport \\\"./OracleInterface.sol\\\";\\n\\ninterface OperatorInterface is ChainlinkRequestInterface, OracleInterface {\\n  function operatorRequest(\\n    address sender,\\n    uint256 payment,\\n    bytes32 specId,\\n    bytes4 callbackFunctionId,\\n    uint256 nonce,\\n    uint256 dataVersion,\\n    bytes calldata data\\n  ) external;\\n\\n  function fulfillOracleRequest2(\\n    bytes32 requestId,\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration,\\n    bytes calldata data\\n  ) external returns (bool);\\n\\n  function ownerTransferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/interfaces/OracleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface OracleInterface {\\n  function fulfillOracleRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration,\\n    bytes32 data\\n  ) external returns (bool);\\n\\n  function withdraw(address recipient, uint256 amount) external;\\n\\n  function withdrawable() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/interfaces/OwnableInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface OwnableInterface {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(address recipient) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/interfaces/WithdrawalInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\ninterface WithdrawalInterface {\\n  /**\\n   * @notice transfer LINK held by the contract belonging to msg.sender to\\n   * another address\\n   * @param recipient is the address to send the LINK to\\n   * @param amount is the amount of LINK to send\\n   */\\n  function withdraw(address recipient, uint256 amount) external;\\n\\n  /**\\n   * @notice query the available amount of LINK to withdraw by msg.sender\\n   */\\n  function withdrawable() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/LinkTokenReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nabstract contract LinkTokenReceiver {\\n  /**\\n   * @notice Called when LINK is sent to the contract via `transferAndCall`\\n   * @dev The data payload's first 2 words will be overwritten by the `sender` and `amount`\\n   * values to ensure correctness. Calls oracleRequest.\\n   * @param sender Address of the sender\\n   * @param amount Amount of LINK sent (specified in wei)\\n   * @param data Payload of the transaction\\n   */\\n  function onTokenTransfer(\\n    address sender,\\n    uint256 amount,\\n    bytes memory data\\n  ) public validateFromLINK permittedFunctionsForLINK(data) {\\n    assembly {\\n      // solhint-disable-next-line avoid-low-level-calls\\n      mstore(add(data, 36), sender) // ensure correct sender is passed\\n      // solhint-disable-next-line avoid-low-level-calls\\n      mstore(add(data, 68), amount) // ensure correct amount is passed\\n    }\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, ) = address(this).delegatecall(data); // calls oracleRequest\\n    require(success, \\\"Unable to create request\\\");\\n  }\\n\\n  function getChainlinkToken() public view virtual returns (address);\\n\\n  /**\\n   * @notice Validate the function called on token transfer\\n   */\\n  function _validateTokenTransferAction(bytes4 funcSelector, bytes memory data) internal virtual;\\n\\n  /**\\n   * @dev Reverts if not sent from the LINK token\\n   */\\n  modifier validateFromLINK() {\\n    require(msg.sender == getChainlinkToken(), \\\"Must use LINK token\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if the given data does not begin with the `oracleRequest` function selector\\n   * @param data The data payload of the request\\n   */\\n  modifier permittedFunctionsForLINK(bytes memory data) {\\n    bytes4 funcSelector;\\n    assembly {\\n      // solhint-disable-next-line avoid-low-level-calls\\n      funcSelector := mload(add(data, 32))\\n    }\\n    _validateTokenTransferAction(funcSelector, data);\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/vendor/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts v3.4.0(fa64a1ced0b70ab89073d5d0b6e01b0778f7e7d6)\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies on extcodesize, which returns 0 for contracts in\\n    // construction, since the code is only stored at the end of the\\n    // constructor execution.\\n\\n    uint256 size;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      size := extcodesize(account)\\n    }\\n    return size > 0;\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`. A\\n   * plain`call` is an unsafe replacement for a function call: use this\\n   * function instead.\\n   *\\n   * If `target` reverts with a revert reason, it is bubbled up by this\\n   * function (like regular Solidity function calls).\\n   *\\n   * Returns the raw returned data. To convert to the expected return value,\\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n   *\\n   * Requirements:\\n   *\\n   * - `target` must be a contract.\\n   * - calling `target` with `data` must not revert.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n   * `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but also transferring `value` wei to `target`.\\n   *\\n   * Requirements:\\n   *\\n   * - the calling contract must have an ETH balance of at least `value`.\\n   * - the called Solidity function must be `payable`.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n    require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  function _verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) private pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      // Look for revert reason and bubble it up if present\\n      if (returndata.length > 0) {\\n        // The easiest way to bubble the revert reason is using memory via assembly\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.7/vendor/SafeMathChainlink.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMathChainlink {\\n  /**\\n   * @dev Returns the addition of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `+` operator.\\n   *\\n   * Requirements:\\n   * - Addition cannot overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `*` operator.\\n   *\\n   * Requirements:\\n   * - Multiplication cannot overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, \\\"SafeMath: division by zero\\\");\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Operator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"@chainlink/contracts/src/v0.7/AuthorizedReceiver.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.7/LinkTokenReceiver.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.7/ConfirmedOwner.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.7/interfaces/LinkTokenInterface.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.7/interfaces/OperatorInterface.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.7/interfaces/OwnableInterface.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.7/interfaces/WithdrawalInterface.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.7/vendor/Address.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.7/vendor/SafeMathChainlink.sol\\\";\\n\\n/**\\n * @title The Chainlink Operator contract\\n * @notice Node operators can deploy this contract to fulfill requests sent to them\\n * @notice Contains correction hardcoded value of gas price limits check MINIMUM_CONSUMER_GAS_LIMIT\\n */\\ncontract Operator is AuthorizedReceiver, ConfirmedOwner, LinkTokenReceiver, OperatorInterface, WithdrawalInterface {\\n  using Address for address;\\n  using SafeMathChainlink for uint256;\\n\\n  struct Commitment {\\n    bytes31 paramsHash;\\n    uint8 dataVersion;\\n  }\\n\\n  uint256 public constant getExpiryTime = 5 minutes;\\n  uint256 private constant MAXIMUM_DATA_VERSION = 256;\\n  uint256 private constant SELECTOR_LENGTH = 4;\\n  uint256 private constant EXPECTED_REQUEST_WORDS = 2;\\n  uint256 private constant MINIMUM_REQUEST_LENGTH = SELECTOR_LENGTH + (32 * EXPECTED_REQUEST_WORDS);\\n  // We initialize fields to 1 instead of 0 so that the first invocation\\n  // does not cost more gas.\\n  uint256 private constant ONE_FOR_CONSISTENT_GAS_COST = 1;\\n  // oracleRequest is intended for version 1, enabling single word responses\\n  bytes4 private constant ORACLE_REQUEST_SELECTOR = this.oracleRequest.selector;\\n  // operatorRequest is intended for version 2, enabling multi-word responses\\n  bytes4 private constant OPERATOR_REQUEST_SELECTOR = this.operatorRequest.selector;\\n\\n  LinkTokenInterface internal immutable linkToken;\\n  mapping(bytes32 => Commitment) private s_commitments;\\n  mapping(address => bool) private s_owned;\\n  // Tokens sent for requests that have not been fulfilled yet\\n  uint256 private s_tokensInEscrow = ONE_FOR_CONSISTENT_GAS_COST;\\n\\n  event OracleRequest(\\n    bytes32 indexed specId,\\n    address requester,\\n    bytes32 requestId,\\n    uint256 payment,\\n    address callbackAddr,\\n    bytes4 callbackFunctionId,\\n    uint256 cancelExpiration,\\n    uint256 dataVersion,\\n    bytes data\\n  );\\n\\n  event CancelOracleRequest(bytes32 indexed requestId);\\n\\n  event OracleResponse(bytes32 indexed requestId);\\n\\n  event OwnableContractAccepted(address indexed acceptedContract);\\n\\n  event TargetsUpdatedAuthorizedSenders(address[] targets, address[] senders, address changedBy);\\n\\n  /**\\n   * @notice Deploy with the address of the LINK token\\n   * @dev Sets the LinkToken address for the imported LinkTokenInterface\\n   * @param link The address of the LINK token\\n   * @param owner The address of the owner\\n   */\\n  constructor(address link, address owner) ConfirmedOwner(owner) {\\n    linkToken = LinkTokenInterface(link); // external but already deployed and unalterable\\n  }\\n\\n  /**\\n   * @notice The type and version of this contract\\n   * @return Type and version string\\n   */\\n  function typeAndVersion() external pure virtual returns (string memory) {\\n    return \\\"Operator 1.0.0\\\";\\n  }\\n\\n  /**\\n   * @notice Creates the Chainlink request. This is a backwards compatible API\\n   * with the Oracle.sol contract, but the behavior changes because\\n   * callbackAddress is assumed to be the same as the request sender.\\n   * @param callbackAddress The consumer of the request\\n   * @param payment The amount of payment given (specified in wei)\\n   * @param specId The Job Specification ID\\n   * @param callbackAddress The address the oracle data will be sent to\\n   * @param callbackFunctionId The callback function ID for the response\\n   * @param nonce The nonce sent by the requester\\n   * @param dataVersion The specified data version\\n   * @param data The extra request parameters\\n   */\\n  function oracleRequest(\\n    address sender,\\n    uint256 payment,\\n    bytes32 specId,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 nonce,\\n    uint256 dataVersion,\\n    bytes calldata data\\n  ) external override validateFromLINK {\\n    (bytes32 requestId, uint256 expiration) = _verifyAndProcessOracleRequest(\\n      sender,\\n      payment,\\n      callbackAddress,\\n      callbackFunctionId,\\n      nonce,\\n      dataVersion\\n    );\\n    emit OracleRequest(specId, sender, requestId, payment, sender, callbackFunctionId, expiration, dataVersion, data);\\n  }\\n\\n  /**\\n   * @notice Creates the Chainlink request\\n   * @dev Stores the hash of the params as the on-chain commitment for the request.\\n   * Emits OracleRequest event for the Chainlink node to detect.\\n   * @param sender The sender of the request\\n   * @param payment The amount of payment given (specified in wei)\\n   * @param specId The Job Specification ID\\n   * @param callbackFunctionId The callback function ID for the response\\n   * @param nonce The nonce sent by the requester\\n   * @param dataVersion The specified data version\\n   * @param data The extra request parameters\\n   */\\n  function operatorRequest(\\n    address sender,\\n    uint256 payment,\\n    bytes32 specId,\\n    bytes4 callbackFunctionId,\\n    uint256 nonce,\\n    uint256 dataVersion,\\n    bytes calldata data\\n  ) external override validateFromLINK {\\n    (bytes32 requestId, uint256 expiration) = _verifyAndProcessOracleRequest(\\n      sender,\\n      payment,\\n      sender,\\n      callbackFunctionId,\\n      nonce,\\n      dataVersion\\n    );\\n    emit OracleRequest(specId, sender, requestId, payment, sender, callbackFunctionId, expiration, dataVersion, data);\\n  }\\n\\n  /**\\n   * @notice Called by the Chainlink node to fulfill requests\\n   * @dev Given params must hash back to the commitment stored from `oracleRequest`.\\n   * Will call the callback address' callback function without bubbling up error\\n   * checking in a `require` so that the node can get paid.\\n   * @param requestId The fulfillment request ID that must match the requester's\\n   * @param payment The payment amount that will be released for the oracle (specified in wei)\\n   * @param callbackAddress The callback address to call for fulfillment\\n   * @param callbackFunctionId The callback function ID to use for fulfillment\\n   * @param expiration The expiration that the node should respond by before the requester can cancel\\n   * @param data The data to return to the consuming contract\\n   * @return Status if the external call was successful\\n   */\\n  function fulfillOracleRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration,\\n    bytes32 data\\n  )\\n    external\\n    override\\n    validateAuthorizedSender\\n    validateRequestId(requestId)\\n    validateCallbackAddress(callbackAddress)\\n    returns (bool)\\n  {\\n    _verifyOracleRequestAndProcessPayment(requestId, payment, callbackAddress, callbackFunctionId, expiration, 1);\\n    emit OracleResponse(requestId);\\n    // All updates to the oracle's fulfillment should come before calling the\\n    // callback(addr+functionId) as it is untrusted.\\n    // See: https://solidity.readthedocs.io/en/develop/security-considerations.html#use-the-checks-effects-interactions-pattern\\n    (bool success, ) = callbackAddress.call(abi.encodeWithSelector(callbackFunctionId, requestId, data)); // solhint-disable-line avoid-low-level-calls\\n    return success;\\n  }\\n\\n  /**\\n   * @notice Called by the Chainlink node to fulfill requests with multi-word support\\n   * @dev Given params must hash back to the commitment stored from `oracleRequest`.\\n   * Will call the callback address' callback function without bubbling up error\\n   * checking in a `require` so that the node can get paid.\\n   * @param requestId The fulfillment request ID that must match the requester's\\n   * @param payment The payment amount that will be released for the oracle (specified in wei)\\n   * @param callbackAddress The callback address to call for fulfillment\\n   * @param callbackFunctionId The callback function ID to use for fulfillment\\n   * @param expiration The expiration that the node should respond by before the requester can cancel\\n   * @param data The data to return to the consuming contract\\n   * @return Status if the external call was successful\\n   */\\n  function fulfillOracleRequest2(\\n    bytes32 requestId,\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration,\\n    bytes calldata data\\n  )\\n    external\\n    override\\n    validateAuthorizedSender\\n    validateRequestId(requestId)\\n    validateCallbackAddress(callbackAddress)\\n    validateMultiWordResponseId(requestId, data)\\n    returns (bool)\\n  {\\n    _verifyOracleRequestAndProcessPayment(requestId, payment, callbackAddress, callbackFunctionId, expiration, 2);\\n    emit OracleResponse(requestId);\\n    // All updates to the oracle's fulfillment should come before calling the\\n    // callback(addr+functionId) as it is untrusted.\\n    // See: https://solidity.readthedocs.io/en/develop/security-considerations.html#use-the-checks-effects-interactions-pattern\\n    (bool success, ) = callbackAddress.call(abi.encodePacked(callbackFunctionId, data)); // solhint-disable-line avoid-low-level-calls\\n    return success;\\n  }\\n\\n  /**\\n   * @notice Transfer the ownership of ownable contracts. This is primarily\\n   * intended for Authorized Forwarders but could possibly be extended to work\\n   * with future contracts.\\n   * @param ownable list of addresses to transfer\\n   * @param newOwner address to transfer ownership to\\n   */\\n  function transferOwnableContracts(address[] calldata ownable, address newOwner) external onlyOwner {\\n    for (uint256 i = 0; i < ownable.length; i++) {\\n      s_owned[ownable[i]] = false;\\n      OwnableInterface(ownable[i]).transferOwnership(newOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Accept the ownership of an ownable contract. This is primarily\\n   * intended for Authorized Forwarders but could possibly be extended to work\\n   * with future contracts.\\n   * @dev Must be the pending owner on the contract\\n   * @param ownable list of addresses of Ownable contracts to accept\\n   */\\n  function acceptOwnableContracts(address[] calldata ownable) public validateAuthorizedSenderSetter {\\n    for (uint256 i = 0; i < ownable.length; i++) {\\n      s_owned[ownable[i]] = true;\\n      emit OwnableContractAccepted(ownable[i]);\\n      OwnableInterface(ownable[i]).acceptOwnership();\\n    }\\n  }\\n\\n  /**\\n   * @notice Sets the fulfillment permission for\\n   * @param targets The addresses to set permissions on\\n   * @param senders The addresses that are allowed to send updates\\n   */\\n  function setAuthorizedSendersOn(address[] calldata targets, address[] calldata senders)\\n    public\\n    validateAuthorizedSenderSetter\\n  {\\n    TargetsUpdatedAuthorizedSenders(targets, senders, msg.sender);\\n\\n    for (uint256 i = 0; i < targets.length; i++) {\\n      AuthorizedReceiverInterface(targets[i]).setAuthorizedSenders(senders);\\n    }\\n  }\\n\\n  /**\\n   * @notice Accepts ownership of ownable contracts and then immediately sets\\n   * the authorized sender list on each of the newly owned contracts. This is\\n   * primarily intended for Authorized Forwarders but could possibly be\\n   * extended to work with future contracts.\\n   * @param targets The addresses to set permissions on\\n   * @param senders The addresses that are allowed to send updates\\n   */\\n  function acceptAuthorizedReceivers(address[] calldata targets, address[] calldata senders)\\n    external\\n    validateAuthorizedSenderSetter\\n  {\\n    acceptOwnableContracts(targets);\\n    setAuthorizedSendersOn(targets, senders);\\n  }\\n\\n  /**\\n   * @notice Allows the node operator to withdraw earned LINK to a given address\\n   * @dev The owner of the contract can be another wallet and does not have to be a Chainlink node\\n   * @param recipient The address to send the LINK token to\\n   * @param amount The amount to send (specified in wei)\\n   */\\n  function withdraw(address recipient, uint256 amount)\\n    external\\n    override(OracleInterface, WithdrawalInterface)\\n    onlyOwner\\n    validateAvailableFunds(amount)\\n  {\\n    assert(linkToken.transfer(recipient, amount));\\n  }\\n\\n  /**\\n   * @notice Displays the amount of LINK that is available for the node operator to withdraw\\n   * @dev We use `ONE_FOR_CONSISTENT_GAS_COST` in place of 0 in storage\\n   * @return The amount of withdrawable LINK on the contract\\n   */\\n  function withdrawable() external view override(OracleInterface, WithdrawalInterface) returns (uint256) {\\n    return _fundsAvailable();\\n  }\\n\\n  /**\\n   * @notice Forward a call to another contract\\n   * @dev Only callable by the owner\\n   * @param to address\\n   * @param data to forward\\n   */\\n  function ownerForward(address to, bytes calldata data) external onlyOwner validateNotToLINK(to) {\\n    require(to.isContract(), \\\"Must forward to a contract\\\");\\n    (bool status, ) = to.call(data);\\n    require(status, \\\"Forwarded call failed\\\");\\n  }\\n\\n  /**\\n   * @notice Interact with other LinkTokenReceiver contracts by calling transferAndCall\\n   * @param to The address to transfer to.\\n   * @param value The amount to be transferred.\\n   * @param data The extra data to be passed to the receiving contract.\\n   * @return success bool\\n   */\\n  function ownerTransferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external override onlyOwner validateAvailableFunds(value) returns (bool success) {\\n    return linkToken.transferAndCall(to, value, data);\\n  }\\n\\n  /**\\n   * @notice Distribute funds to multiple addresses using ETH send\\n   * to this payable function.\\n   * @dev Array length must be equal, ETH sent must equal the sum of amounts.\\n   * A malicious receiver could cause the distribution to revert, in which case\\n   * it is expected that the address is removed from the list.\\n   * @param receivers list of addresses\\n   * @param amounts list of amounts\\n   */\\n  function distributeFunds(address payable[] calldata receivers, uint256[] calldata amounts) external payable {\\n    require(receivers.length > 0 && receivers.length == amounts.length, \\\"Invalid array length(s)\\\");\\n    uint256 valueRemaining = msg.value;\\n    for (uint256 i = 0; i < receivers.length; i++) {\\n      uint256 sendAmount = amounts[i];\\n      valueRemaining = valueRemaining.sub(sendAmount);\\n      receivers[i].transfer(sendAmount);\\n    }\\n    require(valueRemaining == 0, \\\"Too much ETH sent\\\");\\n  }\\n\\n  /**\\n   * @notice Allows recipient to cancel requests sent to this oracle contract.\\n   * Will transfer the LINK sent for the request back to the recipient address.\\n   * @dev Given params must hash to a commitment stored on the contract in order\\n   * for the request to be valid. Emits CancelOracleRequest event.\\n   * @param requestId The request ID\\n   * @param payment The amount of payment given (specified in wei)\\n   * @param callbackFunc The requester's specified callback function selector\\n   * @param expiration The time of the expiration for the request\\n   */\\n  function cancelOracleRequest(\\n    bytes32 requestId,\\n    uint256 payment,\\n    bytes4 callbackFunc,\\n    uint256 expiration\\n  ) external override {\\n    bytes31 paramsHash = _buildParamsHash(payment, msg.sender, callbackFunc, expiration);\\n    require(s_commitments[requestId].paramsHash == paramsHash, \\\"Params do not match request ID\\\");\\n    // solhint-disable-next-line not-rely-on-time\\n    require(expiration <= block.timestamp, \\\"Request is not expired\\\");\\n\\n    delete s_commitments[requestId];\\n    emit CancelOracleRequest(requestId);\\n\\n    linkToken.transfer(msg.sender, payment);\\n  }\\n\\n  /**\\n   * @notice Allows requester to cancel requests sent to this oracle contract.\\n   * Will transfer the LINK sent for the request back to the recipient address.\\n   * @dev Given params must hash to a commitment stored on the contract in order\\n   * for the request to be valid. Emits CancelOracleRequest event.\\n   * @param nonce The nonce used to generate the request ID\\n   * @param payment The amount of payment given (specified in wei)\\n   * @param callbackFunc The requester's specified callback function selector\\n   * @param expiration The time of the expiration for the request\\n   */\\n  function cancelOracleRequestByRequester(\\n    uint256 nonce,\\n    uint256 payment,\\n    bytes4 callbackFunc,\\n    uint256 expiration\\n  ) external {\\n    bytes32 requestId = keccak256(abi.encodePacked(msg.sender, nonce));\\n    bytes31 paramsHash = _buildParamsHash(payment, msg.sender, callbackFunc, expiration);\\n    require(s_commitments[requestId].paramsHash == paramsHash, \\\"Params do not match request ID\\\");\\n    // solhint-disable-next-line not-rely-on-time\\n    require(expiration <= block.timestamp, \\\"Request is not expired\\\");\\n\\n    delete s_commitments[requestId];\\n    emit CancelOracleRequest(requestId);\\n\\n    linkToken.transfer(msg.sender, payment);\\n  }\\n\\n  /**\\n   * @notice Returns the address of the LINK token\\n   * @dev This is the public implementation for chainlinkTokenAddress, which is\\n   * an internal method of the ChainlinkClient contract\\n   */\\n  function getChainlinkToken() public view override returns (address) {\\n    return address(linkToken);\\n  }\\n\\n  /**\\n   * @notice Require that the token transfer action is valid\\n   * @dev OPERATOR_REQUEST_SELECTOR = multiword, ORACLE_REQUEST_SELECTOR = singleword\\n   */\\n  function _validateTokenTransferAction(bytes4 funcSelector, bytes memory data) internal pure override {\\n    require(data.length >= MINIMUM_REQUEST_LENGTH, \\\"Invalid request length\\\");\\n    require(\\n      funcSelector == OPERATOR_REQUEST_SELECTOR || funcSelector == ORACLE_REQUEST_SELECTOR,\\n      \\\"Must use whitelisted functions\\\"\\n    );\\n  }\\n\\n  /**\\n   * @notice Verify the Oracle Request and record necessary information\\n   * @param sender The sender of the request\\n   * @param payment The amount of payment given (specified in wei)\\n   * @param callbackAddress The callback address for the response\\n   * @param callbackFunctionId The callback function ID for the response\\n   * @param nonce The nonce sent by the requester\\n   */\\n  function _verifyAndProcessOracleRequest(\\n    address sender,\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 nonce,\\n    uint256 dataVersion\\n  ) private validateNotToLINK(callbackAddress) returns (bytes32 requestId, uint256 expiration) {\\n    requestId = keccak256(abi.encodePacked(sender, nonce));\\n    require(s_commitments[requestId].paramsHash == 0, \\\"Must use a unique ID\\\");\\n    // solhint-disable-next-line not-rely-on-time\\n    expiration = block.timestamp.add(getExpiryTime);\\n    bytes31 paramsHash = _buildParamsHash(payment, callbackAddress, callbackFunctionId, expiration);\\n    s_commitments[requestId] = Commitment(paramsHash, _safeCastToUint8(dataVersion));\\n    s_tokensInEscrow = s_tokensInEscrow.add(payment);\\n    return (requestId, expiration);\\n  }\\n\\n  /**\\n   * @notice Verify the Oracle request and unlock escrowed payment\\n   * @param requestId The fulfillment request ID that must match the requester's\\n   * @param payment The payment amount that will be released for the oracle (specified in wei)\\n   * @param callbackAddress The callback address to call for fulfillment\\n   * @param callbackFunctionId The callback function ID to use for fulfillment\\n   * @param expiration The expiration that the node should respond by before the requester can cancel\\n   */\\n  function _verifyOracleRequestAndProcessPayment(\\n    bytes32 requestId,\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration,\\n    uint256 dataVersion\\n  ) internal {\\n    bytes31 paramsHash = _buildParamsHash(payment, callbackAddress, callbackFunctionId, expiration);\\n    require(s_commitments[requestId].paramsHash == paramsHash, \\\"Params do not match request ID\\\");\\n    require(s_commitments[requestId].dataVersion <= _safeCastToUint8(dataVersion), \\\"Data versions must match\\\");\\n    s_tokensInEscrow = s_tokensInEscrow.sub(payment);\\n    delete s_commitments[requestId];\\n  }\\n\\n  /**\\n   * @notice Build the bytes31 hash from the payment, callback and expiration.\\n   * @param payment The payment amount that will be released for the oracle (specified in wei)\\n   * @param callbackAddress The callback address to call for fulfillment\\n   * @param callbackFunctionId The callback function ID to use for fulfillment\\n   * @param expiration The expiration that the node should respond by before the requester can cancel\\n   * @return hash bytes31\\n   */\\n  function _buildParamsHash(\\n    uint256 payment,\\n    address callbackAddress,\\n    bytes4 callbackFunctionId,\\n    uint256 expiration\\n  ) internal pure returns (bytes31) {\\n    return bytes31(keccak256(abi.encodePacked(payment, callbackAddress, callbackFunctionId, expiration)));\\n  }\\n\\n  /**\\n   * @notice Safely cast uint256 to uint8\\n   * @param number uint256\\n   * @return uint8 number\\n   */\\n  function _safeCastToUint8(uint256 number) internal pure returns (uint8) {\\n    require(number < MAXIMUM_DATA_VERSION, \\\"number too big to cast\\\");\\n    return uint8(number);\\n  }\\n\\n  /**\\n   * @notice Returns the LINK available in this contract, not locked in escrow\\n   * @return uint256 LINK tokens available\\n   */\\n  function _fundsAvailable() private view returns (uint256) {\\n    uint256 inEscrow = s_tokensInEscrow.sub(ONE_FOR_CONSISTENT_GAS_COST);\\n    return linkToken.balanceOf(address(this)).sub(inEscrow);\\n  }\\n\\n  /**\\n   * @notice concrete implementation of AuthorizedReceiver\\n   * @return bool of whether sender is authorized\\n   */\\n  function _canSetAuthorizedSenders() internal view override returns (bool) {\\n    return isAuthorizedSender(msg.sender) || owner() == msg.sender;\\n  }\\n\\n  // MODIFIERS\\n\\n  /**\\n   * @dev Reverts if the first 32 bytes of the bytes array is not equal to requestId\\n   * @param requestId bytes32\\n   * @param data bytes\\n   */\\n  modifier validateMultiWordResponseId(bytes32 requestId, bytes calldata data) {\\n    require(data.length >= 32, \\\"Response must be > 32 bytes\\\");\\n    bytes32 firstDataWord;\\n    assembly {\\n      // extract the first word from data\\n      // functionSelector = 4\\n      // wordLength = 32\\n      // dataArgumentOffset = 7 * wordLength\\n      // funcSelector + dataArgumentOffset == 0xe4\\n      firstDataWord := calldataload(0xe4)\\n    }\\n    require(requestId == firstDataWord, \\\"First word must be requestId\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if amount requested is greater than withdrawable balance\\n   * @param amount The given amount to compare to `s_withdrawableTokens`\\n   */\\n  modifier validateAvailableFunds(uint256 amount) {\\n    require(_fundsAvailable() >= amount, \\\"Amount requested is greater than withdrawable balance\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if request ID does not exist\\n   * @param requestId The given request ID to check in stored `commitments`\\n   */\\n  modifier validateRequestId(bytes32 requestId) {\\n    require(s_commitments[requestId].paramsHash != 0, \\\"Must have a valid requestId\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if the callback address is the LINK token\\n   * @param to The callback address\\n   */\\n  modifier validateNotToLINK(address to) {\\n    require(to != address(linkToken), \\\"Cannot call to LINK\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Reverts if the target address is owned by the operator\\n   */\\n  modifier validateCallbackAddress(address callbackAddress) {\\n    require(!s_owned[callbackAddress], \\\"Cannot call owned contract\\\");\\n    _;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"link\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"senders\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"changedBy\",\"type\":\"address\"}],\"name\":\"AuthorizedSendersChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"name\":\"CancelOracleRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"specId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"callbackAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"callbackFunctionId\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cancelExpiration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dataVersion\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"OracleRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"name\":\"OracleResponse\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"acceptedContract\",\"type\":\"address\"}],\"name\":\"OwnableContractAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"senders\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"changedBy\",\"type\":\"address\"}],\"name\":\"TargetsUpdatedAuthorizedSenders\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"senders\",\"type\":\"address[]\"}],\"name\":\"acceptAuthorizedReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"ownable\",\"type\":\"address[]\"}],\"name\":\"acceptOwnableContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"internalType\":\"bytes4\",\"name\":\"callbackFunc\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"cancelOracleRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"internalType\":\"bytes4\",\"name\":\"callbackFunc\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"cancelOracleRequestByRequester\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"receivers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"distributeFunds\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"callbackAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"callbackFunctionId\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"data\",\"type\":\"bytes32\"}],\"name\":\"fulfillOracleRequest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"callbackAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"callbackFunctionId\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"fulfillOracleRequest2\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAuthorizedSenders\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainlinkToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExpiryTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"isAuthorizedSender\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"specId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes4\",\"name\":\"callbackFunctionId\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dataVersion\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"operatorRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"specId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callbackAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"callbackFunctionId\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dataVersion\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"oracleRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ownerForward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ownerTransferAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"senders\",\"type\":\"address[]\"}],\"name\":\"setAuthorizedSenders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"senders\",\"type\":\"address[]\"}],\"name\":\"setAuthorizedSendersOn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"ownable\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnableContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typeAndVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Operator", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca000000000000000000000000fcfcd4ec7e78f7407cdc64a5f24f896e0fb6d510", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}