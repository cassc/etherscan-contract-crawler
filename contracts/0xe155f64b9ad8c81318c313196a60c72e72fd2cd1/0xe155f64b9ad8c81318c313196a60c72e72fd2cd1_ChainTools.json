{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"verified-sources/0xE155F64B9aD8c81318c313196a60c72e72fD2cD1/sources/ChaintoolsFinal.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n/*                              \\r\\n                    CHAINTOOLS 2023. DEFI REIMAGINED\\r\\n\\r\\n                                                               2023\\r\\n\\r\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800            2021           \u28f0\u28fe\u28ff\u28f6\u2844\u2800\u2800\u2800\u2800\u2800\\r\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28002019\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800     \u2839\u28ffV4\u2844\u2877\u2800\u2800\u2800\u2800\u2800   \\r\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800 \u2880\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800 \u28e4\u28fe\u28ff\u28f7\u28e6\u2840\u2800\u2800\u2800\u2800   \u28ff\u28ff\u284f\u2801\u2800\u2800\u2800\u2800\u2800   \\r\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800 \u2880\u28f4\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u2800\u2800\u2800 \u2880\u28ff\u28ff\u28ff\u28ff\u28ff\u2804\u2800\u2800\u2800  \u28f0\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800\u2800\u2800   \\r\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800 \u2880\u28f4\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800 \u2880\u28f4\u28ff\u28ff\u28ff\u281f\u281b\u280b\u2800\u2800\u2800 \u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800   \\r\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800 \u2880\u28f4\u28ff\u28ff\u28ff\u28ff\u28ff\u281f\u2809\u2809\u2809\u2801\u2880\u28f4\u28ff\u28ffV3\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800  \u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28c7\u2800\u2800\u2800\u2800\u2800\u2800   \\r\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800 \u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u281b\u2800\u2800\u2800\u2800\u2800 \u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2801\u2800\u2800\u2800\u2800\u2800 \u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u2840\u2800\u2800\u2800\u2800   \\r\\n\u2800\u2800\u2800        2017\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28fc\u28ff\u28ffV2\u28ff\u28ff\u287f\u2800\u2800\u2800\u2800\u2800\u2800\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28c4\u2800\u2800\u2800\u2800\u2800\u2800 \u28b9\u28ff \u28ff\u28ff\u28ff\u28ff\u2819\u28bf\u28c6\u2800\u2800\u2800   \\r\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28e4\u28f4\u28e6\u28e4\u2800\u2800\u2800\u2800\u2800\u2880\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e6\u2840\u2800\u2800\u2800\u2800\u2808\u28bb\u28ff\u28ff\u28ff\u28ff\u281b\u283f\u283f\u2836\u2836\u28f6\u2800  \u28ff \u28b8\u28ff\u28ff\u28ff\u28ff\u28c6\u2839\u2807\u2800\u2800   \\r\\n\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28e0\u28f4\u28ff\u28ff\u28ff\u28ff\u28f7\u2846\u2800\u2800\u2800\u2800\u2838\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u2809\u281b\u28bf\u28f7\u2844\u2800\u2800\u2800\u28b8\u28ff\u28ff\u28ff\u28ff\u28e6\u2840\u2800\u2800\u2800\u2800\u2800  \u2839\u2807\u28ff\u28ff\u28ff\u28ff\u28ff\u2846\u2800\u2800\u2800\u2800   \\r\\n\u2800\u2800\u2800\u2800\u28e0\u28f4\u28ff\u28ffV1\u28ff\u28ff\u28ff\u284f\u281b\u2803\u2800\u2800\u2800\u2800\u2800\u2839\u28ff\u28ff\u28ff\u28ff\u28ff\u28c7\u2800\u2800\u2818\u280b\u2801\u2800\u2800\u2800\u2808\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800\u2800\u2800  \u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u2800\u2800\u2800\u2800   \\r\\n\u2800\u2800\u28e0\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e6\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800 \u2838\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2800\u2800\u2800\u2800  \u2800\u28ff\u28ff\u285f\u28bf\u28ff\u28ff\u2800\u2800\u2800\u2800   \\r\\n\u2800\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u281b\u2809\u2819\u28ff\u28ff\u28ff\u28e6\u2840\u2800\u2800\u2800\u2800\u2800 \u2888\u28ff\u28ff\u285f\u28b9\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28ff\u28ff\u287f\u2808\u28ff\u28ff\u285f\u2800\u2800\u2800\u2800\u2800  \u28b8\u28ff\u28ff\u2800\u28b8\u28ff\u28ff\u2800\u2800\u2800\u2800   \\r\\n\u2800\u2800\u2839\u28ff\u28ff\u28ff\u28ff\u28f7\u2840\u2800\u283b\u28ff\u28ff\u28ff\u28ff\u28f6\u28c4\u2800\u2800\u2800\u28b0\u28ff\u28ff\u285f\u2801\u28fe\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u2880\u28f6\u28ff\u281f\u280b\u2800\u28bc\u28ff\u28ff\u2803\u2800\u2800\u2800\u2800\u2800  \u28ff\u28ff\u2801\u2800\u28b9\u28ff\u28ff\u2800\u2800\u2800\u2800   \\r\\n\u2800\u2880\u28f4\u28ff\u287f\u280b\u28b9\u28ff\u2847\u2800\u2800\u2808\u2819\u28ff\u28c7\u2819\u28ff\u28f7\u2800\u2800\u28b8\u28ff\u285f\u2800\u2800\u28bb\u28ff\u284f\u2800\u2800\u2800\u2800\u2800\u2880\u28fc\u287f\u2801\u2800\u2800\u2800\u2818\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800   \u28a8\u28ff\u2847\u2800\u2800\u2800\u28ff\u28ff\u2800\u2800\u2800\u2800   \\r\\n\u28f4\u28ff\u285f\u2809\u2800\u2800\u28fe\u28ff\u2847\u2800\u2800\u2800\u2800\u2888\u28ff\u2844\u2800\u2809\u2800\u2800\u28fc\u28ff\u2846\u2800\u2800\u28b8\u28ff\u28f7\u2800\u2800\u2800\u2800\u28b4\u28ff\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\u28ff\u28ef\u2840\u2800\u2800\u2800\u2800    \u28b8\u28ff\u28c7\u2800\u2800\u2800\u28ba\u28ff\u2844\u2800\u2800\u2800   \\r\\n\u2808\u283b\u2837\u2804\u2800\u2800\u28ff\u28ff\u28f7\u28e4\u28e0\u2800\u2800\u2808\u283d\u2837\u2800\u2800\u2800\u2838\u281f\u281b\u281b\u2812\u2836\u2838\u28ff\u28ff\u28f7\u28e6\u28e4\u28c4\u2808\u283b\u2837\u2804\u2800\u2800\u2800\u283e\u283f\u283f\u28ff\u28f6\u28e4\u2800    \u2818\u281b\u281b\u281b\u2812\u2800\u2838\u283f\u283f\u2826 \\r\\n\\r\\n\\r\\nTelegram: https://t.me/ChaintoolsOfficial\\r\\nWebsite: https://www.chaintools.ai/\\r\\nWhitepaper: https://chaintools-whitepaper.gitbook.io/\\r\\nTwitter: https://twitter.com/ChaintoolsTech\\r\\ndApp: https://www.chaintools.wtf/\\r\\n*/\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n// import \\\"forge-std/console.sol\\\";\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router02 {\\r\\n    function getAmountsOut(uint256 amountIn, address[] memory path)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint256 amountTokenDesired,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (\\r\\n            uint256 amountToken,\\r\\n            uint256 amountETH,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n}\\r\\n\\r\\ninterface IV2Pair {\\r\\n    function swap(\\r\\n        uint256 amount0Out,\\r\\n        uint256 amount1Out,\\r\\n        address to,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n    function token0() external view returns (address);\\r\\n\\r\\n    function burn(address to)\\r\\n        external\\r\\n        returns (uint256 amount0, uint256 amount1);\\r\\n}\\r\\n\\r\\ninterface IV3Pool {\\r\\n    function liquidity() external view returns (uint128 Liq);\\r\\n\\r\\n    struct Info {\\r\\n        uint128 liquidity;\\r\\n        uint256 feeGrowthInside0LastX128;\\r\\n        uint256 feeGrowthInside1LastX128;\\r\\n        uint128 tokensOwed0;\\r\\n        uint128 tokensOwed1;\\r\\n    }\\r\\n\\r\\n    function initialize(uint160 sqrtPriceX96) external;\\r\\n\\r\\n    function positions(bytes32 key)\\r\\n        external\\r\\n        view\\r\\n        returns (IV3Pool.Info memory liqInfo);\\r\\n\\r\\n    function swap(\\r\\n        address recipient,\\r\\n        bool zeroForOne,\\r\\n        int256 amountSpecified,\\r\\n        uint160 sqrtPriceLimitX96,\\r\\n        bytes memory data\\r\\n    ) external returns (int256 amount0, int256 amount1);\\r\\n\\r\\n    function burn(\\r\\n        int24 tickLower,\\r\\n        int24 tickUpper,\\r\\n        uint128 amount\\r\\n    ) external returns (uint256 amount0, uint256 amount1);\\r\\n\\r\\n    function collect(\\r\\n        address recipient,\\r\\n        int24 tickLower,\\r\\n        int24 tickUpper,\\r\\n        uint128 amount0Requested,\\r\\n        uint128 amount1Requested\\r\\n    ) external returns (uint128 amount0, uint128 amount1);\\r\\n\\r\\n    function token0() external view returns (address);\\r\\n\\r\\n    function token1() external view returns (address);\\r\\n\\r\\n    function slot0()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint160,\\r\\n            int24,\\r\\n            uint16,\\r\\n            uint16,\\r\\n            uint16,\\r\\n            uint8,\\r\\n            bool\\r\\n        );\\r\\n\\r\\n    function flash(\\r\\n        address recipient,\\r\\n        uint256 amount0,\\r\\n        uint256 amount1,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n    function uniswapV3FlashCallback(\\r\\n        uint256 fee0,\\r\\n        uint256 fee1,\\r\\n        bytes memory data\\r\\n    ) external;\\r\\n\\r\\n    function mint(\\r\\n        address recipient,\\r\\n        int24 tickLower,\\r\\n        int24 tickUpper,\\r\\n        uint128 amount,\\r\\n        bytes calldata data\\r\\n    ) external returns (uint256 amount0, uint256 amount1);\\r\\n}\\r\\n\\r\\ninterface IWETH {\\r\\n    function withdraw(uint256 wad) external;\\r\\n\\r\\n    function approve(address who, uint256 wad) external returns (bool);\\r\\n\\r\\n    function deposit() external payable;\\r\\n\\r\\n    function transfer(address dst, uint256 wad) external returns (bool);\\r\\n\\r\\n    function balanceOf(address _owner) external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IQuoterV2 {\\r\\n    function quoteExactInputSingle(\\r\\n        address tokenIn,\\r\\n        address tokenOut,\\r\\n        uint24 fee,\\r\\n        uint256 amountIn,\\r\\n        uint160 sqrtPriceLimitX96\\r\\n    ) external returns (uint256 amountOut);\\r\\n}\\r\\n\\r\\ninterface IV3Factory {\\r\\n    function getPool(\\r\\n        address token0,\\r\\n        address token1,\\r\\n        uint24 poolFee\\r\\n    ) external view returns (address);\\r\\n\\r\\n    function createPool(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint24 fee\\r\\n    ) external returns (address);\\r\\n}\\r\\n\\r\\ninterface INonfungiblePositionManager {\\r\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\r\\n\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n\\r\\n    struct IncreaseLiquidityParams {\\r\\n        uint256 tokenId;\\r\\n        uint256 amount0Desired;\\r\\n        uint256 amount1Desired;\\r\\n        uint256 amount0Min;\\r\\n        uint256 amount1Min;\\r\\n        uint256 deadline;\\r\\n    }\\r\\n\\r\\n    function increaseLiquidity(\\r\\n        INonfungiblePositionManager.IncreaseLiquidityParams calldata params\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint128 liquidity,\\r\\n            uint256 amount0,\\r\\n            uint256 amount1\\r\\n        );\\r\\n\\r\\n    function tokenOfOwnerByIndex(address owner, uint256 index)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 tokenId);\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) external;\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function factory() external view returns (address);\\r\\n\\r\\n    struct MintParams {\\r\\n        address token0;\\r\\n        address token1;\\r\\n        uint24 fee;\\r\\n        int24 tickLower;\\r\\n        int24 tickUpper;\\r\\n        uint256 amount0Desired;\\r\\n        uint256 amount1Desired;\\r\\n        uint256 amount0Min;\\r\\n        uint256 amount1Min;\\r\\n        address recipient;\\r\\n        uint256 deadline;\\r\\n    }\\r\\n\\r\\n    function mint(MintParams calldata mp)\\r\\n        external\\r\\n        payable\\r\\n        returns (\\r\\n            uint256 tokenId,\\r\\n            uint128 liquidity,\\r\\n            uint256 amount0,\\r\\n            uint256 amount1\\r\\n        );\\r\\n\\r\\n    function collect(CollectParams calldata params)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint256 amount0, uint256 amount1);\\r\\n\\r\\n    struct CollectParams {\\r\\n        uint256 tokenId;\\r\\n        address recipient;\\r\\n        uint128 amount0Max;\\r\\n        uint128 amount1Max;\\r\\n    }\\r\\n\\r\\n    struct DecreaseLiquidityParams {\\r\\n        uint256 tokenId;\\r\\n        uint128 liquidity;\\r\\n        uint256 amount0Min;\\r\\n        uint256 amount1Min;\\r\\n        uint256 deadline;\\r\\n    }\\r\\n\\r\\n    function decreaseLiquidity(DecreaseLiquidityParams calldata dl)\\r\\n        external\\r\\n        returns (uint256 amount0, uint256 amount1);\\r\\n\\r\\n    function positions(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint96 nonce,\\r\\n            address operator,\\r\\n            address token0,\\r\\n            address token1,\\r\\n            uint24 fee,\\r\\n            int24 tickLower,\\r\\n            int24 tickUpper,\\r\\n            uint128 liquidity,\\r\\n            uint256 feeGrowthInside0LastX128,\\r\\n            uint256 feeGrowthInside1LastX128,\\r\\n            uint128 tokensOwed0,\\r\\n            uint128 tokensOwed1\\r\\n        );\\r\\n}\\r\\n\\r\\ninterface IRouterV3 {\\r\\n    function factory() external view returns (address);\\r\\n\\r\\n    function WETH9() external view returns (address);\\r\\n\\r\\n    struct ExactInputSingleParams {\\r\\n        address tokenIn;\\r\\n        address tokenOut;\\r\\n        uint24 fee;\\r\\n        address recipient;\\r\\n        uint256 deadline;\\r\\n        uint256 amountIn;\\r\\n        uint256 amountOutMinimum;\\r\\n        uint160 sqrtPriceLimitX96;\\r\\n    }\\r\\n    struct ExactOutputSingleParams {\\r\\n        address tokenIn;\\r\\n        address tokenOut;\\r\\n        uint24 fee;\\r\\n        address recipient;\\r\\n        uint256 deadline;\\r\\n        uint256 amountOut;\\r\\n        uint256 amountInMaximum;\\r\\n        uint160 sqrtPriceLimitX96;\\r\\n    }\\r\\n\\r\\n    function exactOutputSingle(ExactOutputSingleParams calldata params)\\r\\n        external\\r\\n        returns (uint256 amountIn);\\r\\n\\r\\n    function exactInputSingle(ExactInputSingleParams calldata params)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint256 amountOut);\\r\\n}\\r\\n\\r\\n// Credits: https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/TickMath.sol\\r\\nlibrary TickMath {\\r\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\r\\n    int24 internal constant MIN_TICK = -887272;\\r\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\r\\n    int24 internal constant MAX_TICK = 887272;\\r\\n\\r\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\r\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\r\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\r\\n    uint160 internal constant MAX_SQRT_RATIO =\\r\\n        1461446703485210103287273052203988822378723970342;\\r\\n\\r\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\r\\n    /// @dev Throws if |tick| > max tick\\r\\n    /// @param tick The input tick for the above formula\\r\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\r\\n    /// at the given tick\\r\\n    function getSqrtRatioAtTick(int24 tick)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint160 sqrtPriceX96)\\r\\n    {\\r\\n        uint256 absTick = tick < 0\\r\\n            ? uint256(-int256(tick))\\r\\n            : uint256(int256(tick));\\r\\n        require(absTick <= uint256(int256(MAX_TICK)), \\\"T\\\");\\r\\n\\r\\n        uint256 ratio = absTick & 0x1 != 0\\r\\n            ? 0xfffcb933bd6fad37aa2d162d1a594001\\r\\n            : 0x100000000000000000000000000000000;\\r\\n        if (absTick & 0x2 != 0)\\r\\n            ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\r\\n        if (absTick & 0x4 != 0)\\r\\n            ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\r\\n        if (absTick & 0x8 != 0)\\r\\n            ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\r\\n        if (absTick & 0x10 != 0)\\r\\n            ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\r\\n        if (absTick & 0x20 != 0)\\r\\n            ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\r\\n        if (absTick & 0x40 != 0)\\r\\n            ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\r\\n        if (absTick & 0x80 != 0)\\r\\n            ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\r\\n        if (absTick & 0x100 != 0)\\r\\n            ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\r\\n        if (absTick & 0x200 != 0)\\r\\n            ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\r\\n        if (absTick & 0x400 != 0)\\r\\n            ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\r\\n        if (absTick & 0x800 != 0)\\r\\n            ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\r\\n        if (absTick & 0x1000 != 0)\\r\\n            ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\r\\n        if (absTick & 0x2000 != 0)\\r\\n            ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\r\\n        if (absTick & 0x4000 != 0)\\r\\n            ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\r\\n        if (absTick & 0x8000 != 0)\\r\\n            ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\r\\n        if (absTick & 0x10000 != 0)\\r\\n            ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\r\\n        if (absTick & 0x20000 != 0)\\r\\n            ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\r\\n        if (absTick & 0x40000 != 0)\\r\\n            ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\r\\n        if (absTick & 0x80000 != 0)\\r\\n            ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\r\\n\\r\\n        if (tick > 0) ratio = type(uint256).max / ratio;\\r\\n\\r\\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\r\\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\r\\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\r\\n        sqrtPriceX96 = uint160(\\r\\n            (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract ChainTools is Context, IERC20, IERC20Metadata {\\r\\n    using TickMath for uint160;\\r\\n\\r\\n    IUniswapV2Router02 internal immutable router;\\r\\n    INonfungiblePositionManager internal immutable positionManager;\\r\\n    YieldBooster internal YIELD_BOOSTER;\\r\\n    YieldVault internal YIELD_VAULT;\\r\\n    address internal immutable uniswapV3Pool;\\r\\n    address internal immutable multiSig;\\r\\n    address internal immutable WETH;\\r\\n    address internal immutable v3Router;\\r\\n    address internal immutable apest;\\r\\n\\r\\n    uint256 public immutable MAX_SUPPLY;\\r\\n\\r\\n    uint8 internal triggerOnApproval;\\r\\n    uint8 internal tokenomicsOn;\\r\\n    uint32 internal startStamp;\\r\\n    uint32 internal lastRewardStamp;\\r\\n    uint80 internal issuanceRate;\\r\\n\\r\\n    uint256 internal _totalSupply;\\r\\n\\r\\n    mapping(address => uint256) internal _balances;\\r\\n    mapping(address => mapping(address => uint256)) internal _allowances;\\r\\n\\r\\n    mapping(address => bool) internal isTaxExcluded;\\r\\n    mapping(address => bool) internal badPool;\\r\\n\\r\\n    mapping(address => address) internal upperRef;\\r\\n    mapping(address => uint256) internal sandwichLock;\\r\\n\\r\\n    event zapIn(\\r\\n        address indexed from,\\r\\n        uint256 tokenId,\\r\\n        uint256 flag,\\r\\n        uint256 amtETHIn,\\r\\n        uint256 amtTokensIn\\r\\n    );\\r\\n    event rewardLPETH(uint256 amtETHIn);\\r\\n    event rewardLPTOKEN(uint256 amtTokenIn);\\r\\n    event referralPaid(address indexed from, address indexed to, uint256 amt);\\r\\n\\r\\n    error MinMax();\\r\\n    error ZeroAddress();\\r\\n    error Auth();\\r\\n    error Sando();\\r\\n\\r\\n    constructor(address _multisig, address _apest) {\\r\\n        MAX_SUPPLY = 15_000_000e18;\\r\\n        multiSig = _multisig;\\r\\n        apest = _apest;\\r\\n        tokenomicsOn = 1;\\r\\n        issuanceRate = 100e18;\\r\\n        v3Router = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\\r\\n        router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n        WETH = IRouterV3(v3Router).WETH9();\\r\\n\\r\\n        positionManager = INonfungiblePositionManager(\\r\\n            0xC36442b4a4522E871399CD717aBDD847Ab11FE88\\r\\n        );\\r\\n\\r\\n        uniswapV3Pool = IV3Factory(positionManager.factory()).createPool(\\r\\n            WETH,\\r\\n            address(this),\\r\\n            10000\\r\\n        );\\r\\n\\r\\n        require(IV3Pool(uniswapV3Pool).token0() == WETH, \\\"token0pool0\\\");\\r\\n\\r\\n        //Initial supply\\r\\n        uint256 forLp = 600_000e18;\\r\\n        _totalSupply += forLp;\\r\\n        _balances[address(this)] += forLp;\\r\\n        emit Transfer(address(0), address(this), forLp);\\r\\n\\r\\n        uint256 forMarketing = 600_000e18;\\r\\n        _totalSupply += forMarketing;\\r\\n        _balances[_multisig] += forMarketing;\\r\\n        emit Transfer(address(0), multiSig, forMarketing);\\r\\n\\r\\n        int24 startTick = -106400;\\r\\n        IV3Pool(uniswapV3Pool).initialize(\\r\\n            TickMath.getSqrtRatioAtTick(-startTick)\\r\\n        );\\r\\n        IERC20(WETH).approve(address(positionManager), type(uint256).max);\\r\\n        IERC20(WETH).approve(v3Router, type(uint256).max);\\r\\n\\r\\n        _allowances[address(this)][v3Router] = type(uint256).max;\\r\\n        _allowances[address(this)][address(positionManager)] = type(uint256)\\r\\n            .max;\\r\\n\\r\\n        isTaxExcluded[v3Router] = true;\\r\\n        isTaxExcluded[multiSig] = true;\\r\\n        isTaxExcluded[address(this)] = true;\\r\\n    }\\r\\n\\r\\n    function prepareFomo(address yieldVault, address yieldBooster) external {\\r\\n        if (msg.sender != apest) revert Auth();\\r\\n        if (startStamp > 0) revert MinMax();\\r\\n\\r\\n        //Compounder\\r\\n        YIELD_VAULT = YieldVault(yieldVault);\\r\\n        isTaxExcluded[address(YIELD_VAULT)] = true;\\r\\n        _allowances[address(YIELD_VAULT)][address(positionManager)] = type(\\r\\n            uint256\\r\\n        ).max;\\r\\n        _allowances[address(YIELD_VAULT)][address(v3Router)] = type(uint256)\\r\\n            .max;\\r\\n        //Yield Booster\\r\\n        YIELD_BOOSTER = YieldBooster(payable(yieldBooster));\\r\\n\\r\\n        _allowances[address(YIELD_BOOSTER)][address(positionManager)] = type(\\r\\n            uint256\\r\\n        ).max;\\r\\n\\r\\n        isTaxExcluded[address(YIELD_BOOSTER)] = true;\\r\\n        _totalSupply += 100_000e18;\\r\\n        _balances[address(YIELD_BOOSTER)] += 100_000e18;\\r\\n        emit Transfer(address(0), address(YIELD_BOOSTER), 100_000e18);\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    function openTrading() external payable {\\r\\n        if (msg.sender != apest) revert Auth();\\r\\n        startStamp = uint32(block.timestamp);\\r\\n\\r\\n        int24 startTick = -106400;\\r\\n        int24 tick = -startTick;\\r\\n\\r\\n        tick = (tick / 200) * 200;\\r\\n        uint256 a0;\\r\\n        uint256 a1;\\r\\n        IWETH(WETH).deposit{value: msg.value}();\\r\\n        (, , a0, a1) = positionManager.mint(\\r\\n            INonfungiblePositionManager.MintParams({\\r\\n                token0: WETH,\\r\\n                token1: address(this),\\r\\n                fee: 10000,\\r\\n                tickLower: tick - 420000,\\r\\n                tickUpper: tick + 420000,\\r\\n                amount0Desired: msg.value,\\r\\n                amount1Desired: 600_000e18,\\r\\n                amount0Min: 0,\\r\\n                amount1Min: 0,\\r\\n                recipient: address(this),\\r\\n                deadline: block.timestamp\\r\\n            })\\r\\n        );\\r\\n\\r\\n        positionManager.setApprovalForAll(address(YIELD_VAULT), true);\\r\\n\\r\\n        uint256 leftOver2 = 600_000e18 - a1;\\r\\n        uint256 leftOver = IERC20(WETH).balanceOf(address(this));\\r\\n\\r\\n        if (leftOver != 0) {\\r\\n            IERC20(WETH).transfer(multiSig, leftOver - 1);\\r\\n        }\\r\\n\\r\\n        _basicTransfer(address(this), multiSig, leftOver2);\\r\\n        lastRewardStamp = uint32(block.timestamp);\\r\\n\\r\\n        YIELD_BOOSTER.preventFragmentations(address(0));\\r\\n\\r\\n        triggerOnApproval = 1;\\r\\n    }\\r\\n\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return \\\"ChainTools\\\";\\r\\n    }\\r\\n\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return \\\"CTLS\\\";\\r\\n    }\\r\\n\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account)\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function transfer(address to, uint256 amount)\\r\\n        public\\r\\n        virtual\\r\\n        override\\r\\n        returns (bool)\\r\\n    {\\r\\n        _transfer(_msgSender(), to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender)\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount)\\r\\n        public\\r\\n        virtual\\r\\n        override\\r\\n        returns (bool)\\r\\n    {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        if (triggerOnApproval != 0) try this.swapBack() {} catch {}\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        address spender = _msgSender();\\r\\n        _approve(from, spender, _allowances[from][spender] - amount);\\r\\n        _transfer(from, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _basicTransfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal returns (bool) {\\r\\n        _balances[sender] -= amount;\\r\\n        unchecked {\\r\\n            _balances[recipient] += amount;\\r\\n        }\\r\\n        if (\\r\\n            sender != address(YIELD_BOOSTER) &&\\r\\n            recipient != address(YIELD_BOOSTER) &&\\r\\n            recipient != address(positionManager)\\r\\n        ) emit Transfer(sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        if (owner == address(0)) revert ZeroAddress();\\r\\n        if (spender == address(0)) revert ZeroAddress();\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal returns (bool) {\\r\\n        //determine trader\\r\\n        address trader = sender == uniswapV3Pool ? recipient : sender;\\r\\n        if (sender != uniswapV3Pool && recipient != uniswapV3Pool)\\r\\n            trader = sender;\\r\\n\\r\\n        if (startStamp == 0) {\\r\\n            revert MinMax();\\r\\n        }\\r\\n\\r\\n        if (\\r\\n            trader != address(this) &&\\r\\n            trader != address(YIELD_BOOSTER) &&\\r\\n            trader != address(positionManager) &&\\r\\n            trader != address(YIELD_VAULT)\\r\\n        ) {\\r\\n            //One Block Delay [Sandwich/Frontrun Protection]\\r\\n            if (sandwichLock[trader] < block.number) {\\r\\n                sandwichLock[trader] = block.number + 1;\\r\\n            } else {\\r\\n                revert Sando();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (tokenomicsOn != 0) {\\r\\n            if (amount < 1e8 || amount > 2_000_000e18) revert MinMax();\\r\\n        } else {\\r\\n            return _basicTransfer(sender, recipient, amount);\\r\\n        }\\r\\n        //Normal Transfer\\r\\n        if (\\r\\n            sender != uniswapV3Pool &&\\r\\n            sender != address(positionManager) &&\\r\\n            recipient != uniswapV3Pool\\r\\n        ) {\\r\\n            if (badPool[recipient]) revert Auth();\\r\\n            try this.swapBack() {} catch {}\\r\\n            return _basicTransfer(sender, recipient, amount);\\r\\n        }\\r\\n\\r\\n        if (\\r\\n            recipient == uniswapV3Pool ||\\r\\n            recipient == address(positionManager) ||\\r\\n            isTaxExcluded[sender] ||\\r\\n            isTaxExcluded[recipient]\\r\\n        ) {\\r\\n            return _basicTransfer(sender, recipient, amount);\\r\\n        }\\r\\n\\r\\n        unchecked {\\r\\n            if (sender != uniswapV3Pool) {\\r\\n                try this.swapBack() {} catch {}\\r\\n            }\\r\\n        }\\r\\n\\r\\n        _balances[sender] -= amount;\\r\\n\\r\\n        //Tax & Final transfer amounts\\r\\n        unchecked {\\r\\n            uint256 tFee = amount / 20;\\r\\n\\r\\n            if (\\r\\n                //Only first 10 minutes\\r\\n                block.timestamp < startStamp + 10 minutes\\r\\n            ) {\\r\\n                //Sniper bots funding lp rewards\\r\\n                tFee *= 2;\\r\\n            }\\r\\n\\r\\n            amount -= tFee;\\r\\n            //if sender is not position manager tax go to contract\\r\\n            if (sender != address(positionManager)) {\\r\\n                _balances[address(this)] += tFee;\\r\\n            } else if (sender == address(positionManager)) {\\r\\n                address ref = upperRef[recipient] != address(0)\\r\\n                    ? upperRef[recipient]\\r\\n                    : multiSig;\\r\\n                uint256 rFee0 = tFee / 5;\\r\\n                _balances[ref] += rFee0;\\r\\n                emit Transfer(recipient, ref, tFee);\\r\\n                tFee -= rFee0;\\r\\n\\r\\n                emit referralPaid(recipient, ref, rFee0);\\r\\n\\r\\n                _balances[address(YIELD_BOOSTER)] += tFee;\\r\\n            }\\r\\n\\r\\n            _balances[recipient] += amount;\\r\\n        }\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function swapBack() public {\\r\\n        unchecked {\\r\\n            uint256 fullAmount = _balances[address(this)];\\r\\n            if (fullAmount < _totalSupply / 2000) {\\r\\n                return;\\r\\n            }\\r\\n            if (\\r\\n                msg.sender != address(this) &&\\r\\n                msg.sender != address(YIELD_VAULT) &&\\r\\n                msg.sender != address(YIELD_BOOSTER)\\r\\n            ) revert Auth();\\r\\n            //0.25% max per swap\\r\\n            uint256 maxSwap = _totalSupply / 400;\\r\\n\\r\\n            if (fullAmount > maxSwap) {\\r\\n                fullAmount = maxSwap;\\r\\n            }\\r\\n\\r\\n            IRouterV3(v3Router).exactInputSingle(\\r\\n                IRouterV3.ExactInputSingleParams({\\r\\n                    tokenIn: address(this),\\r\\n                    tokenOut: WETH,\\r\\n                    fee: 10000,\\r\\n                    recipient: address(this),\\r\\n                    deadline: block.timestamp,\\r\\n                    amountIn: fullAmount,\\r\\n                    amountOutMinimum: 0,\\r\\n                    sqrtPriceLimitX96: 0\\r\\n                })\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function sendLPRewardsETH() internal {\\r\\n        address sendToken = WETH;\\r\\n        unchecked {\\r\\n            assembly {\\r\\n                let bal := balance(address())\\r\\n                if gt(bal, 10000000000) {\\r\\n                    let inputMem := mload(0x40)\\r\\n                    mstore(inputMem, 0xd0e30db)\\r\\n                    pop(call(gas(), sendToken, bal, inputMem, 0x4, 0, 0))\\r\\n                }\\r\\n            }\\r\\n\\r\\n            uint256 fin = IERC20(WETH).balanceOf(address(this)) - 1;\\r\\n            address rec = multiSig;\\r\\n            assembly {\\r\\n                let inputMem := mload(0x40)\\r\\n                mstore(\\r\\n                    inputMem,\\r\\n                    0xa9059cbb00000000000000000000000000000000000000000000000000000000\\r\\n                )\\r\\n                mstore(add(inputMem, 0x04), rec)\\r\\n                mstore(add(inputMem, 0x24), div(mul(fin, 65), 100))\\r\\n                pop(call(gas(), sendToken, 0, inputMem, 0x44, 0, 0))\\r\\n            }\\r\\n            rec = uniswapV3Pool;\\r\\n            assembly {\\r\\n                let inputMem := mload(0x40)\\r\\n                mstore(\\r\\n                    inputMem,\\r\\n                    0xa9059cbb00000000000000000000000000000000000000000000000000000000\\r\\n                )\\r\\n                mstore(add(inputMem, 0x04), rec)\\r\\n                mstore(add(inputMem, 0x24), div(mul(fin, 35), 100))\\r\\n                pop(call(gas(), sendToken, 0, inputMem, 0x44, 0, 0))\\r\\n            }\\r\\n\\r\\n            emit rewardLPETH((fin * 35) / 100);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function flashReward() external {\\r\\n        if (\\r\\n            msg.sender != address(this) &&\\r\\n            msg.sender != address(YIELD_VAULT) &&\\r\\n            msg.sender != address(multiSig) &&\\r\\n            msg.sender != address(YIELD_BOOSTER)\\r\\n        ) revert Auth();\\r\\n        if (IV3Pool(uniswapV3Pool).liquidity() != 0) {\\r\\n            IV3Pool(uniswapV3Pool).flash(address(this), 0, 0, \\\"\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function uniswapV3FlashCallback(\\r\\n        uint256,\\r\\n        uint256,\\r\\n        bytes calldata\\r\\n    ) external {\\r\\n        if (msg.sender != uniswapV3Pool) revert Auth();\\r\\n        uint256 secondsPassed = block.timestamp - lastRewardStamp;\\r\\n        if (secondsPassed > 30 minutes) {\\r\\n            sendLPRewardsETH();\\r\\n            lastRewardStamp = uint32(block.timestamp);\\r\\n\\r\\n            if (issuanceRate == 0) return;\\r\\n\\r\\n            uint256 pending = (secondsPassed / 60) * issuanceRate;\\r\\n            if (_totalSupply + pending < MAX_SUPPLY) {\\r\\n                unchecked {\\r\\n                    _balances[uniswapV3Pool] += pending;\\r\\n                    _totalSupply += pending;\\r\\n                    emit Transfer(address(0), uniswapV3Pool, pending);\\r\\n                }\\r\\n            }\\r\\n            emit rewardLPTOKEN(pending);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _collectLPRewards(uint256 tokenId)\\r\\n        internal\\r\\n        returns (uint256 c0, uint256 c1)\\r\\n    {\\r\\n        (c0, c1) = positionManager.collect(\\r\\n            INonfungiblePositionManager.CollectParams({\\r\\n                tokenId: tokenId,\\r\\n                recipient: address(this),\\r\\n                amount0Max: type(uint128).max,\\r\\n                amount1Max: type(uint128).max\\r\\n            })\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _decreasePosition(uint256 tokenId, uint128 liquidity)\\r\\n        internal\\r\\n        returns (uint256 a0, uint256 a1)\\r\\n    {\\r\\n        positionManager.decreaseLiquidity(\\r\\n            INonfungiblePositionManager.DecreaseLiquidityParams({\\r\\n                tokenId: tokenId,\\r\\n                liquidity: liquidity,\\r\\n                amount0Min: 0,\\r\\n                amount1Min: 0,\\r\\n                deadline: block.timestamp\\r\\n            })\\r\\n        );\\r\\n        (a0, a1) = _collectLPRewards(tokenId);\\r\\n    }\\r\\n\\r\\n    function _swapV3(\\r\\n        address tokenIn,\\r\\n        address tokenOut,\\r\\n        uint24 poolFee,\\r\\n        uint256 amountIn,\\r\\n        uint256 minOut\\r\\n    ) internal returns (uint256 out) {\\r\\n        if (tokenIn != WETH && tokenIn != address(this)) {\\r\\n            tokenIn.call(\\r\\n                abi.encodeWithSelector(\\r\\n                    IERC20.approve.selector,\\r\\n                    address(v3Router),\\r\\n                    amountIn\\r\\n                )\\r\\n            );\\r\\n        }\\r\\n        require(tokenIn == WETH || tokenOut == WETH, \\\"unsupported_pair\\\");\\r\\n        out = IRouterV3(v3Router).exactInputSingle(\\r\\n            IRouterV3.ExactInputSingleParams({\\r\\n                tokenIn: tokenIn,\\r\\n                tokenOut: tokenOut,\\r\\n                fee: poolFee,\\r\\n                recipient: address(this),\\r\\n                deadline: block.timestamp,\\r\\n                amountIn: amountIn,\\r\\n                amountOutMinimum: minOut,\\r\\n                sqrtPriceLimitX96: 0\\r\\n            })\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function zapFromV2LPToken(\\r\\n        address fromToken,\\r\\n        uint256 amountIn,\\r\\n        uint128 minOut,\\r\\n        uint128 minOut2,\\r\\n        uint256 flag,\\r\\n        address ref\\r\\n    ) external returns (uint256 tokenId) {\\r\\n        fromToken.call(\\r\\n            abi.encodeWithSelector(\\r\\n                IERC20.transferFrom.selector,\\r\\n                msg.sender,\\r\\n                fromToken,\\r\\n                amountIn\\r\\n            )\\r\\n        );\\r\\n\\r\\n        bool isToken0Weth = IV2Pair(fromToken).token0() == WETH;\\r\\n\\r\\n        (uint256 removed0, uint256 removed1) = IV2Pair(fromToken).burn(\\r\\n            address(this)\\r\\n        );\\r\\n        uint256 bef = address(this).balance;\\r\\n        uint256 finalAmt = isToken0Weth ? removed0 : removed1;\\r\\n        address _weth = WETH;\\r\\n\\r\\n        //withdraw weth\\r\\n        assembly {\\r\\n            let inputMem := mload(0x40)\\r\\n            mstore(\\r\\n                inputMem,\\r\\n                0x2e1a7d4d00000000000000000000000000000000000000000000000000000000\\r\\n            )\\r\\n            mstore(add(inputMem, 0x04), finalAmt)\\r\\n            pop(call(gas(), _weth, 0, inputMem, 0x24, 0, 0))\\r\\n        }\\r\\n        finalAmt = isToken0Weth ? removed1 : removed0;\\r\\n        _weth = IV3Pool(fromToken).token0();\\r\\n        address approvalToken = YIELD_VAULT.findApprovalToken(fromToken);\\r\\n        if (approvalToken != address(0)) {\\r\\n            approvalToken.call(\\r\\n                abi.encodeWithSelector(\\r\\n                    IERC20.approve.selector,\\r\\n                    address(router),\\r\\n                    amountIn\\r\\n                )\\r\\n            );\\r\\n        }\\r\\n\\r\\n        address[] memory path2 = new address[](2);\\r\\n        path2[0] = approvalToken;\\r\\n        path2[1] = WETH;\\r\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            finalAmt,\\r\\n            minOut,\\r\\n            path2,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n\\r\\n        tokenId = this.zapFromETH{value: address(this).balance - bef}(\\r\\n            minOut2,\\r\\n            msg.sender,\\r\\n            flag,\\r\\n            ref\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function zapFromV3LPToken(\\r\\n        uint256 tokenId,\\r\\n        uint256 minOut,\\r\\n        uint256 minOut2,\\r\\n        uint256 flag,\\r\\n        address ref\\r\\n    ) external payable returns (uint256 tokenIdNew) {\\r\\n        if (positionManager.ownerOf(tokenId) != msg.sender) revert Auth();\\r\\n        (address token0, address token1, uint128 liquidity) = YIELD_VAULT\\r\\n            .getPosition(tokenId);\\r\\n        (uint256 c0, uint256 c1) = _decreasePosition(\\r\\n            tokenId,\\r\\n            (liquidity * uint128(msg.value)) / 100\\r\\n        );\\r\\n\\r\\n        uint256 gotOut = _swapV3(\\r\\n            token0 == WETH ? token1 : token0,\\r\\n            WETH,\\r\\n            YIELD_VAULT.findPoolFee(token0, token1),\\r\\n            token0 == WETH ? c1 : c0,\\r\\n            minOut\\r\\n        );\\r\\n\\r\\n        uint256 totalWETH = token0 == WETH ? c0 + gotOut : c1 + gotOut;\\r\\n        address _weth = WETH;\\r\\n        assembly {\\r\\n            let inputMem := mload(0x40)\\r\\n            mstore(\\r\\n                inputMem,\\r\\n                0x2e1a7d4d00000000000000000000000000000000000000000000000000000000\\r\\n            )\\r\\n            mstore(add(inputMem, 0x04), totalWETH)\\r\\n            pop(call(gas(), _weth, 0, inputMem, 0x24, 0, 0))\\r\\n        }\\r\\n\\r\\n        return\\r\\n            this.zapFromETH{value: totalWETH}(minOut2, msg.sender, flag, ref);\\r\\n    }\\r\\n\\r\\n    function zapFromToken(\\r\\n        address fromToken,\\r\\n        uint256 amountIn,\\r\\n        uint256 minOut,\\r\\n        uint256 minOut2,\\r\\n        bool isV2,\\r\\n        uint24 poolFee,\\r\\n        uint256 flag,\\r\\n        address ref\\r\\n    ) external returns (uint256 tokenId) {\\r\\n        address _weth = WETH;\\r\\n\\r\\n        fromToken.call(\\r\\n            abi.encodeWithSelector(\\r\\n                IERC20.transferFrom.selector,\\r\\n                msg.sender,\\r\\n                address(this),\\r\\n                amountIn\\r\\n            )\\r\\n        );\\r\\n\\r\\n        if (fromToken == WETH) {\\r\\n            assembly {\\r\\n                let inputMem := mload(0x40)\\r\\n                mstore(\\r\\n                    inputMem,\\r\\n                    0x2e1a7d4d00000000000000000000000000000000000000000000000000000000\\r\\n                )\\r\\n                mstore(add(inputMem, 0x04), amountIn)\\r\\n                pop(call(gas(), _weth, 0, inputMem, 0x24, 0, 0))\\r\\n            }\\r\\n            return\\r\\n                this.zapFromETH{value: amountIn}(\\r\\n                    minOut2,\\r\\n                    msg.sender,\\r\\n                    flag,\\r\\n                    ref\\r\\n                );\\r\\n        }\\r\\n\\r\\n        if (isV2) {\\r\\n            if (fromToken != address(this) && fromToken != WETH) {\\r\\n                fromToken.call(\\r\\n                    abi.encodeWithSelector(\\r\\n                        IERC20.approve.selector,\\r\\n                        address(router),\\r\\n                        amountIn\\r\\n                    )\\r\\n                );\\r\\n            }\\r\\n            uint256 bef = address(this).balance;\\r\\n            address[] memory path2 = new address[](2);\\r\\n            path2[0] = fromToken;\\r\\n            path2[1] = WETH;\\r\\n            router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n                amountIn,\\r\\n                minOut,\\r\\n                path2,\\r\\n                address(this),\\r\\n                block.timestamp\\r\\n            );\\r\\n            return\\r\\n                this.zapFromETH{value: address(this).balance - bef}(\\r\\n                    minOut2,\\r\\n                    msg.sender,\\r\\n                    flag,\\r\\n                    ref\\r\\n                );\\r\\n        } else {\\r\\n            if (fromToken != address(this) && fromToken != WETH) {\\r\\n                fromToken.call(\\r\\n                    abi.encodeWithSelector(\\r\\n                        IERC20.approve.selector,\\r\\n                        v3Router,\\r\\n                        amountIn\\r\\n                    )\\r\\n                );\\r\\n            }\\r\\n            uint256 gotOut = IRouterV3(v3Router).exactInputSingle(\\r\\n                IRouterV3.ExactInputSingleParams({\\r\\n                    tokenIn: fromToken,\\r\\n                    tokenOut: WETH,\\r\\n                    fee: poolFee,\\r\\n                    recipient: address(this),\\r\\n                    deadline: block.timestamp,\\r\\n                    amountIn: amountIn,\\r\\n                    amountOutMinimum: minOut,\\r\\n                    sqrtPriceLimitX96: 0\\r\\n                })\\r\\n            );\\r\\n            assembly {\\r\\n                let inputMem := mload(0x40)\\r\\n                mstore(\\r\\n                    inputMem,\\r\\n                    0x2e1a7d4d00000000000000000000000000000000000000000000000000000000\\r\\n                )\\r\\n                mstore(add(inputMem, 0x04), gotOut)\\r\\n                pop(call(gas(), _weth, 0, inputMem, 0x24, 0, 0))\\r\\n            }\\r\\n            return\\r\\n                this.zapFromETH{value: gotOut}(minOut2, msg.sender, flag, ref);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _mintPosition(\\r\\n        uint256 amt0Desired,\\r\\n        uint256 amount1Desired,\\r\\n        uint256 flag,\\r\\n        address to\\r\\n    )\\r\\n        internal\\r\\n        returns (\\r\\n            uint256 tokenId,\\r\\n            uint256 amt0Consumed,\\r\\n            uint256 amt1Consumed\\r\\n        )\\r\\n    {\\r\\n        int24 tick = YIELD_VAULT.getCurrentTick();\\r\\n        int24 tickDist = YieldVault(YIELD_VAULT).getTickDistance(flag);\\r\\n        (tokenId, , amt0Consumed, amt1Consumed) = positionManager.mint(\\r\\n            INonfungiblePositionManager.MintParams({\\r\\n                token0: WETH,\\r\\n                token1: address(this),\\r\\n                fee: 10000,\\r\\n                tickLower: tick - tickDist < int24(-887000)\\r\\n                    ? int24(-887000)\\r\\n                    : tick - tickDist,\\r\\n                tickUpper: tick + tickDist > int24(887000)\\r\\n                    ? int24(887000)\\r\\n                    : tick + tickDist,\\r\\n                amount0Desired: amt0Desired,\\r\\n                amount1Desired: amount1Desired,\\r\\n                amount0Min: 0,\\r\\n                amount1Min: 0,\\r\\n                recipient: to,\\r\\n                deadline: block.timestamp\\r\\n            })\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _zapFromWETH(\\r\\n        uint256 minOut,\\r\\n        uint256 finalAmt,\\r\\n        uint256 flag,\\r\\n        address to\\r\\n    ) internal returns (uint256 tokenId) {\\r\\n        unchecked {\\r\\n            uint256 startTickDeviation = YIELD_VAULT.getStartTickDeviation(\\r\\n                YIELD_VAULT.getCurrentTick()\\r\\n            );\\r\\n\\r\\n            uint256 gotTokens;\\r\\n\\r\\n            uint256 deviationAmt = YIELD_VAULT.getDeviation(\\r\\n                finalAmt,\\r\\n                startTickDeviation\\r\\n            );\\r\\n            gotTokens = IRouterV3(v3Router).exactInputSingle(\\r\\n                IRouterV3.ExactInputSingleParams({\\r\\n                    tokenIn: WETH,\\r\\n                    tokenOut: address(this),\\r\\n                    fee: 10000,\\r\\n                    recipient: address(this),\\r\\n                    deadline: block.timestamp,\\r\\n                    amountIn: deviationAmt,\\r\\n                    amountOutMinimum: minOut,\\r\\n                    sqrtPriceLimitX96: 0\\r\\n                })\\r\\n            );\\r\\n            finalAmt -= deviationAmt;\\r\\n            uint256 a1Out;\\r\\n            (tokenId, deviationAmt, a1Out) = _mintPosition(\\r\\n                finalAmt,\\r\\n                gotTokens,\\r\\n                flag,\\r\\n                to\\r\\n            );\\r\\n\\r\\n            if (a1Out > gotTokens) revert MinMax();\\r\\n            if (deviationAmt > finalAmt) revert MinMax();\\r\\n\\r\\n            address sendToken = WETH;\\r\\n            assembly {\\r\\n                let inputMem := mload(0x40)\\r\\n                mstore(\\r\\n                    inputMem,\\r\\n                    0xa9059cbb00000000000000000000000000000000000000000000000000000000\\r\\n                )\\r\\n                mstore(add(inputMem, 0x04), to)\\r\\n                mstore(add(inputMem, 0x24), sub(finalAmt, deviationAmt))\\r\\n                pop(call(gas(), sendToken, 0, inputMem, 0x44, 0, 0))\\r\\n            }\\r\\n\\r\\n            _basicTransfer(address(this), to, gotTokens - a1Out);\\r\\n\\r\\n            emit zapIn(to, tokenId, flag, deviationAmt, gotTokens);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function zapFromETH(\\r\\n        uint256 minOut,\\r\\n        address to,\\r\\n        uint256 flag,\\r\\n        address upper\\r\\n    ) external payable returns (uint256 tokenId) {\\r\\n        address _d = address(YIELD_BOOSTER);\\r\\n        address cUpper = upperRef[tx.origin];\\r\\n        //handle referrals\\r\\n        {\\r\\n            if (\\r\\n                upper != tx.origin &&\\r\\n                cUpper == address(0) &&\\r\\n                upper != address(0)\\r\\n            ) {\\r\\n                upperRef[tx.origin] = upper;\\r\\n            }\\r\\n            if (upperRef[tx.origin] == address(0)) {\\r\\n                cUpper = _d;\\r\\n            } else {\\r\\n                cUpper = upperRef[tx.origin];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        unchecked {\\r\\n            uint256 finalAmt = msg.value;\\r\\n            uint256 forReferral = finalAmt / 100; //1%\\r\\n            uint256 forMarketing = forReferral * 3; //3% (1.5% lp) (1.5% market0ng)\\r\\n\\r\\n            finalAmt -= (forReferral + forMarketing);\\r\\n            forMarketing /= 2; //half lp, half marketing\\r\\n            address sendToken = WETH;\\r\\n            assembly {\\r\\n                pop(call(gas(), _d, forMarketing, \\\"\\\", 0, 0, 0))\\r\\n                //limit gas\\r\\n                pop(call(7000, cUpper, forReferral, \\\"\\\", 0, 0, 0))\\r\\n                let inputMem := mload(0x40)\\r\\n                //wrap eth\\r\\n                mstore(inputMem, 0xd0e30db)\\r\\n                pop(call(gas(), sendToken, finalAmt, inputMem, 0x4, 0, 0))\\r\\n            }\\r\\n\\r\\n            emit referralPaid(to, cUpper, forReferral);\\r\\n\\r\\n            return _zapFromWETH(minOut, finalAmt, flag, to);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //Protocol FUNCTIONS\\r\\n    function adjustFomo(\\r\\n        uint16 flag,\\r\\n        uint256 amount,\\r\\n        address who\\r\\n    ) external {\\r\\n        if (flag == 5) {\\r\\n            //prevent liquidity fragmentation\\r\\n            if (msg.sender != address(YIELD_BOOSTER)) revert Auth();\\r\\n            require(IV3Pool(who).token0() != address(0)); //will revert if non-pair contract\\r\\n            require(who != uniswapV3Pool);\\r\\n            badPool[who] = !badPool[who];\\r\\n        } else {\\r\\n            if (msg.sender != multiSig) revert Auth();\\r\\n\\r\\n            if (flag == 0) {\\r\\n                //Shutdown tokenomics [emergency only!]\\r\\n                require(amount == 0 || amount == 1);\\r\\n                tokenomicsOn = uint8(amount);\\r\\n            } else if (flag == 1) {\\r\\n                //Change issuance rate\\r\\n                require(amount <= 100e18);\\r\\n                issuanceRate = uint80(amount);\\r\\n            } else if (flag == 2) {\\r\\n                //Exclude from tax\\r\\n                require(who != address(this) && who != uniswapV3Pool);\\r\\n                isTaxExcluded[who] = !isTaxExcluded[who];\\r\\n            } else if (flag == 3) {\\r\\n                //New YIELD_VAULT implementation\\r\\n                positionManager.setApprovalForAll(address(YIELD_VAULT), false);\\r\\n                YIELD_VAULT = YieldVault(who);\\r\\n                positionManager.setApprovalForAll(address(who), true);\\r\\n                isTaxExcluded[who] = true;\\r\\n                _allowances[who][address(positionManager)] = type(uint256).max;\\r\\n            } else if (flag == 4) {\\r\\n                //Unlock LP\\r\\n                require(block.timestamp >= startStamp + (1 days * 30 * 4));\\r\\n                positionManager.transferFrom(address(this), multiSig, amount);\\r\\n            } else if (flag == 6) {\\r\\n                require(amount == 0 || amount == 1);\\r\\n                triggerOnApproval = uint8(amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //old -> new token migration\\r\\n    function completeMigration(\\r\\n        address[] calldata addressList,\\r\\n        uint256[] calldata tokenAmounts\\r\\n    ) external payable {\\r\\n        require(addressList.length == tokenAmounts.length);\\r\\n        require(startStamp == 0, \\\"already_complete\\\");\\r\\n        if (msg.sender != apest) revert Auth();\\r\\n        uint256 size = uint256(addressList.length);\\r\\n\\r\\n        for (uint256 i; i < size; ) {\\r\\n            unchecked {\\r\\n                address adr = addressList[i];\\r\\n                uint256 amt = tokenAmounts[i];\\r\\n                _balances[adr] = amt;\\r\\n                emit Transfer(address(0), adr, amt);\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //GETTERS\\r\\n    function getIsTaxExcluded(address who) external view returns (bool) {\\r\\n        return isTaxExcluded[who];\\r\\n    }\\r\\n\\r\\n    function getUpperRef(address who) external view returns (address) {\\r\\n        return upperRef[who];\\r\\n    }\\r\\n\\r\\n    function getYieldBooster() external view returns (address yb) {\\r\\n        return address(YIELD_BOOSTER);\\r\\n    }\\r\\n\\r\\n    function getV3Pool() external view returns (address pool) {\\r\\n        pool = uniswapV3Pool;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract YieldBooster {\\r\\n    INonfungiblePositionManager internal immutable positionManager;\\r\\n    address internal immutable token;\\r\\n    address internal immutable pool;\\r\\n    address internal immutable multiSig;\\r\\n    address internal immutable WETH;\\r\\n    address internal immutable v3Router;\\r\\n    address internal immutable YIELD_VAULT;\\r\\n    address internal immutable keeper;\\r\\n    event YIELDBOOSTED(uint256 token0, uint256 token1);\\r\\n    event REWARDPOOLFEE(uint256 totalVolume);\\r\\n\\r\\n    constructor(\\r\\n        address _CTLS,\\r\\n        address _pool,\\r\\n        address _yield_vault,\\r\\n        address _mSig\\r\\n    ) {\\r\\n        token = _CTLS;\\r\\n        pool = _pool;\\r\\n        v3Router = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\\r\\n        multiSig = _mSig;\\r\\n        YIELD_VAULT = _yield_vault;\\r\\n        positionManager = INonfungiblePositionManager(\\r\\n            0xC36442b4a4522E871399CD717aBDD847Ab11FE88\\r\\n        );\\r\\n        keeper = YieldVault(YIELD_VAULT).keeper();\\r\\n        WETH = IRouterV3(v3Router).WETH9();\\r\\n    }\\r\\n\\r\\n    function preventFragmentations(address who) external {\\r\\n        require(msg.sender == multiSig || msg.sender == token, \\\"multiSig\\\");\\r\\n        if (who == address(0)) {\\r\\n            address fac = positionManager.factory();\\r\\n            address _pool = IV3Factory(fac).createPool(WETH, token, 3000);\\r\\n            ChainTools(payable(token)).adjustFomo(5, 0, _pool);\\r\\n            _pool = IV3Factory(fac).createPool(WETH, token, 500);\\r\\n            ChainTools(payable(token)).adjustFomo(5, 0, _pool);\\r\\n        } else {\\r\\n            ChainTools(payable(token)).adjustFomo(5, 0, who);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function yield(\\r\\n        uint256 id,\\r\\n        uint256 times,\\r\\n        uint256 startAmt,\\r\\n        uint256 flag,\\r\\n        uint128 a0,\\r\\n        uint128 a1,\\r\\n        address to\\r\\n    ) external returns (uint256 c2, uint256 c3) {\\r\\n        require(msg.sender == multiSig || msg.sender == keeper, \\\"multiSig\\\");\\r\\n        bool breakLoop;\\r\\n        for (uint256 i; i < times; ) {\\r\\n            unchecked {\\r\\n                int256 borrow2;\\r\\n                if (!breakLoop) {\\r\\n                    try\\r\\n                        IV3Pool(pool).swap(\\r\\n                            address(this),\\r\\n                            false,\\r\\n                            -int256(startAmt),\\r\\n                            1461446703485210103287273052203988822378723970341,\\r\\n                            \\\"\\\"\\r\\n                        )\\r\\n                    returns (int256 _a1, int256) {\\r\\n                        borrow2 = _a1;\\r\\n                    } catch {\\r\\n                        breakLoop = true;\\r\\n                    }\\r\\n                    try\\r\\n                        IV3Pool(pool).swap(\\r\\n                            address(this),\\r\\n                            true,\\r\\n                            -int256(borrow2),\\r\\n                            4295128740,\\r\\n                            \\\"\\\"\\r\\n                        )\\r\\n                    {} catch {\\r\\n                        breakLoop = true;\\r\\n                    }\\r\\n                } else {\\r\\n                    break;\\r\\n                }\\r\\n\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n        try YieldVault(YIELD_VAULT).buyback(flag, a0, a1, to, id) returns (\\r\\n            uint256 c0,\\r\\n            uint256 c1\\r\\n        ) {\\r\\n            c2 = c0;\\r\\n            c3 = c1;\\r\\n        } catch {}\\r\\n\\r\\n        emit REWARDPOOLFEE(startAmt * times * 2);\\r\\n    }\\r\\n\\r\\n    function uniswapV3SwapCallback(\\r\\n        int256 amount0Delta,\\r\\n        int256 amount1Delta,\\r\\n        bytes calldata\\r\\n    ) external {\\r\\n        address _pool = pool;\\r\\n        assembly {\\r\\n            if iszero(eq(caller(), _pool)) {\\r\\n                revert(0, 0)\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (amount0Delta < 0) {\\r\\n            address sendToken = token;\\r\\n\\r\\n            assembly {\\r\\n                let inputMem := mload(0x40)\\r\\n                mstore(\\r\\n                    inputMem,\\r\\n                    0xa9059cbb00000000000000000000000000000000000000000000000000000000\\r\\n                )\\r\\n                mstore(add(inputMem, 0x04), _pool)\\r\\n                mstore(add(inputMem, 0x24), amount1Delta)\\r\\n                pop(call(gas(), sendToken, 0, inputMem, 0x44, 0, 0))\\r\\n            }\\r\\n        } else {\\r\\n            address sendToken = WETH;\\r\\n            assembly {\\r\\n                let inputMem := mload(0x40)\\r\\n                mstore(\\r\\n                    inputMem,\\r\\n                    0xa9059cbb00000000000000000000000000000000000000000000000000000000\\r\\n                )\\r\\n                mstore(add(inputMem, 0x04), _pool)\\r\\n                mstore(add(inputMem, 0x24), amount0Delta)\\r\\n                pop(call(gas(), sendToken, 0, inputMem, 0x44, 0, 0))\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdraw(\\r\\n        address token,\\r\\n        address toAddress,\\r\\n        uint256 amount\\r\\n    ) external {\\r\\n        require(msg.sender == multiSig, \\\"multiSig\\\");\\r\\n        if (amount != 0) IERC20(token).transfer(toAddress, amount);\\r\\n        if (address(this).balance > 0) {\\r\\n            multiSig.call{value: address(this).balance}(\\\"\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n}\\r\\n\\r\\ncontract YieldVault {\\r\\n    struct Pending {\\r\\n        uint128 amount0;\\r\\n        uint128 amount1;\\r\\n    }\\r\\n\\r\\n    INonfungiblePositionManager internal immutable positionManager;\\r\\n\\r\\n    address internal immutable quoter;\\r\\n    address internal immutable CTLS;\\r\\n    address internal immutable WETH;\\r\\n    address internal immutable multiSig;\\r\\n    address internal immutable v3Router;\\r\\n    address internal immutable uniswapV3Pool;\\r\\n    address public keeper;\\r\\n    uint256 internal minCompAmtETH = 2e17;\\r\\n\\r\\n    mapping(uint256 => Pending) internal balances;\\r\\n    mapping(address => uint128) internal refBalances;\\r\\n\\r\\n    error Auth();\\r\\n    error Max0();\\r\\n    error Max1();\\r\\n\\r\\n    event referralPaid(\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256 amount\\r\\n    );\\r\\n    event Compounded(uint256 indexed tokenId, uint256 c0, uint256 c1);\\r\\n    event ShiftedPosition(\\r\\n        uint256 indexed tokenIdOld,\\r\\n        uint256 indexed tokenIdNew,\\r\\n        uint256 flag,\\r\\n        uint256 t0,\\r\\n        uint256 t1\\r\\n    );\\r\\n    event BoughtBack(uint256 indexed flag, uint256 a0, uint256 a1);\\r\\n    event limitOrderCreated(\\r\\n        address indexed who,\\r\\n        uint256 tokenId,\\r\\n        uint256 flag,\\r\\n        uint256 amount0Or1,\\r\\n        bool isWETH\\r\\n    );\\r\\n\\r\\n    constructor(\\r\\n        address _CTLS,\\r\\n        address _keeper,\\r\\n        address _uniPool,\\r\\n        address _dev\\r\\n    ) {\\r\\n        positionManager = INonfungiblePositionManager(\\r\\n            0xC36442b4a4522E871399CD717aBDD847Ab11FE88\\r\\n        );\\r\\n        CTLS = _CTLS;\\r\\n        v3Router = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\\r\\n        WETH = IRouterV3(v3Router).WETH9();\\r\\n        IERC20(WETH).approve(address(positionManager), type(uint256).max);\\r\\n\\r\\n        quoter = 0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6;\\r\\n        keeper = _keeper;\\r\\n        multiSig = _dev;\\r\\n        IERC20(WETH).approve(address(v3Router), type(uint256).max);\\r\\n\\r\\n        uniswapV3Pool = _uniPool;\\r\\n    }\\r\\n\\r\\n    //CallStatic\\r\\n    function filterReady(\\r\\n        uint256[] calldata tokenIds,\\r\\n        uint256 minAmount0,\\r\\n        uint256 minAmount1\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256[] memory readyToComp,\\r\\n            uint256[] memory amt0,\\r\\n            uint256[] memory amt1,\\r\\n            uint256 gasSpent,\\r\\n            uint256 txCostInETH\\r\\n        )\\r\\n    {\\r\\n        if (msg.sender != keeper) revert Auth();\\r\\n        unchecked {\\r\\n            try ChainTools(payable(CTLS)).swapBack() {} catch {}\\r\\n            try ChainTools(payable(CTLS)).flashReward() {} catch {}\\r\\n\\r\\n            uint256 startGas = gasleft();\\r\\n            uint256 tokenIdsL = tokenIds.length;\\r\\n            readyToComp = new uint256[](tokenIdsL);\\r\\n            amt0 = new uint256[](tokenIdsL);\\r\\n            amt1 = new uint256[](tokenIdsL);\\r\\n            for (uint256 i; i < tokenIdsL; ) {\\r\\n                uint256 tokenId = tokenIds[i];\\r\\n                address tokenOwner = positionManager.ownerOf(tokenId);\\r\\n                if (tokenId != 0) {\\r\\n                    try\\r\\n                        positionManager.collect(\\r\\n                            INonfungiblePositionManager.CollectParams({\\r\\n                                tokenId: tokenId,\\r\\n                                recipient: address(this),\\r\\n                                amount0Max: type(uint128).max,\\r\\n                                amount1Max: type(uint128).max\\r\\n                            })\\r\\n                        )\\r\\n                    returns (uint256 claimed0, uint256 claimed1) {\\r\\n                        Pending memory pen = balances[tokenId];\\r\\n                        refBalances[\\r\\n                            ChainTools(payable(CTLS)).getUpperRef(tokenOwner)\\r\\n                        ] = uint128(claimed0 / 100);\\r\\n                        balances[1].amount0 += uint128(claimed0 / 20);\\r\\n                        balances[1].amount1 += uint128(claimed1 / 25);\\r\\n                        claimed0 -= (claimed0 / 20) + (claimed0 / 100);\\r\\n                        claimed1 -= claimed1 / 25;\\r\\n\\r\\n                        //Add Pending Earned Referral Rewards into Personal Pending Rewards\\r\\n                        pen.amount0 +=\\r\\n                            uint128(claimed0) +\\r\\n                            refBalances[tokenOwner];\\r\\n                        pen.amount1 += uint128(claimed1);\\r\\n\\r\\n                        //Reset pending referal\\r\\n                        refBalances[tokenOwner] = 0;\\r\\n                        if (claimed0 > minAmount0 && claimed1 > minAmount1) {\\r\\n                            readyToComp[i] = tokenId;\\r\\n                            amt0[i] = claimed0;\\r\\n                            amt1[i] = claimed1;\\r\\n                        }\\r\\n\\r\\n                        balances[tokenId] = pen;\\r\\n                    } catch {}\\r\\n                }\\r\\n\\r\\n                ++i;\\r\\n            }\\r\\n\\r\\n            gasSpent = startGas - gasleft();\\r\\n            txCostInETH = tx.gasprice * gasSpent;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function unite(uint256[] calldata tokenIds)\\r\\n        external\\r\\n        returns (\\r\\n            uint256[] memory reverting,\\r\\n            uint256 pFee0,\\r\\n            uint256 pFee1\\r\\n        )\\r\\n    {\\r\\n        if (msg.sender != keeper) revert Auth();\\r\\n        unchecked {\\r\\n            try ChainTools(payable(CTLS)).swapBack() {} catch {}\\r\\n            try ChainTools(payable(CTLS)).flashReward() {} catch {}\\r\\n\\r\\n            uint256 tokenIdsL = tokenIds.length;\\r\\n            reverting = new uint256[](tokenIds.length);\\r\\n            for (uint256 i; i < tokenIdsL; ) {\\r\\n                uint256 tokenId = tokenIds[i];\\r\\n                address tokenOwner = positionManager.ownerOf(tokenId);\\r\\n                try\\r\\n                    positionManager.collect(\\r\\n                        INonfungiblePositionManager.CollectParams({\\r\\n                            tokenId: tokenId,\\r\\n                            recipient: address(this),\\r\\n                            amount0Max: type(uint128).max,\\r\\n                            amount1Max: type(uint128).max\\r\\n                        })\\r\\n                    )\\r\\n                returns (uint256 claimed0, uint256 claimed1) {\\r\\n                    Pending memory pen = balances[tokenId];\\r\\n\\r\\n                    //Compound Tax + Token Tax (10% TOTAL) [5% in WETH] [5% in TOKENS]\\r\\n                    //9% protocol, 1% ref\\r\\n                    pFee0 = claimed0 / 20;\\r\\n                    pFee1 = claimed1 / 25;\\r\\n                    uint256 rFee0 = claimed0 / 100;\\r\\n\\r\\n                    claimed0 -= (pFee0 + rFee0);\\r\\n                    claimed1 -= pFee1;\\r\\n\\r\\n                    balances[1].amount0 += uint128(pFee0);\\r\\n                    balances[1].amount1 += uint128(pFee1);\\r\\n\\r\\n                    //Determine Referal\\r\\n                    refBalances[\\r\\n                        ChainTools(payable(CTLS)).getUpperRef(tokenOwner)\\r\\n                    ] = uint128(rFee0);\\r\\n\\r\\n                    //Add Pending Earned Referral Rewards into Personal Pending Rewards\\r\\n                    pen.amount0 += uint128(claimed0) + refBalances[tokenOwner];\\r\\n                    pen.amount1 += uint128(claimed1);\\r\\n\\r\\n                    //Reset pending referal\\r\\n                    refBalances[tokenOwner] = 0;\\r\\n\\r\\n                    if (claimed0 != 0 && claimed1 != 0) {\\r\\n                        try this.increaseLiq(tokenId, pen) {} catch {\\r\\n                            //CallStatic catch reverting -> exclude from call\\r\\n                            //If revert during real call, update balances to sync referral rewards\\r\\n                            balances[tokenId] = pen;\\r\\n                            reverting[i] = tokenId;\\r\\n                        }\\r\\n                    } else {\\r\\n                        reverting[i] = tokenId;\\r\\n                        balances[tokenId] = pen;\\r\\n                    }\\r\\n                } catch {\\r\\n                    reverting[i] = tokenId;\\r\\n                }\\r\\n\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function increaseLiq(uint256 tokenId, Pending memory pen)\\r\\n        external\\r\\n        returns (uint256 collected0, uint256 collected1)\\r\\n    {\\r\\n        if (msg.sender != address(this)) revert Auth();\\r\\n        (, collected0, collected1) = positionManager.increaseLiquidity(\\r\\n            INonfungiblePositionManager.IncreaseLiquidityParams({\\r\\n                tokenId: tokenId,\\r\\n                amount0Desired: pen.amount0,\\r\\n                amount1Desired: pen.amount1,\\r\\n                amount0Min: 0,\\r\\n                amount1Min: 0,\\r\\n                deadline: block.timestamp\\r\\n            })\\r\\n        );\\r\\n        if (\\r\\n            collected0 > pen.amount0 &&\\r\\n            collected0 > IERC20(WETH).balanceOf(address(this))\\r\\n        ) revert Max0();\\r\\n        if (\\r\\n            collected1 > pen.amount1 &&\\r\\n            collected1 > IERC20(CTLS).balanceOf(address(this))\\r\\n        ) revert Max1();\\r\\n        balances[tokenId].amount0 = (pen.amount0 - uint128(collected0));\\r\\n        balances[tokenId].amount1 = (pen.amount1 - uint128(collected1));\\r\\n        emit Compounded(tokenId, collected0, collected1);\\r\\n    }\\r\\n\\r\\n    function withdraw_yield(\\r\\n        uint256 tokenId,\\r\\n        uint128 amount0,\\r\\n        uint128 amount1\\r\\n    ) public {\\r\\n        address tokenOwner = positionManager.ownerOf(tokenId);\\r\\n        if (tokenId == 1) tokenOwner = multiSig;\\r\\n        if (tokenOwner != msg.sender) revert Auth();\\r\\n        unchecked {\\r\\n            if (amount0 == 0 && amount1 == 0) {\\r\\n                amount0 = balances[tokenId].amount0;\\r\\n                amount1 = balances[tokenId].amount1;\\r\\n                balances[tokenId].amount0 = 0;\\r\\n                balances[tokenId].amount1 = 0;\\r\\n                IERC20(WETH).transfer(tokenOwner, amount0);\\r\\n                IERC20(CTLS).transfer(tokenOwner, amount1);\\r\\n            } else if (amount0 != 0 && amount1 != 0) {\\r\\n                if (amount0 > balances[tokenId].amount0) revert Max0();\\r\\n                if (amount1 > balances[tokenId].amount1) revert Max1();\\r\\n                balances[tokenId].amount0 -= amount0;\\r\\n                balances[tokenId].amount1 -= amount1;\\r\\n\\r\\n                IERC20(WETH).transfer(tokenOwner, amount0);\\r\\n                IERC20(CTLS).transfer(tokenOwner, amount1);\\r\\n            } else if (amount0 == 0 && amount1 != 0) {\\r\\n                if (amount1 > balances[tokenId].amount1) revert Max1();\\r\\n                balances[tokenId].amount1 -= amount1;\\r\\n                IERC20(CTLS).transfer(tokenOwner, amount1);\\r\\n            } else if (amount0 != 0 && amount1 == 0) {\\r\\n                if (amount0 > balances[tokenId].amount0) revert Max0();\\r\\n                balances[tokenId].amount0 -= amount0;\\r\\n                IERC20(WETH).transfer(tokenOwner, amount0);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdraw_yield_many(\\r\\n        uint256[] calldata tokenIds,\\r\\n        uint128[] calldata amt0,\\r\\n        uint128[] calldata amt1\\r\\n    ) external {\\r\\n        unchecked {\\r\\n            uint256 size = tokenIds.length;\\r\\n            require(size == amt0.length && size == amt1.length, \\\"L\\\");\\r\\n            for (uint256 i; i < size; ) {\\r\\n                withdraw_yield(tokenIds[i], amt0[i], amt1[i]);\\r\\n\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdraw_referral_rewards(uint128 amount0) external {\\r\\n        unchecked {\\r\\n            if (amount0 == 0) {\\r\\n                amount0 = refBalances[msg.sender];\\r\\n                refBalances[msg.sender] = 0;\\r\\n                IERC20(WETH).transfer(msg.sender, amount0);\\r\\n            } else if (amount0 != 0) {\\r\\n                if (amount0 > refBalances[msg.sender]) revert Max0();\\r\\n                refBalances[msg.sender] -= amount0;\\r\\n                IERC20(WETH).transfer(msg.sender, amount0);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //PROTOCOL LP/FEES\\r\\n    function buyback(\\r\\n        uint256 flag,\\r\\n        uint128 internalWETHAmt,\\r\\n        uint128 internalTokenAmt,\\r\\n        address to,\\r\\n        uint256 id\\r\\n    ) external returns (uint256 t0, uint256 t1) {\\r\\n        if (tx.origin != keeper && msg.sender != multiSig) revert Auth();\\r\\n\\r\\n        (t0, t1) = positionManager.collect(\\r\\n            INonfungiblePositionManager.CollectParams({\\r\\n                tokenId: id,\\r\\n                recipient: address(this),\\r\\n                amount0Max: type(uint128).max,\\r\\n                amount1Max: type(uint128).max\\r\\n            })\\r\\n        );\\r\\n        unchecked {\\r\\n            balances[1].amount0 += uint128(t0);\\r\\n            balances[1].amount1 += uint128(t1);\\r\\n        }\\r\\n\\r\\n        if (\\r\\n            balances[1].amount0 >= internalWETHAmt &&\\r\\n            balances[1].amount1 >= internalTokenAmt\\r\\n        ) {\\r\\n            unchecked {\\r\\n                balances[1].amount0 -= internalWETHAmt;\\r\\n                balances[1].amount1 -= internalTokenAmt;\\r\\n            }\\r\\n\\r\\n            if (flag == 0) {\\r\\n                try ChainTools(payable(CTLS)).flashReward() {} catch {} //lp reward only\\r\\n            } else if (flag == 1) {\\r\\n                //buyback only\\r\\n                uint256 gotTokens = IRouterV3(v3Router).exactInputSingle(\\r\\n                    IRouterV3.ExactInputSingleParams({\\r\\n                        tokenIn: WETH,\\r\\n                        tokenOut: CTLS,\\r\\n                        fee: 10000,\\r\\n                        recipient: to,\\r\\n                        deadline: block.timestamp,\\r\\n                        amountIn: internalWETHAmt,\\r\\n                        amountOutMinimum: 0,\\r\\n                        sqrtPriceLimitX96: 0\\r\\n                    })\\r\\n                );\\r\\n                emit BoughtBack(flag, internalWETHAmt, gotTokens);\\r\\n            } else if (flag == 2) {\\r\\n                //buyback+lp reward\\r\\n                uint256 gotTokens = IRouterV3(v3Router).exactInputSingle(\\r\\n                    IRouterV3.ExactInputSingleParams({\\r\\n                        tokenIn: WETH,\\r\\n                        tokenOut: CTLS,\\r\\n                        fee: 10000,\\r\\n                        recipient: ChainTools(payable(CTLS)).getYieldBooster(),\\r\\n                        deadline: block.timestamp,\\r\\n                        amountIn: (internalWETHAmt - (internalWETHAmt / 2)),\\r\\n                        amountOutMinimum: 0,\\r\\n                        sqrtPriceLimitX96: 0\\r\\n                    })\\r\\n                );\\r\\n                emit BoughtBack(flag, internalWETHAmt, gotTokens);\\r\\n                try ChainTools(payable(CTLS)).flashReward() {} catch {}\\r\\n            } else if (flag == 3) {\\r\\n                //buyback + swapback + send rewards\\r\\n                uint256 gotTokens = IRouterV3(v3Router).exactInputSingle(\\r\\n                    IRouterV3.ExactInputSingleParams({\\r\\n                        tokenIn: WETH,\\r\\n                        tokenOut: CTLS,\\r\\n                        fee: 10000,\\r\\n                        recipient: to,\\r\\n                        deadline: block.timestamp,\\r\\n                        amountIn: internalWETHAmt,\\r\\n                        amountOutMinimum: 0,\\r\\n                        sqrtPriceLimitX96: 0\\r\\n                    })\\r\\n                );\\r\\n                emit BoughtBack(flag, internalWETHAmt, gotTokens);\\r\\n                try ChainTools(payable(CTLS)).swapBack() {} catch {}\\r\\n                try ChainTools(payable(CTLS)).flashReward() {} catch {}\\r\\n            }\\r\\n        } else {\\r\\n            revert Max0();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _collectLPRewards(uint256 tokenId)\\r\\n        internal\\r\\n        returns (uint128 c0, uint128 c1)\\r\\n    {\\r\\n        (uint256 c0u, uint256 c1u) = positionManager.collect(\\r\\n            INonfungiblePositionManager.CollectParams({\\r\\n                tokenId: tokenId,\\r\\n                recipient: address(this),\\r\\n                amount0Max: type(uint128).max,\\r\\n                amount1Max: type(uint128).max\\r\\n            })\\r\\n        );\\r\\n\\r\\n        c0 = uint128(c0u);\\r\\n        c1 = uint128(c1u);\\r\\n    }\\r\\n\\r\\n    function _decreasePosition(uint256 tokenId, uint128 liquidity)\\r\\n        internal\\r\\n        returns (uint128 a0, uint128 a1)\\r\\n    {\\r\\n        positionManager.decreaseLiquidity(\\r\\n            INonfungiblePositionManager.DecreaseLiquidityParams({\\r\\n                tokenId: tokenId,\\r\\n                liquidity: liquidity,\\r\\n                amount0Min: 0,\\r\\n                amount1Min: 0,\\r\\n                deadline: block.timestamp\\r\\n            })\\r\\n        );\\r\\n\\r\\n        (a0, a1) = _collectLPRewards(tokenId);\\r\\n    }\\r\\n\\r\\n    function shiftPosition(\\r\\n        uint256 tokenId,\\r\\n        uint256 flag,\\r\\n        uint256 min0Out,\\r\\n        uint256 min1Out\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256 newTokenId,\\r\\n            uint256 min0,\\r\\n            uint256 min1\\r\\n        )\\r\\n    {\\r\\n        address tokenOwner = positionManager.ownerOf(tokenId);\\r\\n        if (msg.sender != tokenOwner) revert Auth();\\r\\n        (, , uint128 liq) = this.getPosition(tokenId);\\r\\n        (uint128 WETHRemoved, uint128 tokensRemoved) = _decreasePosition(\\r\\n            tokenId,\\r\\n            liq\\r\\n        );\\r\\n\\r\\n        if (WETHRemoved > 1e6 && tokensRemoved >= 10e18) {\\r\\n            //Token Tax (3% TOTAL) [1.5% in WETH] [1.5% in TOKENS]\\r\\n            unchecked {\\r\\n                liq = WETHRemoved / 100; //ref\\r\\n\\r\\n                //protocol\\r\\n                balances[1].amount0 += liq;\\r\\n                balances[1].amount1 += tokensRemoved / 100;\\r\\n\\r\\n                WETHRemoved -= liq * 2; //ref+protocol\\r\\n                tokensRemoved -= tokensRemoved / 100;\\r\\n            }\\r\\n\\r\\n            {\\r\\n                address upper = ChainTools(payable(CTLS)).getUpperRef(\\r\\n                    tokenOwner\\r\\n                );\\r\\n                upper == address(0)\\r\\n                    ? balances[1].amount0 += liq\\r\\n                    : refBalances[upper] += liq;\\r\\n                emit referralPaid(\\r\\n                    tokenOwner,\\r\\n                    upper == address(0) ? multiSig : upper,\\r\\n                    liq\\r\\n                );\\r\\n            }\\r\\n\\r\\n            (newTokenId, min0, min1) = _mintPosition(\\r\\n                WETHRemoved,\\r\\n                tokensRemoved,\\r\\n                flag,\\r\\n                msg.sender,\\r\\n                false,\\r\\n                min0Out,\\r\\n                min1Out\\r\\n            );\\r\\n\\r\\n            if (min0 > WETHRemoved) revert Max0();\\r\\n            if (min1 > tokensRemoved) revert Max1();\\r\\n            balances[newTokenId].amount0 += uint128(WETHRemoved - min0);\\r\\n            balances[newTokenId].amount1 += uint128(tokensRemoved - min1);\\r\\n\\r\\n            emit ShiftedPosition(tokenId, newTokenId, flag, min0, min1);\\r\\n        } else {\\r\\n            revert(\\\"no_limit_orders\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function createLimitOrderPosition(\\r\\n        uint128 amount0Or1,\\r\\n        uint256 flag,\\r\\n        bool isToken0,\\r\\n        uint256 min0Or1Out\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256 newTokenId,\\r\\n            uint256 min0,\\r\\n            uint256 min1\\r\\n        )\\r\\n    {\\r\\n        isToken0\\r\\n            ? IERC20(WETH).transferFrom(msg.sender, address(this), amount0Or1)\\r\\n            : IERC20(CTLS).transferFrom(msg.sender, address(this), amount0Or1);\\r\\n        unchecked {\\r\\n            uint128 pFee = amount0Or1 / 25;\\r\\n            uint128 rFee0 = amount0Or1 / 100;\\r\\n            amount0Or1 -= (pFee + rFee0);\\r\\n\\r\\n            isToken0\\r\\n                ? balances[1].amount0 += pFee\\r\\n                : balances[1].amount1 += pFee;\\r\\n\\r\\n            address upper = ChainTools(payable(CTLS)).getUpperRef(msg.sender);\\r\\n            //Determine Referal\\r\\n            upper == address(0)\\r\\n                ? balances[1].amount0 += rFee0\\r\\n                : refBalances[upper] += rFee0;\\r\\n            emit referralPaid(\\r\\n                msg.sender,\\r\\n                upper == address(0) ? multiSig : upper,\\r\\n                rFee0\\r\\n            );\\r\\n        }\\r\\n\\r\\n        (newTokenId, min0, min1) = _mintPosition(\\r\\n            isToken0 ? amount0Or1 : 0,\\r\\n            isToken0 ? 0 : amount0Or1,\\r\\n            flag,\\r\\n            msg.sender,\\r\\n            true,\\r\\n            isToken0 ? min0Or1Out : 0,\\r\\n            isToken0 ? 0 : min0Or1Out\\r\\n        );\\r\\n        if (isToken0) {\\r\\n            _sendRefunds(amount0Or1 - min0, 0);\\r\\n        } else {\\r\\n            _sendRefunds(0, amount0Or1 - min1);\\r\\n        }\\r\\n        emit limitOrderCreated(\\r\\n            msg.sender,\\r\\n            newTokenId,\\r\\n            flag,\\r\\n            isToken0 ? min0 : min1,\\r\\n            isToken0\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _sendRefunds(uint256 amount0, uint256 amount1) internal {\\r\\n        if (amount0 != 0) IERC20(WETH).transfer(msg.sender, amount0);\\r\\n        if (amount1 >= 1e15) IERC20(CTLS).transfer(msg.sender, amount1);\\r\\n    }\\r\\n\\r\\n    function createNomralPosition(\\r\\n        uint128 amount0,\\r\\n        uint128 amount1,\\r\\n        uint256 flag,\\r\\n        uint256 min0,\\r\\n        uint256 min1\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256 tokenId,\\r\\n            uint256 amt0Consumed,\\r\\n            uint256 amt1Consumed\\r\\n        )\\r\\n    {\\r\\n        IERC20(WETH).transferFrom(msg.sender, address(this), amount0);\\r\\n        IERC20(CTLS).transferFrom(msg.sender, address(this), amount1);\\r\\n        {\\r\\n            uint128 pFee0 = amount0 / 50;\\r\\n            uint128 pFee1 = amount1 / 50;\\r\\n            uint128 rFee0 = amount0 / 100;\\r\\n            balances[1].amount0 += pFee0;\\r\\n            balances[1].amount1 += pFee1;\\r\\n\\r\\n            amount0 -= (pFee0 + rFee0);\\r\\n            amount1 -= pFee1;\\r\\n            //Referral Tax [0.5%]\\r\\n            address upper = ChainTools(payable(CTLS)).getUpperRef(msg.sender);\\r\\n            upper == address(0)\\r\\n                ? balances[1].amount0 += rFee0\\r\\n                : refBalances[upper] += rFee0;\\r\\n            emit referralPaid(\\r\\n                msg.sender,\\r\\n                upper == address(0) ? multiSig : upper,\\r\\n                rFee0\\r\\n            );\\r\\n\\r\\n            (tokenId, amt0Consumed, amt1Consumed) = _mintPosition(\\r\\n                amount0,\\r\\n                amount1,\\r\\n                flag,\\r\\n                msg.sender,\\r\\n                false,\\r\\n                min0,\\r\\n                min1\\r\\n            );\\r\\n\\r\\n            IERC20(WETH).transfer(msg.sender, amount0 - amt0Consumed);\\r\\n            IERC20(CTLS).transfer(msg.sender, amount1 - amt1Consumed);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _mintPosition(\\r\\n        uint256 amt0Desired,\\r\\n        uint256 amt1Desired,\\r\\n        uint256 flag,\\r\\n        address to,\\r\\n        bool isLimit,\\r\\n        uint256 min0,\\r\\n        uint256 min1\\r\\n    )\\r\\n        internal\\r\\n        returns (\\r\\n            uint256 tokenId,\\r\\n            uint256 amt0Consumed,\\r\\n            uint256 amt1Consumed\\r\\n        )\\r\\n    {\\r\\n        int24 tick = this.getCurrentTick();\\r\\n        int24 tickDist = this.getTickDistance(flag);\\r\\n\\r\\n        if (!isLimit) {\\r\\n            (tokenId, , amt0Consumed, amt1Consumed) = positionManager.mint(\\r\\n                INonfungiblePositionManager.MintParams({\\r\\n                    token0: WETH,\\r\\n                    token1: CTLS,\\r\\n                    fee: 10000,\\r\\n                    tickLower: tick - tickDist < int24(-887000)\\r\\n                        ? int24(-887000)\\r\\n                        : tick - tickDist,\\r\\n                    tickUpper: tick + tickDist > int24(887000)\\r\\n                        ? int24(887000)\\r\\n                        : tick + tickDist,\\r\\n                    amount0Desired: amt0Desired,\\r\\n                    amount1Desired: amt1Desired,\\r\\n                    amount0Min: min0,\\r\\n                    amount1Min: min1,\\r\\n                    recipient: to,\\r\\n                    deadline: block.timestamp\\r\\n                })\\r\\n            );\\r\\n        } else {\\r\\n            (tokenId, , amt0Consumed, amt1Consumed) = positionManager.mint(\\r\\n                INonfungiblePositionManager.MintParams({\\r\\n                    token0: WETH,\\r\\n                    token1: CTLS,\\r\\n                    fee: 10000,\\r\\n                    tickLower: amt0Desired == 0 ? tick - tickDist : tick,\\r\\n                    tickUpper: amt0Desired == 0 ? tick : tick + tickDist,\\r\\n                    amount0Desired: amt0Desired,\\r\\n                    amount1Desired: amt1Desired,\\r\\n                    amount0Min: min0,\\r\\n                    amount1Min: min1,\\r\\n                    recipient: to,\\r\\n                    deadline: block.timestamp\\r\\n                })\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //GETTERS\\r\\n    function balanceOf(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (uint128 balance0, uint128 balance1)\\r\\n    {\\r\\n        balance0 = balances[tokenId].amount0;\\r\\n        balance1 = balances[tokenId].amount1;\\r\\n    }\\r\\n\\r\\n    function balanceOfReferal(address who)\\r\\n        external\\r\\n        view\\r\\n        returns (uint128 amount0)\\r\\n    {\\r\\n        return refBalances[who];\\r\\n    }\\r\\n\\r\\n    function balanceOfMany(uint256[] calldata tokenIds)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint128 balance0Total,\\r\\n            uint128 balance1Total,\\r\\n            uint256[] memory returnTokenIds,\\r\\n            uint128[] memory balances0,\\r\\n            uint128[] memory balances1\\r\\n        )\\r\\n    {\\r\\n        uint256 size = tokenIds.length;\\r\\n        balances0 = new uint128[](size);\\r\\n        balances1 = new uint128[](size);\\r\\n\\r\\n        unchecked {\\r\\n            for (uint256 i; i < size; ++i) {\\r\\n                uint256 tokenId = tokenIds[i];\\r\\n                uint128 bal0 = balances[tokenId].amount0;\\r\\n                uint128 bal1 = balances[tokenId].amount1;\\r\\n\\r\\n                balance0Total += bal0;\\r\\n                balance1Total += bal1;\\r\\n\\r\\n                balances0[i] = bal0;\\r\\n                balances1[i] = bal1;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        returnTokenIds = tokenIds;\\r\\n    }\\r\\n\\r\\n    function findPoolFee(address token0, address token1)\\r\\n        public\\r\\n        view\\r\\n        returns (uint24 poolFee)\\r\\n    {\\r\\n        address factory = IRouterV3(v3Router).factory();\\r\\n        uint128 highestLiq;\\r\\n        try IV3Factory(factory).getPool(token0, token1, 100) returns (\\r\\n            address pool100\\r\\n        ) {\\r\\n            if (pool100 != address(0)) {\\r\\n                try IV3Pool(pool100).liquidity() returns (uint128 liq) {\\r\\n                    if (liq > highestLiq) {\\r\\n                        poolFee = 100;\\r\\n                        highestLiq = liq;\\r\\n                    }\\r\\n                } catch {}\\r\\n            }\\r\\n        } catch {}\\r\\n        try IV3Factory(factory).getPool(token0, token1, 500) returns (\\r\\n            address pool500\\r\\n        ) {\\r\\n            if (pool500 != address(0)) {\\r\\n                try IV3Pool(pool500).liquidity() returns (uint128 liq) {\\r\\n                    if (liq > highestLiq) {\\r\\n                        poolFee = 500;\\r\\n                        highestLiq = liq;\\r\\n                    }\\r\\n                } catch {}\\r\\n            }\\r\\n        } catch {}\\r\\n        try IV3Factory(factory).getPool(token0, token1, 3000) returns (\\r\\n            address pool3000\\r\\n        ) {\\r\\n            if (pool3000 != address(0)) {\\r\\n                try IV3Pool(pool3000).liquidity() returns (uint128 liq) {\\r\\n                    if (liq > highestLiq) {\\r\\n                        poolFee = 3000;\\r\\n                        highestLiq = liq;\\r\\n                    }\\r\\n                } catch {}\\r\\n            }\\r\\n        } catch {}\\r\\n\\r\\n        try IV3Factory(factory).getPool(token0, token1, 10000) returns (\\r\\n            address pool10000\\r\\n        ) {\\r\\n            if (pool10000 != address(0)) {\\r\\n                try IV3Pool(pool10000).liquidity() returns (uint128 liq) {\\r\\n                    if (liq > highestLiq) {\\r\\n                        poolFee = 10000;\\r\\n                        highestLiq = liq;\\r\\n                    }\\r\\n                } catch {}\\r\\n            }\\r\\n        } catch {}\\r\\n    }\\r\\n\\r\\n    function getPosition(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            address token0,\\r\\n            address token1,\\r\\n            uint128 liquidity\\r\\n        )\\r\\n    {\\r\\n        (, , token0, token1, , , , liquidity, , , , ) = positionManager\\r\\n            .positions(tokenId);\\r\\n    }\\r\\n\\r\\n    function getDeviation(uint256 amountIn, uint256 startTickDeviation)\\r\\n        external\\r\\n        pure\\r\\n        returns (uint256 adjusted)\\r\\n    {\\r\\n        adjusted = (amountIn * (10000 + startTickDeviation)) / 20000;\\r\\n    }\\r\\n\\r\\n    function getStartTickDeviation(int24 currentTick)\\r\\n        external\\r\\n        pure\\r\\n        returns (uint256 perc)\\r\\n    {\\r\\n        int24 startTickDeviation;\\r\\n\\r\\n        if (currentTick > -106400) {\\r\\n            startTickDeviation = currentTick + -106400;\\r\\n        } else {\\r\\n            startTickDeviation = -106400 + currentTick;\\r\\n        }\\r\\n        if (startTickDeviation < 0) {\\r\\n            startTickDeviation = -startTickDeviation;\\r\\n        }\\r\\n        perc = (uint256(int256(startTickDeviation)) * 75) / 107400;\\r\\n    }\\r\\n\\r\\n    function getCurrentTick() external view returns (int24 cTick) {\\r\\n        (, cTick, , , , , ) = IV3Pool(uniswapV3Pool).slot0();\\r\\n        cTick = (cTick / 200) * 200;\\r\\n    }\\r\\n\\r\\n    function getTickDistance(uint256 flag)\\r\\n        external\\r\\n        pure\\r\\n        returns (int24 tickDistance)\\r\\n    {\\r\\n        if (flag == 0) {\\r\\n            //default\\r\\n            tickDistance = 30000;\\r\\n        } else if (flag == 1) {\\r\\n            tickDistance = 20000;\\r\\n        } else if (flag == 2) {\\r\\n            tickDistance = 10000;\\r\\n        } else if (flag == 3) {\\r\\n            tickDistance = 5000;\\r\\n        } else if (flag == 4) {\\r\\n            tickDistance = 2000;\\r\\n        } else {\\r\\n            revert(\\\"invalid_flag\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function findApprovalToken(address pool)\\r\\n        external\\r\\n        view\\r\\n        returns (address token)\\r\\n    {\\r\\n        return\\r\\n            this.findApprovalToken(\\r\\n                IV3Pool(pool).token0(),\\r\\n                IV3Pool(pool).token1()\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function findApprovalToken(address token0, address token1)\\r\\n        external\\r\\n        view\\r\\n        returns (address token)\\r\\n    {\\r\\n        require(token0 == WETH || token1 == WETH, \\\"Not WETH Pair\\\");\\r\\n        token = token0 == WETH ? token1 : token0;\\r\\n        if (token == CTLS || token == WETH) {\\r\\n            token = address(0);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 7777\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_multisig\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_apest\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Auth\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MinMax\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Sando\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"referralPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amtETHIn\",\"type\":\"uint256\"}],\"name\":\"rewardLPETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amtTokenIn\",\"type\":\"uint256\"}],\"name\":\"rewardLPTOKEN\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"flag\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amtETHIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amtTokensIn\",\"type\":\"uint256\"}],\"name\":\"zapIn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"flag\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"adjustFomo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addressList\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"}],\"name\":\"completeMigration\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flashReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"getIsTaxExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"getUpperRef\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getV3Pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getYieldBooster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"yb\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"yieldVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"yieldBooster\",\"type\":\"address\"}],\"name\":\"prepareFomo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"uniswapV3FlashCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flag\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"upper\",\"type\":\"address\"}],\"name\":\"zapFromETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minOut2\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isV2\",\"type\":\"bool\"},{\"internalType\":\"uint24\",\"name\":\"poolFee\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"flag\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"zapFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"minOut\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"minOut2\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"flag\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"zapFromV2LPToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minOut2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"flag\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"zapFromV3LPToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenIdNew\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ChainTools", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "7777", "ConstructorArguments": "000000000000000000000000b0df68e0bf4f54d06a4a448735d2a3d7d97a22220000000000000000000000009318a070a16e25554f098c6930b506123b66e19d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}