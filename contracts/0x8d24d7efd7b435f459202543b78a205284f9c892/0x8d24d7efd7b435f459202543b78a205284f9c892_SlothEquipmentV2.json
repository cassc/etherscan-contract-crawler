{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SlothEquipmentV2.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"./interfaces/ISlothItemV3.sol\\\";\\nimport \\\"./interfaces/ISpecialSlothItem.sol\\\";\\nimport \\\"./interfaces/IItemType.sol\\\";\\nimport \\\"./interfaces/IEquipment.sol\\\";\\nimport \\\"./interfaces/ISlothBody.sol\\\";\\nimport \\\"./interfaces/ISlothV2.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract SlothEquipmentV2 is Ownable {\\n  event SetItem (\\n    uint256 indexed _tokenId,\\n    uint256[] _itemIds,\\n    IItemType.ItemMintType[] _itemMintType,\\n    address[] _slothItemAddr,\\n    uint256 _setAt\\n  );\\n\\n  address private _slothAddr;\\n  address private _slothItemAddr;\\n  address private _specialSlothItemAddr;\\n  address private _userGeneratedSlothItemAddr;\\n  uint8 private constant _ITEM_NUM = 5;\\n  bool private _itemAvailable;\\n\\n  function _getSpecialType(uint256 _itemTokenId) internal view returns (uint256) {\\n    ISpecialSlothItem specialSlothItem = ISpecialSlothItem(_specialSlothItemAddr);\\n    return specialSlothItem.getSpecialType(_itemTokenId);\\n  }\\n\\n  function _checkIsCombinationalCollabo(uint256 _specialType) internal view returns (bool) {\\n    ISpecialSlothItem specialSlothItem = ISpecialSlothItem(_specialSlothItemAddr);\\n    return specialSlothItem.isCombinational(_specialType);\\n  }\\n\\n  function setItems(uint256 tokenId, IEquipment.EquipmentTargetItem[] memory _targetItems, address _contractAddress) external {\\n    require(_itemAvailable, \\\"item not available\\\");\\n    require(ISlothBody(_contractAddress).exists(tokenId), \\\"not exist\\\");\\n    require(ISlothBody(_contractAddress).ownerOf(tokenId) == msg.sender, \\\"not owner\\\");\\n    require(_targetItems.length == _ITEM_NUM, \\\"invalid itemIds length\\\");\\n\\n    IEquipment.Equipment[_ITEM_NUM] memory _equipments = ISlothBody(_contractAddress).getEquipments(tokenId);\\n    uint256[] memory _equipmentItemIds = new uint256[](_ITEM_NUM);\\n    for (uint8 i = 0; i < _ITEM_NUM; i++) {\\n      _equipmentItemIds[i] = _equipments[i].itemId;\\n    }\\n    validateSetItems(_equipmentItemIds, _targetItems, msg.sender);\\n\\n    address[] memory itemAddrs = new address[](5);\\n    uint256[] memory _itemIds = new uint256[](5);\\n    IItemType.ItemMintType[] memory _itemMintTypes = new IItemType.ItemMintType[](5);\\n    for (uint8 i = 0; i < _ITEM_NUM; i++) {\\n      itemAddrs[i] = ISloth(_contractAddress).setItem(tokenId, _targetItems[i], ISlothItem.ItemType(i), msg.sender);\\n      _itemIds[i] = _targetItems[i].itemTokenId;\\n      _itemMintTypes[i] = _targetItems[i].itemMintType;\\n    }\\n    // _lastSetAt[tokenId] = block.timestamp;\\n    emit SetItem(tokenId, _itemIds, _itemMintTypes, itemAddrs, block.timestamp);\\n  }\\n\\n  function _checkOwner(uint256 _itemTokenId, IItemType.ItemMintType _itemMintType, address sender) internal view {\\n    if (_itemMintType == IItemType.ItemMintType.SLOTH_ITEM) {\\n      ISlothItemV3 slothItem = ISlothItemV3(_slothItemAddr);\\n      require(slothItem.exists(_itemTokenId), \\\"token not exists\\\");\\n      require(slothItem.ownerOf(_itemTokenId) == sender, \\\"not owner\\\");\\n      return;\\n    }\\n    \\n    if (uint(_itemMintType) == uint(IItemType.ItemMintType.SPECIAL_SLOTH_ITEM)) {\\n      ISpecialSlothItem specialSlothItem = ISpecialSlothItem(_specialSlothItemAddr);\\n      require(specialSlothItem.exists(_itemTokenId), \\\"token not exists\\\");\\n      require(specialSlothItem.ownerOf(_itemTokenId) == sender, \\\"not owner\\\");  \\n      return;\\n    }\\n\\n    revert(\\\"wrorng itemMintType\\\");\\n  }\\n\\n  function _checkItemType(uint256 _itemTokenId, IItemType.ItemMintType _itemMintType, IItemType.ItemType _itemType) internal view {\\n    if (_itemMintType == IItemType.ItemMintType.SLOTH_ITEM) {\\n      ISlothItemV3 slothItem = ISlothItemV3(_slothItemAddr);\\n      require(slothItem.getItemType(_itemTokenId) == _itemType, \\\"wrong item type\\\");\\n      return;\\n    }\\n\\n    if (_itemMintType == IItemType.ItemMintType.SPECIAL_SLOTH_ITEM) {\\n      ISpecialSlothItem specialSlothItem = ISpecialSlothItem(_specialSlothItemAddr);\\n      require(specialSlothItem.getItemType(_itemTokenId) == _itemType, \\\"wrong item type\\\");\\n      return;\\n    }\\n\\n    revert(\\\"wrorng itemMintType\\\");\\n  }\\n\\n  function validateSetItems(uint256[] memory equipmentItemIds, IEquipment.EquipmentTargetItem[] memory equipmentTargetItems, address sender) internal view returns (bool) {\\n    uint8 equipmentTargetSlothItemNum = 0;\\n    uint8 specialItemCount = 0;\\n    uint256 latestSpecialType = 99;\\n    bool latestSpecialTypeCombinationable = true;\\n  \\n    for (uint8 i = 0; i < _ITEM_NUM; i++) {\\n      uint256 _itemTokenId = equipmentTargetItems[i].itemTokenId;\\n      IItemType.ItemMintType _itemMintType = equipmentTargetItems[i].itemMintType;\\n      // token\u5b58\u5728\u30c1\u30a7\u30c3\u30af\u3001\u30aa\u30fc\u30ca\u30fc\u30c1\u30a7\u30c3\u30af\\n      if (_itemTokenId != 0) {\\n        if (equipmentItemIds[i] != _itemTokenId) {\\n          _checkOwner(_itemTokenId, _itemMintType, sender);\\n        }\\n\\n        if (_itemMintType == IItemType.ItemMintType.SPECIAL_SLOTH_ITEM) {\\n          _checkItemType(_itemTokenId, _itemMintType, IItemType.ItemType(i));\\n          // \u30b3\u30e9\u30dc\u30a2\u30a4\u30c6\u30e0\u3060\u3063\u305f\u5834\u5408\u306b\u3001\u4f75\u7528\u53ef\u4e0d\u53ef\u306e\u30c1\u30a7\u30c3\u30af\u3092\u884c\u3046\\n          uint256 _specialType = _getSpecialType(_itemTokenId);\\n          if (latestSpecialType != _specialType) {\\n            bool combinationable = _checkIsCombinationalCollabo(_specialType);\\n            latestSpecialTypeCombinationable = combinationable;\\n            specialItemCount++;\\n            if (specialItemCount >= 2) {\\n              // 2\u500b\u76ee\u4ee5\u964d\u306e\u30b3\u30e9\u30dc\u304c\u51fa\u3066\u304d\u305f\u3068\u304d\u306bconbination\u306e\u30c1\u30a7\u30c3\u30af\u3092\u884c\u3046\\n              if (combinationable && latestSpecialTypeCombinationable) {\\n                // \u4f75\u7528\u53ef\u306e\u5834\u5408\u306f\u4f55\u3082\u3057\u306a\u3044\\n              } else {\\n                // \u4f75\u7528\u4e0d\u53ef\u306e\u5834\u5408\u306f\u30a8\u30e9\u30fc\u3092\u8fd4\u3059\\n                revert(\\\"not combinationable\\\");\\n              }\\n            }\\n            latestSpecialType = _specialType;\\n          }\\n        } else {\\n          _checkItemType(_itemTokenId, _itemMintType, IItemType.ItemType(i));\\n\\n          equipmentTargetSlothItemNum++;\\n        }\\n      }\\n    }\\n    if (latestSpecialTypeCombinationable == false && equipmentTargetSlothItemNum > 0) {\\n      revert(\\\"not combinationable\\\");\\n    }\\n    return true;\\n  }\\n\\n  function getTargetItemContractAddress(IItemType.ItemMintType _itemMintType) external view returns (address) {\\n    if (_itemMintType == IItemType.ItemMintType.SLOTH_ITEM) {\\n      return _slothItemAddr;\\n    } else if (_itemMintType == IItemType.ItemMintType.SPECIAL_SLOTH_ITEM) {\\n      return _specialSlothItemAddr;\\n    } else if (_itemMintType == IItemType.ItemMintType.USER_GENERATED_SLOTH_ITEM) {\\n      return _userGeneratedSlothItemAddr;\\n    } else {\\n      revert(\\\"invalid itemMintType\\\");\\n    }\\n  }\\n\\n  function setItemAvailable(bool newItemAvailable) external onlyOwner {\\n    _itemAvailable = newItemAvailable;\\n  }\\n\\n  function setSlothAddr(address newSlothAddr) external onlyOwner {\\n    _slothAddr = newSlothAddr;\\n  }\\n  function setSlothItemAddr(address newSlothItemAddr) external onlyOwner {\\n    _slothItemAddr = newSlothItemAddr;\\n  }\\n  function setSpecialSlothItemAddr(address newSpecialSlothItemAddr) external onlyOwner {\\n    _specialSlothItemAddr = newSpecialSlothItemAddr;\\n  }\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISlothBody.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { IEquipment } from \\\"./IEquipment.sol\\\";\\n\\ninterface ISlothBody {\\n  function exists(uint256 tokenId) external view returns (bool);\\n  function ownerOf(uint256 tokenId) external view returns (address);\\n  function getEquipments(uint256 tokenId) external view returns (IEquipment.Equipment[5] memory);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IItemType.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IItemType {\\n  enum ItemType { CLOTHES, HEAD, HAND, FOOT, STAMP }\\n  enum ItemMintType { SLOTH_ITEM, SPECIAL_SLOTH_ITEM, USER_GENERATED_SLOTH_ITEM }\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISlothItemV3.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { IERC721AQueryableUpgradeable } from \\\"erc721a-upgradeable/contracts/interfaces/IERC721AQueryableUpgradeable.sol\\\";\\nimport \\\"./IItemType.sol\\\";\\n\\ninterface ISlothItemV3 is IERC721AQueryableUpgradeable {\\n  function getItemType(uint256 tokenId) external view returns (IItemType.ItemType);\\n  function getItemMintCount(address sender) external view returns (uint256);\\n  function exists(uint256 tokenId) external view returns (bool);\\n  function clothesMint(address sender, uint256 quantity) external;\\n  function itemMint(address sender, uint256 quantity) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IEquipment.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"./IItemType.sol\\\";\\n\\ninterface IEquipment {\\n  struct EquipmentTargetItem {\\n    uint256 itemTokenId;\\n    IItemType.ItemMintType itemMintType; \\n  }\\n  struct Equipment {\\n    uint256 itemId;\\n    address itemAddr;\\n  }\\n  struct EquipmentTargetSpecial {\\n    uint256 specialType;\\n    bool combinationable;\\n  }\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISlothV2.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { IERC721AQueryableUpgradeable } from \\\"erc721a-upgradeable/contracts/interfaces/IERC721AQueryableUpgradeable.sol\\\";\\nimport { IEquipment } from \\\"./IEquipment.sol\\\";\\nimport { ISlothItem } from \\\"./ISlothItem.sol\\\";\\n\\ninterface ISloth is IERC721AQueryableUpgradeable {\\n  function mint(address sender, uint8 quantity) external;\\n  function numberMinted(address sender) external view returns (uint256);\\n  function setItem(uint256 _tokenId, IEquipment.EquipmentTargetItem memory _targetItem, ISlothItem.ItemType _targetItemType, address sender) external returns (address);\\n  function receiveItem(address tokenOwner, address itemContractAddress, uint256 itemTokenId) external;\\n  function sendItem(address tokenOwner, address itemContractAddress, uint256 itemTokenId) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISpecialSlothItem.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"./IItemType.sol\\\";\\nimport { IERC721AQueryableUpgradeable } from \\\"erc721a-upgradeable/contracts/interfaces/IERC721AQueryableUpgradeable.sol\\\";\\n\\ninterface ISpecialSlothItem is IERC721AQueryableUpgradeable, IItemType {\\n  function getItemType(uint256 tokenId) external view returns (ItemType);\\n  function getSpecialType(uint256 tokenId) external view returns (uint256);\\n  function getClothType(uint256 tokenId) external view returns (uint256);\\n  function exists(uint256 tokenId) external view returns (bool);\\n  function isCombinational(uint256 _specialType) external view returns (bool);\\n  function mintPoupelle(address sender, uint256 quantity) external;\\n  function mintCollaboCloth(address sender, uint256 quantity, uint256 _specialType) external;\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"erc721a-upgradeable/contracts/interfaces/IERC721AQueryableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.2\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '../extensions/IERC721AQueryableUpgradeable.sol';\\n\"\r\n    },\r\n    \"erc721a-upgradeable/contracts/extensions/IERC721AQueryableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.2\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\nimport '../IERC721AUpgradeable.sol';\\n\\n/**\\n * @dev Interface of ERC721AQueryable.\\n */\\ninterface IERC721AQueryableUpgradeable is IERC721AUpgradeable {\\n    /**\\n     * Invalid query range (`start` >= `stop`).\\n     */\\n    error InvalidQueryRange();\\n\\n    /**\\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\\n     *\\n     * If the `tokenId` is out of bounds:\\n     *\\n     * - `addr = address(0)`\\n     * - `startTimestamp = 0`\\n     * - `burned = false`\\n     * - `extraData = 0`\\n     *\\n     * If the `tokenId` is burned:\\n     *\\n     * - `addr = <Address of owner before token was burned>`\\n     * - `startTimestamp = <Timestamp when token was burned>`\\n     * - `burned = true`\\n     * - `extraData = <Extra data when token was burned>`\\n     *\\n     * Otherwise:\\n     *\\n     * - `addr = <Address of owner>`\\n     * - `startTimestamp = <Timestamp of start of ownership>`\\n     * - `burned = false`\\n     * - `extraData = <Extra data at start of ownership>`\\n     */\\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\\n\\n    /**\\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\\n     * See {ERC721AQueryable-explicitOwnershipOf}\\n     */\\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`,\\n     * in the range [`start`, `stop`)\\n     * (i.e. `start <= tokenId < stop`).\\n     *\\n     * This function allows for tokens to be queried if the collection\\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\\n     *\\n     * Requirements:\\n     *\\n     * - `start < stop`\\n     */\\n    function tokensOfOwnerIn(\\n        address owner,\\n        uint256 start,\\n        uint256 stop\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Returns an array of token IDs owned by `owner`.\\n     *\\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\\n     * It is meant to be called off-chain.\\n     *\\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\\n     * multiple smaller scans if the collection is large enough to cause\\n     * an out-of-gas error (10K collections should be fine).\\n     */\\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"erc721a-upgradeable/contracts/IERC721AUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.2\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of ERC721A.\\n */\\ninterface IERC721AUpgradeable {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * The caller cannot approve to their own address.\\n     */\\n    error ApproveToCaller();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\n        uint24 extraData;\\n    }\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    // =============================================================\\n    //                           IERC2309\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\n     *\\n     * See {_mintERC2309} for more details.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISlothItem.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { IERC721AQueryableUpgradeable } from \\\"erc721a-upgradeable/contracts/interfaces/IERC721AQueryableUpgradeable.sol\\\";\\n\\ninterface ISlothItem is IERC721AQueryableUpgradeable {\\n  enum ItemType { CLOTHES, HEAD, HAND, FOOT, STAMP }\\n\\n  function getItemType(uint256 tokenId) external view returns (ItemType);\\n  function getItemMintCount(address sender) external view returns (uint256);\\n  function exists(uint256 tokenId) external view returns (bool);\\n  function clothesMint(address sender) external;\\n  function itemMint(address sender, uint256 quantity) external;\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_itemIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"enum IItemType.ItemMintType[]\",\"name\":\"_itemMintType\",\"type\":\"uint8[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"_slothItemAddr\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_setAt\",\"type\":\"uint256\"}],\"name\":\"SetItem\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"enum IItemType.ItemMintType\",\"name\":\"_itemMintType\",\"type\":\"uint8\"}],\"name\":\"getTargetItemContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newItemAvailable\",\"type\":\"bool\"}],\"name\":\"setItemAvailable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"itemTokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum IItemType.ItemMintType\",\"name\":\"itemMintType\",\"type\":\"uint8\"}],\"internalType\":\"struct IEquipment.EquipmentTargetItem[]\",\"name\":\"_targetItems\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"setItems\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSlothAddr\",\"type\":\"address\"}],\"name\":\"setSlothAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSlothItemAddr\",\"type\":\"address\"}],\"name\":\"setSlothItemAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSpecialSlothItemAddr\",\"type\":\"address\"}],\"name\":\"setSpecialSlothItemAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SlothEquipmentV2", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}