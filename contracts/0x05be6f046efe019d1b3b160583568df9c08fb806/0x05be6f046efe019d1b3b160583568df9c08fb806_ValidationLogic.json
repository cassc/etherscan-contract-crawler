{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\\n     * 0 before setting it to a non-zero value.\\n     */\\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IInitializableDebtToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.18;\\n\\nimport \\\"./IKyokoPoolAddressesProvider.sol\\\";\\n\\n/**\\n * @title IInitializableDebtToken\\n * @notice Interface for the initialize function common between debt tokens\\n * @author Kyoko\\n **/\\ninterface IInitializableDebtToken {\\n  /**\\n   * @dev Emitted when a debt token is initialized\\n   * @param underlyingAsset The address of the underlying asset\\n   * @param pool The address of the associated lending pool\\n   * @param reserveId The id of the reserve\\n   * @param debtTokenDecimals the decimals of the debt token\\n   * @param debtTokenName the name of the debt token\\n   * @param debtTokenSymbol the symbol of the debt token\\n   **/\\n  event Initialized(\\n    address indexed underlyingAsset,\\n    address indexed pool,\\n    uint256 reserveId,\\n    uint8 debtTokenDecimals,\\n    string debtTokenName,\\n    string debtTokenSymbol\\n  );\\n\\n  /**\\n   * @dev Initializes the debt token.\\n   * @param provider The address of the address provider where this debtToken will be used\\n   * @param reserveId The id of the reserve\\n   * @param underlyingAsset The address of the underlying asset of this kToken (E.g. WETH for hWETH)\\n   * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's\\n   * @param debtTokenName The name of the token\\n   * @param debtTokenSymbol The symbol of the token\\n   */\\n  function initialize(\\n    IKyokoPoolAddressesProvider provider,\\n    uint256 reserveId,\\n    address underlyingAsset,\\n    uint8 debtTokenDecimals,\\n    string memory debtTokenName,\\n    string memory debtTokenSymbol\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IInterestRateStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.18;\\n\\nimport \\\"../libraries/utils/DataTypes.sol\\\";\\n\\ninterface IInterestRateStrategy {\\n    event SetMinBorrowTime(uint40 newTime);\\n\\n    event VariableRateUpdated(\\n        uint256 indexed reserveId,\\n        uint256 newBaseStableRate,\\n        uint256 newVariableSlope1,\\n        uint256 newVariableSlope2\\n    );\\n\\n    event StableRateUpdated(\\n        uint256 indexed reserveId,\\n        uint256 newBaseStableRate,\\n        uint256 newVariableSlope1,\\n        uint256 newVariableSlope2\\n    );\\n\\n    event AddNewRate(uint256 reserveId);\\n\\n    function getRate(uint256 reserveId)\\n        external\\n        view\\n        returns (DataTypes.Rate memory);\\n\\n    function getMaxVariableBorrowRate(uint256 reserveId)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function calculateInterestRates(\\n        uint256 reserveId,\\n        address reserve,\\n        address kToken,\\n        uint256 liquidityAdded,\\n        uint256 liquidityTaken,\\n        uint256 totalStableDebt,\\n        uint256 totalVariableDebt,\\n        uint256 averageStableBorrowRate,\\n        uint256 reserveFactor\\n    )\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function calculateInterestRates(\\n        DataTypes.Rate memory rate,\\n        uint256 availableLiquidity,\\n        uint256 totalStableDebt,\\n        uint256 totalVariableDebt,\\n        uint256 averageStableBorrowRate,\\n        uint256 reserveFactor\\n    )\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n    \\n    function setRate(\\n        uint256 reserveId,\\n        uint256 _optimalUtilizationRate,\\n        uint256 _baseVariableBorrowRate,\\n        uint256 _variableSlope1,\\n        uint256 _variableSlope2,\\n        uint256 _baseStableBorrowRate,\\n        uint256 _stableSlope1,\\n        uint256 _stableSlope2\\n    ) external;\\n\\n    function setVariableRate(\\n        uint256 reserveId,\\n        uint256 _baseVariableRate,\\n        uint256 _variableSlope1,\\n        uint256 _variableSlope2\\n    ) external;\\n\\n    function setStableRate(\\n        uint256 reserveId,\\n        uint256 _baseStableRate,\\n        uint256 _stableSlope1,\\n        uint256 _stableSlope2\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IKToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.18;\\n\\nimport \\\"./IScaledBalanceToken.sol\\\";\\nimport \\\"./IKyokoPoolAddressesProvider.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\ninterface IKToken is IERC20Upgradeable, IScaledBalanceToken {\\n    /**\\n     * @dev Emitted when an kToken is initialized\\n     * @param underlyingAsset The address of the underlying asset\\n     * @param pool The address of the associated lending pool\\n     * @param reserveId The id of the reserves\\n     * @param treasury The address of the treasury\\n     * @param kTokenDecimals the decimals of the underlying\\n     * @param kTokenName the name of the kToken\\n     * @param kTokenSymbol the symbol of the kToken\\n     **/\\n    event Initialize(\\n        address indexed underlyingAsset,\\n        address indexed pool,\\n        uint256 indexed reserveId,\\n        address treasury,\\n        uint8 kTokenDecimals,\\n        string kTokenName,\\n        string kTokenSymbol\\n    );\\n\\n    /**\\n     * @dev Initializes the kToken\\n     * @param pool The address of the lending pool where this kToken will be used\\n     * @param reserveId The id of the reserves\\n     * @param treasury The address of the Kyoko treasury, receiving the fees on this kToken\\n     * @param underlyingAsset The address of the underlying asset of this kToken (E.g. WETH for kWETH)\\n     * @param kTokenDecimals The decimals of the kToken, same as the underlying asset's\\n     * @param kTokenName The name of the kToken\\n     * @param kTokenSymbol The symbol of the kToken\\n     */\\n    function initialize(\\n        IKyokoPoolAddressesProvider pool,\\n        uint256 reserveId,\\n        address treasury,\\n        address underlyingAsset,\\n        uint8 kTokenDecimals,\\n        string calldata kTokenName,\\n        string calldata kTokenSymbol\\n    ) external;\\n\\n    /**\\n     * @dev Emitted after the mint action\\n     * @param from The address performing the mint\\n     * @param value The amount being\\n     * @param index The new liquidity index of the reserve\\n     **/\\n    event Mint(address indexed from, uint256 value, uint256 index);\\n\\n    /**\\n     * @dev Mints `amount` kTokens to `user`\\n     * @param user The address receiving the minted tokens\\n     * @param amount The amount of tokens getting minted\\n     * @param index The new liquidity index of the reserve\\n     * @return `true` if the the previous balance of the user was 0\\n     */\\n    function mint(\\n        address user,\\n        uint256 amount,\\n        uint256 index\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted after kTokens are burned\\n     * @param from The owner of the kTokens, getting them burned\\n     * @param target The address that will receive the underlying\\n     * @param value The amount being burned\\n     * @param index The new liquidity index of the reserve\\n     **/\\n    event Burn(\\n        address indexed from,\\n        address indexed target,\\n        uint256 value,\\n        uint256 index\\n    );\\n\\n    /**\\n     * @dev Emitted during the transfer action\\n     * @param from The user whose tokens are being transferred\\n     * @param to The recipient\\n     * @param value The amount being transferred\\n     * @param index The new liquidity index of the reserve\\n     **/\\n    event BalanceTransfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 value,\\n        uint256 index\\n    );\\n\\n    /**\\n     * @dev Burns kTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\\n     * @param user The owner of the kTokens, getting them burned\\n     * @param receiverOfUnderlying The address that will receive the underlying\\n     * @param amount The amount being burned\\n     * @param index The new liquidity index of the reserve\\n     **/\\n    function burn(\\n        address user,\\n        address receiverOfUnderlying,\\n        uint256 amount,\\n        uint256 index\\n    ) external;\\n\\n    /**\\n     * @dev Burns kTokens from `user`\\n     * @param user The owner of the kTokens, getting them burned\\n     * @param amount The amount being burned\\n     * @param index The new liquidity index of the reserve\\n     **/\\n    function burn(address user, uint256 amount, uint256 index) external;\\n\\n    /**\\n     * @dev Mints kTokens to the reserve treasury\\n     * @param amount The amount of tokens getting minted\\n     * @param index The new liquidity index of the reserve\\n     */\\n    function mintToTreasury(uint256 amount, uint256 index) external;\\n\\n    /**\\n     * @dev Transfers kTokens in the event of a borrow being liquidated, in case the liquidators reclaims the kToken\\n     * @param from The address getting liquidated, current owner of the kTokens\\n     * @param to The recipient\\n     * @param value The amount of tokens getting transferred\\n     **/\\n    function transferOnLiquidation(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external;\\n\\n    /**\\n     * @dev Transfers the underlying asset to `target`. Used by the KyokoPool to transfer\\n     * assets in borrow(), withdraw() and flashLoan()\\n     * @param user The recipient of the underlying\\n     * @param amount The amount getting transferred\\n     * @return The amount transferred\\n     **/\\n    function transferUnderlyingTo(\\n        address user,\\n        uint256 amount\\n    ) external returns (uint256);\\n\\n    function transferUnderlyingNFTTo(\\n        address nft,\\n        address target,\\n        uint256 nftId\\n    ) external returns (uint256);\\n\\n    /**\\n     * @dev Invoked to execute actions on the kToken side after a repayment.\\n     * @param user The user executing the repayment\\n     * @param amount The amount getting repaid\\n     **/\\n    function handleRepayment(address user, uint256 amount) external;\\n\\n    /**\\n     * @dev Returns the address of the underlying asset of this kToken (E.g. WETH for aWETH)\\n     **/\\n    function UNDERLYING_ASSET_ADDRESS() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IKyokoPoolAddressesProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.18;\\n\\n/**\\n * @title LendingPoolAddressesProvider contract\\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\\n * - Owned by the Kyoko Governance\\n * @author Kyoko\\n **/\\ninterface IKyokoPoolAddressesProvider {\\n    event MarketIdSet(string newMarketId);\\n    event KyokoPoolUpdated(address indexed newAddress);\\n    event ConfigurationAdminUpdated(address indexed newAddress);\\n    event EmergencyAdminUpdated(address indexed newAddress);\\n    event KyokoPoolLiquidatorUpdated(address indexed newAddress);\\n    event KyokoPoolConfiguratorUpdated(address indexed newAddress);\\n    event KyokoPoolFactoryUpdated(address indexed newAddress);\\n    event RateStrategyUpdated(address indexed newAddress);\\n    event PriceOracleUpdated(address indexed newAddress);\\n    event AddressSet(bytes32 id, address indexed newAddress);\\n    event AddressRevoke(bytes32 id, address indexed oldAddress);\\n\\n    function getMarketId() external view returns (string memory);\\n\\n    function setMarketId(string calldata marketId) external;\\n\\n    function setAddress(bytes32 id, address newAddress) external;\\n\\n    function revokeAddress(bytes32 id, address oldAddress) external;\\n\\n    function getAddress(bytes32 id) external view returns (address[] memory);\\n\\n    function hasRole(bytes32 id, address account) external view returns (bool);\\n\\n    function getKyokoPool() external view returns (address[] memory);\\n\\n    function isKyokoPool(address account) external view returns (bool);\\n\\n    function setKyokoPool(address pool) external;\\n\\n    function getKyokoPoolLiquidator() external view returns (address[] memory);\\n    \\n    function isLiquidator(address account) external view returns (bool);\\n\\n    function setKyokoPoolLiquidator(address liquidator) external;\\n\\n    function getKyokoPoolConfigurator() external view returns (address[] memory);\\n    \\n    function isConfigurator(address account) external view returns (bool);\\n\\n    function setKyokoPoolConfigurator(address configurator) external;\\n\\n    function getKyokoPoolFactory() external view returns (address[] memory);\\n    \\n    function isFactory(address account) external view returns (bool);\\n\\n    function setKyokoPoolFactory(address factory) external;\\n\\n    function getPoolAdmin() external view returns (address[] memory);\\n    \\n    function isAdmin(address account) external view returns (bool);\\n\\n    function setPoolAdmin(address admin) external;\\n\\n    function getEmergencyAdmin() external view returns (address[] memory);\\n    \\n    function isEmergencyAdmin(address account) external view returns (bool);\\n\\n    function setEmergencyAdmin(address admin) external;\\n\\n    function getPriceOracle() external view returns (address[] memory);\\n\\n    function isOracle(address account) external view returns (bool);\\n\\n    function setPriceOracle(address priceOracle) external;\\n\\n    function getRateStrategy() external view returns (address[] memory);\\n\\n    function isStrategy(address account) external view returns (bool);\\n\\n    function setRateStrategy(address rateStrategy) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IScaledBalanceToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.18;\\n\\ninterface IScaledBalanceToken {\\n  /**\\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\\n   * @param user The user whose balance is calculated\\n   * @return The scaled balance of the user\\n   **/\\n  function scaledBalanceOf(address user) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the scaled balance of the user and the scaled total supply.\\n   * @param user The address of the user\\n   * @return The scaled balance of the user\\n   * @return The scaled balance and the scaled total supply\\n   **/\\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\\n\\n  /**\\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\\n   * @return The scaled total supply\\n   **/\\n  function scaledTotalSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStableDebtToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.18;\\n\\nimport \\\"./IInitializableDebtToken.sol\\\";\\n\\n/**\\n * @title IStableDebtToken\\n * @notice Defines the interface for the stable debt token\\n * @dev It does not inherit from IERC20 to save in code size\\n * @author Kyoko\\n **/\\n\\ninterface IStableDebtToken is IInitializableDebtToken {\\n  /**\\n   * @dev Emitted when new stable debt is minted\\n   * @param user The address of the user who triggered the minting\\n   * @param onBehalfOf The recipient of stable debt tokens\\n   * @param amount The amount minted\\n   * @param currentBalance The current balance of the user\\n   * @param balanceIncrease The increase in balance since the last action of the user\\n   * @param newRate The rate of the debt after the minting\\n   * @param avgStableRate The new average stable rate after the minting\\n   * @param newTotalSupply The new total supply of the stable debt token after the action\\n   **/\\n  event Mint(\\n    address indexed user,\\n    address indexed onBehalfOf,\\n    uint256 amount,\\n    uint256 currentBalance,\\n    uint256 balanceIncrease,\\n    uint256 newRate,\\n    uint256 avgStableRate,\\n    uint256 newTotalSupply\\n  );\\n\\n  /**\\n   * @dev Emitted when new stable debt is burned\\n   * @param user The address of the user\\n   * @param amount The amount being burned\\n   * @param currentBalance The current balance of the user\\n   * @param balanceIncrease The the increase in balance since the last action of the user\\n   * @param avgStableRate The new average stable rate after the burning\\n   * @param newTotalSupply The new total supply of the stable debt token after the action\\n   **/\\n  event Burn(\\n    address indexed user,\\n    uint256 amount,\\n    uint256 currentBalance,\\n    uint256 balanceIncrease,\\n    uint256 avgStableRate,\\n    uint256 newTotalSupply\\n  );\\n\\n  /**\\n   * @dev Mints debt token to the `onBehalfOf` address.\\n   * - The resulting rate is the weighted average between the rate of the new debt\\n   * and the rate of the previous debt\\n   * @param user The address receiving the borrowed underlying, being the delegatee in case\\n   * of credit delegate, or same as `onBehalfOf` otherwise\\n   * @param onBehalfOf The address receiving the debt tokens\\n   * @param amount The amount of debt tokens to mint\\n   * @param rate The rate of the debt being minted\\n   **/\\n  function mint(\\n    address user,\\n    address onBehalfOf,\\n    uint256 amount,\\n    uint256 rate\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Burns debt of `user`\\n   * - The resulting rate is the weighted average between the rate of the new debt\\n   * and the rate of the previous debt\\n   * @param user The address of the user getting his debt burned\\n   * @param amount The amount of debt tokens getting burned\\n   **/\\n  function burn(address user, uint256 amount) external;\\n\\n  /**\\n   * @dev Returns the average rate of all the stable rate loans.\\n   * @return The average stable rate\\n   **/\\n  function getAverageStableRate() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the stable rate of the user debt\\n   * @return The stable rate of the user\\n   **/\\n  function getUserStableRate(address user) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the timestamp of the last update of the user\\n   * @return The timestamp\\n   **/\\n  function getUserLastUpdated(address user) external view returns (uint40);\\n\\n  /**\\n   * @dev Returns the principal, the total supply and the average stable rate\\n   **/\\n  function getSupplyData()\\n    external\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256,\\n      uint40\\n    );\\n\\n  /**\\n   * @dev Returns the timestamp of the last update of the total supply\\n   * @return The timestamp\\n   **/\\n  function getTotalSupplyLastUpdated() external view returns (uint40);\\n\\n  /**\\n   * @dev Returns the total supply and the average stable rate\\n   **/\\n  function getTotalSupplyAndAvgRate() external view returns (uint256, uint256);\\n\\n  /**\\n   * @dev Returns the principal debt balance of the user\\n   * @return The debt balance of the user since the last burn/mint action\\n   **/\\n  function principalBalanceOf(address user) external view returns (uint256);\\n\\n  function balanceOfAmount(address account, uint256 amount) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVariableDebtToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.18;\\n\\nimport \\\"./IScaledBalanceToken.sol\\\";\\nimport \\\"./IInitializableDebtToken.sol\\\";\\n\\n/**\\n * @title IVariableDebtToken\\n * @author Kyoko\\n * @notice Defines the basic interface for a variable debt token.\\n **/\\ninterface IVariableDebtToken is IScaledBalanceToken, IInitializableDebtToken {\\n  /**\\n   * @dev Emitted after the mint action\\n   * @param from The address performing the mint\\n   * @param onBehalfOf The address of the user on which behalf minting has been performed\\n   * @param value The amount to be minted\\n   * @param index The last index of the reserve\\n   **/\\n  event Mint(address indexed from, address indexed onBehalfOf, uint256 value, uint256 index);\\n\\n  /**\\n   * @dev Mints debt token to the `onBehalfOf` address\\n   * @param user The address receiving the borrowed underlying, being the delegatee in case\\n   * of credit delegate, or same as `onBehalfOf` otherwise\\n   * @param onBehalfOf The address receiving the debt tokens\\n   * @param amount The amount of debt being minted\\n   * @param index The variable debt index of the reserve\\n   * @return `true` if the the previous balance of the user is 0\\n   **/\\n  function mint(\\n    address user,\\n    address onBehalfOf,\\n    uint256 amount,\\n    uint256 index\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when variable debt is burnt\\n   * @param user The user which debt has been burned\\n   * @param amount The amount of debt being burned\\n   * @param index The index of the user\\n   **/\\n  event Burn(address indexed user, uint256 amount, uint256 index);\\n\\n  /**\\n   * @dev Burns user variable debt\\n   * @param user The user which debt is burnt\\n   * @param index The variable debt index of the reserve\\n   **/\\n  function burn(\\n    address user,\\n    uint256 amount,\\n    uint256 index\\n  ) external;\\n\\n  function balanceOfAmount(address user, uint256 amount) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/logic/ReserveConfiguration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.18;\\n\\nimport \\\"../utils/Errors.sol\\\";\\nimport \\\"../utils/DataTypes.sol\\\";\\n\\n/**\\n * @title ReserveConfiguration library\\n * @author Kyoko\\n * @notice Implements the bitmap logic to handle the reserve configuration\\n */\\nlibrary ReserveConfiguration {\\n    uint256 constant RESERVE_FACTOR_MASK =                       0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\\n    uint256 constant BORROW_RATIO_MASK =                         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\\n    uint256 constant PERIOD_MASK =                               0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000FFFFFFFF; // prettier-ignore\\n    uint256 constant MIN_BORROW_TIME_MASK =                      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000FFFFFFFFFFFFFFFFFF; // prettier-ignore\\n    uint256 constant ACTIVE_MASK =                               0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\\n    uint256 constant LIQUIDATION_THRESHOLD_MASK =                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0001FFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\\n    uint256 constant BORROWING_MASK =                            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\\n    uint256 constant STABLE_BORROWING_MASK =                     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\\n    uint256 constant LIQUIDATION_TIME_MASK =                     0xFFFFFFFFFFFFFFFFFFFFFFFFF8000007FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\\n    uint256 constant BID_TIME_MASK =                             0xFFFFFFFFFFFFFFFFFFF8000007FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\\n    uint256 constant FROZEN_MASK =                               0xFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\\n    uint256 constant LOCK_MASK =                                 0xFFFFFFFFFFF00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\\n    uint256 constant TYPE_MASK =                                 0xFFFFFFFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\\n\\n    /// @dev For the factor, the start bit is 0 (up to 15), hence no bitshifting is needed\\n    uint256 constant BORROW_RATIO_START_BIT_POSITION = 16;\\n    uint256 constant PERIOD_START_BIT_POSITION = 32;\\n    uint256 constant MIN_BORROW_TIME_START_BIT_POSITION = 72;\\n    uint256 constant IS_ACTIVE_START_BIT_POSITION = 112;\\n    uint256 constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 113;\\n    uint256 constant BORROWING_ENABLED_START_BIT_POSITION = 129;\\n    uint256 constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 130;\\n    uint256 constant LIQUIDATION_TIME_START_BIT_POSITION = 131;\\n    uint256 constant BID_TIME_START_BIT_POSITION = 155;\\n    uint256 constant IS_FROZEN_START_BIT_POSITION = 179;\\n    uint256 constant LOCK_START_BIT_POSITION = 180;\\n    uint256 constant TYPE_START_BIT_POSITION = 212;\\n\\n    uint256 constant MAX_VALID_RESERVE_FACTOR = 10000;\\n    uint256 constant MAX_VALID_BORROW_RATIO = 10000;\\n    uint256 constant MAX_VALID_PERIOD = 30 days;\\n    uint256 constant MAX_VALID_MIN_BORROW_TIME = 15 days;\\n    uint256 constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\\n    uint256 constant MAX_VALID_LIQUIDATION_TIME = 30 days;\\n    uint256 constant MAX_VALID_BID_TIME = 15 days;\\n\\n    /**\\n     * @dev Sets the reserve factor of the reserve\\n     * @param self The reserve configuration\\n     * @param reserveFactor The reserve factor\\n     **/\\n    function setReserveFactor(\\n        DataTypes.ReserveConfigurationMap memory self,\\n        uint256 reserveFactor\\n    ) internal pure {\\n        require(\\n            reserveFactor <= MAX_VALID_RESERVE_FACTOR,\\n            Errors.RC_INVALID_RESERVE_FACTOR\\n        );\\n\\n        self.data = (self.data & RESERVE_FACTOR_MASK) | reserveFactor;\\n    }\\n\\n    /**\\n     * @dev Gets the reserve factor of the reserve\\n     * @param self The reserve configuration\\n     * @return The reserve factor\\n     **/\\n    function getReserveFactor(\\n        DataTypes.ReserveConfigurationMap storage self\\n    ) internal view returns (uint256) {\\n        return self.data & ~RESERVE_FACTOR_MASK;\\n    }\\n\\n    /**\\n     * @dev Sets the borrow ratio of the reserve\\n     * @param self The reserve configuration\\n     * @param ratio The new borrow ratio\\n     **/\\n    function setBorrowRatio(\\n        DataTypes.ReserveConfigurationMap memory self,\\n        uint256 ratio\\n    ) internal pure {\\n        require(\\n            ratio <= MAX_VALID_BORROW_RATIO,\\n            Errors.RC_INVALID_BORROW_RATIO\\n        );\\n\\n        self.data =\\n            (self.data & BORROW_RATIO_MASK) |\\n            (ratio << BORROW_RATIO_START_BIT_POSITION);\\n    }\\n\\n    /**\\n     * @dev Gets the borrow ratio of the reserve\\n     * @param self The reserve configuration\\n     * @return The borrow ratio\\n     **/\\n    function getBorrowRatio(\\n        DataTypes.ReserveConfigurationMap storage self\\n    ) internal view returns (uint256) {\\n        return\\n            (self.data & ~BORROW_RATIO_MASK) >> BORROW_RATIO_START_BIT_POSITION;\\n    }\\n\\n    /**\\n     * @dev Sets the fixed borrow period of the reserve\\n     * @param self The reserve configuration\\n     * @param period The new period\\n     **/\\n    function setPeriod(\\n        DataTypes.ReserveConfigurationMap memory self,\\n        uint256 period\\n    ) internal pure {\\n        require(period <= MAX_VALID_PERIOD, Errors.RC_INVALID_PERIOD);\\n\\n        self.data =\\n            (self.data & PERIOD_MASK) |\\n            (period << PERIOD_START_BIT_POSITION);\\n    }\\n\\n    /**\\n     * @dev Gets the fixed borrow period of the reserve\\n     * @param self The reserve configuration\\n     * @return The fixed borrow period\\n     **/\\n    function getPeriod(\\n        DataTypes.ReserveConfigurationMap storage self\\n    ) internal view returns (uint256) {\\n        return (self.data & ~PERIOD_MASK) >> PERIOD_START_BIT_POSITION;\\n    }\\n\\n    /**\\n     * @dev Sets the miniumn borrow time of the reserve\\n     * @param self The reserve configuration\\n     * @param time The new minimum borrow time\\n     **/\\n    function setMinBorrowTime(\\n        DataTypes.ReserveConfigurationMap memory self,\\n        uint256 time\\n    ) internal pure {\\n        require(\\n            time <= MAX_VALID_MIN_BORROW_TIME,\\n            Errors.RC_INVALID_MIN_BORROW_TIME\\n        );\\n\\n        self.data =\\n            (self.data & MIN_BORROW_TIME_MASK) |\\n            (time << MIN_BORROW_TIME_START_BIT_POSITION);\\n    }\\n\\n    /**\\n     * @dev Gets the miniumn borrow time of the reserve\\n     * @param self The reserve configuration\\n     * @return The minimum borrow time\\n     **/\\n    function getMinBorrowTime(\\n        DataTypes.ReserveConfigurationMap storage self\\n    ) internal view returns (uint256) {\\n        return\\n            (self.data & ~MIN_BORROW_TIME_MASK) >>\\n            MIN_BORROW_TIME_START_BIT_POSITION;\\n    }\\n\\n    /**\\n     * @dev Sets the active state of the reserve\\n     * @param self The reserve configuration\\n     * @param active The active state\\n     **/\\n    function setActive(\\n        DataTypes.ReserveConfigurationMap memory self,\\n        bool active\\n    ) internal pure {\\n        self.data =\\n            (self.data & ACTIVE_MASK) |\\n            (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);\\n    }\\n\\n    /**\\n     * @dev Gets the active state of the reserve\\n     * @param self The reserve configuration\\n     * @return The active state\\n     **/\\n    function getActive(\\n        DataTypes.ReserveConfigurationMap storage self\\n    ) internal view returns (bool) {\\n        return (self.data & ~ACTIVE_MASK) != 0;\\n    }\\n\\n    /**\\n     * @dev Sets the liquidation threshold of the reserve\\n     * @param self The reserve configuration\\n     * @param threshold The new liquidation threshold\\n     **/\\n    function setLiquidationThreshold(\\n        DataTypes.ReserveConfigurationMap memory self,\\n        uint256 threshold\\n    ) internal pure {\\n        require(\\n            threshold <= MAX_VALID_LIQUIDATION_THRESHOLD,\\n            Errors.RC_INVALID_LIQ_THRESHOLD\\n        );\\n\\n        self.data =\\n            (self.data & LIQUIDATION_THRESHOLD_MASK) |\\n            (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);\\n    }\\n\\n    /**\\n     * @dev Gets the liquidation threshold of the reserve\\n     * @param self The reserve configuration\\n     * @return The liquidation threshold\\n     **/\\n    function getLiquidationThreshold(\\n        DataTypes.ReserveConfigurationMap storage self\\n    ) internal view returns (uint256) {\\n        return\\n            (self.data & ~LIQUIDATION_THRESHOLD_MASK) >>\\n            LIQUIDATION_THRESHOLD_START_BIT_POSITION;\\n    }\\n\\n    /**\\n     * @dev Enables or disables borrowing on the reserve\\n     * @param self The reserve configuration\\n     * @param enabled True if the borrowing needs to be enabled, false otherwise\\n     **/\\n    function setBorrowingEnabled(\\n        DataTypes.ReserveConfigurationMap memory self,\\n        bool enabled\\n    ) internal pure {\\n        self.data =\\n            (self.data & BORROWING_MASK) |\\n            (uint256(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION);\\n    }\\n\\n    /**\\n     * @dev Gets the borrowing state of the reserve\\n     * @param self The reserve configuration\\n     * @return The borrowing state\\n     **/\\n    function getBorrowingEnabled(\\n        DataTypes.ReserveConfigurationMap storage self\\n    ) internal view returns (bool) {\\n        return (self.data & ~BORROWING_MASK) != 0;\\n    }\\n\\n    /**\\n     * @dev Enables or disables stable rate borrowing on the reserve\\n     * @param self The reserve configuration\\n     * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise\\n     **/\\n    function setStableRateBorrowingEnabled(\\n        DataTypes.ReserveConfigurationMap memory self,\\n        bool enabled\\n    ) internal pure {\\n        self.data =\\n            (self.data & STABLE_BORROWING_MASK) |\\n            (uint256(enabled ? 1 : 0) <<\\n                STABLE_BORROWING_ENABLED_START_BIT_POSITION);\\n    }\\n\\n    /**\\n     * @dev Gets the stable rate borrowing state of the reserve\\n     * @param self The reserve configuration\\n     * @return The stable rate borrowing state\\n     **/\\n    function getStableRateBorrowingEnabled(\\n        DataTypes.ReserveConfigurationMap storage self\\n    ) internal view returns (bool) {\\n        return (self.data & ~STABLE_BORROWING_MASK) != 0;\\n    }\\n\\n    /**\\n     * @dev Sets the liquidation duration of the reserve\\n     * @param self The reserve configuration\\n     * @param time The new liquidation duration\\n     **/\\n    function setLiquidationTime(\\n        DataTypes.ReserveConfigurationMap memory self,\\n        uint256 time\\n    ) internal pure {\\n        require(time <= MAX_VALID_LIQUIDATION_TIME, Errors.RC_INVALID_LIQ_TIME);\\n\\n        self.data =\\n            (self.data & LIQUIDATION_TIME_MASK) |\\n            (time << LIQUIDATION_TIME_START_BIT_POSITION);\\n    }\\n\\n    /**\\n     * @dev Gets the liquidation duration of the reserve\\n     * @param self The reserve configuration\\n     * @return The liquidation duration\\n     **/\\n    function getLiquidationTime(\\n        DataTypes.ReserveConfigurationMap storage self\\n    ) internal view returns (uint256) {\\n        return\\n            (self.data & ~LIQUIDATION_TIME_MASK) >>\\n            LIQUIDATION_TIME_START_BIT_POSITION;\\n    }\\n\\n    /**\\n     * @dev Sets the effective time of auction\\n     * @param self The reserve configuration\\n     * @param time The new auction duration\\n     **/\\n    function setBidTime(\\n        DataTypes.ReserveConfigurationMap memory self,\\n        uint256 time\\n    ) internal pure {\\n        require(time <= MAX_VALID_BID_TIME, Errors.RC_INVALID_BID_TIME);\\n\\n        self.data =\\n            (self.data & BID_TIME_MASK) |\\n            (time << BID_TIME_START_BIT_POSITION);\\n    }\\n\\n    /**\\n     * @dev Gets the effective time of auction\\n     * @param self The reserve configuration\\n     * @return The effective time of auction\\n     **/\\n    function getBidTime(\\n        DataTypes.ReserveConfigurationMap storage self\\n    ) internal view returns (uint256) {\\n        return (self.data & ~BID_TIME_MASK) >> BID_TIME_START_BIT_POSITION;\\n    }\\n\\n    /**\\n     * @dev Sets the frozen state of the reserve\\n     * @param self The reserve configuration\\n     * @param frozen The frozen state\\n     **/\\n    function setFrozen(\\n        DataTypes.ReserveConfigurationMap memory self,\\n        bool frozen\\n    ) internal pure {\\n        self.data =\\n            (self.data & FROZEN_MASK) |\\n            (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);\\n    }\\n\\n    /**\\n     * @dev Gets the frozen state of the reserve\\n     * @param self The reserve configuration\\n     * @return The frozen state\\n     **/\\n    function getFrozen(\\n        DataTypes.ReserveConfigurationMap storage self\\n    ) internal view returns (bool) {\\n        return (self.data & ~FROZEN_MASK) != 0;\\n    }\\n\\n    /**\\n     * @dev Sets the initial liquidity lock time of reserve\\n     * @param self The reserve configuration\\n     * @param lockTime The new lock\\n     **/\\n    function setLockTime(\\n        DataTypes.ReserveConfigurationMap memory self,\\n        uint256 lockTime\\n    ) internal pure {\\n        self.data =\\n            (self.data & LOCK_MASK) |\\n            (lockTime << LOCK_START_BIT_POSITION);\\n    }\\n\\n    /**\\n     * @dev Gets the lock time of initial liquidity\\n     * @param self The reserve configuration\\n     * @return The lock time of initial liquidity\\n     **/\\n    function getLockTime(\\n        DataTypes.ReserveConfigurationMap storage self\\n    ) internal view returns (uint256) {\\n        return (self.data & ~LOCK_MASK) >> LOCK_START_BIT_POSITION;\\n    }\\n\\n    /**\\n     * @dev Sets the type of reserve, 0 for perimissionless poo, 1 for blue chip, others for middle pool\\n     * @param self The reserve configuration\\n     * @param reserveType The new type\\n     **/\\n    function setType(\\n        DataTypes.ReserveConfigurationMap memory self,\\n        uint256 reserveType\\n    ) internal pure {\\n        self.data =\\n            (self.data & TYPE_MASK) |\\n            (reserveType << TYPE_START_BIT_POSITION);\\n    }\\n\\n    /**\\n     * @dev Gets the type of reserve, 0 for perimissionless poo, 1 for blue chip, others for middle pool\\n     * @param self The reserve configuration\\n     * @return The type of reserve\\n     **/\\n    function getType(\\n        DataTypes.ReserveConfigurationMap storage self\\n    ) internal view returns (uint256) {\\n        return (self.data & ~TYPE_MASK) >> TYPE_START_BIT_POSITION;\\n    }\\n\\n    /**\\n     * @dev Gets the configuration flags of the reserve\\n     * @param self The reserve configuration\\n     * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enabled\\n     **/\\n    function getFlags(\\n        DataTypes.ReserveConfigurationMap storage self\\n    ) internal view returns (bool, bool, bool, bool) {\\n        uint256 dataLocal = self.data;\\n\\n        return (\\n            (dataLocal & ~ACTIVE_MASK) != 0,\\n            (dataLocal & ~FROZEN_MASK) != 0,\\n            (dataLocal & ~BORROWING_MASK) != 0,\\n            (dataLocal & ~STABLE_BORROWING_MASK) != 0\\n        );\\n    }\\n\\n    /**\\n     * @dev Gets the configuration paramters of the reserve\\n     * @param self The reserve configuration\\n     * @return The state params representing factor, borrow ratio, minimum borrow time, liquidation threshold, liquidation duration, auction duration, lock time, reserve type\\n     **/\\n    function getParams(\\n        DataTypes.ReserveConfigurationMap storage self\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 dataLocal = self.data;\\n\\n        return (\\n            dataLocal & ~RESERVE_FACTOR_MASK,\\n            (dataLocal & ~BORROW_RATIO_MASK) >> BORROW_RATIO_START_BIT_POSITION,\\n            (dataLocal & ~PERIOD_MASK) >> PERIOD_START_BIT_POSITION,\\n            (dataLocal & ~MIN_BORROW_TIME_MASK) >>\\n                MIN_BORROW_TIME_START_BIT_POSITION,\\n            (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >>\\n                LIQUIDATION_THRESHOLD_START_BIT_POSITION,\\n            (dataLocal & ~LIQUIDATION_TIME_MASK) >>\\n                LIQUIDATION_TIME_START_BIT_POSITION,\\n            (dataLocal & ~BID_TIME_MASK) >> BID_TIME_START_BIT_POSITION,\\n            (dataLocal & ~LOCK_MASK) >> LOCK_START_BIT_POSITION,\\n            (dataLocal & ~TYPE_MASK) >> TYPE_START_BIT_POSITION\\n        );\\n    }\\n\\n    /**\\n     * @dev Gets the configuration paramters of the reserve from a memory object\\n     * @param self The reserve configuration\\n     * @return The state params representing factor, borrow ratio, minimum borrow time, liquidation threshold, liquidation duration, auction duration, lock time, reserve type\\n     **/\\n    function getParamsMemory(\\n        DataTypes.ReserveConfigurationMap memory self\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 localData = self.data;\\n        return (\\n            localData & ~RESERVE_FACTOR_MASK,\\n            (localData & ~BORROW_RATIO_MASK) >> BORROW_RATIO_START_BIT_POSITION,\\n            (localData & ~PERIOD_MASK) >> PERIOD_START_BIT_POSITION,\\n            (localData & ~MIN_BORROW_TIME_MASK) >>\\n                MIN_BORROW_TIME_START_BIT_POSITION,\\n            (localData & ~LIQUIDATION_THRESHOLD_MASK) >>\\n                LIQUIDATION_THRESHOLD_START_BIT_POSITION,\\n            (localData & ~LIQUIDATION_TIME_MASK) >>\\n                LIQUIDATION_TIME_START_BIT_POSITION,\\n            (localData & ~BID_TIME_MASK) >> BID_TIME_START_BIT_POSITION,\\n            (localData & ~LOCK_MASK) >> LOCK_START_BIT_POSITION,\\n            (localData & ~TYPE_MASK) >> TYPE_START_BIT_POSITION\\n        );\\n    }\\n\\n    /**\\n     * @dev Gets the configuration flags of the reserve from a memory object\\n     * @param self The reserve configuration\\n     * @return The state flags representing active, frozen, borrowing enabled, stableRateBorrowing enabled\\n     **/\\n    function getFlagsMemory(\\n        DataTypes.ReserveConfigurationMap memory self\\n    ) internal pure returns (bool, bool, bool, bool) {\\n        return (\\n            (self.data & ~ACTIVE_MASK) != 0,\\n            (self.data & ~FROZEN_MASK) != 0,\\n            (self.data & ~BORROWING_MASK) != 0,\\n            (self.data & ~STABLE_BORROWING_MASK) != 0\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/logic/ReserveLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.18;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"../../interfaces/IKToken.sol\\\";\\nimport \\\"../../interfaces/IInterestRateStrategy.sol\\\";\\nimport \\\"../../interfaces/IVariableDebtToken.sol\\\";\\nimport \\\"../../interfaces/IStableDebtToken.sol\\\";\\nimport \\\"../utils/MathUtils.sol\\\";\\nimport \\\"../utils/WadRayMath.sol\\\";\\nimport \\\"../utils/PercentageMath.sol\\\";\\nimport \\\"../utils/DataTypes.sol\\\";\\nimport \\\"../utils/Errors.sol\\\";\\nimport \\\"./ReserveConfiguration.sol\\\";\\n\\n/**\\n * @title ReserveLogic library\\n * @author Kyoko\\n * @notice Implements the logic to update the reserves state\\n */\\nlibrary ReserveLogic {\\n    using WadRayMath for uint256;\\n    using PercentageMath for uint256;\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n    /**\\n     * @dev Emitted when the state of a reserve is updated\\n     * @param reserveId The id of the reserve\\n     * @param liquidityRate The new liquidity rate\\n     * @param stableBorrowRate The new stable borrow rate\\n     * @param variableBorrowRate The new variable borrow rate\\n     * @param liquidityIndex The new liquidity index\\n     * @param variableBorrowIndex The new variable borrow index\\n     **/\\n    event ReserveDataUpdated(\\n        uint256 indexed reserveId,\\n        uint256 liquidityRate,\\n        uint256 stableBorrowRate,\\n        uint256 variableBorrowRate,\\n        uint256 liquidityIndex,\\n        uint256 variableBorrowIndex\\n    );\\n\\n    using ReserveLogic for DataTypes.ReserveData;\\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\n\\n    /**\\n     * @dev Returns the ongoing normalized income for the reserve\\n     * A value of 1e27 means there is no income. As time passes, the income is accrued\\n     * A value of 2*1e27 means for each unit of asset one unit of income has been accrued\\n     * @param reserve The reserve object\\n     * @return the normalized income. expressed in ray\\n     **/\\n    function getNormalizedIncome(\\n        DataTypes.ReserveData storage reserve\\n    ) internal view returns (uint256) {\\n        uint40 timestamp = reserve.lastUpdateTimestamp;\\n\\n        //solium-disable-next-line\\n        if (timestamp == uint40(block.timestamp)) {\\n            //if the index was updated in the same block, no need to perform any calculation\\n            return reserve.liquidityIndex;\\n        }\\n\\n        uint256 cumulated = MathUtils\\n            .calculateLinearInterest(reserve.currentLiquidityRate, timestamp)\\n            .rayMul(reserve.liquidityIndex);\\n\\n        return cumulated;\\n    }\\n\\n    /**\\n     * @dev Returns the ongoing normalized variable debt for the reserve\\n     * A value of 1e27 means there is no debt. As time passes, the income is accrued\\n     * A value of 2*1e27 means that for each unit of debt, one unit worth of interest has been accumulated\\n     * @param reserve The reserve object\\n     * @return The normalized variable debt. expressed in ray\\n     **/\\n    function getNormalizedDebt(\\n        DataTypes.ReserveData storage reserve\\n    ) internal view returns (uint256) {\\n        uint40 timestamp = reserve.lastUpdateTimestamp;\\n\\n        //solium-disable-next-line\\n        if (timestamp == uint40(block.timestamp)) {\\n            //if the index was updated in the same block, no need to perform any calculation\\n            return reserve.variableBorrowIndex;\\n        }\\n\\n        uint256 cumulated = MathUtils\\n            .calculateCompoundedInterest(\\n                reserve.currentVariableBorrowRate,\\n                timestamp\\n            )\\n            .rayMul(reserve.variableBorrowIndex);\\n\\n        return cumulated;\\n    }\\n\\n    /**\\n     * @dev Updates the liquidity cumulative index and the variable borrow index.\\n     * @param reserve the reserve object\\n     **/\\n    function updateState(DataTypes.ReserveData storage reserve) internal {\\n        uint256 scaledVariableDebt = IVariableDebtToken(\\n            reserve.variableDebtTokenAddress\\n        ).scaledTotalSupply();\\n        uint256 previousVariableBorrowIndex = reserve.variableBorrowIndex;\\n        uint256 previousLiquidityIndex = reserve.liquidityIndex;\\n        uint40 lastUpdatedTimestamp = reserve.lastUpdateTimestamp;\\n\\n        (\\n            uint256 newLiquidityIndex,\\n            uint256 newVariableBorrowIndex\\n        ) = _updateIndexes(\\n                reserve,\\n                scaledVariableDebt,\\n                previousLiquidityIndex,\\n                previousVariableBorrowIndex,\\n                lastUpdatedTimestamp\\n            );\\n\\n        _mintToTreasury(\\n            reserve,\\n            scaledVariableDebt,\\n            previousVariableBorrowIndex,\\n            newLiquidityIndex,\\n            newVariableBorrowIndex,\\n            lastUpdatedTimestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev Accumulates a predefined amount of asset to the reserve as a fixed, instantaneous income. Used for example to accumulate\\n     * the flashloan fee to the reserve, and spread it between all the depositors\\n     * @param reserve The reserve object\\n     * @param totalLiquidity The total liquidity available in the reserve\\n     * @param amount The amount to accomulate\\n     **/\\n    function cumulateToLiquidityIndex(\\n        DataTypes.ReserveData storage reserve,\\n        uint256 totalLiquidity,\\n        uint256 amount\\n    ) internal {\\n        uint256 amountToLiquidityRatio = amount.wadToRay().rayDiv(\\n            totalLiquidity.wadToRay()\\n        );\\n\\n        uint256 result = amountToLiquidityRatio + WadRayMath.ray();\\n\\n        result = result.rayMul(reserve.liquidityIndex);\\n        require(\\n            result <= type(uint128).max,\\n            Errors.RL_LIQUIDITY_INDEX_OVERFLOW\\n        );\\n\\n        reserve.liquidityIndex = uint128(result);\\n    }\\n\\n    /**\\n     * @dev Initializes a reserve\\n     * @param reserve The reserve object\\n     * @param kTokenAddress The address of the overlying kToken contract\\n     * @param stableDebtTokenAddress The address of stableDebtToken\\n     * @param variableDebtTokenAddress The address of variableDebtToken\\n     * @param interestRateStrategyAddress The address of rate strategy\\n     **/\\n    function init(\\n        DataTypes.ReserveData storage reserve,\\n        address kTokenAddress,\\n        address stableDebtTokenAddress,\\n        address variableDebtTokenAddress,\\n        address interestRateStrategyAddress\\n    ) external {\\n        require(\\n            reserve.kTokenAddress == address(0),\\n            Errors.RL_RESERVE_ALREADY_INITIALIZED\\n        );\\n\\n        reserve.liquidityIndex = uint128(WadRayMath.ray());\\n        reserve.variableBorrowIndex = uint128(WadRayMath.ray());\\n        reserve.kTokenAddress = kTokenAddress;\\n        reserve.stableDebtTokenAddress = stableDebtTokenAddress;\\n        reserve.variableDebtTokenAddress = variableDebtTokenAddress;\\n        reserve.interestRateStrategyAddress = interestRateStrategyAddress;\\n    }\\n\\n    struct UpdateInterestRatesLocalVars {\\n        address stableDebtTokenAddress;\\n        uint256 availableLiquidity;\\n        uint256 totalStableDebt;\\n        uint256 newLiquidityRate;\\n        uint256 newStableRate;\\n        uint256 newVariableRate;\\n        uint256 avgStableRate;\\n        uint256 totalVariableDebt;\\n    }\\n\\n    /**\\n     * @dev Updates the reserve current stable borrow rate, the current variable borrow rate and the current liquidity rate\\n     * @param reserve The address of the reserve to be updated\\n     * @param liquidityAdded The amount of liquidity added to the protocol (deposit or repay) in the previous action\\n     * @param liquidityTaken The amount of liquidity taken from the protocol (redeem or borrow)\\n     **/\\n    function updateInterestRates(\\n        DataTypes.ReserveData storage reserve,\\n        address reserveAddress,\\n        address kTokenAddress,\\n        uint256 liquidityAdded,\\n        uint256 liquidityTaken\\n    ) internal {\\n        UpdateInterestRatesLocalVars memory vars;\\n        uint256 reserveId = reserve.id;\\n\\n        vars.stableDebtTokenAddress = reserve.stableDebtTokenAddress;\\n\\n        (vars.totalStableDebt, vars.avgStableRate) = IStableDebtToken(\\n            vars.stableDebtTokenAddress\\n        ).getTotalSupplyAndAvgRate();\\n\\n        //calculates the total variable debt locally using the scaled total supply instead\\n        //of totalSupply(), as it's noticeably cheaper. Also, the index has been\\n        //updated by the previous updateState() call\\n        vars.totalVariableDebt = IVariableDebtToken(\\n            reserve.variableDebtTokenAddress\\n        ).scaledTotalSupply().rayMul(reserve.variableBorrowIndex);\\n\\n        uint256 factor = reserve.configuration.getReserveFactor();\\n\\n        (\\n            vars.newLiquidityRate,\\n            vars.newStableRate,\\n            vars.newVariableRate\\n        ) = IInterestRateStrategy(reserve.interestRateStrategyAddress)\\n            .calculateInterestRates(\\n                reserve.id,\\n                reserveAddress,\\n                kTokenAddress,\\n                liquidityAdded,\\n                liquidityTaken,\\n                vars.totalStableDebt,\\n                vars.totalVariableDebt,\\n                vars.avgStableRate,\\n                factor\\n            );\\n        require(\\n            vars.newLiquidityRate <= type(uint128).max,\\n            Errors.RL_LIQUIDITY_RATE_OVERFLOW\\n        );\\n        require(\\n            vars.newStableRate <= type(uint128).max,\\n            Errors.RL_STABLE_BORROW_RATE_OVERFLOW\\n        );\\n        require(\\n            vars.newVariableRate <= type(uint128).max,\\n            Errors.RL_VARIABLE_BORROW_RATE_OVERFLOW\\n        );\\n\\n        reserve.currentLiquidityRate = uint128(vars.newLiquidityRate);\\n        reserve.currentStableBorrowRate = uint128(vars.newStableRate);\\n        reserve.currentVariableBorrowRate = uint128(vars.newVariableRate);\\n\\n        emit ReserveDataUpdated(\\n            reserveId,\\n            vars.newLiquidityRate,\\n            vars.newStableRate,\\n            vars.newVariableRate,\\n            reserve.liquidityIndex,\\n            reserve.variableBorrowIndex\\n        );\\n    }\\n\\n    struct MintToTreasuryLocalVars {\\n        uint256 currentStableDebt;\\n        uint256 principalStableDebt;\\n        uint256 previousStableDebt;\\n        uint256 currentVariableDebt;\\n        uint256 previousVariableDebt;\\n        uint256 avgStableRate;\\n        uint256 cumulatedStableInterest;\\n        uint256 totalDebtAccrued;\\n        uint256 amountToMint;\\n        uint256 reserveFactor;\\n        uint40 stableSupplyUpdatedTimestamp;\\n    }\\n\\n    /**\\n     * @dev Mints part of the repaid interest to the reserve treasury as a function of the reserveFactor for the\\n     * specific asset.\\n     * @param reserve The reserve reserve to be updated\\n     * @param scaledVariableDebt The current scaled total variable debt\\n     * @param previousVariableBorrowIndex The variable borrow index before the last accumulation of the interest\\n     * @param newLiquidityIndex The new liquidity index\\n     * @param newVariableBorrowIndex The variable borrow index after the last accumulation of the interest\\n     **/\\n    function _mintToTreasury(\\n        DataTypes.ReserveData storage reserve,\\n        uint256 scaledVariableDebt,\\n        uint256 previousVariableBorrowIndex,\\n        uint256 newLiquidityIndex,\\n        uint256 newVariableBorrowIndex,\\n        uint40 timestamp\\n    ) internal {\\n        MintToTreasuryLocalVars memory vars;\\n\\n        vars.reserveFactor = reserve.configuration.getReserveFactor();\\n\\n        if (vars.reserveFactor == 0) {\\n            return;\\n        }\\n\\n        //fetching the principal, total stable debt and the avg stable rate\\n        (\\n            vars.principalStableDebt,\\n            vars.currentStableDebt,\\n            vars.avgStableRate,\\n            vars.stableSupplyUpdatedTimestamp\\n        ) = IStableDebtToken(reserve.stableDebtTokenAddress).getSupplyData();\\n\\n        //calculate the last principal variable debt\\n        vars.previousVariableDebt = scaledVariableDebt.rayMul(\\n            previousVariableBorrowIndex\\n        );\\n\\n        //calculate the new total supply after accumulation of the index\\n        vars.currentVariableDebt = scaledVariableDebt.rayMul(\\n            newVariableBorrowIndex\\n        );\\n\\n        //calculate the stable debt until the last timestamp update\\n        vars.cumulatedStableInterest = MathUtils.calculateCompoundedInterest(\\n            vars.avgStableRate,\\n            vars.stableSupplyUpdatedTimestamp,\\n            timestamp\\n        );\\n\\n        vars.previousStableDebt = vars.principalStableDebt.rayMul(\\n            vars.cumulatedStableInterest\\n        );\\n\\n        //debt accrued is the sum of the current debt minus the sum of the debt at the last update\\n        vars.totalDebtAccrued =\\n            vars.currentVariableDebt +\\n            vars.currentStableDebt -\\n            vars.previousVariableDebt -\\n            vars.previousStableDebt;\\n\\n        vars.amountToMint = vars.totalDebtAccrued.percentMul(\\n            vars.reserveFactor\\n        );\\n\\n        if (vars.amountToMint != 0) {\\n            IKToken(reserve.kTokenAddress).mintToTreasury(\\n                vars.amountToMint,\\n                newLiquidityIndex\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates the reserve indexes and the timestamp of the update\\n     * @param reserve The reserve reserve to be updated\\n     * @param scaledVariableDebt The scaled variable debt\\n     * @param liquidityIndex The last stored liquidity index\\n     * @param variableBorrowIndex The last stored variable borrow index\\n     **/\\n    function _updateIndexes(\\n        DataTypes.ReserveData storage reserve,\\n        uint256 scaledVariableDebt,\\n        uint256 liquidityIndex,\\n        uint256 variableBorrowIndex,\\n        uint40 timestamp\\n    ) internal returns (uint256, uint256) {\\n        uint256 currentLiquidityRate = reserve.currentLiquidityRate;\\n\\n        uint256 newLiquidityIndex = liquidityIndex;\\n        uint256 newVariableBorrowIndex = variableBorrowIndex;\\n\\n        //only cumulating if there is any income being produced\\n        if (currentLiquidityRate > 0) {\\n            uint256 cumulatedLiquidityInterest = MathUtils\\n                .calculateLinearInterest(currentLiquidityRate, timestamp);\\n            newLiquidityIndex = cumulatedLiquidityInterest.rayMul(\\n                liquidityIndex\\n            );\\n            require(\\n                newLiquidityIndex <= type(uint128).max,\\n                Errors.RL_LIQUIDITY_INDEX_OVERFLOW\\n            );\\n\\n            reserve.liquidityIndex = uint128(newLiquidityIndex);\\n\\n            //as the liquidity rate might come only from stable rate loans, we need to ensure\\n            //that there is actual variable debt before accumulating\\n            if (scaledVariableDebt != 0) {\\n                uint256 cumulatedVariableBorrowInterest = MathUtils\\n                    .calculateCompoundedInterest(\\n                        reserve.currentVariableBorrowRate,\\n                        timestamp\\n                    );\\n                newVariableBorrowIndex = cumulatedVariableBorrowInterest.rayMul(\\n                    variableBorrowIndex\\n                );\\n                require(\\n                    newVariableBorrowIndex <= type(uint128).max,\\n                    Errors.RL_VARIABLE_BORROW_INDEX_OVERFLOW\\n                );\\n                reserve.variableBorrowIndex = uint128(newVariableBorrowIndex);\\n            }\\n        }\\n\\n        //solium-disable-next-line\\n        reserve.lastUpdateTimestamp = uint40(block.timestamp);\\n        return (newLiquidityIndex, newVariableBorrowIndex);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/logic/ValidationLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.18;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\\\";\\nimport \\\"./ReserveLogic.sol\\\";\\nimport \\\"./ReserveConfiguration.sol\\\";\\nimport \\\"../utils/WadRayMath.sol\\\";\\nimport \\\"../utils/PercentageMath.sol\\\";\\nimport \\\"../utils/DataTypes.sol\\\";\\nimport \\\"../utils/Errors.sol\\\";\\nimport \\\"../../interfaces/IInterestRateStrategy.sol\\\";\\n\\n/**\\n * @title ValidationLogic library\\n * @author Kyoko\\n * @notice Implements functions to validate the different actions of the protocol\\n */\\nlibrary ValidationLogic {\\n    using ReserveLogic for DataTypes.ReserveData;\\n    using WadRayMath for uint256;\\n    using PercentageMath for uint256;\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\\n\\n    uint256 public constant REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD = 4000;\\n    uint256 public constant REBALANCE_UP_USAGE_RATIO_THRESHOLD = 0.95 * 1e27; //usage ratio of 95%\\n\\n    /**\\n     * @dev Validates a deposit action\\n     * @param reserve The reserve object on which the user is depositing\\n     * @param amount The amount to be deposited\\n     */\\n    function validateDeposit(\\n        DataTypes.ReserveData storage reserve,\\n        uint256 amount\\n    ) external view {\\n        (bool isActive, bool isFrozen, , ) = reserve.configuration.getFlags();\\n\\n        require(amount != 0, Errors.VL_INVALID_AMOUNT);\\n        require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\\n        require(!isFrozen, Errors.VL_RESERVE_FROZEN);\\n    }\\n\\n    /**\\n     * @dev Validates a withdraw action\\n     * @param reserve The reserve object\\n     * @param amount The amount to be withdrawn\\n     * @param userBalance The balance of the user\\n     */\\n    function validateWithdraw(\\n        DataTypes.ReserveData storage reserve,\\n        uint256 amount,\\n        uint256 userBalance\\n    ) external view {\\n        require(amount != 0, Errors.VL_INVALID_AMOUNT);\\n        require(\\n            amount <= userBalance,\\n            Errors.VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE\\n        );\\n\\n        bool isActive = reserve.configuration.getActive();\\n        require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\\n    }\\n\\n    /**\\n     * @dev Validates a borrow action\\n     * @param reserve The reserve state from which the user is borrowing\\n     * @param asset The address of the asset to borrow\\n     * @param tokenId The token id of the nft which the user is borrowing\\n     * @param userAddress The address of the user\\n     * @param interestRateMode The interest rate mode at which the user is borrowing\\n     */\\n\\n    function validateBorrow(\\n        DataTypes.ReserveData storage reserve,\\n        address asset,\\n        uint256 tokenId,\\n        address userAddress,\\n        uint256 interestRateMode,\\n        bool flag\\n    ) external view {\\n        (\\n            bool isActive,\\n            bool isFrozen,\\n            bool borrowingEnabled,\\n            bool stableRateBorrowingEnabled\\n        ) = reserve.configuration.getFlags();\\n        require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\\n        require(!isFrozen, Errors.VL_RESERVE_FROZEN);\\n        require(borrowingEnabled, Errors.VL_BORROWING_NOT_ENABLED);\\n        require(\\n            IERC721Upgradeable(asset).ownerOf(tokenId) == userAddress,\\n            Errors.VL_NOT_NFT_OWNER\\n        );\\n\\n        require(flag, Errors.VL_NOT_SUPPORT);\\n\\n        //validate interest rate mode\\n        require(\\n            uint256(DataTypes.InterestRateMode.VARIABLE) == interestRateMode ||\\n                uint256(DataTypes.InterestRateMode.STABLE) == interestRateMode,\\n            Errors.VL_INVALID_INTEREST_RATE_MODE_SELECTED\\n        );\\n\\n        if (interestRateMode == uint256(DataTypes.InterestRateMode.STABLE)) {\\n            //check if the borrow mode is stable and if stable rate borrowing is enabled on this reserve\\n            require(\\n                stableRateBorrowingEnabled,\\n                Errors.VL_STABLE_BORROWING_NOT_ENABLED\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Validates a repay action\\n     * @param reserve The reserve state from which the user is repaying\\n     * @param borrowInfo The borrow state from which the user is repaying\\n     * @param user The address of the user msg.sender is repaying for\\n     * @param amountSent The amount sent for the repayment\\n     * @param amountPay The amount for user should pay\\n     * @param floor The floor price of the repay nft\\n     */\\n    function validateRepay(\\n        DataTypes.ReserveData storage reserve,\\n        DataTypes.BorrowInfo storage borrowInfo,\\n        address user,\\n        uint256 amountSent,\\n        uint256 amountPay,\\n        uint256 floor\\n    ) external view {\\n        bool isActive = reserve.configuration.getActive();\\n        uint256 liqThreshold = reserve.configuration.getLiquidationThreshold();\\n\\n        require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\\n        uint256 minBorrowTime = reserve.configuration.getMinBorrowTime();\\n        require(\\n            block.timestamp - borrowInfo.startTime > minBorrowTime,\\n            Errors.VL_TOO_EARLY\\n        );\\n        require(\\n            borrowInfo.status == DataTypes.Status.BORROW,\\n            Errors.VL_BAD_STATUS\\n        );\\n        require(borrowInfo.user == user, Errors.VL_INVALID_USER);\\n\\n        require(amountSent > 0, Errors.VL_INVALID_AMOUNT);\\n        require(amountPay > 0, Errors.VL_NO_DEBT_OF_SELECTED_TYPE);\\n        require(amountSent >= amountPay, Errors.LP_REQUESTED_AMOUNT_TOO_SMALL);\\n        if (borrowInfo.rateMode == DataTypes.InterestRateMode.STABLE) {\\n            require(\\n                block.timestamp <= borrowInfo.liquidateTime,\\n                Errors.VL_TOO_LATE\\n            );\\n        } else if (borrowInfo.rateMode == DataTypes.InterestRateMode.VARIABLE) {\\n            require(\\n                floor > amountPay.percentMul(liqThreshold),\\n                Errors.VL_BAD_PRICE_TO_REPAY\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Validates the liquidation action\\n     * @param reserve The reserve state from which the user is liquidating\\n     * @param borrowInfo The borrow state from which the user is liquidating\\n     * @param amountSent The bid price has been paid\\n     * @param amountPay The debt should be paid\\n     * @param floor The floor price of the liquidated nft\\n     **/\\n    function validateLiquidationCall(\\n        DataTypes.ReserveData storage reserve,\\n        DataTypes.BorrowInfo storage borrowInfo,\\n        uint256 amountSent,\\n        uint256 amountPay,\\n        uint256 floor\\n    ) external view {\\n        bool isActive = reserve.configuration.getActive();\\n        uint256 liqThreshold = reserve.configuration.getLiquidationThreshold();\\n\\n        require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\\n        require(\\n            borrowInfo.user != address(0) &&\\n                borrowInfo.status == DataTypes.Status.BORROW,\\n            Errors.VL_BAD_STATUS\\n        );\\n        if (borrowInfo.rateMode == DataTypes.InterestRateMode.VARIABLE) {\\n            require(\\n                floor < amountPay.percentMul(liqThreshold),\\n                Errors.KPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD\\n            );\\n        } else if (borrowInfo.rateMode == DataTypes.InterestRateMode.STABLE) {\\n            require(\\n                block.timestamp > borrowInfo.liquidateTime,\\n                Errors.VL_TOO_EARLY\\n            );\\n        }\\n        require(amountSent > 0, Errors.VL_INVALID_AMOUNT);\\n        require(amountPay > 0, Errors.VL_NO_DEBT_OF_SELECTED_TYPE);\\n        require(amountSent >= amountPay, Errors.LP_REQUESTED_AMOUNT_TOO_SMALL);\\n    }\\n\\n    /**\\n     * @dev Validates a stable borrow rate rebalance action\\n     * @param reserve The reserve state on which the user is getting rebalanced\\n     * @param reserveAddress The address of the reserve\\n     * @param stableDebtToken The stable debt token instance\\n     * @param variableDebtToken The variable debt token instance\\n     * @param kTokenAddress The address of the kToken contract\\n     */\\n    function validateRebalanceStableBorrowRate(\\n        DataTypes.ReserveData storage reserve,\\n        address reserveAddress,\\n        IERC20Upgradeable stableDebtToken,\\n        IERC20Upgradeable variableDebtToken,\\n        address kTokenAddress\\n    ) external view {\\n        //   DataTypes.Rate memory rate = reserve.rate;\\n        bool isActive = reserve.configuration.getActive();\\n\\n        require(isActive, Errors.VL_NO_ACTIVE_RESERVE);\\n\\n        //if the usage ratio is below 95%, no rebalances are needed\\n        uint256 totalDebt = (stableDebtToken.totalSupply() +\\n            variableDebtToken.totalSupply()).wadToRay();\\n        uint256 availableLiquidity = IERC20Upgradeable(reserveAddress)\\n            .balanceOf(kTokenAddress)\\n            .wadToRay();\\n        uint256 usageRatio = totalDebt == 0\\n            ? 0\\n            : totalDebt.rayDiv(availableLiquidity + totalDebt);\\n\\n        //if the liquidity rate is below REBALANCE_UP_THRESHOLD of the max variable APR at 95% usage,\\n        //then we allow rebalancing of the stable rate positions.\\n\\n        uint256 currentLiquidityRate = reserve.currentLiquidityRate;\\n        // uint256 maxVariableBorrowRate = rate.baseVariableBorrowRate + rate.variableRateSlope1 + rate.variableRateSlope2;\\n        uint256 maxVariableBorrowRate = IInterestRateStrategy(\\n            reserve.interestRateStrategyAddress\\n        ).getMaxVariableBorrowRate(reserve.id);\\n\\n        require(\\n            usageRatio >= REBALANCE_UP_USAGE_RATIO_THRESHOLD &&\\n                currentLiquidityRate <=\\n                maxVariableBorrowRate.percentMul(\\n                    REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD\\n                ),\\n            Errors.LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET\\n        );\\n    }\\n\\n    /**\\n     * @dev Validates the auction action\\n     * @param auction The auction info\\n     * @param status The status of borrow nft\\n     * @param amountSent The bid price has been paid\\n     **/\\n    function validateBidCall(\\n        DataTypes.Auction storage auction,\\n        DataTypes.Status status,\\n        uint256 amountSent\\n    ) internal view {\\n        require(status == DataTypes.Status.AUCTION, Errors.VL_BAD_STATUS);\\n        require(!auction.settled, Errors.VL_AUCTION_ALREADY_SETTLED);\\n        require(\\n            amountSent > auction.amount,\\n            Errors.LP_REQUESTED_AMOUNT_TOO_SMALL\\n        );\\n        require(block.timestamp < auction.endTime, Errors.VL_TOO_LATE);\\n    }\\n\\n    /**\\n     * @dev Validates the claim action\\n     * @param borrowInfo The borrow info\\n     * @param auction The auction info\\n     * @param user The address of the claim user\\n     **/\\n    function validateClaimCall(\\n        DataTypes.BorrowInfo storage borrowInfo,\\n        DataTypes.Auction storage auction,\\n        address user\\n    ) internal view {\\n        require(\\n            borrowInfo.status == DataTypes.Status.AUCTION,\\n            Errors.VL_BAD_STATUS\\n        );\\n        require(!auction.settled, Errors.VL_AUCTION_ALREADY_SETTLED);\\n        require(auction.bidder == user, Errors.VL_INVALID_USER);\\n        require(block.timestamp > auction.endTime, Errors.VL_TOO_EARLY);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/utils/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.18;\\n\\nlibrary DataTypes {\\n    struct ReserveData {\\n        //stores the reserve configuration\\n        ReserveConfigurationMap configuration;\\n        //the liquidity index. Expressed in ray\\n        uint128 liquidityIndex;\\n        // variable borrow index. Expressed in ray\\n        uint128 variableBorrowIndex;\\n        //the current supply rate. Expressed in ray\\n        uint128 currentLiquidityRate;\\n        // the current variable borrow rate. Expressed in ray\\n        uint128 currentVariableBorrowRate;\\n        //the current stable borrow rate. Expressed in ray\\n        uint128 currentStableBorrowRate;\\n        uint40 lastUpdateTimestamp;\\n        //tokens addresses\\n        address kTokenAddress;\\n        address stableDebtTokenAddress;\\n        address variableDebtTokenAddress;\\n        //address of the interest rate strategy\\n        address interestRateStrategyAddress;\\n        //the id of the reserve. Represents the position in the list of the active reserves\\n        uint256 id;\\n    }\\n\\n    struct ReserveConfigurationMap {\\n        // bit 0-15: factor\\n        // bit 16-31: borrow ratio\\n        // bit 32-71: period\\n        // bit 72-111: min borrow time\\n        // bit 112: reserve is active\\n        // bit 113-128: Liq. threshold\\n        // bit 129: borrowing is enabled\\n        // bit 130: stable rate borrowing enabled\\n        // bit 131-154: liquidation duration\\n        // bit 155-178: auction duration\\n        // bit 179: reserve is frozen\\n        // bit 180-211: initial liquidity lock period\\n        // bit 212-219: reserve type\\n        uint256 data;\\n    }\\n\\n    struct Request {\\n        address user;\\n        address nft;\\n        uint256 id;\\n        InterestRateMode rateMode;\\n        uint256 reserveId;\\n    }\\n\\n    enum Status {\\n        BORROW,\\n        REPAY,\\n        AUCTION,\\n        WITHDRAW\\n    }\\n\\n    enum InterestRateMode {\\n        NONE,\\n        STABLE,\\n        VARIABLE\\n    }\\n\\n    struct BorrowInfo {\\n        uint256 reserveId;\\n        address nft;\\n        uint256 nftId;\\n        address user;\\n        uint64 startTime;\\n        uint256 principal;\\n        uint256 borrowId;\\n        uint64 liquidateTime;\\n        Status status;\\n        InterestRateMode rateMode;\\n    }\\n\\n    struct Auction {\\n        // ID for the Noun (ERC721 token ID)\\n        uint256 borrowId;\\n        // The current highest bid amount\\n        uint256 amount;\\n        // The time that the auction started\\n        uint256 startTime;\\n        // The time that the auction is scheduled to end\\n        uint256 endTime;\\n        // The address of the current highest bid\\n        address payable bidder;\\n        // Whether or not the auction has been settled\\n        bool settled;\\n    }\\n\\n    struct InitReserveInput {\\n        uint256 reserveId;\\n        address kTokenImpl;\\n        address stableDebtTokenImpl;\\n        address variableDebtTokenImpl;\\n        address interestRateStrategyAddress;\\n        address underlyingAsset;\\n        address treasury;\\n        uint16 factor;\\n        uint16 borrowRatio;\\n        uint40 period;\\n        uint40 minBorrowTime;\\n        uint16 liqThreshold;\\n        uint24 liqDuration;\\n        uint24 bidDuration;\\n        uint32 lockTime;\\n        bool stableBorrowed;\\n    }\\n\\n    struct RateStrategyInput {\\n        uint256 reserveId;\\n        uint256 optimalUtilizationRate;\\n        uint256 baseVariableBorrowRate;\\n        uint256 variableSlope1;\\n        uint256 variableSlope2;\\n        uint256 baseStableBorrowRate;\\n        uint256 stableSlope1;\\n        uint256 stableSlope2;\\n    }\\n    \\n    struct Rate {\\n        /**\\n         * @dev this constant represents the utilization rate at which the pool aims to obtain most competitive borrow rates.\\n         * Expressed in ray\\n         **/\\n        uint256 optimalUtilizationRate;\\n        /**\\n         * @dev This constant represents the excess utilization rate above the optimal. It's always equal to\\n         * 1-optimal utilization rate. Added as a constant here for gas optimizations.\\n         * Expressed in ray\\n         **/\\n        uint256 excessUtilizationRate;\\n        // Base variable borrow rate when Utilization rate = 0. Expressed in ray\\n        uint256 baseVariableBorrowRate;\\n        // Slope of the variable interest curve when utilization rate > 0 and <= OPTIMAL_UTILIZATION_RATE. Expressed in ray\\n        uint256 variableRateSlope1;\\n        // Slope of the variable interest curve when utilization rate > OPTIMAL_UTILIZATION_RATE. Expressed in ray\\n        uint256 variableRateSlope2;\\n        // Base stable borrow rate when Utilization rate = 0. Expressed in ray\\n        uint256 baseStableBorrowRate;\\n        // Slope of the stable interest curve when utilization rate > 0 and <= OPTIMAL_UTILIZATION_RATE. Expressed in ray\\n        uint256 stableRateSlope1;\\n        // Slope of the stable interest curve when utilization rate > OPTIMAL_UTILIZATION_RATE. Expressed in ray\\n        uint256 stableRateSlope2;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/utils/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Errors library\\n * @author Kyoko\\n * @notice Defines the error messages emitted by the different contracts of the Kyoko protocol\\n * @dev Error messages prefix glossary:\\n *  - VL = ValidationLogic\\n *  - MATH = Math libraries\\n *  - CT = Common errors between tokens (KToken, VariableDebtToken and StableDebtToken)\\n *  - KT = KToken\\n *  - SDT = StableDebtToken\\n *  - VDT = VariableDebtToken\\n *  - KP = KyokoPool\\n *  - KF = KyokoFactory\\n *  - KPC = KyokoPoolConfiguration\\n *  - RL = ReserveLogic\\n *  - KPCM = KyokoPoolCollateralManager\\n *  - P = Pausable\\n */\\nlibrary Errors {\\n  //common errors\\n  string public constant CALLER_NOT_POOL_ADMIN = '25'; // 'The caller must be the pool admin'\\n  string public constant BORROW_ALLOWANCE_NOT_ENOUGH = '26'; // User borrows on behalf, but allowance are too small\\n  string public constant ERROR = '27'; // User borrows on behalf, but allowance are too small\\n\\n  //contract specific errors\\n  string public constant VL_INVALID_AMOUNT = '1'; // 'Amount must be greater than 0'\\n  string public constant VL_NO_ACTIVE_RESERVE = '2'; // 'Action requires an active reserve'\\n  string public constant VL_RESERVE_FROZEN = '3'; // 'Action cannot be performed because the reserve is frozen'\\n  string public constant VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE = '4'; // 'User cannot withdraw more than the available balance'\\n  string public constant VL_INVALID_INTEREST_RATE_MODE_SELECTED = '5'; // 'Invalid interest rate mode selected'\\n  string public constant VL_BORROWING_NOT_ENABLED = '6'; // 'Borrowing is not enabled'\\n  string public constant VL_STABLE_BORROWING_NOT_ENABLED = '7'; // stable borrowing not enabled\\n  string public constant VL_NO_DEBT_OF_SELECTED_TYPE = '8'; // 'for repayment of stable debt, the user needs to have stable debt, otherwise, he needs to have variable debt'\\n  string public constant VL_NOT_NFT_OWNER = '9'; // 'User is not the owner of the nft'\\n  string public constant VL_NOT_SUPPORT = '10'; // 'User's nft for borrow is not support'\\n  string public constant VL_TOO_EARLY = '11'; // 'Action is earlier than requested'\\n  string public constant VL_TOO_LATE = '12'; // 'Action is later than requested'\\n  string public constant VL_BAD_STATUS = '13'; // 'Action with wrong borrow status'\\n  string public constant VL_INVALID_USER = '14'; // 'User is not borrow owner'\\n  string public constant VL_AUCTION_ALREADY_SETTLED = '15'; // 'Auction is already done'\\n  string public constant VL_BAD_PRICE_TO_REPAY = '16'; // 'The floor price below liquidation price'\\n  string public constant LP_NOT_ENOUGH_STABLE_BORROW_BALANCE = '31'; // 'User does not have any stable rate loan for this reserve'\\n  string public constant LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = '32'; // 'Interest rate rebalance conditions were not met'\\n  string public constant LP_LIQUIDATION_CALL_FAILED = '33'; // 'Liquidation call failed'\\n  string public constant LP_REQUESTED_AMOUNT_TOO_SMALL = '34'; // 'The requested amount is too small for an action.'\\n  string public constant LP_CALLER_NOT_KYOKO_POOL_CONFIGURATOR = '35'; // 'The caller of the function is Kyoko pool configurator'\\n  string public constant LP_CALLER_NOT_KYOKO_POOL_ORACLE = '36'; // 'The caller of the function is not the Kyoko pool oracle'\\n  string public constant LP_CALLER_NOT_KYOKO_POOL_FACTORY = '37'; // 'The caller of the function is not the Kyoko pool factory'\\n  string public constant LP_NFT_ALREADY_EXIST = '38'; // 'The initial reserve nft is already exist'\\n  string public constant LP_WETH_TRANSFER_FAILED = '39'; // 'Failed to transfer eth and weth'\\n  string public constant LP_BORROW_FAILED = '41'; // 'Can't be borrowed'\\n  string public constant LP_LIQUIDITY_INSUFFICIENT = '42'; // 'Insufficient pool balance'\\n  string public constant LP_IS_PAUSED = '43'; // 'Pool is paused'\\n  string public constant LP_NO_MORE_RESERVES_ALLOWED = '44';\\n  string public constant LP_NOT_CONTRACT = '45';\\n  string public constant LP_NFT_NOT_SUPPORT = '46';\\n  string public constant CT_CALLER_MUST_BE_KYOKO_POOL = '51'; // 'The caller of this function must be a Kyoko pool'\\n  string public constant RL_RESERVE_ALREADY_INITIALIZED = '52'; // 'Reserve has already been initialized'\\n  string public constant KPC_RESERVE_LIQUIDITY_NOT_0 = '53'; // 'The liquidity of the reserve needs to be 0'\\n  string public constant KPC_CALLER_NOT_EMERGENCY_ADMIN = '54'; // 'The caller must be the emergency admin'\\n  string public constant KPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD = '55'; // 'Health factor is not below the threshold'\\n  string public constant KPCM_LIQUIDATION_DISABLED = '56'; // 'Health factor is not below the threshold'\\n  string public constant KPCM_NO_ERRORS = '57'; // 'No errors'\\n  string public constant MATH_MULTIPLICATION_OVERFLOW = '58';\\n  string public constant MATH_ADDITION_OVERFLOW = '59';\\n  string public constant MATH_DIVISION_BY_ZERO = '60';\\n  string public constant RL_LIQUIDITY_INDEX_OVERFLOW = '61'; //  Liquidity index overflows uint128\\n  string public constant RL_VARIABLE_BORROW_INDEX_OVERFLOW = '62'; //  Variable borrow index overflows uint128\\n  string public constant RL_LIQUIDITY_RATE_OVERFLOW = '63'; //  Liquidity rate overflows uint128\\n  string public constant RL_VARIABLE_BORROW_RATE_OVERFLOW = '64'; //  Variable borrow rate overflows uint128\\n  string public constant RL_STABLE_BORROW_RATE_OVERFLOW = '65'; //  Stable borrow rate overflows uint128\\n  string public constant CT_INVALID_MINT_AMOUNT = '66'; //invalid amount to mint\\n  string public constant CT_INVALID_BURN_AMOUNT = '67'; //invalid amount to burn\\n  string public constant RC_INVALID_RESERVE_FACTOR = '71';\\n  string public constant RC_INVALID_BORROW_RATIO = '72';\\n  string public constant RC_INVALID_PERIOD = '73';\\n  string public constant RC_INVALID_MIN_BORROW_TIME = '74';\\n  string public constant RC_INVALID_LIQ_THRESHOLD = '75';\\n  string public constant RC_INVALID_LIQ_TIME = '76';\\n  string public constant RC_INVALID_BID_TIME = '77';\\n  string public constant SDT_STABLE_DEBT_OVERFLOW = '81';\\n  string public constant SDT_BURN_EXCEEDS_BALANCE = '82';\\n  string public constant SDT_CREATION_FAILED = '83';\\n  string public constant VDT_CREATION_FAILED = '84';\\n  string public constant KF_LIQUIDITY_INSUFFICIENT = '85';\\n  string public constant KT_CREATION_FAILED = '86';\\n  string public constant KT_ERROR_CREATOR = '87';\\n  string public constant KT_INITIAL_LIQUIDITY_LOCK = '88';\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/utils/MathUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.18;\\n\\nimport \\\"./WadRayMath.sol\\\";\\n\\nlibrary MathUtils {\\n  using WadRayMath for uint256;\\n\\n  /// @dev Ignoring leap years\\n  uint256 internal constant SECONDS_PER_YEAR = 365 days;\\n\\n  /**\\n   * @dev Function to calculate the interest accumulated using a linear interest rate formula\\n   * @param rate The interest rate, in ray\\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\\n   * @return The interest rate linearly accumulated during the timeDelta, in ray\\n   **/\\n\\n  function calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    //solium-disable-next-line\\n    uint256 timeDifference = block.timestamp - uint256(lastUpdateTimestamp);\\n\\n    return (((rate * timeDifference) / SECONDS_PER_YEAR) + WadRayMath.ray());\\n  }\\n\\n  /**\\n   * @dev Function to calculate the interest using a compounded interest rate formula\\n   * To avoid expensive exponentiation, the calculation is performed using a binomial approximation:\\n   *\\n   *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\\n   *\\n   * The approximation slightly underpays liquidity providers and undercharges borrowers, with the advantage of great gas cost reductions\\n   * The whitepaper contains reference to the approximation and a table showing the margin of error per different time periods\\n   *\\n   * @param rate The interest rate, in ray\\n   * @param lastUpdateTimestamp The timestamp of the last update of the interest\\n   * @return The interest rate compounded during the timeDelta, in ray\\n   **/\\n  function calculateCompoundedInterest(\\n    uint256 rate,\\n    uint40 lastUpdateTimestamp,\\n    uint256 currentTimestamp\\n  ) internal pure returns (uint256) {\\n    //solium-disable-next-line\\n    uint256 exp = currentTimestamp - uint256(lastUpdateTimestamp);\\n\\n    if (exp == 0) {\\n      return WadRayMath.ray();\\n    }\\n\\n    uint256 expMinusOne = exp - 1;\\n\\n    uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\\n\\n    uint256 ratePerSecond = rate / SECONDS_PER_YEAR;\\n\\n    uint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond);\\n    uint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond);\\n\\n    uint256 secondTerm = exp * expMinusOne * basePowerTwo / 2;\\n    uint256 thirdTerm = exp * expMinusOne * expMinusTwo * basePowerThree / 6;\\n\\n    return WadRayMath.ray() + (ratePerSecond * exp) + secondTerm + thirdTerm;\\n  }\\n\\n  /**\\n   * @dev Calculates the compounded interest between the timestamp of the last update and the current block timestamp\\n   * @param rate The interest rate (in ray)\\n   * @param lastUpdateTimestamp The timestamp from which the interest accumulation needs to be calculated\\n   **/\\n  function calculateCompoundedInterest(uint256 rate, uint40 lastUpdateTimestamp)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    return calculateCompoundedInterest(rate, lastUpdateTimestamp, block.timestamp);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/utils/PercentageMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.18;\\n\\nimport \\\"./Errors.sol\\\";\\n\\n/**\\n * @title PercentageMath library\\n * @author Kyoko\\n * @notice Provides functions to perform percentage calculations\\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\\n * @dev Operations are rounded half up\\n **/\\n\\nlibrary PercentageMath {\\n  uint256 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals\\n  uint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;\\n\\n  /**\\n   * @dev Executes a percentage multiplication\\n   * @param value The value of which the percentage needs to be calculated\\n   * @param percentage The percentage of the value to be calculated\\n   * @return The percentage of value\\n   **/\\n  function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256) {\\n    if (value == 0 || percentage == 0) {\\n      return 0;\\n    }\\n\\n    require(\\n      value <= (type(uint256).max - HALF_PERCENT) / percentage,\\n      Errors.MATH_MULTIPLICATION_OVERFLOW\\n    );\\n\\n    return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR;\\n  }\\n\\n  /**\\n   * @dev Executes a percentage division\\n   * @param value The value of which the percentage needs to be calculated\\n   * @param percentage The percentage of the value to be calculated\\n   * @return The value divided the percentage\\n   **/\\n  function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256) {\\n    require(percentage != 0, Errors.MATH_DIVISION_BY_ZERO);\\n    uint256 halfPercentage = percentage / 2;\\n\\n    require(\\n      value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR,\\n      Errors.MATH_MULTIPLICATION_OVERFLOW\\n    );\\n\\n    return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/utils/WadRayMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.18;\\n\\nimport \\\"./Errors.sol\\\";\\n\\n/**\\n * @title WadRayMath library\\n * @author Kyoko\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\\n **/\\n\\nlibrary WadRayMath {\\n  uint256 internal constant WAD = 1e18;\\n  uint256 internal constant halfWAD = WAD / 2;\\n\\n  uint256 internal constant RAY = 1e27;\\n  uint256 internal constant halfRAY = RAY / 2;\\n\\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n  /**\\n   * @return One ray, 1e27\\n   **/\\n  function ray() internal pure returns (uint256) {\\n    return RAY;\\n  }\\n\\n  /**\\n   * @return One wad, 1e18\\n   **/\\n\\n  function wad() internal pure returns (uint256) {\\n    return WAD;\\n  }\\n\\n  /**\\n   * @return Half ray, 1e27/2\\n   **/\\n  function halfRay() internal pure returns (uint256) {\\n    return halfRAY;\\n  }\\n\\n  /**\\n   * @return Half ray, 1e18/2\\n   **/\\n  function halfWad() internal pure returns (uint256) {\\n    return halfWAD;\\n  }\\n\\n  /**\\n   * @dev Multiplies two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a*b, in wad\\n   **/\\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n\\n    require(a <= (type(uint256).max - halfWAD) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return (a * b + halfWAD) / WAD;\\n  }\\n\\n  /**\\n   * @dev Divides two wad, rounding half up to the nearest wad\\n   * @param a Wad\\n   * @param b Wad\\n   * @return The result of a/b, in wad\\n   **/\\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO);\\n    uint256 halfB = b / 2;\\n\\n    require(a <= (type(uint256).max - halfB) / WAD, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return (a * WAD + halfB) / b;\\n  }\\n\\n  /**\\n   * @dev Multiplies two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a*b, in ray\\n   **/\\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n\\n    require(a <= (type(uint256).max - halfRAY) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return (a * b + halfRAY) / RAY;\\n  }\\n\\n  /**\\n   * @dev Divides two ray, rounding half up to the nearest ray\\n   * @param a Ray\\n   * @param b Ray\\n   * @return The result of a/b, in ray\\n   **/\\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO);\\n    uint256 halfB = b / 2;\\n\\n    require(a <= (type(uint256).max - halfB) / RAY, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n\\n    return (a * RAY + halfB) / b;\\n  }\\n\\n  /**\\n   * @dev Casts ray down to wad\\n   * @param a Ray\\n   * @return a casted to wad, rounded half up to the nearest wad\\n   **/\\n  function rayToWad(uint256 a) internal pure returns (uint256) {\\n    uint256 halfRatio = WAD_RAY_RATIO / 2;\\n    uint256 result = halfRatio + a;\\n    require(result >= halfRatio, Errors.MATH_ADDITION_OVERFLOW);\\n\\n    return result / WAD_RAY_RATIO;\\n  }\\n\\n  /**\\n   * @dev Converts wad up to ray\\n   * @param a Wad\\n   * @return a converted in ray\\n   **/\\n  function wadToRay(uint256 a) internal pure returns (uint256) {\\n    uint256 result = a * WAD_RAY_RATIO;\\n    require(result / WAD_RAY_RATIO == a, Errors.MATH_MULTIPLICATION_OVERFLOW);\\n    return result;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"REBALANCE_UP_LIQUIDITY_RATE_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REBALANCE_UP_USAGE_RATIO_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ValidationLogic", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "10", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}