{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary Errors {\\r\\n    /// Common error\\r\\n    string constant CM_CONTRACT_HAS_BEEN_INITIALIZED = \\\"CM-01\\\"; \\r\\n    string constant CM_FACTORY_ADDRESS_IS_NOT_CONFIGURED = \\\"CM-02\\\";\\r\\n    string constant CM_VICS_ADDRESS_IS_NOT_CONFIGURED = \\\"CM-03\\\";\\r\\n    string constant CM_VICS_EXCHANGE_IS_NOT_CONFIGURED = \\\"CM-04\\\";\\r\\n    string constant CM_CEX_FUND_MANAGER_IS_NOT_CONFIGURED = \\\"CM-05\\\";\\r\\n    string constant CM_TREASURY_MANAGER_IS_NOT_CONFIGURED = \\\"CM-06\\\";\\r\\n    string constant CM_CEX_DEFAULT_MASTER_ACCOUNT_IS_NOT_CONFIGURED = \\\"CM-07\\\";\\r\\n    string constant CM_ADDRESS_IS_NOT_ICEXDABOTCERTTOKEN = \\\"CM-08\\\";\\r\\n    string constant CM_INDEX_OUT_OF_RANGE = \\\"CM-09\\\";\\r\\n    string constant CM_UNAUTHORIZED_CALLER = \\\"CM-10\\\";\\r\\n    string constant CM_PROXY_ADMIN_IS_NOT_CONFIGURED = \\\"CM-11\\\";\\r\\n    \\r\\n\\r\\n    /// IBCertToken error  (Bot Certificate Token)\\r\\n    string constant BCT_CALLER_IS_NOT_OWNER = \\\"BCT-01\\\"; \\r\\n    string constant BCT_REQUIRE_ALL_TOKENS_BURNT = \\\"BCT-02\\\";\\r\\n    string constant BCT_UNLOCK_AMOUNT_EXCEEDS_TOTAL_LOCKED = \\\"BCT-03\\\";\\r\\n    string constant BCT_INSUFFICIENT_LIQUID_FOR_UNLOCKING = \\\"BCT-04a\\\";\\r\\n    string constant BCT_INSUFFICIENT_LIQUID_FOR_LOCKING = \\\"BCT-04b\\\";\\r\\n    string constant BCT_AMOUNT_EXCEEDS_TOTAL_STAKE = \\\"BCT-05\\\";\\r\\n    string constant BCT_CANNOT_MINT_TO_ZERO_ADDRESS = \\\"BCT-06\\\";\\r\\n    string constant BCT_INSUFFICIENT_LIQUID_FOR_BURN = \\\"BCT-07\\\";\\r\\n    string constant BCT_INSUFFICIENT_ACCOUNT_FUND = \\\"BCT-08\\\";\\r\\n    string constant BCT_CALLER_IS_NEITHER_BOT_NOR_CERTLOCKER = \\\"BCT-09\\\";\\r\\n    string constant BCT_VALUE_MISMATCH_ASSET_AMOUNT = \\\"BCT-10\\\";\\r\\n\\r\\n    /// IBCEXCertToken error (Cex Bot Certificate Token)\\r\\n    string constant CBCT_CALLER_IS_NOT_FUND_MANAGER = \\\"CBCT-01\\\";\\r\\n\\r\\n    /// GovernToken error (Bot Governance Token)\\r\\n    string constant BGT_CALLER_IS_NOT_OWNED_BOT = \\\"BGT-01\\\";\\r\\n    string constant BGT_CANNOT_MINT_TO_ZERO_ADDRESS = \\\"BGT-02\\\";\\r\\n    string constant BGT_CALLER_IS_NOT_GOVERNANCE = \\\"BGT-03\\\";\\r\\n\\r\\n    // VaultBase error (VB)\\r\\n    string constant VB_CALLER_IS_NOT_DABOT = \\\"VB-01a\\\";\\r\\n    string constant VB_CALLER_IS_NOT_OWNER_BOT = \\\"VB-01b\\\";\\r\\n    string constant VB_INVALID_VAULT_ID = \\\"VB-02\\\";\\r\\n    string constant VB_INVALID_VAULT_TYPE = \\\"VB-03\\\";\\r\\n    string constant VB_INVALID_SNAPSHOT_ID = \\\"VB-04\\\";\\r\\n\\r\\n    // RegularVault Error (RV)\\r\\n    string constant RV_VAULT_IS_RESTRICTED = \\\"RV-01\\\";\\r\\n    string constant RV_DEPOSIT_LOCKED = \\\"RV-02\\\";\\r\\n    string constant RV_WITHDRAWL_AMOUNT_EXCEED_DEPOSIT = \\\"RV-03\\\";\\r\\n\\r\\n    // BotVaultManager (VM)\\r\\n    string constant VM_VAULT_EXISTS = \\\"VM-01\\\";\\r\\n\\r\\n    // BotManager (BM)\\r\\n    string constant BM_DOES_NOT_SUPPORT_IDABOT = \\\"BM-01\\\";\\r\\n    string constant BM_DUPLICATED_BOT_QUALIFIED_NAME = \\\"BM-02\\\";\\r\\n    string constant BM_TEMPLATE_IS_NOT_REGISTERED = \\\"BM-03\\\";\\r\\n    string constant BM_GOVERNANCE_TOKEN_IS_NOT_DEPLOYED = \\\"BM-04\\\";\\r\\n    string constant BM_BOT_IS_NOT_REGISTERED = \\\"BM-05\\\";\\r\\n\\r\\n    // DABotModule (BMOD)\\r\\n    string constant BMOD_CALLER_IS_NOT_OWNER = \\\"BMOD-01\\\";\\r\\n    string constant BMOD_CALLER_IS_NOT_BOT_MANAGER = \\\"BMOD-02\\\";\\r\\n    string constant BMOD_BOT_IS_ABANDONED = \\\"BMOD-03\\\";\\r\\n\\r\\n    // DABotControllerLib (BCL)\\r\\n    string constant BCL_DUPLICATED_MODULE = \\\"BCL-01\\\";\\r\\n    string constant BCL_CERT_TOKEN_IS_NOT_CONFIGURED = \\\"BCL-02\\\";\\r\\n    string constant BCL_GOVERN_TOKEN_IS_NOT_CONFIGURED = \\\"BCL-03\\\";\\r\\n    string constant BCL_GOVERN_TOKEN_IS_NOT_DEPLOYED = \\\"BCL-04\\\";\\r\\n    string constant BCL_WARMUP_LOCKER_IS_NOT_CONFIGURED = \\\"BCL-05\\\";\\r\\n    string constant BCL_COOLDOWN_LOCKER_IS_NOT_CONFIGURED = \\\"BCL-06\\\";\\r\\n    string constant BCL_UKNOWN_MODULE_ID = \\\"BCL-07\\\";\\r\\n    string constant BCL_BOT_MANAGER_IS_NOT_CONFIGURED = \\\"BCL-08\\\";\\r\\n\\r\\n    // DABotController (BCMOD)\\r\\n    string constant BCMOD_CANNOT_CALL_TEMPLATE_METHOD_ON_BOT_INSTANCE = \\\"BCMOD-01\\\";\\r\\n    string constant BCMOD_CALLER_IS_NOT_OWNER = \\\"BCMOD-02\\\";\\r\\n    string constant BCMOD_MODULE_HANDLER_NOT_FOUND_FOR_METHOD_SIG = \\\"BCMOD-03\\\";\\r\\n    string constant BCMOD_NEW_OWNER_IS_ZERO = \\\"BCMOD-04\\\";\\r\\n\\r\\n    // CEXFundManagerModule (CFMOD)\\r\\n    string constant CFMOD_DUPLICATED_BENEFITCIARY = \\\"CFMOD-01\\\";\\r\\n    string constant CFMOD_INVALID_CERTIFICATE_OF_ASSET = \\\"CFMOD-02\\\";\\r\\n    string constant CFMOD_CALLER_IS_NOT_FUND_MANAGER = \\\"CFMOD-03\\\";\\r\\n\\r\\n    // DABotSettingLib (BSL)\\r\\n    string constant BSL_CALLER_IS_NOT_OWNER = \\\"BSL-01\\\";\\r\\n    string constant BSL_CALLER_IS_NOT_GOVERNANCE_EXECUTOR = \\\"BSL-02\\\";\\r\\n    string constant BSL_IBO_ENDTIME_IS_SOONER_THAN_IBO_STARTTIME = \\\"BSL-03\\\";\\r\\n    string constant BSL_BOT_IS_ABANDONED = \\\"BSL-04\\\";\\r\\n\\r\\n    // DABotSettingModule (BSMOD)\\r\\n    string constant BSMOD_IBO_ENDTIME_IS_SOONER_THAN_IBO_STARTTIME =  \\\"BSMOD-01\\\";\\r\\n    string constant BSMOD_INIT_DEPOSIT_IS_LESS_THAN_CONFIGURED_THRESHOLD = \\\"BSMOD-02\\\";\\r\\n    string constant BSMOD_FOUNDER_SHARE_IS_ZERO = \\\"BSMOD-03\\\";\\r\\n    string constant BSMOD_INSUFFICIENT_MAX_SHARE = \\\"BSMOD-04\\\";\\r\\n    string constant BSMOD_FOUNDER_SHARE_IS_GREATER_THAN_IBO_SHARE = \\\"BSMOD-05\\\";\\r\\n\\r\\n    // DABotCertLocker (LOCKER)\\r\\n    string constant LOCKER_CALLER_IS_NOT_OWNER_BOT = \\\"LOCKER-01\\\";\\r\\n\\r\\n    // DABotStakingModule (BSTMOD)\\r\\n    string constant BSTMOD_PRE_IBO_REQUIRED = \\\"BSTMOD-01\\\";\\r\\n    string constant BSTMOD_AFTER_IBO_REQUIRED = \\\"BSTMOD-02\\\";\\r\\n    string constant BSTMOD_INVALID_PORTFOLIO_ASSET = \\\"BSTMOD-03\\\";\\r\\n    string constant BSTMOD_PORTFOLIO_FULL = \\\"BSTMOD-04\\\";\\r\\n    string constant BSTMOD_INVALID_CERTIFICATE_ASSET = \\\"BSTMOD-05\\\";\\r\\n    string constant BSTMOD_PORTFOLIO_ASSET_NOT_FOUND = \\\"BSTMOD-06\\\";\\r\\n    string constant BSTMOD_ASSET_IS_ZERO = \\\"BSTMOD-07\\\";\\r\\n    string constant BSTMOD_INVALID_STAKING_CAP = \\\"BSTMOD-08\\\";\\r\\n    string constant BSTMOD_INSUFFICIENT_FUND = \\\"BSTMOD-09\\\";\\r\\n    string constant BSTMOD_CAP_IS_ZERO = \\\"BSTMOD-10\\\";\\r\\n    string constant BSTMOD_CAP_IS_LESS_THAN_STAKED_AND_IBO_CAP = \\\"BSTMOD-11\\\";\\r\\n    string constant BSTMOD_WERIGHT_IS_ZERO = \\\"BSTMOD-12\\\";\\r\\n\\r\\n    // CEX FundManager (CFM)\\r\\n    string constant CFM_REQ_TYPE_IS_MISMATCHED = \\\"CFM-01\\\";\\r\\n    string constant CFM_INVALID_REQUEST_ID = \\\"CFM-02\\\";\\r\\n    string constant CFM_CALLER_IS_NOT_BOT_TOKEN = \\\"CFM-03\\\";\\r\\n    string constant CFM_CLOSE_TYPE_VALUE_IS_NOT_SUPPORTED = \\\"CFM-04\\\";\\r\\n    string constant CFM_UNKNOWN_REQUEST_TYPE = \\\"CFM-05\\\";\\r\\n    string constant CFM_CALLER_IS_NOT_REQUESTER = \\\"CFM-06\\\";\\r\\n    string constant CFM_CALLER_IS_NOT_APPROVER = \\\"CFM-07\\\";\\r\\n    string constant CFM_CEX_CERTIFICATE_IS_REQUIRED = \\\"CFM-08\\\";\\r\\n    string constant CFM_TREASURY_ASSET_CERTIFICATE_IS_REQUIRED = \\\"CFM-09\\\";\\r\\n    string constant CFM_FAIL_TO_TRANSFER_VALUE = \\\"CFM-10\\\";\\r\\n    string constant CFM_AWARDED_ASSET_IS_NOT_TREASURY = \\\"CFM-11\\\";\\r\\n    string constant CFM_INSUFFIENT_ASSET_TO_MINT_STOKEN = \\\"CFM-12\\\";\\r\\n\\r\\n    // FarmBot Module (FBM)  string constant FBM_ = \\\"FBM-\\\";\\r\\n    string constant FBM_CANNOT_REMOVE_WORKER = \\\"FBM-01\\\";\\r\\n    string constant FBM_NULL_OPERATOR_ACCOUNT = \\\"FBM-02\\\";\\r\\n    string constant FBM_INVALID_WORKER = \\\"FBM-03\\\";\\r\\n    string constant FBM_REPAY_ERROR = \\\"FBM-04\\\";\\r\\n    string constant FBM_INVALID_SWAP_ADAPTER = \\\"FBM-05\\\";\\r\\n    string constant FBM_INVALID_SWAP_PATH = \\\"FBM-06\\\";\\r\\n    string constant FBM_INSUFFICIENT_FUND = \\\"FBM-07\\\";\\r\\n\\r\\n    // TreasuryAsset (TA)\\r\\n    string constant TA_MINT_ZERO_AMOUNT = \\\"TA-01\\\";\\r\\n    string constant TA_LOCK_AMOUNT_EXCEED_BALANCE = \\\"TA-02\\\";\\r\\n    string constant TA_UNLOCK_AMOUNT_AND_PASSED_VALUE_IS_MISMATCHED = \\\"TA-03\\\";\\r\\n    string constant TA_AMOUNT_EXCEED_AVAILABLE_BALANCE = \\\"TA-04\\\";\\r\\n    string constant TA_AMOUNT_EXCEED_VALUE_BALANCE = \\\"TA-05\\\";\\r\\n    string constant TA_FUND_MANAGER_IS_NOT_SET = \\\"TA-06\\\";\\r\\n    string constant TA_FAIL_TO_TRANSFER_VALUE = \\\"TA-07\\\";\\r\\n\\r\\n    // Governance (GOV)\\r\\n    string constant GOV_DEFAULT_STRATEGY_IS_NOT_SET = \\\"GOV-01\\\";\\r\\n    string constant GOV_INSUFFICIENT_POWER_TO_CREATE_PROPOSAL = \\\"GOV-02\\\";\\r\\n    string constant GOV_INSUFFICIENT_VICS_TO_CREATE_PROPOSAL = \\\"GOV-03\\\";\\r\\n    string constant GOV_INVALID_PROPOSAL_ID = \\\"GOV-04\\\";\\r\\n    string constant GOV_REQUIRED_PROPOSER_OR_GUARDIAN = \\\"GOV-05\\\";\\r\\n    string constant GOV_TARGET_SHOULD_BE_ZERO_OR_REGISTERED_BOT = \\\"GOV-06\\\";\\r\\n    string constant GOV_INSUFFICIENT_POWER_TO_VOTE = \\\"GOV-07\\\";\\r\\n    string constant GOV_INVALID_NEW_STATE = \\\"GOV-08\\\";\\r\\n    string constant GOV_CANNOT_CHANGE_STATE_OF_CLOSED_PROPOSAL = \\\"GOV-08\\\";\\r\\n    string constant GOV_INVALID_CREATION_DATA = \\\"GOV-09\\\";\\r\\n    string constant GOV_CANNOT_CHANGE_STATE_OF_ON_CHAIN_PROPOSAL = \\\"GOV-10\\\";\\r\\n    string constant GOV_PROPOSAL_DONT_ACCEPT_VOTE = \\\"GOV-11\\\";\\r\\n    string constant GOV_DUPLICATED_VOTE = \\\"GOV-12\\\";\\r\\n    string constant GOV_CAN_ONLY_QUEUE_PASSED_PROPOSAL = \\\"GOV-13\\\";\\r\\n    string constant GOV_DUPLICATED_ACTION = \\\"GOV-14\\\";\\r\\n    string constant GOV_INVALID_VICS_ADDRESS = \\\"GOV-15\\\";\\r\\n\\r\\n    // Timelock Executor (TLE)\\r\\n    string constant TLE_DELAY_SHORTER_THAN_MINIMUM = \\\"TLE-01\\\";\\r\\n    string constant TLE_DELAY_LONGER_THAN_MAXIMUM = \\\"TLE-02\\\";\\r\\n    string constant TLE_ONLY_BY_ADMIN = \\\"TLE-03\\\";\\r\\n    string constant TLE_ONLY_BY_PENDING_ADMIN = \\\"TLE-04\\\";\\r\\n    string constant TLE_ONLY_BY_THIS_TIMELOCK = \\\"TLE-05\\\";\\r\\n    string constant TLE_EXECUTION_TIME_UNDERESTIMATED = \\\"TLE-06\\\";\\r\\n    string constant TLE_ACTION_NOT_QUEUED = \\\"TLE-07\\\";\\r\\n    string constant TLE_TIMELOCK_NOT_FINISHED = \\\"TLE-08\\\";\\r\\n    string constant TLE_GRACE_PERIOD_FINISHED = \\\"TLE-09\\\";\\r\\n    string constant TLE_NOT_ENOUGH_MSG_VALUE = \\\"TLE-10\\\";\\r\\n\\r\\n    // DABotVoteStrategy (BVS) string constant BVS_ = \\\"BVS-\\\";\\r\\n    string constant BVS_NOT_A_REGISTERED_DABOT = \\\"BVS-01\\\";\\r\\n\\r\\n    // DABotWhiteList (BWL) string constant BWL_ = \\\"BWL-\\\";\\r\\n    string constant BWL_ACCOUNT_IS_ZERO = \\\"BWL-01\\\";\\r\\n    string constant BWL_ACCOUNT_IS_NOT_WHITELISTED = \\\"BWL-02\\\";\\r\\n\\r\\n    // Marginal Lending Worker string constant MLF_ = \\\"MLF-\\\";\\r\\n    string constant MLF_ZERO_DEPOSIT = \\\"MLF-01\\\";\\r\\n    string constant MLF_UNKNOWN_CONFIG_TOPIC = \\\"MLF-02\\\";\\r\\n    string constant MLF_REGISTERED_COLLATERAL_ID_EXPECTED = \\\"MLF-03\\\";\\r\\n    string constant MLF_CONFIG_TOPICS_AND_VALUES_MISMATCHED = \\\"MLF-04\\\";\\r\\n    string constant MLF_ADAPTER_IS_NOT_CONFIGURED = \\\"MLF-05\\\";\\r\\n    string constant MLF_CANNOT_REMOVE_IN_USED_COLLATERAL = \\\"MLF-06\\\";\\r\\n    string constant MLF_CANNOT_CHANGE_LENDING_ADAPTER = \\\"MLF-07\\\";\\r\\n    string constant MLF_INVALID_PLATFORM_TOKEN = \\\"MLF-08\\\";\\r\\n    string constant MLF_CANNOT_CHANGE_IN_USED_LEVERAGE_ASSET = \\\"MLF-09\\\";\\r\\n    string constant MLF_INVALID_EXPECTED_HEALTH_FACTOR = \\\"MLF-10\\\";\\r\\n    string constant MLF_LEVERAGE_ASSET_IS_NOT_SET = \\\"MLF-11\\\";\\r\\n    string constant MLF_INVALID_PRECISION = \\\"MLF-12\\\";\\r\\n    string constant MLF_INTERNAL_ERROR = \\\"MLF-13\\\";\\r\\n\\r\\n    // FarmCertTokenModule (FTM) string constant FTM_ = \\\"FTM-\\\";\\r\\n    string constant FTM_INSUFFICICIENT_AMOUNT_TO_DEPOSIT = \\\"FTM-01\\\";\\r\\n\\r\\n    // ILendingAdapter (ILA) string constant ILA_ = \\\"ILA-\\\";\\r\\n    string constant ILA_INVALID_EXPECTED_HEALTH_FACTOR = \\\"ILA-01\\\";\\r\\n    string constant ILA_DEPOSIT_FAILED = \\\"ILA-02\\\";\\r\\n    string constant ILA_WITHDRAW_FAILED = \\\"ILA-03\\\";\\r\\n    string constant ILA_BORROW_FAILED = \\\"ILA-04\\\";\\r\\n    string constant ILA_REPAY_BORROW_FAILED = \\\"ILA-05\\\";\\r\\n\\r\\n    // RoboFi game string constant RFG_ = \\\"RFG-\\\";\\r\\n    string constant RFG_CALLER_IS_NOT_REGISTERED_BOT = \\\"RFG-01\\\";\\r\\n    string constant RFG_CALLER_IS_NOT_BOT_OWNER = \\\"RFG-02\\\";\\r\\n    string constant RFG_CALLER_IS_NOT_VAULT = \\\"RFG-03\\\";\\r\\n    string constant RFG_ROUND_NOT_FINISHED = \\\"RFG-04\\\";\\r\\n    string constant RFG_ROUND_NOT_IN_COMMIT_PHASE = \\\"RFG-05\\\";\\r\\n    string constant RFG_ROUND_NOT_IN_REVEAL_PHASE = \\\"RFG-06\\\";\\r\\n    string constant RFG_ROUND_NOT_READY_CLOSE = \\\"RFG-07\\\";\\r\\n    string constant RFG_ROUND_NOT_CLOSED_YET = \\\"RFG-08\\\";\\r\\n    string constant RFG_INVALID_SECRET_NUMBER = \\\"RFG-09\\\";\\r\\n    string constant RFG_WINNER_IS_REQUIRE = \\\"RFG-10\\\";\\r\\n    string constant RFG_INVALID_SUBMIT_WINNERS = \\\"RFG-11\\\";\\r\\n    string constant RFG_INVALID_NUMBER_OF_WINNERS = \\\"RFG-12\\\";\\r\\n    string constant RFG_INVALID_WON_NUMBER = \\\"RFG-13\\\";\\r\\n    string constant RFG_INVALID_VICS_ADDRESS = \\\"RFG-14\\\";\\r\\n    string constant RFG_INVALID_COMMIT_DURATION = \\\"RFG-15\\\";\\r\\n    string constant RFG_INVALID_REVEAL_DURATION = \\\"RFG-16\\\";\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/common/IConfigurator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\nlibrary Roles {\\r\\n    bytes32 constant ROLE_ADMIN = keccak256('operator.dabot.role');\\r\\n    bytes32 constant ROLE_OPERATORS = keccak256('operator.dabot.role');\\r\\n    bytes32 constant ROLE_TEMPLATE_CREATOR = keccak256('creator.template.dabot.role');\\r\\n    bytes32 constant ROLE_BOT_CREATOR = keccak256('creator.dabot.role');\\r\\n    bytes32 constant ROLE_FUND_APPROVER = keccak256('approver.fund.role');\\r\\n}\\r\\n\\r\\nlibrary AddressBook {\\r\\n    bytes32 constant ADDR_FACTORY = keccak256('factory.address');\\r\\n    bytes32 constant ADDR_VICS = keccak256('vics.address');\\r\\n    bytes32 constant ADDR_TAX = keccak256('tax.address');\\r\\n    bytes32 constant ADDR_GOVERNANCE = keccak256('governance.address');\\r\\n    bytes32 constant ADDR_GOVERNANCE_EXECUTOR = keccak256('executor.governance.address');\\r\\n    bytes32 constant ADDR_BOT_MANAGER = keccak256('botmanager.address');\\r\\n    bytes32 constant ADDR_VICS_EXCHANGE = keccak256('exchange.vics.address');\\r\\n    bytes32 constant ADDR_TREASURY_MANAGER = keccak256('treasury-manager.address');\\r\\n    bytes32 constant ADDR_CEX_FUND_MANAGER = keccak256('fund-manager.address');\\r\\n    bytes32 constant ADDR_CEX_DEFAULT_MASTER_ACCOUNT = keccak256('default.master.address');\\r\\n    bytes32 constant ADDR_ROBOFI_GAME = keccak256('robofi-game.address');\\r\\n}\\r\\n\\r\\nlibrary Config {\\r\\n    /// The amount of VICS that a proposer has to pay when create a new proposal\\r\\n    bytes32 constant PROPOSAL_DEPOSIT = keccak256('deposit.proposal.config');\\r\\n\\r\\n    /// The percentage of proposal creation fee distributed to the account that execute a propsal\\r\\n    bytes32 constant PROPOSAL_REWARD_PERCENT = keccak256('reward.proposal.config');\\r\\n\\r\\n    /// The minimum VICS a bot creator has to deposit to a newly created bot\\r\\n    bytes32 constant CREATOR_DEPOSIT = keccak256('deposit.creator.config');\\r\\n\\r\\n    /// The minim \\r\\n    bytes32 constant PROPOSAL_CREATOR_MININUM_POWER = keccak256('minpower.goverance.config');\\r\\n    \\r\\n    /// The minimum percentage of for-votes over total votes a proposal has to achieve to be passed\\r\\n    bytes32 constant PROPOSAL_MINIMUM_QUORUM = keccak256('minquorum.governance.config');\\r\\n\\r\\n    /// The minimum difference (in percentage) between for-votes and against-vote for a proposal to be passed\\r\\n    bytes32 constant PROPOSAL_VOTE_DIFFERENTIAL = keccak256('differential.governance.config');\\r\\n\\r\\n    /// The voting duration of a proposal\\r\\n    bytes32 constant PROPOSAL_DURATION = keccak256('duration.goverance.config');\\r\\n\\r\\n    /// The interval that a passed proposed is waiting in queue before being executed\\r\\n    bytes32 constant PROPOSAL_EXECUTION_DELAY = keccak256('execdelay.governance.config');\\r\\n\\r\\n    // Number of winners of RoboFi Game\\r\\n    bytes32 constant GAME_NUMBER_WINNER = keccak256('num-of-winner.game.config');\\r\\n\\r\\n    // The commit phase duration of a game\\r\\n    bytes32 constant GAME_COMMIT_DURATION = keccak256('commit.game.config');\\r\\n\\r\\n    // The reveal phase duration of a game\\r\\n    bytes32 constant GAME_REVEAL_DURATION = keccak256('reveal.game.config');\\r\\n}\\r\\n\\r\\ninterface IConfigurator {\\r\\n    function addressOf(bytes32 addrId) external view returns(address);\\r\\n    function configOf(bytes32 configId) external view returns(uint);\\r\\n    function bytesConfigOf(bytes32 configId) external view returns(bytes memory);\\r\\n\\r\\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\\r\\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\\r\\n\\r\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\r\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\r\\n    function grantRole(bytes32 role, address account) external;\\r\\n    function revokeRole(bytes32 role, address account) external;\\r\\n    function renounceRole(bytes32 role, address account) external;\\r\\n\\r\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\r\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n}\\r\\n\\r\\n\"\r\n    },\r\n    \"contracts/common/IInitializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IInitializable {\\r\\n    function init(bytes calldata data) external payable;\\r\\n}\"\r\n    },\r\n    \"contracts/common/IRoboFiFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IRoboFiFactory {\\r\\n    function deploy(address masterContract, \\r\\n                    bytes calldata data, \\r\\n                    bool useCreate2) \\r\\n        external \\r\\n        payable \\r\\n        returns(address);\\r\\n}\\r\\n\\r\\n\"\r\n    },\r\n    \"contracts/dabot/controller/DABotController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\r\\nimport \\\"../../common/IInitializable.sol\\\";\\r\\nimport \\\"../../common/Errors.sol\\\";\\r\\nimport \\\"../interfaces/IDABot.sol\\\";\\r\\nimport \\\"../interfaces/IDABotController.sol\\\";\\r\\nimport \\\"../interfaces/IDABotModule.sol\\\";\\r\\nimport \\\"../interfaces/IDABotGovernToken.sol\\\";\\r\\nimport \\\"../setting/DABotSettingLib.sol\\\";\\r\\nimport \\\"../staking/DABotStakingLib.sol\\\";\\r\\nimport \\\"./DABotControllerLib.sol\\\";\\r\\n\\r\\ncontract DABotModuleController is IInitializable, Context, IDABotControllerEvent {\\r\\n\\r\\n    using DABotTemplateControllerLib for BotTemplateController;\\r\\n    using DABotMetaLib for BotMetaData;\\r\\n    using DABotStakingLib for BotStakingData;\\r\\n    using DABotSettingLib for BotSetting;\\r\\n\\r\\n    constructor(uint8 botType, string memory name, string memory version) {\\r\\n        BotCoreData storage ds = DABotTemplateControllerLib.coredata();\\r\\n        ds.metadata = BotMetaData(\\r\\n            name,\\r\\n            '',\\r\\n            version,\\r\\n            botType,\\r\\n            false,  // abandoned\\r\\n            true,   // is template\\r\\n            true,   // initialized\\r\\n            _msgSender(), // owner\\r\\n            address(0),   // botManager\\r\\n            address(0),   // botTemplate\\r\\n            address(0)    // gToken\\r\\n        );\\r\\n    }\\r\\n\\r\\n    modifier onlyTemplate() {\\r\\n        require(DABotMetaLib.metadata().isTemplate, Errors.BCMOD_CANNOT_CALL_TEMPLATE_METHOD_ON_BOT_INSTANCE); \\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        BotMetaData storage ds = DABotMetaLib.metadata();\\r\\n        require(_msgSender() == ds.botOwner, Errors.BCMOD_CALLER_IS_NOT_OWNER);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function registerModule(address moduleHandler) public onlyTemplate onlyOwner {\\r\\n        IDABotModule _module = IDABotModule(moduleHandler);\\r\\n        (string memory _name, string memory _version, bytes32 _moduleId) = _module.moduleInfo();\\r\\n\\r\\n        BotTemplateController storage ds = DABotTemplateControllerLib.controller();\\r\\n        bool moduleExisted = ds.moduleAddresses[_moduleId] != address(0);\\r\\n\\r\\n        (bool success, bytes memory result) = \\r\\n            moduleHandler.delegatecall(abi.encodeWithSelector(IDABotModule.onRegister.selector, moduleHandler));\\r\\n        \\r\\n        require(success, string(abi.encodePacked(\\\"Controller: module \\\", _name, ' registration error: ',  result)));\\r\\n\\r\\n        if (!moduleExisted) \\r\\n            ds.modules.push(_moduleId);\\r\\n        \\r\\n        emit ModuleRegistered(_moduleId, moduleHandler, _name, _version);\\r\\n    }\\r\\n\\r\\n    function updateModuleHandler(bytes32 moduleId, address newModuleAddress) public onlyTemplate onlyOwner {\\r\\n        BotTemplateController storage ds = DABotTemplateControllerLib.controller();\\r\\n        bool moduleExisted = ds.moduleAddresses[moduleId] != address(0);\\r\\n        address oldModuleAddress = ds.registerModule(moduleId, newModuleAddress); \\r\\n        if (!moduleExisted)\\r\\n            ds.modules.push(moduleId);\\r\\n        emit ModuleHandlerChanged(moduleId, oldModuleAddress, newModuleAddress);\\r\\n    }\\r\\n\\r\\n    function module(bytes32 moduleId) external view onlyTemplate returns(address) {\\r\\n        BotTemplateController storage ds = DABotTemplateControllerLib.controller();\\r\\n        return ds.module(moduleId);\\r\\n    }\\r\\n\\r\\n    function moduleOfSelector(bytes4 selector) public view onlyTemplate returns(address) {\\r\\n        BotTemplateController storage ds = DABotTemplateControllerLib.controller();\\r\\n        return ds.moduleOfSelector(selector);\\r\\n    }\\r\\n\\r\\n    function init(bytes calldata data) external payable override {\\r\\n        BotMetaData storage ds = DABotMetaLib.metadata();\\r\\n        require(!ds.initialized, Errors.CM_CONTRACT_HAS_BEEN_INITIALIZED);\\r\\n       \\r\\n        (BotMetaData memory meta, BotModuleInitData[] memory initData) = \\r\\n            abi.decode(data, (BotMetaData, BotModuleInitData[]));\\r\\n\\r\\n        BotMetaData memory templateMeta = IDABot(meta.botTemplate).metadata();\\r\\n\\r\\n        ds.name = meta.name;\\r\\n        ds.symbol = meta.symbol;\\r\\n        ds.version = meta.version;\\r\\n        ds.botType = templateMeta.botType;\\r\\n        ds.botOwner = meta.botOwner;\\r\\n        ds.botManager = meta.botManager;\\r\\n        ds.botTemplate = meta.botTemplate;\\r\\n                \\r\\n        for(uint i = 0; i < initData.length; i++) {\\r\\n            address moduleAddress = ds.module(initData[i].moduleId);\\r\\n            if (moduleAddress == address(0))\\r\\n                revert(string(abi.encodePacked(\\\"Controller: module #\\\", i, \\\"(\\\", Strings.toHexString(uint256(initData[i].moduleId), 32) ,\\\") not found\\\"))); \\r\\n\\r\\n            (bool success, bytes memory result) = moduleAddress.delegatecall(abi.encodeWithSelector(IDABotModule.onInitialize.selector, initData[i].data));\\r\\n            if (!success) {\\r\\n                revert(string(abi.encodePacked(\\r\\n                        string(result), \\r\\n                        ' (module ', Strings.toString(i + 1), '/', Strings.toString(initData.length), ' ', \\r\\n                        Strings.toHexString(uint160(moduleAddress), 20), \\\")\\\")));\\r\\n            }\\r\\n        }\\r\\n        ds.initialized = true;\\r\\n    }\\r\\n\\r\\n    fallback() external payable {\\r\\n        __forwardCall();\\r\\n    }\\r\\n\\r\\n    function __findImplementation() internal view returns(address) {\\r\\n        BotMetaData storage meta = DABotMetaLib.metadata();\\r\\n        address moduleAddress;\\r\\n        if (meta.botTemplate == address(0)) {\\r\\n            moduleAddress = moduleOfSelector(msg.sig);\\r\\n        } else {\\r\\n            moduleAddress = DABotModuleController(payable(meta.botTemplate)).moduleOfSelector(msg.sig);\\r\\n        }\\r\\n        if (moduleAddress == address(0)) {\\r\\n            revert(string(abi.encodePacked(Errors.BCMOD_MODULE_HANDLER_NOT_FOUND_FOR_METHOD_SIG, \\\" \\\", Strings.toHexString(uint32(msg.sig), 4)))); \\r\\n        }\\r\\n        return moduleAddress;\\r\\n    }\\r\\n\\r\\n    function __forwardCall() internal {\\r\\n        address handler = __findImplementation();\\r\\n        // Execute external function from facet using delegatecall and return any value.\\r\\n        assembly {\\r\\n            // copy function selector and any arguments\\r\\n            calldatacopy(0, 0, calldatasize())\\r\\n            // execute function call using the facet\\r\\n            let result := delegatecall(gas(), handler, 0, calldatasize(), 0, 0)\\r\\n            // get any return value\\r\\n            returndatacopy(0, 0, returndatasize())\\r\\n            // return any return value or error back to the caller\\r\\n            switch result\\r\\n                case 0 {\\r\\n                    revert(0, returndatasize())\\r\\n                }\\r\\n                default {\\r\\n                    return(0, returndatasize())\\r\\n                }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    function rescueToken(address token) external payable onlyOwner {\\r\\n        if (token == address(0))\\r\\n            payable(owner()).transfer(address(this).balance);\\r\\n        else {\\r\\n            IRoboFiERC20 erc20 = IRoboFiERC20(token);\\r\\n            erc20.transfer(owner(), erc20.balanceOf(address(this)));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function qualifiedName() external view returns(string memory) {\\r\\n        BotMetaData storage meta = DABotMetaLib.coredata().metadata;\\r\\n        if (meta.isTemplate)\\r\\n            return string(abi.encodePacked(meta.name,\\\":\\\",meta.version));\\r\\n        return string(abi.encodePacked(meta.symbol,\\\":\\\",meta.name));\\r\\n    }\\r\\n\\r\\n    function metadata() external view returns(BotMetaData memory) {\\r\\n        return DABotMetaLib.coredata().metadata;\\r\\n    }\\r\\n\\r\\n    function governToken() external view returns(IDABotGovernToken) {\\r\\n        return IDABotGovernToken(DABotMetaLib.metadata().gToken);\\r\\n    }\\r\\n\\r\\n    function setting() external view returns(BotSetting memory) {\\r\\n        return DABotSettingLib.setting();\\r\\n    }\\r\\n\\r\\n    function botDetails() external view returns(BotDetail memory output) {\\r\\n        BotMetaData storage meta = DABotMetaLib.metadata();\\r\\n        BotStakingData storage staking = DABotStakingLib.staking();\\r\\n        BotSetting storage _setting = DABotSettingLib.setting();\\r\\n\\r\\n        BotMetaData memory templateMeta = DABotModuleController(payable(meta.botTemplate)).metadata();\\r\\n        IDABotGovernToken gToken = IDABotGovernToken(meta.gToken);\\r\\n\\r\\n        output.botAddress = address(this);\\r\\n        output.template = meta.botTemplate;\\r\\n        output.botSymbol = meta.symbol;\\r\\n        output.botName = meta.name;\\r\\n        output.status = _setting.status();\\r\\n        output.botType = templateMeta.botType;\\r\\n        output.governToken = meta.gToken;\\r\\n        output.templateName = templateMeta.name; \\r\\n        output.templateVersion = templateMeta.version;\\r\\n        output.iboStartTime = _setting.iboStartTime();\\r\\n        output.iboEndTime = _setting.iboEndTime();\\r\\n        output.warmup = _setting.warmupTime();\\r\\n        output.cooldown = _setting.cooldownTime();\\r\\n        output.priceMul = _setting.priceMultiplier();\\r\\n        output.commissionFee = _setting.commission();\\r\\n        output.profitSharing = _setting.profitSharing;\\r\\n        output.initDeposit = _setting.initDeposit;\\r\\n        output.initFounderShare = _setting.initFounderShare;\\r\\n        output.maxShare = _setting.maxShare;\\r\\n        output.iboShare = _setting.iboShare;\\r\\n        output.circulatedShare = gToken.totalSupply();\\r\\n        output.userShare = gToken.balanceOf(_msgSender());\\r\\n        output.portfolio = staking.portfolioDetails();\\r\\n    }\\r\\n\\r\\n    function owner() public view returns(address) {\\r\\n        return DABotMetaLib.metadata().botOwner;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() external onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) external onlyOwner {\\r\\n        require(newOwner != address(0), Errors.BCMOD_NEW_OWNER_IS_ZERO);\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function abandon(bool value) external onlyOwner {\\r\\n        DABotMetaLib.metadata().abandoned = value;\\r\\n        emit BotAbandoned(value);\\r\\n    }\\r\\n\\r\\n    function modulesInfo() external view returns(BotModuleInfo[] memory result) {\\r\\n        BotTemplateController storage ds = DABotTemplateControllerLib.controller();\\r\\n        result = new BotModuleInfo[](ds.modules.length);\\r\\n        for (uint i = 0; i < ds.modules.length; i++) {\\r\\n            IDABotComponent moduleHandler = IDABotComponent(ds.moduleAddresses[ds.modules[i]]);\\r\\n            (string memory _name, string memory _version,) = moduleHandler.moduleInfo();\\r\\n            result[i] = BotModuleInfo(_name, _version, ds.moduleAddresses[ds.modules[i]]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function moduleHandlerInfo(bytes32[] calldata ids) external view returns(address[] memory result) {\\r\\n        BotTemplateController storage ds = DABotTemplateControllerLib.controller();\\r\\n        result = new address[](ids.length);\\r\\n        for (uint i = 0; i < ids.length; i++)\\r\\n            result[i] = ds.moduleAddresses[ids[i]];\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        BotMetaData storage ds = DABotMetaLib.metadata();\\r\\n        address oldOwner = ds.botOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n        ds.botOwner = newOwner;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/controller/DABotControllerLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\r\\nimport \\\"../../common/Errors.sol\\\";\\r\\nimport \\\"../interfaces/IBotTemplateController.sol\\\";\\r\\nimport \\\"../interfaces/IDABotGovernToken.sol\\\";\\r\\nimport \\\"../interfaces/IDABotManager.sol\\\";\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\n\\r\\nstruct BotTemplateController {\\r\\n    mapping(bytes4 => bytes32) selectors;\\r\\n    mapping(bytes32 => address) moduleAddresses;\\r\\n    bytes32[] modules;\\r\\n}\\r\\n\\r\\nstruct BotCoreData {\\r\\n    BotTemplateController controller;\\r\\n    BotMetaData metadata;\\r\\n    BotSetting setting;\\r\\n}\\r\\n\\r\\nlibrary DABotTemplateControllerLib {\\r\\n\\r\\n    using DABotTemplateControllerLib for BotTemplateController;\\r\\n\\r\\n    bytes32 constant CORE_STORAGE_POSITION = keccak256(\\\"core.dabot.storage\\\");\\r\\n\\r\\n    function coredata() internal pure returns(BotCoreData storage ds) {\\r\\n        bytes32 position = CORE_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function controller() internal view returns (BotTemplateController storage) {\\r\\n        return coredata().controller;\\r\\n    }\\r\\n\\r\\n    function requireNewModule(bytes32 moduleId) internal view {\\r\\n        BotTemplateController storage ds = controller();\\r\\n        require(ds.module(moduleId) == address(0), Errors.BCL_DUPLICATED_MODULE);\\r\\n    }\\r\\n\\r\\n    function module(BotTemplateController storage ds, bytes32 moduleId) internal view returns(address) {\\r\\n        return ds.moduleAddresses[moduleId];\\r\\n    }\\r\\n\\r\\n    function moduleOfSelector(BotTemplateController storage ds, bytes4 selector) internal view returns(address) {\\r\\n        bytes32 moduleId = ds.selectors[selector];\\r\\n        return ds.moduleAddresses[moduleId];\\r\\n    }\\r\\n\\r\\n    function registerModule(BotTemplateController storage ds, bytes32 moduleId, address moduleAddress) internal returns(address oldModuleAddress) {\\r\\n        oldModuleAddress = ds.moduleAddresses[moduleId];\\r\\n        ds.moduleAddresses[moduleId] = moduleAddress;\\r\\n    }\\r\\n\\r\\n    function registerSelectors(BotTemplateController storage ds, bytes32 moduleId, bytes4[] memory selectors) internal {\\r\\n        for(uint i = 0; i < selectors.length; i++)\\r\\n            ds.selectors[selectors[i]] = moduleId;\\r\\n    }\\r\\n\\r\\n    \\r\\n}\\r\\n\\r\\nlibrary DABotMetaLib {\\r\\n\\r\\n    using DABotMetaLib for BotMetaData;\\r\\n    using DABotTemplateControllerLib for BotTemplateController;\\r\\n\\r\\n    bytes32 constant CORE_STORAGE_POSITION = keccak256(\\\"core.dabot.storage\\\");\\r\\n\\r\\n    function coredata() internal pure returns(BotCoreData storage ds) {\\r\\n        bytes32 position = CORE_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function metadata() internal view returns (BotMetaData storage) {\\r\\n        return coredata().metadata;\\r\\n    }\\r\\n\\r\\n    function manager(BotMetaData storage ds) internal view returns(IDABotManager _manager) {\\r\\n        _manager = IDABotManager(ds.botManager);\\r\\n        require(address(_manager) != address(0), Errors.BCL_BOT_MANAGER_IS_NOT_CONFIGURED);\\r\\n    }\\r\\n\\r\\n    function configurator(BotMetaData storage ds) internal view returns(IConfigurator _config) {\\r\\n        _config = ds.manager().configurator();\\r\\n    }\\r\\n\\r\\n    function factory(BotMetaData storage ds) internal view returns(IRoboFiFactory _factory) {\\r\\n        IConfigurator config = ds.configurator();\\r\\n        _factory = IRoboFiFactory(config.addressOf(AddressBook.ADDR_FACTORY));\\r\\n        require(address(_factory) != address(0), Errors.CM_FACTORY_ADDRESS_IS_NOT_CONFIGURED);\\r\\n    }\\r\\n\\r\\n    function governToken(BotMetaData storage ds) internal view returns(IDABotGovernToken) {\\r\\n        address gToken = ds.gToken;\\r\\n        require(gToken != address(0), Errors.BCL_GOVERN_TOKEN_IS_NOT_DEPLOYED);\\r\\n        return IDABotGovernToken(gToken);\\r\\n    }\\r\\n\\r\\n    function module(BotMetaData storage ds, bytes32 moduleId) internal view returns(address) {\\r\\n        if (ds.botTemplate == address(0)) {\\r\\n            return DABotTemplateControllerLib.controller().module(moduleId);\\r\\n        }\\r\\n        return IBotTemplateController(ds.botTemplate).module(moduleId);\\r\\n    }\\r\\n\\r\\n    function deployCertToken(BotMetaData storage ds, address asset) internal returns(address) {\\r\\n        address certTokenMaster = ds.module(BOT_CERT_TOKEN_TEMPLATE_ID);\\r\\n        if (certTokenMaster == address(0)) {\\r\\n            revert(string(abi.encodePacked(\\r\\n                Errors.BCL_CERT_TOKEN_IS_NOT_CONFIGURED, \\r\\n                '. template: ', \\r\\n                Strings.toHexString(uint160(ds.botTemplate), 20)\\r\\n                )));\\r\\n        }\\r\\n        require(certTokenMaster != address(0), Errors.BCL_CERT_TOKEN_IS_NOT_CONFIGURED);\\r\\n\\r\\n        return ds.factory().deploy(\\r\\n            certTokenMaster,\\r\\n            abi.encode(address(this), asset),\\r\\n            false\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function deployGovernanceToken(BotMetaData storage ds) internal returns(address) {\\r\\n        address governTokenMaster = ds.module(BOT_GOV_TOKEN_TEMPLATE_ID);\\r\\n        require(governTokenMaster != address(0), Errors.BCL_GOVERN_TOKEN_IS_NOT_CONFIGURED);\\r\\n\\r\\n        return ds.factory().deploy(\\r\\n            governTokenMaster,\\r\\n            abi.encode(address(this)),\\r\\n            false\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function deployLocker(BotMetaData storage ds, bytes32 lockerType, LockerData memory data) internal returns(address) {\\r\\n        address lockerMaster = ds.module(lockerType);\\r\\n        if (lockerMaster == address(0)) {\\r\\n            if (lockerType == BOT_CERT_TOKEN_COOLDOWN_HANDLER_ID) \\r\\n                revert(Errors.BCL_COOLDOWN_LOCKER_IS_NOT_CONFIGURED);\\r\\n            revert(Errors.BCL_UKNOWN_MODULE_ID);\\r\\n        }\\r\\n        return ds.factory().deploy(\\r\\n            lockerMaster,\\r\\n            abi.encode(data),\\r\\n            false\\r\\n        );\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/DABotCommon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\r\\n\\r\\nimport \\\"./interfaces/IDABotComponent.sol\\\";\\r\\n\\r\\nenum BotStatus { PRE_IBO, IN_IBO, ACTIVE, ABANDONED }\\r\\n\\r\\nstruct BotModuleInitData {\\r\\n    bytes32 moduleId;\\r\\n    bytes data;\\r\\n}\\r\\n\\r\\nstruct BotSetting {             // for saving storage, the meta-fields of a bot are encoded into a single uint256 byte slot.\\r\\n    uint64 iboTime;             // 32 bit low: iboStartTime (unix timestamp), \\r\\n                                // 32 bit high: iboEndTime (unix timestamp)\\r\\n    uint24 stakingTime;         // 8 bit low: warm-up time, \\r\\n                                // 8 bit mid: cool-down time\\r\\n                                // 8 bit high: time unit (0 - day, 1 - hour, 2 - minute, 3 - second)\\r\\n    uint32 pricePolicy;         // 16 bit low: price multiplier (fixed point, 2 digits for decimal)\\r\\n                                // 16 bit high: commission fee in percentage (fixed point, 2 digit for decimal)\\r\\n    uint128 profitSharing;      // packed of 16bit profit sharing: bot-creator, gov-user, stake-user, and robofi-game\\r\\n    uint initDeposit;           // the intial deposit (in VICS) of bot-creator\\r\\n    uint initFounderShare;      // the intial shares (i.e., governance token) distributed to bot-creator\\r\\n    uint maxShare;              // max cap of gtoken supply\\r\\n    uint iboShare;              // max supply of gtoken for IBO. Constraint: maxShare >= iboShare + initFounderShare\\r\\n}\\r\\n\\r\\nstruct BotMetaData {\\r\\n    string name;\\r\\n    string symbol;\\r\\n    string version;\\r\\n    uint8 botType;\\r\\n    bool abandoned;\\r\\n    bool isTemplate;        // determine this module is a template, not a bot instance\\r\\n    bool initialized;       // determines whether the bot has been initialized \\r\\n    address botOwner;       // the public address of the bot owner\\r\\n    address botManager;\\r\\n    address botTemplate;    // address of the template contract \\r\\n    address gToken;         // address of the governance token\\r\\n}\\r\\n\\r\\nstruct BotDetail { // represents a detail information of a bot, merely use for bot infomation query\\r\\n    uint id;                    // the unique id of a bot within its manager.\\r\\n                                // note: this id only has value when calling {DABotManager.queryBots}\\r\\n    address botAddress;         // the contract address of the bot.\\r\\n\\r\\n    BotStatus status;           // 0 - PreIBO, 1 - InIBO, 2 - Active, 3 - Abandonned\\r\\n    uint8 botType;              // type of the bot (inherits from the bot's template)\\r\\n    string botSymbol;           // get the bot name.\\r\\n    string botName;             // get the bot full name.\\r\\n    address governToken;        // the address of the governance token\\r\\n    address template;           // the address of the master contract which defines the behaviors of this bot.\\r\\n    string templateName;        // the template name.\\r\\n    string templateVersion;     // the template version.\\r\\n    uint iboStartTime;          // the time when IBO starts (unix second timestamp)\\r\\n    uint iboEndTime;            // the time when IBO ends (unix second timestamp)\\r\\n    uint warmup;                // the duration (in days) for which the staking profit starts counting\\r\\n    uint cooldown;              // the duration (in days) for which users could claim back their stake after submiting the redeem request.\\r\\n    uint priceMul;              // the price multiplier to calculate the price per gtoken (based on the IBO price).\\r\\n    uint commissionFee;         // the commission fee when buying gtoken after IBO time.\\r\\n    uint initDeposit;           \\r\\n    uint initFounderShare;\\r\\n    uint144 profitSharing;\\r\\n    uint maxShare;              // max supply of governance token.\\r\\n    uint circulatedShare;       // the current supply of governance token.\\r\\n    uint iboShare;              // the max supply of gtoken for IBO.\\r\\n    uint userShare;             // the amount of governance token in the caller's balance.\\r\\n    UserPortfolioAsset[] portfolio;\\r\\n}\\r\\n\\r\\nstruct BotModuleInfo {\\r\\n    string name;\\r\\n    string version;\\r\\n    address handler;\\r\\n}\\r\\n\\r\\nstruct PortfolioCreationData {\\r\\n    address asset;\\r\\n    uint256 cap;            // the maximum stake amount for this asset (bot-lifetime).\\r\\n    uint256 iboCap;         // the maximum stake amount for this asset within the IBO.\\r\\n    uint256 weight;         // preference weight for this asset. Use to calculate the max purchasable amount of governance tokens.\\r\\n}\\r\\n\\r\\nstruct PortfolioAsset {\\r\\n    address certToken;    // the certificate asset to return to stake-users\\r\\n    uint256 cap;            // the maximum stake amount for this asset (bot-lifetime).\\r\\n    uint256 iboCap;         // the maximum stake amount for this asset within the IBO.\\r\\n    uint256 weight;         // preference weight for this asset. Use to calculate the max purchasable amount of governance tokens.\\r\\n}\\r\\n\\r\\nstruct UserPortfolioAsset {\\r\\n    address asset;\\r\\n    PortfolioAsset info;\\r\\n    uint256 userStake;\\r\\n    uint256 totalStake;     // the total stake of all users.\\r\\n    uint256 certSupply;     // the total supply of the certificated token\\r\\n}\\r\\n\\r\\n/**\\r\\n@dev Records warming-up certificate tokens of a DABot.\\r\\n*/\\r\\nstruct LockerData {         \\r\\n    address bot;            // the DABOT which creates this locker.\\r\\n    address owner;          // the locker owner, who is albe to unlock and get tokens after the specified release time.\\r\\n    address token;          // the contract of the certificate token.\\r\\n    uint64 created_at;      // the moment when locker is created.\\r\\n    uint64 release_at;      // the monent when locker could be unlock. \\r\\n}\\r\\n\\r\\n/**\\r\\n@dev Provides detail information of a warming-up token lock, plus extra information.\\r\\n    */\\r\\nstruct LockerInfo {\\r\\n    address locker;\\r\\n    LockerData info;\\r\\n    uint256 amount;         // the locked amount of cert token within this locker.\\r\\n    uint256 reward;         // the accumulated rewards\\r\\n    address asset;          // the stake asset beyond the certificated token\\r\\n}\\r\\n\\r\\nstruct MintableShareDetail {\\r\\n    address asset;\\r\\n    uint stakeAmount;\\r\\n    uint mintableShare;\\r\\n    uint weight;\\r\\n    uint iboCap;\\r\\n}\\r\\n\\r\\nstruct AwardingDetail {\\r\\n    address asset;\\r\\n    uint compound;\\r\\n    uint reward;\\r\\n    uint compoundMode;  // 0 - increase, 1 - decrrease\\r\\n}\\r\\n\\r\\nstruct StakingReward {\\r\\n    address asset;\\r\\n    uint amount;\\r\\n}\\r\\n\\r\\nstruct BenefitciaryInfo {\\r\\n    address account;\\r\\n    string name;\\r\\n    string shortName;\\r\\n    uint weight;\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/fundmanager/DABotFundManagerLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../DABotCommon.sol\\\"; \\r\\nimport \\\"../interfaces/IBotBenefitciary.sol\\\"; \\r\\n\\r\\nstruct FundManagementData {\\r\\n    address[] benefitciaries;\\r\\n}\\r\\n\\r\\naddress constant BOT_CREATOR_BENEFITCIARY = address(1);\\r\\naddress constant GOV_USER_BENEFITCIARY = address(2);\\r\\naddress constant STAKE_USER_BENEFITCIARY = address(3);\\r\\n\\r\\nlibrary DABotFundManagerLib {\\r\\n    bytes32 constant FUND_MANAGER_STORAGE_POSITION = keccak256(\\\"fundmanager.dabot.storage\\\");\\r\\n\\r\\n\\r\\n    function fundData() internal pure returns(FundManagementData storage ds) {\\r\\n        bytes32 position = FUND_MANAGER_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot :=  position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function benefitciaryName(address benefitciary) internal view returns(string memory) {\\r\\n        if (benefitciary == BOT_CREATOR_BENEFITCIARY)\\r\\n            return \\\"Bot Creator\\\";\\r\\n        if (benefitciary == GOV_USER_BENEFITCIARY)\\r\\n            return \\\"Governance Users\\\";\\r\\n        if (benefitciary == STAKE_USER_BENEFITCIARY)\\r\\n            return \\\"Stake Users\\\";\\r\\n        return IBotBenefitciary(benefitciary).name();\\r\\n    }\\r\\n\\r\\n    function benefitciaryShortName(address benefitciary) internal view returns(string memory) {\\r\\n        if (benefitciary == BOT_CREATOR_BENEFITCIARY)\\r\\n            return \\\"Bot Creator\\\";\\r\\n        if (benefitciary == GOV_USER_BENEFITCIARY)\\r\\n            return \\\"Gov. Users\\\";\\r\\n        if (benefitciary == STAKE_USER_BENEFITCIARY)\\r\\n            return \\\"Stake Users\\\";\\r\\n        return IBotBenefitciary(benefitciary).shortName();\\r\\n    }\\r\\n\\r\\n    function addBenefitciary(FundManagementData storage ds, address benefitciary) internal {\\r\\n        ds.benefitciaries.push(benefitciary);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/interfaces/IBotBenefitciary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../DABotCommon.sol\\\"; \\r\\n\\r\\n\\r\\n/**\\r\\n@dev The interface of a bot benefitciary who is awarded from the bot's activities.\\r\\n */\\r\\ninterface IBotBenefitciary {\\r\\n\\r\\n    function name() external view returns(string memory);\\r\\n    function shortName() external view returns(string memory);\\r\\n    function onAward(uint amount) external;\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/interfaces/IBotTemplateController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\ninterface IBotTemplateController {\\r\\n    function registerModule(address moduleHandler) external;\\r\\n    function updateModuleHandler(bytes32 moduleId, address newModuleAddress) external;\\r\\n    function module(bytes32 moduleId) external view returns(address);\\r\\n    function moduleOfSelector(bytes32 selector) external view returns(address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/dabot/interfaces/IBotVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../../token/IRoboFiERC20.sol\\\";\\r\\n\\r\\nstruct VaultData {\\r\\n    address botToken;\\r\\n    IERC20 asset;\\r\\n    address bot;\\r\\n    uint8 index;                // the index-th vault generated from botToken\\r\\n                                //  0 - warmup vault, 1 - regular vault, 2 - VIP vault\\r\\n    bytes4 vaultType;           // type of the vault, used to determine the vault handler\\r\\n}\\r\\n\\r\\nstruct UserInfo {\\r\\n    uint deposit;\\r\\n    uint debtPoints;\\r\\n    uint debt;\\r\\n    uint lockPeriod;\\r\\n    uint lastDepositTime;\\r\\n}\\r\\n\\r\\nstruct VaultInfo {\\r\\n    VaultData data;             \\r\\n    UserInfo user;\\r\\n    uint totalDeposit;          // total deposits in the vault\\r\\n    uint accRewardPerShare;     // the pending reward per each unit of deposit\\r\\n    uint lastRewardTime;        // the block time of the last reward transaction\\r\\n    uint pendingReward;         // the pending reward for the caller\\r\\n    bytes option;               // vault option\\r\\n} \\r\\n\\r\\nstruct RegularVaultOption {\\r\\n    bool restricted;    // restrict deposit activity to bot only\\r\\n}\\r\\n\\r\\n\\r\\ninterface IBotVaultEvent {\\r\\n    event Deposit(uint vID, address indexed payor, address indexed account, uint amount);\\r\\n    event Widthdraw(uint vID, address indexed account, uint amount);\\r\\n    event RewardAdded(uint vID, uint assetAmount);\\r\\n    event RewardClaimed(uint vID, address indexed account, uint amount);\\r\\n    event Snapshot(uint vID, uint snapshotId);\\r\\n}\\r\\n\\r\\ninterface IBotVault is IBotVaultEvent {\\r\\n    function deposit(uint vID, uint amount) external;\\r\\n    function delegateDeposit(uint vID, address payor, address account, uint amount, uint lockTime) external;\\r\\n    function withdraw(uint vID, uint amount) external;\\r\\n    function delegateWithdraw(uint vID, address account, uint amount) external;\\r\\n    function pendingReward(uint vID, address account) external view returns(uint);\\r\\n    function balanceOf(uint vID, address account) external view returns(uint);\\r\\n    function balanceOfAt(uint vID, address account, uint blockNo) external view returns(uint);\\r\\n    function updateReward(uint vID, uint assetAmount) external;\\r\\n    function claimReward(uint vID, address account) external;\\r\\n\\r\\n    /**\\r\\n    @dev Queries user deposit info for the given vault.\\r\\n    @param vID the vault ID to query.\\r\\n    @param account the user account to query.\\r\\n     */\\r\\n    function getUserInfo(uint vID, address account) external view returns(UserInfo memory result);\\r\\n    function getVaultInfo(uint vID, address account) external view returns(VaultInfo memory);\\r\\n    function getVaultOption(uint vID) external view returns(bytes memory);\\r\\n    function setVaultOption(uint vID, bytes calldata option) external;\\r\\n}\\r\\n\\r\\ninterface IBotVaultManagerEvent is IBotVaultEvent {\\r\\n    event OpenVault(uint vID, VaultData data);\\r\\n    event DestroyVault(uint vID);\\r\\n    event RegisterHandler(bytes4 vaultType, address handler);\\r\\n    event BotManagerUpdated(address indexed botManager);\\r\\n}\\r\\n\\r\\ninterface IBotVaultManager is IBotVault, IBotVaultManagerEvent {\\r\\n    function vaultOf(uint vID) external view returns(VaultData memory result);\\r\\n    function validVault(uint vID) external view returns(bool);\\r\\n    function createVault(VaultData calldata data) external returns(uint);\\r\\n    function destroyVault(uint vID) external;\\r\\n    function vaultId(address botToken, uint8 vaultIndex) external pure returns(uint);\\r\\n    function registerHandler(bytes4 vaultType, IBotVault handler) external;\\r\\n    function botManager() external view returns(address);\\r\\n    function setBotManager(address account) external;\\r\\n    function snapshot(uint vID) external;\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../DABotCommon.sol\\\"; \\r\\nimport \\\"./IDABotController.sol\\\";\\r\\nimport \\\"./IDABotSettingModule.sol\\\";\\r\\nimport \\\"./IDABotStakingModule.sol\\\";\\r\\nimport \\\"./IDABotGovernModule.sol\\\";\\r\\nimport \\\"./IDABotWhitelist.sol\\\";\\r\\nimport \\\"./IDABotFundManagerModule.sol\\\";\\r\\n\\r\\ninterface IDABot is IDABotController, \\r\\n    IDABotSettingModule, \\r\\n    IDABotStakingModule, \\r\\n    IDABotGovernModule, \\r\\n    IDABotWhitelistModule,\\r\\n    IDABotFundManagerModule \\r\\n{\\r\\n}\\r\\n\\r\\n\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotCertLocker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../../token/IRoboFiERC20.sol\\\";\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\n\\r\\ninterface IDABotCertLocker is IRoboFiERC20 {\\r\\n    function asset() external view returns(IRoboFiERC20);\\r\\n    function detail() external view returns(LockerInfo memory);\\r\\n    function lockedBalance() external view returns(uint);\\r\\n    function unlockerable() external view returns(bool);\\r\\n    function tryUnlock() external returns(bool, uint);\\r\\n    function finalize() external payable;\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotCertToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface IDABotCertTokenEvent {\\r\\n    /**\\r\\n    @dev Triggered when the bot owner locked an amount of certificate token for trading (or yield farming).\\r\\n    @param assetAmount the amount of the underlying asset locked.\\r\\n     */\\r\\n    event Lock(uint assetAmount);\\r\\n\\r\\n    /**\\r\\n    @dev Triggered when the bot owner unlocked an amount of certificate token.\\r\\n    @param assetAmount the amount of the underlying asset unlocked.\\r\\n     */\\r\\n    event Unlock(uint assetAmount);\\r\\n\\r\\n    /**\\r\\n    @dev Triggered when the amount of pegged assets of this certificate token has been changed.\\r\\n    @param amount the changed amount.\\r\\n    @param profitOrLoss true if the the pegged assets increase, false on otherwise.\\r\\n     */\\r\\n    event Compound(uint amount, bool profitOrLoss);\\r\\n}\\r\\n\\r\\ninterface IDABotCertToken is IERC20, IDABotCertTokenEvent {\\r\\n\\r\\n    function isCertToken() external view returns(bool);\\r\\n\\r\\n    /**\\r\\n    @dev Gets the total deposit of the underlying asset within this certificate.\\r\\n     */\\r\\n    function totalStake() external view returns(uint);\\r\\n\\r\\n    function totalLiquid() external view returns(uint);\\r\\n\\r\\n    /**\\r\\n    @dev Queries the bot who owned this certificate.\\r\\n     */\\r\\n    function owner() external view returns(address);\\r\\n    \\r\\n    /**\\r\\n    @dev Gets the underlying asset of this certificate.\\r\\n     */\\r\\n    function asset() external view returns (IERC20);\\r\\n    \\r\\n    /**\\r\\n    @dev Returns the equivalent amount of the underlying asset for the given amount\\r\\n        of certificate tokens.\\r\\n    @param certTokenAmount - the amount of certificate tokens.\\r\\n     */\\r\\n    function value(uint certTokenAmount) external view returns(uint);\\r\\n\\r\\n    function lock(uint assetAmount) external;\\r\\n\\r\\n    function unlock(uint assetAmount) external;\\r\\n\\r\\n    /**\\r\\n    @dev Mints an amount of certificate tokens to the given amount. The equivalent of\\r\\n        underlying asset should be tranfered to this certificate contract by the caller.\\r\\n    @param account - the address to recieve minted tokens.\\r\\n    @param certTokenAmount - the amount of tokens to mint.\\r\\n    @notice Only the owner bot can call this function.\\r\\n     */\\r\\n    function mint(address account, uint certTokenAmount) external returns(uint);\\r\\n\\r\\n    /**\\r\\n    @dev Burns an amount of certificate tokens, and returns the equivalant amount of\\r\\n        the underlying asset to the specified account.\\r\\n    @param account - the address holing certificate tokens to burn.\\r\\n    @param certTokenAmount - the amount of certificate token to burn.\\r\\n    @return the equivalent amount of underlying asset tranfered to the specified account.\\r\\n    @notice Only the owner bot can call this function.\\r\\n     */\\r\\n    function burn(address account, uint certTokenAmount) external returns (uint);\\r\\n\\r\\n    /**\\r\\n    @dev Burns an amount of certificate tokens, and returns the equivalent amount of the \\r\\n        underlying asset to the caller.\\r\\n    @param amount - the amount of certificate token to burn.\\r\\n    @return the equivalent amount of underlying asset transfered to the caller.\\r\\n     */\\r\\n    function burn(uint amount) external returns(uint);\\r\\n\\r\\n    /**\\r\\n    @dev Burns an amount of certificate tokens without returning any underlying assets.\\r\\n    @param account - the account holding certificate tokens to burn.\\r\\n    @param amount - the amount of certificate tokens to burn.\\r\\n    @notice Only owner bot can call this function.\\r\\n     */\\r\\n    function slash(address account, uint amount) external;\\r\\n\\r\\n    /**\\r\\n    @dev Compound a given amount of the underlying asset to the total deposit. \\r\\n        The compoud could be either profit or loss.\\r\\n    @param amount - the compound amount.\\r\\n    @param profitOrLoss - `true` to increase the total deposit, `false` to decrease.\\r\\n     */\\r\\n    function compound(uint amount, bool profitOrLoss) external;\\r\\n\\r\\n    /**\\r\\n    @dev Deletes this certificate token contracts.\\r\\n     */\\r\\n    function finalize() external payable;\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotComponent.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nbytes32 constant IDABotFarmingModuleID = keccak256(\\\"farming.module\\\");\\r\\nbytes32 constant IDABotFundManagerModuleID = keccak256('fundmanager.module');\\r\\nbytes32 constant IDABotStakingModuleID = keccak256(\\\"staking.module\\\");\\r\\nbytes32 constant IDABotGovernModuleID = keccak256('governance.module');\\r\\nbytes32 constant IDABotSettingModuleID = keccak256('setting.module');\\r\\nbytes32 constant IDABotWhitelistModuleID = keccak256(\\\"whitelist.module\\\");\\r\\n\\r\\nbytes32 constant GovTokenHandlerID = keccak256('govtokenimpl.dabot.module');\\r\\nbytes32 constant CertTokenHandlerID = keccak256('certtokenimpl.dabot.module');\\r\\n\\r\\nbytes32 constant BOT_CERT_TOKEN_COOLDOWN_HANDLER_ID = keccak256(\\\"cooldown.dabot.module\\\");\\r\\n\\r\\nbytes32 constant BOT_CERT_TOKEN_TEMPLATE_ID = keccak256(\\\"certificate-token.dabot.module\\\");\\r\\nbytes32 constant BOT_GOV_TOKEN_TEMPLATE_ID = keccak256(\\\"governance-token.dabot.module\\\");\\r\\n\\r\\n//bytes32 constant BOT_MODULE_COOLDOWN_LOCKER = keccak256(\\\"cooldown.dabot.module\\\");\\r\\n\\r\\ninterface IDABotComponent {   \\r\\n    function moduleInfo() external view returns(string memory name, string memory version, bytes32 moduleId);\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../DABotCommon.sol\\\"; \\r\\n\\r\\ninterface IDABotControllerEvent {\\r\\n    event BotAbandoned(bool value);\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n    event ModuleHandlerChanged(bytes32 moduleId, address indexed oldModuleAddress, address indexed newModuleAddress);\\r\\n    event ModuleRegistered(bytes32 moduleId, address indexed moduleAddress, string name, string version);\\r\\n}\\r\\n\\r\\n/**\\r\\n@dev The generic interface of a DABot.\\r\\n */\\r\\ninterface IDABotController is IDABotControllerEvent {\\r\\n    function owner() external view returns(address);\\r\\n    function abandon(bool value) external;\\r\\n    function modulesInfo() external view returns(BotModuleInfo[] memory result);\\r\\n    function governToken() external view returns(address);\\r\\n    function qualifiedName() external view returns(string memory);\\r\\n    function metadata() external view returns(BotMetaData memory);\\r\\n    function setting() external view returns(BotSetting memory);\\r\\n    function botDetails() view external returns(BotDetail memory);\\r\\n    function updatePortfolio(address asset, uint maxCap, uint iboCap, uint weight) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotFarmingModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nstruct SwapDetail {\\r\\n    uint amountIn;\\r\\n    address[] path;\\r\\n    address adapter;\\r\\n}\\r\\n\\r\\ninterface IDABotFarmingModuleEvent {\\r\\n    event WorkerAdded(address indexed worker);\\r\\n    event WorkerRemoved(address indexed worker);\\r\\n    event OperatorUpdated(address indexed account, bool status);\\r\\n    event Swap(address indexed from, address indexed to, uint amountIn, uint amountOut, address adapter);\\r\\n    event Repay(address indexed worker, address platformToken, uint amount);\\r\\n}\\r\\n\\r\\ninterface IDABotFarmingModule is IDABotFarmingModuleEvent {\\r\\n\\r\\n    function allWorkers() external view returns(address[] memory workers);\\r\\n\\r\\n    function deployWorker(\\r\\n        address engineTemplate,\\r\\n        uint16[] calldata pIDs,\\r\\n        bytes[] calldata values\\r\\n    ) external returns(address worker);\\r\\n\\r\\n    function canRemoveWorker(address worker) external view returns(bool);\\r\\n\\r\\n    function indexOfWorker(address worker) external view returns(bool found, uint index);\\r\\n\\r\\n    function removeWorker(uint index) external;\\r\\n\\r\\n    function setOperator(address account, bool status) external; \\r\\n\\r\\n    function isOperator(address account) external view returns(bool);\\r\\n\\r\\n    function swap(SwapDetail[] calldata details) external;\\r\\n\\r\\n    function repay(uint index, address platformToken, uint amount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotFundManagerModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\n\\r\\ninterface IDABotFundManagerModuleEvent {\\r\\n    event Award(AwardingDetail[] pnl, uint[] totalStakes, uint[] certTokenValues);\\r\\n    event AwardCompound(address indexed asset, uint amount, uint mode);\\r\\n    event AwardBenefitciary(address indexed benefitciary, address indexed portfolioAsset, address indexed awardedAsset, uint amount, uint share, uint totalShare);\\r\\n    event AddBenefitciary(address indexed benefitciary);\\r\\n}\\r\\n\\r\\ninterface IDABotFundManagerModule is IDABotFundManagerModuleEvent {\\r\\n    \\r\\n    /**\\r\\n    @dev Gets detailed information about benefitciaries of staking rewards.\\r\\n     */\\r\\n    function benefitciaries() external view returns(BenefitciaryInfo[] memory result);\\r\\n\\r\\n    /**\\r\\n    @dev Replaces the current bot's benefitciaries with its bot template's\\r\\n    @notice Only bot owner can call.\\r\\n     */\\r\\n    function resetBenefitciaries() external; \\r\\n\\r\\n    /**\\r\\n    @dev Add new benefitciary\\r\\n    @param benefitciary - the benefitciary address. Should not be added before.\\r\\n     */\\r\\n    function addBenefitciary(address benefitciary) external;\\r\\n\\r\\n    /**\\r\\n     @dev Add profit/loss for each asset in the portfolio.\\r\\n     @param pnl - list of AwardingDetail data.\\r\\n     */\\r\\n    function award(AwardingDetail[] calldata pnl) external;\\r\\n\\r\\n    /**\\r\\n    @dev Checks the pending stake rewarod of a given account for specified assets.\\r\\n    @param account - the account to check.\\r\\n    @param assets - the list of assets to check for reward. \\r\\n        If empty list is passed, all assets in the portfolio are checked.\\r\\n    @param subVaults - the list of sub-vaults to check. \\r\\n        If empty list is passed, all sub vaults (i.e., [0, 1, 2]) are checked.\\r\\n     */\\r\\n    function pendingStakeReward(address account, address[] calldata assets, \\r\\n        bytes calldata subVaults) external view returns(StakingReward[] memory);\\r\\n\\r\\n    /**\\r\\n    @dev Checks the pending governance rewardsof a given account.\\r\\n    @param account - the account to check.\\r\\n    @param subVaults - the lst oof sub-vaults to check. \\r\\n        if empty list is passed, all sub vaults (i.e., [0, 1]) are checked.\\r\\n     */\\r\\n    function pendingGovernReward(address account, bytes calldata subVaults) external view returns(uint);\\r\\n\\r\\n    /**\\r\\n    @dev Withdraws tokens that have been transfered to the bot contract by mistake.\\r\\n    All balance of the specified token in the bot will be transfered to `to` address.\\r\\n    @param asset - the IERC20 token contract.\\r\\n    @param to - the recipient address\\r\\n     */\\r\\n    function withdrawToken(address asset, address to) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotGovernModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\nimport \\\"../interfaces/IBotVault.sol\\\";\\r\\n\\r\\ninterface IDABotGovernModuleEvent {\\r\\n    event MintGToken(address indexed account, uint amountIn, uint fee, uint amountOut, uint updatedRate);\\r\\n}\\r\\n\\r\\ninterface IDABotGovernModule is IDABotGovernModuleEvent {\\r\\n\\r\\n    /**\\r\\n    @dev Creates staking vaults for governance tokens. This method should be called\\r\\n        internally only by the bot manager.\\r\\n     */\\r\\n    function createGovernVaults() external;\\r\\n\\r\\n    /**\\r\\n    @dev Gets the vaults of governance tokens.\\r\\n    @param account - the account to query depsot/reward information\\r\\n     */\\r\\n    function governVaults(address account) external view returns(VaultInfo[] memory);\\r\\n\\r\\n    /**\\r\\n    @dev Claims all pending governance rewards in all vaults.\\r\\n     */\\r\\n    function harvestGovernanceReward() external;\\r\\n\\r\\n    /**\\r\\n    @dev Queries the total pending governance rewards in all vaults\\r\\n    @param account - the account to query.\\r\\n     */\\r\\n    function governanceReward(address account) external view returns(uint);\\r\\n\\r\\n    /**\\r\\n    @dev Gets the maximum amount of gToken that an account could mint from a bot.\\r\\n    @param account - the account to query.\\r\\n    @return the total mintable amount of gToken.\\r\\n     */\\r\\n    function mintableShare(address account) external view returns(uint);\\r\\n\\r\\n    /** \\r\\n    @dev Gets the details accounting for the amount of mintable shares.\\r\\n    @param account the account to query\\r\\n    @return an array of MintableShareDetail strucs.\\r\\n     */\\r\\n    function iboMintableShareDetail(address account) external view returns(MintableShareDetail[] memory); \\r\\n\\r\\n    /**\\r\\n    @dev Calculates the output for an account who mints shares with the given VICS amount.\\r\\n    @param account - the account to query\\r\\n    @param vicsAmount - the amount of VICS used to mint shares.\\r\\n    @return payment - the amount of VICS for minting shares.\\r\\n            shares - the amount of shares mintied.\\r\\n            fee - the amount of VICS for minting fee. \\r\\n     */\\r\\n    function calcOutShare(address account, uint vicsAmount) external view returns(uint payment, uint shares, uint fee);\\r\\n\\r\\n    /**\\r\\n    @dev Get the total balance of shares owned by the specified account. The total includes\\r\\n        shares within the account's wallet, and shares staked in bot's vaults.\\r\\n    @param account - the account to query.\\r\\n    @return the number of shares.\\r\\n     */\\r\\n    function shareOf(address account) external view returns(uint);\\r\\n\\r\\n    /**\\r\\n    @dev Mints shares for the given VICS amount. Minted shares will directly stakes to BotVault for rewards.\\r\\n    @param vicsAmount - the amount of VICS used to mint shared.\\r\\n    @notice\\r\\n        Minted shares during IBO will be locked in separated pool, which onlly allow users to withdraw\\r\\n        after 1 month after the IBO ends.\\r\\n\\r\\n        VICS for payment will be kept inside the share contracts. Whereas, VICS for fee are transfered\\r\\n        to the tax address, configured in the platform configurator.\\r\\n     */\\r\\n    function mintShare(uint vicsAmount) external;\\r\\n\\r\\n    /**\\r\\n    @dev Burns an amount of gToken and sends the corresponding VICS to caller's wallet.\\r\\n    @param amount - the amount of gToken to burn.\\r\\n     */\\r\\n    function burnShare(uint amount) external;\\r\\n\\r\\n    /**\\r\\n    @dev Takes a snapshot of current vote powers (i.e. amount of gov)\\r\\n     */\\r\\n    function snapshot() external;\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotGovernToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface IDABotGovernToken is IERC20 {\\r\\n\\r\\n    function isGovernToken() external view returns(bool);\\r\\n    \\r\\n    function owner() external view returns(address);\\r\\n    function asset() external view returns (IERC20);\\r\\n    function value(uint amount) external view returns(uint);\\r\\n    function mint(address account, uint amount) external;\\r\\n    function burn(uint amount) external returns(uint);\\r\\n\\r\\n    function snapshot() external;\\r\\n    function totalSupplyAt(uint256 snapshotId) external view returns(uint256);\\r\\n    function balanceOfAt(address account, uint256 snapshotId) external view returns (uint256);\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IBotVault.sol\\\";\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\nimport \\\"../../common/IRoboFiFactory.sol\\\";\\r\\nimport \\\"../../common/IConfigurator.sol\\\";\\r\\n\\r\\ninterface IDABotManagerEvent {\\r\\n    event BotRemoved(address indexed bot);\\r\\n    event BotDeployed(uint botId, address indexed bot, BotDetail detail); \\r\\n    event TemplateRegistered(address indexed template, string name, string version, uint8 templateType);\\r\\n}\\r\\n\\r\\ninterface IDABotManager is IDABotManagerEvent {\\r\\n    \\r\\n    function configurator() external view returns(IConfigurator);\\r\\n    function vaultManager() external view returns(IBotVaultManager);\\r\\n    function addTemplate(address template) external;\\r\\n    function templates() external view returns(address[] memory);\\r\\n    function isRegisteredTemplate(address template) external view returns(bool);\\r\\n    function isRegisteredBot(address botAccount) external view returns(bool);\\r\\n    function totalBots() external view returns(uint);\\r\\n    function botIdOf(string calldata qualifiedName) external view returns(int);\\r\\n    function queryBots(uint[] calldata botId) external view returns(BotDetail[] memory output);\\r\\n    function deployBot(address template, \\r\\n                        string calldata symbol, \\r\\n                        string calldata name,\\r\\n                        BotModuleInitData[] calldata initData\\r\\n                        ) external;\\r\\n    function snapshot(address botAccount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IDABotComponent.sol\\\";\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n@dev An common interface of a DABot module.\\r\\n */\\r\\ninterface IDABotModule is IDABotComponent {\\r\\n    event ModuleRegistered(string name, bytes32 moduleId, address indexed moduleAddress);\\r\\n    \\r\\n    function onRegister(address moduleAddress) external;\\r\\n    function onInitialize(bytes calldata data) external;\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotSettingModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\n\\r\\ninterface IDABotSettingModuleEvent {\\r\\n    event SettingChanged(uint what, BotSetting setting);  \\r\\n    event AddressWritten(bytes32 itemId, address indexed value);\\r\\n    event UintWritten(bytes32 itemId, uint value);\\r\\n    event BytesWritten(bytes32 itemId, bytes value);\\r\\n}\\r\\n\\r\\ninterface IDABotSettingModule is IDABotSettingModuleEvent {   \\r\\n    function status() external view returns(uint);\\r\\n    function iboTime() external view returns(uint startTime, uint endTime);\\r\\n    function stakingTime() external view returns(uint warmup, uint cooldown, uint unit);\\r\\n    function pricePolicy() external view returns(uint priceMul, uint commission);\\r\\n    function profitSharing() external view returns(uint128);\\r\\n    function setIBOTime(uint startTime, uint endTime) external;\\r\\n    function setStakingTime(uint warmup, uint cooldown, uint unit) external;\\r\\n    function setPricePolicy(uint priceMul, uint commission) external;\\r\\n    function setProfitSharing(uint sharingScheme) external;\\r\\n\\r\\n    function readAddress(bytes32 itemId, address defaultAddress) external view returns(address);\\r\\n    function readUint(bytes32 itemId, uint defaultValue) external view returns(uint);\\r\\n    function readBytes(bytes32 itemId, bytes calldata defaultValue) external view returns(bytes memory);\\r\\n\\r\\n    function writeAddress(bytes32 itemId, address value) external;\\r\\n    function writeUint(bytes32 itemId, uint value) external;\\r\\n    function writeBytes(bytes32 itemId, bytes calldata value) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotStakingModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IDABotCertToken.sol\\\";\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\nimport \\\"../interfaces/IBotVault.sol\\\";\\r\\n\\r\\ninterface IDABotStakingModuleEvent {\\r\\n     event PortfolioUpdated(address indexed asset, address indexed certToken, uint maxCap, uint iboCap, uint weight);\\r\\n     event AssetRemoved(address indexed asset, address indexed certToken);   \\r\\n     event Stake(address indexed asset, uint amount, address indexed certToken, uint certAmount, address indexed locker);\\r\\n     event Unstake(address indexed certToken, uint certAmount, address indexed asset, \\r\\n          uint assetAmount, address indexed locker, uint releaseTime);\\r\\n}\\r\\n\\r\\ninterface IDABotStakingModule is IDABotStakingModuleEvent {\\r\\n\\r\\n     /**\\r\\n     @dev Gets the detailed information of the bot's portfolio.\\r\\n     @return the arrays of UserPortfolioAsset struct.\\r\\n      */\\r\\n     function portfolioDetails() external view returns(UserPortfolioAsset[] memory);\\r\\n\\r\\n     /**\\r\\n     @dev Gets the portfolio information for the given asset.\\r\\n     @param asset - the asset to query.\\r\\n      */\\r\\n     function portfolioOf(address asset) external view returns(UserPortfolioAsset memory);\\r\\n\\r\\n     /**\\r\\n     @dev Adds or update an asset in the bot's portfolio.\\r\\n     @param asset - the crypto asset to add/update in the portfolio.\\r\\n     @param maxCap - the maximum amount of crypto asset to stake to the bot.\\r\\n     @param iboCap - the maximum amount of crypto asset to stake during the bot's IBO.\\r\\n     @param weight - the preference index of an asset in the portfolio. This is used\\r\\n               to calculate the mintable amount of governance shares in accoardance to \\r\\n               staked amount. \\r\\n\\r\\n               Gven the same USD-worth amount of two assets, the one with higher weight \\r\\n               will contribute more to the mintable amount of shares than the other.\\r\\n      */\\r\\n     function updatePortfolioAsset(address asset, uint maxCap, uint iboCap, uint weight) external;\\r\\n\\r\\n     /**\\r\\n     @dev Removes an asset from the bot's portfolio.\\r\\n     @param asset - the crypto asset to remove.\\r\\n     @notice asset could only be removed before the IBO. After that, asset could only be\\r\\n               remove if there is no tokens of this asset staked to the bot.\\r\\n      */\\r\\n     function removePortfolioAsset(address asset) external;\\r\\n\\r\\n     /**\\r\\n     @dev Creates vaults for each asset in the portfolio. This method should be called \\r\\n          internally by the bot manager.\\r\\n      */\\r\\n     function createPortfolioVaults() external;\\r\\n\\r\\n     /**\\r\\n     @dev Gets the vaults of certificate tokens in the portfolio.\\r\\n     @param certToken the certificate token.\\r\\n     @param account the account to query deposit/reward information\\r\\n      */\\r\\n     function certificateVaults(address certToken, address account) external view returns(VaultInfo[] memory);\\r\\n\\r\\n     /**\\r\\n     @dev Queries the total staking reward of the specific certificate token of the given account\\r\\n     @param certToken the certificate token.\\r\\n     @param account the account to query.\\r\\n      */\\r\\n     function stakingReward(address certToken, address account) external view returns(uint);\\r\\n\\r\\n     /**\\r\\n     @dev Claims all pending staking rewards of the callers.\\r\\n      */\\r\\n     function harvestStakingReward() external; \\r\\n\\r\\n     /**\\r\\n     @dev Moves certificate tokens staked in warm-up vault to regular vault.\\r\\n          If the tokens are locked, the operation will be reverted.\\r\\n      */\\r\\n     function upgradeVault(address certToken) external;\\r\\n\\r\\n     /**\\r\\n     @dev Gets the maximum amount of crypto asset that could be staked  to the bot.\\r\\n     @param asset - the crypto asset to check.\\r\\n     @return the maximum amount of crypto asset to stake.\\r\\n      */\\r\\n     function getMaxStake(address asset) external returns(uint);\\r\\n\\r\\n     /**\\r\\n     @dev Stakes an amount of crypto asset to the bot to receive staking certificate tokens.\\r\\n     @param asset - the asset to stake.\\r\\n     @param amount - the amount to stake.\\r\\n      */\\r\\n     function stake(address asset, uint amount) external;\\r\\n\\r\\n     /**\\r\\n     @dev Burns an amount of staking certificates to get back underlying asset.\\r\\n     @param certToken - the certificate to burn.\\r\\n     @param amount - the amount to burn.\\r\\n      */\\r\\n     function unstake(IDABotCertToken certToken, uint amount) external;\\r\\n\\r\\n     /**\\r\\n     @dev Gets the total staking balance of an account for the specific asset.\\r\\n          The balance includes pending stakes (i.e., warmup) and excludes \\r\\n          pending unstakes (i.e., cooldown)\\r\\n     @param account - the account to query.\\r\\n     @param asset - the crypto asset to query.\\r\\n     @return the total staked amount of the asset.\\r\\n      */\\r\\n     function stakeBalanceOf(address account, address asset) external view returns(uint);\\r\\n\\r\\n     /**\\r\\n     @dev Gets the total pending stake balance of an account for the specific asset.\\r\\n     @param account - the account to query.\\r\\n     @param asset - the asset to query.\\r\\n     @return the total pending stake.\\r\\n      */\\r\\n     function warmupBalanceOf(address account, address asset) external view returns(uint);\\r\\n\\r\\n     /**\\r\\n     @dev Gets to total pending unstake balance of an account for the specific certificate.\\r\\n     @param account - the account to query.\\r\\n     @param certToken - the certificate token to query.\\r\\n     @return the total pending unstake.\\r\\n      */\\r\\n     function cooldownBalanceOf(address account, address certToken) external view returns(uint);\\r\\n\\r\\n     /**\\r\\n     @dev Gets the certificate contract of an asset of a bot.\\r\\n     @param asset - to crypto asset to query.\\r\\n     @return the address of the certificate contract.\\r\\n      */\\r\\n     function certificateOf(address asset) external view returns(address);\\r\\n\\r\\n     /**\\r\\n     @dev Gets the underlying asset of a certificate.\\r\\n     @param certToken - the address of the certificate contract.\\r\\n     @return the address of the underlying crypto asset.\\r\\n      */\\r\\n     function assetOf(address certToken) external view returns(address);\\r\\n\\r\\n     /**\\r\\n     @dev Determines whether an account is a certificate locker.\\r\\n     @param account - the account to check.\\r\\n     @return true - if the account is an certificate locker instance creatd by the bot.\\r\\n      */\\r\\n     function isCertLocker(address account) external view returns(bool);\\r\\n\\r\\n     /**\\r\\n     @dev Gets the details of lockers for pending stake.\\r\\n     @param account - the account to query.\\r\\n     @return the array of LockerInfo struct.\\r\\n      */\\r\\n     function warmupDetails(address account) external view returns(LockerInfo[] memory);\\r\\n\\r\\n     /**\\r\\n     @dev Gets the details of lockers for pending unstake.\\r\\n     @param account - the account to query.\\r\\n     @return the array of LockerInfo struct.\\r\\n      */\\r\\n     function cooldownDetails(address account) external view returns(LockerInfo[] memory);\\r\\n\\r\\n     /**\\r\\n     @dev Releases tokens in all pending stake lockers. \\r\\n     @notice At most 20 lockers are unlocked. If the caller has more than 20, additional \\r\\n          transactions are required.\\r\\n      */\\r\\n     function releaseWarmups() external;\\r\\n\\r\\n     /**\\r\\n     @dev Releases token in all pending unstake lockers.\\r\\n     @notice At most 20 lockers are unlocked. If the caller has more than 20, additional \\r\\n          transactions are required.\\r\\n      */\\r\\n     function releaseCooldowns() external;\\r\\n\\r\\n     \\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/dabot/interfaces/IDABotWhitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nuint constant WHITELIST_CHECK_STAKE_USERS = 1;\\r\\nuint constant WHITELIST_CHECK_GOV_USERS = 2;\\r\\n\\r\\ninterface IDABotWhitelistModuleEvent {\\r\\n    event WhitelistScope(uint scope);\\r\\n    event WhitelistAdd(address indexed account, uint scope);\\r\\n    event WhitelistRemove(address indexed account);\\r\\n}\\r\\n\\r\\ninterface IDABotWhitelistModule is IDABotWhitelistModuleEvent {\\r\\n\\r\\n    function whitelistScope() external view returns(uint);\\r\\n    function setWhitelistScope(uint scope) external;\\r\\n    function addWhitelist(address account, uint scope) external;\\r\\n    function removeWhitelist(address account) external;\\r\\n    function isWhitelist(address acount, uint scope) external view returns(bool);\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/setting/DABotSettingLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\r\\nimport \\\"../../common/Errors.sol\\\";\\r\\nimport \\\"../../common/IConfigurator.sol\\\";\\r\\nimport \\\"../interfaces/IDABotSettingModule.sol\\\";\\r\\nimport \\\"../controller/DABotControllerLib.sol\\\";\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\n\\r\\nstruct SettingStorage { \\r\\n    mapping(bytes32 => address) addrStorage;\\r\\n    mapping(bytes32 => uint) uintStorage;\\r\\n    mapping(bytes32 => bytes) blobStorage;\\r\\n}\\r\\n\\r\\nlibrary DABotSettingLib {\\r\\n\\r\\n    using DABotSettingLib for BotSetting;\\r\\n    using DABotMetaLib for BotMetaData;\\r\\n\\r\\n    bytes32 constant CORE_STORAGE_POSITION = keccak256(\\\"core.dabot.storage\\\");\\r\\n    bytes32 constant SETTING_STORAGE_POSITION = keccak256(\\\"setting.dabot.storage\\\");\\r\\n\\r\\n    function coredata() internal pure returns(BotCoreData storage ds) {\\r\\n        bytes32 position = CORE_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setting() internal view returns(BotSetting storage) {\\r\\n        return coredata().setting;\\r\\n    }\\r\\n\\r\\n    function settingStorage() internal pure returns(SettingStorage storage ds) {\\r\\n        bytes32 position = SETTING_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function status(BotSetting storage _setting) internal view returns(BotStatus result) {\\r\\n        BotMetaData storage meta = DABotMetaLib.metadata();\\r\\n\\r\\n        if (meta.abandoned) return BotStatus.ABANDONED;\\r\\n        if (block.timestamp < _setting.iboStartTime()) return BotStatus.PRE_IBO;\\r\\n        if (block.timestamp < _setting.iboEndTime()) return BotStatus.IN_IBO;\\r\\n        return BotStatus.ACTIVE;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    @dev Ensures that following conditions are met\\r\\n        1) bot is not abandoned, and\\r\\n        2) either bot is pre-ibo stage and sender is bot owner, or the sender is vote controller module\\r\\n     */\\r\\n    function requireSettingChangable(address account) internal view {\\r\\n        BotMetaData storage _metadata = DABotMetaLib.metadata();\\r\\n        \\r\\n        require(!_metadata.abandoned, Errors.BSL_BOT_IS_ABANDONED);\\r\\n\\r\\n        if (_metadata.isTemplate) {\\r\\n            require(account == _metadata.botOwner, Errors.BSL_CALLER_IS_NOT_OWNER);\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        BotSetting storage _setting = DABotSettingLib.setting();\\r\\n        if (block.timestamp < _setting.iboStartTime()) {\\r\\n            require(account == _metadata.botOwner, Errors.BSL_CALLER_IS_NOT_OWNER);\\r\\n            return;\\r\\n        }\\r\\n        address executor = _metadata.configurator().addressOf(AddressBook.ADDR_GOVERNANCE_EXECUTOR);\\r\\n        require(account == executor, Errors.BSL_CALLER_IS_NOT_GOVERNANCE_EXECUTOR);\\r\\n    }\\r\\n\\r\\n    function readAddress(SettingStorage storage ds, bytes32 itemId, address defaultAddress) internal view returns(address result) {\\r\\n        result = ds.addrStorage[itemId]; \\r\\n        if (result == address(0)) { \\r\\n            BotMetaData storage _metadata = DABotMetaLib.metadata();\\r\\n             if (_metadata.botManager == address(0))\\r\\n                return result;\\r\\n            if (_metadata.botTemplate != address(0))\\r\\n                result = IDABotSettingModule(_metadata.botTemplate).readAddress(itemId, defaultAddress);\\r\\n            if (result == address(0))\\r\\n                result = _metadata.configurator().addressOf(itemId);\\r\\n            if (result == address(0))\\r\\n                result = defaultAddress;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function writeAddress(SettingStorage storage ds, bytes32 itemId, address value) internal {\\r\\n        ds.addrStorage[itemId] = value;\\r\\n    }\\r\\n\\r\\n    function readUint(SettingStorage storage ds, bytes32 itemId, uint defaultValue) internal view returns(uint result) {\\r\\n        result = ds.uintStorage[itemId];\\r\\n        if (result == 0) {\\r\\n            BotMetaData storage _metadata = DABotMetaLib.metadata();\\r\\n            if (_metadata.botManager == address(0))\\r\\n                return result;\\r\\n            if (_metadata.botTemplate != address(0))\\r\\n                result = IDABotSettingModule(_metadata.botTemplate).readUint(itemId, defaultValue);\\r\\n            if (result == 0)\\r\\n                result = _metadata.configurator().configOf(itemId);\\r\\n            if (result == 0)\\r\\n                result = defaultValue;\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    function writeUint(SettingStorage storage ds, bytes32 itemId, uint value) internal {\\r\\n        ds.uintStorage[itemId] = value;\\r\\n    }\\r\\n\\r\\n    function readBytes(SettingStorage storage ds, bytes32 itemId, bytes calldata defaultValue) internal view returns(bytes memory result) {\\r\\n        result = ds.blobStorage[itemId];\\r\\n        if (result.length == 0) {\\r\\n            BotMetaData storage _metadata = DABotMetaLib.metadata();\\r\\n            if (_metadata.botManager == address(0))\\r\\n                return result;\\r\\n            if (_metadata.botTemplate != address(0))\\r\\n                result = IDABotSettingModule(_metadata.botTemplate).readBytes(itemId, defaultValue);\\r\\n            if (result.length == 0)\\r\\n                result = _metadata.configurator().bytesConfigOf(itemId);\\r\\n            if (result.length == 0)\\r\\n                result = defaultValue;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function writeBytes(SettingStorage storage ds, bytes32 itemId, bytes calldata defaultValue) internal {\\r\\n        ds.blobStorage[itemId] = defaultValue;\\r\\n    }\\r\\n\\r\\n    function iboStartTime(BotSetting memory info) internal pure returns(uint) {\\r\\n        return info.iboTime & 0xFFFFFFFF;\\r\\n    }\\r\\n\\r\\n    function iboEndTime(BotSetting memory info) internal pure returns(uint) {\\r\\n        return info.iboTime >> 32;\\r\\n    }\\r\\n\\r\\n    function setIboTime(BotSetting storage info, uint start, uint end) internal {\\r\\n        require(start < end, Errors.BSL_IBO_ENDTIME_IS_SOONER_THAN_IBO_STARTTIME);\\r\\n        info.iboTime = uint64((end << 32) | start);\\r\\n    }\\r\\n\\r\\n    function warmupTime(BotSetting storage info) internal view returns(uint) {\\r\\n        return info.stakingTime & 0xFF;\\r\\n    }\\r\\n\\r\\n    function cooldownTime(BotSetting storage info) internal view returns(uint) {\\r\\n        return (info.stakingTime >> 8) & 0xFF;\\r\\n    }\\r\\n\\r\\n    function getStakingTimeMultiplier(BotSetting storage info) internal view returns (uint) {\\r\\n        uint unit = stakingTimeUnit(info);\\r\\n        if (unit == 0) return 1 days;\\r\\n        if (unit == 1) return 1 hours;\\r\\n        if (unit == 2) return 1 minutes;\\r\\n        return 1 seconds;\\r\\n    }\\r\\n\\r\\n    function stakingTimeUnit(BotSetting storage info) internal view returns (uint) {\\r\\n        return (info.stakingTime >> 16);\\r\\n    }\\r\\n\\r\\n    function setStakingTime(BotSetting storage info, uint warmup, uint cooldown, uint unit) internal {\\r\\n        info.stakingTime = uint24((unit << 16) | (cooldown << 8) | warmup);\\r\\n    }\\r\\n\\r\\n    function priceMultiplier(BotSetting storage info) internal view returns(uint) {\\r\\n        return info.pricePolicy & 0xFFFF;\\r\\n    }\\r\\n\\r\\n    function commission(BotSetting storage info) internal view returns(uint) {\\r\\n        return info.pricePolicy >> 16;\\r\\n    }\\r\\n\\r\\n    function setPricePolicy(BotSetting storage info, uint _priceMul, uint _commission) internal {\\r\\n        info.pricePolicy = uint32((_commission << 16) | _priceMul);\\r\\n    }\\r\\n\\r\\n    function profitShare(BotSetting storage info, uint actor) internal view returns(uint) {\\r\\n        return (info.profitSharing >> actor * 16) & 0xFFFF;\\r\\n    }\\r\\n\\r\\n    function setProfitShare(BotSetting storage info, uint sharingScheme) internal {\\r\\n        info.profitSharing = uint128(sharingScheme);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/dabot/staking/DABotStakingLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../../token/IRoboFiERC20.sol\\\";\\r\\nimport \\\"../../common/Errors.sol\\\";\\r\\nimport \\\"../interfaces/IDABotCertLocker.sol\\\";\\r\\nimport \\\"../interfaces/IDABotCertToken.sol\\\";\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\nimport \\\"../controller/DABotControllerLib.sol\\\";\\r\\n\\r\\n\\r\\nstruct BotStakingData {\\r\\n    IRoboFiERC20[]  assets; \\r\\n    mapping(IRoboFiERC20 => PortfolioAsset) portfolio;\\r\\n    mapping(address => IDABotCertLocker[]) warmup;\\r\\n    mapping(address => IDABotCertLocker[]) cooldown;\\r\\n    mapping(address => bool) lockers;\\r\\n}\\r\\n\\r\\nlibrary DABotStakingLib {\\r\\n    bytes32 constant STAKING_STORAGE_POSITION = keccak256(\\\"staking.dabot.storage\\\");\\r\\n\\r\\n    using DABotStakingLib for BotStakingData;\\r\\n    using DABotMetaLib for BotMetaData;\\r\\n\\r\\n    function staking() internal pure returns(BotStakingData storage ds) {\\r\\n        bytes32 position = STAKING_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function stakeBalanceOf(BotStakingData storage ds, address account, IRoboFiERC20 asset) internal view returns(uint) {\\r\\n        BotMetaData storage meta = DABotMetaLib.metadata();\\r\\n        IBotVaultManager vault = IDABotManager(meta.botManager).vaultManager();\\r\\n        IDABotCertToken certToken = ds.certificateOf(asset);\\r\\n        uint vID = vault.vaultId(address(certToken), 0);\\r\\n\\r\\n        return certToken.balanceOf(account)\\r\\n                // + ds.warmupBalanceOf(account, asset)\\r\\n                + vault.balanceOf(vID, account)\\r\\n                + vault.balanceOf(vID + 1, account)\\r\\n                + vault.balanceOf(vID + 2, account)\\r\\n                + ds.cooldownBalanceOf(account, ds.certificateOf(asset));\\r\\n    }\\r\\n\\r\\n    function totalStake(BotStakingData storage ds, IRoboFiERC20 asset) internal view returns(uint) {\\r\\n        return IDABotCertToken(ds.portfolio[asset].certToken).totalStake();\\r\\n    }\\r\\n\\r\\n    function warmupBalanceOf(BotStakingData storage ds, address account, IRoboFiERC20 asset) internal view returns(uint) {\\r\\n        IDABotCertLocker[] storage lockers = ds.warmup[account];\\r\\n        return lockedBalance(lockers, address(asset));\\r\\n    }\\r\\n\\r\\n    function cooldownBalanceOf(BotStakingData storage ds, address account, IDABotCertToken certToken) internal view returns(uint) {\\r\\n        IDABotCertLocker[] storage lockers = ds.cooldown[account];\\r\\n        return lockedBalance(lockers, address(certToken.asset()));\\r\\n    }\\r\\n    \\r\\n    function certificateOf(BotStakingData storage ds, IRoboFiERC20 asset) internal view returns(IDABotCertToken) {\\r\\n        return IDABotCertToken(ds.portfolio[asset].certToken); \\r\\n    }\\r\\n\\r\\n    function assetOf(address certToken) public view returns(IERC20) {\\r\\n        return IDABotCertToken(certToken).asset(); \\r\\n    }\\r\\n\\r\\n    function lockedBalance(IDABotCertLocker[] storage lockers, address asset) internal view returns(uint result) {\\r\\n        result = 0;\\r\\n        for (uint i = 0; i < lockers.length; i++) \\r\\n            if (address(lockers[i].asset()) == asset)\\r\\n                result += lockers[i].lockedBalance();\\r\\n    }\\r\\n\\r\\n    function portfolioDetails(BotStakingData storage ds) internal view returns(UserPortfolioAsset[] memory output) {\\r\\n        output = new UserPortfolioAsset[](ds.assets.length);\\r\\n        for(uint i = 0; i < ds.assets.length; i++) {\\r\\n            IRoboFiERC20 asset = ds.assets[i];\\r\\n            output[i].asset = address(asset);\\r\\n            output[i].info = ds.portfolio[asset];\\r\\n            output[i].userStake = ds.stakeBalanceOf(msg.sender, asset);\\r\\n            output[i].totalStake = ds.totalStake(asset);\\r\\n            output[i].certSupply = IERC20(ds.portfolio[asset].certToken).totalSupply();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function portfolioOf(BotStakingData storage ds, IRoboFiERC20 asset) internal view returns(UserPortfolioAsset memory  output) {\\r\\n        output.asset = address(asset);\\r\\n        output.info = ds.portfolio[asset];\\r\\n        output.userStake = ds.stakeBalanceOf(msg.sender, asset);\\r\\n        output.totalStake = ds.totalStake(asset);\\r\\n        output.certSupply = IERC20(ds.portfolio[asset].certToken).totalSupply();\\r\\n    }\\r\\n\\r\\n    function updatePortfolioAsset(BotStakingData storage ds, IRoboFiERC20 asset, uint maxCap, uint iboCap, uint weight) internal {\\r\\n        PortfolioAsset storage pAsset = ds.portfolio[asset];\\r\\n\\r\\n        if (address(pAsset.certToken) == address(0)) {\\r\\n            pAsset.certToken = DABotMetaLib.metadata().deployCertToken(address(asset));\\r\\n            ds.assets.push(asset);\\r\\n        }\\r\\n\\r\\n        if (maxCap > 0) pAsset.cap = maxCap;\\r\\n        if (iboCap > 0) pAsset.iboCap = iboCap;\\r\\n        if (weight > 0) pAsset.weight = weight;\\r\\n\\r\\n        uint _totalStake = IDABotCertToken(pAsset.certToken).totalStake();\\r\\n\\r\\n        require((pAsset.cap >= _totalStake) && (pAsset.cap >= pAsset.iboCap), Errors.BSTMOD_INVALID_STAKING_CAP);\\r\\n    }\\r\\n\\r\\n    function removePortfolioAsset(BotStakingData storage ds, IRoboFiERC20 asset) internal returns(address) {\\r\\n        require(address(asset) != address(0), Errors.BSTMOD_ASSET_IS_ZERO);\\r\\n        for(uint i = 0; i < ds.assets.length; i++)\\r\\n            if (address(ds.assets[i]) == address(asset)) {\\r\\n                address certToken = ds.portfolio[asset].certToken;\\r\\n                IDABotCertToken(certToken).finalize(); \\r\\n                delete ds.portfolio[asset];\\r\\n                ds.assets[i] = ds.assets[ds.assets.length - 1];\\r\\n                ds.assets.pop();\\r\\n                return certToken;\\r\\n            }\\r\\n        revert(Errors.BSTMOD_PORTFOLIO_ASSET_NOT_FOUND);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/dabot/templates/DABot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\r\\nimport \\\"../controller/DABotController.sol\\\";\\r\\nimport \\\"../interfaces/IDABotSettingModule.sol\\\";\\r\\nimport \\\"../interfaces/IDABotStakingModule.sol\\\";\\r\\nimport \\\"../interfaces/IDABotGovernModule.sol\\\";\\r\\nimport \\\"../interfaces/IDABotFundManagerModule.sol\\\";\\r\\nimport \\\"../interfaces/IDABotFarmingModule.sol\\\";\\r\\nimport \\\"../interfaces/IDABotWhitelist.sol\\\";\\r\\nimport \\\"../interfaces/IDABot.sol\\\";\\r\\nimport \\\"../DABotCommon.sol\\\";\\r\\nimport \\\"../fundmanager/DABotFundManagerLib.sol\\\";\\r\\n\\r\\ncontract DABot is DABotModuleController, IERC165 {\\r\\n\\r\\n    using DABotFundManagerLib for FundManagementData;\\r\\n\\r\\n    constructor(\\r\\n        uint8 templateType,\\r\\n        string memory templateName,\\r\\n        string memory version,\\r\\n        bytes32[] memory handlerIds,\\r\\n        address[] memory handlerImpls,\\r\\n        address[] memory funcModules,\\r\\n        address[] memory beneficiaries\\r\\n    ) DABotModuleController(templateType, templateName, version)\\r\\n    {\\r\\n        for(uint i = 0; i < handlerIds.length; i++)\\r\\n            updateModuleHandler(handlerIds[i], handlerImpls[i]);\\r\\n        for(uint i = 0; i < funcModules.length; i++)\\r\\n            registerModule(funcModules[i]);\\r\\n        FundManagementData storage fundData = DABotFundManagerLib.fundData();\\r\\n        for(uint i = 0; i < beneficiaries.length; i++)\\r\\n            fundData.addBenefitciary(beneficiaries[i]);\\r\\n    }\\r\\n\\r\\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\\r\\n        return (interfaceId == type(IERC165).interfaceId) ||\\r\\n                (interfaceId == type(IDABot).interfaceId)\\r\\n        ;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/token/IRoboFiERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface IRoboFiERC20 is IERC20 {\\r\\n    function symbol() external view returns (string memory);\\r\\n    function name() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"templateType\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"templateName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"bytes32[]\",\"name\":\"handlerIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"handlerImpls\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"funcModules\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"beneficiaries\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"BotAbandoned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldModuleAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newModuleAddress\",\"type\":\"address\"}],\"name\":\"ModuleHandlerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"moduleAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"}],\"name\":\"ModuleRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"abandon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"botDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"botAddress\",\"type\":\"address\"},{\"internalType\":\"enum BotStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"botType\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"botSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"botName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"governToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"template\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"templateName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"templateVersion\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"iboStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iboEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"warmup\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldown\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceMul\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commissionFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initFounderShare\",\"type\":\"uint256\"},{\"internalType\":\"uint144\",\"name\":\"profitSharing\",\"type\":\"uint144\"},{\"internalType\":\"uint256\",\"name\":\"maxShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"circulatedShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iboShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userShare\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"certToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iboCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"internalType\":\"struct PortfolioAsset\",\"name\":\"info\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"userStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"certSupply\",\"type\":\"uint256\"}],\"internalType\":\"struct UserPortfolioAsset[]\",\"name\":\"portfolio\",\"type\":\"tuple[]\"}],\"internalType\":\"struct BotDetail\",\"name\":\"output\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governToken\",\"outputs\":[{\"internalType\":\"contract IDABotGovernToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadata\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"botType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"abandoned\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isTemplate\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"botOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"botManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"botTemplate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gToken\",\"type\":\"address\"}],\"internalType\":\"struct BotMetaData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"}],\"name\":\"module\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"ids\",\"type\":\"bytes32[]\"}],\"name\":\"moduleHandlerInfo\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"result\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"moduleOfSelector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"modulesInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"handler\",\"type\":\"address\"}],\"internalType\":\"struct BotModuleInfo[]\",\"name\":\"result\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"qualifiedName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"moduleHandler\",\"type\":\"address\"}],\"name\":\"registerModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"rescueToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setting\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"iboTime\",\"type\":\"uint64\"},{\"internalType\":\"uint24\",\"name\":\"stakingTime\",\"type\":\"uint24\"},{\"internalType\":\"uint32\",\"name\":\"pricePolicy\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"profitSharing\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"initDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initFounderShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iboShare\",\"type\":\"uint256\"}],\"internalType\":\"struct BotSetting\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"moduleId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"newModuleAddress\",\"type\":\"address\"}],\"name\":\"updateModuleHandler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DABot", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000022000000000000000000000000000000000000000000000000000000000000002e000000000000000000000000000000000000000000000000000000000000003a0000000000000000000000000000000000000000000000000000000000000001255706772616461626c654345584441426f740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d76302e312e32303232303430330000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052ab5110d90958dd3ab0dba197adbbc84a073494bd404bca449a531615422b4133478c29090d8d2e9285bb655fe4137dfbb22c0a1db0d9049d241539f203b6b4c4353b8779c1d6cd78be90dc24e5ae76d73ea316c079cf7b304af971ba426e206d8ddfaadc7a73f6819ebc2bc5936ae402cadc61c7c84233ab9e52a8f33cd38c5957b15edc429018dab7e7ed05621a7f39b9e83678d95889cee4dc10280c8aa4800000000000000000000000000000000000000000000000000000000000000050000000000000000000000004cb25d7d5a2b522f12993521fe923eb00ba4200f000000000000000000000000a53d99cfc125d98f1591323ebea81338c3c705f5000000000000000000000000100ea439744de39bd89add94c45223cfdfd8ea130000000000000000000000000f30ee1ae8c882268fa0aff64f999e8922f30a80000000000000000000000000a04d193415852b7bc6c9de4af73e28d0229147f70000000000000000000000000000000000000000000000000000000000000005000000000000000000000000e93ff8efbd8ba49caf7c0ef761dca36c43ec158c000000000000000000000000c381b962bc845ac91e4901fa4e4f801f5b4440110000000000000000000000001ba72489dc141520a552be6e6e44991347800cc100000000000000000000000027c08e55ae866ec8a9ff4d9f02932fcbb40febb5000000000000000000000000e09ce178fcb0243615da6346b6a0e7bf8b2b80a90000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}