{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@sense-finance/v1-core/src/adapters/implementations/oracles/ChainlinkPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.11;\\n\\nimport { Trust } from \\\"@sense-finance/v1-utils/src/Trust.sol\\\";\\nimport { Errors } from \\\"@sense-finance/v1-utils/src/libs/Errors.sol\\\";\\nimport { IPriceFeed } from \\\"../../abstract/IPriceFeed.sol\\\";\\nimport { FixedMath } from \\\"../../../external/FixedMath.sol\\\";\\n\\ninterface FeedRegistryLike {\\n    function latestRoundData(address base, address quote)\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n\\n    function decimals(address base, address quote) external view returns (uint8);\\n}\\n\\n/// @title ChainlinkPriceOracle\\n/// @notice Returns prices from Chainlink.\\n/// @dev Implements `IPricefeed` and `Trust`.\\n/// @author Inspired by: https://github.com/Rari-Capital/fuse-v1/blob/development/src/oracles/ChainlinkPriceOracleV3.sol\\ncontract ChainlinkPriceOracle is IPriceFeed, Trust {\\n    using FixedMath for uint256;\\n\\n    // Chainlink's denominations\\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n    address public constant BTC = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\\n    address public constant USD = address(840);\\n\\n    // The maxmimum number of seconds elapsed since the round was last updated before the price is considered stale. If set to 0, no limit is enforced.\\n    uint256 public maxSecondsBeforePriceIsStale;\\n\\n    FeedRegistryLike public feedRegistry = FeedRegistryLike(0x47Fb2585D2C56Fe188D0E6ec628a38b74fCeeeDf); // Chainlink feed registry contract\\n\\n    constructor(uint256 _maxSecondsBeforePriceIsStale) public Trust(msg.sender) {\\n        maxSecondsBeforePriceIsStale = _maxSecondsBeforePriceIsStale;\\n    }\\n\\n    /// @dev Internal function returning the price in ETH of `underlying`.\\n    function _price(address underlying) internal view returns (uint256) {\\n        // Return 1e18 for WETH\\n        if (underlying == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) return 1e18;\\n\\n        // Try token/ETH to get token/ETH\\n        try feedRegistry.latestRoundData(underlying, ETH) returns (\\n            uint80,\\n            int256 tokenEthPrice,\\n            uint256,\\n            uint256 updatedAt,\\n            uint80\\n        ) {\\n            if (tokenEthPrice <= 0) return 0;\\n            _validatePrice(updatedAt);\\n            return uint256(tokenEthPrice).fmul(1e18).fdiv(10**uint256(feedRegistry.decimals(underlying, ETH)));\\n        } catch Error(string memory reason) {\\n            if (keccak256(abi.encodePacked(reason)) != keccak256(abi.encodePacked(\\\"Feed not found\\\")))\\n                revert Errors.AttemptFailed();\\n        }\\n\\n        // Try token/USD to get token/ETH\\n        try feedRegistry.latestRoundData(underlying, USD) returns (\\n            uint80,\\n            int256 tokenUsdPrice,\\n            uint256,\\n            uint256 updatedAt,\\n            uint80\\n        ) {\\n            if (tokenUsdPrice <= 0) return 0;\\n            _validatePrice(updatedAt);\\n\\n            int256 ethUsdPrice;\\n            (, ethUsdPrice, , updatedAt, ) = feedRegistry.latestRoundData(ETH, USD);\\n            if (ethUsdPrice <= 0) return 0;\\n            _validatePrice(updatedAt);\\n            return\\n                uint256(tokenUsdPrice).fmul(1e26).fdiv(10**uint256(feedRegistry.decimals(underlying, USD))).fdiv(\\n                    uint256(ethUsdPrice)\\n                );\\n        } catch Error(string memory reason) {\\n            if (keccak256(abi.encodePacked(reason)) != keccak256(abi.encodePacked(\\\"Feed not found\\\")))\\n                revert Errors.AttemptFailed();\\n        }\\n\\n        // Try token/BTC to get token/ETH\\n        try feedRegistry.latestRoundData(underlying, BTC) returns (\\n            uint80,\\n            int256 tokenBtcPrice,\\n            uint256,\\n            uint256 updatedAt,\\n            uint80\\n        ) {\\n            if (tokenBtcPrice <= 0) return 0;\\n            _validatePrice(updatedAt);\\n\\n            int256 btcEthPrice;\\n            (, btcEthPrice, , updatedAt, ) = feedRegistry.latestRoundData(BTC, ETH);\\n            if (btcEthPrice <= 0) return 0;\\n            _validatePrice(updatedAt);\\n\\n            return\\n                uint256(tokenBtcPrice).fmul(uint256(btcEthPrice)).fdiv(\\n                    10**uint256(feedRegistry.decimals(underlying, BTC))\\n                );\\n        } catch Error(string memory reason) {\\n            if (keccak256(abi.encodePacked(reason)) != keccak256(abi.encodePacked(\\\"Feed not found\\\")))\\n                revert Errors.AttemptFailed();\\n        }\\n\\n        // Revert if all else fails\\n        revert Errors.PriceOracleNotFound();\\n    }\\n\\n    /// @dev validates the price returned from Chainlink\\n    function _validatePrice(uint256 _updatedAt) internal view {\\n        if (maxSecondsBeforePriceIsStale > 0 && block.timestamp <= _updatedAt + maxSecondsBeforePriceIsStale)\\n            revert Errors.InvalidPrice();\\n    }\\n\\n    /// @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\\n    function price(address underlying) external view override returns (uint256) {\\n        return _price(underlying);\\n    }\\n\\n    /// @dev Sets the `maxSecondsBeforePriceIsStale`.\\n    function setMaxSecondsBeforePriceIsStale(uint256 _maxSecondsBeforePriceIsStale) public requiresTrust {\\n        maxSecondsBeforePriceIsStale = _maxSecondsBeforePriceIsStale;\\n        emit MaxSecondsBeforePriceIsStaleChanged(maxSecondsBeforePriceIsStale);\\n    }\\n\\n    /* ========== LOGS ========== */\\n    event MaxSecondsBeforePriceIsStaleChanged(uint256 indexed maxSecondsBeforePriceIsStale);\\n}\\n\"\r\n    },\r\n    \"@sense-finance/v1-utils/src/Trust.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.7.0;\\n\\n/// @notice Ultra minimal authorization logic for smart contracts.\\n/// @author From https://github.com/Rari-Capital/solmate/blob/fab107565a51674f3a3b5bfdaacc67f6179b1a9b/src/auth/Trust.sol\\nabstract contract Trust {\\n    event UserTrustUpdated(address indexed user, bool trusted);\\n\\n    mapping(address => bool) public isTrusted;\\n\\n    constructor(address initialUser) {\\n        isTrusted[initialUser] = true;\\n\\n        emit UserTrustUpdated(initialUser, true);\\n    }\\n\\n    function setIsTrusted(address user, bool trusted) public virtual requiresTrust {\\n        isTrusted[user] = trusted;\\n\\n        emit UserTrustUpdated(user, trusted);\\n    }\\n\\n    modifier requiresTrust() {\\n        require(isTrusted[msg.sender], \\\"UNTRUSTED\\\");\\n\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@sense-finance/v1-utils/src/libs/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.4;\\n\\nlibrary Errors {\\n    // Auth\\n    error CombineRestricted();\\n    error IssuanceRestricted();\\n    error NotAuthorized();\\n    error OnlyYT();\\n    error OnlyDivider();\\n    error OnlyPeriphery();\\n    error OnlyPermissionless();\\n    error RedeemRestricted();\\n    error Untrusted();\\n\\n    // Adapters\\n    error TokenNotSupported();\\n    error FlashCallbackFailed();\\n    error SenderNotEligible();\\n    error TargetMismatch();\\n    error TargetNotSupported();\\n    error InvalidAdapterType();\\n    error PriceOracleNotFound();\\n\\n    // Divider\\n    error AlreadySettled();\\n    error CollectNotSettled();\\n    error GuardCapReached();\\n    error IssuanceFeeCapExceeded();\\n    error IssueOnSettle();\\n    error NotSettled();\\n\\n    // Input & validations\\n    error AlreadyInitialized();\\n    error DuplicateSeries();\\n    error ExistingValue();\\n    error InvalidAdapter();\\n    error InvalidMaturity();\\n    error InvalidParam();\\n    error NotImplemented();\\n    error OutOfWindowBoundaries();\\n    error SeriesDoesNotExist();\\n    error SwapTooSmall();\\n    error TargetParamsNotSet();\\n    error PoolParamsNotSet();\\n    error PTParamsNotSet();\\n    error AttemptFailed();\\n    error InvalidPrice();\\n    error BadContractInteration();\\n\\n    // Periphery\\n    error FactoryNotSupported();\\n    error FlashBorrowFailed();\\n    error FlashUntrustedBorrower();\\n    error FlashUntrustedLoanInitiator();\\n    error UnexpectedSwapAmount();\\n    error TooMuchLeftoverTarget();\\n\\n    // Fuse\\n    error AdapterNotSet();\\n    error FailedBecomeAdmin();\\n    error FailedAddTargetMarket();\\n    error FailedToAddPTMarket();\\n    error FailedAddLpMarket();\\n    error OracleNotReady();\\n    error PoolAlreadyDeployed();\\n    error PoolNotDeployed();\\n    error PoolNotSet();\\n    error SeriesNotQueued();\\n    error TargetExists();\\n    error TargetNotInFuse();\\n\\n    // Tokens\\n    error MintFailed();\\n    error RedeemFailed();\\n    error TransferFailed();\\n}\\n\"\r\n    },\r\n    \"@sense-finance/v1-core/src/adapters/abstract/IPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.11;\\n\\n/// @title IPriceFeed\\n/// @notice Returns prices of underlying tokens\\n/// @author Taken from: https://github.com/Rari-Capital/fuse-v1/blob/development/src/oracles/BasePriceOracle.sol\\ninterface IPriceFeed {\\n    /// @notice Get the price of an underlying asset.\\n    /// @param underlying The underlying asset to get the price of.\\n    /// @return price The underlying asset price in ETH as a mantissa (scaled by 1e18).\\n    /// Zero means the price is unavailable.\\n    function price(address underlying) external view returns (uint256 price);\\n}\\n\"\r\n    },\r\n    \"@sense-finance/v1-core/src/external/FixedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.11;\\n\\n/// @title Fixed point arithmetic library\\n/// @author Taken from https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol\\nlibrary FixedMath {\\n    uint256 internal constant WAD = 1e18;\\n    uint256 internal constant RAY = 1e27;\\n\\n    function fmul(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256) {\\n        return mulDivDown(x, y, baseUnit); // Equivalent to (x * y) / baseUnit rounded down.\\n    }\\n\\n    function fmul(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function fmulUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256) {\\n        return mulDivUp(x, y, baseUnit); // Equivalent to (x * y) / baseUnit rounded up.\\n    }\\n\\n    function fmulUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function fdiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256) {\\n        return mulDivDown(x, baseUnit, y); // Equivalent to (x * baseUnit) / y rounded down.\\n    }\\n\\n    function fdiv(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function fdivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256) {\\n        return mulDivUp(x, baseUnit, y); // Equivalent to (x * baseUnit) / y rounded up.\\n    }\\n\\n    function fdivUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 15000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSecondsBeforePriceIsStale\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AttemptFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PriceOracleNotFound\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maxSecondsBeforePriceIsStale\",\"type\":\"uint256\"}],\"name\":\"MaxSecondsBeforePriceIsStaleChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"trusted\",\"type\":\"bool\"}],\"name\":\"UserTrustUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BTC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feedRegistry\",\"outputs\":[{\"internalType\":\"contract FeedRegistryLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTrusted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSecondsBeforePriceIsStale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"}],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"trusted\",\"type\":\"bool\"}],\"name\":\"setIsTrusted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSecondsBeforePriceIsStale\",\"type\":\"uint256\"}],\"name\":\"setMaxSecondsBeforePriceIsStale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ChainlinkPriceOracle", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "15000", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000003f480", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}