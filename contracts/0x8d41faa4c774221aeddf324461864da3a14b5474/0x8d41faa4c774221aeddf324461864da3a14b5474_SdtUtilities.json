{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(\\n    uint80 _roundId\\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAggregationRouterV5.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface IAggregationExecutor {\\r\\n    function execute(address msgSender) external payable;\\r\\n}\\r\\n\\r\\ninterface IAggregationRouterV5 {\\r\\n    /// @dev swap data for 1inch when claiming rewards to perform a swap\\r\\n    struct SwapDescription {\\r\\n        IERC20 srcToken;\\r\\n        IERC20 dstToken;\\r\\n        address payable srcReceiver;\\r\\n        address payable dstReceiver;\\r\\n        uint256 amount;\\r\\n        uint256 minReturnAmount;\\r\\n        uint256 flags;\\r\\n    }\\r\\n\\r\\n    /// @dev swap transaction data\\r\\n    struct SwapTransaction {\\r\\n        IAggregationExecutor executor;\\r\\n        SwapDescription description;\\r\\n        bytes permit;\\r\\n        bytes data;\\r\\n    }\\r\\n\\r\\n    function swap(\\r\\n        IAggregationExecutor caller,\\r\\n        SwapDescription calldata desc,\\r\\n        bytes calldata permit,\\r\\n        bytes calldata data\\r\\n    ) external payable returns (uint256 returnAmount, uint256 spentAmount);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IBondCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IBondStruct.sol\\\";\\r\\n\\r\\ninterface IBondCalculator {\\r\\n    function computeRoi(\\r\\n        uint256 durationFromStart,\\r\\n        uint256 totalDuration,\\r\\n        IBondStruct.BondFunction composedFunction,\\r\\n        uint256 totalTokenOut,\\r\\n        uint256 amountTokenSold,\\r\\n        uint256 gamma,\\r\\n        uint256 scale,\\r\\n        uint256 minRoi,\\r\\n        uint256 maxRoi\\r\\n    ) external pure returns (uint256 bondRoi);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IBondDepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./ICvgControlTower.sol\\\";\\r\\nimport \\\"./IBondStruct.sol\\\";\\r\\nimport \\\"./ICvgOracle.sol\\\";\\r\\n\\r\\ninterface IBondDepository {\\r\\n    // Deposit Principle token in Treasury through Bond contract\\r\\n    function deposit(uint256 tokenId, uint256 amount, address receiver) external;\\r\\n\\r\\n    function depositToLock(uint256 amount, address receiver) external returns (uint256 cvgToMint);\\r\\n\\r\\n    function positionInfos(uint256 tokenId) external view returns (IBondStruct.BondPending memory);\\r\\n\\r\\n    function getTokenVestingInfo(uint256 tokenId) external view returns (IBondStruct.TokenVestingInfo memory);\\r\\n\\r\\n    function bondParams() external view returns (IBondStruct.BondParams memory);\\r\\n\\r\\n    function pendingPayoutFor(uint256 tokenId) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IBondLogo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface IBondLogo {\\r\\n    struct LogoInfos {\\r\\n        uint256 tokenId;\\r\\n        uint256 termTimestamp;\\r\\n        uint256 pending;\\r\\n        uint256 cvgClaimable;\\r\\n        uint256 unlockingTimestamp;\\r\\n    }\\r\\n    struct LogoInfosFull {\\r\\n        uint256 tokenId;\\r\\n        uint256 termTimestamp;\\r\\n        uint256 pending;\\r\\n        uint256 cvgClaimable;\\r\\n        uint256 unlockingTimestamp;\\r\\n        uint256 year;\\r\\n        uint256 month;\\r\\n        uint256 day;\\r\\n        bool isLocked;\\r\\n        uint256 hoursLock;\\r\\n        uint256 cvgPrice;\\r\\n    }\\r\\n\\r\\n    function _tokenURI(LogoInfos memory logoInfos) external pure returns (string memory output);\\r\\n\\r\\n    \\r\\n    function getLogoInfo(uint256 tokenId) external view returns (IBondLogo.LogoInfosFull memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IBondPositionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IBondStruct.sol\\\";\\r\\nimport \\\"./IBondLogo.sol\\\";\\r\\nimport \\\"./IBondDepository.sol\\\";\\r\\n\\r\\ninterface IBondPositionManager {\\r\\n    function bondDepository() external view returns (IBondDepository);\\r\\n\\r\\n    function getTokenIdsForWallet(address _wallet) external view returns (uint256[] memory);\\r\\n\\r\\n    function bondPerTokenId(uint256 tokenId) external view returns (uint256);\\r\\n\\r\\n    // Deposit Principle token in Treasury through Bond contract\\r\\n    function mintOrCheck(uint256 bondId, uint256 tokenId, address receiver) external returns (uint256);\\r\\n\\r\\n    function burn(uint256 tokenId) external;\\r\\n\\r\\n    function unlockingTimestampPerToken(uint256 tokenId) external view returns (uint256);\\r\\n\\r\\n    function logoInfo(uint256 tokenId) external view returns (IBondLogo.LogoInfos memory);\\r\\n\\r\\n    function checkTokenRedeem(uint256[] calldata tokenIds, address receiver) external view;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IBondStruct.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IBondStruct {\\r\\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\\r\\n                        STORED STRUCTS\\r\\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\\r\\n    struct BondParams {\\r\\n        /**\\r\\n         * @dev Type of function used to compute the actual ROI of a bond.\\r\\n         *      - 0 is SquareRoot\\r\\n         *      - 1 is Ln\\r\\n         *      - 2 is Square\\r\\n         *      - 3 is Linear\\r\\n         */\\r\\n        BondFunction composedFunction;\\r\\n        /// @dev Address of the underlaying token of the bond.\\r\\n        address token;\\r\\n        /**\\r\\n         * @dev Gamma is used in the BondCalculator.It's the value dividing the ratio between the amount already sold and the theorical amount sold.\\r\\n         *      250_000 correspond to 0.25 (25%).\\r\\n         */\\r\\n        uint40 gamma;\\r\\n        /// @dev Total duration of the bond, uint40 is enough for a timestamp.\\r\\n        uint40 bondDuration;\\r\\n        /// @dev Determine if a Bond is paused. Can't deposit on a bond paused.\\r\\n        bool isPaused;\\r\\n        /**\\r\\n         * @dev Scale is used in the BondCalculator. When a scale is A, the ROI vary by incremental of A.\\r\\n         *      If scale is 5_000 correspond to 0.5%, the ROI will vary from the maxROI to minROI by increment of 0.5%.\\r\\n         */\\r\\n        uint32 scale;\\r\\n        /**\\r\\n         * @dev Minimum ROI of the bond. Discount cannot be less than the minROI.\\r\\n         *      If minRoi is 100_000, it represents 10%.\\r\\n         */\\r\\n\\r\\n        uint24 minRoi;\\r\\n        /**\\r\\n         * @dev Maximum ROI of the bond. Discount cannot be more than the maxROI.\\r\\n         *      If maxRoi is 150_000, it represents 15%.\\r\\n         */\\r\\n        uint24 maxRoi;\\r\\n        /**\\r\\n         * @dev Percentage maximum of the cvgToSell that an user can buy in one deposit\\r\\n         *      If percentageOneTx is 200, it represents 20% of cvgToSell.\\r\\n         */\\r\\n        uint24 percentageOneTx;\\r\\n        /// @dev Duration of the vesting in second.\\r\\n        uint32 vestingTerm;\\r\\n        /**\\r\\n         * @dev Maximum amount that can be bought through this bond.\\r\\n         *      uint80 represents 1.2M tokens in ethers. It means that we are never going to open a bond with more than 1.2M tokens.\\r\\n         */\\r\\n        uint80 cvgToSell; // Limit of Max CVG to sell => 1.2M CVG max approx\\r\\n        /// @dev Timestamp in second of the beginning of the bond. Has to be in the future.\\r\\n        uint40 startBondTimestamp;\\r\\n    }\\r\\n    struct BondPending {\\r\\n        /// @dev Timestamp in second of the last interaction with this position.\\r\\n        uint64 lastTimestamp;\\r\\n        /// @dev Time in seconds lefting before the position is fully unvested\\r\\n        uint64 vestingTimeLeft;\\r\\n        /**\\r\\n         * @dev Total amount of CVG still vested in the position.\\r\\n         *      uint128 is way enough because it's an amount in CVG that have a max supply of 150M tokens.\\r\\n         */\\r\\n        uint128 leftClaimable;\\r\\n    }\\r\\n\\r\\n    enum BondFunction {\\r\\n        SQRT,\\r\\n        LN,\\r\\n        POWER_2,\\r\\n        LINEAR\\r\\n    }\\r\\n\\r\\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\\r\\n                        VIEW STRUCTS\\r\\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\\r\\n    struct BondTokenView {\\r\\n        uint128 lastTimestamp;\\r\\n        uint128 vestingEnd;\\r\\n        uint256 claimableCvg;\\r\\n        uint256 leftClaimable;\\r\\n    }\\r\\n\\r\\n    struct BondView {\\r\\n        uint256 actualRoi;\\r\\n        uint256 cvgAlreadySold;\\r\\n        uint256 usdExecutionPrice;\\r\\n        uint256 usdLimitPrice;\\r\\n        uint256 assetBondPrice;\\r\\n        uint256 usdBondPrice;\\r\\n        bool isOracleValid;\\r\\n        BondParams bondParameters;\\r\\n        ERC20View token;\\r\\n    }\\r\\n    struct ERC20View {\\r\\n        string token;\\r\\n        address tokenAddress;\\r\\n        uint256 decimals;\\r\\n    }\\r\\n    struct TokenVestingInfo {\\r\\n        uint256 term;\\r\\n        uint256 claimable;\\r\\n        uint256 pending;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ICommonStruct.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface ICommonStruct {\\r\\n    struct TokenAmount {\\r\\n        IERC20 token;\\r\\n        uint256 amount;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ICrvPoolPlain.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\\\";\\r\\n\\r\\ninterface ICrvPoolPlain is IERC20Metadata {\\r\\n    function calc_token_amount(uint256[2] memory amounts) external view returns (uint256);\\r\\n\\r\\n    function get_virtual_price() external view returns (uint256);\\r\\n\\r\\n    function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount) external;\\r\\n\\r\\n    function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount, address receiver) external;\\r\\n\\r\\n    function exchange(\\r\\n        int128 i, //index tokenIn\\r\\n        int128 j, //index tokenOut\\r\\n        uint256 dx, //amountIn\\r\\n        uint256 min_dy, //amountOut\\r\\n        address receiver\\r\\n    ) external;\\r\\n\\r\\n    function get_dy(\\r\\n        int128 i, //index tokenIn\\r\\n        int128 j, //index tokenOut\\r\\n        uint256 dx //amountIn\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function coins(uint256 i) external view returns (address);\\r\\n\\r\\n    function last_price() external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ICvg.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\\\";\\r\\n\\r\\ninterface ICvg is IERC20Metadata {\\r\\n    function MAX_AIRDROP() external view returns (uint256);\\r\\n\\r\\n    function MAX_BOND() external view returns (uint256);\\r\\n\\r\\n    function MAX_STAKING() external view returns (uint256);\\r\\n\\r\\n    function MAX_VESTING() external view returns (uint256);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function burn(uint256 amount) external;\\r\\n\\r\\n    function cvgControlTower() external view returns (address);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\r\\n\\r\\n    function mintBond(address account, uint256 amount) external;\\r\\n\\r\\n    function mintStaking(address account, uint256 amount) external;\\r\\n\\r\\n    function mintedBond() external view returns (uint256);\\r\\n\\r\\n    function mintedStaking() external view returns (uint256);\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ICvgControlTower.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\r\\n\\r\\nimport \\\"./IERC20Mintable.sol\\\";\\r\\nimport \\\"./ICvg.sol\\\";\\r\\nimport \\\"./IBondDepository.sol\\\";\\r\\nimport \\\"./IBondCalculator.sol\\\";\\r\\nimport \\\"./IBondStruct.sol\\\";\\r\\nimport \\\"./ICvgOracle.sol\\\";\\r\\nimport \\\"./IVotingPowerEscrow.sol\\\";\\r\\nimport \\\"./ICvgRewards.sol\\\";\\r\\nimport \\\"./ILockingPositionManager.sol\\\";\\r\\nimport \\\"./ILockingPositionDelegate.sol\\\";\\r\\nimport \\\"./IGaugeController.sol\\\";\\r\\nimport \\\"./IYsDistributor.sol\\\";\\r\\nimport \\\"./IBondPositionManager.sol\\\";\\r\\nimport \\\"./ISdtStakingPositionManager.sol\\\";\\r\\nimport \\\"./IBondLogo.sol\\\";\\r\\nimport \\\"./ILockingLogo.sol\\\";\\r\\nimport \\\"./ILockingPositionService.sol\\\";\\r\\nimport \\\"./IVestingCvg.sol\\\";\\r\\nimport \\\"./ISdtBuffer.sol\\\";\\r\\nimport \\\"./ISdtBlackHole.sol\\\";\\r\\nimport \\\"./ISdtStakingPositionService.sol\\\";\\r\\nimport \\\"./ISdtFeeCollector.sol\\\";\\r\\nimport \\\"./ISdtBuffer.sol\\\";\\r\\nimport \\\"./ISdtRewardDistributor.sol\\\";\\r\\n\\r\\ninterface ICvgControlTower {\\r\\n    function cvgToken() external view returns (ICvg);\\r\\n\\r\\n    function cvgOracle() external view returns (ICvgOracle);\\r\\n\\r\\n    function bondCalculator() external view returns (IBondCalculator);\\r\\n\\r\\n    function gaugeController() external view returns (IGaugeController);\\r\\n\\r\\n    function cvgCycle() external view returns (uint128);\\r\\n\\r\\n    function votingPowerEscrow() external view returns (IVotingPowerEscrow);\\r\\n\\r\\n    function treasuryDao() external view returns (address);\\r\\n\\r\\n    function treasuryPod() external view returns (address);\\r\\n\\r\\n    function treasuryPdd() external view returns (address);\\r\\n\\r\\n    function treasuryAirdrop() external view returns (address);\\r\\n\\r\\n    function treasuryTeam() external view returns (address);\\r\\n\\r\\n    function cvgRewards() external view returns (ICvgRewards);\\r\\n\\r\\n    function lockingPositionManager() external view returns (ILockingPositionManager);\\r\\n\\r\\n    function lockingPositionService() external view returns (ILockingPositionService);\\r\\n\\r\\n    function lockingPositionDelegate() external view returns (ILockingPositionDelegate);\\r\\n\\r\\n    function isStakingContract(address contractAddress) external view returns (bool);\\r\\n\\r\\n    function ysDistributor() external view returns (IYsDistributor);\\r\\n\\r\\n    function isBond(address account) external view returns (bool);\\r\\n\\r\\n    function bondPositionManager() external view returns (IBondPositionManager);\\r\\n\\r\\n    function sdtStakingPositionManager() external view returns (ISdtStakingPositionManager);\\r\\n\\r\\n    function sdtStakingLogo() external view returns (ISdtStakingLogo);\\r\\n\\r\\n    function bondLogo() external view returns (IBondLogo);\\r\\n\\r\\n    function lockingLogo() external view returns (ILockingLogo);\\r\\n\\r\\n    function isSdtStaking(address contractAddress) external view returns (bool);\\r\\n\\r\\n    function vestingCvg() external view returns (IVestingCvg);\\r\\n\\r\\n    function sdt() external view returns (IERC20);\\r\\n\\r\\n    function cvgSDT() external view returns (IERC20Mintable);\\r\\n\\r\\n    function cvgSdtStaking() external view returns (ISdtStakingPositionService);\\r\\n\\r\\n    function cvgSdtBuffer() external view returns (ISdtBuffer);\\r\\n\\r\\n    function veSdtMultisig() external view returns (address);\\r\\n\\r\\n    function cloneFactory() external view returns (address);\\r\\n\\r\\n    function sdtUtilities() external view returns (address);\\r\\n\\r\\n    function insertNewSdtStaking(address _sdtStakingClone) external;\\r\\n\\r\\n    function allBaseSdAssetStaking(uint256 _index) external view returns (address);\\r\\n\\r\\n    function allBaseSdAssetBuffer(uint256 _index) external view returns (address);\\r\\n\\r\\n    function sdtFeeCollector() external view returns (ISdtFeeCollector);\\r\\n\\r\\n    function updateCvgCycle() external;\\r\\n\\r\\n    function sdtBlackHole() external view returns (ISdtBlackHole);\\r\\n\\r\\n    function sdtRewardDistributor() external view returns (address);\\r\\n\\r\\n    function poolCvgSdt() external view returns (address);\\r\\n\\r\\n    function bondDepository() external view returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ICvgOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\r\\nimport \\\"./IOracleStruct.sol\\\";\\r\\n\\r\\ninterface ICvgOracle {\\r\\n    function getPriceVerified(address erc20) external view returns (uint256);\\r\\n\\r\\n    function getPriceUnverified(address erc20) external view returns (uint256);\\r\\n\\r\\n    function getAndVerifyTwoPrices(address tokenIn, address tokenOut) external view returns (uint256, uint256);\\r\\n\\r\\n    function getTwoPricesAndIsValid(\\r\\n        address tokenIn,\\r\\n        address tokenOut\\r\\n    ) external view returns (uint256, uint256, bool, uint256, uint256, bool);\\r\\n\\r\\n    function getPriceAndValidationData(\\r\\n        address erc20Address\\r\\n    ) external view returns (uint256, uint256, bool, bool, bool, bool);\\r\\n\\r\\n    function getPoolAddressByToken(address erc20) external view returns (address);\\r\\n\\r\\n    function poolTypePerErc20(address) external view returns (IOracleStruct.PoolType);\\r\\n\\r\\n    //OWNER\\r\\n\\r\\n    function setPoolTypeForToken(address _erc20Address, IOracleStruct.PoolType _poolType) external;\\r\\n\\r\\n    function setStableParams(address _erc20Address, IOracleStruct.StableParams calldata _stableParams) external;\\r\\n\\r\\n    function setCurveDuoParams(address _erc20Address, IOracleStruct.CurveDuoParams calldata _curveDuoParams) external;\\r\\n\\r\\n    function setCurveTriParams(address _erc20Address, IOracleStruct.CurveTriParams calldata _curveTriParams) external;\\r\\n\\r\\n    function setUniV3Params(address _erc20Address, IOracleStruct.UniV3Params calldata _uniV3Params) external;\\r\\n\\r\\n    function setUniV2Params(address _erc20Address, IOracleStruct.UniV2Params calldata _uniV2Params) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ICvgRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface ICvgRewards {\\r\\n    function cvgCycleRewards() external view returns (uint256);\\r\\n\\r\\n    function addGauge(address gaugeAddress) external;\\r\\n\\r\\n    function removeGauge(address gaugeAddress) external;\\r\\n\\r\\n    function getCycleLocking(uint256 timestamp) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Mintable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface for the optional mint function from the ERC20 standard.\\r\\n *\\r\\n * _Available since v4.1._\\r\\n */\\r\\ninterface IERC20Mintable is IERC20Metadata {\\r\\n    /**\\r\\n     * @dev Mint `amount` of token to `account`\\r\\n     */\\r\\n    function mint(address account, uint256 amount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IGaugeController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IGaugeController {\\r\\n    struct WeightType {\\r\\n        uint256 weight;\\r\\n        uint256 type_weight;\\r\\n        int128 gauge_type;\\r\\n    }\\r\\n\\r\\n    function add_type(string memory typeName, uint256 weight) external;\\r\\n\\r\\n    function add_gauge(address addr, int128 gaugeType, uint256 weight) external;\\r\\n\\r\\n    function get_gauge_weight(address gaugeAddress) external view returns (uint256);\\r\\n\\r\\n    function get_gauge_weights(address[] memory gaugeAddresses) external view returns (uint256[] memory, uint256);\\r\\n\\r\\n    function get_gauge_weights_and_types(address[] memory gaugeAddresses) external view returns (WeightType[] memory);\\r\\n\\r\\n    function get_total_weight() external view returns (uint256);\\r\\n\\r\\n    function n_gauges() external view returns (uint128);\\r\\n\\r\\n    function gauges(uint256 index) external view returns (address);\\r\\n\\r\\n    function gauge_types(address gaugeAddress) external view returns (int128);\\r\\n\\r\\n    function get_type_weight(int128 typeId) external view returns (uint256);\\r\\n\\r\\n    function gauge_relative_weight(address addr, uint256 time) external view returns (uint256);\\r\\n\\r\\n    function set_lock(bool isLock) external;\\r\\n\\r\\n    function gauge_relative_weight_write(address gaugeAddress) external;\\r\\n\\r\\n    function gauge_relative_weight_writes(uint256 from, uint256 length) external;\\r\\n\\r\\n    function simple_vote(uint256 tokenId, address gaugeAddress, uint256 tokenWeight) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ILockingLogo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface ILockingLogo {\\r\\n    struct LogoInfos {\\r\\n        uint256 tokenId;\\r\\n        uint256 cvgLocked;\\r\\n        uint256 lockEnd;\\r\\n        uint256 ysPercentage;\\r\\n        uint256 mgCvg;\\r\\n        uint256 unlockingTimestamp;\\r\\n    }\\r\\n    struct GaugePosition {\\r\\n        uint256 ysWidth; // width of the YS gauge part\\r\\n        uint256 veWidth; // width of the VE gauge part\\r\\n    }\\r\\n\\r\\n    struct LogoInfosFull {\\r\\n        uint256 tokenId;\\r\\n        uint256 cvgLocked;\\r\\n        uint256 lockEnd;\\r\\n        uint256 ysPercentage;\\r\\n        uint256 mgCvg;\\r\\n        uint256 unlockingTimestamp;\\r\\n        uint256 cvgLockedInUsd;\\r\\n        uint256 ysCvgActual;\\r\\n        uint256 ysCvgNext;\\r\\n        uint256 veCvg;\\r\\n        GaugePosition gaugePosition;\\r\\n        uint256 claimableInUsd;\\r\\n        bool isLocked;\\r\\n        uint256 hoursLock;\\r\\n    }\\r\\n\\r\\n    function _tokenURI(LogoInfos memory logoInfos) external pure returns (string memory output);\\r\\n\\r\\n    function getLogoInfo(uint256 tokenId) external view returns (ILockingLogo.LogoInfosFull memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ILockingPositionDelegate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface ILockingPositionDelegate {\\r\\n    struct OwnedAndDelegated {\\r\\n        uint256[] owneds;\\r\\n        uint256[] mgDelegateds;\\r\\n        uint256[] veDelegateds;\\r\\n    }\\r\\n\\r\\n    function delegatedYsCvg(uint256 tokenId) external view returns (address);\\r\\n\\r\\n    function getMgDelegateeInfoPerTokenAndAddress(\\r\\n        uint256 _tokenId,\\r\\n        address _to\\r\\n    ) external view returns (uint256, uint256, uint256);\\r\\n\\r\\n    function getIndexForVeDelegatee(address _delegatee, uint256 _tokenId) external view returns (uint256);\\r\\n\\r\\n    function getIndexForMgCvgDelegatee(address _delegatee, uint256 _tokenId) external view returns (uint256);\\r\\n\\r\\n    function delegateVeCvg(uint256 _tokenId, address _to) external;\\r\\n\\r\\n    function delegateYsCvg(uint256 _tokenId, address _to, bool _status) external;\\r\\n\\r\\n    function delegateMgCvg(uint256 _tokenId, address _to, uint256 _percentage) external;\\r\\n\\r\\n    function delegatedVeCvg(uint256 tokenId) external view returns (address);\\r\\n\\r\\n    function getVeCvgDelegatees(address account) external view returns (uint256[] memory);\\r\\n\\r\\n    function getMgCvgDelegatees(address account) external view returns (uint256[] memory);\\r\\n\\r\\n    function getTokenOwnedAndDelegated(address _addr) external view returns (OwnedAndDelegated[] memory);\\r\\n\\r\\n    function getTokenMgOwnedAndDelegated(address _addr) external view returns (uint256[] memory, uint256[] memory);\\r\\n\\r\\n    function getTokenVeOwnedAndDelegated(address _addr) external view returns (uint256[] memory, uint256[] memory);\\r\\n\\r\\n    function addTokenAtMint(uint256 _tokenId, address minter) external;\\r\\n\\r\\n    function cleanDelegateesOnTransfer(uint256 _tokenId) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ILockingPositionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./ILockingLogo.sol\\\";\\r\\n\\r\\ninterface ILockingPositionManager {\\r\\n    function ownerOf(uint256 tokenId) external view returns (address);\\r\\n\\r\\n    function mint(address account) external returns (uint256);\\r\\n\\r\\n    function burn(uint256 tokenId, address caller) external;\\r\\n\\r\\n    function logoInfo(uint256 tokenId) external view returns (ILockingLogo.LogoInfos memory);\\r\\n\\r\\n    function checkYsClaim(uint256 tokenId, address caller) external view;\\r\\n\\r\\n    function checkOwnership(uint256 _tokenId, address operator) external view;\\r\\n\\r\\n    function checkOwnerships(uint256[] memory _tokenIds, address operator) external view;\\r\\n\\r\\n    function checkFullCompliance(uint256 tokenId, address operator) external view;\\r\\n\\r\\n    function getTokenIdsForWallet(address _wallet) external view returns (uint256[] memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ILockingPositionService.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface ILockingPositionService {\\r\\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\\r\\n                        STORED STRUCTS\\r\\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\\r\\n    struct LockingPosition {\\r\\n        /// @dev Starting cycle of a LockingPosition. Maximum value of uint24 is 16M, so 16M weeks is way enough.\\r\\n        uint24 startCycle;\\r\\n        /// @dev End cycle of a LockingPosition. Maximum value of uint24 is 16M, so 16M weeks is way enough.\\r\\n        uint24 lastEndCycle;\\r\\n        /** @dev Percentage of the token allocated to ysCvg. Amount dedicated to vote is so equal to 100 - ysPercentage.\\r\\n         *  A position with ysPercentage as 60 will allocate 60% of his locking to YsCvg and 40% to veCvg and mgCvg.\\r\\n         */\\r\\n        uint8 ysPercentage;\\r\\n        /** @dev Total Cvg amount locked in the position.\\r\\n         *  Max supply of CVG is 150M, it so fits into an uint104 (20 000 billions approx).\\r\\n         */\\r\\n        uint104 totalCvgLocked;\\r\\n        /**  @dev MgCvgAmount held by the position.\\r\\n         *   Max supply of mgCVG is 150M, it so fits into an uint96 (20 billions approx).\\r\\n         */\\r\\n        uint96 mgCvgAmount;\\r\\n    }\\r\\n\\r\\n    struct TrackingBalance {\\r\\n        /** @dev Amount of ysCvg to add to the total supply when the corresponding cvgCycle is triggered.\\r\\n         *  Max supply of ysCVG is 150M, it so fits into an uint128.\\r\\n         */\\r\\n        uint128 ysToAdd;\\r\\n        /** @dev Amount of ysCvg to remove from the total supply when the corresponding cvgCycle is triggered.\\r\\n         *  Max supply of ysCVG is 150M, it so fits into an uint128.\\r\\n         */\\r\\n        uint128 ysToSub;\\r\\n    }\\r\\n\\r\\n    struct Checkpoints {\\r\\n        uint24 cycleId;\\r\\n        uint232 ysBalance;\\r\\n    }\\r\\n\\r\\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\\r\\n                        VIEW STRUCTS\\r\\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\\r\\n\\r\\n    struct TokenView {\\r\\n        uint256 tokenId;\\r\\n        uint128 startCycle;\\r\\n        uint128 endCycle;\\r\\n        uint256 cvgLocked;\\r\\n        uint256 ysActual;\\r\\n        uint256 ysTotal;\\r\\n        uint256 veCvgActual;\\r\\n        uint256 mgCvg;\\r\\n        uint256 ysPercentage;\\r\\n    }\\r\\n\\r\\n    struct LockingInfo {\\r\\n        uint256 tokenId;\\r\\n        uint256 cvgLocked;\\r\\n        uint256 lockEnd;\\r\\n        uint256 ysPercentage;\\r\\n        uint256 mgCvg;\\r\\n    }\\r\\n\\r\\n    function TDE_DURATION() external view returns (uint256);\\r\\n\\r\\n    function MAX_LOCK() external view returns (uint24);\\r\\n\\r\\n    function updateYsTotalSupply() external;\\r\\n\\r\\n    function ysTotalSupplyHistory(uint256) external view returns (uint256);\\r\\n\\r\\n    function ysShareOnTokenAtTde(uint256, uint256) external view returns (uint256);\\r\\n\\r\\n    function veCvgVotingPowerPerAddress(address _user) external view returns (uint256);\\r\\n\\r\\n    function mintPosition(\\r\\n        uint24 lockDuration,\\r\\n        uint128 amount,\\r\\n        uint8 ysPercentage,\\r\\n        address receiver,\\r\\n        bool isAddToManagedTokens\\r\\n    ) external;\\r\\n\\r\\n    function increaseLockAmount(uint256 tokenId, uint128 amount, address operator) external;\\r\\n\\r\\n    function increaseLockTime(uint256 tokenId, uint256 durationAdd) external;\\r\\n\\r\\n    function increaseLockTimeAndAmount(uint256 tokenId, uint24 durationAdd, uint128 amount, address operator) external;\\r\\n\\r\\n    function totalSupplyYsCvgHistories(uint256 cycleClaimed) external view returns (uint256);\\r\\n\\r\\n    function balanceOfYsCvgAt(uint256 tokenId, uint256 cycle) external view returns (uint256);\\r\\n\\r\\n    function lockingPositions(uint256 tokenId) external view returns (LockingPosition memory);\\r\\n\\r\\n    function unlockingTimestampPerToken(uint256 tokenId) external view returns (uint256);\\r\\n\\r\\n    function lockingInfo(uint256 tokenId) external view returns (LockingInfo memory);\\r\\n\\r\\n    function isContractLocker(address contractAddress) external view returns (bool);\\r\\n\\r\\n    function getTotalSupplyAtAndBalanceOfYs(uint256 tokenId, uint256 cycleId) external view returns (uint256, uint256);\\r\\n\\r\\n    function getTotalSupplyHistoryAndBalanceOfYs(\\r\\n        uint256 tokenId,\\r\\n        uint256 cycleId\\r\\n    ) external view returns (uint256, uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ILpStakeDaoStrat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\r\\n\\r\\ninterface ILpStakeDaoStrat is IERC20Metadata {\\r\\n    function deposit(address staker, uint256 amount, bool earn) external;\\r\\n\\r\\n    function token() external view returns (IERC20Metadata);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IOracleStruct.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\r\\n\\r\\ninterface IOracleStruct {\\r\\n    enum PoolType {\\r\\n        NOT_INIT,\\r\\n        STABLE,\\r\\n        CURVE_DUO,\\r\\n        CURVE_TRI,\\r\\n        UNI_V3,\\r\\n        UNI_V2\\r\\n    }\\r\\n\\r\\n    struct StableParams {\\r\\n        AggregatorV3Interface aggregatorOracle;\\r\\n        uint40 deltaLimitOracle; // 5 % => 500 & 100 % => 10 000\\r\\n        uint56 maxLastUpdate; // Buffer time before a not updated price is considered as stale\\r\\n        uint128 minPrice;\\r\\n        uint128 maxPrice;\\r\\n    }\\r\\n\\r\\n    struct CurveDuoParams {\\r\\n        bool isReversed;\\r\\n        bool isEthPriceRelated;\\r\\n        address poolAddress;\\r\\n        uint40 deltaLimitOracle; // 5 % => 500 & 100 % => 10 000\\r\\n        uint40 maxLastUpdate; // Buffer time before a not updated price is considered as stale\\r\\n        uint128 minPrice;\\r\\n        uint128 maxPrice;\\r\\n        address[] stablesToCheck;\\r\\n    }\\r\\n\\r\\n    struct CurveTriParams {\\r\\n        bool isReversed;\\r\\n        bool isEthPriceRelated;\\r\\n        address poolAddress;\\r\\n        uint40 deltaLimitOracle;\\r\\n        uint40 maxLastUpdate;\\r\\n        uint8 k;\\r\\n        uint120 minPrice;\\r\\n        uint128 maxPrice;\\r\\n        address[] stablesToCheck;\\r\\n    }\\r\\n\\r\\n    struct UniV2Params {\\r\\n        bool isReversed;\\r\\n        bool isEthPriceRelated;\\r\\n        address poolAddress;\\r\\n        uint80 deltaLimitOracle;\\r\\n        uint96 maxLastUpdate;\\r\\n        AggregatorV3Interface aggregatorOracle;\\r\\n        uint128 minPrice;\\r\\n        uint128 maxPrice;\\r\\n        address[] stablesToCheck;\\r\\n    }\\r\\n\\r\\n    struct UniV3Params {\\r\\n        bool isReversed;\\r\\n        bool isEthPriceRelated;\\r\\n        address poolAddress;\\r\\n        uint80 deltaLimitOracle;\\r\\n        uint80 maxLastUpdate;\\r\\n        uint16 twap;\\r\\n        AggregatorV3Interface aggregatorOracle;\\r\\n        uint128 minPrice;\\r\\n        uint128 maxPrice;\\r\\n        address[] stablesToCheck;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPresaleCvgSeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\r\\n\\r\\ninterface IPresaleCvgSeed is IERC721Enumerable {\\r\\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\\r\\n                            ENUMS & STRUCTS\\r\\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\\r\\n    enum SaleState {\\r\\n        NOT_ACTIVE,\\r\\n        PRESEED,\\r\\n        SEED,\\r\\n        OVER\\r\\n    }\\r\\n\\r\\n    struct PresaleInfo {\\r\\n        uint256 vestingType; // Define the presaler type\\r\\n        uint256 cvgAmount; // Total CVG amount claimable for the nft owner\\r\\n    }\\r\\n\\r\\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\\r\\n                            SETTERS\\r\\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\\r\\n    function setSaleState(SaleState _saleState) external;\\r\\n\\r\\n    function grantPreseed(address _wallet, uint256 _amount) external;\\r\\n\\r\\n    function grantSeed(address _wallet, uint256 _amount) external;\\r\\n\\r\\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\\r\\n                            EXTERNALS\\r\\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\\r\\n    function investMint(bool _isDai) external;\\r\\n\\r\\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\\r\\n                            GETTERS\\r\\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\\r\\n    function presaleInfoTokenId(uint256 _tokenId) external view returns (PresaleInfo memory);\\r\\n\\r\\n    function saleState() external view returns (SaleState);\\r\\n\\r\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view override returns (uint256);\\r\\n\\r\\n    function getTokenIdAndType(\\r\\n        address _wallet,\\r\\n        uint256 _index\\r\\n    ) external view returns (uint256 tokenId, uint256 typeVesting);\\r\\n\\r\\n    function getTokenIdsForWallet(address _wallet) external view returns (uint256[] memory);\\r\\n\\r\\n    function getTotalCvg() external view returns (uint256);\\r\\n\\r\\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\\r\\n                        WITHDRAW OWNER\\r\\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\\r\\n    function withdrawFunds() external;\\r\\n\\r\\n    function withdrawToken(address _token) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ISdAssets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\r\\nimport \\\"./ICvgControlTower.sol\\\";\\r\\nimport \\\"./ISdtBuffer.sol\\\";\\r\\n\\r\\ninterface IOperator {\\r\\n    function token() external view returns (IERC20Metadata);\\r\\n\\r\\n    function deposit(uint256 amount, bool isLock, bool isStake, address receiver) external;\\r\\n}\\r\\n\\r\\ninterface ISdAsset is IERC20Metadata {\\r\\n    function sdAssetGauge() external view returns (IERC20);\\r\\n\\r\\n    function initialize(\\r\\n        ICvgControlTower _cvgControlTower,\\r\\n        IERC20 _sdAssetGauge,\\r\\n        string memory setName,\\r\\n        string memory setSymbol\\r\\n    ) external;\\r\\n\\r\\n    function setSdAssetBuffer(address _sdAssetBuffer) external;\\r\\n\\r\\n    function mint(address to, uint256 amount) external;\\r\\n\\r\\n    function operator() external view returns (IOperator);\\r\\n}\\r\\n\\r\\ninterface ISdAssetGauge is IERC20Metadata {\\r\\n    function deposit(uint256 value, address addr) external;\\r\\n\\r\\n    function deposit(uint256 value, address addr, bool claimRewards) external;\\r\\n\\r\\n    function staking_token() external view returns (IERC20);\\r\\n\\r\\n    function reward_count() external view returns (uint256);\\r\\n\\r\\n    function reward_tokens(uint256 i) external view returns (IERC20);\\r\\n\\r\\n    function claim_rewards(address account) external;\\r\\n\\r\\n    function set_rewards_receiver(address account) external;\\r\\n\\r\\n    function claimable_reward(address account, address token) external view returns (uint256);\\r\\n\\r\\n    function set_reward_distributor(address rewardToken, address distributor) external;\\r\\n\\r\\n    function deposit_reward_token(address rewardToken, uint256 amount) external;\\r\\n\\r\\n    function admin() external view returns (address);\\r\\n\\r\\n    function working_balances(address) external view returns (uint256);\\r\\n\\r\\n    function working_supply() external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ISdtBlackHole.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"./ICommonStruct.sol\\\";\\r\\n\\r\\ninterface ISdtBlackHole {\\r\\n    function withdraw(uint256 amount, address receiver) external;\\r\\n\\r\\n    function setGaugeReceiver(address gaugeAddress, address bufferReceiver) external;\\r\\n\\r\\n    function getBribeTokensForBuffer(address buffer) external view returns (IERC20[] memory);\\r\\n\\r\\n    function pullSdStakingBribes(\\r\\n        address _processor,\\r\\n        uint256 _processorRewardsPercentage\\r\\n    ) external returns (ICommonStruct.TokenAmount[] memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ISdtBuffer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"./ICvgControlTower.sol\\\";\\r\\n\\r\\nimport \\\"./ISdAssets.sol\\\";\\r\\n\\r\\nimport \\\"./ICommonStruct.sol\\\";\\r\\n\\r\\ninterface ISdtBuffer {\\r\\n    function initialize(\\r\\n        ICvgControlTower _cvgControlTower,\\r\\n        address _sdAssetStaking,\\r\\n        ISdAssetGauge _sdGaugeAsset,\\r\\n        IERC20 _sdt\\r\\n    ) external;\\r\\n\\r\\n    function pullRewards(address _processor) external returns (ICommonStruct.TokenAmount[] memory);\\r\\n\\r\\n    function processorRewardsPercentage() external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ISdtFeeCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface ISdtFeeCollector {\\r\\n    function rootFees() external returns (uint256);\\r\\n\\r\\n    function withdrawToken(IERC20[] calldata _tokens) external;\\r\\n\\r\\n    function withdrawSdt() external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ISdtRewardDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"./ICommonStruct.sol\\\";\\r\\n\\r\\ninterface ISdtRewardDistributor {\\r\\n    function claimCvgSdtSimple(\\r\\n        address receiver,\\r\\n        uint256 cvgAmount,\\r\\n        ICommonStruct.TokenAmount[] memory sdtRewards,\\r\\n        uint256 minCvgSdtAmountOut,\\r\\n        bool isConvert\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ISdtStakingLogo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./ICommonStruct.sol\\\";\\r\\n\\r\\ninterface ISdtStakingLogo {\\r\\n    struct LogoInfos {\\r\\n        uint256 tokenId;\\r\\n        string symbol;\\r\\n        uint256 pending;\\r\\n        uint256 totalStaked;\\r\\n        uint256 cvgClaimable;\\r\\n        ICommonStruct.TokenAmount[] sdtClaimable;\\r\\n        uint256 unlockingTimestamp;\\r\\n    }\\r\\n\\r\\n    struct LogoInfosFull {\\r\\n        uint256 tokenId;\\r\\n        string symbol;\\r\\n        uint256 pending;\\r\\n        uint256 totalStaked;\\r\\n        uint256 cvgClaimable;\\r\\n        ICommonStruct.TokenAmount[] sdtClaimable;\\r\\n        uint256 unlockingTimestamp;\\r\\n        uint256 claimableInUsd;\\r\\n        bool erroneousAmount;\\r\\n        bool isLocked;\\r\\n        uint256 hoursLock;\\r\\n    }\\r\\n\\r\\n    function _tokenURI(LogoInfos memory logoInfos) external pure returns (string memory output);\\r\\n\\r\\n    function getLogoInfo(uint256 tokenId) external view returns (ISdtStakingLogo.LogoInfosFull memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ISdtStakingPositionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./ISdtStakingLogo.sol\\\";\\r\\nimport \\\"./ISdtStakingPositionService.sol\\\";\\r\\n\\r\\ninterface ISdtStakingPositionManager {\\r\\n    struct ClaimSdtStakingContract {\\r\\n        ISdtStakingPositionService stakingContract;\\r\\n        uint256[] tokenIds;\\r\\n    }\\r\\n\\r\\n    function mint(address account) external;\\r\\n\\r\\n    function burn(uint256 tokenId) external;\\r\\n\\r\\n    function nextId() external view returns (uint256);\\r\\n\\r\\n    function ownerOf(uint256 tokenId) external view returns (address);\\r\\n\\r\\n    function checkMultipleClaimCompliance(ClaimSdtStakingContract[] calldata, address account) external view;\\r\\n\\r\\n    function checkTokenFullCompliance(uint256 tokenId, address account) external view;\\r\\n\\r\\n    function checkIncreaseDepositCompliance(uint256 tokenId, address account) external view;\\r\\n\\r\\n    function stakingPerTokenId(uint256 tokenId) external view returns (address);\\r\\n\\r\\n    function unlockingTimestampPerToken(uint256 tokenId) external view returns (uint256);\\r\\n\\r\\n    function logoInfo(uint256 tokenId) external view returns (ISdtStakingLogo.LogoInfos memory);\\r\\n\\r\\n    function getTokenIdsForWallet(address _wallet) external view returns (uint256[] memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ISdtStakingPositionService.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\r\\nimport \\\"./ICommonStruct.sol\\\";\\r\\nimport \\\"./ISdtBuffer.sol\\\";\\r\\n\\r\\ninterface ISdtStakingPositionService {\\r\\n    struct CycleInfo {\\r\\n        uint256 cvgRewardsAmount;\\r\\n        uint256 totalStaked;\\r\\n        bool isSdtProcessed;\\r\\n    }\\r\\n\\r\\n    struct TokenInfo {\\r\\n        uint256 amountStaked;\\r\\n        uint256 pendingStaked;\\r\\n    }\\r\\n    struct CycleInfoMultiple {\\r\\n        uint256 totalStaked;\\r\\n        ICommonStruct.TokenAmount[] sdtClaimable;\\r\\n    }\\r\\n    struct StakingInfo {\\r\\n        uint256 tokenId;\\r\\n        string symbol;\\r\\n        uint256 pending;\\r\\n        uint256 totalStaked;\\r\\n        uint256 cvgClaimable;\\r\\n        ICommonStruct.TokenAmount[] sdtClaimable;\\r\\n    }\\r\\n\\r\\n    function setBuffer(address _buffer) external;\\r\\n\\r\\n    function stakingCycle() external view returns (uint256);\\r\\n\\r\\n    function cycleInfo(uint256 cycleId) external view returns (CycleInfo memory);\\r\\n\\r\\n    function stakingAsset() external view returns (ISdAssetGauge);\\r\\n\\r\\n    function buffer() external view returns (ISdtBuffer);\\r\\n\\r\\n    function tokenTotalStaked(uint256 _tokenId) external view returns (uint256 amount);\\r\\n\\r\\n    function stakedAmountEligibleAtCycle(\\r\\n        uint256 cvgCycle,\\r\\n        uint256 tokenId,\\r\\n        uint256 actualCycle\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function tokenInfoByCycle(uint256 cycleId, uint256 tokenId) external view returns (TokenInfo memory);\\r\\n\\r\\n    function stakingInfo(uint256 tokenId) external view returns (StakingInfo memory);\\r\\n\\r\\n    function getProcessedSdtRewards(uint256 _cycleId) external view returns (ICommonStruct.TokenAmount[] memory);\\r\\n\\r\\n    function deposit(uint256 tokenId, uint256 amount, address operator) external;\\r\\n\\r\\n    function claimCvgSdtMultiple(\\r\\n        uint256 _tokenId,\\r\\n        address operator\\r\\n    ) external returns (uint256, ICommonStruct.TokenAmount[] memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IVestingCvg.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"./IPresaleCvgSeed.sol\\\";\\r\\n\\r\\ninterface IVestingCvg {\\r\\n    /// @dev Struct Info about VestingSchedules\\r\\n    struct VestingSchedule {\\r\\n        uint16 daysBeforeCliff;\\r\\n        uint16 daysAfterCliff;\\r\\n        uint24 dropCliff;\\r\\n        uint256 totalAmount;\\r\\n        uint256 totalReleased;\\r\\n    }\\r\\n\\r\\n    struct InfoVestingTokenId {\\r\\n        uint256 amountReleasable;\\r\\n        uint256 totalCvg;\\r\\n        uint256 amountRedeemed;\\r\\n    }\\r\\n\\r\\n    enum VestingType {\\r\\n        SEED,\\r\\n        WL,\\r\\n        IBO,\\r\\n        TEAM,\\r\\n        DAO\\r\\n    }\\r\\n\\r\\n    function vestingSchedules(VestingType vestingType) external view returns (VestingSchedule memory);\\r\\n\\r\\n    function getInfoVestingTokenId(\\r\\n        uint256 _tokenId,\\r\\n        VestingType vestingType\\r\\n    ) external view returns (InfoVestingTokenId memory);\\r\\n\\r\\n    function whitelistedTeam() external view returns (address);\\r\\n\\r\\n    function presaleSeed() external view returns (IPresaleCvgSeed);\\r\\n\\r\\n    function MAX_SUPPLY_TEAM() external view returns (uint256);\\r\\n\\r\\n    function startTimestamp() external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IVotingPowerEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IVotingPowerEscrow {\\r\\n    function create_lock(uint256 tokenId, uint256 value, uint256 unlockTime) external;\\r\\n\\r\\n    function increase_amount(uint256 tokenId, uint256 value) external;\\r\\n\\r\\n    function increase_unlock_time(uint256 tokenId, uint256 unlockTime) external;\\r\\n\\r\\n    function increase_unlock_time_and_amount(uint256 tokenId, uint256 unlockTime, uint256 amount) external;\\r\\n\\r\\n    function withdraw(uint256 tokenId) external;\\r\\n\\r\\n    function total_supply() external returns (uint256);\\r\\n\\r\\n    function balanceOf(uint256 tokenId) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IYsDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./ICommonStruct.sol\\\";\\r\\n\\r\\ninterface IYsDistributor {\\r\\n    struct TokenAmount {\\r\\n        IERC20 token;\\r\\n        uint96 amount;\\r\\n    }\\r\\n\\r\\n    struct Claim {\\r\\n        uint256 tdeCycle;\\r\\n        bool isClaimed;\\r\\n        TokenAmount[] tokenAmounts;\\r\\n    }\\r\\n\\r\\n    function getPositionRewardsForTdes(\\r\\n        uint256[] calldata _tdeIds,\\r\\n        uint256 actualCycle,\\r\\n        uint256 _tokenId\\r\\n    ) external view returns (Claim[] memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Staking/StakeDAO/SdtUtilities.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n _____\\r\\n/  __ \\\\\\r\\n| /  \\\\/ ___  _ ____   _____ _ __ __ _  ___ _ __   ___ ___\\r\\n| |    / _ \\\\| '_ \\\\ \\\\ / / _ \\\\ '__/ _` |/ _ \\\\ '_ \\\\ / __/ _ \\\\\\r\\n| \\\\__/\\\\ (_) | | | \\\\ V /  __/ | | (_| |  __/ | | | (_|  __/\\r\\n \\\\____/\\\\___/|_| |_|\\\\_/ \\\\___|_|  \\\\__, |\\\\___|_| |_|\\\\___\\\\___|\\r\\n                                 __/ |\\r\\n                                |___/\\r\\n */\\r\\n\\r\\n/// @title Cvg-Finance - SdtUtilities\\r\\n/// @notice This contract is an utility contract enhancing user experience for the dapp involving integration of StakeDao.\\r\\n/// @notice It allows to wraps several transactions in one.\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\r\\n\\r\\nimport \\\"../../interfaces/ICvgControlTower.sol\\\";\\r\\nimport \\\"../../interfaces/IAggregationRouterV5.sol\\\";\\r\\nimport \\\"../../interfaces/ICrvPoolPlain.sol\\\";\\r\\nimport \\\"../../interfaces/ISdAssets.sol\\\";\\r\\nimport \\\"../../interfaces/ILpStakeDaoStrat.sol\\\";\\r\\n\\r\\ncontract SdtUtilities is Ownable2Step {\\r\\n    struct TokenSpender {\\r\\n        address token;\\r\\n        address spender;\\r\\n        uint256 amount;\\r\\n    }\\r\\n\\r\\n    struct TokenCycles {\\r\\n        uint256 tokenId;\\r\\n        uint256[] cycleIds;\\r\\n    }\\r\\n\\r\\n    struct ClaimSdtStakingContract {\\r\\n        address stakingContract;\\r\\n        TokenCycles[] tokenCycles;\\r\\n    }\\r\\n\\r\\n    struct SetStablePool {\\r\\n        address liquidLocker;\\r\\n        ICrvPoolPlain lp;\\r\\n    }\\r\\n\\r\\n    uint256 internal constant HUNDRED = 1_000;\\r\\n\\r\\n    /// @dev address of the CvgControlTower\\r\\n    ICvgControlTower public cvgControlTower;\\r\\n\\r\\n    /// @notice Fetches the associated StablePool from Curve linked to an Asset.\\r\\n    /// @dev    Is used for sdAssets & CvgSdt\\r\\n    mapping(address => ICrvPoolPlain) public stablePoolPerAsset;\\r\\n\\r\\n    IERC20 public immutable sdt;\\r\\n\\r\\n    IERC20Mintable public immutable cvgSdt;\\r\\n\\r\\n    /// @dev Corresponds to the % of depeg from which we need to start swapping the SDT.\\r\\n    uint256 public percentageDepeg;\\r\\n\\r\\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\\r\\n                            CONSTRUCTOR\\r\\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\\r\\n\\r\\n    constructor(ICvgControlTower _cvgControlTower, IERC20Mintable _cvgSdt, IERC20 _sdt) {\\r\\n        cvgControlTower = _cvgControlTower;\\r\\n        sdt = _sdt;\\r\\n        cvgSdt = _cvgSdt;\\r\\n        percentageDepeg = 1_025; //2.5%\\r\\n        _transferOwnership(msg.sender);\\r\\n    }\\r\\n\\r\\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\\r\\n                        EXTERNAL FUNCTIONS\\r\\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\\r\\n\\r\\n    /**\\r\\n     * @notice Convert & Stake SDT on the CvgSdtStaking. Mints a new position or increases an already existing one.\\r\\n     * @dev    Can also send an amount of CvgSdt summed to the converted amount and therefore, staked in the CvgSdtStaking.\\r\\n     *         Force the Swap in the StablePool if CvgSdt is depeged from 5% from the SDT, acts as a peg keeper.\\r\\n     * @param _tokenId      Token id of the position, if 0, mints an NFT\\r\\n     * @param _cvgSdtAmount Amount of CvgSdt to sum with the SDT converted\\r\\n     * @param _sdtAmount    Amount of SDT to convert in CvgSdt\\r\\n     */\\r\\n    function convertAndStakeCvgSdt(uint256 _tokenId, uint256 _cvgSdtAmount, uint256 _sdtAmount) external {\\r\\n        if (_cvgSdtAmount != 0) {\\r\\n            cvgSdt.transferFrom(msg.sender, address(this), _cvgSdtAmount);\\r\\n        }\\r\\n\\r\\n        /// @dev Get CvgSdt\\r\\n        if (_sdtAmount != 0) {\\r\\n            /// @dev Send Sdt on the contract\\r\\n            sdt.transferFrom(msg.sender, address(this), _sdtAmount);\\r\\n            /// @dev Get the stable pool Sdt/CvgSdt\\r\\n            ICrvPoolPlain crvPoolPlain = stablePoolPerAsset[address(cvgSdt)];\\r\\n            /// @dev Acts as a peg keeper and will prefers swap in the liquid pool in case of a depeg\\r\\n            if (crvPoolPlain.get_dy(0, 1, _sdtAmount) > (_sdtAmount * percentageDepeg) / HUNDRED) {\\r\\n                /// @dev peg is too low, we swap in the LP with the SDT sent\\r\\n                crvPoolPlain.exchange(0, 1, _sdtAmount, _sdtAmount, address(this));\\r\\n            } else {\\r\\n                /// @dev peg OK, we pass through the mint process 1:1, sending the SDT in the veSDTMultisig\\r\\n                cvgSdt.mint(address(this), _sdtAmount);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        /// @dev deposit of the CvgAmount, sum of the CvgSdt already posessed & the Sdt converted to CvgSdt\\r\\n        cvgControlTower.cvgSdtStaking().deposit(_tokenId, cvgSdt.balanceOf(address(this)), msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Convert & Stake SDT on a SdAssetStaking. Converts the user asset directly to the sdGaugeAsset of StakeDao and stake it into Convergence.\\r\\n     *         Mints a new position or increases an already existing one.\\r\\n     * @dev    Can send a base amount of sdAsset that is summed to the converted amount of asset.\\r\\n     *         Can send a base amount of sdAssetGauge that is summed to the totalAmount of sdAssetGauge.\\r\\n     *         For the Asset => SdAsset conversion we choose the best rate between the mint 1:1 on stake or the swap in the linked stable pool.\\r\\n     * @param _tokenId          Token id of the position, if 0, mints an NFT\\r\\n     * @param _sdAssetStaking   SdAssetStakingService address\\r\\n     * @param _gaugeAssetAmount Amount of sdGaugeAsset to add to the converted amounts\\r\\n     * @param _sdAssetAmount    Amount of sdAsset to convert in sdGaugeAsset\\r\\n     * @param _assetAmount      Amount of asset to convert in sdAssets\\r\\n     * @param isLock            Lock and get fees from the corresponding Liquid Locker\\r\\n     */\\r\\n    function convertAndStakeSdAsset(\\r\\n        uint256 _tokenId,\\r\\n        ISdtStakingPositionService _sdAssetStaking,\\r\\n        uint256 _gaugeAssetAmount,\\r\\n        uint256 _sdAssetAmount,\\r\\n        uint256 _assetAmount,\\r\\n        bool isLock\\r\\n    ) external {\\r\\n        ISdAssetGauge gaugeAsset = _sdAssetStaking.stakingAsset();\\r\\n\\r\\n        ISdAsset sdAsset = ISdAsset(address(gaugeAsset.staking_token()));\\r\\n\\r\\n        /// @dev Transfers the base amount of sdGaugeAsset\\r\\n        if (_gaugeAssetAmount != 0) {\\r\\n            gaugeAsset.transferFrom(msg.sender, address(this), _gaugeAssetAmount);\\r\\n        }\\r\\n\\r\\n        /// @dev Transfers the base amount of sdAsset\\r\\n        if (_sdAssetAmount != 0) {\\r\\n            sdAsset.transferFrom(msg.sender, address(this), _sdAssetAmount);\\r\\n        }\\r\\n\\r\\n        /// @dev Transfers the amount of assets that'll be converted to sdAssets.\\r\\n        if (_assetAmount != 0) {\\r\\n            IOperator operator = sdAsset.operator();\\r\\n\\r\\n            operator.token().transferFrom(msg.sender, address(this), _assetAmount);\\r\\n            ICrvPoolPlain crvPoolPlain = stablePoolPerAsset[address(sdAsset)];\\r\\n            /// @dev if the curvePool is set, we search the best conversion rate\\r\\n            if (address(crvPoolPlain) != address(0)) {\\r\\n                /// @dev swap is better, we pass through a swap in the LP\\r\\n                if (crvPoolPlain.get_dy(0, 1, _assetAmount) > _assetAmount) {\\r\\n                    crvPoolPlain.exchange(0, 1, _assetAmount, _assetAmount, address(this));\\r\\n                }\\r\\n                /// @dev deposit is better, we pass through the operator to deposit\\r\\n                else {\\r\\n                    operator.deposit(_assetAmount, isLock, false, address(this));\\r\\n                }\\r\\n            }\\r\\n            /// @dev if no curvePool setted, we always deposit through the operator in 1:1 ( this usecase is for balancer )\\r\\n            else {\\r\\n                operator.deposit(_assetAmount, isLock, false, address(this));\\r\\n            }\\r\\n        }\\r\\n        /// @dev Always convert the full amount\\r\\n        uint256 sdAssetBalance = sdAsset.balanceOf(address(this));\\r\\n        if (sdAssetBalance > 0) {\\r\\n            /// @dev get more sdGaugeAssets\\r\\n            gaugeAsset.deposit(sdAssetBalance, address(this));\\r\\n        }\\r\\n\\r\\n        /// @dev stake sdGaugeAsset\\r\\n        _sdAssetStaking.deposit(_tokenId, gaugeAsset.balanceOf(address(this)), msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Convert & Stake SDT on a LpAssetStaking. Converts the user lpAsset directly to the LpGaugeAsset of StakeDao and stake it into Convergence.\\r\\n     *         Mints a new position or increases an already existing one.\\r\\n     * @dev    Can send a base amount of lpAssetGauge that is sumed to converted amount.\\r\\n     * @param _tokenId          Token id of the position, if 0, mints an NFT\\r\\n     * @param _lpStaking        SdAssetStakingService address\\r\\n     * @param _gaugeAssetAmount Amount of lpGaugeAsset to add to the converted amounts\\r\\n     * @param _lpAssetAmount    Amount of lpAsset to convert in lpGaugeAsset\\r\\n     * @param _isEarn           Streams the rewards of the underlying strategie if true\\r\\n     */\\r\\n    function convertAndStakeLpAsset(\\r\\n        uint256 _tokenId,\\r\\n        ISdtStakingPositionService _lpStaking,\\r\\n        uint256 _gaugeAssetAmount,\\r\\n        uint256 _lpAssetAmount,\\r\\n        bool _isEarn\\r\\n    ) external {\\r\\n        ISdAssetGauge lpGaugeAsset = _lpStaking.stakingAsset();\\r\\n\\r\\n        if (_gaugeAssetAmount != 0) {\\r\\n            lpGaugeAsset.transferFrom(msg.sender, address(this), _gaugeAssetAmount);\\r\\n        }\\r\\n\\r\\n        if (_lpAssetAmount != 0) {\\r\\n            ILpStakeDaoStrat lpAsset = ILpStakeDaoStrat(address(lpGaugeAsset.staking_token()));\\r\\n            lpAsset.token().transferFrom(msg.sender, address(this), _lpAssetAmount);\\r\\n            lpAsset.deposit(address(this), _lpAssetAmount, _isEarn);\\r\\n        }\\r\\n\\r\\n        _lpStaking.deposit(_tokenId, lpGaugeAsset.balanceOf(address(this)), msg.sender);\\r\\n    }\\r\\n\\r\\n    /* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=\\r\\n                        OWNER FUNCTIONS\\r\\n    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-= */\\r\\n    /**\\r\\n     * @notice Approve tokens to contracts that will be transferedFrom this contract.\\r\\n     * @dev    All converter contracts must be approved with the corresponding ERC20.\\r\\n     * @param _tokenSpenders Array of approval struct.\\r\\n     */\\r\\n    function approveTokens(TokenSpender[] calldata _tokenSpenders) external onlyOwner {\\r\\n        for (uint256 i; i < _tokenSpenders.length; ) {\\r\\n            IERC20(_tokenSpenders[i].token).approve(_tokenSpenders[i].spender, _tokenSpenders[i].amount);\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the stable pool linked to a liquid locker\\r\\n     * @param _setStablePools Array of SetStablePool struct\\r\\n     */\\r\\n    function setStablePools(SetStablePool[] calldata _setStablePools) external onlyOwner {\\r\\n        for (uint256 i; i < _setStablePools.length; ) {\\r\\n            stablePoolPerAsset[_setStablePools[i].liquidLocker] = _setStablePools[i].lp;\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setPercentageDepeg(uint256 newPercentageDepeg) external onlyOwner {\\r\\n        require(newPercentageDepeg >= 1000, \\\"PERCENTAGE_TOO_LOW\\\");\\r\\n        percentageDepeg = newPercentageDepeg;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 250\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ICvgControlTower\",\"name\":\"_cvgControlTower\",\"type\":\"address\"},{\"internalType\":\"contract IERC20Mintable\",\"name\":\"_cvgSdt\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_sdt\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct SdtUtilities.TokenSpender[]\",\"name\":\"_tokenSpenders\",\"type\":\"tuple[]\"}],\"name\":\"approveTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cvgSdtAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sdtAmount\",\"type\":\"uint256\"}],\"name\":\"convertAndStakeCvgSdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"contract ISdtStakingPositionService\",\"name\":\"_lpStaking\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gaugeAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lpAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isEarn\",\"type\":\"bool\"}],\"name\":\"convertAndStakeLpAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"contract ISdtStakingPositionService\",\"name\":\"_sdAssetStaking\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gaugeAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sdAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_assetAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLock\",\"type\":\"bool\"}],\"name\":\"convertAndStakeSdAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cvgControlTower\",\"outputs\":[{\"internalType\":\"contract ICvgControlTower\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cvgSdt\",\"outputs\":[{\"internalType\":\"contract IERC20Mintable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentageDepeg\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sdt\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPercentageDepeg\",\"type\":\"uint256\"}],\"name\":\"setPercentageDepeg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"liquidLocker\",\"type\":\"address\"},{\"internalType\":\"contract ICrvPoolPlain\",\"name\":\"lp\",\"type\":\"address\"}],\"internalType\":\"struct SdtUtilities.SetStablePool[]\",\"name\":\"_setStablePools\",\"type\":\"tuple[]\"}],\"name\":\"setStablePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stablePoolPerAsset\",\"outputs\":[{\"internalType\":\"contract ICrvPoolPlain\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SdtUtilities", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "250", "ConstructorArguments": "000000000000000000000000b0afc8363b8f36e0cce5d54251e20720ffaeaee7000000000000000000000000830614ae209ff9d8706d386fcdbc7a55206fcffc00000000000000000000000073968b9a57c6e53d41345fd57a6e6ae27d6cdb2f", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}