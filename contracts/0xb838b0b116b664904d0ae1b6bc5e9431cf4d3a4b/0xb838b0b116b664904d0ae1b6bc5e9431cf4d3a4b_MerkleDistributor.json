{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2021-04-03\r\n*/\r\n\r\n// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.6.7;\r\n\r\n// Allows anyone to claim a token if they exist in a merkle root\r\nabstract contract IMerkleDistributor {\r\n    // Time from the moment this contract is deployed and until the owner can withdraw leftover tokens\r\n    uint256 public constant timelapseUntilWithdrawWindow = 90 days;\r\n\r\n    // Returns the address of the token distributed by this contract\r\n    function token() virtual external view returns (address);\r\n    // Returns the merkle root of the merkle tree containing account balances available to claim\r\n    function merkleRoot() virtual external view returns (bytes32);\r\n    // Returns the timestamp when this contract was deployed\r\n    function deploymentTime() virtual external view returns (uint256);\r\n    // Returns the address for the owner of this contract\r\n    function owner() virtual external view returns (address);\r\n    // Returns true if the index has been marked claimed\r\n    function isClaimed(uint256 index) virtual external view returns (bool);\r\n    // Send tokens to an address without that address claiming them\r\n    function sendTokens(address dst, uint256 tokenAmount) virtual external;\r\n    // Claim the given amount of the token to the given address. Reverts if the inputs are invalid\r\n    function claim(uint256 index, address account, uint256 amount, bytes32[] calldata merkleProof) virtual external;\r\n\r\n    // This event is triggered whenever an address is added to the set of authed addresses\r\n    event AddAuthorization(address account);\r\n    // This event is triggered whenever an address is removed from the set of authed addresses\r\n    event RemoveAuthorization(address account);\r\n    // This event is triggered whenever a call to #claim succeeds\r\n    event Claimed(uint256 index, address account, uint256 amount);\r\n    // This event is triggered whenever some tokens are sent to an address without that address claiming them\r\n    event SendTokens(address dst, uint256 tokenAmount);\r\n}\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle trees (hash trees),\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n        bytes32 computedHash = leaf;\r\n\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n            }\r\n        }\r\n\r\n        // Check if the computed hash (root) is equal to the provided root\r\n        return computedHash == root;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract MerkleDistributor is IMerkleDistributor {\r\n    // --- Auth ---\r\n    mapping (address => uint) public authorizedAccounts;\r\n    /**\r\n     * @notice Add auth to an account\r\n     * @param account Account to add auth to\r\n     */\r\n    function addAuthorization(address account) virtual external isAuthorized {\r\n        authorizedAccounts[account] = 1;\r\n        emit AddAuthorization(account);\r\n    }\r\n    /**\r\n     * @notice Remove auth from an account\r\n     * @param account Account to remove auth from\r\n     */\r\n    function removeAuthorization(address account) virtual external isAuthorized {\r\n        authorizedAccounts[account] = 0;\r\n        emit RemoveAuthorization(account);\r\n    }\r\n    /**\r\n    * @notice Checks whether msg.sender can call an authed function\r\n    **/\r\n    modifier isAuthorized {\r\n        require(authorizedAccounts[msg.sender] == 1, \"MerkleDistributorFactory/account-not-authorized\");\r\n        _;\r\n    }\r\n    /*\r\n    * @notify Checks whether an address can send tokens out of this contract\r\n    */\r\n    modifier canSendTokens {\r\n        require(\r\n          either(authorizedAccounts[msg.sender] == 1, both(owner == msg.sender, now >= addition(deploymentTime, timelapseUntilWithdrawWindow))),\r\n          \"MerkleDistributorFactory/cannot-send-tokens\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // The token being distributed\r\n    address public immutable override token;\r\n    // The owner of this contract\r\n    address public immutable override owner;\r\n    // The merkle root of all addresses that get a distribution\r\n    bytes32 public immutable override merkleRoot;\r\n    // Timestamp when this contract was deployed\r\n    uint256 public immutable override deploymentTime;\r\n\r\n    // This is a packed array of booleans\r\n    mapping(uint256 => uint256) private claimedBitMap;\r\n\r\n    constructor(address token_, bytes32 merkleRoot_) public {\r\n        authorizedAccounts[msg.sender] = 1;\r\n        owner                          = msg.sender;\r\n        token                          = token_;\r\n        merkleRoot                     = merkleRoot_;\r\n        deploymentTime                 = now;\r\n\r\n        emit AddAuthorization(msg.sender);\r\n    }\r\n\r\n    // --- Math ---\r\n    function addition(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"MerkleDistributorFactory/add-uint-uint-overflow\");\r\n    }\r\n\r\n    // --- Boolean Logic ---\r\n    function either(bool x, bool y) internal pure returns (bool z) {\r\n        assembly{ z := or(x, y)}\r\n    }\r\n    function both(bool x, bool y) internal pure returns (bool z) {\r\n        assembly{ z := and(x, y)}\r\n    }\r\n\r\n    // --- Administration ---\r\n    /*\r\n    * @notice Send tokens to an authorized address\r\n    * @param dst The address to send tokens to\r\n    * @param tokenAmount The amount of tokens to send\r\n    */\r\n    function sendTokens(address dst, uint256 tokenAmount) external override canSendTokens {\r\n        require(dst != address(0), \"MerkleDistributorFactory/null-dst\");\r\n        IERC20(token).transfer(dst, tokenAmount);\r\n        emit SendTokens(dst, tokenAmount);\r\n    }\r\n\r\n    /*\r\n    * @notice View function returning whether an address has already claimed their tokens\r\n    * @param index The position of the address inside the merkle tree\r\n    */\r\n    function isClaimed(uint256 index) public view override returns (bool) {\r\n        uint256 claimedWordIndex = index / 256;\r\n        uint256 claimedBitIndex = index % 256;\r\n        uint256 claimedWord = claimedBitMap[claimedWordIndex];\r\n        uint256 mask = (1 << claimedBitIndex);\r\n        return claimedWord & mask == mask;\r\n    }\r\n    /*\r\n    * @notice Mark an address as having claimed their distribution\r\n    * @param index The position of the address inside the merkle tree\r\n    */\r\n    function _setClaimed(uint256 index) private {\r\n        uint256 claimedWordIndex = index / 256;\r\n        uint256 claimedBitIndex = index % 256;\r\n        claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\r\n    }\r\n    /*\r\n    * @notice Claim your distribution\r\n    * @param index The position of the address inside the merkle tree\r\n    * @param account The actual address from the tree\r\n    * @param amount The amount being distributed\r\n    * @param merkleProof The merkle path used to prove that the address is in the tree and can claim amount tokens\r\n    */\r\n    function claim(uint256 index, address account, uint256 amount, bytes32[] calldata merkleProof) external override {\r\n        require(!isClaimed(index), 'MerkleDistributor/drop-already-claimed');\r\n\r\n        // Verify the merkle proof\r\n        bytes32 node = keccak256(abi.encodePacked(index, account, amount));\r\n        require(MerkleProof.verify(merkleProof, merkleRoot, node), 'MerkleDistributor/invalid-proof');\r\n\r\n        // Mark it claimed and send the token\r\n        _setClaimed(index);\r\n        require(IERC20(token).transfer(account, amount), 'MerkleDistributor/transfer-failed');\r\n\r\n        emit Claimed(index, account, amount);\r\n    }\r\n}\r\n\r\ncontract MerkleDistributorFactory {\r\n    // --- Auth ---\r\n    mapping (address => uint) public authorizedAccounts;\r\n    /**\r\n     * @notice Add auth to an account\r\n     * @param account Account to add auth to\r\n     */\r\n    function addAuthorization(address account) virtual external isAuthorized {\r\n        authorizedAccounts[account] = 1;\r\n        emit AddAuthorization(account);\r\n    }\r\n    /**\r\n     * @notice Remove auth from an account\r\n     * @param account Account to remove auth from\r\n     */\r\n    function removeAuthorization(address account) virtual external isAuthorized {\r\n        authorizedAccounts[account] = 0;\r\n        emit RemoveAuthorization(account);\r\n    }\r\n    /**\r\n    * @notice Checks whether msg.sender can call an authed function\r\n    **/\r\n    modifier isAuthorized {\r\n        require(authorizedAccounts[msg.sender] == 1, \"MerkleDistributorFactory/account-not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Variables ---\r\n    // Number of distributors created\r\n    uint256 public nonce;\r\n    // The token that's being distributed by every merkle distributor\r\n    address public distributedToken;\r\n    // Mapping of ID => distributor address\r\n    mapping(uint256 => address) public distributors;\r\n    // Tokens left to distribute to every distributor\r\n    mapping(uint256 => uint256) public tokensToDistribute;\r\n\r\n    // --- Events ---\r\n    event AddAuthorization(address account);\r\n    event RemoveAuthorization(address account);\r\n    event DeployDistributor(uint256 id, address distributor, uint256 tokenAmount);\r\n    event SendTokensToDistributor(uint256 id);\r\n\r\n    constructor(address distributedToken_) public {\r\n        require(distributedToken_ != address(0), \"MerkleDistributorFactory/null-distributed-token\");\r\n\r\n        authorizedAccounts[msg.sender] = 1;\r\n        distributedToken               = distributedToken_;\r\n\r\n        emit AddAuthorization(msg.sender);\r\n    }\r\n\r\n    // --- Math ---\r\n    function addition(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"MerkleDistributorFactory/add-uint-uint-overflow\");\r\n    }\r\n\r\n    // --- Core Logic ---\r\n    /*\r\n    * @notice Deploy a new merkle distributor\r\n    * @param merkleRoot The merkle root used in the distributor\r\n    */\r\n    function deployDistributor(bytes32 merkleRoot, uint256 tokenAmount) external isAuthorized {\r\n        require(tokenAmount > 0, \"MerkleDistributorFactory/null-token-amount\");\r\n        nonce                     = addition(nonce, 1);\r\n        address newDistributor    = address(new MerkleDistributor(distributedToken, merkleRoot));\r\n        distributors[nonce]       = newDistributor;\r\n        tokensToDistribute[nonce] = tokenAmount;\r\n        emit DeployDistributor(nonce, newDistributor, tokenAmount);\r\n    }\r\n    /*\r\n    * @notice Send tokens to a distributor\r\n    * @param nonce The nonce/id of the distributor to send tokens to\r\n    */\r\n    function sendTokensToDistributor(uint256 id) external isAuthorized {\r\n        require(tokensToDistribute[id] > 0, \"MerkleDistributorFactory/nothing-to-send\");\r\n        uint256 tokensToSend = tokensToDistribute[id];\r\n        tokensToDistribute[id] = 0;\r\n        IERC20(distributedToken).transfer(distributors[id], tokensToSend);\r\n        emit SendTokensToDistributor(id);\r\n    }\r\n    /*\r\n    * @notice Sent distributedToken tokens out of this contract and to a custom destination\r\n    * @param dst The address that will receive tokens\r\n    * @param tokenAmount The token amount to send\r\n    */\r\n    function sendTokensToCustom(address dst, uint256 tokenAmount) external isAuthorized {\r\n        require(dst != address(0), \"MerkleDistributorFactory/null-dst\");\r\n        IERC20(distributedToken).transfer(dst, tokenAmount);\r\n    }\r\n    /*\r\n    * @notice This contract gives up on being an authorized address inside a specific distributor contract\r\n    */\r\n    function dropDistributorAuth(uint256 id) external isAuthorized {\r\n        MerkleDistributor(distributors[id]).removeAuthorization(address(this));\r\n    }\r\n    /*\r\n    * @notice Send tokens from a distributor contract to this contract\r\n    */\r\n    function getBackTokensFromDistributor(uint256 id, uint256 tokenAmount) external isAuthorized {\r\n        MerkleDistributor(distributors[id]).sendTokens(address(this), tokenAmount);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot_\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RemoveAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"SendTokens\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorizedAccounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deploymentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"sendTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timelapseUntilWithdrawWindow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MerkleDistributor", "CompilerVersion": "v0.6.7+commit.b8d736ae", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000006243d8cea23066d098a15582d81a598b4e8391f49cfc34b2b206ff564a70fe24c02951931a35160abb752a7915d6a0e1c021e2fb", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://528f15fdf759afd9c80c6e566c7284f43679cac830e946499c4a21591ba9ff27"}