{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/canvas/CanvasBounds.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.23;\\r\\n\\r\\nimport \\\"./ICanvas.sol\\\";\\r\\n\\r\\nabstract contract CanvasBounds {\\r\\n    modifier inBounds(uint8 x, uint8 y) {\\r\\n        require(x < chunksCountX, \\\"position x out of bounds\\\");\\r\\n        require(y < chunksCountY, \\\"position y out of bounds\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function getChunksCount() external pure returns (uint16 x, uint16 y) {\\r\\n        return (chunksCountX, chunksCountY);\\r\\n    }\\r\\n\\r\\n    function chunkIndex(\\r\\n        uint8 x,\\r\\n        uint8 y\\r\\n    ) public pure inBounds(x, y) returns (uint16) {\\r\\n        return chunksCountX * y + x;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/canvas/ICanvas.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.23;\\r\\n\\r\\nuint16 constant chunksCountX = 24;\\r\\nuint16 constant chunksCountY = 24;\\r\\nuint8 constant chunkPixelSize = 1;\\r\\n\\r\\ninterface ICanvas {\\r\\n    function getChunk(uint8 x, uint8 y) external view returns (uint256);\\r\\n\\r\\n    function setChunk(uint8 x, uint8 y, uint256 chunkData) external;\\r\\n\\r\\n    function setChunkByIndex(uint16 chunkIndex, uint256 chunkData) external;\\r\\n\\r\\n    function getChunks()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[chunksCountX * chunksCountY] memory);\\r\\n\\r\\n    function getBitmap() external view returns (string memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/game/Game.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.23;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"../lib/Ownable.sol\\\";\\r\\nimport \\\"../canvas/ICanvas.sol\\\";\\r\\nimport \\\"../canvas/CanvasBounds.sol\\\";\\r\\nimport \\\"../nft/IMintableNft.sol\\\";\\r\\nimport \\\"./IGame.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\r\\n\\r\\nstruct ChunkData {\\r\\n    address owner;\\r\\n    uint256 price;\\r\\n}\\r\\nstruct ChunkWriteDto {\\r\\n    uint8 x;\\r\\n    uint8 y;\\r\\n    uint256 data;\\r\\n}\\r\\n\\r\\nabstract contract GameInternal is\\r\\n    IGame,\\r\\n    CanvasBounds,\\r\\n    Ownable,\\r\\n    ReentrancyGuard\\r\\n{\\r\\n    ICanvas immutable _canvas;\\r\\n    address immutable dev;\\r\\n    IERC20 public token;\\r\\n    uint256 constant _tokenDecimals = 9;\\r\\n    uint256 public constant startChunkWritePrice = 1 * (10 ** _tokenDecimals);\\r\\n    uint256 public chunkOverridePricePercent = 10; // percent to to price to override chunk\\r\\n\\r\\n    uint256 constant startGameTimer = 86400;\\r\\n    uint256 public chunkWriteAddsGameSeconds = 60;\\r\\n    uint256 public chunksWritenCount;\\r\\n    uint256 _gameEndTime;\\r\\n    ChunkData[chunksCountX * chunksCountY] _chunks;\\r\\n    mapping(address => uint16) _ownersShare;\\r\\n\\r\\n    constructor(address canvasAddress) {\\r\\n        _canvas = ICanvas(canvasAddress);\\r\\n        dev = msg.sender;\\r\\n    }\\r\\n\\r\\n    modifier writeEnable() {\\r\\n        require(isWriteEnable(), \\\"game not started\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function start() external onlyOwner {\\r\\n        _gameEndTime = block.timestamp + startGameTimer;\\r\\n    }\\r\\n\\r\\n    function isStarted() external view returns (bool) {\\r\\n        return _gameEndTime != 0;\\r\\n    }\\r\\n\\r\\n    function gameEndTime() external view returns (uint256) {\\r\\n        return _gameEndTime;\\r\\n    }\\r\\n\\r\\n    function isGameEnd() public view returns (bool) {\\r\\n        return _gameEndTime > 0 && _gameEndTime <= block.timestamp;\\r\\n    }\\r\\n\\r\\n    function isWriteEnable() public view returns (bool) {\\r\\n        return _gameEndTime > 0 && !isGameEnd();\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    function setToken(address tokenAddress) external onlyOwner {\\r\\n        require(address(token) == address(0));\\r\\n        token = IERC20(tokenAddress);\\r\\n    }\\r\\n\\r\\n    function canvas() external view returns (address) {\\r\\n        return address(_canvas);\\r\\n    }\\r\\n\\r\\n    function writeChunks(ChunkWriteDto[] calldata input) external writeEnable {\\r\\n        uint256 cost = _writeChunksPrice(input, msg.sender);\\r\\n        token.transferFrom(msg.sender, address(this), cost);\\r\\n        for (uint256 i = 0; i < input.length; ++i) {\\r\\n            _writeChunk(input[i], msg.sender);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _writeChunk(ChunkWriteDto calldata input, address writer) private {\\r\\n        uint16 index = chunkIndex(input.x, input.y);\\r\\n        ChunkData storage chunk = _chunks[index];\\r\\n\\r\\n        address lastOwner = chunk.owner;\\r\\n        if (lastOwner != address(0)) --_ownersShare[lastOwner];\\r\\n        else ++chunksWritenCount;\\r\\n        ++_ownersShare[msg.sender];\\r\\n\\r\\n        chunk.price = _writeChunkPrice(chunk, writer);\\r\\n        chunk.owner = msg.sender;\\r\\n        _canvas.setChunkByIndex(index, input.data);\\r\\n\\r\\n        _gameEndTime += chunkWriteAddsGameSeconds;\\r\\n    }\\r\\n\\r\\n    function getChunksOwners()\\r\\n        external\\r\\n        view\\r\\n        returns (address[chunksCountX * chunksCountY] memory accs)\\r\\n    {\\r\\n        for (uint256 i = 0; i < chunksCountX * chunksCountY; ++i) {\\r\\n            accs[i] = _chunks[i].owner;\\r\\n        }\\r\\n        return accs;\\r\\n    }\\r\\n\\r\\n    function _getChunk(\\r\\n        uint8 x,\\r\\n        uint8 y\\r\\n    ) private view returns (ChunkData storage) {\\r\\n        return _chunks[chunkIndex(x, y)];\\r\\n    }\\r\\n\\r\\n    function writeChunkPrice(uint8 x, uint8 y) private view returns (uint256) {\\r\\n        return _writeChunkPrice(_getChunk(x, y), msg.sender);\\r\\n    }\\r\\n\\r\\n    function writeChunkPriceFor(\\r\\n        uint8 x,\\r\\n        uint8 y,\\r\\n        address account\\r\\n    ) private view returns (uint256) {\\r\\n        return _writeChunkPrice(_getChunk(x, y), account);\\r\\n    }\\r\\n\\r\\n    function writeChunksPriceFor(\\r\\n        address account\\r\\n    ) private view returns (uint256[] memory) {\\r\\n        uint256 size = chunksCountX * chunksCountY;\\r\\n        uint256[] memory prices = new uint256[](size);\\r\\n        for (uint256 i = 0; i < size; ++i) {\\r\\n            _writeChunkPrice(_chunks[i], account);\\r\\n        }\\r\\n        return prices;\\r\\n    }\\r\\n\\r\\n    function writeChunksPrice(\\r\\n        ChunkWriteDto[] calldata input\\r\\n    ) external view returns (uint256) {\\r\\n        return _writeChunksPrice(input, msg.sender);\\r\\n    }\\r\\n\\r\\n    function writeChunksPriceFor(\\r\\n        ChunkWriteDto[] calldata input,\\r\\n        address account\\r\\n    ) external view returns (uint256) {\\r\\n        return _writeChunksPrice(input, account);\\r\\n    }\\r\\n\\r\\n    function _writeChunkPrice(\\r\\n        ChunkData memory data,\\r\\n        address writer\\r\\n    ) private view returns (uint256) {\\r\\n        if (data.owner == writer) return 0;\\r\\n        if (data.price == 0) return startChunkWritePrice;\\r\\n        return data.price + (data.price * chunkOverridePricePercent) / 100;\\r\\n    }\\r\\n\\r\\n    function _writeChunksPrice(\\r\\n        ChunkWriteDto[] calldata data,\\r\\n        address writer\\r\\n    ) private view returns (uint256) {\\r\\n        uint256 cost;\\r\\n        for (uint256 i = 0; i < data.length; ++i) {\\r\\n            cost += _writeChunkPrice(_getChunk(data[i].x, data[i].y), writer);\\r\\n        }\\r\\n        return cost;\\r\\n    }\\r\\n\\r\\n    function getChunks()\\r\\n        external\\r\\n        view\\r\\n        returns (ChunkData[chunksCountX * chunksCountY] memory)\\r\\n    {\\r\\n        return _chunks;\\r\\n    }\\r\\n\\r\\n    function getChunkOwner(\\r\\n        uint8 x,\\r\\n        uint8 y\\r\\n    ) external view inBounds(x, y) returns (address) {\\r\\n        return _chunks[chunkIndex(x, y)].owner;\\r\\n    }\\r\\n\\r\\n    function accountShare(address acc) external view returns (uint16) {\\r\\n        return _ownersShare[acc];\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract Auction is GameInternal {\\r\\n    IMintableNft public nft;\\r\\n    uint256 constant auctionStartTimer = 86400;\\r\\n    uint256 public constant auctionBidAddsTimer = 60;\\r\\n    uint256 public constant auctionBidStepShare = 5;\\r\\n    uint256 public constant auctionBidStepPrecesion = 100;\\r\\n    address public bidAddress;\\r\\n    uint256 public bidEther = 1e16 - 1; // starts 0.01 ether\\r\\n    uint256 public auctionEndTime;\\r\\n    uint256 public etherToClaimTotal;\\r\\n    uint256 public tokenToClaimTotal;\\r\\n\\r\\n    constructor(address canvasAddress) GameInternal(canvasAddress) {}\\r\\n\\r\\n    modifier whenAuction() {\\r\\n        require(isAuction(), \\\"auction is not started\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setNft(address nftAddress) external onlyOwner {\\r\\n        require(address(nft) == address(0));\\r\\n        nft = IMintableNft(nftAddress);\\r\\n    }\\r\\n\\r\\n    function isAuction() public view returns (bool) {\\r\\n        if (!isGameEnd()) return false;\\r\\n        return auctionEndTime == 0 || block.timestamp < auctionEndTime;\\r\\n    }\\r\\n\\r\\n    function isAuctionEnd() public view returns (bool) {\\r\\n        return auctionEndTime > 0 && auctionEndTime <= block.timestamp;\\r\\n    }\\r\\n\\r\\n    function newBidEtherMin() public view returns (uint256) {\\r\\n        return (bidEther * auctionBidStepShare) / auctionBidStepPrecesion;\\r\\n    }\\r\\n\\r\\n    function makeBid() external payable {\\r\\n        require(isAuction(), \\\"no auction time\\\");\\r\\n        require(msg.value > newBidEtherMin(), \\\"bid is too low\\\");\\r\\n        if (bidAddress != address(0)) _sendEther(bidAddress, bidEther);\\r\\n        bidAddress = msg.sender;\\r\\n        bidEther = msg.value;\\r\\n        if (auctionEndTime == 0)\\r\\n            auctionEndTime = block.timestamp + auctionStartTimer;\\r\\n        else auctionEndTime += auctionBidAddsTimer;\\r\\n    }\\r\\n\\r\\n    function _sendEther(address to, uint256 count) internal nonReentrant {\\r\\n        if (count == 0) return;\\r\\n        (bool sentFee, ) = payable(to).call{value: count}(\\\"\\\");\\r\\n        require(sentFee, \\\"sent fee error: ether is not sent\\\");\\r\\n    }\\r\\n\\r\\n    function claimNft() public {\\r\\n        require(isAuctionEnd(), \\\"auction still continue\\\");\\r\\n        require(!isNftClaimed(), \\\"nft already claimed\\\");\\r\\n        nft.transfer(bidAddress);\\r\\n        _sendEther(dev, bidEther / 5);\\r\\n        etherToClaimTotal = address(this).balance;\\r\\n        tokenToClaimTotal = token.balanceOf(address(this));\\r\\n    }\\r\\n\\r\\n    function isNftClaimed() public view returns (bool) {\\r\\n        return nft.isTransferred();\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Game is Auction {\\r\\n    mapping(address => bool) public isClaimed;\\r\\n\\r\\n    constructor(address canvasAddress) Auction(canvasAddress) {}\\r\\n\\r\\n    function claim() external {\\r\\n        require(isAuctionEnd(), \\\"auction still continue\\\");\\r\\n        if (!isNftClaimed()) claimNft();\\r\\n\\r\\n        require(!isClaimed[msg.sender], \\\"already claimed\\\");\\r\\n        isClaimed[msg.sender] = true;\\r\\n        uint256 share = _ownersShare[msg.sender];\\r\\n        require(share > 0, \\\"account share is 0\\\");\\r\\n        _sendEther(msg.sender, (etherToClaimTotal * share) / chunksWritenCount);\\r\\n        token.transfer(\\r\\n            address(0),\\r\\n            //msg.sender,\\r\\n            (tokenToClaimTotal * share) / chunksWritenCount\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/game/IGame.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.23;\\r\\n\\r\\ninterface IGame {\\r\\n    function isStarted() external view returns (bool);\\r\\n\\r\\n    function gameEndTime() external view returns (uint256);\\r\\n\\r\\n    function isGameEnd() external view returns (bool);\\r\\n\\r\\n    function isWriteEnable() external view returns (bool);\\r\\n\\r\\n    function isAuction() external view returns (bool);\\r\\n\\r\\n    function isAuctionEnd() external view returns (bool);\\r\\n\\r\\n    function isNftClaimed() external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.23;\\r\\n\\r\\ncontract Ownable {\\r\\n    address _owner;\\r\\n\\r\\n    event RenounceOwnership();\\r\\n\\r\\n    constructor() {\\r\\n        _owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == msg.sender, \\\"only owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function owner() external view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    function ownerRenounce() public onlyOwner {\\r\\n        _owner = address(0);\\r\\n        emit RenounceOwnership();\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) external onlyOwner {\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/nft/IMintableNft.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.23;\\r\\n\\r\\ninterface IMintableNft {\\r\\n    function transfer(address to) external;\\r\\n\\r\\n    function isTransferred() external view returns (bool);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"canvasAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RenounceOwnership\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acc\",\"type\":\"address\"}],\"name\":\"accountShare\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionBidAddsTimer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionBidStepPrecesion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionBidStepShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bidAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bidEther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canvas\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"x\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"y\",\"type\":\"uint8\"}],\"name\":\"chunkIndex\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chunkOverridePricePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chunkWriteAddsGameSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chunksWritenCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimNft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"etherToClaimTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"x\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"y\",\"type\":\"uint8\"}],\"name\":\"getChunkOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChunks\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct ChunkData[576]\",\"name\":\"\",\"type\":\"tuple[576]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChunksCount\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"x\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"y\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChunksOwners\",\"outputs\":[{\"internalType\":\"address[576]\",\"name\":\"accs\",\"type\":\"address[576]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAuction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAuctionEnd\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isGameEnd\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNftClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isWriteEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"makeBid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newBidEtherMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nft\",\"outputs\":[{\"internalType\":\"contract IMintableNft\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerRenounce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"}],\"name\":\"setNft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startChunkWritePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenToClaimTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"x\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"y\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"internalType\":\"struct ChunkWriteDto[]\",\"name\":\"input\",\"type\":\"tuple[]\"}],\"name\":\"writeChunks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"x\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"y\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"internalType\":\"struct ChunkWriteDto[]\",\"name\":\"input\",\"type\":\"tuple[]\"}],\"name\":\"writeChunksPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"x\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"y\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"internalType\":\"struct ChunkWriteDto[]\",\"name\":\"input\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"writeChunksPriceFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Game", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008f506eaf9354aee0dd4460505fef7d75a9d5eb60", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}