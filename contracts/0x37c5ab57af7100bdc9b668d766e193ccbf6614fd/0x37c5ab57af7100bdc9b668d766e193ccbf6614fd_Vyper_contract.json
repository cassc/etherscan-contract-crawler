{"SourceCode": "# @version 0.3.7\r\n\r\n# A \"zap\" for crypto pools to get_dx\r\n# (c) Curve.Fi, 2023\r\n\r\ninterface ERC20:\r\n    def decimals() -> uint256: view\r\n\r\ninterface Curve:\r\n    def A() -> uint256: view\r\n    def gamma() -> uint256: view\r\n    def price_scale(i: uint256) -> uint256: view\r\n    def coins(i: uint256) -> address: view\r\n    def balances(i: uint256) -> uint256: view\r\n    def D() -> uint256: view\r\n    def fee_calc(xp: uint256[3]) -> uint256: view\r\n    def future_A_gamma_time() -> uint256: view\r\n\r\ninterface Curve2:\r\n    def price_scale() -> uint256: view\r\n\r\ninterface Math3:\r\n    def newton_D(ANN: uint256, gamma: uint256, x_unsorted: uint256[3]) -> uint256: view\r\n    def newton_y(ANN: uint256, gamma: uint256, x: uint256[3], D: uint256, i: uint256) -> uint256: view\r\n\r\ninterface Math2:\r\n    def newton_D(ANN: uint256, gamma: uint256, x_unsorted: uint256[2]) -> uint256: view\r\n    def newton_y(ANN: uint256, gamma: uint256, x: uint256[2], D: uint256, i: uint256) -> uint256: view\r\n    def fee_calc(pool: address, xp: uint256[2]) -> uint256: view\r\n\r\ninterface StablePool:\r\n    def calc_withdraw_one_coin(_token_amount: uint256, i: int128) -> uint256: view\r\n\r\ninterface StableCalcZap:\r\n    def calc_token_amount(pool: address, token: address, amounts: uint256[MAX_COINS], n_coins: uint256, deposit: bool, use_underlying: bool) -> uint256: view\r\n    def get_dx_underlying(pool: address, i: int128, j: int128, dy: uint256, n_coins: uint256) -> uint256: view\r\n\r\ninterface AtricryptoZap:\r\n    def calc_token_amount(amounts: uint256[5], deposit: bool) -> uint256: view\r\n    def calc_withdraw_one_coin(token_amount: uint256, i: uint256) -> uint256: view\r\n\r\n\r\nSTABLE_CALC_ZAP: constant(address) = 0xCA8d0747B5573D69653C3aC22242e6341C36e4b4\r\nMATH2: constant(address) = 0x69522fb5337663d3B4dFB0030b881c1A750Adb4f\r\nMATH3: constant(address) = 0x4f37A9d177470499A2dD084621020b023fcffc1F\r\nMAX_COINS: constant(uint256) = 10\r\nPRECISION: constant(uint256) = 10**18  # The precision to convert to\r\n\r\n\r\n@internal\r\n@view\r\ndef _get_dx_2_coins(\r\n        pool: address,\r\n        i: uint256,\r\n        j: uint256,\r\n        dy: uint256,\r\n        xp: DynArray[uint256, MAX_COINS],\r\n        precisions: DynArray[uint256, MAX_COINS],\r\n        price_scale: DynArray[uint256, MAX_COINS],\r\n) -> uint256:\r\n    A: uint256 = Curve(pool).A()\r\n    gamma: uint256 = Curve(pool).gamma()\r\n    D: uint256 = Curve(pool).D()\r\n    _xp_initial: uint256[2] = [\r\n        xp[0] * precisions[0],\r\n        xp[1] * price_scale[0] * precisions[1] / PRECISION,\r\n    ]\r\n    if Curve(pool).future_A_gamma_time() > 0:\r\n        D = Math2(MATH2).newton_D(A, gamma, _xp_initial)\r\n\r\n    _fee: uint256 = 0\r\n    x: uint256 = 0\r\n    for k in range(10):\r\n        _xp: uint256[2] = [xp[0], xp[1]]\r\n        _xp[j] -= dy * 10 ** 10 / (10 ** 10 - _fee)\r\n        _xp[0] *= precisions[0]\r\n        _xp[1] = _xp[1] * price_scale[0] * precisions[1] / PRECISION\r\n        x = Math2(MATH2).newton_y(A, gamma, _xp, D, i)\r\n        _xp[i] = x\r\n        _fee = Math2(MATH2).fee_calc(pool, _xp)\r\n\r\n    dx: uint256 = x - _xp_initial[i] + 1\r\n    if i > 0:\r\n        dx = dx * PRECISION / price_scale[i - 1]\r\n    dx /= precisions[i]\r\n\r\n    return dx\r\n\r\n\r\n@internal\r\n@view\r\ndef _get_dx_3_coins(\r\n        pool: address,\r\n        i: uint256,\r\n        j: uint256,\r\n        dy: uint256,\r\n        xp: DynArray[uint256, MAX_COINS],\r\n        precisions: DynArray[uint256, MAX_COINS],\r\n        price_scale: DynArray[uint256, MAX_COINS],\r\n) -> uint256:\r\n    A: uint256 = Curve(pool).A()\r\n    gamma: uint256 = Curve(pool).gamma()\r\n    D: uint256 = Curve(pool).D()\r\n    _xp_initial: uint256[3] = [\r\n        xp[0] * precisions[0],\r\n        xp[1] * price_scale[0] * precisions[1] / PRECISION,\r\n        xp[2] * price_scale[1] * precisions[2] / PRECISION,\r\n    ]\r\n    if Curve(pool).future_A_gamma_time() > 0:\r\n        D = Math3(MATH3).newton_D(A, gamma, _xp_initial)\r\n\r\n    # Calc new balances without fees\r\n\r\n    _fee: uint256 = 0\r\n    x: uint256 = 0\r\n    for k in range(10):\r\n        _xp: uint256[3] = [xp[0], xp[1], xp[2]]\r\n        _xp[j] -= dy * 10**10 / (10**10 - _fee)\r\n        _xp[0] *= precisions[0]\r\n        _xp[1] = _xp[1] * price_scale[0] * precisions[1] / PRECISION\r\n        _xp[2] = _xp[2] * price_scale[1] * precisions[2] / PRECISION\r\n        x = Math3(MATH3).newton_y(A, gamma, _xp, D, i)\r\n        _xp[i] = x\r\n        _fee = Curve(pool).fee_calc(_xp)\r\n\r\n    dx: uint256 = x - _xp_initial[i] + 1\r\n    if i > 0:\r\n        dx = dx * PRECISION / price_scale[i - 1]\r\n    dx /= precisions[i]\r\n\r\n    return dx\r\n\r\n\r\n@internal\r\n@view\r\ndef _get_dx(pool: address, i: uint256, j: uint256, dy: uint256, n_coins: uint256) -> uint256:\r\n    assert i != j and i < MAX_COINS and j < MAX_COINS, \"coin index out of range\"\r\n    assert dy > 0, \"do not exchange 0 coins\"\r\n\r\n    precisions: DynArray[uint256, MAX_COINS] = []\r\n    xp: DynArray[uint256, MAX_COINS] = []\r\n    for k in range(MAX_COINS):\r\n        if k == n_coins:\r\n            break\r\n        xp.append(Curve(pool).balances(k))\r\n        coin: address = Curve(pool).coins(k)\r\n        precisions.append(10**(18 - ERC20(coin).decimals()))\r\n\r\n    price_scale: DynArray[uint256, MAX_COINS] = []\r\n    for k in range(MAX_COINS):\r\n        if k == n_coins - 1:\r\n            break\r\n        if n_coins == 2:\r\n            price_scale.append(Curve2(pool).price_scale())\r\n            break\r\n        price_scale.append(Curve(pool).price_scale(k))\r\n\r\n    if n_coins == 3:\r\n        return self._get_dx_3_coins(pool, i, j, dy, xp, precisions, price_scale)\r\n    else:\r\n        return self._get_dx_2_coins(pool, i, j, dy, xp, precisions, price_scale)\r\n\r\n\r\n@external\r\n@view\r\ndef get_dx(pool: address, i: uint256, j: uint256, dy: uint256, n_coins: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the input amount required to receive the desired output amount.\r\n    @param pool Address of the pool\r\n    @param i Input coin index\r\n    @param j Output coin index\r\n    @param dy Desired amount of the coin going out\r\n    @param n_coins Number of coins in the pool\r\n    @return Required input amount\r\n    \"\"\"\r\n    return self._get_dx(pool, i, j, dy, n_coins)\r\n\r\n\r\n@external\r\n@view\r\ndef get_dx_meta_underlying(pool: address, i: uint256, j: uint256, dy: uint256, n_coins: uint256, base_pool: address, base_token: address) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the input amount required to receive the desired output amount.\r\n            For underlying calculations in meta pool of a type [coin, stable-pool-LP].\r\n    @param pool Address of the pool\r\n    @param i Input coin index\r\n    @param j Output coin index\r\n    @param dy Desired amount of the coin going out\r\n    @param n_coins Number of coins in the pool\r\n    @param base_pool Address of the base pool\r\n    @param base_token Address of the base pool's LP token\r\n    @return Required input amount\r\n    \"\"\"\r\n    # [coin] + [...n_meta_coins...]\r\n    if i > 0 and j > 0:  # meta_coin1 -> meta_coin2\r\n        return StableCalcZap(STABLE_CALC_ZAP).get_dx_underlying(base_pool, convert(i - 1, int128), convert(j - 1, int128), dy, n_coins - 1)\r\n    elif i == 0:  # coin -> meta_coin\r\n        # coin -(swap)-> LP -(remove)-> meta_coin (dy - meta_coin)\r\n        # 1. lp_amount = calc_token_amount([..., dy, ...], deposit=False)\r\n        # 2. dx = get_dx(0, 1, lp_amount)\r\n        base_amounts: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n        base_amounts[j - 1] = dy\r\n        lp_amount: uint256 = StableCalcZap(STABLE_CALC_ZAP).calc_token_amount(base_pool, base_token, base_amounts, n_coins - 1, False, True)\r\n        return self._get_dx(pool, 0, 1, lp_amount, 2)\r\n    else:  # j == 0, meta_coin -> coin\r\n        # meta_coin -(add)-> LP -(swap)-> coin (dy - coin)\r\n        # 1. lp_amount = get_dx(1, 0, dy)\r\n        # 2. dx = calc_withdraw_one_coin(lp_amount, i - 1)\r\n        lp_amount: uint256 = self._get_dx(pool, 1, 0, dy, 2)\r\n        # This is not right. Should be something like calc_add_one_coin. But tests say that it's precise enough.\r\n        return StablePool(base_pool).calc_withdraw_one_coin(lp_amount, convert(i - 1, int128))\r\n\r\n\r\n@internal\r\n@view\r\ndef _get_dx_tricrypto_meta_underlying(pool: address, i: uint256, j: uint256, dy: uint256, n_coins: uint256, base_pool: address, base_token: address) -> uint256:\r\n    # [...n_meta_coins...] + [coin1, coin2]\r\n    n_meta_coins: uint256 = n_coins - 2\r\n    if i < n_meta_coins and j < n_meta_coins:  # meta_coin1 -> meta_coin2\r\n        return StableCalcZap(STABLE_CALC_ZAP).get_dx_underlying(base_pool, convert(i, int128), convert(j, int128), dy, n_meta_coins)\r\n    elif i >= n_meta_coins and j >= n_meta_coins:  # coin1 -> coin2\r\n        return self._get_dx(pool, i - n_meta_coins + 1, j - n_meta_coins + 1, dy, 3)\r\n    elif i >= n_meta_coins:  # coin -> meta_coin\r\n        # coin -(swap)-> LP -(remove)-> meta_coin (dy - meta_coin)\r\n        # 1. lp_amount = calc_token_amount([..., dy, ...], deposit=False)\r\n        # 2. dx = get_dx(1 or 2, 0, lp_amount)\r\n        base_amounts: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n        base_amounts[j] = dy\r\n        lp_amount: uint256 = StableCalcZap(STABLE_CALC_ZAP).calc_token_amount(base_pool, base_token, base_amounts, n_meta_coins, False, True)\r\n        return self._get_dx(pool, i - n_meta_coins + 1, 0, lp_amount, 3)\r\n    else:  # j >= n_meta_coins, meta_coin -> coin\r\n        # meta_coin -(add)-> LP -(swap)-> coin (dy - coin)\r\n        # 1. lp_amount = get_dx(0, 1 or 2, dy)\r\n        # 2. dx = calc_withdraw_one_coin(lp_amount, i - 1)\r\n        lp_amount: uint256 = self._get_dx(pool, 0, j - n_meta_coins + 1, dy, 3)\r\n        # This is not right. Should be something like calc_add_one_coin. But tests say that it's precise enough.\r\n        return StablePool(base_pool).calc_withdraw_one_coin(lp_amount, convert(i, int128))\r\n\r\n\r\n@external\r\n@view\r\ndef get_dx_tricrypto_meta_underlying(pool: address, i: uint256, j: uint256, dy: uint256, n_coins: uint256, base_pool: address, base_token: address) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the input amount required to receive the desired output amount.\r\n            For underlying calculations in meta pool of a type [stable-pool-LP, coin1, coin2].\r\n            xDAI (Gnosis): tricrypto\r\n            Polygon: atricrypto3\r\n            Avalanche: atricrypto, avaxcrypto\r\n    @param pool Address of the pool\r\n    @param i Input coin index\r\n    @param j Output coin index\r\n    @param dy Desired amount of the coin going out\r\n    @param n_coins Number of coins in the pool\r\n    @param base_pool Address of the base pool\r\n    @param base_token Address of the base pool's LP token\r\n    @return Required input amount\r\n    \"\"\"\r\n    return self._get_dx_tricrypto_meta_underlying(pool, i, j, dy, n_coins, base_pool, base_token)\r\n\r\n\r\n@external\r\n@view\r\ndef get_dx_double_meta_underlying(\r\n        pool: address,\r\n        i: uint256,\r\n        j: uint256,\r\n        dy: uint256,\r\n        base_pool: address,\r\n        base_pool_zap: address,\r\n        second_base_pool: address,\r\n        second_base_token: address,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the input amount required to receive the desired output amount.\r\n            For underlying calculations in double meta pool of a type [coin, tricrypto-meta-pool-LP].\r\n            Polygon: crv/tricrypto and wmatic/tricrypto.\r\n    @param pool Address of the pool\r\n    @param i Input coin index\r\n    @param j Output coin index\r\n    @param dy Desired amount of the coin going out\r\n    @param base_pool Address of the base pool\r\n    @param base_pool_zap Address of the base pool's zap for underlying calc_token_amount\r\n    @param second_base_pool Address of the second base pool\r\n    @param second_base_token Address of the second base pool's LP token\r\n    @return Required input amount\r\n    \"\"\"\r\n    # [coin] + [...n_meta_coins...]\r\n    if i > 0 and j > 0:  # meta_coin1 -> meta_coin2\r\n        return self._get_dx_tricrypto_meta_underlying(base_pool, i - 1, j - 1, dy, 5, second_base_pool, second_base_token)\r\n    elif i == 0:  # coin -> meta_coin\r\n        # coin -(swap)-> LP -(remove)-> meta_coin (dy - meta_coin)\r\n        # 1. lp_amount = calc_token_amount([..., dy, ...], deposit=False)\r\n        # 2. dx = get_dx(0, 1, lp_amount)\r\n        base_amounts: uint256[5] = empty(uint256[5])\r\n        base_amounts[j - 1] = dy\r\n        lp_amount: uint256 = AtricryptoZap(base_pool_zap).calc_token_amount(base_amounts, False)\r\n        return self._get_dx(pool, 0, 1, lp_amount, 2)\r\n    else:  # j == 0, meta_coin -> coin\r\n        # meta_coin -(add)-> LP -(swap)-> coin (dy - coin)\r\n        # 1. lp_amount = get_dx(1, 0, dy)\r\n        # 2. dx = calc_withdraw_one_coin(lp_amount, i - 1)\r\n        lp_amount: uint256 = self._get_dx(pool, 1, 0, dy, 2)\r\n        # This is not right. Should be something like calc_add_one_coin. But tests say that it's precise enough.\r\n        return AtricryptoZap(base_pool_zap).calc_withdraw_one_coin(lp_amount, i - 1)", "ABI": "[{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dx\",\"inputs\":[{\"name\":\"pool\",\"type\":\"address\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dy\",\"type\":\"uint256\"},{\"name\":\"n_coins\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dx_meta_underlying\",\"inputs\":[{\"name\":\"pool\",\"type\":\"address\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dy\",\"type\":\"uint256\"},{\"name\":\"n_coins\",\"type\":\"uint256\"},{\"name\":\"base_pool\",\"type\":\"address\"},{\"name\":\"base_token\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dx_tricrypto_meta_underlying\",\"inputs\":[{\"name\":\"pool\",\"type\":\"address\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dy\",\"type\":\"uint256\"},{\"name\":\"n_coins\",\"type\":\"uint256\"},{\"name\":\"base_pool\",\"type\":\"address\"},{\"name\":\"base_token\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dx_double_meta_underlying\",\"inputs\":[{\"name\":\"pool\",\"type\":\"address\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dy\",\"type\":\"uint256\"},{\"name\":\"base_pool\",\"type\":\"address\"},{\"name\":\"base_pool_zap\",\"type\":\"address\"},{\"name\":\"second_base_pool\",\"type\":\"address\"},{\"name\":\"second_base_token\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.3.7", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}