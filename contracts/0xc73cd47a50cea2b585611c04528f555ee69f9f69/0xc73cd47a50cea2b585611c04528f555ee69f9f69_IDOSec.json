{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/IDOSec/IDOSec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\nimport \\\"../interfaces/IDOSec/IIDOSecController.sol\\\";\\n\\n/** @title IDO contract does IDO\\n * @notice\\n */\\n\\ncontract IDOSec is Ownable, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n\\n    struct User {\\n        uint256 totalFunded; // total funded amount of user\\n        uint256 released; // currently released token amount\\n    }\\n\\n    uint256 public constant ROUNDS_COUNT = 2; // 1: whitelist, 2: fcfs\\n\\n    IIDOSecController public controller;\\n\\n    uint256 public startTime;\\n    uint256 public endTime;\\n    uint256 public claimTime;\\n\\n    IERC20 public saleToken;\\n    uint256 public saleTarget;\\n    uint256 public saleRaised;\\n\\n    // 0x0 BNB, other: BEP20\\n    address public fundToken;\\n    uint256 public fundTarget;\\n    uint256 public fundRaised;\\n    uint256 public totalReleased;\\n\\n    //\\n    uint256 public fcfsAmount; // users' fcfs allocation\\n    uint256 public minFundAmount;\\n\\n    string public meta; // meta data json url\\n\\n    // all funder Addresses\\n    address[] public funderAddresses;\\n\\n    mapping(address => User) public whitelistFunders;\\n\\n    mapping(address => User) public fcfsFunders;\\n\\n    // vesting info\\n    uint256 public cliffTime;\\n    // 15 = 1.5%, 1000 = 100%\\n    uint256 public distributePercentAtClaim;\\n    uint256 public vestingDuration;\\n    uint256 public vestingPeriodicity;\\n\\n    // whitelist\\n    mapping(address => uint256) public whitelistAmount;\\n\\n    mapping(uint256 => uint256) public roundsFundRaised;\\n\\n    event IDOInitialized(uint256 saleTarget, address fundToken, uint256 fundTarget);\\n\\n    event IDOBaseDataChanged(\\n        uint256 startTime,\\n        uint256 endTime,\\n        uint256 claimTime,\\n        uint256 minFundAmount,\\n        uint256 fcfsAmount,\\n        string meta\\n    );\\n\\n    event IDOTokenInfoChanged(uint256 saleTarget, uint256 fundTarget);\\n\\n    event SaleTokenAddressSet(address saleToken);\\n\\n    event VestingSet(\\n        uint256 cliffTime,\\n        uint256 distributePercentAtClaim,\\n        uint256 vestingDuration,\\n        uint256 vestingPeriodicity\\n    );\\n\\n    event IDOProgressChanged(address buyer, uint256 amount, uint256 fundRaised, uint256 saleRaised, uint256 roundId);\\n\\n    event IDOClaimed(address to, uint256 amount);\\n\\n    modifier isOperatorOrOwner() {\\n        require(controller.isOperator(msg.sender) || owner() == msg.sender, \\\"Not owner or operator\\\");\\n\\n        _;\\n    }\\n\\n    modifier isNotStarted() {\\n        require(startTime > block.timestamp, \\\"Already started\\\");\\n\\n        _;\\n    }\\n\\n    modifier isOngoing() {\\n        require(startTime <= block.timestamp && block.timestamp <= endTime, \\\"Not onging\\\");\\n\\n        _;\\n    }\\n\\n    modifier isEnded() {\\n        require(block.timestamp >= endTime, \\\"Not ended\\\");\\n\\n        _;\\n    }\\n\\n    modifier isNotEnded() {\\n        require(block.timestamp < endTime, \\\"Ended\\\");\\n\\n        _;\\n    }\\n\\n    modifier isClaimable() {\\n        require(block.timestamp >= claimTime, \\\"Not claimable\\\");\\n\\n        _;\\n    }\\n\\n    modifier onlyEOA() {\\n        require(tx.origin == msg.sender, \\\"should be EOA\\\");\\n        _;\\n    }\\n\\n    modifier canRaise(address addr, uint256 amount) {\\n        uint256 currentRoundId = getCurrentRoundId();\\n\\n        uint256 maxAllocation = getMaxAllocation(addr);\\n\\n        require(amount > 0, \\\"0 amount\\\");\\n\\n        require(fundRaised + amount <= fundTarget, \\\"Target hit!\\\");\\n\\n        uint256 personalTotal;\\n        if (currentRoundId == 1) {\\n            personalTotal = amount + whitelistFunders[addr].totalFunded;\\n        } else if (currentRoundId == 2) {\\n            personalTotal = amount + fcfsFunders[addr].totalFunded;\\n        }\\n\\n        require(personalTotal >= minFundAmount, \\\"Low amount\\\");\\n        require(personalTotal <= maxAllocation, \\\"Too much amount\\\");\\n\\n        _;\\n    }\\n\\n    /**\\n     * @notice constructor\\n     *\\n     * @param _controller {address} Controller address\\n     * @param _saleTarget {uint256} Total token amount to sell\\n     * @param _fundToken {address} Fund token address\\n     * @param _fundTarget {uint256} Total amount of fund Token\\n     */\\n    constructor(\\n        IIDOSecController _controller,\\n        uint256 _saleTarget,\\n        address _fundToken,\\n        uint256 _fundTarget\\n    ) {\\n        require(address(_controller) != address(0), \\\"Invalid\\\");\\n        require(_saleTarget > 0 && _fundTarget > 0, \\\"Invalid\\\");\\n\\n        saleTarget = _saleTarget;\\n\\n        fundToken = _fundToken;\\n        fundTarget = _fundTarget;\\n\\n        controller = _controller;\\n\\n        emit IDOInitialized(saleTarget, fundToken, fundTarget);\\n    }\\n\\n    /**\\n     * @notice setBaseData\\n     *\\n     * @param _startTime {uint256}  timestamp of IDO start time\\n     * @param _endTime {uint256}  timestamp of IDO end time\\n     * @param _claimTime {uint256}  timestamp of IDO claim time\\n     * @param _minFundAmount {uint256}  mimimum fund amount of users\\n     * @param _fcfsAmount {uint256}  fcfsAmount of buy\\n     * @param _meta {string}  url of meta data\\n     */\\n    function setBaseData(\\n        uint256 _startTime,\\n        uint256 _endTime,\\n        uint256 _claimTime,\\n        uint256 _minFundAmount,\\n        uint256 _fcfsAmount,\\n        string memory _meta\\n    ) external isOperatorOrOwner {\\n        require(_minFundAmount > 0, \\\"0 minFund\\\");\\n        require(_fcfsAmount > 0, \\\"0 base\\\");\\n\\n        require(_startTime > block.timestamp && _startTime < _endTime && _endTime < _claimTime, \\\"Invalid times\\\");\\n\\n        startTime = _startTime;\\n        endTime = _endTime;\\n        claimTime = _claimTime;\\n        minFundAmount = _minFundAmount;\\n        meta = _meta;\\n        fcfsAmount = _fcfsAmount;\\n\\n        emit IDOBaseDataChanged(startTime, endTime, claimTime, minFundAmount, fcfsAmount, meta);\\n    }\\n\\n    function getCurrentRoundId() public view returns (uint256) {\\n        if (block.timestamp < startTime || block.timestamp > endTime) {\\n            return 0; // not started\\n        }\\n        uint256 roundDuration = (endTime - startTime) / ROUNDS_COUNT;\\n        uint256 index = (block.timestamp - startTime) / roundDuration;\\n\\n        // 1: white, 2: fcfs\\n\\n        return index + 1;\\n    }\\n\\n    function getRoundTotalAllocation(uint256 currentRoundId) public view returns (uint256) {\\n        if (currentRoundId == 0) {\\n            return 0;\\n        }\\n        if (currentRoundId == 1) {\\n            return fundTarget;\\n        }\\n        return fundTarget - roundsFundRaised[1];\\n    }\\n\\n    function getMaxAllocation(address addr) public view returns (uint256) {\\n        uint256 currentRoundId = getCurrentRoundId();\\n\\n        if (currentRoundId == 0) {\\n            return 0;\\n        }\\n\\n        if (currentRoundId == 1) {\\n            // whitelist period\\n            return whitelistAmount[addr];\\n        }\\n\\n        return fcfsAmount;\\n    }\\n\\n    function getFundersCount() external view returns (uint256) {\\n        return funderAddresses.length;\\n    }\\n\\n    function getFunderInfo(address funder) external view returns (User memory) {\\n        User memory info;\\n\\n        info.totalFunded = whitelistFunders[funder].totalFunded + fcfsFunders[funder].totalFunded;\\n\\n        info.released = whitelistFunders[funder].released + fcfsFunders[funder].released;\\n\\n        return info;\\n    }\\n\\n    function setStartTime(uint256 _startTime) external isOperatorOrOwner isNotStarted {\\n        require(_startTime > block.timestamp, \\\"Invalid\\\");\\n        startTime = _startTime;\\n\\n        emit IDOBaseDataChanged(startTime, endTime, claimTime, minFundAmount, fcfsAmount, meta);\\n    }\\n\\n    function setEndTime(uint256 _endTime) external isOperatorOrOwner isNotEnded {\\n        require(_endTime > block.timestamp && _endTime > startTime, \\\"Invalid\\\");\\n\\n        endTime = _endTime;\\n\\n        emit IDOBaseDataChanged(startTime, endTime, claimTime, minFundAmount, fcfsAmount, meta);\\n    }\\n\\n    function setClaimTime(uint256 _claimTime) external isOperatorOrOwner {\\n        require(_claimTime > block.timestamp && _claimTime > endTime, \\\"Invalid\\\");\\n\\n        claimTime = _claimTime;\\n\\n        emit IDOBaseDataChanged(startTime, endTime, claimTime, minFundAmount, fcfsAmount, meta);\\n    }\\n\\n    function setFcFsAmount(uint256 _fcfsAmount) external isOperatorOrOwner {\\n        require(_fcfsAmount > 0, \\\"Invalid\\\");\\n\\n        fcfsAmount = _fcfsAmount;\\n\\n        emit IDOBaseDataChanged(startTime, endTime, claimTime, minFundAmount, fcfsAmount, meta);\\n    }\\n\\n    function setMinFundAmount(uint256 _minFundAmount) external isOperatorOrOwner {\\n        require(_minFundAmount > 0, \\\"Invalid\\\");\\n\\n        minFundAmount = _minFundAmount;\\n\\n        emit IDOBaseDataChanged(startTime, endTime, claimTime, minFundAmount, fcfsAmount, meta);\\n    }\\n\\n    function setMeta(string memory _meta) external isOperatorOrOwner {\\n        meta = _meta;\\n\\n        emit IDOBaseDataChanged(startTime, endTime, claimTime, minFundAmount, fcfsAmount, meta);\\n    }\\n\\n    function setSaleToken(IERC20 _saleToken) external isOperatorOrOwner {\\n        require(address(_saleToken) != address(0), \\\"Invalid\\\");\\n\\n        saleToken = _saleToken;\\n        emit SaleTokenAddressSet(address(saleToken));\\n    }\\n\\n    function setSaleTarget(uint256 _saleTarget) external isOperatorOrOwner {\\n        require(_saleTarget > 0, \\\"Invalid\\\");\\n        saleTarget = _saleTarget;\\n        emit IDOTokenInfoChanged(saleTarget, fundTarget);\\n    }\\n\\n    function setFundTarget(uint256 _fundTarget) external isOperatorOrOwner {\\n        require(_fundTarget > 0, \\\"Invalid\\\");\\n        fundTarget = _fundTarget;\\n        emit IDOTokenInfoChanged(saleTarget, fundTarget);\\n    }\\n\\n    function setVestingInfo(\\n        uint256 _cliffTime,\\n        uint256 _distributePercentAtClaim,\\n        uint256 _vestingDuration,\\n        uint256 _vestingPeriodicity\\n    ) external isOperatorOrOwner {\\n        require(_cliffTime > claimTime, \\\"Invalid Cliff\\\");\\n        require(_distributePercentAtClaim <= 1000, \\\"Invalid tge\\\");\\n        require(_vestingDuration > 0 && _vestingPeriodicity > 0, \\\"0 Duration or Period\\\");\\n        require(\\n            (_vestingDuration - (_vestingDuration / _vestingPeriodicity) * _vestingPeriodicity) == 0,\\n            \\\"Not divided\\\"\\n        );\\n\\n        cliffTime = _cliffTime;\\n        distributePercentAtClaim = _distributePercentAtClaim;\\n        vestingDuration = _vestingDuration;\\n        vestingPeriodicity = _vestingPeriodicity;\\n\\n        emit VestingSet(cliffTime, distributePercentAtClaim, vestingDuration, vestingPeriodicity);\\n    }\\n\\n    function withdrawRemainingSaleToken() external isOperatorOrOwner {\\n        require(block.timestamp > endTime, \\\"IDO has not yet ended\\\");\\n        saleToken.safeTransfer(msg.sender, saleToken.balanceOf(address(this)) + totalReleased - saleRaised);\\n    }\\n\\n    function withdrawFundedBNB() external isOperatorOrOwner isEnded {\\n        require(fundToken == address(0), \\\"It's not BNB-buy pool!\\\");\\n\\n        uint256 balance = address(this).balance;\\n\\n        (address feeRecipient, uint256 feePercent) = controller.getFeeInfo();\\n\\n        uint256 fee = (balance * (feePercent)) / (1000);\\n        uint256 restAmount = balance - (fee);\\n\\n        (bool success, ) = payable(feeRecipient).call{ value: fee }(\\\"\\\");\\n        require(success, \\\"BNB fee pay failed\\\");\\n        (bool success1, ) = payable(msg.sender).call{ value: restAmount }(\\\"\\\");\\n        require(success1, \\\"BNB withdraw failed\\\");\\n    }\\n\\n    function withdrawFundedToken() external isOperatorOrOwner isEnded {\\n        require(fundToken != address(0), \\\"It's not token-buy pool!\\\");\\n\\n        uint256 balance = IERC20(fundToken).balanceOf(address(this));\\n\\n        (address feeRecipient, uint256 feePercent) = controller.getFeeInfo();\\n\\n        uint256 fee = (balance * feePercent) / 1000;\\n        uint256 restAmount = balance - fee;\\n\\n        IERC20(fundToken).safeTransfer(feeRecipient, fee);\\n        IERC20(fundToken).safeTransfer(msg.sender, restAmount);\\n    }\\n\\n    function getUnlockedTokenAmount(address addr, uint256 fundedAmount) private view returns (uint256) {\\n        require(addr != address(0), \\\"Invalid address!\\\");\\n\\n        if (block.timestamp < claimTime) return 0;\\n\\n        uint256 totalSaleToken = (fundedAmount * saleTarget) / fundTarget;\\n\\n        uint256 distributeAmountAtClaim = (totalSaleToken * distributePercentAtClaim) / 1000;\\n\\n        if (cliffTime > block.timestamp) {\\n            return distributeAmountAtClaim;\\n        }\\n\\n        if (cliffTime == 0) {\\n            // vesting info is not set yet\\n            return 0;\\n        }\\n\\n        uint256 finalTime = cliffTime + vestingDuration - vestingPeriodicity;\\n\\n        if (block.timestamp >= finalTime) {\\n            return totalSaleToken;\\n        }\\n\\n        uint256 lockedAmount = totalSaleToken - distributeAmountAtClaim;\\n\\n        uint256 totalPeridicities = vestingDuration / vestingPeriodicity;\\n        uint256 periodicityAmount = lockedAmount / totalPeridicities;\\n        uint256 currentperiodicityCount = (block.timestamp - cliffTime) / vestingPeriodicity + 1;\\n        uint256 availableAmount = periodicityAmount * currentperiodicityCount;\\n\\n        return distributeAmountAtClaim + availableAmount;\\n    }\\n\\n    function getWhitelistClaimableAmount(address addr) private view returns (uint256) {\\n        return getUnlockedTokenAmount(addr, whitelistFunders[addr].totalFunded) - whitelistFunders[addr].released;\\n    }\\n\\n    function getFCFSClaimableAmount(address addr) private view returns (uint256) {\\n        return getUnlockedTokenAmount(addr, fcfsFunders[addr].totalFunded) - fcfsFunders[addr].released;\\n    }\\n\\n    function getClaimableAmount(address addr) public view returns (uint256) {\\n        return getWhitelistClaimableAmount(addr) + getFCFSClaimableAmount(addr);\\n    }\\n\\n    function _claimTo(address to) private {\\n        require(to != address(0), \\\"Invalid address\\\");\\n        uint256 claimableAmount = getClaimableAmount(to);\\n        if (claimableAmount > 0) {\\n            whitelistFunders[to].released = whitelistFunders[to].released + getWhitelistClaimableAmount(to);\\n            fcfsFunders[to].released = fcfsFunders[to].released + getFCFSClaimableAmount(to);\\n\\n            saleToken.safeTransfer(to, claimableAmount);\\n            totalReleased = totalReleased + claimableAmount;\\n            emit IDOClaimed(to, claimableAmount);\\n        }\\n    }\\n\\n    function claim() external isClaimable nonReentrant onlyEOA {\\n        uint256 claimableAmount = getClaimableAmount(msg.sender);\\n        require(claimableAmount > 0, \\\"Nothing to claim\\\");\\n        _claimTo(msg.sender);\\n    }\\n\\n    function batchClaim(address[] calldata addrs) external isClaimable nonReentrant onlyEOA {\\n        for (uint256 index = 0; index < addrs.length; index++) {\\n            _claimTo(addrs[index]);\\n        }\\n    }\\n\\n    function _processBuy(address buyer, uint256 amount) private {\\n        uint256 saleTokenAmount = (amount * saleTarget) / fundTarget;\\n        uint256 currentRoundId = getCurrentRoundId();\\n\\n        fundRaised = fundRaised + amount;\\n        saleRaised = saleRaised + saleTokenAmount;\\n\\n        uint256 roundId = currentRoundId;\\n\\n        if (currentRoundId == 1) {\\n            // whitelist\\n            if (whitelistFunders[buyer].totalFunded == 0) {\\n                funderAddresses.push(buyer);\\n            }\\n\\n            whitelistFunders[buyer].totalFunded = whitelistFunders[buyer].totalFunded + amount;\\n        } else if (currentRoundId == 2) {\\n            // fcfs\\n            if (whitelistFunders[buyer].totalFunded == 0 && fcfsFunders[buyer].totalFunded == 0) {\\n                funderAddresses.push(buyer);\\n            }\\n\\n            fcfsFunders[buyer].totalFunded = fcfsFunders[buyer].totalFunded + amount;\\n        }\\n\\n        roundsFundRaised[roundId] = roundsFundRaised[roundId] + amount;\\n\\n        emit IDOProgressChanged(buyer, amount, fundRaised, saleRaised, currentRoundId);\\n    }\\n\\n    function buyWithBNB() public payable isOngoing canRaise(msg.sender, msg.value) onlyEOA {\\n        require(fundToken == address(0), \\\"It's not BNB-buy pool!\\\");\\n\\n        _processBuy(msg.sender, msg.value);\\n    }\\n\\n    function buy(uint256 amount) public isOngoing canRaise(msg.sender, amount) onlyEOA {\\n        require(fundToken != address(0), \\\"It's not token-buy pool!\\\");\\n\\n        _processBuy(msg.sender, amount);\\n\\n        IERC20(fundToken).safeTransferFrom(msg.sender, address(this), amount);\\n    }\\n\\n    function setWhitelist(address[] calldata addrs, uint256[] calldata amounts) external isOperatorOrOwner {\\n        require(addrs.length == amounts.length, \\\"Invalid params\\\");\\n\\n        for (uint256 index = 0; index < addrs.length; index++) {\\n            whitelistAmount[addrs[index]] = amounts[index];\\n        }\\n    }\\n\\n    receive() external payable {\\n        revert(\\\"Something went wrong!\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDOSec/IIDOSecController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IIDOSecController {\\n    event NewIDOCreated(address indexed pool, address creator);\\n\\n    function isOperator(address) external view returns (bool);\\n\\n    function getFeeInfo() external view returns (address, uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IIDOSecController\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_saleTarget\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_fundToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fundTarget\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minFundAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fcfsAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"meta\",\"type\":\"string\"}],\"name\":\"IDOBaseDataChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"IDOClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"saleTarget\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fundToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fundTarget\",\"type\":\"uint256\"}],\"name\":\"IDOInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fundRaised\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"saleRaised\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"IDOProgressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"saleTarget\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fundTarget\",\"type\":\"uint256\"}],\"name\":\"IDOTokenInfoChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"saleToken\",\"type\":\"address\"}],\"name\":\"SaleTokenAddressSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cliffTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"distributePercentAtClaim\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestingDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestingPeriodicity\",\"type\":\"uint256\"}],\"name\":\"VestingSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ROUNDS_COUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"batchClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyWithBNB\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cliffTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract IIDOSecController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributePercentAtClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fcfsAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"fcfsFunders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalFunded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"released\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundTarget\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"funderAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getClaimableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentRoundId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"funder\",\"type\":\"address\"}],\"name\":\"getFunderInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalFunded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"released\",\"type\":\"uint256\"}],\"internalType\":\"struct IDOSec.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFundersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getMaxAllocation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentRoundId\",\"type\":\"uint256\"}],\"name\":\"getRoundTotalAllocation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"meta\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minFundAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundsFundRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleTarget\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_claimTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minFundAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fcfsAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_meta\",\"type\":\"string\"}],\"name\":\"setBaseData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_claimTime\",\"type\":\"uint256\"}],\"name\":\"setClaimTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"setEndTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fcfsAmount\",\"type\":\"uint256\"}],\"name\":\"setFcFsAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fundTarget\",\"type\":\"uint256\"}],\"name\":\"setFundTarget\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_meta\",\"type\":\"string\"}],\"name\":\"setMeta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minFundAmount\",\"type\":\"uint256\"}],\"name\":\"setMinFundAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_saleTarget\",\"type\":\"uint256\"}],\"name\":\"setSaleTarget\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_saleToken\",\"type\":\"address\"}],\"name\":\"setSaleToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"setStartTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cliffTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_distributePercentAtClaim\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_vestingDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_vestingPeriodicity\",\"type\":\"uint256\"}],\"name\":\"setVestingInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReleased\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingPeriodicity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistFunders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalFunded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"released\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFundedBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFundedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawRemainingSaleToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "IDOSec", "CompilerVersion": "v0.8.2+commit.661d1103", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "00000000000000000000000093f3c3263cc1d66b33e0d92b6dac4a9f1bd060eb0000000000000000000000000000000000000000000295be96e6406697200000000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000000000000000000000000034f086f3b33b68400000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}