{"SourceCode": "/* RiceProtect.com\r\n\r\nSimply Protect $RICE\r\n\r\nWebsite: https://riceprotect.com\r\nDocs: https://docs.riceprotect.com/\r\nTwitter: https://x.com/riceprotect\r\nTelegram: https://t.me/RiceProtect\r\n\r\n*/\r\n\r\n// Sources flattened with hardhat v2.17.1 https://hardhat.org\r\n\r\n// SPDX-License-Identifier: MIT AND SEE\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\npragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactETH(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapETHForExactTokens(\r\n        uint amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n\r\n    function quote(\r\n        uint amountA,\r\n        uint reserveA,\r\n        uint reserveB\r\n    ) external pure returns (uint amountB);\r\n\r\n    function getAmountOut(\r\n        uint amountIn,\r\n        uint reserveIn,\r\n        uint reserveOut\r\n    ) external pure returns (uint amountOut);\r\n\r\n    function getAmountIn(\r\n        uint amountOut,\r\n        uint reserveIn,\r\n        uint reserveOut\r\n    ) external pure returns (uint amountIn);\r\n\r\n    function getAmountsOut(\r\n        uint amountIn,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n\r\n    function getAmountsIn(\r\n        uint amountOut,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n}\r\n\r\npragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(\r\n        address indexed token0,\r\n        address indexed token1,\r\n        address pair,\r\n        uint\r\n    );\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external view returns (address pair);\r\n\r\n    function allPairs(uint) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint value,\r\n        uint deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(\r\n        address indexed sender,\r\n        uint amount0,\r\n        uint amount1,\r\n        address indexed to\r\n    );\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function price0CumulativeLast() external view returns (uint);\r\n\r\n    function price1CumulativeLast() external view returns (uint);\r\n\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n\r\n    function swap(\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// Original license: SPDX_License_Identifier: SEE\r\n\r\npragma solidity 0.8.21;\r\n\r\ninterface IVaultProtect {\r\n    function depositInternal(address from, uint256 amount) external;\r\n}\r\n\r\nabstract contract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    constructor(\r\n        string memory _tokenName,\r\n        string memory _tokenSymbol,\r\n        uint8 _tokenDecimals\r\n    ) {\r\n        _name = _tokenName;\r\n        _symbol = _tokenSymbol;\r\n        _decimals = _tokenDecimals;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\ncontract RiceProtect is ERC20Detailed, Ownable {\r\n    IUniswapV2Router02 public router;\r\n    address public pair;\r\n    IVaultProtect public vaultProtect;\r\n    address public RiceYield;\r\n    address public marketingAddress;\r\n\r\n    uint256 public debaseTime = 1 hours;\r\n    uint256 public latestDebase;\r\n    uint256 public debaseStartedAt;\r\n    uint256 public currentEpoch;\r\n\r\n    bool public autoDebase;\r\n    bool public claimStatus = false;\r\n\r\n    uint8 private constant DECIMALS = 9;\r\n\r\n    uint256 private constant INITIAL_TOKENS_SUPPLY =\r\n        500_000_000 * 10 ** DECIMALS;\r\n\r\n    uint256 private constant TOTAL_PARTS =\r\n        type(uint256).max - (type(uint256).max % INITIAL_TOKENS_SUPPLY);\r\n\r\n    uint256 private _totalSupply;\r\n    uint256 private _fragment;\r\n    uint256 private _initFragment;\r\n\r\n    // tax\r\n    uint256 public marketing = 2;\r\n    uint256 public rewardsFee = 3;\r\n\r\n    uint256 private _initialTax = 30;\r\n    uint256 private _reduceTaxAt = 30;\r\n\r\n    uint256 private _buyCount = 0;\r\n    uint256 private _sellCount = 0;\r\n\r\n    bool public limitsInEffect = true;\r\n    bool public tradingEnable = false;\r\n\r\n    uint256 public swapbackPercent = 5; // 0.5%\r\n    uint256 public maxWallet = (INITIAL_TOKENS_SUPPLY * 2) / 100; // 2%\r\n    uint256 public maxAmount = (INITIAL_TOKENS_SUPPLY * 2) / 100; // 2%\r\n\r\n    mapping(address => bool) public _isProtected;\r\n    mapping(address => bool) public isExcludedFromFee;\r\n    mapping(address => uint256) private _partBalances;\r\n    mapping(address => mapping(address => uint256)) private _allowedTokens;\r\n\r\n    address[] private _protected;\r\n\r\n    event Debase(uint256 time, uint256 supply);\r\n\r\n    bool inSwap;\r\n\r\n    modifier swapping() {\r\n        inSwap = true;\r\n        _;\r\n        inSwap = false;\r\n    }\r\n\r\n    modifier validRecipient(address to) {\r\n        require(to != address(0x0));\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address _vaultProtect,\r\n        address _RiceYield\r\n    ) ERC20Detailed(\"Rice Protect\", \"RICE\", DECIMALS) {\r\n        router = IUniswapV2Router02(\r\n            address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D)\r\n        );\r\n\r\n        pair = IUniswapV2Factory(router.factory()).createPair(\r\n            address(this),\r\n            router.WETH()\r\n        );\r\n\r\n        vaultProtect = IVaultProtect(_vaultProtect);\r\n        RiceYield = _RiceYield;\r\n        marketingAddress = _msgSender();\r\n\r\n        _totalSupply = INITIAL_TOKENS_SUPPLY;\r\n        _partBalances[_msgSender()] = TOTAL_PARTS;\r\n        _fragment = TOTAL_PARTS / (_totalSupply);\r\n        _initFragment = _fragment;\r\n\r\n        protectAddress(address(this), true);\r\n        protectAddress(address(vaultProtect), true);\r\n\r\n        isExcludedFromFee[address(this)] = true;\r\n        isExcludedFromFee[address(router)] = true;\r\n        isExcludedFromFee[_msgSender()] = true;\r\n        isExcludedFromFee[_vaultProtect] = true;\r\n\r\n        _allowedTokens[_msgSender()][address(router)] = type(uint256).max;\r\n        _allowedTokens[address(this)][address(router)] = type(uint256).max;\r\n\r\n        emit Transfer(\r\n            address(0x0),\r\n            address(_msgSender()),\r\n            balanceOf(_msgSender())\r\n        );\r\n    }\r\n\r\n    function totalSupply() external view override returns (uint256) {\r\n        if (_protected.length == 0) return _totalSupply;\r\n\r\n        uint256 totalProtectExcluded;\r\n        uint256 totalProtectIncluded;\r\n\r\n        for (uint256 i = 0; i < _protected.length; i++) {\r\n            totalProtectExcluded +=\r\n                _partBalances[_protected[i]] /\r\n                _initFragment;\r\n            totalProtectIncluded += _partBalances[_protected[i]] / _fragment;\r\n        }\r\n\r\n        return _totalSupply - totalProtectIncluded + totalProtectExcluded;\r\n    }\r\n\r\n    function allowance(\r\n        address owner_,\r\n        address spender\r\n    ) external view override returns (uint256) {\r\n        return _allowedTokens[owner_][spender];\r\n    }\r\n\r\n    function balanceOf(address who) public view override returns (uint256) {\r\n        if (_isProtected[who]) {\r\n            return _partBalances[who] / _initFragment;\r\n        }\r\n        return _partBalances[who] / (_fragment);\r\n    }\r\n\r\n    function shouldDebase() public view returns (bool) {\r\n        uint256 times = (block.timestamp - latestDebase) / debaseTime;\r\n        return latestDebase > 0 && times > 0 && autoDebase;\r\n    }\r\n\r\n    function transfer(\r\n        address to,\r\n        uint256 value\r\n    ) external override validRecipient(to) returns (bool) {\r\n        _transfer(_msgSender(), to, value);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        if (!inSwap && !isExcludedFromFee[from] && !isExcludedFromFee[to]) {\r\n            require(tradingEnable, \"Trading not live\");\r\n\r\n            uint256 totalFee = rewardsFee + marketing;\r\n\r\n            if (from == pair && _buyCount < _reduceTaxAt) {\r\n                totalFee = _initialTax;\r\n                _buyCount++;\r\n            }\r\n\r\n            if (to == pair && _sellCount < _reduceTaxAt) {\r\n                totalFee = _initialTax;\r\n                _sellCount++;\r\n            }\r\n\r\n            if (limitsInEffect) {\r\n                if (from == pair || to == pair) {\r\n                    require(amount <= maxAmount, \"Max Tx Exceeded\");\r\n                }\r\n                if (to != pair && to != address(vaultProtect)) {\r\n                    require(\r\n                        balanceOf(to) + amount <= maxWallet,\r\n                        \"Max Wallet Exceeded\"\r\n                    );\r\n                }\r\n            }\r\n\r\n            uint256 fee = (amount * totalFee) / 100;\r\n            amount = amount - fee;\r\n\r\n            _transfer(from, address(this), fee);\r\n\r\n            uint256 riceBalance = balanceOf(address(this));\r\n            uint256 swapbackAmount = (_totalSupply * swapbackPercent) / 1000;\r\n            if (to == pair) {\r\n                if (riceBalance >= swapbackAmount) {\r\n                    swapBack();\r\n                }\r\n                if (shouldDebase()) {\r\n                    try this.manualDebase() {} catch {}\r\n                }\r\n            }\r\n        }\r\n\r\n        (uint256 fromAmount, uint256 toAmount) = getPartAmountBeforeTx(\r\n            from,\r\n            to,\r\n            amount\r\n        );\r\n\r\n        _partBalances[from] -= fromAmount;\r\n        _partBalances[to] += toAmount;\r\n\r\n        if (to == address(vaultProtect)) {\r\n            try vaultProtect.depositInternal(from, amount) {} catch {}\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function getPartAmountBeforeTx(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public view returns (uint256, uint256) {\r\n        uint256 excludeAmount = amount * _initFragment;\r\n        uint256 includeAmount = amount * _fragment;\r\n\r\n        // exclude -> exclude\r\n        if (_isProtected[from] && _isProtected[to]) {\r\n            return (excludeAmount, excludeAmount);\r\n        }\r\n        // exclude -> include\r\n        if (_isProtected[from] && !_isProtected[to]) {\r\n            return (excludeAmount, includeAmount);\r\n        }\r\n        // include -> include\r\n        if (!_isProtected[from] && !_isProtected[to]) {\r\n            return (includeAmount, includeAmount);\r\n        }\r\n        // include -> exclude\r\n        return (includeAmount, excludeAmount);\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external override validRecipient(to) returns (bool) {\r\n        if (_allowedTokens[from][_msgSender()] != type(uint256).max) {\r\n            require(\r\n                _allowedTokens[from][_msgSender()] >= value,\r\n                \"Insufficient Allowance\"\r\n            );\r\n            _allowedTokens[from][_msgSender()] =\r\n                _allowedTokens[from][_msgSender()] -\r\n                (value);\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(\r\n        address spender,\r\n        uint256 subtractedValue\r\n    ) external returns (bool) {\r\n        uint256 oldValue = _allowedTokens[_msgSender()][spender];\r\n        if (subtractedValue >= oldValue) {\r\n            _allowedTokens[_msgSender()][spender] = 0;\r\n        } else {\r\n            _allowedTokens[_msgSender()][spender] =\r\n                oldValue -\r\n                (subtractedValue);\r\n        }\r\n        emit Approval(\r\n            _msgSender(),\r\n            spender,\r\n            _allowedTokens[_msgSender()][spender]\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(\r\n        address spender,\r\n        uint256 addedValue\r\n    ) external returns (bool) {\r\n        _allowedTokens[_msgSender()][spender] =\r\n            _allowedTokens[_msgSender()][spender] +\r\n            (addedValue);\r\n        emit Approval(\r\n            _msgSender(),\r\n            spender,\r\n            _allowedTokens[_msgSender()][spender]\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function approve(\r\n        address spender,\r\n        uint256 value\r\n    ) public override returns (bool) {\r\n        _allowedTokens[_msgSender()][spender] = value;\r\n        emit Approval(_msgSender(), spender, value);\r\n        return true;\r\n    }\r\n\r\n    function debase() private {\r\n        uint256 times = (block.timestamp - latestDebase) / debaseTime;\r\n\r\n        latestDebase = block.timestamp;\r\n\r\n        currentEpoch += times;\r\n\r\n        for (uint256 i = 0; i < times; i++) {\r\n            uint256 supplyDelta = (_totalSupply * 26) / 10000; // 0.26%\r\n\r\n            unchecked {\r\n                _totalSupply = _totalSupply - supplyDelta;\r\n                _fragment = TOTAL_PARTS / (_totalSupply);\r\n            }\r\n\r\n            emit Debase(block.timestamp, _totalSupply);\r\n        }\r\n\r\n        IUniswapV2Pair(pair).sync();\r\n    }\r\n\r\n    function protectAddress(address account, bool _status) public onlyOwner {\r\n        if (_status) {\r\n            _isProtected[account] = true;\r\n            _protected.push(account);\r\n        } else {\r\n            for (uint256 i = 0; i < _protected.length; i++) {\r\n                if (_protected[i] == account) {\r\n                    _protected[i] = _protected[_protected.length - 1];\r\n                    _isProtected[account] = false;\r\n                    _protected.pop();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function manualDebase() public {\r\n        require(shouldDebase(), \"Not in time\");\r\n        debase();\r\n    }\r\n\r\n    function enableTrading() external onlyOwner {\r\n        require(!tradingEnable, \"Trading Live Already\");\r\n        tradingEnable = true;\r\n    }\r\n\r\n    function removeLimits() external onlyOwner {\r\n        require(limitsInEffect, \"Limits already removed\");\r\n        limitsInEffect = false;\r\n    }\r\n\r\n    function excludedFromFees(\r\n        address _address,\r\n        bool _value\r\n    ) external onlyOwner {\r\n        isExcludedFromFee[_address] = _value;\r\n    }\r\n\r\n    function startDebase(bool _status) external onlyOwner {\r\n        autoDebase = _status;\r\n        latestDebase = block.timestamp;\r\n        debaseStartedAt = block.timestamp;\r\n    }\r\n\r\n    function updateVaultProtect(address _newAddress) external onlyOwner {\r\n        protectAddress(address(vaultProtect), false);\r\n        vaultProtect = IVaultProtect(_newAddress);\r\n        isExcludedFromFee[_newAddress] = true;\r\n        protectAddress(_newAddress, true);\r\n    }\r\n\r\n    function updateRiceYield(address _newRiceYield) external onlyOwner {\r\n        RiceYield = _newRiceYield;\r\n    }\r\n\r\n    function swapBack() public swapping {\r\n        uint256 ethBeforeSwap = address(this).balance;\r\n        uint256 swapbackAmount = (_totalSupply * swapbackPercent) / 1000;\r\n        swapTokensForETH(swapbackAmount);\r\n        uint256 totalETH = address(this).balance - ethBeforeSwap;\r\n        uint256 totalFee = marketing + rewardsFee;\r\n        uint256 amountForRiceYield = (totalETH * rewardsFee) / totalFee;\r\n\r\n        if (amountForRiceYield > 0) {\r\n            (bool success, ) = payable(RiceYield).call{\r\n                value: amountForRiceYield\r\n            }(\"\");\r\n            require(success, \"Failed to send ETH to RiceYield\");\r\n        }\r\n\r\n        if (address(this).balance > 0) {\r\n            (bool success, ) = payable(marketingAddress).call{\r\n                value: address(this).balance\r\n            }(\"\");\r\n            require(success, \"Failed to send ETH to Marketing\");\r\n        }\r\n    }\r\n\r\n    function swapTokensForETH(uint256 tokenAmount) internal {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, // accept any amount\r\n            path,\r\n            address(address(this)),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultProtect\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_RiceYield\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"name\":\"Debase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"RiceYield\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isProtected\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoDebase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"debaseStartedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"debaseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"excludedFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getPartAmountBeforeTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestDebase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitsInEffect\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualDebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"protectAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shouldDebase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"startDebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapbackPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRiceYield\",\"type\":\"address\"}],\"name\":\"updateRiceYield\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"updateVaultProtect\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultProtect\",\"outputs\":[{\"internalType\":\"contract IVaultProtect\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RiceProtect", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000009474103b6980af41bcd33e74ae051a171c477320000000000000000000000000888c734ddbfad099e77f339d29878fd7820497c9", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://017f6b1424cf7bf634d83b691e65a47fc094b6029369d31d0ff4ba87bd40f4ce"}