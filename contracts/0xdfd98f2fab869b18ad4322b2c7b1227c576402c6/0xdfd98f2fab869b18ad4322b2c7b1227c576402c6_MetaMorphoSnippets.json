{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contract-9d397b2b6e.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ntype Id is bytes32;\\n\\nstruct MarketParams {\\n    address loanToken;\\n    address collateralToken;\\n    address oracle;\\n    address irm;\\n    uint256 lltv;\\n}\\n\\n/// @dev Warning: For `feeRecipient`, `supplyShares` does not contain the accrued shares since the last interest\\n/// accrual.\\nstruct Position {\\n    uint256 supplyShares;\\n    uint128 borrowShares;\\n    uint128 collateral;\\n}\\n\\n/// @dev Warning: `totalSupplyAssets` does not contain the accrued interest since the last interest accrual.\\n/// @dev Warning: `totalBorrowAssets` does not contain the accrued interest since the last interest accrual.\\n/// @dev Warning: `totalSupplyShares` does not contain the additional shares accrued by `feeRecipient` since the last\\n/// interest accrual.\\nstruct Market {\\n    uint128 totalSupplyAssets;\\n    uint128 totalSupplyShares;\\n    uint128 totalBorrowAssets;\\n    uint128 totalBorrowShares;\\n    uint128 lastUpdate;\\n    uint128 fee;\\n}\\n\\nstruct Authorization {\\n    address authorizer;\\n    address authorized;\\n    bool isAuthorized;\\n    uint256 nonce;\\n    uint256 deadline;\\n}\\n\\nstruct Signature {\\n    uint8 v;\\n    bytes32 r;\\n    bytes32 s;\\n}\\n\\n/// @dev This interface is used for factorizing IMorphoStaticTyping and IMorpho.\\n/// @dev Consider using the IMorpho interface instead of this one.\\ninterface IMorphoBase {\\n    /// @notice The EIP-712 domain separator.\\n    /// @dev Warning: Every EIP-712 signed message based on this domain separator can be reused on another chain sharing\\n    /// the same chain id because the domain separator would be the same.\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    /// @notice The owner of the contract.\\n    /// @dev It has the power to change the owner.\\n    /// @dev It has the power to set fees on markets and set the fee recipient.\\n    /// @dev It has the power to enable but not disable IRMs and LLTVs.\\n    function owner() external view returns (address);\\n\\n    /// @notice The fee recipient of all markets.\\n    /// @dev The recipient receives the fees of a given market through a supply position on that market.\\n    function feeRecipient() external view returns (address);\\n\\n    /// @notice Whether the `irm` is enabled.\\n    function isIrmEnabled(address irm) external view returns (bool);\\n\\n    /// @notice Whether the `lltv` is enabled.\\n    function isLltvEnabled(uint256 lltv) external view returns (bool);\\n\\n    /// @notice Whether `authorized` is authorized to modify `authorizer`'s positions.\\n    /// @dev Anyone is authorized to modify their own positions, regardless of this variable.\\n    function isAuthorized(address authorizer, address authorized) external view returns (bool);\\n\\n    /// @notice The `authorizer`'s current nonce. Used to prevent replay attacks with EIP-712 signatures.\\n    function nonce(address authorizer) external view returns (uint256);\\n\\n    /// @notice Sets `newOwner` as `owner` of the contract.\\n    /// @dev Warning: No two-step transfer ownership.\\n    /// @dev Warning: The owner can be set to the zero address.\\n    function setOwner(address newOwner) external;\\n\\n    /// @notice Enables `irm` as a possible IRM for market creation.\\n    /// @dev Warning: It is not possible to disable an IRM.\\n    function enableIrm(address irm) external;\\n\\n    /// @notice Enables `lltv` as a possible LLTV for market creation.\\n    /// @dev Warning: It is not possible to disable a LLTV.\\n    function enableLltv(uint256 lltv) external;\\n\\n    /// @notice Sets the `newFee` for the given market `marketParams`.\\n    /// @dev Warning: The recipient can be the zero address.\\n    function setFee(MarketParams memory marketParams, uint256 newFee) external;\\n\\n    /// @notice Sets `newFeeRecipient` as `feeRecipient` of the fee.\\n    /// @dev Warning: If the fee recipient is set to the zero address, fees will accrue there and will be lost.\\n    /// @dev Modifying the fee recipient will allow the new recipient to claim any pending fees not yet accrued. To\\n    /// ensure that the current recipient receives all due fees, accrue interest manually prior to making any changes.\\n    function setFeeRecipient(address newFeeRecipient) external;\\n\\n    /// @notice Creates the market `marketParams`.\\n    /// @dev Here is the list of assumptions on the market's dependencies (tokens, IRM and oracle) that guarantees\\n    /// Morpho behaves as expected:\\n    /// - The token should be ERC-20 compliant, except that it can omit return values on `transfer` and `transferFrom`.\\n    /// - The token balance of Morpho should only decrease on `transfer` and `transferFrom`. In particular, tokens with\\n    /// burn functions are not supported.\\n    /// - The token should not re-enter Morpho on `transfer` nor `transferFrom`.\\n    /// - The token balance of the sender (resp. receiver) should decrease (resp. increase) by exactly the given amount\\n    /// on `transfer` and `transferFrom`. In particular, tokens with fees on transfer are not supported.\\n    /// - The IRM should not re-enter Morpho.\\n    /// - The oracle should return a price with the correct scaling.\\n    /// @dev Here is a list of properties on the market's dependencies that could break Morpho's liveness properties\\n    /// (funds could get stuck):\\n    /// - The token can revert on `transfer` and `transferFrom` for a reason other than an approval or balance issue.\\n    /// - A very high amount of assets (~1e35) supplied or borrowed can make the computation of `toSharesUp` and\\n    /// `toSharesDown` overflow.\\n    /// - The IRM can revert on `borrowRate`.\\n    /// - A very high borrow rate returned by the IRM can make the computation of `interest` in `_accrueInterest`\\n    /// overflow.\\n    /// - The oracle can revert on `price`. Note that this can be used to prevent `borrow`, `withdrawCollateral` and\\n    /// `liquidate` from being used under certain market conditions.\\n    /// - A very high price returned by the oracle can make the computation of `maxBorrow` in `_isHealthy` overflow, or\\n    /// the computation of `assetsRepaid` in `liquidate` overflow.\\n    /// @dev The borrow share price of a market with less than 1e4 assets borrowed can be decreased by manipulations, to\\n    /// the point where `totalBorrowShares` is very large and borrowing overflows.\\n    function createMarket(MarketParams memory marketParams) external;\\n\\n    /// @notice Supplies `assets` or `shares` on behalf of `onBehalf`, optionally calling back the caller's\\n    /// `onMorphoSupply` function with the given `data`.\\n    /// @dev Either `assets` or `shares` should be zero. Most usecases should rely on `assets` as an input so the caller\\n    /// is guaranteed to have `assets` tokens pulled from their balance, but the possibility to mint a specific amount\\n    /// of shares is given for full compatibility and precision.\\n    /// @dev If the supply of a market gets depleted, the supply share price instantly resets to\\n    /// `VIRTUAL_ASSETS`:`VIRTUAL_SHARES`.\\n    /// @dev Supplying a large amount can revert for overflow.\\n    /// @param marketParams The market to supply assets to.\\n    /// @param assets The amount of assets to supply.\\n    /// @param shares The amount of shares to mint.\\n    /// @param onBehalf The address that will own the increased supply position.\\n    /// @param data Arbitrary data to pass to the `onMorphoSupply` callback. Pass empty data if not needed.\\n    /// @return assetsSupplied The amount of assets supplied.\\n    /// @return sharesSupplied The amount of shares minted.\\n    function supply(\\n        MarketParams memory marketParams,\\n        uint256 assets,\\n        uint256 shares,\\n        address onBehalf,\\n        bytes memory data\\n    ) external returns (uint256 assetsSupplied, uint256 sharesSupplied);\\n\\n    /// @notice Withdraws `assets` or `shares` on behalf of `onBehalf` to `receiver`.\\n    /// @dev Either `assets` or `shares` should be zero. To withdraw max, pass the `shares`'s balance of `onBehalf`.\\n    /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\\n    /// @dev Withdrawing an amount corresponding to more shares than supplied will revert for underflow.\\n    /// @dev It is advised to use the `shares` input when withdrawing the full position to avoid reverts due to\\n    /// conversion roundings between shares and assets.\\n    /// @param marketParams The market to withdraw assets from.\\n    /// @param assets The amount of assets to withdraw.\\n    /// @param shares The amount of shares to burn.\\n    /// @param onBehalf The address of the owner of the supply position.\\n    /// @param receiver The address that will receive the withdrawn assets.\\n    /// @return assetsWithdrawn The amount of assets withdrawn.\\n    /// @return sharesWithdrawn The amount of shares burned.\\n    function withdraw(\\n        MarketParams memory marketParams,\\n        uint256 assets,\\n        uint256 shares,\\n        address onBehalf,\\n        address receiver\\n    ) external returns (uint256 assetsWithdrawn, uint256 sharesWithdrawn);\\n\\n    /// @notice Borrows `assets` or `shares` on behalf of `onBehalf` to `receiver`.\\n    /// @dev Either `assets` or `shares` should be zero. Most usecases should rely on `assets` as an input so the caller\\n    /// is guaranteed to borrow `assets` of tokens, but the possibility to mint a specific amount of shares is given for\\n    /// full compatibility and precision.\\n    /// @dev If the borrow of a market gets depleted, the borrow share price instantly resets to\\n    /// `VIRTUAL_ASSETS`:`VIRTUAL_SHARES`.\\n    /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\\n    /// @dev Borrowing a large amount can revert for overflow.\\n    /// @param marketParams The market to borrow assets from.\\n    /// @param assets The amount of assets to borrow.\\n    /// @param shares The amount of shares to mint.\\n    /// @param onBehalf The address that will own the increased borrow position.\\n    /// @param receiver The address that will receive the borrowed assets.\\n    /// @return assetsBorrowed The amount of assets borrowed.\\n    /// @return sharesBorrowed The amount of shares minted.\\n    function borrow(\\n        MarketParams memory marketParams,\\n        uint256 assets,\\n        uint256 shares,\\n        address onBehalf,\\n        address receiver\\n    ) external returns (uint256 assetsBorrowed, uint256 sharesBorrowed);\\n\\n    /// @notice Repays `assets` or `shares` on behalf of `onBehalf`, optionally calling back the caller's\\n    /// `onMorphoReplay` function with the given `data`.\\n    /// @dev Either `assets` or `shares` should be zero. To repay max, pass the `shares`'s balance of `onBehalf`.\\n    /// @dev Repaying an amount corresponding to more shares than borrowed will revert for underflow.\\n    /// @dev It is advised to use the `shares` input when repaying the full position to avoid reverts due to conversion\\n    /// roundings between shares and assets.\\n    /// @param marketParams The market to repay assets to.\\n    /// @param assets The amount of assets to repay.\\n    /// @param shares The amount of shares to burn.\\n    /// @param onBehalf The address of the owner of the debt position.\\n    /// @param data Arbitrary data to pass to the `onMorphoRepay` callback. Pass empty data if not needed.\\n    /// @return assetsRepaid The amount of assets repaid.\\n    /// @return sharesRepaid The amount of shares burned.\\n    function repay(\\n        MarketParams memory marketParams,\\n        uint256 assets,\\n        uint256 shares,\\n        address onBehalf,\\n        bytes memory data\\n    ) external returns (uint256 assetsRepaid, uint256 sharesRepaid);\\n\\n    /// @notice Supplies `assets` of collateral on behalf of `onBehalf`, optionally calling back the caller's\\n    /// `onMorphoSupplyCollateral` function with the given `data`.\\n    /// @dev Interest are not accrued since it's not required and it saves gas.\\n    /// @dev Supplying a large amount can revert for overflow.\\n    /// @param marketParams The market to supply collateral to.\\n    /// @param assets The amount of collateral to supply.\\n    /// @param onBehalf The address that will own the increased collateral position.\\n    /// @param data Arbitrary data to pass to the `onMorphoSupplyCollateral` callback. Pass empty data if not needed.\\n    function supplyCollateral(MarketParams memory marketParams, uint256 assets, address onBehalf, bytes memory data)\\n        external;\\n\\n    /// @notice Withdraws `assets` of collateral on behalf of `onBehalf` to `receiver`.\\n    /// @dev `msg.sender` must be authorized to manage `onBehalf`'s positions.\\n    /// @dev Withdrawing an amount corresponding to more collateral than supplied will revert for underflow.\\n    /// @param marketParams The market to withdraw collateral from.\\n    /// @param assets The amount of collateral to withdraw.\\n    /// @param onBehalf The address of the owner of the collateral position.\\n    /// @param receiver The address that will receive the collateral assets.\\n    function withdrawCollateral(MarketParams memory marketParams, uint256 assets, address onBehalf, address receiver)\\n        external;\\n\\n    /// @notice Liquidates the given `repaidShares` of debt asset or seize the given `seizedAssets` of collateral on the\\n    /// given market `marketParams` of the given `borrower`'s position, optionally calling back the caller's\\n    /// `onMorphoLiquidate` function with the given `data`.\\n    /// @dev Either `seizedAssets` or `repaidShares` should be zero.\\n    /// @dev Seizing more than the collateral balance will underflow and revert without any error message.\\n    /// @dev Repaying more than the borrow balance will underflow and revert without any error message.\\n    /// @param marketParams The market of the position.\\n    /// @param borrower The owner of the position.\\n    /// @param seizedAssets The amount of collateral to seize.\\n    /// @param repaidShares The amount of shares to repay.\\n    /// @param data Arbitrary data to pass to the `onMorphoLiquidate` callback. Pass empty data if not needed.\\n    /// @return The amount of assets seized.\\n    /// @return The amount of assets repaid.\\n    function liquidate(\\n        MarketParams memory marketParams,\\n        address borrower,\\n        uint256 seizedAssets,\\n        uint256 repaidShares,\\n        bytes memory data\\n    ) external returns (uint256, uint256);\\n\\n    /// @notice Executes a flash loan.\\n    /// @dev Flash loans have access to the whole balance of the contract (the liquidity and deposited collateral of all\\n    /// markets combined, plus donations).\\n    /// @dev Warning: Not ERC-3156 compliant but compatibility is easily reached:\\n    /// - `flashFee` is zero.\\n    /// - `maxFlashLoan` is the token's balance of this contract.\\n    /// - The receiver of `assets` is the caller.\\n    /// @param token The token to flash loan.\\n    /// @param assets The amount of assets to flash loan.\\n    /// @param data Arbitrary data to pass to the `onMorphoFlashLoan` callback.\\n    function flashLoan(address token, uint256 assets, bytes calldata data) external;\\n\\n    /// @notice Sets the authorization for `authorized` to manage `msg.sender`'s positions.\\n    /// @param authorized The authorized address.\\n    /// @param newIsAuthorized The new authorization status.\\n    function setAuthorization(address authorized, bool newIsAuthorized) external;\\n\\n    /// @notice Sets the authorization for `authorization.authorized` to manage `authorization.authorizer`'s positions.\\n    /// @dev Warning: Reverts if the signature has already been submitted.\\n    /// @dev The signature is malleable, but it has no impact on the security here.\\n    /// @dev The nonce is passed as argument to be able to revert with a different error message.\\n    /// @param authorization The `Authorization` struct.\\n    /// @param signature The signature.\\n    function setAuthorizationWithSig(Authorization calldata authorization, Signature calldata signature) external;\\n\\n    /// @notice Accrues interest for the given market `marketParams`.\\n    function accrueInterest(MarketParams memory marketParams) external;\\n\\n    /// @notice Returns the data stored on the different `slots`.\\n    function extSloads(bytes32[] memory slots) external view returns (bytes32[] memory);\\n}\\n\\n/// @dev This interface is inherited by Morpho so that function signatures are checked by the compiler.\\n/// @dev Consider using the IMorpho interface instead of this one.\\ninterface IMorphoStaticTyping is IMorphoBase {\\n    /// @notice The state of the position of `user` on the market corresponding to `id`.\\n    /// @dev Warning: For `feeRecipient`, `supplyShares` does not contain the accrued shares since the last interest\\n    /// accrual.\\n    function position(Id id, address user)\\n        external\\n        view\\n        returns (uint256 supplyShares, uint128 borrowShares, uint128 collateral);\\n\\n    /// @notice The state of the market corresponding to `id`.\\n    /// @dev Warning: `totalSupplyAssets` does not contain the accrued interest since the last interest accrual.\\n    /// @dev Warning: `totalBorrowAssets` does not contain the accrued interest since the last interest accrual.\\n    /// @dev Warning: `totalSupplyShares` does not contain the accrued shares by `feeRecipient` since the last interest\\n    /// accrual.\\n    function market(Id id)\\n        external\\n        view\\n        returns (\\n            uint128 totalSupplyAssets,\\n            uint128 totalSupplyShares,\\n            uint128 totalBorrowAssets,\\n            uint128 totalBorrowShares,\\n            uint128 lastUpdate,\\n            uint128 fee\\n        );\\n\\n    /// @notice The market params corresponding to `id`.\\n    /// @dev This mapping is not used in Morpho. It is there to enable reducing the cost associated to calldata on layer\\n    /// 2s by creating a wrapper contract with functions that take `id` as input instead of `marketParams`.\\n    function idToMarketParams(Id id)\\n        external\\n        view\\n        returns (address loanToken, address collateralToken, address oracle, address irm, uint256 lltv);\\n}\\n\\n/// @title IMorpho\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @dev Use this interface for Morpho to have access to all the functions with the appropriate function signatures.\\ninterface IMorpho is IMorphoBase {\\n    /// @notice The state of the position of `user` on the market corresponding to `id`.\\n    /// @dev Warning: For `feeRecipient`, `p.supplyShares` does not contain the accrued shares since the last interest\\n    /// accrual.\\n    function position(Id id, address user) external view returns (Position memory p);\\n\\n    /// @notice The state of the market corresponding to `id`.\\n    /// @dev Warning: `m.totalSupplyAssets` does not contain the accrued interest since the last interest accrual.\\n    /// @dev Warning: `m.totalBorrowAssets` does not contain the accrued interest since the last interest accrual.\\n    /// @dev Warning: `m.totalSupplyShares` does not contain the accrued shares by `feeRecipient` since the last\\n    /// interest accrual.\\n    function market(Id id) external view returns (Market memory m);\\n\\n    /// @notice The market params corresponding to `id`.\\n    /// @dev This mapping is not used in Morpho. It is there to enable reducing the cost associated to calldata on layer\\n    /// 2s by creating a wrapper contract with functions that take `id` as input instead of `marketParams`.\\n    function idToMarketParams(Id id) external view returns (MarketParams memory);\\n}\\n\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC4626.sol)\\n\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\\n/**\\n * @dev Interface of the ERC4626 \\\"Tokenized Vault Standard\\\", as defined in\\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\\n */\\ninterface IERC4626 is IERC20, IERC20Metadata {\\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed sender,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /**\\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\\n     *\\n     * - MUST be an ERC-20 token contract.\\n     * - MUST NOT revert.\\n     */\\n    function asset() external view returns (address assetTokenAddress);\\n\\n    /**\\n     * @dev Returns the total amount of the underlying asset that is \u201cmanaged\u201d by Vault.\\n     *\\n     * - SHOULD include any compounding that occurs from yield.\\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT revert.\\n     */\\n    function totalAssets() external view returns (uint256 totalManagedAssets);\\n\\n    /**\\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\\n     * through a deposit call.\\n     *\\n     * - MUST return a limited value if receiver is subject to some deposit limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\\n     * - MUST NOT revert.\\n     */\\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\\n     *   in the same transaction.\\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   deposit execution, and are accounted for during deposit.\\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n     */\\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\\n     * - MUST return a limited value if receiver is subject to some mint limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\\n     * - MUST NOT revert.\\n     */\\n    function maxMint(address receiver) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\\n     *   same transaction.\\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\\n     */\\n    function previewMint(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\\n     *   execution, and are accounted for during mint.\\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n     */\\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\\n     * Vault, through a withdraw call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\\n     *   called\\n     *   in the same transaction.\\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   withdraw execution, and are accounted for during withdraw.\\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\\n     * through a redeem call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\\n     *   same transaction.\\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\\n     */\\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   redeem execution, and are accounted for during redeem.\\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\\n}\\n\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\\nstruct MarketConfig {\\n    /// @notice The maximum amount of assets that can be allocated to the market.\\n    uint184 cap;\\n    /// @notice Whether the market is in the withdraw queue.\\n    bool enabled;\\n    /// @notice The timestamp at which the market can be instantly removed from the withdraw queue.\\n    uint64 removableAt;\\n}\\n\\nstruct PendingUint192 {\\n    /// @notice The pending value to set.\\n    uint192 value;\\n    /// @notice The timestamp at which the pending value becomes valid.\\n    uint64 validAt;\\n}\\n\\nstruct PendingAddress {\\n    /// @notice The pending value to set.\\n    address value;\\n    /// @notice The timestamp at which the pending value becomes valid.\\n    uint64 validAt;\\n}\\n\\n/// @title PendingLib\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @notice Library to manage pending values and their validity timestamp.\\nlibrary PendingLib {\\n    /// @dev Updates `pending`'s value to `newValue` and its corresponding `validAt` timestamp.\\n    /// @dev Assumes `timelock` <= `MAX_TIMELOCK`.\\n    function update(PendingUint192 storage pending, uint184 newValue, uint256 timelock) internal {\\n        pending.value = newValue;\\n        // Safe \\\"unchecked\\\" cast because timelock <= MAX_TIMELOCK.\\n        pending.validAt = uint64(block.timestamp + timelock);\\n    }\\n\\n    /// @dev Updates `pending`'s value to `newValue` and its corresponding `validAt` timestamp.\\n    /// @dev Assumes `timelock` <= `MAX_TIMELOCK`.\\n    function update(PendingAddress storage pending, address newValue, uint256 timelock) internal {\\n        pending.value = newValue;\\n        // Safe \\\"unchecked\\\" cast because timelock <= MAX_TIMELOCK.\\n        pending.validAt = uint64(block.timestamp + timelock);\\n    }\\n}\\n\\n/// @dev Either `assets` or `shares` should be zero.\\nstruct MarketAllocation {\\n    /// @notice The market to allocate.\\n    MarketParams marketParams;\\n    /// @notice The amount of assets to allocate.\\n    uint256 assets;\\n}\\n\\ninterface IMulticall {\\n    function multicall(bytes[] calldata) external returns (bytes[] memory);\\n}\\n\\ninterface IOwnable {\\n    function owner() external returns (address);\\n    function transferOwnership(address) external;\\n    function renounceOwnership() external;\\n    function acceptOwnership() external;\\n    function pendingOwner() external view returns (address);\\n}\\n\\n/// @dev This interface is used for factorizing IMetaMorphoStaticTyping and IMetaMorpho.\\n/// @dev Consider using the IMetaMorpho interface instead of this one.\\ninterface IMetaMorphoBase {\\n    function MORPHO() external view returns (IMorpho);\\n\\n    function curator() external view returns (address);\\n    function isAllocator(address target) external view returns (bool);\\n    function guardian() external view returns (address);\\n\\n    function fee() external view returns (uint96);\\n    function feeRecipient() external view returns (address);\\n    function skimRecipient() external view returns (address);\\n    function timelock() external view returns (uint256);\\n    function supplyQueue(uint256) external view returns (Id);\\n    function supplyQueueLength() external view returns (uint256);\\n    function withdrawQueue(uint256) external view returns (Id);\\n    function withdrawQueueLength() external view returns (uint256);\\n\\n    function lastTotalAssets() external view returns (uint256);\\n\\n    function submitTimelock(uint256 newTimelock) external;\\n    function acceptTimelock() external;\\n    function revokePendingTimelock() external;\\n\\n    function submitCap(MarketParams memory marketParams, uint256 supplyCap) external;\\n    function acceptCap(Id id) external;\\n    function revokePendingCap(Id id) external;\\n\\n    function submitMarketRemoval(Id id) external;\\n    function revokePendingMarketRemoval(Id id) external;\\n\\n    function submitGuardian(address newGuardian) external;\\n    function acceptGuardian() external;\\n    function revokePendingGuardian() external;\\n\\n    function skim(address) external;\\n\\n    function setIsAllocator(address newAllocator, bool newIsAllocator) external;\\n    function setCurator(address newCurator) external;\\n    function setFee(uint256 newFee) external;\\n    function setFeeRecipient(address newFeeRecipient) external;\\n    function setSkimRecipient(address) external;\\n\\n    function setSupplyQueue(Id[] calldata newSupplyQueue) external;\\n    function updateWithdrawQueue(uint256[] calldata indexes) external;\\n    function reallocate(MarketAllocation[] calldata allocations) external;\\n}\\n\\n/// @dev This interface is inherited by MetaMorpho so that function signatures are checked by the compiler.\\n/// @dev Consider using the IMetaMorpho interface instead of this one.\\ninterface IMetaMorphoStaticTyping is IMetaMorphoBase {\\n    function config(Id) external view returns (uint184 cap, bool enabled, uint64 removableAt);\\n    function pendingGuardian() external view returns (address guardian, uint64 validAt);\\n    function pendingCap(Id) external view returns (uint192 value, uint64 validAt);\\n    function pendingTimelock() external view returns (uint192 value, uint64 validAt);\\n}\\n\\n/// @title IMetaMorpho\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @dev Use this interface for MetaMorpho to have access to all the functions with the appropriate function signatures.\\ninterface IMetaMorpho is IMetaMorphoBase, IERC4626, IERC20Permit, IOwnable, IMulticall {\\n    function config(Id) external view returns (MarketConfig memory);\\n    function pendingGuardian() external view returns (PendingAddress memory);\\n    function pendingCap(Id) external view returns (PendingUint192 memory);\\n    function pendingTimelock() external view returns (PendingUint192 memory);\\n}\\n\\n/// @title MarketParamsLib\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @notice Library to convert a market to its id.\\nlibrary MarketParamsLib {\\n    /// @notice The length of the data used to compute the id of a market.\\n    /// @dev The length is 5 * 32 because `MarketParams` has 5 variables of 32 bytes each.\\n    uint256 internal constant MARKET_PARAMS_BYTES_LENGTH = 5 * 32;\\n\\n    /// @notice Returns the id of the market `marketParams`.\\n    function id(MarketParams memory marketParams) internal pure returns (Id marketParamsId) {\\n        assembly (\\\"memory-safe\\\") {\\n            marketParamsId := keccak256(marketParams, MARKET_PARAMS_BYTES_LENGTH)\\n        }\\n    }\\n}\\n\\n/// @title IIrm\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @notice Interface that Interest Rate Models (IRMs) used by Morpho must implement.\\ninterface IIrm {\\n    /// @notice Returns the borrow rate of the market `marketParams`.\\n    /// @dev Assumes that `market` corresponds to `marketParams`.\\n    function borrowRate(MarketParams memory marketParams, Market memory market) external returns (uint256);\\n\\n    /// @notice Returns the borrow rate of the market `marketParams` without modifying any storage.\\n    /// @dev Assumes that `market` corresponds to `marketParams`.\\n    function borrowRateView(MarketParams memory marketParams, Market memory market) external view returns (uint256);\\n}\\n\\nuint256 constant WAD = 1e18;\\n\\n/// @title MathLib\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @notice Library to manage fixed-point arithmetic.\\nlibrary MathLib {\\n    /// @dev Returns (`x` * `y`) / `WAD` rounded down.\\n    function wMulDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD);\\n    }\\n\\n    /// @dev Returns (`x` * `WAD`) / `y` rounded down.\\n    function wDivDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y);\\n    }\\n\\n    /// @dev Returns (`x` * `WAD`) / `y` rounded up.\\n    function wDivUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y);\\n    }\\n\\n    /// @dev Returns (`x` * `y`) / `d` rounded down.\\n    function mulDivDown(uint256 x, uint256 y, uint256 d) internal pure returns (uint256) {\\n        return (x * y) / d;\\n    }\\n\\n    /// @dev Returns (`x` * `y`) / `d` rounded up.\\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256) {\\n        return (x * y + (d - 1)) / d;\\n    }\\n\\n    /// @dev Returns the sum of the first three non-zero terms of a Taylor expansion of e^(nx) - 1, to approximate a\\n    /// continuous compound interest rate.\\n    function wTaylorCompounded(uint256 x, uint256 n) internal pure returns (uint256) {\\n        uint256 firstTerm = x * n;\\n        uint256 secondTerm = mulDivDown(firstTerm, firstTerm, 2 * WAD);\\n        uint256 thirdTerm = mulDivDown(secondTerm, firstTerm, 3 * WAD);\\n\\n        return firstTerm + secondTerm + thirdTerm;\\n    }\\n}\\n\\n/// @title ErrorsLib\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @notice Library exposing error messages.\\nlibrary ErrorsLib {\\n    /// @notice Thrown when the caller is not the owner.\\n    string internal constant NOT_OWNER = \\\"not owner\\\";\\n\\n    /// @notice Thrown when the LLTV to enable exceeds the maximum LLTV.\\n    string internal constant MAX_LLTV_EXCEEDED = \\\"max LLTV exceeded\\\";\\n\\n    /// @notice Thrown when the fee to set exceeds the maximum fee.\\n    string internal constant MAX_FEE_EXCEEDED = \\\"max fee exceeded\\\";\\n\\n    /// @notice Thrown when the value is already set.\\n    string internal constant ALREADY_SET = \\\"already set\\\";\\n\\n    /// @notice Thrown when the IRM is not enabled at market creation.\\n    string internal constant IRM_NOT_ENABLED = \\\"IRM not enabled\\\";\\n\\n    /// @notice Thrown when the LLTV is not enabled at market creation.\\n    string internal constant LLTV_NOT_ENABLED = \\\"LLTV not enabled\\\";\\n\\n    /// @notice Thrown when the market is already created.\\n    string internal constant MARKET_ALREADY_CREATED = \\\"market already created\\\";\\n\\n    /// @notice Thrown when the market is not created.\\n    string internal constant MARKET_NOT_CREATED = \\\"market not created\\\";\\n\\n    /// @notice Thrown when not exactly one of the input amount is zero.\\n    string internal constant INCONSISTENT_INPUT = \\\"inconsistent input\\\";\\n\\n    /// @notice Thrown when zero assets is passed as input.\\n    string internal constant ZERO_ASSETS = \\\"zero assets\\\";\\n\\n    /// @notice Thrown when a zero address is passed as input.\\n    string internal constant ZERO_ADDRESS = \\\"zero address\\\";\\n\\n    /// @notice Thrown when the caller is not authorized to conduct an action.\\n    string internal constant UNAUTHORIZED = \\\"unauthorized\\\";\\n\\n    /// @notice Thrown when the collateral is insufficient to `borrow` or `withdrawCollateral`.\\n    string internal constant INSUFFICIENT_COLLATERAL = \\\"insufficient collateral\\\";\\n\\n    /// @notice Thrown when the liquidity is insufficient to `withdraw` or `borrow`.\\n    string internal constant INSUFFICIENT_LIQUIDITY = \\\"insufficient liquidity\\\";\\n\\n    /// @notice Thrown when the position to liquidate is healthy.\\n    string internal constant HEALTHY_POSITION = \\\"position is healthy\\\";\\n\\n    /// @notice Thrown when the authorization signature is invalid.\\n    string internal constant INVALID_SIGNATURE = \\\"invalid signature\\\";\\n\\n    /// @notice Thrown when the authorization signature is expired.\\n    string internal constant SIGNATURE_EXPIRED = \\\"signature expired\\\";\\n\\n    /// @notice Thrown when the nonce is invalid.\\n    string internal constant INVALID_NONCE = \\\"invalid nonce\\\";\\n\\n    /// @notice Thrown when a token transfer reverted.\\n    string internal constant TRANSFER_REVERTED = \\\"transfer reverted\\\";\\n\\n    /// @notice Thrown when a token transfer returned false.\\n    string internal constant TRANSFER_RETURNED_FALSE = \\\"transfer returned false\\\";\\n\\n    /// @notice Thrown when a token transferFrom reverted.\\n    string internal constant TRANSFER_FROM_REVERTED = \\\"transferFrom reverted\\\";\\n\\n    /// @notice Thrown when a token transferFrom returned false\\n    string internal constant TRANSFER_FROM_RETURNED_FALSE = \\\"transferFrom returned false\\\";\\n\\n    /// @notice Thrown when the maximum uint128 is exceeded.\\n    string internal constant MAX_UINT128_EXCEEDED = \\\"max uint128 exceeded\\\";\\n}\\n\\n/// @title UtilsLib\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @notice Library exposing helpers.\\n/// @dev Inspired by https://github.com/morpho-org/morpho-utils.\\nlibrary UtilsLib {\\n    /// @dev Returns true if there is exactly one zero among `x` and `y`.\\n    function exactlyOneZero(uint256 x, uint256 y) internal pure returns (bool z) {\\n        assembly {\\n            z := xor(iszero(x), iszero(y))\\n        }\\n    }\\n\\n    /// @dev Returns the min of `x` and `y`.\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            z := xor(x, mul(xor(x, y), lt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns `x` safely cast to uint128.\\n    function toUint128(uint256 x) internal pure returns (uint128) {\\n        require(x <= type(uint128).max, ErrorsLib.MAX_UINT128_EXCEEDED);\\n        return uint128(x);\\n    }\\n\\n    /// @dev Returns max(x - y, 0).\\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            z := mul(gt(x, y), sub(x, y))\\n        }\\n    }\\n}\\n\\n/// @title MorphoStorageLib\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @notice Helper library exposing getters to access Morpho storage variables' slot.\\n/// @dev This library is not used in Morpho itself and is intended to be used by integrators.\\nlibrary MorphoStorageLib {\\n    /* SLOTS */\\n\\n    uint256 internal constant OWNER_SLOT = 0;\\n    uint256 internal constant FEE_RECIPIENT_SLOT = 1;\\n    uint256 internal constant POSITION_SLOT = 2;\\n    uint256 internal constant MARKET_SLOT = 3;\\n    uint256 internal constant IS_IRM_ENABLED_SLOT = 4;\\n    uint256 internal constant IS_LLTV_ENABLED_SLOT = 5;\\n    uint256 internal constant IS_AUTHORIZED_SLOT = 6;\\n    uint256 internal constant NONCE_SLOT = 7;\\n    uint256 internal constant ID_TO_MARKET_PARAMS_SLOT = 8;\\n\\n    /* SLOT OFFSETS */\\n\\n    uint256 internal constant LOAN_TOKEN_OFFSET = 0;\\n    uint256 internal constant COLLATERAL_TOKEN_OFFSET = 1;\\n    uint256 internal constant ORACLE_OFFSET = 2;\\n    uint256 internal constant IRM_OFFSET = 3;\\n    uint256 internal constant LLTV_OFFSET = 4;\\n\\n    uint256 internal constant SUPPLY_SHARES_OFFSET = 0;\\n    uint256 internal constant BORROW_SHARES_AND_COLLATERAL_OFFSET = 1;\\n\\n    uint256 internal constant TOTAL_SUPPLY_ASSETS_AND_SHARES_OFFSET = 0;\\n    uint256 internal constant TOTAL_BORROW_ASSETS_AND_SHARES_OFFSET = 1;\\n    uint256 internal constant LAST_UPDATE_AND_FEE_OFFSET = 2;\\n\\n    /* GETTERS */\\n\\n    function ownerSlot() internal pure returns (bytes32) {\\n        return bytes32(OWNER_SLOT);\\n    }\\n\\n    function feeRecipientSlot() internal pure returns (bytes32) {\\n        return bytes32(FEE_RECIPIENT_SLOT);\\n    }\\n\\n    function positionSupplySharesSlot(Id id, address user) internal pure returns (bytes32) {\\n        return bytes32(\\n            uint256(keccak256(abi.encode(user, keccak256(abi.encode(id, POSITION_SLOT))))) + SUPPLY_SHARES_OFFSET\\n        );\\n    }\\n\\n    function positionBorrowSharesAndCollateralSlot(Id id, address user) internal pure returns (bytes32) {\\n        return bytes32(\\n            uint256(keccak256(abi.encode(user, keccak256(abi.encode(id, POSITION_SLOT)))))\\n                + BORROW_SHARES_AND_COLLATERAL_OFFSET\\n        );\\n    }\\n\\n    function marketTotalSupplyAssetsAndSharesSlot(Id id) internal pure returns (bytes32) {\\n        return bytes32(uint256(keccak256(abi.encode(id, MARKET_SLOT))) + TOTAL_SUPPLY_ASSETS_AND_SHARES_OFFSET);\\n    }\\n\\n    function marketTotalBorrowAssetsAndSharesSlot(Id id) internal pure returns (bytes32) {\\n        return bytes32(uint256(keccak256(abi.encode(id, MARKET_SLOT))) + TOTAL_BORROW_ASSETS_AND_SHARES_OFFSET);\\n    }\\n\\n    function marketLastUpdateAndFeeSlot(Id id) internal pure returns (bytes32) {\\n        return bytes32(uint256(keccak256(abi.encode(id, MARKET_SLOT))) + LAST_UPDATE_AND_FEE_OFFSET);\\n    }\\n\\n    function isIrmEnabledSlot(address irm) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(irm, IS_IRM_ENABLED_SLOT));\\n    }\\n\\n    function isLltvEnabledSlot(uint256 lltv) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(lltv, IS_LLTV_ENABLED_SLOT));\\n    }\\n\\n    function isAuthorizedSlot(address authorizer, address authorizee) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(authorizee, keccak256(abi.encode(authorizer, IS_AUTHORIZED_SLOT))));\\n    }\\n\\n    function nonceSlot(address authorizer) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(authorizer, NONCE_SLOT));\\n    }\\n\\n    function idToLoanTokenSlot(Id id) internal pure returns (bytes32) {\\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + LOAN_TOKEN_OFFSET);\\n    }\\n\\n    function idToCollateralTokenSlot(Id id) internal pure returns (bytes32) {\\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + COLLATERAL_TOKEN_OFFSET);\\n    }\\n\\n    function idToOracleSlot(Id id) internal pure returns (bytes32) {\\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + ORACLE_OFFSET);\\n    }\\n\\n    function idToIrmSlot(Id id) internal pure returns (bytes32) {\\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + IRM_OFFSET);\\n    }\\n\\n    function idToLltvSlot(Id id) internal pure returns (bytes32) {\\n        return bytes32(uint256(keccak256(abi.encode(id, ID_TO_MARKET_PARAMS_SLOT))) + LLTV_OFFSET);\\n    }\\n}\\n\\n/// @title MorphoLib\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @notice Helper library to access Morpho storage variables.\\n/// @dev Warning: Supply and borrow getters may return outdated values that do not include accrued interest.\\nlibrary MorphoLib {\\n    function supplyShares(IMorpho morpho, Id id, address user) internal view returns (uint256) {\\n        bytes32[] memory slot = _array(MorphoStorageLib.positionSupplySharesSlot(id, user));\\n        return uint256(morpho.extSloads(slot)[0]);\\n    }\\n\\n    function borrowShares(IMorpho morpho, Id id, address user) internal view returns (uint256) {\\n        bytes32[] memory slot = _array(MorphoStorageLib.positionBorrowSharesAndCollateralSlot(id, user));\\n        return uint128(uint256(morpho.extSloads(slot)[0]));\\n    }\\n\\n    function collateral(IMorpho morpho, Id id, address user) internal view returns (uint256) {\\n        bytes32[] memory slot = _array(MorphoStorageLib.positionBorrowSharesAndCollateralSlot(id, user));\\n        return uint256(morpho.extSloads(slot)[0] >> 128);\\n    }\\n\\n    function totalSupplyAssets(IMorpho morpho, Id id) internal view returns (uint256) {\\n        bytes32[] memory slot = _array(MorphoStorageLib.marketTotalSupplyAssetsAndSharesSlot(id));\\n        return uint128(uint256(morpho.extSloads(slot)[0]));\\n    }\\n\\n    function totalSupplyShares(IMorpho morpho, Id id) internal view returns (uint256) {\\n        bytes32[] memory slot = _array(MorphoStorageLib.marketTotalSupplyAssetsAndSharesSlot(id));\\n        return uint256(morpho.extSloads(slot)[0] >> 128);\\n    }\\n\\n    function totalBorrowAssets(IMorpho morpho, Id id) internal view returns (uint256) {\\n        bytes32[] memory slot = _array(MorphoStorageLib.marketTotalBorrowAssetsAndSharesSlot(id));\\n        return uint128(uint256(morpho.extSloads(slot)[0]));\\n    }\\n\\n    function totalBorrowShares(IMorpho morpho, Id id) internal view returns (uint256) {\\n        bytes32[] memory slot = _array(MorphoStorageLib.marketTotalBorrowAssetsAndSharesSlot(id));\\n        return uint256(morpho.extSloads(slot)[0] >> 128);\\n    }\\n\\n    function lastUpdate(IMorpho morpho, Id id) internal view returns (uint256) {\\n        bytes32[] memory slot = _array(MorphoStorageLib.marketLastUpdateAndFeeSlot(id));\\n        return uint128(uint256(morpho.extSloads(slot)[0]));\\n    }\\n\\n    function fee(IMorpho morpho, Id id) internal view returns (uint256) {\\n        bytes32[] memory slot = _array(MorphoStorageLib.marketLastUpdateAndFeeSlot(id));\\n        return uint256(morpho.extSloads(slot)[0] >> 128);\\n    }\\n\\n    function _array(bytes32 x) private pure returns (bytes32[] memory) {\\n        bytes32[] memory res = new bytes32[](1);\\n        res[0] = x;\\n        return res;\\n    }\\n}\\n\\n/// @title SharesMathLib\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @notice Shares management library.\\n/// @dev This implementation mitigates share price manipulations, using OpenZeppelin's method of virtual shares:\\n/// https://docs.openzeppelin.com/contracts/4.x/erc4626#inflation-attack.\\nlibrary SharesMathLib {\\n    using MathLib for uint256;\\n\\n    /// @dev The number of virtual shares has been chosen low enough to prevent overflows, and high enough to ensure\\n    /// high precision computations.\\n    uint256 internal constant VIRTUAL_SHARES = 1e6;\\n\\n    /// @dev A number of virtual assets of 1 enforces a conversion rate between shares and assets when a market is\\n    /// empty.\\n    uint256 internal constant VIRTUAL_ASSETS = 1;\\n\\n    /// @dev Calculates the value of `assets` quoted in shares, rounding down.\\n    function toSharesDown(uint256 assets, uint256 totalAssets, uint256 totalShares) internal pure returns (uint256) {\\n        return assets.mulDivDown(totalShares + VIRTUAL_SHARES, totalAssets + VIRTUAL_ASSETS);\\n    }\\n\\n    /// @dev Calculates the value of `shares` quoted in assets, rounding down.\\n    function toAssetsDown(uint256 shares, uint256 totalAssets, uint256 totalShares) internal pure returns (uint256) {\\n        return shares.mulDivDown(totalAssets + VIRTUAL_ASSETS, totalShares + VIRTUAL_SHARES);\\n    }\\n\\n    /// @dev Calculates the value of `assets` quoted in shares, rounding up.\\n    function toSharesUp(uint256 assets, uint256 totalAssets, uint256 totalShares) internal pure returns (uint256) {\\n        return assets.mulDivUp(totalShares + VIRTUAL_SHARES, totalAssets + VIRTUAL_ASSETS);\\n    }\\n\\n    /// @dev Calculates the value of `shares` quoted in assets, rounding up.\\n    function toAssetsUp(uint256 shares, uint256 totalAssets, uint256 totalShares) internal pure returns (uint256) {\\n        return shares.mulDivUp(totalAssets + VIRTUAL_ASSETS, totalShares + VIRTUAL_SHARES);\\n    }\\n}\\n\\n/// @title MorphoBalancesLib\\n/// @author Morpho Labs\\n/// @custom:contact security@morpho.org\\n/// @notice Helper library exposing getters with the expected value after interest accrual.\\n/// @dev This library is not used in Morpho itself and is intended to be used by integrators.\\n/// @dev The getter to retrieve the expected total borrow shares is not exposed because interest accrual does not apply\\n/// to it. The value can be queried directly on Morpho using `totalBorrowShares`.\\nlibrary MorphoBalancesLib {\\n    using MathLib for uint256;\\n    using MathLib for uint128;\\n    using UtilsLib for uint256;\\n    using MorphoLib for IMorpho;\\n    using SharesMathLib for uint256;\\n    using MarketParamsLib for MarketParams;\\n\\n    /// @notice Returns the expected market balances of a market after having accrued interest.\\n    /// @return The expected total supply assets.\\n    /// @return The expected total supply shares.\\n    /// @return The expected total borrow assets.\\n    /// @return The expected total borrow shares.\\n    function expectedMarketBalances(IMorpho morpho, MarketParams memory marketParams)\\n        internal\\n        view\\n        returns (uint256, uint256, uint256, uint256)\\n    {\\n        Id id = marketParams.id();\\n\\n        Market memory market = morpho.market(id);\\n\\n        uint256 elapsed = block.timestamp - market.lastUpdate;\\n\\n        // Skipped if elapsed == 0 of if totalBorrowAssets == 0 because interest would be null.\\n        if (elapsed != 0 && market.totalBorrowAssets != 0) {\\n            uint256 borrowRate = IIrm(marketParams.irm).borrowRateView(marketParams, market);\\n            uint256 interest = market.totalBorrowAssets.wMulDown(borrowRate.wTaylorCompounded(elapsed));\\n            market.totalBorrowAssets += interest.toUint128();\\n            market.totalSupplyAssets += interest.toUint128();\\n\\n            if (market.fee != 0) {\\n                uint256 feeAmount = interest.wMulDown(market.fee);\\n                // The fee amount is subtracted from the total supply in this calculation to compensate for the fact\\n                // that total supply is already updated.\\n                uint256 feeShares =\\n                    feeAmount.toSharesDown(market.totalSupplyAssets - feeAmount, market.totalSupplyShares);\\n                market.totalSupplyShares += feeShares.toUint128();\\n            }\\n        }\\n\\n        return (market.totalSupplyAssets, market.totalSupplyShares, market.totalBorrowAssets, market.totalBorrowShares);\\n    }\\n\\n    /// @notice Returns the expected total supply assets of a market after having accrued interest.\\n    function expectedTotalSupplyAssets(IMorpho morpho, MarketParams memory marketParams)\\n        internal\\n        view\\n        returns (uint256 totalSupplyAssets)\\n    {\\n        (totalSupplyAssets,,,) = expectedMarketBalances(morpho, marketParams);\\n    }\\n\\n    /// @notice Returns the expected total borrow assets of a market after having accrued interest.\\n    function expectedTotalBorrowAssets(IMorpho morpho, MarketParams memory marketParams)\\n        internal\\n        view\\n        returns (uint256 totalBorrowAssets)\\n    {\\n        (,, totalBorrowAssets,) = expectedMarketBalances(morpho, marketParams);\\n    }\\n\\n    /// @notice Returns the expected total supply shares of a market after having accrued interest.\\n    function expectedTotalSupplyShares(IMorpho morpho, MarketParams memory marketParams)\\n        internal\\n        view\\n        returns (uint256 totalSupplyShares)\\n    {\\n        (, totalSupplyShares,,) = expectedMarketBalances(morpho, marketParams);\\n    }\\n\\n    /// @notice Returns the expected supply assets balance of `user` on a market after having accrued interest.\\n    /// @dev Warning: Wrong for `feeRecipient` because their supply shares increase is not taken into account.\\n    /// @dev Warning: Withdrawing a supply position using the expected assets balance can lead to a revert due to\\n    /// conversion roundings between shares and assets.\\n    function expectedSupplyAssets(IMorpho morpho, MarketParams memory marketParams, address user)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        Id id = marketParams.id();\\n        uint256 supplyShares = morpho.supplyShares(id, user);\\n        (uint256 totalSupplyAssets, uint256 totalSupplyShares,,) = expectedMarketBalances(morpho, marketParams);\\n\\n        return supplyShares.toAssetsDown(totalSupplyAssets, totalSupplyShares);\\n    }\\n\\n    /// @notice Returns the expected borrow assets balance of `user` on a market after having accrued interest.\\n    /// @dev Warning: repaying a borrow position using the expected assets balance can lead to a revert due to\\n    /// conversion roundings between shares and assets.\\n    function expectedBorrowAssets(IMorpho morpho, MarketParams memory marketParams, address user)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        Id id = marketParams.id();\\n        uint256 borrowShares = morpho.borrowShares(id, user);\\n        (,, uint256 totalBorrowAssets, uint256 totalBorrowShares) = expectedMarketBalances(morpho, marketParams);\\n\\n        return borrowShares.toAssetsUp(totalBorrowAssets, totalBorrowShares);\\n    }\\n}\\n\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\\ncontract MetaMorphoSnippets {\\n    using MathLib for uint256;\\n    using Math for uint256;\\n    using MarketParamsLib for MarketParams;\\n    using MorphoBalancesLib for IMorpho;\\n\\n    IMorpho public immutable morpho;\\n\\n    constructor(address morphoAddress) {\\n        morpho = IMorpho(morphoAddress);\\n    }\\n\\n    // --- VIEW FUNCTIONS ---\\n\\n    /// @notice Returns the current APR of the vault on a Morpho Blue market.\\n    /// @param marketParams The morpho blue market parameters.\\n    /// @param market The morpho blue market state.\\n    function supplyAPRMarket(MarketParams memory marketParams, Market memory market)\\n        public\\n        view\\n        returns (uint256 supplyRate)\\n    {\\n        supplyRate = supplyAPRMarket(marketParams, market, 0, 0);\\n    }\\n\\n    /// @notice Returns the current APR of the vault on a Morpho Blue market.\\n    /// @param marketParams The morpho blue market parameters.\\n    /// @param market The morpho blue market state.\\n    /// @param add The amount to add to the market balance.\\n    /// @param sub The amount to subtract from the market balance.\\n    function supplyAPRMarket(MarketParams memory marketParams, Market memory market, uint256 add, uint256 sub)\\n        public\\n        view\\n        returns (uint256 supplyRate)\\n    {\\n        // Get the borrow rate\\n        uint256 borrowRate;\\n        if (marketParams.irm == address(0) || (sub > 0 && (uint256(market.totalSupplyAssets) + add) <= sub)) {\\n            return 0;\\n        } else {\\n            // simulate change in market total assets\\n            market.totalSupplyAssets = uint128(uint256(market.totalSupplyAssets) + add - sub);\\n            borrowRate = IIrm(marketParams.irm).borrowRateView(marketParams, market);\\n        }\\n\\n        (uint256 totalSupplyAssets,, uint256 totalBorrowAssets,) = morpho.expectedMarketBalances(marketParams);\\n        if (sub > 0 && (totalSupplyAssets + add) <= sub) {\\n            return 0;\\n        }\\n        // Get the supply rate using add/sub simulations\\n        uint256 utilization = totalBorrowAssets == 0 ? 0 : totalBorrowAssets.wDivUp(totalSupplyAssets + add - sub);\\n        supplyRate = borrowRate.wMulDown(1 ether - market.fee).wMulDown(utilization);\\n    }\\n\\n    /// @notice Returns the current APY of a MetaMorpho vault.\\n    /// @dev It is computed as the sum of all APY of enabled markets weighted by the supply on these markets.\\n    /// @param vault The address of the MetaMorpho vault.\\n    function supplyAPRVault(address vault) public view returns (uint256 avgSupplyRate) {\\n        avgSupplyRate = supplyAPRVault(vault, 0, 0);\\n    }\\n\\n    /// @notice Returns the current APY of a MetaMorpho vault.\\n    /// @dev It is computed as the sum of all APY of enabled markets weighted by the supply on these markets.\\n    /// @param vault The address of the MetaMorpho vault.\\n    /// @param add The amount to add to the vault balance.\\n    /// @param sub The amount to subtract from the vault balance.\\n    function supplyAPRVault(address vault, uint256 add, uint256 sub) public view returns (uint256 avgSupplyRate) {\\n        uint256 ratio;\\n        uint256 expectedSupply;\\n        uint256 queueLength = IMetaMorpho(vault).withdrawQueueLength();\\n        uint256 supplyQueueLength = IMetaMorpho(vault).supplyQueueLength();\\n        uint256 newTotalAmount = IMetaMorpho(vault).totalAssets();\\n\\n        if (sub > 0 && (newTotalAmount + add) <= sub) {\\n            // impossible to remove more than the vault has\\n            return 0;\\n        }\\n        // simulate change in vault total assets\\n        newTotalAmount = newTotalAmount + add - sub;\\n\\n        for (uint256 i; i < queueLength; ++i) {\\n            Id idMarket = IMetaMorpho(vault).withdrawQueue(i);\\n            MarketParams memory marketParams = morpho.idToMarketParams(idMarket);\\n            uint256 toAdd;\\n            if (add > 0) {\\n                toAdd = _calcMarketAdd(IMetaMorpho(vault), idMarket, supplyQueueLength, add);\\n            }\\n            uint256 toSub;\\n            if (sub > 0) {\\n                (toSub, sub) = _calcMarketSub(IMetaMorpho(vault), idMarket, sub);\\n            }\\n\\n            expectedSupply = morpho.expectedSupplyAssets(marketParams, vault);\\n            if (toSub > 0 && (expectedSupply + toAdd) < toSub) {\\n                // impossible to remove more than the vault assets\\n                sub += toSub;\\n                continue;\\n            }\\n            // Use scaled add and sub values to calculate current supply APR Market\\n            ratio += supplyAPRMarket(marketParams, morpho.market(idMarket), toAdd, toSub).wMulDown(\\n                // Use scaled add and sub values to calculate assets supplied\\n                expectedSupply + toAdd - toSub\\n            );\\n        }\\n\\n        // If there is still some liquidity to remove here it means there is not enough liquidity\\n        // in the vault to cover the requested withdraw amount\\n        if (sub > 0) {\\n            return 0;\\n        }\\n\\n        avgSupplyRate = ratio.mulDivDown(WAD - IMetaMorpho(vault).fee(), newTotalAmount);\\n    }\\n\\n    /// @notice calculate how much of vault `_add` amount will be added to this market\\n    /// @param _mmVault metamorpho vault\\n    /// @param _targetMarketId target market id\\n    /// @param _supplyQueueLen supply queue length\\n    /// @param _add amount of liquidity to add\\n    function _calcMarketAdd(\\n        IMetaMorpho _mmVault,\\n        Id _targetMarketId,\\n        uint256 _supplyQueueLen,\\n        uint256 _add\\n    ) internal view returns (uint256) {\\n        uint256 _assetsSuppliedByVault;\\n        uint184 _marketCap;\\n        Id _currMarketId;\\n        Market memory _market;\\n        Position memory _pos;\\n\\n        // loop throuh supplyQueue, starting from the first market, and see how much will\\n        // be deposited in target market\\n        for (uint256 i = 0; i < _supplyQueueLen; i++) {\\n            _currMarketId = _mmVault.supplyQueue(i);\\n            _market = morpho.market(_currMarketId);\\n            _pos = morpho.position(_currMarketId, address(_mmVault));\\n            _assetsSuppliedByVault = _pos.supplyShares * _market.totalSupplyAssets / _market.totalSupplyShares;\\n            // get max depositable amount for this market\\n            _marketCap = _mmVault.config(_currMarketId).cap;\\n            uint256 _maxDeposit;\\n            if (_assetsSuppliedByVault < uint256(_marketCap)) {\\n                _maxDeposit = uint256(_marketCap) - _assetsSuppliedByVault;\\n            }\\n            // If this is the target market, return the current _add value, eventually\\n            // reduced to the max depositable amount\\n            if (Id.unwrap(_currMarketId) == Id.unwrap(_targetMarketId)) {\\n                if (_add > _maxDeposit) {\\n                    _add = _maxDeposit;\\n                }\\n                break;\\n            }\\n            // If this is not the target market, check if we can deposit all the _add amount\\n            // in this market, otherwise continue the loop and subtract the max depositable\\n            if (_add > _maxDeposit) {\\n                _add -= _maxDeposit;\\n            } else {\\n                _add = 0;\\n                break;\\n            }\\n        }\\n\\n        return _add;\\n    }\\n\\n    /// @notice calculate how much of vault `_sub` amount will be removed from target market\\n    /// @param _mmVault metamorpho vault\\n    /// @param _targetMarketId target market id\\n    /// @param _sub liquidity to remove\\n    function _calcMarketSub(\\n        IMetaMorpho _mmVault, \\n        Id _targetMarketId,\\n        uint256 _sub\\n    ) internal view returns (uint256 toSub, uint256 remaining) {\\n        Market memory _market = morpho.market(_targetMarketId);\\n        Position memory _position = morpho.position(_targetMarketId, address(_mmVault));\\n        if (_market.totalSupplyShares == 0) {\\n            return (0, _sub);\\n        }\\n        uint256 _vaultAssets = _position.supplyShares * _market.totalSupplyAssets / _market.totalSupplyShares;\\n        uint256 _availableLiquidity = _market.totalSupplyAssets - _market.totalBorrowAssets;\\n        uint256 _withdrawable = _vaultAssets > _availableLiquidity ? _availableLiquidity : _vaultAssets;\\n\\n        if (_sub > _withdrawable) {\\n            (toSub, remaining) = (_withdrawable, _sub - _withdrawable);\\n        } else {\\n            (toSub, remaining) = (_sub, 0);\\n        }\\n    }\\n}\\n\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"morphoAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"morpho\",\"outputs\":[{\"internalType\":\"contract IMorpho\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"loanToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"irm\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lltv\",\"type\":\"uint256\"}],\"internalType\":\"struct MarketParams\",\"name\":\"marketParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"totalSupplyAssets\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"totalSupplyShares\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"totalBorrowAssets\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"totalBorrowShares\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"lastUpdate\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"fee\",\"type\":\"uint128\"}],\"internalType\":\"struct Market\",\"name\":\"market\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"add\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sub\",\"type\":\"uint256\"}],\"name\":\"supplyAPRMarket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"supplyRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"loanToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"irm\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lltv\",\"type\":\"uint256\"}],\"internalType\":\"struct MarketParams\",\"name\":\"marketParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"totalSupplyAssets\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"totalSupplyShares\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"totalBorrowAssets\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"totalBorrowShares\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"lastUpdate\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"fee\",\"type\":\"uint128\"}],\"internalType\":\"struct Market\",\"name\":\"market\",\"type\":\"tuple\"}],\"name\":\"supplyAPRMarket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"supplyRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"add\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sub\",\"type\":\"uint256\"}],\"name\":\"supplyAPRVault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"avgSupplyRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"supplyAPRVault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"avgSupplyRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MetaMorphoSnippets", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "000000000000000000000000bbbbbbbbbb9cc5e90e3b3af64bdaf62c37eeffcb", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}