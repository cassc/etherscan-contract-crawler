{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/home/metapriest/code/my_code/dotvote/contracts/contracts/SafeMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.7.4;\\n\\nlibrary SafeMathLib {\\n  function times(uint a, uint b) public pure returns (uint) {\\n    uint c = a * b;\\n    require(a == 0 || c / a == b, 'Overflow detected');\\n    return c;\\n  }\\n\\n  function minus(uint a, uint b) public pure returns (uint) {\\n    require(b <= a, 'Underflow detected');\\n    return a - b;\\n  }\\n\\n  function plus(uint a, uint b) public pure returns (uint) {\\n    uint c = a + b;\\n    require(c>=a && c>=b, 'Overflow detected');\\n    return c;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"/home/metapriest/code/my_code/dotvote/contracts/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.7.4;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"/home/metapriest/code/my_code/dotvote/contracts/contracts/yield/BasicPoolFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.7.4;\\n\\nimport \\\"../SafeMathLib.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\ncontract BasicPoolFactory {\\n    using SafeMathLib for uint;\\n\\n    struct Receipt {\\n        uint id;\\n        uint amountDepositedWei;\\n        uint timeDeposited;\\n        uint timeWithdrawn;\\n        address owner;\\n    }\\n\\n    struct Pool {\\n        uint id;\\n        uint[] rewardsWeiPerSecondPerToken;\\n        uint[] rewardsWeiClaimed;\\n        uint maximumDepositWei;\\n        uint totalDepositsWei;\\n        uint numReceipts;\\n        uint startTime;\\n        uint endTime;\\n        address depositToken;\\n        address[] rewardTokens;\\n        mapping (uint => Receipt) receipts;\\n    }\\n\\n    struct Metadata {\\n        bytes32 name;\\n        bytes32 ipfsHash;\\n    }\\n\\n    uint public numPools;\\n    mapping (uint => Pool) public pools;\\n    mapping (uint => Metadata) public metadatas;\\n\\n    address public management;\\n\\n    event DepositOccurred(uint indexed poolId, uint indexed receiptId, address indexed owner);\\n    event WithdrawalOccurred(uint indexed poolId, uint indexed receiptId, address indexed owner);\\n    event ExcessRewardsWithdrawn(uint indexed poolId);\\n    event ManagementUpdated(address oldManagement, address newManagement);\\n    event PoolAdded(uint indexed poolId, bytes32 indexed name, address indexed depositToken);\\n\\n    modifier managementOnly() {\\n        require (msg.sender == management, 'Only management may call this');\\n        _;\\n    }\\n\\n    constructor (address mgmt) {\\n        management = mgmt;\\n    }\\n\\n    // change the management key\\n    function setManagement(address newMgmt) public managementOnly {\\n        address oldMgmt = management;\\n        management = newMgmt;\\n        emit ManagementUpdated(oldMgmt, newMgmt);\\n    }\\n\\n    function addPool (\\n        uint startTime,\\n        uint maxDeposit,\\n        uint[] memory rewardsWeiPerSecondPerToken,\\n        uint programLengthDays,\\n        address depositTokenAddress,\\n        address[] memory rewardTokenAddresses,\\n        bytes32 ipfsHash,\\n        bytes32 name\\n    ) external managementOnly {\\n        numPools = numPools.plus(1);\\n        Pool storage pool = pools[numPools];\\n        pool.id = numPools;\\n        pool.rewardsWeiPerSecondPerToken = rewardsWeiPerSecondPerToken;\\n        pool.startTime = startTime > block.timestamp ? startTime : block.timestamp;\\n        pool.endTime = pool.startTime.plus(programLengthDays * 1 days);\\n        pool.depositToken = depositTokenAddress;\\n        require(rewardsWeiPerSecondPerToken.length == rewardTokenAddresses.length, 'Rewards and reward token arrays must be same length');\\n\\n        for (uint i = 0; i < rewardTokenAddresses.length; i++) {\\n            pool.rewardTokens.push(rewardTokenAddresses[i]);\\n            pool.rewardsWeiClaimed.push(0);\\n        }\\n        pool.maximumDepositWei = maxDeposit;\\n\\n        {\\n            Metadata storage metadata = metadatas[numPools];\\n            metadata.ipfsHash = ipfsHash;\\n            metadata.name = name;\\n        }\\n        emit PoolAdded(pool.id, name, depositTokenAddress);\\n    }\\n\\n    function getRewards(uint poolId, uint receiptId) public view returns (uint[] memory) {\\n        Pool storage pool = pools[poolId];\\n        Receipt memory receipt = pool.receipts[receiptId];\\n        require(pool.id == poolId, 'Uninitialized pool');\\n        require(receipt.id == receiptId, 'Uninitialized receipt');\\n        uint nowish = block.timestamp;\\n        if (nowish > pool.endTime) {\\n            nowish = pool.endTime;\\n        }\\n\\n        uint secondsDiff = nowish.minus(receipt.timeDeposited);\\n        uint[] memory rewardsLocal = new uint[](pool.rewardsWeiPerSecondPerToken.length);\\n        for (uint i = 0; i < pool.rewardsWeiPerSecondPerToken.length; i++) {\\n            rewardsLocal[i] = (secondsDiff.times(pool.rewardsWeiPerSecondPerToken[i]).times(receipt.amountDepositedWei)) / 1e18;\\n        }\\n\\n        return rewardsLocal;\\n    }\\n\\n    function deposit(uint poolId, uint amount) external {\\n        Pool storage pool = pools[poolId];\\n        require(pool.id == poolId, 'Uninitialized pool');\\n        require(block.timestamp > pool.startTime, 'Cannot deposit before pool start');\\n        require(block.timestamp < pool.endTime, 'Cannot deposit after pool ends');\\n        require(pool.totalDepositsWei < pool.maximumDepositWei, 'Maximum deposit already reached');\\n        if (pool.totalDepositsWei.plus(amount) > pool.maximumDepositWei) {\\n            amount = pool.maximumDepositWei.minus(pool.totalDepositsWei);\\n        }\\n        pool.totalDepositsWei = pool.totalDepositsWei.plus(amount);\\n        pool.numReceipts = pool.numReceipts.plus(1);\\n\\n        Receipt storage receipt = pool.receipts[pool.numReceipts];\\n        receipt.id = pool.numReceipts;\\n        receipt.amountDepositedWei = amount;\\n        receipt.timeDeposited = block.timestamp;\\n        receipt.owner = msg.sender;\\n\\n        bool success = IERC20(pool.depositToken).transferFrom(msg.sender, address(this), amount);\\n        require(success, 'Token transfer failed');\\n\\n        emit DepositOccurred(poolId, pool.numReceipts, msg.sender);\\n    }\\n\\n    function withdraw(uint poolId, uint receiptId) external {\\n        Pool storage pool = pools[poolId];\\n        require(pool.id == poolId, 'Uninitialized pool');\\n        Receipt storage receipt = pool.receipts[receiptId];\\n        require(receipt.id == receiptId, 'Can only withdraw real receipts');\\n        require(receipt.owner == msg.sender || block.timestamp > pool.endTime, 'Can only withdraw your own deposit');\\n        require(receipt.timeWithdrawn == 0, 'Can only withdraw once per receipt');\\n\\n        // close re-entry gate\\n        receipt.timeWithdrawn = block.timestamp;\\n\\n        uint[] memory rewards = getRewards(poolId, receiptId);\\n        pool.totalDepositsWei = pool.totalDepositsWei.minus(receipt.amountDepositedWei);\\n        bool success = true;\\n\\n        for (uint i = 0; i < rewards.length; i++) {\\n            pool.rewardsWeiClaimed[i] = pool.rewardsWeiClaimed[i].plus(rewards[i]);\\n            success = success && IERC20(pool.rewardTokens[i]).transfer(receipt.owner, rewards[i]);\\n        }\\n        success = success && IERC20(pool.depositToken).transfer(receipt.owner, receipt.amountDepositedWei);\\n        require(success, 'Token transfer failed');\\n\\n        emit WithdrawalOccurred(poolId, receiptId, receipt.owner);\\n    }\\n\\n    function withdrawExcessRewards(uint poolId) external {\\n        Pool storage pool = pools[poolId];\\n        require(pool.id == poolId, 'Uninitialized pool');\\n        require(pool.totalDepositsWei == 0, 'Cannot withdraw until all deposits are withdrawn');\\n        require(block.timestamp > pool.endTime, 'Contract must reach maturity');\\n\\n        bool success = true;\\n        for (uint i = 0; i < pool.rewardTokens.length; i++) {\\n            IERC20 rewardToken = IERC20(pool.rewardTokens[i]);\\n            uint rewards = rewardToken.balanceOf(address(this));\\n            success = success && rewardToken.transfer(management, rewards);\\n        }\\n        IERC20 depositToken = IERC20(pool.depositToken);\\n        success = success && depositToken.transfer(management, depositToken.balanceOf(address(this)));\\n        require(success, 'Token transfer failed');\\n        emit ExcessRewardsWithdrawn(poolId);\\n    }\\n\\n    function getRewardData(uint poolId) external view returns (uint[] memory, uint[] memory, address[] memory) {\\n        Pool storage pool = pools[poolId];\\n        return (pool.rewardsWeiPerSecondPerToken, pool.rewardsWeiClaimed, pool.rewardTokens);\\n    }\\n\\n    function getReceipt(uint poolId, uint receiptId) external view returns (uint, uint, uint, address) {\\n        Pool storage pool = pools[poolId];\\n        Receipt storage receipt = pool.receipts[receiptId];\\n        return (receipt.amountDepositedWei, receipt.timeDeposited, receipt.timeWithdrawn, receipt.owner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"/home/metapriest/code/my_code/dotvote/contracts/contracts/SafeMathLib.sol\": {\r\n        \"SafeMathLib\": \"0x82d7630c5EB722557De6D76575C9a7b8DE718500\"\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mgmt\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"receiptId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"DepositOccurred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"ExcessRewardsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldManagement\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newManagement\",\"type\":\"address\"}],\"name\":\"ManagementUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositToken\",\"type\":\"address\"}],\"name\":\"PoolAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"receiptId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"WithdrawalOccurred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"rewardsWeiPerSecondPerToken\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"programLengthDays\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"depositTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"rewardTokenAddresses\",\"type\":\"address[]\"},{\"internalType\":\"bytes32\",\"name\":\"ipfsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"receiptId\",\"type\":\"uint256\"}],\"name\":\"getReceipt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"getRewardData\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"receiptId\",\"type\":\"uint256\"}],\"name\":\"getRewards\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"management\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"metadatas\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumDepositWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDepositsWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numReceipts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"depositToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMgmt\",\"type\":\"address\"}],\"name\":\"setManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"receiptId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"withdrawExcessRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BasicPoolFactory", "CompilerVersion": "v0.7.4+commit.3f05b770", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000288fe43139741f91a8cbb6f4add83811c794851b", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}