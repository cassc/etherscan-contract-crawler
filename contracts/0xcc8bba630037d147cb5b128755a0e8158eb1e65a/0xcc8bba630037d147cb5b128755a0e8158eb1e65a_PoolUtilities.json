{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/boosting/PoolUtilities.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport \\\"../interfaces/IFxnToken.sol\\\";\\nimport \\\"../interfaces/IFxnGauge.sol\\\";\\nimport \\\"../interfaces/IGaugeController.sol\\\";\\nimport \\\"../interfaces/IPoolRegistry.sol\\\";\\nimport \\\"../interfaces/IProxyVault.sol\\\";\\nimport \\\"../interfaces/IVoteEscrow.sol\\\";\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\n/*\\nThis is a utility library which is mainly used for off chain calculations\\n*/\\ncontract PoolUtilities{\\n    address public constant convexProxy = address(0xd11a4Ee017cA0BECA8FA45fF2abFe9C6267b7881);\\n    address public constant fxn = address(0x365AccFCa291e7D3914637ABf1F7635dB165Bb09);\\n    address public constant vefxn = address(0xEC6B8A3F3605B083F7044C0F31f2cac0caf1d469);\\n    address public constant gaugeController = address(0xe60eB8098B34eD775ac44B1ddE864e098C6d7f37);\\n    uint256 internal constant TOKENLESS_PRODUCTION = 40;\\n    address public immutable poolRegistry;\\n\\n    constructor(address _poolRegistry){\\n        poolRegistry = _poolRegistry;\\n    }\\n\\n    //get apr with given rates and prices\\n    function apr(uint256 _rate, uint256 _priceOfReward, uint256 _priceOfDeposit) external pure returns(uint256 _apr){\\n        return _rate * 365 days * _priceOfReward / _priceOfDeposit; \\n    }\\n\\n    function gaugeWorkingBalance(address _gauge) public view returns (uint256) {\\n        uint256 _veSupply = IVoteEscrow(vefxn).totalSupply();\\n\\n        uint256 _supply = IFxnGauge(_gauge).totalSupply();\\n\\n        // if (_owner == address(0)) _owner = _account;\\n        uint256 _veBalance = IVoteEscrow(IFxnGauge(_gauge).veProxy()).adjustedVeBalance(convexProxy);\\n        uint256 _balance = IFxnGauge(_gauge).sharedBalanceOf(convexProxy);\\n        uint256 _workingBalance = (_balance * TOKENLESS_PRODUCTION) / 100;\\n        if (_veSupply > 0) {\\n          _workingBalance += (((_supply * _veBalance) / _veSupply) * (100 - TOKENLESS_PRODUCTION)) / 100;\\n        }\\n        if (_workingBalance > _balance) {\\n          _workingBalance = _balance;\\n        }\\n\\n        return _workingBalance;\\n      }\\n\\n    //get rates of each token per deposit for the specified pool id\\n    function poolRewardRatesById(uint256 _pid) external view returns (address[] memory tokens, uint256[] memory rates) {\\n        (address _imp, address _gaugeAddress, , ,) = IPoolRegistry(poolRegistry).poolInfo(_pid);\\n        IProxyVault.VaultType vtype = IProxyVault(_imp).vaultType();\\n        if(vtype == IProxyVault.VaultType.RebalancePool){\\n            return rebalancePoolRewardRates(_gaugeAddress);\\n        }\\n        return gaugeRewardRates(_gaugeAddress);\\n    }\\n\\n    //get rates of each token per deposit for the specified gauge\\n    function gaugeRewardRates(address _gauge) public view returns (address[] memory tokens, uint256[] memory rates) {\\n        //get token emission rates and gauge weighting\\n        uint256 emissionRate = IFxnToken(fxn).rate();\\n        uint256 gaugeWeight = IGaugeController(gaugeController).gauge_relative_weight(_gauge);\\n\\n        //get list of reward tokens\\n        address[] memory rewardTokens = IFxnGauge(_gauge).getActiveRewardTokens();\\n        rates = new uint256[](rewardTokens.length + 1);\\n        tokens = new address[](rewardTokens.length + 1);\\n\\n        //get supplies and deposits\\n        uint256 gaugeSupply = IFxnGauge(_gauge).totalSupply();\\n        uint256 gaugeWorkingSupply = IFxnGauge(_gauge).workingSupply();\\n        uint256 convexWorking = gaugeWorkingBalance(_gauge);\\n        uint256 convexDeposits = IFxnGauge(_gauge).sharedBalanceOf(convexProxy);\\n\\n        //emission rate per working supply\\n        if(gaugeWorkingSupply > 0){\\n            emissionRate = emissionRate * gaugeWeight / gaugeWorkingSupply;\\n        }else{\\n            emissionRate = emissionRate * gaugeWeight / 1e18;\\n        }\\n\\n        //convex emission rate per deposit for minting fxn\\n        if(convexDeposits > 0){\\n            rates[0] = convexWorking * emissionRate / convexDeposits;\\n        }else{\\n            rates[0] = emissionRate; //if no deposits, will always be max boost\\n        }\\n        tokens[0] = fxn;\\n\\n        //calc extra rewards (not boosted, ratePerDepost = rate/totalSupply)\\n        for(uint256 i = 0; i < rewardTokens.length; i++){\\n            (,uint80 _rate,,uint40 finishAt) = IFxnGauge(_gauge).rewardData(rewardTokens[i]);\\n\\n            if(block.timestamp <= uint256(finishAt)){\\n                rates[i+1] = uint256(_rate);\\n                if(gaugeSupply > 0){\\n                    rates[i+1] = uint256(_rate) * 1e18 / gaugeSupply;\\n                }\\n            }\\n            tokens[i+1] = rewardTokens[i];\\n        }\\n    }\\n\\n    //get rates of each token per deposit for the specified rebalance pool\\n    function rebalancePoolRewardRates(address _pool) public view returns (address[] memory tokens, uint256[] memory rates) {\\n        //get list of reward tokens\\n        address[] memory rewardTokens = IFxnGauge(_pool).getActiveRewardTokens();\\n        rates = new uint256[](rewardTokens.length);\\n        tokens = new address[](rewardTokens.length);\\n\\n        //get total supply on the pool\\n        uint256 gaugeSupply = IFxnGauge(_pool).totalSupply();\\n\\n        //get boost ratio\\n        uint256 boostRatio = getRebalancePoolBoostRatio(_pool);\\n\\n        //calc extra rewards (not boosted, ratePerDepost = rate/totalSupply)\\n        for(uint256 i = 0; i < rewardTokens.length; i++){\\n            (,uint80 _rate,,uint40 finishAt) = IFxnGauge(_pool).rewardData(rewardTokens[i]);\\n\\n            if(block.timestamp <= uint256(finishAt)){\\n                rates[i] = uint256(_rate);\\n                if(gaugeSupply > 0){\\n                    rates[i] = rates[i] * 1e18 / gaugeSupply;\\n                }\\n                if(rewardTokens[i] == fxn){\\n                    rates[i] = rates[i] * boostRatio / 1e18;\\n                }\\n            }\\n            tokens[i] = rewardTokens[i];\\n        }\\n    }\\n\\n    //get boost ratio for the specified pool id\\n    function poolBoostRatioById(uint256 _pid) external view returns (uint256){\\n        (address _imp, address _gaugeAddress, , ,) = IPoolRegistry(poolRegistry).poolInfo(_pid);\\n        IProxyVault.VaultType vtype = IProxyVault(_imp).vaultType();\\n        if(vtype == IProxyVault.VaultType.RebalancePool){\\n            return getRebalancePoolBoostRatio(_gaugeAddress);\\n        }\\n        return getGaugeBoostRatio(_gaugeAddress);\\n    }\\n\\n    //get boost ratio of an lp gauge\\n    function getGaugeBoostRatio(address _gauge) public view returns(uint256){\\n        //get working and deposits\\n        uint256 convexWorking = gaugeWorkingBalance(_gauge);\\n        uint256 convexDeposits = IFxnGauge(_gauge).sharedBalanceOf(convexProxy);\\n\\n        if(convexDeposits == 0) return 1e18;\\n\\n        return convexWorking * 1e18 / convexDeposits;\\n    }\\n\\n    //get boost ratio of a rebalance pool\\n    function getRebalancePoolBoostRatio(address _pool) public view returns(uint256){\\n        //getBoostRatio on the pool is only for a depositing user and not the parent proxy\\n        //thus we have to calc the boost here\\n        //working balance = min(balance, balance * 0.4 + 0.6 * veBalance * supply / veSupply) / balance\\n        uint256 gaugeSupply = IFxnGauge(_pool).totalSupply();\\n        uint256 vesupply = IERC20(vefxn).totalSupply();\\n        uint256 vebalance = IERC20(vefxn).balanceOf(convexProxy);\\n\\n        //if no one is staked, assume full boost\\n        if(gaugeSupply == 0) return 1e18;\\n\\n        (, uint256 balance, ) = IFxnGauge(_pool).voteOwnerBalances(convexProxy);\\n        //if no one is using convex yet, assume full boost\\n        if(balance == 0) return 1e18;\\n\\n        //40%\\n        uint256 boostedBalance = uint256(balance) * 4 / 10;\\n        // add vebalance ratio up to 60%\\n        boostedBalance += vebalance * gaugeSupply / vesupply * 6 / 10;\\n\\n        if(boostedBalance > balance){\\n            boostedBalance = balance;\\n        }\\n\\n        return boostedBalance * 1e18 / balance;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IVoteEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\ninterface IVoteEscrow {\\n    function locked(address) external view returns(uint256);\\n    function locked__end(address) external view returns(uint256);\\n    function create_lock(uint256, uint256) external;\\n    function increase_amount(uint256) external;\\n    function increase_unlock_time(uint256) external;\\n    function withdraw() external;\\n    function checkpoint() external;\\n    function admin() external view returns (address);\\n    function smart_wallet_checker() external view returns (address);\\n    function commit_smart_wallet_checker(address _checker) external;\\n    function apply_smart_wallet_checker() external;\\n    function adjustedVeBalance(address _account) external view returns (uint256);\\n    function totalSupply() external view returns(uint256);\\n}\"\r\n    },\r\n    \"/contracts/interfaces/IProxyVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\ninterface IProxyVault {\\n\\n    enum VaultType{\\n        Erc20Basic,\\n        RebalancePool\\n    }\\n\\n    function vaultType() external view returns(VaultType);\\n    function vaultVersion() external view returns(uint256);\\n    function initialize(address _owner, uint256 _pid) external;\\n    function pid() external returns(uint256);\\n    function usingProxy() external returns(address);\\n    function owner() external returns(address);\\n    function gaugeAddress() external returns(address);\\n    function stakingToken() external returns(address);\\n    function rewards() external returns(address);\\n    function getReward() external;\\n    function getReward(bool _claim) external;\\n    function getReward(bool _claim, address[] calldata _rewardTokenList) external;\\n    function earned() external returns (address[] memory token_addresses, uint256[] memory total_earned);\\n}\"\r\n    },\r\n    \"/contracts/interfaces/IPoolRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\ninterface IPoolRegistry {\\n    function poolLength() external view returns(uint256);\\n    function poolInfo(uint256 _pid) external view returns(address, address, address, address, uint8);\\n    function vaultMap(uint256 _pid, address _user) external view returns(address vault);\\n    function addUserVault(uint256 _pid, address _user) external returns(address vault, address stakeAddress, address stakeToken, address rewards);\\n    function deactivatePool(uint256 _pid) external;\\n    function addPool(address _implementation, address _stakingAddress, address _stakingToken) external;\\n    function setRewardActiveOnCreation(bool _active) external;\\n    function setRewardImplementation(address _imp) external;\\n}\"\r\n    },\r\n    \"/contracts/interfaces/IGaugeController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\ninterface IGaugeController {\\n    function add_gauge(address,int128,uint256) external;\\n    function add_type(string calldata, uint256) external;\\n    function admin() external view returns(address);\\n    function gauge_relative_weight(address) external view returns(uint256);\\n}\"\r\n    },\r\n    \"/contracts/interfaces/IFxnToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IFxnToken{\\n    function rate() external view returns(uint256);\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IFxnGauge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IFxnGauge{\\n\\n    //basics\\n    function stakingToken() external view returns(address);\\n    function totalSupply() external view returns(uint256);\\n    function workingSupply() external view returns(uint256);\\n    function workingBalanceOf(address _account) external view returns(uint256);\\n    function deposit(uint256 _amount) external;\\n    function deposit(uint256 _amount, address _receiver) external;\\n    function withdraw(uint256 _amount) external;\\n    function withdraw(uint256 _amount, address _receiver) external;\\n    function user_checkpoint(address _account) external returns (bool);\\n    function balanceOf(address _account) external view returns(uint256);\\n    function integrate_fraction(address account) external view returns (uint256);\\n    function baseToken() external view returns(address);\\n    function asset() external view returns(address);\\n    function market() external view returns(address);\\n\\n    //weight sharing\\n    function toggleVoteSharing(address _staker) external;\\n    function acceptSharedVote(address _newOwner) external;\\n    function rejectSharedVote() external;\\n    function getStakerVoteOwner(address _account) external view returns (address);\\n    function numAcceptedStakers(address _account) external view returns (uint256);\\n    function sharedBalanceOf(address _account) external view returns (uint256);\\n    function veProxy() external view returns(address);\\n\\n    //rewards\\n    function rewardData(address _token) external view returns(uint96 queued, uint80 rate, uint40 lastUpdate, uint40 finishAt);\\n    function getActiveRewardTokens() external view returns (address[] memory _rewardTokens);\\n    function rewardReceiver(address account) external view returns (address);\\n    function setRewardReceiver(address _newReceiver) external;\\n    function claim() external;\\n    function claim(address account) external;\\n    function claim(address account, address receiver) external;\\n    function getBoostRatio(address _account) external view returns (uint256);\\n    function depositReward(address _token, uint256 _amount) external;\\n    function voteOwnerBalances(address _account) external view returns(uint112 product, uint104 amount, uint40 updateAt);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceOfReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceOfDeposit\",\"type\":\"uint256\"}],\"name\":\"apr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_apr\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convexProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fxn\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gaugeController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"gaugeRewardRates\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rates\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"gaugeWorkingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"getGaugeBoostRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"getRebalancePoolBoostRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"poolBoostRatioById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"poolRewardRatesById\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rates\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"rebalancePoolRewardRates\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rates\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vefxn\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PoolUtilities", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000db95d646012bb87ac2e6cd63eab2c42323c1f5af", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}