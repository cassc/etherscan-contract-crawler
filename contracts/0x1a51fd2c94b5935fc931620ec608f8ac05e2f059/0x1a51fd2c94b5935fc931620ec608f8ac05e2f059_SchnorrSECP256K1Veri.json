{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/utils/SchnorrSECP256K1Verifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ncontract SchnorrSECP256K1Verifier {\\n  // See https://en.bitcoin.it/wiki/Secp256k1 for this constant.\\n  uint256 constant public Q = // Group order of secp256k1\\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\\n  uint256 constant public HALF_Q = (Q >> 1) + 1;\\n\\n  /** **************************************************************************\\n      @notice verifySignature returns true iff passed a valid Schnorr signature.\\n      @dev See https://en.wikipedia.org/wiki/Schnorr_signature for reference.\\n      @dev In what follows, let d be your secret key, PK be your public key,\\n      PKx be the x ordinate of your public key, and PKyp be the parity bit for\\n      the y ordinate (i.e., 0 if PKy is even, 1 if odd.)\\n      **************************************************************************\\n      @dev TO CREATE A VALID SIGNATURE FOR THIS METHOD\\n      @dev First PKx must be less than HALF_Q. Then follow these instructions\\n           (see evm/test/schnorr_test.js, for an example of carrying them out):\\n      @dev 1. Hash the target message to a uint256, called msgHash here, using\\n              keccak256\\n      @dev 2. Pick k uniformly and cryptographically securely randomly from\\n              {0,...,Q-1}. It is critical that k remains confidential, as your\\n              private key can be reconstructed from k and the signature.\\n      @dev 3. Compute k*g in the secp256k1 group, where g is the group\\n              generator. (This is the same as computing the public key from the\\n              secret key k. But it's OK if k*g's x ordinate is greater than\\n              HALF_Q.)\\n      @dev 4. Compute the ethereum address for k*g. This is the lower 160 bits\\n              of the keccak hash of the concatenated affine coordinates of k*g,\\n              as 32-byte big-endians. (For instance, you could pass k to\\n              ethereumjs-utils's privateToAddress to compute this, though that\\n              should be strictly a development convenience, not for handling\\n              live secrets, unless you've locked your javascript environment\\n              down very carefully.) Call this address\\n              nonceTimesGeneratorAddress.\\n      @dev 5. Compute e=uint256(keccak256(PKx as a 32-byte big-endian\\n                                        \u2016 PKyp as a single byte\\n                                        \u2016 msgHash\\n                                        \u2016 nonceTimesGeneratorAddress))\\n              This value e is called \\\"msgChallenge\\\" in verifySignature's source\\n              code below. Here \\\"\u2016\\\" means concatenation of the listed byte\\n              arrays.\\n      @dev 6. Let x be your secret key. Compute s = (k - d * e) % Q. Add Q to\\n              it, if it's negative. This is your signature. (d is your secret\\n              key.)\\n      **************************************************************************\\n      @dev TO VERIFY A SIGNATURE\\n      @dev Given a signature (s, e) of msgHash, constructed as above, compute\\n      S=e*PK+s*generator in the secp256k1 group law, and then the ethereum\\n      address of S, as described in step 4. Call that\\n      nonceTimesGeneratorAddress. Then call the verifySignature method as:\\n      @dev    verifySignature(PKx, PKyp, s, msgHash,\\n                              nonceTimesGeneratorAddress)\\n      **************************************************************************\\n      @dev This signging scheme deviates slightly from the classical Schnorr\\n      signature, in that the address of k*g is used in place of k*g itself,\\n      both when calculating e and when verifying sum S as described in the\\n      verification paragraph above. This reduces the difficulty of\\n      brute-forcing a signature by trying random secp256k1 points in place of\\n      k*g in the signature verification process from 256 bits to 160 bits.\\n      However, the difficulty of cracking the public key using \\\"baby-step,\\n      giant-step\\\" is only 128 bits, so this weakening constitutes no compromise\\n      in the security of the signatures or the key.\\n      @dev The constraint signingPubKeyX < HALF_Q comes from Eq. (281), p. 24\\n      of Yellow Paper version 78d7b9a. ecrecover only accepts \\\"s\\\" inputs less\\n      than HALF_Q, to protect against a signature- malleability vulnerability in\\n      ECDSA. Schnorr does not have this vulnerability, but we must account for\\n      ecrecover's defense anyway. And since we are abusing ecrecover by putting\\n      signingPubKeyX in ecrecover's \\\"s\\\" argument the constraint applies to\\n      signingPubKeyX, even though it represents a value in the base field, and\\n      has no natural relationship to the order of the curve's cyclic group.\\n      **************************************************************************\\n      @param signingPubKeyX is the x ordinate of the public key. This must be\\n             less than HALF_Q. \\n      @param pubKeyYParity is 0 if the y ordinate of the public key is even, 1 \\n             if it's odd.\\n      @param signature is the actual signature, described as s in the above\\n             instructions.\\n      @param msgHash is a 256-bit hash of the message being signed.\\n      @param nonceTimesGeneratorAddress is the ethereum address of k*g in the\\n             above instructions\\n      **************************************************************************\\n      @return True if passed a valid signature, false otherwise. */\\n  function verifySignature(\\n    uint256 signingPubKeyX,\\n    uint8 pubKeyYParity,\\n    uint256 signature,\\n    uint256 msgHash,\\n    address nonceTimesGeneratorAddress) public pure returns (bool) {\\n    require(signingPubKeyX < HALF_Q, \\\"Public-key x >= HALF_Q\\\");\\n    // Avoid signature malleability from multiple representations for \u2124/Q\u2124 elts\\n    require(signature < Q, \\\"signature must be reduced modulo Q\\\");\\n\\n    // Forbid trivial inputs, to avoid ecrecover edge cases. The main thing to\\n    // avoid is something which causes ecrecover to return 0x0: then trivial\\n    // signatures could be constructed with the nonceTimesGeneratorAddress input\\n    // set to 0x0.\\n    //\\n    require(nonceTimesGeneratorAddress != address(0) && signingPubKeyX > 0 &&\\n      signature > 0 && msgHash > 0, \\\"no zero inputs allowed\\\");\\n\\n    uint256 msgChallenge = // \\\"e\\\"\\n      uint256(keccak256(abi.encodePacked(nonceTimesGeneratorAddress, msgHash)));\\n\\n    // Verify msgChallenge * signingPubKey + signature * generator ==\\n    //        nonce * generator\\n    //\\n    // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\\n    // The point corresponding to the address returned by\\n    // ecrecover(-s*r,v,r,e*r) is (r\u207b\u00b9 mod Q)*(e*r*R-(-s)*r*g)=e*R+s*g, where R\\n    // is the (v,r) point. See https://crypto.stackexchange.com/a/18106\\n    //\\n    address recoveredAddress = ecrecover(\\n      bytes32(Q - mulmod(signingPubKeyX, signature, Q)),\\n      // https://ethereum.github.io/yellowpaper/paper.pdf p. 24, \\\"The\\n      // value 27 represents an even y value and 28 represents an odd\\n      // y value.\\\"\\n      (pubKeyYParity == 0) ? 27 : 28,\\n      bytes32(signingPubKeyX),\\n      bytes32(mulmod(msgChallenge, signingPubKeyX, Q)));\\n    return nonceTimesGeneratorAddress == recoveredAddress;\\n  }\\n\\n  function validatePubKey (uint256 signingPubKeyX) public pure {\\n    require(signingPubKeyX < HALF_Q, \\\"Public-key x >= HALF_Q\\\");\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"HALF_Q\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Q\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"signingPubKeyX\",\"type\":\"uint256\"}],\"name\":\"validatePubKey\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"signingPubKeyX\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"pubKeyYParity\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"signature\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"msgHash\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nonceTimesGeneratorAddress\",\"type\":\"address\"}],\"name\":\"verifySignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "SchnorrSECP256K1Verifier", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}