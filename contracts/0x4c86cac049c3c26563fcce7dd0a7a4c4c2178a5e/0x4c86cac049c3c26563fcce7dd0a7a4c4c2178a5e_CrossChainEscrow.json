{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\ninterface IEIP1271 {\r\n    function isValidSignature(\r\n        bytes32 eip712Hash,\r\n        bytes calldata signature\r\n    ) external view returns (bytes4 magicValue);\r\n}\r\n\r\n\r\ncontract SignatureVerifier {\r\n    // --- Errors ---\r\n\r\n    error InvalidSignature();\r\n\r\n    // --- Internal methods ---\r\n\r\n    function verifySignature(\r\n        address signer,\r\n        bytes32 eip712Hash,\r\n        bytes calldata signature\r\n    ) internal view {\r\n        if (signer.code.length == 0) {\r\n            (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);\r\n\r\n            address actualSigner = ecrecover(eip712Hash, v, r, s);\r\n            if (actualSigner == address(0) || actualSigner != signer) {\r\n                revert InvalidSignature();\r\n            }\r\n        } else {\r\n            if (\r\n                IEIP1271(signer).isValidSignature(eip712Hash, signature) !=\r\n                IEIP1271.isValidSignature.selector\r\n            ) {\r\n                revert InvalidSignature();\r\n            }\r\n        }\r\n    }\r\n\r\n    function splitSignature(\r\n        bytes calldata signature\r\n    ) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\r\n        uint256 length = signature.length;\r\n        if (length == 65) {\r\n            assembly {\r\n                r := calldataload(signature.offset)\r\n                s := calldataload(add(signature.offset, 0x20))\r\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\r\n            }\r\n        } else if (length == 64) {\r\n            assembly {\r\n                r := calldataload(signature.offset)\r\n                let vs := calldataload(add(signature.offset, 0x20))\r\n                s := and(\r\n                    vs,\r\n                    0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\r\n                )\r\n                v := add(shr(255, vs), 27)\r\n            }\r\n        } else {\r\n            revert InvalidSignature();\r\n        }\r\n\r\n        if (\r\n            uint256(s) >\r\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\r\n        ) {\r\n            revert InvalidSignature();\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            revert InvalidSignature();\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract EIP712 {\r\n    // --- Public fields ---\r\n\r\n    bytes32 public immutable DOMAIN_SEPARATOR;\r\n\r\n    // --- Constructor ---\r\n\r\n    constructor(bytes memory name, bytes memory version) {\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256(\r\n                    \"EIP712Domain(\"\r\n                    \"string name,\"\r\n                    \"string version,\"\r\n                    \"uint256 chainId,\"\r\n                    \"address verifyingContract\"\r\n                    \")\"\r\n                ),\r\n                keccak256(name),\r\n                keccak256(version),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    // --- Internal methods ---\r\n\r\n    function getEIP712Hash(\r\n        bytes32 structHash\r\n    ) internal view returns (bytes32 eip712Hash) {\r\n        eip712Hash = keccak256(\r\n            abi.encodePacked(hex\"1901\", DOMAIN_SEPARATOR, structHash)\r\n        );\r\n    }\r\n}\r\n\r\n\r\ncontract CrossChainEscrow is EIP712, SignatureVerifier {\r\n    // --- Structs ---\r\n\r\n    struct Request {\r\n        bool isCollectionRequest;\r\n        address maker;\r\n        address solver;\r\n        address token;\r\n        uint256 tokenId;\r\n        uint256 amount;\r\n        uint256 price;\r\n        address recipient;\r\n        uint256 chainId;\r\n        uint256 deadline;\r\n        uint256 salt;\r\n    }\r\n\r\n    struct RequestStatus {\r\n        bool isExecuted;\r\n        bool isPrevalidated;\r\n    }\r\n\r\n    struct Withdraw {\r\n        address solver;\r\n        address user;\r\n        uint256 amount;\r\n        uint256 deadline;\r\n        uint256 salt;\r\n    }\r\n\r\n    struct WithdrawStatus {\r\n        bool isExecuted;\r\n    }\r\n\r\n    // --- Events ---\r\n\r\n    event Deposited(address user, address solver, uint256 amount);\r\n\r\n    event RequestExecuted(bytes32 requestHash);\r\n    event RequestPrevalidated(bytes32 requestHash, Request request);\r\n\r\n    event WithdrawExecuted(\r\n        bytes32 withdrawHash,\r\n        address user,\r\n        address solver,\r\n        uint256 amount\r\n    );\r\n\r\n    // --- Errors ---\r\n\r\n    error RequestIsExecuted();\r\n    error RequestIsExpired();\r\n    error RequestIsPrevalidated();\r\n\r\n    error WithdrawIsExecuted();\r\n    error WithdrawIsExpired();\r\n\r\n    error Unauthorized();\r\n    error UnsuccessfulCall();\r\n\r\n    // --- Fields ---\r\n\r\n    bytes32 public immutable REQUEST_TYPEHASH;\r\n    bytes32 public immutable WITHDRAW_TYPEHASH;\r\n\r\n    // Keep track of the user's deposited balance per solver\r\n    mapping(address => mapping(address => uint256)) public perSolverBalance;\r\n\r\n    // Keep track of request and withdraw statuses\r\n    mapping(bytes32 => RequestStatus) public requestStatus;\r\n    mapping(bytes32 => WithdrawStatus) public withdrawStatus;\r\n\r\n    // --- Constructor ---\r\n\r\n    constructor() EIP712(\"CrossChainEscrow\", \"1\") {\r\n        REQUEST_TYPEHASH = keccak256(\r\n            abi.encodePacked(\r\n                \"Request(\",\r\n                \"bool isCollectionRequest,\",\r\n                \"address maker,\",\r\n                \"address solver,\",\r\n                \"address token,\",\r\n                \"uint256 tokenId,\",\r\n                \"uint256 amount,\",\r\n                \"uint256 price,\",\r\n                \"address recipient,\",\r\n                \"uint256 chainId,\",\r\n                \"uint256 deadline,\",\r\n                \"uint256 salt\"\r\n                \")\"\r\n            )\r\n        );\r\n\r\n        WITHDRAW_TYPEHASH = keccak256(\r\n            abi.encodePacked(\r\n                \"Withdraw(\",\r\n                \"address solver,\",\r\n                \"address user,\",\r\n                \"uint256 amount,\",\r\n                \"uint256 deadline,\",\r\n                \"uint256 salt\",\r\n                \")\"\r\n            )\r\n        );\r\n    }\r\n\r\n    // --- Public methods ---\r\n\r\n    function deposit(address solver) public payable {\r\n        perSolverBalance[msg.sender][solver] += msg.value;\r\n\r\n        emit Deposited(msg.sender, solver, msg.value);\r\n    }\r\n\r\n    function prevalidate(Request memory request) public {\r\n        address maker = request.maker;\r\n\r\n        if (msg.sender != maker) {\r\n            revert Unauthorized();\r\n        }\r\n\r\n        bytes32 requestHash = getRequestHash(request);\r\n        RequestStatus memory status = requestStatus[requestHash];\r\n        if (status.isExecuted) {\r\n            revert RequestIsExecuted();\r\n        }\r\n        if (status.isPrevalidated) {\r\n            revert RequestIsPrevalidated();\r\n        }\r\n\r\n        requestStatus[requestHash].isPrevalidated = true;\r\n\r\n        emit RequestPrevalidated(requestHash, request);\r\n    }\r\n\r\n    function depositAndPrevalidate(\r\n        address solver,\r\n        Request calldata request\r\n    ) external payable {\r\n        deposit(solver);\r\n        prevalidate(request);\r\n    }\r\n\r\n    function executeWithdraw(\r\n        Withdraw calldata withdraw,\r\n        bytes calldata signature\r\n    ) external {\r\n        address solver = withdraw.solver;\r\n        address user = withdraw.user;\r\n        uint256 amount = withdraw.amount;\r\n\r\n        if (msg.sender != user) {\r\n            revert Unauthorized();\r\n        }\r\n\r\n        if (withdraw.deadline < block.timestamp) {\r\n            revert WithdrawIsExpired();\r\n        }\r\n\r\n        bytes32 withdrawHash = getWithdrawHash(withdraw);\r\n        WithdrawStatus memory status = withdrawStatus[withdrawHash];\r\n        if (status.isExecuted) {\r\n            revert WithdrawIsExecuted();\r\n        }\r\n\r\n        bytes32 eip712Hash = getEIP712Hash(withdrawHash);\r\n        verifySignature(solver, eip712Hash, signature);\r\n\r\n        withdrawStatus[withdrawHash].isExecuted = true;\r\n\r\n        perSolverBalance[user][solver] -= amount;\r\n        send(user, amount);\r\n\r\n        emit WithdrawExecuted(withdrawHash, user, solver, amount);\r\n    }\r\n\r\n    // --- Solver methods ---\r\n\r\n    function executeRequest(\r\n        Request calldata request,\r\n        bytes calldata signature\r\n    ) external {\r\n        address solver = request.solver;\r\n        address maker = request.maker;\r\n        uint256 price = request.price;\r\n\r\n        if (msg.sender != solver) {\r\n            revert Unauthorized();\r\n        }\r\n\r\n        if (request.deadline < block.timestamp) {\r\n            revert RequestIsExpired();\r\n        }\r\n\r\n        bytes32 requestHash = getRequestHash(request);\r\n        RequestStatus memory status = requestStatus[requestHash];\r\n        if (status.isExecuted) {\r\n            revert RequestIsExecuted();\r\n        }\r\n\r\n        bytes32 eip712Hash = getEIP712Hash(requestHash);\r\n        if (!status.isPrevalidated) {\r\n            verifySignature(maker, eip712Hash, signature);\r\n        }\r\n\r\n        requestStatus[requestHash].isExecuted = true;\r\n\r\n        perSolverBalance[maker][solver] -= price;\r\n        send(solver, price);\r\n\r\n        emit RequestExecuted(requestHash);\r\n    }\r\n\r\n    // --- View methods ---\r\n\r\n    function getRequestHash(\r\n        Request memory request\r\n    ) public view returns (bytes32 requestHash) {\r\n        requestHash = keccak256(\r\n            abi.encode(\r\n                REQUEST_TYPEHASH,\r\n                request.isCollectionRequest,\r\n                request.maker,\r\n                request.solver,\r\n                request.token,\r\n                request.tokenId,\r\n                request.amount,\r\n                request.price,\r\n                request.recipient,\r\n                request.chainId,\r\n                request.deadline,\r\n                request.salt\r\n            )\r\n        );\r\n    }\r\n\r\n    function getWithdrawHash(\r\n        Withdraw calldata withdraw\r\n    ) public view returns (bytes32 withdrawHash) {\r\n        withdrawHash = keccak256(\r\n            abi.encode(\r\n                WITHDRAW_TYPEHASH,\r\n                withdraw.solver,\r\n                withdraw.user,\r\n                withdraw.amount,\r\n                withdraw.deadline,\r\n                withdraw.salt\r\n            )\r\n        );\r\n    }\r\n\r\n    // --- Internal methods ---\r\n\r\n    function send(address to, uint256 amount) internal {\r\n        (bool result, ) = to.call{value: amount}(\"\");\r\n        if (!result) {\r\n            revert UnsuccessfulCall();\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RequestIsExecuted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RequestIsExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RequestIsPrevalidated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnsuccessfulCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawIsExecuted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawIsExpired\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"requestHash\",\"type\":\"bytes32\"}],\"name\":\"RequestExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"requestHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isCollectionRequest\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct CrossChainEscrow.Request\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"RequestPrevalidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"withdrawHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawExecuted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REQUEST_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WITHDRAW_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isCollectionRequest\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"internalType\":\"struct CrossChainEscrow.Request\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"depositAndPrevalidate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isCollectionRequest\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"internalType\":\"struct CrossChainEscrow.Request\",\"name\":\"request\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"executeRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"internalType\":\"struct CrossChainEscrow.Withdraw\",\"name\":\"withdraw\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"executeWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isCollectionRequest\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"internalType\":\"struct CrossChainEscrow.Request\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"getRequestHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"internalType\":\"struct CrossChainEscrow.Withdraw\",\"name\":\"withdraw\",\"type\":\"tuple\"}],\"name\":\"getWithdrawHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"withdrawHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"perSolverBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isCollectionRequest\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"internalType\":\"struct CrossChainEscrow.Request\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"prevalidate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"requestStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isExecuted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPrevalidated\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"withdrawStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isExecuted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CrossChainEscrow", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f54649a796cb4b927fe25f6af82c8016cebded196ce8229452873eb8d3734af1"}