{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(account),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: address zero is not a valid owner\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _ownerOf(tokenId);\\n        require(owner != address(0), \\\"ERC721: invalid token ID\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        _requireMinted(tokenId);\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not token owner or approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        _requireMinted(tokenId);\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\\n     */\\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\\n        return _owners[tokenId];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _ownerOf(tokenId) != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\\n\\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        unchecked {\\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\\n            // Given that tokens are minted one by one, it is impossible in practice that\\n            // this ever happens. Might change if we allow batch minting.\\n            // The ERC fails to describe this case.\\n            _balances[to] += 1;\\n        }\\n\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\\n\\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\\n        owner = ERC721.ownerOf(tokenId);\\n\\n        // Clear approvals\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // Cannot overflow, as that would require more tokens to be burned/transferred\\n            // out than the owner initially received through minting and transferring in.\\n            _balances[owner] -= 1;\\n        }\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId, 1);\\n\\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n\\n        // Clear approvals from the previous owner\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\\n            // `from`'s balance is the number of token held, which is at least one before the current\\n            // transfer.\\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\\n            // all 2**256 token ids to be minted, which in practice is impossible.\\n            _balances[from] -= 1;\\n            _balances[to] += 1;\\n        }\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` has not been minted yet.\\n     */\\n    function _requireMinted(uint256 tokenId) internal view virtual {\\n        require(_exists(tokenId), \\\"ERC721: invalid token ID\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\\n     * - When `from` is zero, the tokens will be minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\\n     * - When `from` is zero, the tokens were minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens were burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\\n\\n    /**\\n     * @dev Unsafe write access to the balances, used by extensions that \\\"mint\\\" tokens using an {ownerOf} override.\\n     *\\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\\n     * that `ownerOf(tokenId)` is `a`.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\\n        _balances[account] += amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Burnable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC721.sol\\\";\\nimport \\\"../../../utils/Context.sol\\\";\\n\\n/**\\n * @title ERC721 Burnable Token\\n * @dev ERC721 Token that can be burned (destroyed).\\n */\\nabstract contract ERC721Burnable is Context, ERC721 {\\n    /**\\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own `tokenId` or be an approved operator.\\n     */\\n    function burn(uint256 tokenId) public virtual {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n        _burn(tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CloprStories.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Clopr Contracts\\n\\npragma solidity 0.8.21;\\n\\nimport {ERC721} from \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\nimport {ERC721Burnable} from \\\"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\\\";\\nimport {AccessControl} from \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport {ECDSA} from \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {ERC165} from \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\"; // import for natSpecs\\nimport {IERC721Metadata} from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IAccessControl} from \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport {ICloprStories} from \\\"./interfaces/ICloprStories.sol\\\";\\nimport {ICloprBottles} from \\\"./interfaces/ICloprBottles.sol\\\";\\nimport {IDelegateRegistry} from \\\"./lib/delegateCash/IDelegateRegistry.sol\\\";\\nimport {IERC4906} from \\\"./interfaces/IERC4906.sol\\\";\\n\\n/**\\n * @title CloprStories\\n * @author Pybast.eth - Nefture\\n * @custom:lead Antoine Bertin - Clopr\\n * @dev Manages the lifecycle and properties of CloprStories, unique NFTs with evolving stories tied to specific assets, representing a novel form of asset-driven narrative.\\n */\\ncontract CloprStories is\\n    ERC721,\\n    ERC721Burnable,\\n    Ownable,\\n    AccessControl,\\n    ICloprStories,\\n    IERC4906\\n{\\n    /// @dev total number of tokens\\n    uint32 private currentSupply;\\n\\n    /// @dev base URI used to retrieve tokens' metadata if they are not decentralized\\n    ///      with setImmutableTokenURI function\\n    string private defaultBaseUri;\\n\\n    /// @dev role to give the authorisation to decentralize a token's metadata\\n    bytes32 private constant SIGNER_IMMUTABLE_METADATA_ROLE =\\n        keccak256(\\\"SIGNER_IMMUTABLE_METADATA_ROLE\\\");\\n\\n    uint16 public constant STORY_POTION_ID = 42;\\n\\n    /// @dev delegate cash V2 contract\\n    IDelegateRegistry private constant DC =\\n        IDelegateRegistry(0x00000000000000447e69651d841bD8D104Bed493);\\n\\n    /// @dev CloprBottles' smart contract address\\n    ICloprBottles private constant BOTTLES_CONTRACT =\\n        ICloprBottles(0xB0711E51eef597FA03bfF2CbFea3Dc4d3C4f6906);\\n\\n    /// @dev stores CloprStories information\\n    mapping(uint256 tokenId => StoryInformation storyInformation)\\n        private stories;\\n\\n    /// @dev stores nonces to make sure setImmutableTokenURI's signatures can only be used once\\n    mapping(uint256 tokenId => uint256 nonce) private signatureNonce;\\n\\n    constructor(\\n        string memory startDefaultBaseUri\\n    ) ERC721(\\\"CloprStories\\\", \\\"CSTR\\\") {\\n        if (bytes(startDefaultBaseUri).length == 0) revert BaseUriCantBeNull();\\n\\n        defaultBaseUri = startDefaultBaseUri;\\n\\n        _grantRole(\\n            DEFAULT_ADMIN_ROLE,\\n            0x799B7627f972dcf97b00bBBC702b2AD1b7546519\\n        );\\n        _transferOwnership(0x799B7627f972dcf97b00bBBC702b2AD1b7546519);\\n    }\\n\\n    /**\\n     * ----------- EXTERNAL -----------\\n     */\\n\\n    /// @inheritdoc ICloprStories\\n    function createStory(\\n        uint256 bottleTokenId,\\n        IERC721 nftContractAddress,\\n        uint256 nftTokenId,\\n        address vault\\n    ) external {\\n        if (address(nftContractAddress) == address(this))\\n            revert CantCreateStoryOfStory();\\n\\n        address requester = msg.sender;\\n\\n        if (vault != address(0)) {\\n            bool isDelegateValid = DC.checkDelegateForERC721(\\n                msg.sender,\\n                vault,\\n                address(nftContractAddress),\\n                nftTokenId,\\n                \\\"\\\"\\n            );\\n            if (!isDelegateValid) revert InvalidDelegateVaultPairing();\\n            requester = vault;\\n        }\\n\\n        // reverts if bottle not staked or not filled up with StoryPotion\\n        BOTTLES_CONTRACT.emptyBottle(bottleTokenId, STORY_POTION_ID, requester);\\n\\n        uint256 tokenId = ++currentSupply;\\n\\n        // slither-disable-next-line timestamp\\n        stories[tokenId] = StoryInformation({\\n            unftTokenId: nftTokenId,\\n            unftContract: nftContractAddress,\\n            storyCompletionTime: uint48(block.timestamp + 518400), // 6 * 24 * 3600 as it takes 6 days to go from 0/6 to 6/6,\\n            maxStoryLength: 6,\\n            metadataUri: \\\"\\\"\\n        });\\n\\n        _mint(requester, tokenId);\\n\\n        // external calls\\n        if (!nftContractAddress.supportsInterface(0x80ac58cd))\\n            revert NotErc721Contract();\\n\\n        if (IERC721(nftContractAddress).ownerOf(nftTokenId) != requester)\\n            revert DontOwnNft();\\n\\n        emit CreateStory(\\n            address(nftContractAddress),\\n            nftTokenId,\\n            tokenId,\\n            bottleTokenId\\n        );\\n    }\\n\\n    /// @inheritdoc ICloprStories\\n    function burnAndGrowStory(\\n        uint256 burnedTokenId,\\n        uint256 extendedTokenId,\\n        address burnVault,\\n        address extendVault\\n    ) external {\\n        StoryInformation memory burnedStory = stories[burnedTokenId];\\n        StoryInformation memory extendedStory = stories[extendedTokenId];\\n\\n        address burnRequester = msg.sender;\\n        address extendRequester = msg.sender;\\n\\n        if (burnVault != address(0)) {\\n            bool isDelegateValid = DC.checkDelegateForERC721(\\n                msg.sender,\\n                burnVault,\\n                address(burnedStory.unftContract),\\n                burnedStory.unftTokenId,\\n                \\\"\\\"\\n            );\\n            if (!isDelegateValid) revert InvalidDelegateVaultPairing();\\n            burnRequester = burnVault;\\n        }\\n\\n        if (extendVault != address(0)) {\\n            bool isDelegateValid = DC.checkDelegateForERC721(\\n                msg.sender,\\n                extendVault,\\n                address(extendedStory.unftContract),\\n                extendedStory.unftTokenId,\\n                \\\"\\\"\\n            );\\n            if (!isDelegateValid) revert InvalidDelegateVaultPairing();\\n            extendRequester = extendVault;\\n        }\\n\\n        if (burnedTokenId == extendedTokenId) revert NeedDifferentTokenIds();\\n\\n        if (\\n            ownerOf(extendedTokenId) != extendRequester ||\\n            ownerOf(burnedTokenId) != burnRequester\\n        ) revert DontOwnStory();\\n\\n        if (!_exists(extendedTokenId)) revert StoryDoesntExist();\\n\\n        // slither-disable-next-line timestamp\\n        if (\\n            block.timestamp < burnedStory.storyCompletionTime ||\\n            block.timestamp < extendedStory.storyCompletionTime\\n        ) revert StoryNotCompleted();\\n\\n        uint24 maxStoryLength;\\n\\n        unchecked {\\n            maxStoryLength =\\n                extendedStory.maxStoryLength +\\n                burnedStory.maxStoryLength;\\n        }\\n\\n        unchecked {\\n            // slither-disable-next-line timestamp\\n            stories[extendedTokenId] = StoryInformation({\\n                unftTokenId: extendedStory.unftTokenId,\\n                unftContract: extendedStory.unftContract,\\n                storyCompletionTime: uint48(\\n                    block.timestamp + 86400 * burnedStory.maxStoryLength\\n                ), // 24 * 3600 * maxStoryLength\\n                maxStoryLength: maxStoryLength,\\n                metadataUri: extendedStory.metadataUri\\n            });\\n        }\\n\\n        delete stories[burnedTokenId];\\n\\n        // if the extended story had decentralized its metadata, we remove it to come back to\\n        // centralized and dynamic metadata\\n        delete stories[extendedTokenId].metadataUri;\\n\\n        _burn(burnedTokenId);\\n\\n        emit ExtendStory(burnedTokenId, extendedTokenId, maxStoryLength);\\n        emit MetadataUpdate(extendedTokenId);\\n    }\\n\\n    /// @inheritdoc ICloprStories\\n    function setImmutableTokenURI(\\n        uint256 tokenId,\\n        string calldata metadataUri,\\n        bytes calldata signature,\\n        address vault\\n    ) external {\\n        StoryInformation memory story = stories[tokenId];\\n\\n        address requester = msg.sender;\\n\\n        if (vault != address(0)) {\\n            bool isDelegateValid = DC.checkDelegateForERC721(\\n                msg.sender,\\n                vault,\\n                address(story.unftContract),\\n                story.unftTokenId,\\n                \\\"\\\"\\n            );\\n            if (!isDelegateValid) revert InvalidDelegateVaultPairing();\\n            requester = vault;\\n        }\\n\\n        // slither-disable-next-line timestamp\\n        if (block.timestamp < story.storyCompletionTime)\\n            revert StoryNotCompleted();\\n\\n        if (ownerOf(tokenId) != requester) revert DontOwnStory();\\n\\n        bytes32 hash_ = ECDSA.toEthSignedMessageHash(\\n            keccak256(\\n                abi.encodePacked(\\n                    tokenId,\\n                    metadataUri,\\n                    story.maxStoryLength,\\n                    signatureNonce[tokenId]\\n                )\\n            )\\n        );\\n        if (\\n            !hasRole(\\n                SIGNER_IMMUTABLE_METADATA_ROLE,\\n                ECDSA.recover(hash_, signature)\\n            )\\n        ) revert NotAuthorised();\\n\\n        stories[tokenId].metadataUri = metadataUri;\\n        signatureNonce[tokenId]++;\\n\\n        emit SetImmutableTokenURI(tokenId);\\n    }\\n\\n    /**\\n     * ----------- ADMIN -----------\\n     */\\n\\n    /// @inheritdoc ICloprStories\\n    function changeDefaultBaseUri(\\n        string memory newDefaultBaseUri\\n    ) external onlyOwner {\\n        if (bytes(newDefaultBaseUri).length == 0) revert BaseUriCantBeNull();\\n\\n        defaultBaseUri = newDefaultBaseUri;\\n\\n        emit NewDefaultBaseUri(newDefaultBaseUri);\\n        emit BatchMetadataUpdate(1, type(uint256).max);\\n    }\\n\\n    /// @inheritdoc ICloprStories\\n    function offchainMetadataUpdate() external onlyOwner {\\n        emit BatchMetadataUpdate(1, type(uint256).max);\\n    }\\n\\n    /**\\n     * ----------- ENUMERATIONS -----------\\n     */\\n\\n    /// @inheritdoc ICloprStories\\n    function getStoryInformation(\\n        uint256 tokenId\\n    )\\n        external\\n        view\\n        returns (\\n            IERC721 unftContract,\\n            uint256 unftTokenId,\\n            uint256 storyLength,\\n            uint24 maxStoryLength\\n        )\\n    {\\n        StoryInformation memory story = stories[tokenId];\\n\\n        _checkStoryExists(address(story.unftContract));\\n\\n        unftContract = story.unftContract;\\n        unftTokenId = story.unftTokenId;\\n        maxStoryLength = story.maxStoryLength;\\n\\n        storyLength = _getStoryLength(\\n            story.storyCompletionTime,\\n            story.maxStoryLength\\n        );\\n    }\\n\\n    /// @inheritdoc ICloprStories\\n    function getUnft(\\n        uint256 tokenId\\n    ) external view returns (IERC721 unftContract, uint256 unftTokenId) {\\n        StoryInformation memory story = stories[tokenId];\\n\\n        _checkStoryExists(address(story.unftContract));\\n\\n        unftContract = story.unftContract;\\n        unftTokenId = story.unftTokenId;\\n    }\\n\\n    /// @inheritdoc ICloprStories\\n    function getUnftContract(\\n        uint256 tokenId\\n    ) external view returns (IERC721 unftContract) {\\n        StoryInformation memory story = stories[tokenId];\\n\\n        _checkStoryExists(address(story.unftContract));\\n\\n        unftContract = story.unftContract;\\n    }\\n\\n    /// @inheritdoc ICloprStories\\n    function getUnftTokenId(\\n        uint256 tokenId\\n    ) external view returns (uint256 unftTokenId) {\\n        StoryInformation memory story = stories[tokenId];\\n\\n        _checkStoryExists(address(story.unftContract));\\n\\n        unftTokenId = story.unftTokenId;\\n    }\\n\\n    /// @inheritdoc ICloprStories\\n    function getStoryLength(\\n        uint256 tokenId\\n    ) external view returns (uint256 storyLength) {\\n        StoryInformation memory story = stories[tokenId];\\n\\n        _checkStoryExists(address(story.unftContract));\\n\\n        storyLength = _getStoryLength(\\n            story.storyCompletionTime,\\n            story.maxStoryLength\\n        );\\n    }\\n\\n    /// @inheritdoc ICloprStories\\n    function getMaxStoryLength(\\n        uint256 tokenId\\n    ) external view returns (uint256 maxStoryLength) {\\n        StoryInformation memory story = stories[tokenId];\\n\\n        _checkStoryExists(address(story.unftContract));\\n\\n        maxStoryLength = story.maxStoryLength;\\n    }\\n\\n    /**\\n     * ----------- PUBLIC -----------\\n     */\\n\\n    /// @notice get the total supply of CloprStories tokens\\n    /// @return currentSupply_ current supply CloprStories tokens\\n    function totalSupply() public view returns (uint256 currentSupply_) {\\n        currentSupply_ = currentSupply;\\n    }\\n\\n    /// @notice Get the owner of a Clopr Story\\n    /// @dev The owner of a story is the owner of its UNFT\\n    /// @param tokenId token ID of the story\\n    /// @inheritdoc\\tERC721\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        StoryInformation memory story = stories[tokenId];\\n\\n        _checkStoryExists(address(story.unftContract));\\n\\n        address owner = IERC721(story.unftContract).ownerOf(story.unftTokenId);\\n\\n        // slither-disable-next-line incorrect-equality\\n        if (owner == address(0)) revert UNFTDoesntExist();\\n\\n        return owner;\\n    }\\n\\n    /// @notice Get a Clopr Story's metadata URI\\n    /// @param tokenId token ID of the story\\n    /// @return tokenURI_ the URI of the token\\n    /// @inheritdoc IERC721Metadata\\n    function tokenURI(\\n        uint256 tokenId\\n    ) public view override(ERC721) returns (string memory tokenURI_) {\\n        _requireMinted(tokenId);\\n\\n        string storage metadataUri = stories[tokenId].metadataUri;\\n\\n        if (bytes(metadataUri).length > 0) {\\n            tokenURI_ = metadataUri;\\n        } else {\\n            tokenURI_ = super.tokenURI(tokenId);\\n        }\\n    }\\n\\n    /// @notice Owner can Burn one of his Clopr Story\\n    /// @dev This function can't be called from a delegated wallet\\n    /// @param tokenId token ID for which to decentralise the metadata\\n    /// @inheritdoc\\tERC721Burnable\\n    function burn(uint256 tokenId) public override {\\n        if (ownerOf(tokenId) != msg.sender) revert CallerNotOwner();\\n\\n        _burn(tokenId);\\n        delete stories[tokenId];\\n    }\\n\\n    /// @notice Transfer a Clopr Story to the wallet owning the UNFT\\n    /// @dev In certain dapps, CloprStories might not appear as owned by the owner of\\n    ///      the UNFT, this is because the Clopr protocol's ownership mechanism isn't\\n    ///      implemented in the dapp so it only relies on the Transfer events.\\n    ///      This function enables emitting a Transfer event from a previous address to the\\n    ///      current owner's address to see your story appear in your favorite dapps.\\n    ///      Note that this action can be done by anyone on behalf of the owner\\n    /// @param to recipient address\\n    /// @param tokenId token ID of the story\\n    function transferFrom(\\n        address,\\n        address to,\\n        uint256 tokenId\\n    ) public override {\\n        address owner = ownerOf(tokenId);\\n        address currentOwner = ERC721.ownerOf(tokenId);\\n\\n        if (owner != to) revert CantTransferCloprStories();\\n        // slither-disable-next-line incorrect-equality\\n        if (currentOwner == owner) revert TokenAlreadyOwned();\\n\\n        _transfer(currentOwner, owner, tokenId);\\n    }\\n\\n    /// @notice Transfer a Clopr Story to the wallet owning the UNFT\\n    /// @dev In certain dapps, CloprStories might not appear as owned by the owner of\\n    ///      the UNFT, this is because the Clopr protocol's ownership mechanism isn't\\n    ///      implemented in the dapp so it only relies on the Transfer events.\\n    ///      This function enables emitting a Transfer event from a previous address to the\\n    ///      current owner's address to see your story appear in your favorite dapps.\\n    ///      Note that this action can be done by anyone on behalf of the owner\\n    /// @param from address from which to transfer\\n    /// @param to recipient address\\n    /// @param tokenId token ID of the story\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public override {\\n        address owner = ownerOf(tokenId);\\n        address currentOwner = ERC721.ownerOf(tokenId);\\n\\n        if (owner != to) revert CantTransferCloprStories();\\n        // slither-disable-next-line incorrect-equality\\n        if (currentOwner == owner) revert TokenAlreadyOwned();\\n\\n        _safeTransfer(currentOwner, owner, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(\\n        address, // operator\\n        bool // approved\\n    ) public pure override {\\n        revert CantApproveStories();\\n    }\\n\\n    function approve(\\n        address, // to\\n        uint256 // tokenId\\n    ) public pure override {\\n        revert CantApproveStories();\\n    }\\n\\n    /**\\n     * ----------- ERC165 -----------\\n     */\\n\\n    /// @notice Know if a given interface ID is supported by this contract\\n    /// @dev This function overrides ERC721A, AccessControl, IERC721A, ERC2981\\n    /// @param interfaceId ID of the interface\\n    /// @return supports_ is the interface supported\\n    /// @inheritdoc\\tERC165\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public pure override(ERC721, AccessControl) returns (bool supports_) {\\n        supports_ =\\n            interfaceId == type(IERC721).interfaceId || // ERC165 interface ID for ERC721\\n            interfaceId == type(IERC721Metadata).interfaceId || // ERC165 interface ID for ERC721Metadata\\n            interfaceId == type(IERC165).interfaceId || // ERC165 interface id for ERC165\\n            interfaceId == type(IAccessControl).interfaceId || // ERC165 interface id for AccessControl\\n            interfaceId == type(IERC4906).interfaceId; // ERC165 interface id for ERC4906\\n    }\\n\\n    /**\\n     * ----------- INTERNAL -----------\\n     */\\n\\n    /// @dev retrieve a story's number of pages (length)\\n    /// @param storyCompletionTime timestamp at which the story will be completed\\n    /// @param maxStoryLength story's maximum number of pages (length)\\n    function _getStoryLength(\\n        uint256 storyCompletionTime,\\n        uint256 maxStoryLength\\n    ) internal view returns (uint256 storyLength) {\\n        // slither-disable-next-line timestamp\\n        if (block.timestamp > storyCompletionTime) {\\n            storyLength = maxStoryLength;\\n        } else {\\n            unchecked {\\n                // slither-disable-next-line timestamp\\n                // we add 86399 and not 86400 to prevent underflow during other potential\\n                // executions in the story's creation block. Stories then reveal 1 second before\\n                // the expected 24 hours period.\\n                storyLength =\\n                    maxStoryLength -\\n                    (storyCompletionTime + 86399 - block.timestamp) /\\n                    86400; // 24 * 3600\\n            }\\n        }\\n    }\\n\\n    /// @dev verify if a story exists based on its UNFT's contract address\\n    /// @param storyUnftContractAddress contract address of the story's UNFT\\n    function _checkStoryExists(address storyUnftContractAddress) internal pure {\\n        // slither-disable-next-line incorrect-equality\\n        if (storyUnftContractAddress == address(0)) revert StoryDoesntExist();\\n    }\\n\\n    /// @dev internal function to retrieve the base URI\\n    /// @return baseUri the base uri\\n    /// @inheritdoc ERC721\\n    function _baseURI() internal view override returns (string memory baseUri) {\\n        baseUri = defaultBaseUri;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICloprBottles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Clopr Contracts\\n\\npragma solidity 0.8.21;\\n\\nimport \\\"../lib/standards/IERC721A.sol\\\";\\n\\n/**\\n * @title ICloprBottles\\n * @author Pybast.eth - Nefture\\n * @custom:lead Antoine Bertin - Clopr\\n * @notice This contract serves as the core of the Clopr protocol, managing the CloprBottles NFT collection, including potion-based assets, staking mechanisms, and dynamic metadata.\\n */\\ninterface ICloprBottles is IERC721A {\\n    /// @notice struct for base URI information\\n    /// @param baseUri base URI of the potion\\n    /// @param isFrozen if true, then the baseUri can't be modified\\n    /// @param exists used to know if a potionBaseUri exists\\n    struct PotionBaseUri {\\n        string baseUri;\\n        bool isFrozen;\\n        bool exists;\\n    }\\n\\n    /// @notice struct for bottles information\\n    /// @param potionId is the ID of the potion inside the bottle or the ID of the last potion if the bottle is empty\\n    /// @param filled is the fill status of the bottle from 0 (empty) or 100 (full)\\n    /// @param delegatedFillLevel if true, then potionFill should be ingored and the fill level calculation should be delegated to the potion contract\\n    /// @param stakingTime timestamp of the bottle's staking or 0 if the bottle is unstaked\\n    /// @param numberDrinks number of times the bottle was drunk\\n    /// @param lastEmptyBlock block number at which the bottle was last emptied\\n    struct BottleInformation {\\n        uint16 potionId;\\n        bool filled;\\n        bool delegatedFillLevel;\\n        uint48 stakingTime;\\n        uint24 numberDrinks;\\n        uint64 lastEmptyBlock;\\n    }\\n\\n    /// @notice struct for mint phase information\\n    /// @param price is the price of the mint phase\\n    /// @param startTimestamp is the start timestamp of the mint phase\\n    /// @param endTimestamp is the end timestamp of the mint phase\\n    /// @param maxMintPerWallet is the maximum token that can be minted per address\\n    /// @param remainingSupply is the remaining supply for a mint phase\\n    struct MintPhase {\\n        uint128 price;\\n        uint48 startTimestamp;\\n        uint48 endTimestamp;\\n        uint8 maxMintPerWallet;\\n        uint16 remainingSupply;\\n    }\\n\\n    /// @notice thrown if the given vault is not delegated to the caller\\n    error InvalidDelegateVaultPairing();\\n\\n    /// @notice thrown if a given potion doesn't exist\\n    error PotionDoesntExist();\\n\\n    /// @notice thrown if a potion's URI is frozen\\n    error PotionUriIsFrozen();\\n\\n    /// @notice thrown if a potion already exist\\n    error PotionAlreadyExist();\\n\\n    /// @notice thrown if an address is not the bottle's owner\\n    error NotBottleOwner();\\n\\n    /// @notice thrown if a bottle is not staked\\n    error BottleNotStaked();\\n\\n    /// @notice thrown if the marketing supply has been reached\\n    error MarketingSupplyReached();\\n\\n    /// @notice thrown if the mint phase already exist\\n    error MintPhaseAlreadyExist();\\n\\n    /// @notice thrown if the mint phase doesn't exist\\n    error MintPhaseDoesntExist();\\n\\n    /// @notice thrown if the mint phase has ended or if it doesn't exist\\n    error MintPhaseEndedOrDoesntExist();\\n\\n    /// @notice thrown if the mint phase has not started yet\\n    error MintPhaseNotStarted();\\n\\n    /// @notice thrown if the mint price is not correct\\n    error BadMintPrice();\\n\\n    /// @notice thrown if the mint is sold out\\n    error MintSoldOut();\\n\\n    /// @notice thrown if the mint phase is sold out\\n    error PhaseSoldOut();\\n\\n    /// @notice thrown if the phase's maximum mint has been reached\\n    error MaxMintReached();\\n\\n    /// @notice thrown if not authorised to mint\\n    error NotAuthorised();\\n\\n    /// @notice thrown if trying to transfer a staked bottle\\n    error CantTransferStakedBottle();\\n\\n    /// @notice thrown if trying to transferFrom a bottle that was just emptied\\n    error CantTransferRecentlyEmptiedBottle();\\n\\n    /// @notice thrown if trying to fill up a bottle without the authorisation\\n    error FillingUpNotAuthorised();\\n\\n    /// @notice thrown if trying to fill up a bottle that is not empty\\n    error BottleNotEmpty();\\n\\n    /// @notice thrown if trying to empty a bottle without the authorisation\\n    error EmptyingNotAuthorized();\\n\\n    /// @notice thrown if trying to empty a bottle from the wrong potion\\n    error InvalidPotion();\\n\\n    /// @notice thrown if trying to empty a bottle that is not full\\n    error BottleNotFull();\\n\\n    /// @notice thrown if trying to set the royalties receiver to the zero address\\n    error RoyaltyReceiverCantBeZero();\\n\\n    /// @notice thrown if trying to set the royalties amount to a value higher than the maximum of 1000\\n    error RoyaltyPerThousandTooHigh();\\n\\n    /// @notice thrown if there is no ether left to withdraw from the contract\\n    error NothingToWithdraw();\\n\\n    /// @notice thrown if trying to withdraw to the zero address\\n    error CantWithdrawToZeroAddress();\\n\\n    /// @notice thrown if withdrawing has failed\\n    error FailedToWithdraw();\\n\\n    /// @notice thrown if trying to set the potionBaseUri as an empty string\\n    error PotionBaseUriCantBeNull();\\n\\n    /// @notice thrown if trying to set potionFillContract or potionEmptyContract to address(0)\\n    error PotionContractCantBeNull();\\n\\n    /// @notice thrown if trying to set the startTimestamp of a mint phase to zero\\n    error InvalidStartTimestamp();\\n\\n    /// @notice emitted when a new potion type is added to the Clopr protocol\\n    /// @param potionFillContract contract allowed to fill up bottles\\n    /// @param potionEmptyContract contract allowed to empty bottles\\n    /// @param potionId new potion's unique ID\\n    /// @param potionMetadataUri nes potion's metadata URI\\n    event NewPotion(\\n        address indexed potionFillContract,\\n        address indexed potionEmptyContract,\\n        uint256 indexed potionId,\\n        string potionMetadataUri\\n    );\\n\\n    /// @notice emitted when a potion's base URI is modified\\n    /// @param potionId potion's ID\\n    /// @param potionMetadataBaseUri new potion's base URI\\n    event NewPotionBaseUri(\\n        uint256 indexed potionId,\\n        string potionMetadataBaseUri\\n    );\\n\\n    /// @notice emitted when a potion's URI is frozen so that it will never be modified\\n    /// @param potionId ID of the potion subject to a URI freeze\\n    event FreezePotionUri(uint256 indexed potionId);\\n\\n    /// @notice emitted when a bottle is staked or unstaked\\n    /// @param tokenId ID of the bottle\\n    /// @param staked true if the bottle is being staked, false if it is being unstaked\\n    event BottleStaked(uint256 indexed tokenId, bool indexed staked);\\n\\n    /// @notice emitted when a new staking season is started\\n    /// @param seasonStartTime timestamp of the start of the season\\n    event StartNewSeason(uint256 indexed seasonStartTime);\\n\\n    /// @notice emitted when a bottle is filled up with potion\\n    /// @param tokenId ID of the bottle being filled up\\n    /// @param potionId ID of the potion filling up the bottle\\n    event FillBottle(uint256 indexed tokenId, uint256 indexed potionId);\\n\\n    /// @notice emitted when a bottle is emptied\\n    /// @param tokenId ID of the bottle being emptied\\n    event EmptyBottle(uint256 indexed tokenId);\\n\\n    /// @notice emitted when the ERC2981 royalties are modified\\n    /// @param royaltyPerThousand royalty amount per thousand\\n    /// @param royaltyReceiver royalties receiver address\\n    event RoyaltyChange(uint16 royaltyPerThousand, address royaltyReceiver);\\n\\n    /// @notice emitted when a new mint phase is created\\n    /// @param phaseIndex index of the mint phase\\n    /// @param price price of the mint phase\\n    /// @param startTimestamp timestamp for the start of the mint phase\\n    /// @param endTimestamp timestamp for the end of the mint phase\\n    /// @param maxMintPerWallet maximum number of tokens mintable per wallet\\n    /// @param phaseSupply maximum token supply for the mint phase\\n    event NewMintPhase(\\n        uint256 indexed phaseIndex,\\n        uint128 price,\\n        uint48 indexed startTimestamp,\\n        uint48 indexed endTimestamp,\\n        uint8 maxMintPerWallet,\\n        uint16 phaseSupply\\n    );\\n\\n    /// @notice emitted when a mint phase is cancelled\\n    /// @param phaseIndex index of the mint phase\\n    event CancelMintPhase(uint256 indexed phaseIndex);\\n\\n    /**\\n     * ----------- EXTERNAL -----------\\n     */\\n\\n    /// @notice Stake a CloprBottles\\n    /// @dev Emits an event to enable tracking bottle staking status\\n    /// @param tokenId token ID of the bottle\\n    function stake(uint256 tokenId, address vault) external;\\n\\n    /// @notice Unstake a CloprBottles\\n    /// @dev Emits an event to enable tracking bottle staking status\\n    /// @param tokenId token ID of the bottle\\n    function unstake(uint256 tokenId, address vault) external;\\n\\n    /// @notice Allows the owner of a bottle to empty the content of his bottle\\n    /// @dev Emits an event to enable tracking bottle contents\\n    /// @param tokenId token ID of the bottle\\n    function emergencyEmptyBottle(uint256 tokenId) external;\\n\\n    /// @notice mint CloprBottless\\n    /// @param quantity number of tokens being minted\\n    /// @param mintPhaseIndex index of the mint phase\\n    /// @param signature ECDSA signature prooving that caller is whitelisted\\n    function mintBottles(\\n        uint8 quantity,\\n        uint256 mintPhaseIndex,\\n        bytes calldata signature\\n    ) external payable;\\n\\n    /**\\n     * ----------- CLOPR PROTOCOL -----------\\n     */\\n\\n    /// @notice Allows permited contracts to fill a CloprBottles with a specified Clopr Potion\\n    /// @dev Emits an event to enable tracking bottles' content\\n    /// @param tokenId token ID of the bottle\\n    /// @param potionId potion ID being filled up\\n    /// @param potentialBottleOwner said owner of the CloprBottles being filled up\\n    function fillBottle(\\n        uint256 tokenId,\\n        uint16 potionId,\\n        bool isDelegatedFillLevel,\\n        address potentialBottleOwner\\n    ) external;\\n\\n    /// @notice Allows permited contracts to empty the content a CloprBottles\\n    /// @dev Emits an event to enable tracking bottles' content\\n    /// @param tokenId token ID of the bottle\\n    /// @param potionId potion ID being emptied\\n    /// @param bottleOwner owner of the CloprBottles being filled up\\n    function emptyBottle(\\n        uint256 tokenId,\\n        uint16 potionId,\\n        address bottleOwner\\n    ) external;\\n\\n    /**\\n     * ----------- ADMIN -----------\\n     */\\n\\n    /// @notice Allows owner to extend the protocol by adding a new potion, a contract allowed to fill bottles with this potion and a contract allowed to empty bottles with this potion\\n    /// @dev The new potion's ID must be unique\\n    ///      Emits an event to enable tracking new extensions of the protocol\\n    /// @param potionId the new potion's ID\\n    /// @param potionFillContract the contract now allowed to fill bottles with the new potion\\n    /// @param potionEmptyContract the contract now allowed to empty bottles filled up with the new potion\\n    /// @param potionBaseUri base URI of the new potion\\n    function addNewPotion(\\n        uint256 potionId,\\n        address potionFillContract,\\n        address potionEmptyContract,\\n        string memory potionBaseUri\\n    ) external;\\n\\n    /// @notice Allows the creation of mint phases\\n    /// @dev Emits an event to enable tracking mint phases\\n    /// @param phaseIndex index of the mint phase\\n    /// @param price price of the mint phase to create\\n    /// @param startTimestamp timestamp for the start of the mint phase\\n    /// @param endTimestamp timestamp for the end of the mint phase\\n    /// @param maxMintPerWallet maximum number of tokens mintable per wallet\\n    /// @param phaseSupply maximum token supply for the mint phase\\n    function createNewMintPhase(\\n        uint256 phaseIndex,\\n        uint128 price,\\n        uint48 startTimestamp,\\n        uint48 endTimestamp,\\n        uint8 maxMintPerWallet,\\n        uint16 phaseSupply\\n    ) external;\\n\\n    /// @notice Allows the cancellation of a mint phase\\n    /// @param phaseIndex index of the mint phase to cancel\\n    function cancelMintPhase(uint256 phaseIndex) external;\\n\\n    /// @notice Allows wallets with MARKETING_MINT_ROLE to mint tokens for marketing purposes up to MARKETING_SUPPLY\\n    /// @param quantity number of tokens being minted\\n    /// @param to wallet receiving the tokens\\n    function marketingMint(uint16 quantity, address to) external;\\n\\n    /// @notice set a new ERC2981 royalty for CloprBottless\\n    /// @param newRoyaltyPerThousand royalty amount per thousand\\n    /// @param newRoyaltyReceiver address of the royalties receiver\\n    function setRoyalty(\\n        uint16 newRoyaltyPerThousand,\\n        address newRoyaltyReceiver\\n    ) external;\\n\\n    /// @notice Allows owner to change the base URI for a certain potion\\n    /// @dev Don't forget the trailing slash in the base URI as it will be concatenated with other information.\\n    ///      Emits an event to enable tracking base URI changes\\n    /// @param potionId the ID of the potion associated with the new base URI\\n    /// @param newPotionBaseUri the new base URI of the potion\\n    function changePotionBaseUri(\\n        uint256 potionId,\\n        string memory newPotionBaseUri\\n    ) external;\\n\\n    /// @dev Used to emit an ERC-4906 event if the metadata are modified off chain\\n    function offchainMetadataUpdate() external;\\n\\n    /// @notice Allows owner to freeze the URI of a particular potion making it immutable\\n    /// @dev Emits an event to enable tracking URI freezes\\n    /// @param potionId The potion ID which will have its URI frozen\\n    function freezePotionUri(uint256 potionId) external;\\n\\n    /// @notice Allows owner to start a new season, this will reset all staking durations\\n    /// @dev Emits an event to enable tracking seasons\\n    function startSeason() external;\\n\\n    /// @notice allows owner to withdraw contract's ether to an arbitrary account\\n    /// @param receiver receiver of the funds\\n    function withdraw(address receiver) external;\\n\\n    /**\\n     * ----------- ENUMERATIONS -----------\\n     */\\n\\n    /// @notice get the number of tokens which were minted for marketing\\n    /// @return mintedMarketingSupply the number of tokens which were minted for marketing\\n    function getMintedMarketingSupply()\\n        external\\n        view\\n        returns (uint16 mintedMarketingSupply);\\n\\n    /// @notice Get the timestamp at which the current season was started\\n    /// @return seasonStartTime_ the timestamp at which the current season was started\\n    function getCurrentSeasonStartTime()\\n        external\\n        view\\n        returns (uint48 seasonStartTime_);\\n\\n    /// @notice Get the information of a mint phase\\n    /// @param mintPhaseIndex index of the mint phase\\n    /// @return mintPhase mint phase object\\n    function getMintPhaseInfos(\\n        uint256 mintPhaseIndex\\n    ) external view returns (MintPhase memory mintPhase);\\n\\n    /// @notice Get the mint price of CloprBottless for a specific mint phase\\n    /// @param mintPhaseIndex index of the mint phase\\n    /// @return mintPrice the mintPhase's price of CloprBottless\\n    function getMintPrice(\\n        uint256 mintPhaseIndex\\n    ) external view returns (uint128 mintPrice);\\n\\n    /// @notice Retrieve the information of a bottle\\n    /// @param tokenId token ID of the bottle\\n    /// @return potionId the potion ID filling up the bottle\\n    /// @return potionFill the amount of potion filling up the bottle from 0 (empty) to 100 (full)\\n    /// @return stakingTime the timestamp at which the bottle was staked\\n    /// @return stakingDuration the timestamp at which the bottle was staked\\n    /// @return numberDrinks the number of times the bottle was staked\\n    function getBottleInformation(\\n        uint256 tokenId\\n    )\\n        external\\n        view\\n        returns (\\n            uint16 potionId,\\n            uint8 potionFill,\\n            uint48 stakingTime,\\n            uint48 stakingDuration,\\n            uint24 numberDrinks,\\n            uint64 lastEmptyBlock\\n        );\\n\\n    /// @notice Get the time at which a bottle was staked\\n    /// @param tokenId token ID of the bottle\\n    /// @return stakingTime the timestamp at which the bottle was staked\\n    function getStakingTime(\\n        uint256 tokenId\\n    ) external view returns (uint48 stakingTime);\\n\\n    /// @notice Get the staking duration of a bottle\\n    /// @dev The staking duration can be affected by the current season's start time\\n    /// @param tokenId token ID of the bottle\\n    /// @return stakingDuration the duration the bottle was staked for\\n    function getStakingDuration(\\n        uint256 tokenId\\n    ) external view returns (uint48 stakingDuration);\\n\\n    /// @notice Get the fill level of a bottle\\n    /// @param tokenId token ID of the bottle\\n    /// @return fillLevel the bottle's fill level from 0 (empty) to 100 (full)\\n    function getBottleFillLevel(\\n        uint256 tokenId\\n    ) external view returns (uint8 fillLevel);\\n\\n    /// @notice get the block number at which the bottle was emptied\\n    /// @param tokenId token ID of the bottle\\n    /// @return lastEmptyBlock block number at which the bottle was emptied\\n    function getBottleLastEmptyBlock(\\n        uint256 tokenId\\n    ) external view returns (uint64 lastEmptyBlock);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICloprStories.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Clopr Contracts\\n\\npragma solidity 0.8.21;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\n/**\\n * @title ICloprStories\\n * @author Pybast.eth - Nefture\\n * @custom:lead Antoine Bertin - Clopr\\n * @dev Manages the lifecycle and properties of CloprStories, unique NFTs with evolving stories tied to specific assets, representing a novel form of asset-driven narrative.\\n */\\ninterface ICloprStories {\\n    /// @notice struct to store stories' information\\n    /// @param unftTokenId token ID of the story's underlying NFT\\n    /// @param unftContract contract address of the story's underlying NFT\\n    /// @param storyCompletionTime timestamp at which the story will be complete\\n    /// @param maxStoryLength maximum number of pages (length) of the story\\n    /// @param metadataUri URI of the story's metadata if it has been decentralized with `setImmutableTokenURI`\\n    struct StoryInformation {\\n        uint256 unftTokenId;\\n        IERC721 unftContract;\\n        uint48 storyCompletionTime;\\n        uint24 maxStoryLength; // uint24 is enough because in the case if all 50,000 stories are merged, the theoretical unique story will be 300000 pages\\n        string metadataUri;\\n    }\\n\\n    /// @notice thrown if the given vault is not delegated to the caller\\n    error InvalidDelegateVaultPairing();\\n\\n    /// @notice thrown if the story doesn't exist\\n    error StoryDoesntExist();\\n\\n    /// @notice thrown if the caller doesn't own the story\\n    error DontOwnStory();\\n\\n    /// @notice thrown if the caller is not authorised\\n    error NotAuthorised();\\n\\n    /// @notice thrown if the story is not complete\\n    error StoryNotCompleted();\\n\\n    /// @notice thrown if trying to create the ClopStory of a CloprStory\\n    error CantCreateStoryOfStory();\\n\\n    /// @notice thrown if trying to create a CloprStory of a non ERC721 contract\\n    error NotErc721Contract();\\n\\n    /// @notice thrown if trying to burn and grow the same CloprStory\\n    error NeedDifferentTokenIds();\\n\\n    /// @notice thrown if trying to create a CloprStory of an ERC721 token you don't own\\n    error DontOwnNft();\\n\\n    /// @notice thrown if trying to transfer a CloprStory to its owner\\n    error TokenAlreadyOwned();\\n\\n    /// @notice thrown if trying to burn a CloprStory not owned\\n    error CallerNotOwner();\\n\\n    /// @notice thrown if trying to transfer a CloprStory\\n    error CantTransferCloprStories();\\n\\n    /// @notice thrown if the CloprStory's underlying NFT doesn't exist\\n    error UNFTDoesntExist();\\n\\n    /// @notice thrown if trying to approve or setApprovalForAll a CloprStory\\n    error CantApproveStories();\\n\\n    /// @notice thrown if trying to set the baseUri as an empty string\\n    error BaseUriCantBeNull();\\n\\n    /// @notice emitted when a CloprStory is created\\n    /// @param nftContractAddress contract address of the CloprStory's underlying NFT\\n    /// @param nftTokenId token ID of the CloprStory's underlying NFT\\n    /// @param storyTokenId token ID of the newly created CloprStory\\n    /// @param bottleTokenId token ID of the bottle used to create the CloprStory\\n    event CreateStory(\\n        address indexed nftContractAddress,\\n        uint256 indexed nftTokenId,\\n        uint256 indexed storyTokenId,\\n        uint256 bottleTokenId\\n    );\\n\\n    /// @notice emitted when a CloprStory is extended\\n    /// @param burnedTokenId token ID of the burned CloprStory\\n    /// @param extendedTokenId token ID of the extended CloprStory\\n    /// @param newMaxLength new maximum number of pages (length) of the extended CloprStory\\n    event ExtendStory(\\n        uint256 indexed burnedTokenId,\\n        uint256 indexed extendedTokenId,\\n        uint24 newMaxLength\\n    );\\n\\n    /// @notice emitted when a CloprStory gets a decentralized token URI\\n    /// @param tokenId token ID of the CloprStory\\n    event SetImmutableTokenURI(uint256 indexed tokenId);\\n\\n    /// @notice emitted when the base URI is modified\\n    /// @param newDefaultBaseUri new base URI\\n    event NewDefaultBaseUri(string newDefaultBaseUri);\\n\\n    /**\\n     * ----------- EXTERNAL -----------\\n     */\\n\\n    /// @notice Create a Clopr Story and associate it with an NFT by drinking a Clop Bottle filled with StoryPotion\\n    /// @dev Emits an event to enable tracking story creation\\n    /// @param bottleTokenId CloprBottles to use to create the story\\n    /// @param contractAddress contract address of the NFT being associated with the Clopr Story\\n    /// @param nftTokenId token ID of the NFT being associated with the Clopr Story\\n    /// @param vault Delegate Cash vault to use as a delegated wallet\\n    function createStory(\\n        uint256 bottleTokenId,\\n        IERC721 contractAddress,\\n        uint256 nftTokenId,\\n        address vault\\n    ) external;\\n\\n    /// @notice Burn a Clopr Story to extend the maximum number of pages of another Clopr Story\\n    /// @dev Emits an event to enable tracking Clopr Story burns and page extensions\\n    /// @param burnedTokenId token ID of the Clopr Story being burned\\n    /// @param extendedTokenId token ID of the Clopr Story being extended\\n    /// @param vault1 Delegate Cash vault to use as a delegated wallet for the burned Clopr Story\\n    /// @param vault2 Delegate Cash vault to use as a delegated wallet for the extended Clopr Story\\n    function burnAndGrowStory(\\n        uint256 burnedTokenId,\\n        uint256 extendedTokenId,\\n        address vault1,\\n        address vault2\\n    ) external;\\n\\n    /// @notice Enables the decentralisation of a token's metadata\\n    /// @dev A signature, by a trusted third party, is necessary to decentralise a tokens' metadata.\\n    ///      Emits an event to enable tracking token decentralisation\\n    /// @param tokenId token ID for which to decentralise the metadata\\n    /// @param metadataUri new token's metadata URI\\n    /// @param signature signature that allows the sender to set its immutable token URI\\n    function setImmutableTokenURI(\\n        uint256 tokenId,\\n        string calldata metadataUri,\\n        bytes calldata signature,\\n        address vault\\n    ) external;\\n\\n    /**\\n     * ----------- ADMIN -----------\\n     */\\n\\n    /// @notice Get a Clopr Story's metadata URI\\n    /// @dev Don't forget the trailing slash in the base URI as it will be concatenated with other information.\\n    ///      Emits an event to enable tracking base URI changes\\n    /// @param newDefaultBaseUri token ID of the story\\n    function changeDefaultBaseUri(string memory newDefaultBaseUri) external;\\n\\n    /// @dev Used to emit an ERC-4906 event if the metadata are modified off chain\\n    function offchainMetadataUpdate() external;\\n\\n    /**\\n     * ----------- ENUMERATIONS -----------\\n     */\\n\\n    /// @notice Get all information of a story\\n    /// @param tokenId token ID of the story\\n    /// @return unftContract address of the NFT smart contract associated with the story\\n    /// @return unftTokenId token ID of the NFT smart contract associated with the story\\n    /// @return storyLength number of pages of the story\\n    /// @return maxStoryLength maximum number of pages of the story\\n    function getStoryInformation(\\n        uint256 tokenId\\n    )\\n        external\\n        view\\n        returns (\\n            IERC721 unftContract,\\n            uint256 unftTokenId,\\n            uint256 storyLength,\\n            uint24 maxStoryLength\\n        );\\n\\n    /// @notice Get the UNFT of a story\\n    /// @param tokenId token ID of the story\\n    /// @return unftContract address of the NFT smart contract associated with the story\\n    /// @return unftTokenId token ID of the NFT smart contract associated with the story\\n    function getUnft(\\n        uint256 tokenId\\n    ) external view returns (IERC721 unftContract, uint256 unftTokenId);\\n\\n    /// @notice Get the UNFT's contract address of a story\\n    /// @param tokenId token ID of the story\\n    /// @return unftContract address of the NFT smart contract associated with the story\\n    function getUnftContract(\\n        uint256 tokenId\\n    ) external view returns (IERC721 unftContract);\\n\\n    /// @notice Get the UNFT's token ID of a story\\n    /// @param tokenId token ID of the story\\n    /// @return unftTokenId token ID of the NFT smart contract associated with the story\\n    function getUnftTokenId(\\n        uint256 tokenId\\n    ) external view returns (uint256 unftTokenId);\\n\\n    /// @notice Get a story's length\\n    /// @param tokenId token ID of the story\\n    /// @return storyLength number of pages of the story\\n    function getStoryLength(\\n        uint256 tokenId\\n    ) external view returns (uint256 storyLength);\\n\\n    /// @notice Get a story's maximum length\\n    /// @param tokenId token ID of the story\\n    /// @return maxStoryLength maximum number of pages of the story\\n    function getMaxStoryLength(\\n        uint256 tokenId\\n    ) external view returns (uint256 maxStoryLength);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC4906.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4906.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/// @title EIP-721 Metadata Update Extension\\ninterface IERC4906 {\\n    /// @dev This event emits when the metadata of a token is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFT.\\n    event MetadataUpdate(uint256 _tokenId);\\n\\n    /// @dev This event emits when the metadata of a range of tokens is changed.\\n    /// So that the third-party platforms such as NFT market could\\n    /// timely update the images and related attributes of the NFTs.\\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/delegateCash/IDelegateRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity >=0.8.13;\\n\\n/**\\n * @title IDelegateRegistry\\n * @custom:version 2.0\\n * @custom:author foobar (0xfoobar)\\n * @notice A standalone immutable registry storing delegated permissions from one address to another\\n */\\ninterface IDelegateRegistry {\\n    /// @notice Delegation type, NONE is used when a delegation does not exist or is revoked\\n    enum DelegationType {\\n        NONE,\\n        ALL,\\n        CONTRACT,\\n        ERC721,\\n        ERC20,\\n        ERC1155\\n    }\\n\\n    /// @notice Struct for returning delegations\\n    struct Delegation {\\n        DelegationType type_;\\n        address to;\\n        address from;\\n        bytes32 rights;\\n        address contract_;\\n        uint256 tokenId;\\n        uint256 amount;\\n    }\\n\\n    /// @notice Emitted when an address delegates or revokes rights for their entire wallet\\n    event DelegateAll(address indexed from, address indexed to, bytes32 rights, bool enable);\\n\\n    /// @notice Emitted when an address delegates or revokes rights for a contract address\\n    event DelegateContract(address indexed from, address indexed to, address indexed contract_, bytes32 rights, bool enable);\\n\\n    /// @notice Emitted when an address delegates or revokes rights for an ERC721 tokenId\\n    event DelegateERC721(address indexed from, address indexed to, address indexed contract_, uint256 tokenId, bytes32 rights, bool enable);\\n\\n    /// @notice Emitted when an address delegates or revokes rights for an amount of ERC20 tokens\\n    event DelegateERC20(address indexed from, address indexed to, address indexed contract_, bytes32 rights, uint256 amount);\\n\\n    /// @notice Emitted when an address delegates or revokes rights for an amount of an ERC1155 tokenId\\n    event DelegateERC1155(address indexed from, address indexed to, address indexed contract_, uint256 tokenId, bytes32 rights, uint256 amount);\\n\\n    /// @notice Thrown if multicall calldata is malformed\\n    error MulticallFailed();\\n\\n    /**\\n     * -----------  WRITE -----------\\n     */\\n\\n    /**\\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\\n     * @param data The encoded function data for each of the calls to make to this contract\\n     * @return results The results from each of the calls passed in via data\\n     */\\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\\n\\n    /**\\n     * @notice Allow the delegate to act on behalf of `msg.sender` for all contracts\\n     * @param to The address to act as delegate\\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\\n     * @return delegationHash The unique identifier of the delegation\\n     */\\n    function delegateAll(address to, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\\n\\n    /**\\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific contract\\n     * @param to The address to act as delegate\\n     * @param contract_ The contract whose rights are being delegated\\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\\n     * @return delegationHash The unique identifier of the delegation\\n     */\\n    function delegateContract(address to, address contract_, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\\n\\n    /**\\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific ERC721 token\\n     * @param to The address to act as delegate\\n     * @param contract_ The contract whose rights are being delegated\\n     * @param tokenId The token id to delegate\\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\\n     * @param enable Whether to enable or disable this delegation, true delegates and false revokes\\n     * @return delegationHash The unique identifier of the delegation\\n     */\\n    function delegateERC721(address to, address contract_, uint256 tokenId, bytes32 rights, bool enable) external payable returns (bytes32 delegationHash);\\n\\n    /**\\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC20 tokens\\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\\n     * @param to The address to act as delegate\\n     * @param contract_ The address for the fungible token contract\\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\\n     * @param amount The amount to delegate, > 0 delegates and 0 revokes\\n     * @return delegationHash The unique identifier of the delegation\\n     */\\n    function delegateERC20(address to, address contract_, bytes32 rights, uint256 amount) external payable returns (bytes32 delegationHash);\\n\\n    /**\\n     * @notice Allow the delegate to act on behalf of `msg.sender` for a specific amount of ERC1155 tokens\\n     * @dev The actual amount is not encoded in the hash, just the existence of a amount (since it is an upper bound)\\n     * @param to The address to act as delegate\\n     * @param contract_ The address of the contract that holds the token\\n     * @param tokenId The token id to delegate\\n     * @param rights Specific subdelegation rights granted to the delegate, pass an empty bytestring to encompass all rights\\n     * @param amount The amount of that token id to delegate, > 0 delegates and 0 revokes\\n     * @return delegationHash The unique identifier of the delegation\\n     */\\n    function delegateERC1155(address to, address contract_, uint256 tokenId, bytes32 rights, uint256 amount) external payable returns (bytes32 delegationHash);\\n\\n    /**\\n     * ----------- CHECKS -----------\\n     */\\n\\n    /**\\n     * @notice Check if `to` is a delegate of `from` for the entire wallet\\n     * @param to The potential delegate address\\n     * @param from The potential address who delegated rights\\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\\n     * @return valid Whether delegate is granted to act on the from's behalf\\n     */\\n    function checkDelegateForAll(address to, address from, bytes32 rights) external view returns (bool);\\n\\n    /**\\n     * @notice Check if `to` is a delegate of `from` for the specified `contract_` or the entire wallet\\n     * @param to The delegated address to check\\n     * @param contract_ The specific contract address being checked\\n     * @param from The cold wallet who issued the delegation\\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet or that specific contract\\n     */\\n    function checkDelegateForContract(address to, address from, address contract_, bytes32 rights) external view returns (bool);\\n\\n    /**\\n     * @notice Check if `to` is a delegate of `from` for the specific `contract` and `tokenId`, the entire `contract_`, or the entire wallet\\n     * @param to The delegated address to check\\n     * @param contract_ The specific contract address being checked\\n     * @param tokenId The token id for the token to delegating\\n     * @param from The wallet that issued the delegation\\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\\n     * @return valid Whether delegate is granted to act on from's behalf for entire wallet, that contract, or that specific tokenId\\n     */\\n    function checkDelegateForERC721(address to, address from, address contract_, uint256 tokenId, bytes32 rights) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the amount of ERC20 tokens the delegate is granted rights to act on the behalf of\\n     * @param to The delegated address to check\\n     * @param contract_ The address of the token contract\\n     * @param from The cold wallet who issued the delegation\\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\\n     */\\n    function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the amount of a ERC1155 tokens the delegate is granted rights to act on the behalf of\\n     * @param to The delegated address to check\\n     * @param contract_ The address of the token contract\\n     * @param tokenId The token id to check the delegated amount of\\n     * @param from The cold wallet who issued the delegation\\n     * @param rights Specific rights to check for, pass the zero value to ignore subdelegations and check full delegations only\\n     * @return balance The delegated balance, which will be 0 if the delegation does not exist\\n     */\\n    function checkDelegateForERC1155(address to, address from, address contract_, uint256 tokenId, bytes32 rights) external view returns (uint256);\\n\\n    /**\\n     * ----------- ENUMERATIONS -----------\\n     */\\n\\n    /**\\n     * @notice Returns all enabled delegations a given delegate has received\\n     * @param to The address to retrieve delegations for\\n     * @return delegations Array of Delegation structs\\n     */\\n    function getIncomingDelegations(address to) external view returns (Delegation[] memory delegations);\\n\\n    /**\\n     * @notice Returns all enabled delegations an address has given out\\n     * @param from The address to retrieve delegations for\\n     * @return delegations Array of Delegation structs\\n     */\\n    function getOutgoingDelegations(address from) external view returns (Delegation[] memory delegations);\\n\\n    /**\\n     * @notice Returns all hashes associated with enabled delegations an address has received\\n     * @param to The address to retrieve incoming delegation hashes for\\n     * @return delegationHashes Array of delegation hashes\\n     */\\n    function getIncomingDelegationHashes(address to) external view returns (bytes32[] memory delegationHashes);\\n\\n    /**\\n     * @notice Returns all hashes associated with enabled delegations an address has given out\\n     * @param from The address to retrieve outgoing delegation hashes for\\n     * @return delegationHashes Array of delegation hashes\\n     */\\n    function getOutgoingDelegationHashes(address from) external view returns (bytes32[] memory delegationHashes);\\n\\n    /**\\n     * @notice Returns the delegations for a given array of delegation hashes\\n     * @param delegationHashes is an array of hashes that correspond to delegations\\n     * @return delegations Array of Delegation structs, return empty structs for nonexistent or revoked delegations\\n     */\\n    function getDelegationsFromHashes(bytes32[] calldata delegationHashes) external view returns (Delegation[] memory delegations);\\n\\n    /**\\n     * ----------- STORAGE ACCESS -----------\\n     */\\n\\n    /**\\n     * @notice Allows external contracts to read arbitrary storage slots\\n     */\\n    function readSlot(bytes32 location) external view returns (bytes32);\\n\\n    /**\\n     * @notice Allows external contracts to read an arbitrary array of storage slots\\n     */\\n    function readSlots(bytes32[] calldata locations) external view returns (bytes32[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/standards/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.2.3\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of ERC721A.\\n */\\ninterface IERC721A {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwner();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwner();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    /**\\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\\n     */\\n    error MintERC2309QuantityExceedsLimit();\\n\\n    /**\\n     * The `extraData` cannot be set on an unintialized ownership slot.\\n     */\\n    error OwnershipNotInitializedForExtraData();\\n\\n    // =============================================================\\n    //                            STRUCTS\\n    // =============================================================\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Stores the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\\n        uint24 extraData;\\n    }\\n\\n    // =============================================================\\n    //                         TOKEN COUNTERS\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     * Burned tokens will reduce the count.\\n     * To get the total number of tokens minted, please see {_totalMinted}.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // =============================================================\\n    //                            IERC721\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables\\n     * (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in `owner`'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\\n     * checking first that contract recipients are aware of the ERC721 protocol\\n     * to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move\\n     * this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement\\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\\n     * whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token\\n     * by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the\\n     * zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external payable;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom}\\n     * for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // =============================================================\\n    //                        IERC721Metadata\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    // =============================================================\\n    //                           IERC2309\\n    // =============================================================\\n\\n    /**\\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\\n     * (inclusive) is transferred from `from` to `to`, as defined in the\\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\\n     *\\n     * See {_mintERC2309} for more details.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"startDefaultBaseUri\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BaseUriCantBeNull\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CantApproveStories\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CantCreateStoryOfStory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CantTransferCloprStories\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DontOwnNft\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DontOwnStory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidDelegateVaultPairing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NeedDifferentTokenIds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAuthorised\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotErc721Contract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StoryDoesntExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StoryNotCompleted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenAlreadyOwned\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UNFTDoesntExist\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_toTokenId\",\"type\":\"uint256\"}],\"name\":\"BatchMetadataUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"storyTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bottleTokenId\",\"type\":\"uint256\"}],\"name\":\"CreateStory\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"burnedTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"extendedTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"newMaxLength\",\"type\":\"uint24\"}],\"name\":\"ExtendStory\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"MetadataUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newDefaultBaseUri\",\"type\":\"string\"}],\"name\":\"NewDefaultBaseUri\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"SetImmutableTokenURI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STORY_POTION_ID\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"burnedTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extendedTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"burnVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"extendVault\",\"type\":\"address\"}],\"name\":\"burnAndGrowStory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newDefaultBaseUri\",\"type\":\"string\"}],\"name\":\"changeDefaultBaseUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bottleTokenId\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC721\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"createStory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getMaxStoryLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxStoryLength\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getStoryInformation\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"unftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"unftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"storyLength\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"maxStoryLength\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getStoryLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"storyLength\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getUnft\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"unftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"unftTokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getUnftContract\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"unftContract\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getUnftTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unftTokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offchainMetadataUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"metadataUri\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"setImmutableTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"supports_\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"tokenURI_\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentSupply_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CloprStories", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002468747470733a2f2f6d657461646174612e636c6f70726e66742e636f6d2f73746f72792f00000000000000000000000000000000000000000000000000000000", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}