{"SourceCode": "pragma solidity ^0.4.18;\r\n\r\n /*\r\n * Contract that is working with ERC223 tokens\r\n * https://github.com/ethereum/EIPs/issues/223\r\n */\r\n\r\n/// @title ERC223ReceivingContract - Standard contract implementation for compatibility with ERC223 tokens.\r\ncontract ERC223ReceivingContract {\r\n\r\n    /// @dev Function that is called when a user or another contract wants to transfer funds.\r\n    /// @param _from Transaction initiator, analogue of msg.sender\r\n    /// @param _value Number of tokens to transfer.\r\n    /// @param _data Data containig a function signature and/or parameters\r\n    function tokenFallback(address _from, uint256 _value, bytes _data) public;\r\n}\r\n\r\n/// @title Base Token contract - Functions to be implemented by token contracts.\r\ncontract Token {\r\n    /*\r\n     * Implements ERC 20 standard.\r\n     * https://github.com/ethereum/EIPs/blob/f90864a3d2b2b45c4decf95efd26b3f0c276051a/EIPS/eip-20-token-standard.md\r\n     * https://github.com/ethereum/EIPs/issues/20\r\n     *\r\n     *  Added support for the ERC 223 \"tokenFallback\" method in a \"transfer\" function with a payload.\r\n     *  https://github.com/ethereum/EIPs/issues/223\r\n     */\r\n\r\n    /*\r\n     * ERC 20\r\n     */\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n    function burn(uint num) public;\r\n\r\n    /*\r\n     * ERC 223\r\n     */\r\n    function transfer(address _to, uint256 _value, bytes _data) public returns (bool success);\r\n\r\n    /*\r\n     * Events\r\n     */\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    event Burn(address indexed _burner, uint _value);\r\n\r\n    // There is no ERC223 compatible Transfer event, with `_data` included.\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/// @title PHI ERC223 Token with burn functionality\r\ncontract PhiToken is Token {\r\n\r\n    /*\r\n     *  Terminology:\r\n     *  1 token unit = PHI\r\n     *  1 token = PHI = sphi * multiplier\r\n     *  multiplier set from token's number of decimals (i.e. 10 ** decimals)\r\n     */\r\n\r\n    /*  \r\n     *  Section 1\r\n     *  - Variables\r\n     */\r\n    /// Token metadata\r\n    string constant public name = \"PHI Token\";\r\n    string constant public symbol = \"PHI\";\r\n    uint8 constant public decimals = 18;\r\n    using SafeMath for uint;\r\n    uint constant multiplier = 10 ** uint(decimals);\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    /*\r\n     * This is a slight change to the ERC20 base standard.\r\n     * function totalSupply() constant returns (uint256 supply);\r\n     * is replaced with:\r\n     * uint256 public totalSupply;\r\n     * This automatically creates a getter function for the totalSupply.\r\n     * This is moved to the base contract since public getter functions are not\r\n     * currently recognised as an implementation of the matching abstract\r\n     * function by the compiler.\r\n     *\r\n     * Hardcoded total supply (in sphi), it can be decreased only by burning tokens\r\n     */\r\n    uint256 public totalSupply =  24157817 * multiplier;\r\n\r\n    /// Keep track of assigned tokens at deploy\r\n    bool initialTokensAssigned = false;\r\n\r\n    /// Store pre-ico and ico address\r\n    address public PRE_ICO_ADDR;\r\n    address public ICO_ADDR;\r\n\r\n    /// Where tokens for team will be sent, used also for function-auth\r\n    address public WALLET_ADDR;\r\n\r\n    /// How long the tokens should be locked for transfers\r\n    uint public lockTime;\r\n\r\n    /* \r\n     *  Section 2\r\n     *  - modifiers\r\n     */\r\n    /// Do not allow transfers if lockTime is active, allow only\r\n    /// pre-ico and ico if it is (to distribute tokens)\r\n    modifier onlyIfLockTimePassed () {\r\n        require(now > lockTime || (msg.sender == PRE_ICO_ADDR || msg.sender == ICO_ADDR));\r\n        _;\r\n    }\r\n\r\n    /* \r\n     *  Section 3\r\n     *  - Events\r\n     */\r\n    event Deployed(uint indexed _total_supply);\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Contract constructor function, assigns tokens to ico, pre-ico,\r\n    /// wallet address and pre sale investors.\r\n    /// @param ico_address Address of the ico contract.\r\n    /// @param pre_ico_address Address of the pre-ico contract.\r\n    /// @param wallet_address Address of tokens to be sent to the PHI team.\r\n    /// @param _lockTime Epoch Timestamp describing how long the tokens should be\r\n    /// locked for transfers.\r\n    function PhiToken(\r\n        address ico_address,\r\n        address pre_ico_address,\r\n        address wallet_address,\r\n        uint _lockTime)\r\n        public\r\n    {\r\n        // Check destination address\r\n        require(ico_address != 0x0);\r\n        require(pre_ico_address != 0x0);\r\n        require(wallet_address != 0x0);\r\n        require(ico_address != pre_ico_address && wallet_address != ico_address);\r\n        require(initialTokensAssigned == false);\r\n        // _lockTime should be in the future\r\n        require(_lockTime > now);\r\n        lockTime = _lockTime;\r\n\r\n        WALLET_ADDR = wallet_address;\r\n\r\n        // Check total supply\r\n        require(totalSupply > multiplier);\r\n\r\n        // tokens to be assigned to pre-ico, ico and wallet address\r\n        uint initAssign = 0;\r\n\r\n        // to be sold in the ico\r\n        initAssign += assignTokens(ico_address, 7881196 * multiplier);\r\n        ICO_ADDR = ico_address;\r\n        // to be sold in the pre-ico\r\n        initAssign += assignTokens(pre_ico_address, 3524578 * multiplier);\r\n        PRE_ICO_ADDR = pre_ico_address;\r\n        // Reserved for the team, airdrop, marketing, business etc..\r\n        initAssign += assignTokens(wallet_address, 9227465 * multiplier);\r\n\r\n        // Pre sale allocations\r\n        uint presaleTokens = 0;\r\n        presaleTokens += assignTokens(address(0x72B16DC0e5f85aA4BBFcE81687CCc9D6871C2965), 230387 * multiplier);\r\n        presaleTokens += assignTokens(address(0x7270cC02d88Ea63FC26384f5d08e14EE87E75154), 132162 * multiplier);\r\n        presaleTokens += assignTokens(address(0x25F92f21222969BB0b1f14f19FBa770D30Ff678f), 132162 * multiplier);\r\n        presaleTokens += assignTokens(address(0xAc99C59D3353a34531Fae217Ba77139BBe4eDBb3), 443334 * multiplier);\r\n        presaleTokens += assignTokens(address(0xbe41D37eB2d2859143B9f1D29c7BC6d7e59174Da), 970826500000000000000000); // 970826.5 PHI\r\n        presaleTokens += assignTokens(address(0x63e9FA0e43Fcc7C702ed5997AfB8E215C5beE3c9), 970826500000000000000000); // 970826.5 PHI\r\n        presaleTokens += assignTokens(address(0x95c67812c5C41733419aC3b1916d2F282E7A15A4), 396486 * multiplier);\r\n        presaleTokens += assignTokens(address(0x1f5d30BB328498fF6E09b717EC22A9046C41C257), 20144 * multiplier);\r\n        presaleTokens += assignTokens(address(0x0a1ac564e95dAEDF8d454a3593b75CCdd474fc42), 19815 * multiplier);\r\n        presaleTokens += assignTokens(address(0x0C5448D5bC4C40b4d2b2c1D7E58E0541698d3e6E), 19815 * multiplier);\r\n        presaleTokens += assignTokens(address(0xFAe11D521538F067cE0B13B6f8C929cdEA934D07), 75279 * multiplier);\r\n        presaleTokens += assignTokens(address(0xEE51304603887fFF15c6d12165C6d96ff0f0c85b), 45949 * multiplier);\r\n        presaleTokens += assignTokens(address(0xd7Bab04C944faAFa232d6EBFE4f60FF8C4e9815F), 6127 * multiplier);\r\n        presaleTokens += assignTokens(address(0x603f39C81560019c8360F33bA45Bc1E4CAECb33e), 45949 * multiplier);\r\n        presaleTokens += assignTokens(address(0xBB5128f1093D1aa85F6d7D0cC20b8415E0104eDD), 15316 * multiplier);\r\n        \r\n        initialTokensAssigned = true;\r\n\r\n        Deployed(totalSupply);\r\n\r\n        assert(presaleTokens == 3524578 * multiplier);\r\n        assert(totalSupply == (initAssign.add(presaleTokens)));\r\n    }\r\n\r\n    /// @dev Helper function to assign tokens (team, pre-sale, ico, pre-ico etc..).\r\n    /// @notice It will be automatically called on deploy.\r\n    /// @param addr Receiver of the tokens.\r\n    /// @param amount Tokens (in sphi).\r\n    /// @return Tokens assigned\r\n    function assignTokens (address addr, uint amount) internal returns (uint) {\r\n        require(addr != 0x0);\r\n        require(initialTokensAssigned == false);\r\n        balances[addr] = amount;\r\n        Transfer(0x0, addr, balances[addr]);\r\n        return balances[addr];\r\n    }\r\n\r\n    /// @notice Allows `msg.sender` to simply destroy `_value` token units (sphi). This means the total\r\n    /// token supply will decrease.\r\n    /// @dev Allows to destroy token units (sphi).\r\n    /// @param _value Number of token units (sphi) to burn.\r\n    function burn(uint256 _value) public onlyIfLockTimePassed {\r\n        require(_value > 0);\r\n        require(balances[msg.sender] >= _value);\r\n        require(totalSupply >= _value);\r\n\r\n        uint pre_balance = balances[msg.sender];\r\n        address burner = msg.sender;\r\n        balances[burner] = balances[burner].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        Burn(burner, _value);\r\n        Transfer(burner, 0x0, _value);\r\n        assert(balances[burner] == pre_balance.sub(_value));\r\n    }\r\n\r\n    /*\r\n     * Token functions\r\n     */\r\n\r\n    /// @notice Send `_value` tokens to `_to` from `msg.sender`.\r\n    /// @dev Transfers sender's tokens to a given address. Returns success.\r\n    /// @param _to Address of token receiver.\r\n    /// @param _value Number of tokens to transfer.\r\n    /// @return Returns success of function call.\r\n    function transfer(address _to, uint256 _value) public onlyIfLockTimePassed returns (bool) {\r\n        require(_to != 0x0);\r\n        require(_to != address(this));\r\n        require(balances[msg.sender] >= _value);\r\n        require(balances[_to].add(_value) >= balances[_to]);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Send `_value` tokens to `_to` from `msg.sender` and trigger\r\n    /// tokenFallback if sender is a contract.\r\n    /// @dev Function that is called when a user or another contract wants to transfer funds.\r\n    /// @param _to Address of token receiver.\r\n    /// @param _value Number of tokens to transfer.\r\n    /// @param _data Data to be sent to tokenFallback\r\n    /// @return Returns success of function call.\r\n    function transfer(\r\n        address _to,\r\n        uint256 _value,\r\n        bytes _data)\r\n        public\r\n        onlyIfLockTimePassed\r\n        returns (bool)\r\n    {\r\n        require(transfer(_to, _value));\r\n\r\n        uint codeLength;\r\n\r\n        assembly {\r\n            // Retrieve the size of the code on target address, this needs assembly.\r\n            codeLength := extcodesize(_to)\r\n        }\r\n\r\n        if (codeLength > 0) {\r\n            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Transfer `_value` tokens from `_from` to `_to` if `msg.sender` is allowed.\r\n    /// @dev Allows for an approved third party to transfer tokens from one\r\n    /// address to another. Returns success.\r\n    /// @param _from Address from where tokens are withdrawn.\r\n    /// @param _to Address to where tokens are sent.\r\n    /// @param _value Number of tokens to transfer.\r\n    /// @return Returns success of function call.\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public\r\n        onlyIfLockTimePassed\r\n        returns (bool)\r\n    {\r\n        require(_from != 0x0);\r\n        require(_to != 0x0);\r\n        require(_to != address(this));\r\n        require(balances[_from] >= _value);\r\n        require(allowed[_from][msg.sender] >= _value);\r\n        require(balances[_to].add(_value) >= balances[_to]);\r\n\r\n        balances[_to] = balances[_to].add(_value);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\r\n        Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows `_spender` to transfer `_value` tokens from `msg.sender` to any address.\r\n    /// @dev Sets approved amount of tokens for spender. Returns success.\r\n    /// @param _spender Address of allowed account.\r\n    /// @param _value Number of approved tokens.\r\n    /// @return Returns success of function call.\r\n    function approve(address _spender, uint256 _value) public onlyIfLockTimePassed returns (bool) {\r\n        require(_spender != 0x0);\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        // allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        // already 0 to mitigate the race condition described here:\r\n        // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require(_value == 0 || allowed[msg.sender][_spender] == 0);\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * Read functions\r\n     */\r\n    /// @dev Returns number of allowed tokens that a spender can transfer on\r\n    /// behalf of a token owner.\r\n    /// @param _owner Address of token owner.\r\n    /// @param _spender Address of token spender.\r\n    /// @return Returns remaining allowance for spender.\r\n    function allowance(address _owner, address _spender)\r\n        constant\r\n        public\r\n        returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /// @dev Returns number of tokens owned by the given address.\r\n    /// @param _owner Address of token owner.\r\n    /// @return Returns balance of owner.\r\n    function balanceOf(address _owner) constant public returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WALLET_ADDR\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ICO_ADDR\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRE_ICO_ADDR\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"ico_address\",\"type\":\"address\"},{\"name\":\"pre_ico_address\",\"type\":\"address\"},{\"name\":\"wallet_address\",\"type\":\"address\"},{\"name\":\"_lockTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_total_supply\",\"type\":\"uint256\"}],\"name\":\"Deployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"}]", "ContractName": "PhiToken", "CompilerVersion": "v0.4.19+commit.c4cbbb05", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ac65447589555ec19cbafc5cec717318ec811874000000000000000000000000a17f2bc6b11b4dd60ab38c94e7784634646749c90000000000000000000000008e36256fa656adcf951bb458ba6e5439432780f0000000000000000000000000000000000000000000000000000000005ac60fc0", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://6762d56fc8f0ccd3db3270c48ca0481f5105a61f0ce21bdfda6c6d4391442549"}