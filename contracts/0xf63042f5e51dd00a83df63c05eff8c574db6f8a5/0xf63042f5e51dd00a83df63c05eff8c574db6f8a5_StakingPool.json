{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.20;\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\nlibrary Address {\r\n    error AddressInsufficientBalance(address account);\r\n    error AddressEmptyCode(address target);\r\n    error FailedInnerCall();\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        if (address(this).balance < amount) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        if (!success) {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, defaultRevert);\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        function() internal view customRevert\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, customRevert);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, defaultRevert);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        function() internal view customRevert\r\n    ) internal returns (bytes memory) {\r\n        if (address(this).balance < value) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, customRevert);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, defaultRevert);\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        function() internal view customRevert\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, customRevert);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, defaultRevert);\r\n    }\r\n\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        function() internal view customRevert\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, customRevert);\r\n    }\r\n\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        function() internal view customRevert\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                if (target.code.length == 0) {\r\n                    revert AddressEmptyCode(target);\r\n                }\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, customRevert);\r\n        }\r\n    }\r\n\r\n    function verifyCallResult(bool success, bytes memory returndata) internal view returns (bytes memory) {\r\n        return verifyCallResult(success, returndata, defaultRevert);\r\n    }\r\n\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        function() internal view customRevert\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, customRevert);\r\n        }\r\n    }\r\n\r\n    function defaultRevert() internal pure {\r\n        revert FailedInnerCall();\r\n    }\r\n\r\n    function _revert(bytes memory returndata, function() internal view customRevert) private view {\r\n        if (returndata.length > 0) {\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            customRevert();\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    error SafeERC20FailedOperation(address token);\r\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 oldAllowance = token.allowance(address(this), spender);\r\n        forceApprove(token, spender, oldAllowance + value);\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\r\n        unchecked {\r\n            uint256 currentAllowance = token.allowance(address(this), spender);\r\n            if (currentAllowance < requestedDecrease) {\r\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\r\n            }\r\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\r\n        }\r\n    }\r\n\r\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\r\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\r\n\r\n        if (!_callOptionalReturnBool(token, approvalCall)) {\r\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\r\n            _callOptionalReturn(token, approvalCall);\r\n        }\r\n    }\r\n\r\n    /*\r\n    function safePermit(\r\n        IERC20Permit token,\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal {\r\n        uint256 nonceBefore = token.nonces(owner);\r\n        token.permit(owner, spender, value, deadline, v, r, s);\r\n        uint256 nonceAfter = token.nonces(owner);\r\n        if (nonceAfter != nonceBefore + 1) {\r\n            revert SafeERC20FailedOperation(address(token));\r\n        }\r\n    }\r\n    */\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data);\r\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\r\n            revert SafeERC20FailedOperation(address(token));\r\n        }\r\n    }\r\n\r\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract ReEntrancyGuard {\r\n    bool internal locked;\r\n\r\n    modifier noReentrant() {\r\n        require(!locked, \"No re-entrancy\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n}\r\n\r\ncontract StakingPool is Ownable, ReEntrancyGuard {\r\n  using SafeERC20 for IERC20;\r\n  uint256 public constant EXP_FACTOR = 1e36;\r\n\r\n  struct PoolInfo {\r\n    IERC20 stakeToken;\r\n    IERC20 rewardToken;\r\n    uint256 lastRewardTimestamp;\r\n    uint256 accRewardPerShare;\r\n    uint256 depositedAmount;\r\n    uint256 rewardsAmount;\r\n    uint256 rewardsClaimed;\r\n    uint256 rewardReserve;\r\n    uint256 rewardPerDayRate; // 1 == 0.0001% - smallest unit\r\n    uint256 lockupDuration; // seconds the stake is locked for\r\n    uint256 depositMinimum; // min per deposit\r\n    uint256 stakeMaximum; // total stake maximum\r\n    bool depositEnabled;\r\n  }\r\n\r\n  struct UserInfo {\r\n    uint256 amount;\r\n    uint256 rewardDebt;\r\n    uint256 pendingRewards;\r\n    uint256 lockupStart;\r\n  }  \r\n\r\n  // mappings\r\n  PoolInfo public poolInfo;\r\n  mapping(address => UserInfo) public userInfo;  \r\n\r\n  event Deposit(address indexed user, uint256 amount);\r\n  event Withdraw(address indexed user, uint256 amount);\r\n  event Claim(address indexed user, uint256 amount);  \r\n\r\n  constructor(IERC20 stakeToken, IERC20 rewardToken, uint256 rewardPerDayRate, uint256 lockupDuration, uint256 depositMinimum, uint256 stakeMaximum) {\r\n    PoolInfo storage pool = poolInfo;\r\n    pool.stakeToken = stakeToken;\r\n    pool.rewardToken = rewardToken;\r\n    pool.rewardPerDayRate = rewardPerDayRate;\r\n    pool.lockupDuration = lockupDuration;\r\n    pool.depositMinimum = depositMinimum;\r\n    pool.stakeMaximum = stakeMaximum;\r\n  }\r\n\r\n  function setRewardPerDayRate(uint256 rate) external onlyOwner {\r\n    PoolInfo storage pool = poolInfo;\r\n    updatePool();\r\n    pool.rewardPerDayRate = rate;\r\n  }\r\n\r\n  function setLockupDuration(uint256 lockupDuration) external onlyOwner {\r\n    PoolInfo storage pool = poolInfo;\r\n    pool.lockupDuration = lockupDuration;\r\n  }\r\n\r\n  function setDepositMinimum(uint256 amount) external onlyOwner {\r\n    PoolInfo storage pool = poolInfo;\r\n    pool.depositMinimum = amount;\r\n  }\r\n\r\n  function setStakeMaximum(uint256 amount) external onlyOwner {\r\n    PoolInfo storage pool = poolInfo;\r\n    pool.stakeMaximum = amount;\r\n  }\r\n\r\n  function setDepositEnabled(bool enabled) external onlyOwner {\r\n    PoolInfo storage pool = poolInfo;\r\n    pool.depositEnabled = enabled;\r\n  }\r\n\r\n  function updatePool() internal {\r\n    PoolInfo storage pool = poolInfo;\r\n    \r\n    if(block.timestamp <= pool.lastRewardTimestamp) {\r\n        return;\r\n    }\r\n\r\n    if(pool.depositedAmount == 0) {\r\n      pool.lastRewardTimestamp = block.timestamp;\r\n      return;\r\n    }\r\n\r\n    uint256 diff = block.timestamp - pool.lastRewardTimestamp;\r\n    uint256 rewardPerSecondRate = (pool.rewardPerDayRate * EXP_FACTOR) / 86400;\r\n    uint256 reward = (diff * (rewardPerSecondRate / 1000000) * pool.depositedAmount) / EXP_FACTOR;\r\n\r\n    pool.rewardsAmount = pool.rewardsAmount + reward;\r\n    pool.accRewardPerShare = pool.accRewardPerShare + ((reward * EXP_FACTOR) / pool.depositedAmount);\r\n    pool.lastRewardTimestamp = block.timestamp;\r\n  }  \r\n\r\n  function _deposit(uint256 amount) internal {\r\n    PoolInfo storage pool = poolInfo;\r\n    UserInfo storage user = userInfo[msg.sender];\r\n\r\n    require(pool.depositEnabled, \"Deposits are not enabled\");\r\n    require(amount > 0, \"The amount can not be zero\");\r\n    require(amount >= pool.depositMinimum, \"The amount is less than the deposit minimum\");\r\n    require(pool.stakeMaximum == 0 || (user.amount + amount <= pool.stakeMaximum), \"The deposit is more than the stake maximum\");\r\n\r\n    updatePool();\r\n\r\n    if(user.amount > 0) {\r\n      uint256 pending = ((user.amount * pool.accRewardPerShare) / EXP_FACTOR) - user.rewardDebt;\r\n      user.pendingRewards = user.pendingRewards + pending;\r\n    }\r\n\r\n    pool.stakeToken.safeTransferFrom(address(msg.sender), address(this), amount);\r\n    user.amount = user.amount + amount;\r\n    pool.depositedAmount = pool.depositedAmount + amount;\r\n    user.rewardDebt = (user.amount * pool.accRewardPerShare) / EXP_FACTOR;\r\n    user.lockupStart = block.timestamp;\r\n\r\n    emit Deposit(msg.sender, amount);\r\n  }\r\n\r\n  function _withdraw(uint256 amount) internal {\r\n    PoolInfo storage pool = poolInfo;\r\n    UserInfo storage user = userInfo[msg.sender];    \r\n\r\n    require(amount > 0, \"The amount can not be zero\");\r\n    require(user.amount >= amount, \"The amount is more than the stake amount\");\r\n    require(pool.lockupDuration == 0 || block.timestamp > user.lockupStart + pool.lockupDuration, \"The stake lockup duration has not been reached\");\r\n\r\n    updatePool();\r\n\r\n    uint256 pending = ((user.amount * pool.accRewardPerShare) / EXP_FACTOR) - user.rewardDebt;\r\n    if(pending > 0) {\r\n      user.pendingRewards = user.pendingRewards + pending;\r\n    }\r\n\r\n    pool.stakeToken.safeTransfer(msg.sender, amount);\r\n    pool.depositedAmount = pool.depositedAmount - amount;\r\n    user.amount = user.amount - amount;\r\n    user.rewardDebt = (user.amount * pool.accRewardPerShare) / EXP_FACTOR;\r\n    //user.lockupStart = block.timestamp;\r\n\r\n    emit Withdraw(msg.sender, amount);\r\n  }\r\n\r\n  function deposit(uint256 amount) external noReentrant {\r\n    _deposit(amount);\r\n  }  \r\n\r\n  function depositMax() external noReentrant {\r\n    _deposit(poolInfo.stakeToken.allowance(msg.sender, address(this)));\r\n  }  \r\n\r\n  function withdraw(uint256 amount) external noReentrant {\r\n    _withdraw(amount);\r\n  }  \r\n\r\n  function withdrawMax() external noReentrant {\r\n    _withdraw(userInfo[msg.sender].amount);\r\n  }  \r\n\r\n  function claim() external noReentrant {\r\n    PoolInfo storage pool = poolInfo;\r\n    UserInfo storage user = userInfo[msg.sender];\r\n\r\n    updatePool();\r\n\r\n    uint256 pending = ((user.amount * pool.accRewardPerShare) / EXP_FACTOR) - user.rewardDebt;\r\n    if(pending > 0 || user.pendingRewards > 0) {\r\n      user.pendingRewards = user.pendingRewards + pending;\r\n      uint256 claimed = safeRewardTransfer(msg.sender, user.pendingRewards);\r\n      emit Claim(msg.sender, claimed);\r\n      user.pendingRewards = user.pendingRewards - claimed;\r\n      user.lockupStart = block.timestamp;\r\n      pool.rewardsAmount = pool.rewardsAmount - claimed;\r\n      pool.rewardsClaimed = pool.rewardsClaimed + claimed;\r\n    }\r\n    user.rewardDebt = (user.amount * pool.accRewardPerShare) / EXP_FACTOR;\r\n  }  \r\n\r\n  function pendingRewards(address _user) external view returns (uint256) {\r\n    PoolInfo storage pool = poolInfo;\r\n    UserInfo storage user = userInfo[_user];\r\n\r\n    uint256 accRewardPerShare = pool.accRewardPerShare;\r\n    if(block.timestamp > pool.lastRewardTimestamp && pool.depositedAmount > 0) {\r\n      uint256 diff = block.timestamp - pool.lastRewardTimestamp;\r\n      uint256 rewardPerSecondRate = (pool.rewardPerDayRate * EXP_FACTOR) / 86400;\r\n      uint256 reward = (diff * (rewardPerSecondRate / 1000000) * pool.depositedAmount) / EXP_FACTOR;\r\n      accRewardPerShare = accRewardPerShare + ((reward * EXP_FACTOR) / pool.depositedAmount); // store expanded 1e36\r\n    }\r\n    return (((user.amount * accRewardPerShare) / EXP_FACTOR) - user.rewardDebt) + user.pendingRewards;\r\n  } \r\n\r\n  function pendingRewardsTotal(uint256 timestamp) external view returns (uint256) {\r\n    PoolInfo storage pool = poolInfo;    \r\n    if(timestamp == 0) {\r\n      timestamp = block.timestamp;\r\n    }\r\n    uint256 accRewardPerShare = pool.accRewardPerShare;\r\n    if(timestamp > pool.lastRewardTimestamp && pool.depositedAmount > 0) {\r\n      uint256 diff = timestamp - pool.lastRewardTimestamp;\r\n      uint256 rewardPerSecondRate = (pool.rewardPerDayRate * EXP_FACTOR) / 86400;\r\n      uint256 reward = (diff * (rewardPerSecondRate / 1000000) * pool.depositedAmount) / EXP_FACTOR;\r\n      accRewardPerShare = accRewardPerShare + ((reward * EXP_FACTOR) / pool.depositedAmount); // store expanded 1e36\r\n    }\r\n    uint256 poolDebt = 0;\r\n    poolDebt = (pool.depositedAmount * pool.accRewardPerShare) / EXP_FACTOR;\r\n    return (((pool.depositedAmount * accRewardPerShare) / EXP_FACTOR) - poolDebt) + pool.rewardsAmount;\r\n  }\r\n\r\n  function safeRewardTransfer(address to, uint256 amount) internal returns (uint256) {\r\n    PoolInfo storage pool = poolInfo;\r\n    uint256 rewardAmount = amount;\r\n    if(rewardAmount > pool.rewardsAmount) {\r\n      rewardAmount = pool.rewardsAmount;\r\n    }\r\n    if(rewardAmount > pool.rewardReserve) {\r\n      rewardAmount = pool.rewardReserve;\r\n    }\r\n    pool.rewardToken.safeTransfer(to, rewardAmount);\r\n    pool.rewardReserve = pool.rewardReserve - rewardAmount;\r\n    return rewardAmount;\r\n  }  \r\n\r\n  function depositRewardReserve(uint256 amount) external onlyOwner {\r\n    PoolInfo storage pool = poolInfo;\r\n    pool.rewardToken.safeTransferFrom(address(msg.sender), address(this), amount);\r\n    pool.rewardReserve = pool.rewardReserve + amount;\r\n  }\r\n\r\n  function withdrawRewardReserve(uint256 amount) external onlyOwner {\r\n    PoolInfo storage pool = poolInfo;\r\n    require(pool.rewardReserve >= amount, \"Amount is more than the reward reserve\");\r\n    pool.rewardReserve = pool.rewardReserve - amount;\r\n    pool.rewardToken.safeTransfer(address(owner()), amount);\r\n  }  \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerDayRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockupDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositMinimum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeMaximum\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EXP_FACTOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositRewardReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"pendingRewardsTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accRewardPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerDayRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockupDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositMinimum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeMaximum\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"depositEnabled\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setDepositEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setDepositMinimum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lockupDuration\",\"type\":\"uint256\"}],\"name\":\"setLockupDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setRewardPerDayRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setStakeMaximum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockupStart\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawRewardReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StakingPool", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b2d97fe4bd48246337c02024985d9b2a0c3ddcfe000000000000000000000000b2d97fe4bd48246337c02024985d9b2a0c3ddcfe0000000000000000000000000000000000000000000000000000000000011bd100000000000000000000000000000000000000000000000000000000001baf8000000000000000000000000000000000000000000000001b1ae4d6e2ef5000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b9e0cc0feef6741c8963855eee64b5ead24d7f4a25a12ff0c78fa9312c0d0b48"}