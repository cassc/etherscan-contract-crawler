{"SourceCode": "pragma solidity ^0.4.15;\r\n\r\n\r\n/*\r\n*  deex.exchange pre-ICO tokens smart contract\r\n*  implements [ERC-20 Token Standard](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md)\r\n*\r\n*  Style\r\n*  1) before start coding, run Python and type 'import this' in Python console.\r\n*  2) we avoid using inheritance (contract B is A) as it makes code less clear for observer\r\n*  (\"Flat is better than nested\", \"Readability counts\")\r\n*  3) we avoid using -= ; =- ; +=; =+\r\n*  see: https://github.com/ether-camp/virtual-accelerator/issues/8\r\n*  https://www.ethnews.com/ethercamps-hkg-token-has-a-bug-and-needs-to-be-reissued\r\n*  4) always explicitly mark variables and functions visibility (\"Explicit is better than implicit\")\r\n*  5) every function except constructor should trigger at leas one event.\r\n*  6) smart contracts have to be audited and reviewed, comment your code.\r\n*\r\n*  Code is published on https://github.com/thedeex/thedeex.github.io\r\n*/\r\n\r\n\r\n/* \"Interfaces\" */\r\n\r\n//  this is expected from another contracts\r\n//  if it wants to spend tokens of behalf of the token owner in our contract\r\n//  this can be used in many situations, for example to convert pre-ICO tokens to ICO tokens\r\n//  see 'approveAndCall' function\r\ncontract allowanceRecipient {\r\n    function receiveApproval(address _from, uint256 _value, address _inContract, bytes _extraData) returns (bool success);\r\n}\r\n\r\n\r\n// see:\r\n// https://github.com/ethereum/EIPs/issues/677\r\ncontract tokenRecipient {\r\n    function tokenFallback(address _from, uint256 _value, bytes _extraData) returns (bool success);\r\n}\r\n\r\n\r\ncontract DEEX {\r\n\r\n    // ver. 2.0\r\n\r\n    /* ---------- Variables */\r\n\r\n    /* --- ERC-20 variables */\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#name\r\n    // function name() constant returns (string name)\r\n    string public name = \"deex\";\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#symbol\r\n    // function symbol() constant returns (string symbol)\r\n    string public symbol = \"deex\";\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#decimals\r\n    // function decimals() constant returns (uint8 decimals)\r\n    uint8 public decimals = 0;\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#totalsupply\r\n    // function totalSupply() constant returns (uint256 totalSupply)\r\n    // we start with zero and will create tokens as SC receives ETH\r\n    uint256 public totalSupply;\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#balanceof\r\n    // function balanceOf(address _owner) constant returns (uint256 balance)\r\n    mapping (address => uint256) public balanceOf;\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#allowance\r\n    // function allowance(address _owner, address _spender) constant returns (uint256 remaining)\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    /* ----- For tokens sale */\r\n\r\n    uint256 public salesCounter = 0;\r\n\r\n    uint256 public maxSalesAllowed;\r\n\r\n    bool private transfersBetweenSalesAllowed;\r\n\r\n    // initial value should be changed by the owner\r\n    uint256 public tokenPriceInWei = 0;\r\n\r\n    uint256 public saleStartUnixTime = 0; // block.timestamp\r\n    uint256 public saleEndUnixTime = 0;  // block.timestamp\r\n\r\n    /* --- administrative */\r\n    address public owner;\r\n\r\n    // account that can set prices\r\n    address public priceSetter;\r\n\r\n    // 0 - not set\r\n    uint256 private priceMaxWei = 0;\r\n    // 0 - not set\r\n    uint256 private priceMinWei = 0;\r\n\r\n    // accounts holding tokens for for the team, for advisers and for the bounty campaign\r\n    mapping (address => bool) public isPreferredTokensAccount;\r\n\r\n    bool public contractInitialized = false;\r\n\r\n\r\n    /* ---------- Constructor */\r\n    // do not forget about:\r\n    // https://medium.com/@codetractio/a-look-into-paritys-multisig-wallet-bug-affecting-100-million-in-ether-and-tokens-356f5ba6e90a\r\n    function DEEX() {\r\n        owner = msg.sender;\r\n\r\n        // for testNet can be more than 2\r\n        // --------------------------------2------------------------------------------------------change  in production!\r\n        maxSalesAllowed = 2;\r\n        //\r\n        transfersBetweenSalesAllowed = true;\r\n    }\r\n\r\n\r\n    function initContract(address team, address advisers, address bounty) public onlyBy(owner) returns (bool){\r\n\r\n        require(contractInitialized == false);\r\n        contractInitialized = true;\r\n\r\n        priceSetter = msg.sender;\r\n\r\n        totalSupply = 100000000;\r\n\r\n        // tokens for sale go SC own account\r\n        balanceOf[this] = 75000000;\r\n\r\n        // for the team\r\n        balanceOf[team] = balanceOf[team] + 15000000;\r\n        isPreferredTokensAccount[team] = true;\r\n\r\n        // for advisers\r\n        balanceOf[advisers] = balanceOf[advisers] + 7000000;\r\n        isPreferredTokensAccount[advisers] = true;\r\n\r\n        // for the bounty campaign\r\n        balanceOf[bounty] = balanceOf[bounty] + 3000000;\r\n        isPreferredTokensAccount[bounty] = true;\r\n\r\n    }\r\n\r\n    /* ---------- Events */\r\n\r\n    /* --- ERC-20 events */\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#events\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer-1\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#approval\r\n    event Approval(address indexed _owner, address indexed spender, uint256 value);\r\n\r\n    /* --- Administrative events:  */\r\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\r\n\r\n    /* ---- Tokens creation and sale events  */\r\n\r\n    event PriceChanged(uint256 indexed newTokenPriceInWei);\r\n\r\n    event SaleStarted(uint256 startUnixTime, uint256 endUnixTime, uint256 indexed saleNumber);\r\n\r\n    event NewTokensSold(uint256 numberOfTokens, address indexed purchasedBy, uint256 indexed priceInWei);\r\n\r\n    event Withdrawal(address indexed to, uint sumInWei);\r\n\r\n    /* --- Interaction with other contracts events  */\r\n    event DataSentToAnotherContract(address indexed _from, address indexed _toContract, bytes _extraData);\r\n\r\n    /* ---------- Functions */\r\n\r\n    /* --- Modifiers  */\r\n    modifier onlyBy(address _account){\r\n        require(msg.sender == _account);\r\n\r\n        _;\r\n    }\r\n\r\n    /* --- ERC-20 Functions */\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#methods\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer\r\n    function transfer(address _to, uint256 _value) public returns (bool){\r\n        return transferFrom(msg.sender, _to, _value);\r\n    }\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transferfrom\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool){\r\n\r\n        // transfers are possible only after sale is finished\r\n        // except for manager and preferred accounts\r\n\r\n        bool saleFinished = saleIsFinished();\r\n        require(saleFinished || msg.sender == owner || isPreferredTokensAccount[msg.sender]);\r\n\r\n        // transfers can be forbidden until final ICO is finished\r\n        // except for manager and preferred accounts\r\n        require(transfersBetweenSalesAllowed || salesCounter == maxSalesAllowed || msg.sender == owner || isPreferredTokensAccount[msg.sender]);\r\n\r\n        // Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event (ERC-20)\r\n        require(_value >= 0);\r\n\r\n        // The function SHOULD throw unless the _from account has deliberately authorized the sender of the message via some mechanism\r\n        require(msg.sender == _from || _value <= allowance[_from][msg.sender]);\r\n\r\n        // check if _from account have required amount\r\n        require(_value <= balanceOf[_from]);\r\n\r\n        // Subtract from the sender\r\n        balanceOf[_from] = balanceOf[_from] - _value;\r\n        //\r\n        // Add the same to the recipient\r\n        balanceOf[_to] = balanceOf[_to] + _value;\r\n\r\n        // If allowance used, change allowances correspondingly\r\n        if (_from != msg.sender) {\r\n            allowance[_from][msg.sender] = allowance[_from][msg.sender] - _value;\r\n        }\r\n\r\n        // event\r\n        Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#approve\r\n    // there is and attack, see:\r\n    // https://github.com/CORIONplatform/solidity/issues/6,\r\n    // https://drive.google.com/file/d/0ByMtMw2hul0EN3NCaVFHSFdxRzA/view\r\n    // but this function is required by ERC-20\r\n    function approve(address _spender, uint256 _value) public returns (bool success){\r\n\r\n        require(_value >= 0);\r\n\r\n        allowance[msg.sender][_spender] = _value;\r\n\r\n        // event\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*  ---------- Interaction with other contracts  */\r\n\r\n    /* User can allow another smart contract to spend some shares in his behalf\r\n    *  (this function should be called by user itself)\r\n    *  @param _spender another contract's address\r\n    *  @param _value number of tokens\r\n    *  @param _extraData Data that can be sent from user to another contract to be processed\r\n    *  bytes - dynamically-sized byte array,\r\n    *  see http://solidity.readthedocs.io/en/v0.4.15/types.html#dynamically-sized-byte-array\r\n    *  see possible attack information in comments to function 'approve'\r\n    *  > this may be used to convert pre-ICO tokens to ICO tokens\r\n    */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n\r\n        approve(_spender, _value);\r\n\r\n        // 'spender' is another contract that implements code as prescribed in 'allowanceRecipient' above\r\n        allowanceRecipient spender = allowanceRecipient(_spender);\r\n\r\n        // our contract calls 'receiveApproval' function of another contract ('allowanceRecipient') to send information about\r\n        // allowance and data sent by user\r\n        // 'this' is this (our) contract address\r\n        if (spender.receiveApproval(msg.sender, _value, this, _extraData)) {\r\n            DataSentToAnotherContract(msg.sender, _spender, _extraData);\r\n            return true;\r\n        }\r\n        else return false;\r\n    }\r\n\r\n    function approveAllAndCall(address _spender, bytes _extraData) public returns (bool success) {\r\n        return approveAndCall(_spender, balanceOf[msg.sender], _extraData);\r\n    }\r\n\r\n    /* https://github.com/ethereum/EIPs/issues/677\r\n    * transfer tokens with additional info to another smart contract, and calls its correspondent function\r\n    * @param address _to - another smart contract address\r\n    * @param uint256 _value - number of tokens\r\n    * @param bytes _extraData - data to send to another contract\r\n    * > this may be used to convert pre-ICO tokens to ICO tokens\r\n    */\r\n    function transferAndCall(address _to, uint256 _value, bytes _extraData) public returns (bool success){\r\n\r\n        transferFrom(msg.sender, _to, _value);\r\n\r\n        tokenRecipient receiver = tokenRecipient(_to);\r\n\r\n        if (receiver.tokenFallback(msg.sender, _value, _extraData)) {\r\n            DataSentToAnotherContract(msg.sender, _to, _extraData);\r\n            return true;\r\n        }\r\n        else return false;\r\n    }\r\n\r\n    // for example for conveting ALL tokens of user account to another tokens\r\n    function transferAllAndCall(address _to, bytes _extraData) public returns (bool success){\r\n        return transferAndCall(_to, balanceOf[msg.sender], _extraData);\r\n    }\r\n\r\n    /* --- Administrative functions */\r\n\r\n    function changeOwner(address _newOwner) public onlyBy(owner) returns (bool success){\r\n        //\r\n        require(_newOwner != address(0));\r\n\r\n        address oldOwner = owner;\r\n        owner = _newOwner;\r\n\r\n        OwnerChanged(oldOwner, _newOwner);\r\n\r\n        return true;\r\n    }\r\n\r\n    /* ---------- Create and sell tokens  */\r\n\r\n    /* set time for start and time for end pre-ICO\r\n    * time is integer representing block timestamp\r\n    * in UNIX Time,\r\n    * see: https://www.epochconverter.com\r\n    * @param uint256 startTime - time to start\r\n    * @param uint256 endTime - time to end\r\n    * should be taken into account that\r\n    * \"block.timestamp\" can be influenced by miners to a certain degree.\r\n    * That means that a miner can \"choose\" the block.timestamp, to a certain degree,\r\n    * to change the outcome of a transaction in the mined block.\r\n    * see:\r\n    * http://solidity.readthedocs.io/en/v0.4.15/frequently-asked-questions.html#are-timestamps-now-block-timestamp-reliable\r\n    */\r\n\r\n    function startSale(uint256 _startUnixTime, uint256 _endUnixTime) public onlyBy(owner) returns (bool success){\r\n\r\n        require(balanceOf[this] > 0);\r\n        require(salesCounter < maxSalesAllowed);\r\n\r\n        // time for sale can be set only if:\r\n        // this is first sale (saleStartUnixTime == 0 && saleEndUnixTime == 0) , or:\r\n        // previous sale finished ( saleIsFinished() )\r\n        require(\r\n        (saleStartUnixTime == 0 && saleEndUnixTime == 0) || saleIsFinished()\r\n        );\r\n        // time can be set only for future\r\n        require(_startUnixTime > now && _endUnixTime > now);\r\n        // end time should be later than start time\r\n        require(_endUnixTime - _startUnixTime > 0);\r\n\r\n        saleStartUnixTime = _startUnixTime;\r\n        saleEndUnixTime = _endUnixTime;\r\n        salesCounter = salesCounter + 1;\r\n\r\n        SaleStarted(_startUnixTime, _endUnixTime, salesCounter);\r\n\r\n        return true;\r\n    }\r\n\r\n    function saleIsRunning() public constant returns (bool){\r\n\r\n        if (balanceOf[this] == 0) {\r\n            return false;\r\n        }\r\n\r\n        if (saleStartUnixTime == 0 && saleEndUnixTime == 0) {\r\n            return false;\r\n        }\r\n\r\n        if (now > saleStartUnixTime && now < saleEndUnixTime) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function saleIsFinished() public constant returns (bool){\r\n\r\n        if (balanceOf[this] == 0) {\r\n            return true;\r\n        }\r\n\r\n        else if (\r\n        (saleStartUnixTime > 0 && saleEndUnixTime > 0)\r\n        && now > saleEndUnixTime) {\r\n\r\n            return true;\r\n        }\r\n\r\n        // <<<\r\n        return false;\r\n    }\r\n\r\n    function changePriceSetter(address _priceSetter) public onlyBy(owner) returns (bool success) {\r\n        priceSetter = _priceSetter;\r\n        return true;\r\n    }\r\n\r\n    function setMinMaxPriceInWei(uint256 _priceMinWei, uint256 _priceMaxWei) public onlyBy(owner) returns (bool success){\r\n        require(_priceMinWei >= 0 && _priceMaxWei >= 0);\r\n        priceMinWei = _priceMinWei;\r\n        priceMaxWei = _priceMaxWei;\r\n        return true;\r\n    }\r\n\r\n\r\n    function setTokenPriceInWei(uint256 _priceInWei) public onlyBy(priceSetter) returns (bool success){\r\n\r\n        require(_priceInWei >= 0);\r\n\r\n        // if 0 - not set\r\n        if (priceMinWei != 0 && _priceInWei < priceMinWei) {\r\n            tokenPriceInWei = priceMinWei;\r\n        }\r\n        else if (priceMaxWei != 0 && _priceInWei > priceMaxWei) {\r\n            tokenPriceInWei = priceMaxWei;\r\n        }\r\n        else {\r\n            tokenPriceInWei = _priceInWei;\r\n        }\r\n\r\n        PriceChanged(tokenPriceInWei);\r\n\r\n        return true;\r\n    }\r\n\r\n    // allows sending ether and receiving tokens just using contract address\r\n    // warning:\r\n    // 'If the fallback function requires more than 2300 gas, the contract cannot receive Ether'\r\n    // see:\r\n    // https://ethereum.stackexchange.com/questions/21643/fallback-function-best-practices-when-registering-information\r\n    function() public payable {\r\n        buyTokens();\r\n    }\r\n\r\n    //\r\n    function buyTokens() public payable returns (bool success){\r\n\r\n        if (saleIsRunning() && tokenPriceInWei > 0) {\r\n\r\n            uint256 numberOfTokens = msg.value / tokenPriceInWei;\r\n\r\n            if (numberOfTokens <= balanceOf[this]) {\r\n\r\n                balanceOf[msg.sender] = balanceOf[msg.sender] + numberOfTokens;\r\n                balanceOf[this] = balanceOf[this] - numberOfTokens;\r\n\r\n                NewTokensSold(numberOfTokens, msg.sender, tokenPriceInWei);\r\n\r\n                return true;\r\n            }\r\n            else {\r\n                // (payable)\r\n                revert();\r\n            }\r\n        }\r\n        else {\r\n            // (payable)\r\n            revert();\r\n        }\r\n    }\r\n\r\n    /*  After sale contract owner\r\n    *  (can be another contract or account)\r\n    *  can withdraw all collected Ether\r\n    */\r\n    function withdrawAllToOwner() public onlyBy(owner) returns (bool) {\r\n\r\n        // only after sale is finished:\r\n        require(saleIsFinished());\r\n        uint256 sumInWei = this.balance;\r\n\r\n        if (\r\n        // makes withdrawal and returns true or false\r\n        !msg.sender.send(this.balance)\r\n        ) {\r\n            return false;\r\n        }\r\n        else {\r\n            // event\r\n            Withdrawal(msg.sender, sumInWei);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /* ---------- Referral System */\r\n\r\n    // list of registered referrers\r\n    // represented by keccak256(address) (returns bytes32)\r\n    // ! referrers can not be removed !\r\n    mapping (bytes32 => bool) private isReferrer;\r\n\r\n    uint256 private referralBonus = 0;\r\n\r\n    uint256 private referrerBonus = 0;\r\n    // tokens owned by referrers:\r\n    mapping (bytes32 => uint256) public referrerBalanceOf;\r\n\r\n    mapping (bytes32 => uint) public referrerLinkedSales;\r\n\r\n    function addReferrer(bytes32 _referrer) public onlyBy(owner) returns (bool success){\r\n        isReferrer[_referrer] = true;\r\n        return true;\r\n    }\r\n\r\n    function removeReferrer(bytes32 _referrer) public onlyBy(owner) returns (bool success){\r\n        isReferrer[_referrer] = false;\r\n        return true;\r\n    }\r\n\r\n    // bonuses are set in as integers (20%, 30%), initial 0%\r\n    function setReferralBonuses(uint256 _referralBonus, uint256 _referrerBonus) public onlyBy(owner) returns (bool success){\r\n        require(_referralBonus > 0 && _referrerBonus > 0);\r\n        referralBonus = _referralBonus;\r\n        referrerBonus = _referrerBonus;\r\n        return true;\r\n    }\r\n\r\n    function buyTokensWithReferrerAddress(address _referrer) public payable returns (bool success){\r\n\r\n        bytes32 referrer = keccak256(_referrer);\r\n\r\n        if (saleIsRunning() && tokenPriceInWei > 0) {\r\n\r\n            if (isReferrer[referrer]) {\r\n\r\n                uint256 numberOfTokens = msg.value / tokenPriceInWei;\r\n\r\n                if (numberOfTokens <= balanceOf[this]) {\r\n\r\n                    referrerLinkedSales[referrer] = referrerLinkedSales[referrer] + numberOfTokens;\r\n\r\n                    uint256 referralBonusTokens = (numberOfTokens * (100 + referralBonus) / 100) - numberOfTokens;\r\n                    uint256 referrerBonusTokens = (numberOfTokens * (100 + referrerBonus) / 100) - numberOfTokens;\r\n\r\n                    balanceOf[this] = balanceOf[this] - numberOfTokens - referralBonusTokens - referrerBonusTokens;\r\n\r\n                    balanceOf[msg.sender] = balanceOf[msg.sender] + (numberOfTokens + referralBonusTokens);\r\n\r\n                    referrerBalanceOf[referrer] = referrerBalanceOf[referrer] + referrerBonusTokens;\r\n\r\n                    NewTokensSold(numberOfTokens + referralBonusTokens, msg.sender, tokenPriceInWei);\r\n\r\n                    return true;\r\n                }\r\n                else {\r\n                    // (payable)\r\n                    revert();\r\n                }\r\n            }\r\n            else {\r\n                // (payable)\r\n                buyTokens();\r\n            }\r\n        }\r\n        else {\r\n            // (payable)\r\n            revert();\r\n        }\r\n    }\r\n\r\n    event ReferrerBonusTokensTaken(address referrer, uint256 bonusTokensValue);\r\n\r\n    function getReferrerBonusTokens() public returns (bool success){\r\n        require(saleIsFinished());\r\n        uint256 bonusTokens = referrerBalanceOf[keccak256(msg.sender)];\r\n        balanceOf[msg.sender] = balanceOf[msg.sender] + bonusTokens;\r\n        ReferrerBonusTokensTaken(msg.sender, bonusTokens);\r\n        return true;\r\n    }\r\n\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"contractInitialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referrer\",\"type\":\"bytes32\"}],\"name\":\"addReferrer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referrer\",\"type\":\"bytes32\"}],\"name\":\"removeReferrer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleStartUnixTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSalesAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleIsRunning\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_priceSetter\",\"type\":\"address\"}],\"name\":\"changePriceSetter\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceSetter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPreferredTokensAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPriceInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"transferAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_priceMinWei\",\"type\":\"uint256\"},{\"name\":\"_priceMaxWei\",\"type\":\"uint256\"}],\"name\":\"setMinMaxPriceInWei\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"referrerLinkedSales\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleEndUnixTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"salesCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAllToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAllAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"buyTokensWithReferrerAddress\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"team\",\"type\":\"address\"},{\"name\":\"advisers\",\"type\":\"address\"},{\"name\":\"bounty\",\"type\":\"address\"}],\"name\":\"initContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_priceInWei\",\"type\":\"uint256\"}],\"name\":\"setTokenPriceInWei\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"referrerBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getReferrerBonusTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleIsFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"transferAllAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referralBonus\",\"type\":\"uint256\"},{\"name\":\"_referrerBonus\",\"type\":\"uint256\"}],\"name\":\"setReferralBonuses\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startUnixTime\",\"type\":\"uint256\"},{\"name\":\"_endUnixTime\",\"type\":\"uint256\"}],\"name\":\"startSale\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newTokenPriceInWei\",\"type\":\"uint256\"}],\"name\":\"PriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"startUnixTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endUnixTime\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"saleNumber\",\"type\":\"uint256\"}],\"name\":\"SaleStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"numberOfTokens\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"purchasedBy\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"priceInWei\",\"type\":\"uint256\"}],\"name\":\"NewTokensSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sumInWei\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_toContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"DataSentToAnotherContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"bonusTokensValue\",\"type\":\"uint256\"}],\"name\":\"ReferrerBonusTokensTaken\",\"type\":\"event\"}]", "ContractName": "DEEX", "CompilerVersion": "v0.4.15+commit.bbb8e64f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://b3bc60739f58c8f425c79647d2af7493c578cc19633611a33f4bc7917b51cf43"}