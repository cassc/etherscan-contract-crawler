{"SourceCode": "// bet.etf.live\r\n\r\npragma solidity 0.8.21;\r\n\r\n// SPDX-License-Identifier: Unlicensed\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastValue = set._values[lastIndex];\r\n\r\n                // Move the last value to the index where the value to delete is\r\n                set._values[toDeleteIndex] = lastValue;\r\n                // Update the index for the moved value\r\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\r\n            }\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index)\r\n        private\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return set._values[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function _values(Set storage set) private view returns (bytes32[] memory) {\r\n        return set._values;\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32Set storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(Bytes32Set storage set)\r\n        internal\r\n        view\r\n        returns (bytes32[] memory)\r\n    {\r\n        bytes32[] memory store = _values(set._inner);\r\n        bytes32[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(AddressSet storage set)\r\n        internal\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        bytes32[] memory store = _values(set._inner);\r\n        address[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(UintSet storage set)\r\n        internal\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        bytes32[] memory store = _values(set._inner);\r\n        uint256[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() external virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract BetETFPools is Ownable, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    using EnumerableSet for EnumerableSet.UintSet;\r\n    using EnumerableSet for EnumerableSet.Bytes32Set;\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n    address public betToken; // $ETF to be used for betting\r\n    address public bonusToken; // bonus rewards token (ETH/ETF LP)\r\n\r\n    EnumerableSet.UintSet private activeBets;\r\n    EnumerableSet.UintSet private settledBets;\r\n    mapping(address => uint256) public amountWonByAccount;\r\n    mapping(address => EnumerableSet.UintSet) private accountBetsPending;\r\n    mapping(uint256 => BetInfo) private betInformation;\r\n\r\n    address public feeReceiver;\r\n    uint256 public feePercent = 420; // accounting for 4.2% transfer tax, to be removed at later date\r\n\r\n    uint256 public totalPaidOut;\r\n\r\n    struct Player {\r\n        uint256 outcomeSelected;\r\n        uint256 amountBet;\r\n    }\r\n\r\n    struct BetInfo {\r\n        string description;\r\n        uint256 deadline;\r\n        uint256 outcomeABets;\r\n        uint256 outcomeBBets;\r\n        mapping(address => Player) players;\r\n        uint256 totalPayout;\r\n        uint256 outcome;\r\n        bool active;\r\n    }\r\n\r\n    event BetCreated(\r\n        uint256 indexed betId,\r\n        uint256 indexed deadline\r\n    );\r\n\r\n    event PlayerBet(\r\n        uint256 indexed betId,\r\n        address indexed walletAddress,\r\n        uint256 indexed outcome,\r\n        uint256 amount\r\n    );\r\n\r\n    event DeadlineUpdated(\r\n        uint256 indexed betID,\r\n        uint256 indexed deadline\r\n    );\r\n\r\n    event BetSettled(\r\n        uint256 indexed betId,\r\n        uint256 indexed outcome\r\n    );\r\n\r\n    event PaidOutTokens(address token, address indexed player, uint256 amount);\r\n\r\n    constructor() {\r\n        feeReceiver = msg.sender;\r\n    }\r\n\r\n    function setFeeReceiver(address _feeReceiver) external onlyOwner {\r\n        feeReceiver = _feeReceiver;\r\n    }\r\n    \r\n    function setBetToken(address _betToken) external onlyOwner {\r\n        betToken = _betToken;\r\n    }\r\n    function setBonusToken(address _bonusToken) external onlyOwner {\r\n        bonusToken = _bonusToken;\r\n    }\r\n\r\n    function setFee(uint256 newFee) external onlyOwner {\r\n        require(newFee < 1000, \"Cannot be more than 10%\");\r\n        feePercent = newFee;\r\n    }\r\n\r\n    function placeBet(uint256 betId, uint256 outcomeSelection, uint256 amount) external nonReentrant {\r\n        require(msg.sender == tx.origin, \"Contracts cannot play\");\r\n        require(IERC20(betToken).balanceOf(msg.sender) >= amount, \"You don't have enough tokens\");\r\n        BetInfo storage betInfo = betInformation[betId];\r\n        require(amount >= 0 ether, \"Cannot bet 0\");\r\n        require(\r\n            betInfo.deadline > block.timestamp,\r\n            \"betting closed\"\r\n        );\r\n        Player storage player = betInfo.players[msg.sender];\r\n        require(\r\n            player.outcomeSelected == 0,\r\n            \"Can only bet once per pool\"\r\n        );\r\n        require(\r\n            outcomeSelection <= 2 && outcomeSelection != 0,\r\n            \"Can only select outcome 1 or 2\"\r\n        );\r\n \r\n        uint256 amountForBet = amount;\r\n\r\n        // handle fees\r\n        if (feePercent > 0) {\r\n            uint256 amountForFee = (amount * feePercent) / 10000;\r\n            IERC20(betToken).transferFrom(msg.sender, feeReceiver, amountForFee);\r\n            amountForBet -= amountForFee;\r\n        }\r\n\r\n        IERC20(betToken).transferFrom(msg.sender, address(this), amountForBet);\r\n\r\n        player.outcomeSelected = outcomeSelection;\r\n        player.amountBet = amountForBet;\r\n        accountBetsPending[msg.sender].add(betId);\r\n        betInfo.totalPayout += amountForBet;\r\n\r\n        if (outcomeSelection == 1) {\r\n            betInfo.outcomeABets += amountForBet;\r\n        } else if (outcomeSelection == 2) {\r\n            betInfo.outcomeBBets += amountForBet;\r\n        }\r\n        emit PlayerBet(betId, msg.sender, outcomeSelection, amountForBet);\r\n    }\r\n\r\n    function createPool(\r\n        uint256 betId, \r\n        uint256 deadline\r\n        ) external onlyOwner {\r\n        require(!activeBets.contains(betId), \"pool already created\");\r\n        require(deadline > block.timestamp, \"deadline must be in future\");\r\n        activeBets.add(betId);\r\n        BetInfo storage betInfo = betInformation[betId];\r\n        betInfo.active = true;\r\n        betInfo.deadline = deadline;\r\n        emit BetCreated(betId, deadline);\r\n    }\r\n\r\n    function updateDeadline(uint256 betId, uint256 newDeadline) external onlyOwner {\r\n        require(activeBets.contains(betId), \"not an active pool\");\r\n        require(newDeadline > block.timestamp, \"deadline must be in future\");       \r\n        BetInfo storage betInfo = betInformation[betId];\r\n\r\n        betInfo.deadline = newDeadline;\r\n        emit DeadlineUpdated(betId, newDeadline);\r\n    }\r\n\r\n    function setOutcome(uint256 betId, uint256 outcome) external onlyOwner {\r\n        BetInfo storage betInfo = betInformation[betId];\r\n        require(activeBets.contains(betId), \"outcome already set\");\r\n        require(\r\n            outcome <= 3 && outcome != 0,\r\n            \"Can only select outcome A or B, or cancelled\"\r\n        );\r\n\r\n        betInfo.outcome = outcome;\r\n\r\n        uint256 shares;\r\n        if (betInfo.outcome == 1) {\r\n            shares = betInfo.outcomeABets;\r\n        } else if (betInfo.outcome == 2) {\r\n            shares = betInfo.outcomeBBets;\r\n        } else if (betInfo.outcome == 3) {\r\n            shares = betInfo.totalPayout;\r\n        }\r\n\r\n        activeBets.remove(betId);\r\n        settledBets.add(betId);\r\n        betInfo.active = false;\r\n        emit BetSettled(betId, outcome);\r\n    }\r\n\r\n    function claimWinnings(uint256 betId) external nonReentrant {\r\n        require(msg.sender == tx.origin, \"Contracts cannot play\");\r\n        BetInfo storage betInfo = betInformation[betId];\r\n        Player storage player = betInfo.players[msg.sender];\r\n        if (\r\n            settledBets.contains(betId) &&\r\n            accountBetsPending[msg.sender].contains(betId)\r\n        ) {\r\n            accountBetsPending[msg.sender].remove(betId);\r\n\r\n            if (player.outcomeSelected == betInfo.outcome) {\r\n                uint256 shares;\r\n                if (betInfo.outcome == 1) {\r\n                    shares = betInfo.outcomeABets;\r\n                } else if (betInfo.outcome == 2) {\r\n                    shares = betInfo.outcomeBBets;\r\n                } \r\n                uint256 amountForPayout = (player.amountBet *\r\n                    betInfo.totalPayout) / shares;\r\n                \r\n                if (amountForPayout > 0) {\r\n                    IERC20(betToken).transfer(msg.sender, amountForPayout);\r\n                    amountWonByAccount[msg.sender] += amountForPayout;\r\n                    totalPaidOut = totalPaidOut.add(amountForPayout);\r\n                    emit PaidOutTokens(betToken, msg.sender, amountForPayout);\r\n                    uint256 bonusRewardsBalance = IERC20(bonusToken).balanceOf(address(this));\r\n                    if (bonusRewardsBalance > 0) {\r\n                        uint256 bonusShares = (amountForPayout * bonusRewardsBalance) / betInfo.totalPayout;\r\n                        IERC20(bonusToken).transfer(msg.sender, bonusShares);\r\n                    }\r\n                }\r\n\r\n            } else if (betInfo.outcome == 3 && player.amountBet > 0) {\r\n                IERC20(betToken).transfer(msg.sender, player.amountBet);\r\n                amountWonByAccount[msg.sender] += player.amountBet;\r\n            }\r\n        }   \r\n    }\r\n\r\n    function getAmountClaimableByBetId(uint256 betId, address account) public view returns (uint256) {\r\n        BetInfo storage betInfo = betInformation[betId];\r\n        Player storage player = betInfo.players[account];\r\n        uint256 amountForPayout;\r\n        if (\r\n            settledBets.contains(betId) &&\r\n            accountBetsPending[account].contains(betId)\r\n        ) {\r\n            uint256 shares;\r\n\r\n            if (player.outcomeSelected == betInfo.outcome) {\r\n\r\n                if (betInfo.outcome == 1) {\r\n                    shares = betInfo.outcomeABets;\r\n                } else if (betInfo.outcome == 2) {\r\n                    shares = betInfo.outcomeBBets;\r\n                amountForPayout = (player.amountBet *\r\n                    betInfo.totalPayout) / shares;\r\n                }\r\n            } else if (betInfo.outcome == 3) {\r\n                amountForPayout = player.amountBet;\r\n            }\r\n        }\r\n        return amountForPayout;\r\n    }\r\n\r\n    function getAmountTotalClaimable(address account) public view returns (uint256) {\r\n        uint256[] memory betIds = accountBetsPending[account].values();\r\n        uint256 amountForPayout;\r\n        for (uint256 i = 0; i < betIds.length; i++) {\r\n            BetInfo storage betInfo = betInformation[betIds[i]];\r\n            Player storage player = betInfo.players[account];\r\n            if (\r\n                settledBets.contains(betIds[i]) &&\r\n                accountBetsPending[account].contains(betIds[i])\r\n            ) {\r\n                uint256 shares;\r\n\r\n                if (betInfo.outcome == 1) {\r\n                    shares = betInfo.outcomeABets;\r\n                } else if (betInfo.outcome == 2) {\r\n                    shares = betInfo.outcomeBBets;\r\n                } \r\n                if (player.outcomeSelected == betInfo.outcome) {\r\n                    amountForPayout +=\r\n                        (player.amountBet * betInfo.totalPayout) /\r\n                        shares;\r\n                } else if (betInfo.outcome == 3) {\r\n                    amountForPayout += player.amountBet;\r\n                }\r\n            }\r\n        }\r\n        return amountForPayout;\r\n    }\r\n\r\n    function getBetInfo(uint256 betId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 deadline,\r\n            uint256 outcomeA,\r\n            uint256 outcomeB,\r\n            uint256 totalPayout,\r\n            bool active,\r\n            uint256 outcome\r\n        )\r\n    {\r\n        BetInfo storage betInfo = betInformation[betId];\r\n\r\n        deadline = betInfo.deadline;\r\n        outcomeA = betInfo.outcomeABets;\r\n        outcomeB = betInfo.outcomeBBets;\r\n        totalPayout = betInfo.totalPayout;\r\n        active = betInfo.active;\r\n        outcome = betInfo.outcome;\r\n    }\r\n\r\n    function getPlayerInfoByBetId(uint256 betId, address account)\r\n        external\r\n        view\r\n        returns (uint256 amountBet, uint256 outcomeSelected)\r\n    {\r\n        BetInfo storage betInfo = betInformation[betId];\r\n        Player storage player = betInfo.players[account];\r\n        amountBet = player.amountBet;\r\n        outcomeSelected = player.outcomeSelected;\r\n    }\r\n\r\n    function getActiveBets() external view returns (uint256[] memory) {\r\n        return activeBets.values();\r\n    }\r\n\r\n    function getInactiveBets() external view returns (uint256[] memory) {\r\n        return settledBets.values();\r\n    }\r\n\r\n    function getAccountBetsPending(address account)\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        return accountBetsPending[account].values();\r\n    }\r\n\r\n    function withdrawStuckTokens(uint256 amountToWithdraw, address tokenAddress) external onlyOwner {\r\n        IERC20(tokenAddress).transfer(msg.sender, amountToWithdraw);\r\n    }\r\n\r\n    function withdrawEth() external onlyOwner {\r\n        uint256 ethBalance = address(this).balance;\r\n        if (ethBalance > 0) {\r\n        payable(msg.sender).transfer(ethBalance);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"BetCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"outcome\",\"type\":\"uint256\"}],\"name\":\"BetSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"betID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"DeadlineUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaidOutTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"outcome\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PlayerBet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"amountWonByAccount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"betToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bonusToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"claimWinnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"createPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountBetsPending\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActiveBets\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAmountClaimableByBetId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAmountTotalClaimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"getBetInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outcomeA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outcomeB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPayout\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"outcome\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInactiveBets\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getPlayerInfoByBetId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountBet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outcomeSelected\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outcomeSelection\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"placeBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_betToken\",\"type\":\"address\"}],\"name\":\"setBetToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bonusToken\",\"type\":\"address\"}],\"name\":\"setBonusToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outcome\",\"type\":\"uint256\"}],\"name\":\"setOutcome\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPaidOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newDeadline\",\"type\":\"uint256\"}],\"name\":\"updateDeadline\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"withdrawStuckTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BetETFPools", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://464645bc9f5798a25ed5cd467370a5d89774e81552b2e04c7604a17e294654e4"}