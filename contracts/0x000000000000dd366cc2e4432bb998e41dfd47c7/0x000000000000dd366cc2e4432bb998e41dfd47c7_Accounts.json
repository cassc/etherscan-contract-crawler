{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Accounts.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport {ERC4337Factory} from \\\"@solady/src/accounts/ERC4337Factory.sol\\\";\\n\\n/// @notice Simple extendable smart account factory implementation.\\n/// @author nani.eth (https://github.com/NaniDAO/accounts/blob/main/src/Accounts.sol)\\ncontract Accounts is ERC4337Factory {\\n    /// @dev Holds an immutable owner.\\n    address internal immutable _OWNER;\\n\\n    /// @dev Constructs this factory to deploy the implementation.\\n    /// Additionally, sets owner account for peripheral concerns.\\n    constructor(address erc4337) payable ERC4337Factory(erc4337) {\\n        _OWNER = createAccount(tx.origin, bytes32(0));\\n    }\\n\\n    /// @dev Tracks mappings of selectors to executors the owner has delegated to.\\n    function get(bytes4 selector) public view virtual returns (address executor) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            executor := sload(selector)\\n        }\\n    }\\n\\n    /// @dev Delegates peripheral call concerns. Can only be called by owner.\\n    function set(bytes4 selector, address executor) public payable virtual {\\n        assert(msg.sender == _OWNER);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            sstore(selector, executor)\\n        }\\n    }\\n\\n    /// @dev Falls back to delegated calls.\\n    fallback() external payable {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            calldatacopy(0x00, 0x00, calldatasize())\\n            // Forwards the calldata to `executor` via delegatecall.\\n            if iszero(\\n                delegatecall(\\n                    gas(),\\n                    /*executor*/\\n                    sload( /*selector*/ shl(224, shr(224, calldataload(0)))),\\n                    0x00,\\n                    calldatasize(),\\n                    codesize(),\\n                    0x00\\n                )\\n            ) {\\n                // Bubble up the revert if the call reverts.\\n                returndatacopy(0x00, 0x00, returndatasize())\\n                revert(0x00, returndatasize())\\n            }\\n            // Copy and return data from successful call.\\n            returndatacopy(0x00, 0x00, returndatasize())\\n            return(0x00, returndatasize())\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/accounts/ERC4337Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {LibClone} from \\\"../utils/LibClone.sol\\\";\\n\\n/// @notice Simple ERC4337 account factory implementation.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/ERC4337Factory.sol)\\n///\\n/// Note:\\n/// - Unlike the ERC1967Factory, this factory does NOT store any admin info on the factory itself.\\n///   The deployed ERC4337 accounts are minimal ERC1967 proxies to an ERC4337 implementation.\\n///   The proxy bytecode does NOT contain any upgrading logic.\\n/// - This factory does NOT contain any logic for upgrading the ERC4337 accounts.\\n///   Upgrading must be done via UUPS logic on the accounts themselves.\\n/// - The ERC4337 standard expects the factory to use deterministic deployment.\\n///   As such, this factory does not include any non-deterministic deployment methods.\\ncontract ERC4337Factory {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         IMMUTABLES                         */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Address of the ERC4337 implementation.\\n    address public immutable implementation;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        CONSTRUCTOR                         */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    constructor(address erc4337) payable {\\n        implementation = erc4337;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      DEPLOY FUNCTIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Deploys an ERC4337 account with `salt` and returns its deterministic address.\\n    /// If the account is already deployed, it will simply return its address.\\n    /// Any `msg.value` will simply be forwarded to the account, regardless.\\n    function createAccount(address owner, bytes32 salt) public payable virtual returns (address) {\\n        // Check that the salt is tied to the owner if required, regardless.\\n        LibClone.checkStartsWith(salt, owner);\\n        // Constructor data is optional, and is omitted for easier Etherscan verification.\\n        (bool alreadyDeployed, address account) =\\n            LibClone.createDeterministicERC1967(msg.value, implementation, salt);\\n\\n        if (!alreadyDeployed) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                mstore(0x14, owner) // Store the `owner` argument.\\n                mstore(0x00, 0xc4d66de8000000000000000000000000) // `initialize(address)`.\\n                if iszero(call(gas(), account, 0, 0x10, 0x24, codesize(), 0x00)) {\\n                    returndatacopy(mload(0x40), 0x00, returndatasize())\\n                    revert(mload(0x40), returndatasize())\\n                }\\n            }\\n        }\\n        return account;\\n    }\\n\\n    /// @dev Returns the deterministic address of the account created via `createAccount`.\\n    function getAddress(bytes32 salt) public view virtual returns (address) {\\n        return LibClone.predictDeterministicAddressERC1967(implementation, salt, address(this));\\n    }\\n\\n    /// @dev Returns the initialization code hash of the ERC4337 account (a minimal ERC1967 proxy).\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash() public view virtual returns (bytes32) {\\n        return LibClone.initCodeHashERC1967(implementation);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/LibClone.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Minimal proxy library.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\\n/// @author Minimal proxy by 0age (https://github.com/0age)\\n/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie\\n/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\\n/// @author Minimal ERC1967 proxy by jtriley-eth (https://github.com/jtriley-eth/minimum-viable-proxy)\\n///\\n/// @dev Minimal proxy:\\n/// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,\\n/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,\\n/// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.\\n///\\n/// @dev Minimal proxy (PUSH0 variant):\\n/// This is a new minimal proxy that uses the PUSH0 opcode introduced during Shanghai.\\n/// It is optimized first for minimal runtime gas, then for minimal bytecode.\\n/// The PUSH0 clone functions are intentionally postfixed with a jarring \\\"_PUSH0\\\" as\\n/// many EVM chains may not support the PUSH0 opcode in the early months after Shanghai.\\n/// Please use with caution.\\n///\\n/// @dev Clones with immutable args (CWIA):\\n/// The implementation of CWIA here implements a `receive()` method that emits the\\n/// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,\\n/// enabling us to accept hard gas-capped `sends` & `transfers` for maximum backwards\\n/// composability. The minimal proxy implementation does not offer this feature.\\n///\\n/// @dev Minimal ERC1967 proxy:\\n/// An minimal ERC1967 proxy, intended to be upgraded with UUPS.\\n/// This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\\nlibrary LibClone {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Unable to deploy the clone.\\n    error DeploymentFailed();\\n\\n    /// @dev The salt must start with either the zero address or `by`.\\n    error SaltDoesNotStartWith();\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  MINIMAL PROXY OPERATIONS                  */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Deploys a clone of `implementation`.\\n    function clone(address implementation) internal returns (address instance) {\\n        instance = clone(0, implementation);\\n    }\\n\\n    /// @dev Deploys a clone of `implementation`.\\n    function clone(uint256 value, address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * --------------------------------------------------------------------------+\\n             * CREATION (9 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\\n             * --------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize     | r         |                              |\\n             * 3d         | RETURNDATASIZE    | 0 r       |                              |\\n             * 81         | DUP2              | r 0 r     |                              |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\\n             * --------------------------------------------------------------------------|\\n             * RUNTIME (44 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\\n             * --------------------------------------------------------------------------|\\n             *                                                                           |\\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | 0                      |                       |\\n             * 3d      | RETURNDATASIZE | 0 0                    |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\\n             *                                                                           |\\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\\n             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\\n             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\\n             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\\n             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\\n             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\\n             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\\n             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\\n             *                                                                           |\\n             * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |\\n             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * fd      | REVERT         |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\\n             * f3      | RETURN         |                        | [0..rds): returndata  |\\n             * --------------------------------------------------------------------------+\\n             */\\n\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            instance := create(value, 0x0c, 0x35)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\\n    function cloneDeterministic(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = cloneDeterministic(0, implementation, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\\n    function cloneDeterministic(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            instance := create2(value, 0x0c, 0x35, salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the clone of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            hash := keccak256(0x0c, 0x35)\\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic clone of `implementation`,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)\\n        internal\\n        pure\\n        returns (address predicted)\\n    {\\n        bytes32 hash = initCodeHash(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*          MINIMAL PROXY OPERATIONS (PUSH0 VARIANT)          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Deploys a PUSH0 clone of `implementation`.\\n    function clone_PUSH0(address implementation) internal returns (address instance) {\\n        instance = clone_PUSH0(0, implementation);\\n    }\\n\\n    /// @dev Deploys a PUSH0 clone of `implementation`.\\n    function clone_PUSH0(uint256 value, address implementation)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * --------------------------------------------------------------------------+\\n             * CREATION (9 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\\n             * --------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize     | r         |                              |\\n             * 5f         | PUSH0             | 0 r       |                              |\\n             * 81         | DUP2              | r 0 r     |                              |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\\n             * 5f         | PUSH0             | 0 o r 0 r |                              |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\\n             * --------------------------------------------------------------------------|\\n             * RUNTIME (45 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\\n             * --------------------------------------------------------------------------|\\n             *                                                                           |\\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5f      | PUSH0          | 0                      |                       |\\n             * 5f      | PUSH0          | 0 0                    |                       |\\n             *                                                                           |\\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0                |                       |\\n             * 5f      | PUSH0          | 0 cds 0 0              |                       |\\n             * 5f      | PUSH0          | 0 0 cds 0 0            |                       |\\n             * 37      | CALLDATACOPY   | 0 0                    | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0                | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 cds 0 0              | [0..cds): calldata    |\\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0         | [0..cds): calldata    |\\n             * 5a      | GAS            | gas addr 0 cds 0 0     | [0..cds): calldata    |\\n             * f4      | DELEGATECALL   | success                | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds success            | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 rds success          | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 0 rds success        | [0..cds): calldata    |\\n             * 3e      | RETURNDATACOPY | success                | [0..rds): returndata  |\\n             *                                                                           |\\n             * 60 0x29 | PUSH1 0x29     | 0x29 success           | [0..rds): returndata  |\\n             * 57      | JUMPI          |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\\n             * fd      | REVERT         |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b      | JUMPDEST       |                        | [0..rds): returndata  |\\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\\n             * f3      | RETURN         |                        | [0..rds): returndata  |\\n             * --------------------------------------------------------------------------+\\n             */\\n\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            instance := create(value, 0x0e, 0x36)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\\n    function cloneDeterministic_PUSH0(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = cloneDeterministic_PUSH0(0, implementation, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\\n    function cloneDeterministic_PUSH0(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            instance := create2(value, 0x0e, 0x36, salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the PUSH0 clone of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash_PUSH0(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            hash := keccak256(0x0e, 0x36)\\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic PUSH0 clone of `implementation`,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress_PUSH0(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHash_PUSH0(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*           CLONES WITH IMMUTABLE ARGS OPERATIONS            */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // Note: This implementation of CWIA differs from the original implementation.\\n    // If the calldata is empty, it will emit a `ReceiveETH(uint256)` event and skip the `DELEGATECALL`.\\n\\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.\\n    function clone(address implementation, bytes memory data) internal returns (address instance) {\\n        instance = clone(0, implementation, data);\\n    }\\n\\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.\\n    function clone(uint256 value, address implementation, bytes memory data)\\n        internal\\n        returns (address instance)\\n    {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n            // The `creationSize` is `extraLength + 108`\\n            // The `runSize` is `creationSize - 10`.\\n\\n            /**\\n             * ---------------------------------------------------------------------------------------------------+\\n             * CREATION (10 bytes)                                                                                |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                                                |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * 61 runSize | PUSH2 runSize     | r         |                                                       |\\n             * 3d         | RETURNDATASIZE    | 0 r       |                                                       |\\n             * 81         | DUP2              | r 0 r     |                                                       |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                                                       |\\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                                                       |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code                            |\\n             * f3         | RETURN            |           | [0..runSize): runtime code                            |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * RUNTIME (98 bytes + extraLength)                                                                   |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * Opcode   | Mnemonic       | Stack                    | Memory                                      |\\n             * ---------------------------------------------------------------------------------------------------|\\n             *                                                                                                    |\\n             * ::: if no calldata, emit event & return w/o `DELEGATECALL` ::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds                      |                                             |\\n             * 60 0x2c  | PUSH1 0x2c     | 0x2c cds                 |                                             |\\n             * 57       | JUMPI          |                          |                                             |\\n             * 34       | CALLVALUE      | cv                       |                                             |\\n             * 3d       | RETURNDATASIZE | 0 cv                     |                                             |\\n             * 52       | MSTORE         |                          | [0..0x20): callvalue                        |\\n             * 7f sig   | PUSH32 0x9e..  | sig                      | [0..0x20): callvalue                        |\\n             * 59       | MSIZE          | 0x20 sig                 | [0..0x20): callvalue                        |\\n             * 3d       | RETURNDATASIZE | 0 0x20 sig               | [0..0x20): callvalue                        |\\n             * a1       | LOG1           |                          | [0..0x20): callvalue                        |\\n             * 00       | STOP           |                          | [0..0x20): callvalue                        |\\n             * 5b       | JUMPDEST       |                          |                                             |\\n             *                                                                                                    |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds                      |                                             |\\n             * 3d       | RETURNDATASIZE | 0 cds                    |                                             |\\n             * 3d       | RETURNDATASIZE | 0 0 cds                  |                                             |\\n             * 37       | CALLDATACOPY   |                          | [0..cds): calldata                          |\\n             *                                                                                                    |\\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d       | RETURNDATASIZE | 0                        | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0                      | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0 0                    | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0 0 0                  | [0..cds): calldata                          |\\n             * 61 extra | PUSH2 extra    | e 0 0 0 0                | [0..cds): calldata                          |\\n             *                                                                                                    |\\n             * ::: copy extra data to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 80       | DUP1           | e e 0 0 0 0              | [0..cds): calldata                          |\\n             * 60 0x62  | PUSH1 0x62     | 0x62 e e 0 0 0 0         | [0..cds): calldata                          |\\n             * 36       | CALLDATASIZE   | cds 0x62 e e 0 0 0 0     | [0..cds): calldata                          |\\n             * 39       | CODECOPY       | e 0 0 0 0                | [0..cds): calldata, [cds..cds+e): extraData |\\n             *                                                                                                    |\\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 01       | ADD            | cds+e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3d       | RETURNDATASIZE | 0 cds+e 0 0 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 73 addr  | PUSH20 addr    | addr 0 cds+e 0 0 0 0     | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 5a       | GAS            | gas addr 0 cds+e 0 0 0 0 | [0..cds): calldata, [cds..cds+e): extraData |\\n             * f4       | DELEGATECALL   | success 0 0              | [0..cds): calldata, [cds..cds+e): extraData |\\n             *                                                                                                    |\\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d       | RETURNDATASIZE | rds success 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3d       | RETURNDATASIZE | rds rds success 0 0      | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 93       | SWAP4          | 0 rds success 0 rds      | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 80       | DUP1           | 0 0 rds success 0 rds    | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3e       | RETURNDATACOPY | success 0 rds            | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * 60 0x60  | PUSH1 0x60     | 0x60 success 0 rds       | [0..rds): returndata                        |\\n             * 57       | JUMPI          | 0 rds                    | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * fd       | REVERT         |                          | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b       | JUMPDEST       | 0 rds                    | [0..rds): returndata                        |\\n             * f3       | RETURN         |                          | [0..rds): returndata                        |\\n             * ---------------------------------------------------------------------------------------------------+\\n             */\\n\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\\n                // The actual EVM limit may be smaller and may change over time.\\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            instance := create(value, sub(data, 0x4c), add(extraLength, 0x6c))\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation`\\n    /// with immutable arguments encoded in `data` and `salt`.\\n    function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = cloneDeterministic(0, implementation, data, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation`\\n    /// with immutable arguments encoded in `data` and `salt`.\\n    function cloneDeterministic(\\n        uint256 value,\\n        address implementation,\\n        bytes memory data,\\n        bytes32 salt\\n    ) internal returns (address instance) {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\\n                // The actual EVM limit may be smaller and may change over time.\\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            instance := create2(value, sub(data, 0x4c), add(extraLength, 0x6c), salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the clone of `implementation`\\n    /// using immutable arguments encoded in `data`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash(address implementation, bytes memory data)\\n        internal\\n        pure\\n        returns (bytes32 hash)\\n    {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.\\n            // The actual EVM limit may be smaller and may change over time.\\n            returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                sub(data, 0x5a),\\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic clone of\\n    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes memory data,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHash(implementation, data);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*              MINIMAL ERC1967 PROXY OPERATIONS              */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // Note: The ERC1967 proxy here is intended to be upgraded with UUPS.\\n    // This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\\n\\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\\n    function deployERC1967(address implementation) internal returns (address instance) {\\n        instance = deployERC1967(0, implementation);\\n    }\\n\\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\\n    function deployERC1967(uint256 value, address implementation)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * ---------------------------------------------------------------------------------+\\n             * CREATION (34 bytes)                                                              |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\\n             * 81         | DUP2           | r 0 r            |                                 |\\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\\n             * ---------------------------------------------------------------------------------|\\n             * RUNTIME (62 bytes)                                                               |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             *                                                                                  |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36         | CALLDATASIZE   | cds              |                                 |\\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | 0                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 60 0x38    | PUSH1 0x38     | dest succ        | [0..returndatasize): returndata |\\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\\n             * ---------------------------------------------------------------------------------+\\n             */\\n\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\\n            mstore(0x20, 0x6009)\\n            mstore(0x1e, implementation)\\n            mstore(0x0a, 0x603d3d8160223d3973)\\n            instance := create(value, 0x21, 0x5f)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\\n    function deployDeterministicERC1967(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = deployDeterministicERC1967(0, implementation, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\\n    function deployDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\\n            mstore(0x20, 0x6009)\\n            mstore(0x1e, implementation)\\n            mstore(0x0a, 0x603d3d8160223d3973)\\n            instance := create2(value, 0x21, 0x5f, salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967(address implementation, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        return createDeterministicERC1967(0, implementation, salt);\\n    }\\n\\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\\n            mstore(0x20, 0x6009)\\n            mstore(0x1e, implementation)\\n            mstore(0x0a, 0x603d3d8160223d3973)\\n            // Compute and store the bytecode hash.\\n            mstore(add(m, 0x35), keccak256(0x21, 0x5f))\\n            mstore(m, shl(88, address()))\\n            mstore8(m, 0xff) // Write the prefix.\\n            mstore(add(m, 0x15), salt)\\n            instance := keccak256(m, 0x55)\\n            for {} 1 {} {\\n                if iszero(extcodesize(instance)) {\\n                    instance := create2(value, 0x21, 0x5f, salt)\\n                    if iszero(instance) {\\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    break\\n                }\\n                alreadyDeployed := 1\\n                if iszero(value) { break }\\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                break\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the clone of `implementation`\\n    /// using immutable arguments encoded in `data`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHashERC1967(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\\n            mstore(0x20, 0x6009)\\n            mstore(0x1e, implementation)\\n            mstore(0x0a, 0x603d3d8160223d3973)\\n            hash := keccak256(0x21, 0x5f)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic clone of\\n    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddressERC1967(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHashERC1967(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      OTHER OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the address when a contract with initialization code hash,\\n    /// `hash`, is deployed with `salt`, by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\\n        internal\\n        pure\\n        returns (address predicted)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and store the bytecode hash.\\n            mstore8(0x00, 0xff) // Write the prefix.\\n            mstore(0x35, hash)\\n            mstore(0x01, shl(96, deployer))\\n            mstore(0x15, salt)\\n            predicted := keccak256(0x00, 0x55)\\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Requires that `salt` starts with either the zero address or `by`.\\n    function checkStartsWith(bytes32 salt, address by) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the salt does not start with the zero address or `by`.\\n            if iszero(or(iszero(shr(96, salt)), eq(shr(96, shl(96, by)), shr(96, salt)))) {\\n                mstore(0x00, 0x0c4549ef) // `SaltDoesNotStartWith()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@solady/=lib/solady/\",\r\n      \"@forge/=lib/forge-std/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solady/=lib/solady/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999999\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc4337\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"createAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"get\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"getAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initCodeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "Accounts", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "9999999", "ConstructorArguments": "0000000000000000000000000000000000001c05075915622130c16f6febc541", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}