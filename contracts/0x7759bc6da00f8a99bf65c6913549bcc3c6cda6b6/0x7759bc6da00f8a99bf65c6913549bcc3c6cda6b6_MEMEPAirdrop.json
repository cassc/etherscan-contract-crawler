{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MemeP.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\r\\n//\\r\\n// https://twitter.com/meme_printer69\\r\\n// https://t.me/thememeprinter\\r\\n// https://www.memeprinter.xyz/\\r\\n\\r\\npragma solidity 0.8.19;\\r\\n\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n}\\r\\n/**\\r\\n * ERC20 standard interface.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function decimals() external view returns (uint8);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function name() external view returns (string memory);\\r\\n    function getOwner() external view returns (address);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address _owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\n/**\\r\\n * Allows for contract ownership along with multi-address authorization\\r\\n */\\r\\nabstract contract Auth {\\r\\n    address internal owner;\\r\\n\\r\\n    constructor(address _owner) {\\r\\n        owner = _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Function modifier to require caller to be contract deployer\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(msg.sender), \\\"!Owner\\\"); _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Check if address is owner\\r\\n     */\\r\\n    function isOwner(address account) public view returns (bool) {\\r\\n        return account == owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Transfer ownership to new address. Caller must be deployer. Leaves old deployer authorized\\r\\n     */\\r\\n    function transferOwnership(address payable adr) public onlyOwner {\\r\\n        owner = adr;\\r\\n        emit OwnershipTransferred(adr);\\r\\n    }\\r\\n\\r\\n    event OwnershipTransferred(address owner);\\r\\n}\\r\\n\\r\\ninterface IDEXFactory {\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n}\\r\\n\\r\\ninterface IDEXRouter {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n\\r\\ninterface IDividendDistributor {\\r\\n    function setShare(address shareholder, uint256 amount) external;\\r\\n    function deposit(uint256 amount) external;\\r\\n    function claimDividend(address shareholder) external;\\r\\n    function getDividendsClaimedOf (address shareholder) external returns (uint256);\\r\\n}\\r\\n\\r\\ncontract DividendDistributor is IDividendDistributor {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    address public _token;\\r\\n    address public _owner;\\r\\n\\r\\n    address public immutable TOKEN = address(0xb131f4A55907B10d1F0A50d8ab8FA09EC342cd74); //UNI TO CHANGE ADD MEME ADDR\\r\\n\\r\\n\\r\\n    struct Share {\\r\\n        uint256 amount;\\r\\n        uint256 totalExcluded;\\r\\n        uint256 totalClaimed;\\r\\n    }\\r\\n\\r\\n    address[] private shareholders;\\r\\n    mapping (address => uint256) private shareholderIndexes;\\r\\n\\r\\n    mapping (address => Share) public shares;\\r\\n\\r\\n    uint256 public totalShares;\\r\\n    uint256 public totalDividends;\\r\\n    uint256 public totalClaimed;\\r\\n    uint256 public dividendsPerShare;\\r\\n    uint256 private dividendsPerShareAccuracyFactor = 10 ** 36;\\r\\n\\r\\n    modifier onlyToken() {\\r\\n        require(msg.sender == _token); _;\\r\\n    }\\r\\n    \\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == _owner); _;\\r\\n    }\\r\\n\\r\\n    constructor (address owner) {\\r\\n        _token = msg.sender;\\r\\n        _owner = owner;\\r\\n    }\\r\\n\\r\\n    receive() external payable { }\\r\\n\\r\\n    function setShare(address shareholder, uint256 amount) external override onlyToken {\\r\\n        if(shares[shareholder].amount > 0){\\r\\n            distributeDividend(shareholder);\\r\\n        }\\r\\n\\r\\n        if(amount > 0 && shares[shareholder].amount == 0){\\r\\n            addShareholder(shareholder);\\r\\n        }else if(amount == 0 && shares[shareholder].amount > 0){\\r\\n            removeShareholder(shareholder);\\r\\n        }\\r\\n\\r\\n        totalShares = totalShares.sub(shares[shareholder].amount).add(amount);\\r\\n        shares[shareholder].amount = amount;\\r\\n        shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\\r\\n    }\\r\\n\\r\\n    function deposit(uint256 amount) external override onlyToken {\\r\\n        \\r\\n        if (amount > 0) {        \\r\\n            totalDividends = totalDividends.add(amount);\\r\\n            dividendsPerShare = dividendsPerShare.add(dividendsPerShareAccuracyFactor.mul(amount).div(totalShares));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function distributeDividend(address shareholder) internal {\\r\\n        if(shares[shareholder].amount == 0){ return; }\\r\\n\\r\\n        uint256 amount = getClaimableDividendOf(shareholder);\\r\\n        if(amount > 0){\\r\\n            totalClaimed = totalClaimed.add(amount);\\r\\n            shares[shareholder].totalClaimed = shares[shareholder].totalClaimed.add(amount);\\r\\n            shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\\r\\n            IERC20(TOKEN).transfer(shareholder, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function claimDividend(address shareholder) external override onlyToken {\\r\\n        distributeDividend(shareholder);\\r\\n    }\\r\\n\\r\\n    function getClaimableDividendOf(address shareholder) public view returns (uint256) {\\r\\n        if(shares[shareholder].amount == 0){ return 0; }\\r\\n\\r\\n        uint256 shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount);\\r\\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\\r\\n\\r\\n        if(shareholderTotalDividends <= shareholderTotalExcluded){ return 0; }\\r\\n\\r\\n        return shareholderTotalDividends.sub(shareholderTotalExcluded);\\r\\n    }\\r\\n\\r\\n    function getCumulativeDividends(uint256 share) internal view returns (uint256) {\\r\\n        return share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\\r\\n    }\\r\\n\\r\\n    function addShareholder(address shareholder) internal {\\r\\n        shareholderIndexes[shareholder] = shareholders.length;\\r\\n        shareholders.push(shareholder);\\r\\n    }\\r\\n\\r\\n    function removeShareholder(address shareholder) internal {\\r\\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\\r\\n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\\r\\n        shareholders.pop();\\r\\n    }\\r\\n    \\r\\n    function manualSend(uint256 amount, address holder) external onlyOwner {\\r\\n        uint256 contractETHBalance = address(this).balance;\\r\\n        payable(holder).transfer(amount > 0 ? amount : contractETHBalance);\\r\\n    }\\r\\n\\r\\n\\r\\n    function getDividendsClaimedOf (address shareholder) external view returns (uint256) {\\r\\n        require (shares[shareholder].amount > 0, \\\"You're not a PRINTER shareholder!\\\");\\r\\n        return shares[shareholder].totalClaimed;\\r\\n    }\\r\\n\\r\\n    }\\r\\n\\r\\n    contract MEMEP is IERC20, Auth {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    address private WETH;\\r\\n    address private DEAD = 0x000000000000000000000000000000000000dEaD;\\r\\n    address private ZERO = 0x0000000000000000000000000000000000000000;\\r\\n\\r\\n    address public immutable MEME = address(0xb131f4A55907B10d1F0A50d8ab8FA09EC342cd74); //UNI TO CHANGE\\r\\n\\r\\n    string private constant  _name = \\\"Print The Meme\\\";\\r\\n    string private constant _symbol = \\\"MEMEP\\\";\\r\\n    uint8 private constant _decimals = 9;\\r\\n\\r\\n    uint256 private _totalSupply = 69696969 * (10 ** _decimals);\\r\\n    uint256 private _maxTxAmountBuy = _totalSupply;\\r\\n    uint256 private teamtokens = 3484848 * (10 ** _decimals);\\r\\n    \\r\\n\\r\\n    mapping (address => uint256) private _balances;\\r\\n    mapping (address => mapping (address => uint256)) private _allowances;\\r\\n    mapping (address => uint256) private cooldown;\\r\\n\\r\\n    mapping (address => bool) private isFeeExempt;\\r\\n    mapping (address => bool) private isDividendExempt;\\r\\n    mapping (address => bool) private isBot;\\r\\n            \\r\\n    uint256 private totalFee = 14;\\r\\n    uint256 private feeDenominator = 100;\\r\\n\\r\\n    address payable public marketingWallet = payable(0x73EBe309e7783FFa4954BBF2466F1588C1A7f057);\\r\\n    address payable public devWallet = payable(0xf3B67c8C4a222F7b0Ee61d23A501E1DAa5597919);\\r\\n    address payable public team = payable(0x122293dE48a23d155731999881De9CF7d65CF2D5);\\r\\n    address payable public team2 = payable(0x9CAF1B6a4b46C45b87330455495BeFb7c07f48a9);\\r\\n    \\r\\n\\r\\n    IDEXRouter public router;\\r\\n    address public pair;\\r\\n\\r\\n    uint256 public launchedAt;\\r\\n    bool private tradingOpen;\\r\\n    bool private buyLimit = true;\\r\\n    uint256 private maxBuy = 1393939 * (10 ** _decimals);\\r\\n    uint256 public numTokensSellToAddToLiquidity = 278787 * 10**9;\\r\\n\\r\\n    DividendDistributor private distributor;    \\r\\n    \\r\\n    bool public blacklistEnabled = false;\\r\\n    bool private inSwap;\\r\\n    bool public stable = false;\\r\\n    modifier swapping() { inSwap = true; _; inSwap = false; }\\r\\n\\r\\n    constructor (\\r\\n        address _owner        \\r\\n    ) Auth(_owner) {\\r\\n        router = IDEXRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n            \\r\\n        WETH = router.WETH();\\r\\n        \\r\\n        pair = IDEXFactory(router.factory()).createPair(address(this), WETH);\\r\\n        \\r\\n        _allowances[address(this)][address(router)] = type(uint256).max;\\r\\n\\r\\n        distributor = new DividendDistributor(_owner);\\r\\n\\r\\n        isFeeExempt[_owner] = true;\\r\\n        isFeeExempt[marketingWallet] = true;             \\r\\n              \\r\\n        isDividendExempt[pair] = true;\\r\\n        isDividendExempt[address(this)] = true;\\r\\n        isDividendExempt[DEAD] = true;        \\r\\n\\r\\n        _balances[_owner] = _totalSupply;\\r\\n    \\r\\n        emit Transfer(address(0), _owner, _totalSupply.sub(teamtokens));\\r\\n        emit Transfer(address(0), devWallet, teamtokens.div(3));\\r\\n        emit Transfer(address(0), team, teamtokens.div(3));\\r\\n        emit Transfer(address(0), team2, teamtokens.div(3));\\r\\n    }\\r\\n\\r\\n    receive() external payable { }\\r\\n\\r\\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\\r\\n    function decimals() external pure override returns (uint8) { return _decimals; }\\r\\n    function symbol() external pure override returns (string memory) { return _symbol; }\\r\\n    function name() external pure override returns (string memory) { return _name; }\\r\\n    function getOwner() external view override returns (address) { return owner; }\\r\\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\\r\\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\\r\\n\\r\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\r\\n        _allowances[msg.sender][spender] = amount;\\r\\n        emit Approval(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function approveMax(address spender) external returns (bool) {\\r\\n        return approve(spender, type(uint256).max);\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\r\\n        return _transferFrom(msg.sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\r\\n        if(_allowances[sender][msg.sender] != type(uint256).max){\\r\\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \\\"Insufficient Allowance\\\");\\r\\n        }\\r\\n\\r\\n        return _transferFrom(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\\r\\n        if (sender!= owner && recipient!= owner) require(tradingOpen, \\\"Trading not yet enabled.\\\"); //transfers disabled before openTrading\\r\\n        if (blacklistEnabled) {\\r\\n            require (!isBot[sender] && !isBot[recipient], \\\"Bot!\\\");\\r\\n        }\\r\\n        if (buyLimit) { \\r\\n            if (sender!=owner && recipient!= owner) require (amount<=maxBuy, \\\"Too much sir\\\");        \\r\\n        }\\r\\n\\r\\n        if (sender == pair && recipient != address(router) && !isFeeExempt[recipient]) {\\r\\n            require (cooldown[recipient] < block.timestamp);\\r\\n            cooldown[recipient] = block.timestamp + 60 seconds; \\r\\n        }\\r\\n       \\r\\n        if(inSwap){ return _basicTransfer(sender, recipient, amount); }      \\r\\n\\r\\n        uint256 contractTokenBalance = balanceOf(address(this));\\r\\n\\r\\n        bool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity;\\r\\n    \\r\\n        bool shouldSwapBack = (overMinTokenBalance && recipient==pair && balanceOf(address(this)) > 0);\\r\\n        if(shouldSwapBack){ swapBack(); }\\r\\n\\r\\n        _balances[sender] = _balances[sender].sub(amount, \\\"Insufficient Balance\\\");\\r\\n\\r\\n        uint256 amountReceived = shouldTakeFee(sender, recipient) ? takeFee(sender, amount) : amount;\\r\\n        \\r\\n        _balances[recipient] = _balances[recipient].add(amountReceived);\\r\\n\\r\\n        if(sender != pair && !isDividendExempt[sender]){ try distributor.setShare(sender, _balances[sender]) {} catch {} }\\r\\n        if(recipient != pair && !isDividendExempt[recipient]){ try distributor.setShare(recipient, _balances[recipient]) {} catch {} }\\r\\n\\r\\n        emit Transfer(sender, recipient, amountReceived);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\\r\\n        _balances[sender] = _balances[sender].sub(amount, \\\"Insufficient Balance\\\");\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n \\r\\n    function shouldTakeFee(address sender, address recipient) internal view returns (bool) {\\r\\n        return ( !(isFeeExempt[sender] || isFeeExempt[recipient]) &&  (sender == pair || recipient == pair) );\\r\\n   }\\r\\n\\r\\n    function takeFee(address sender, uint256 amount) internal returns (uint256) {\\r\\n        uint256 feeAmount = amount.mul(totalFee).div(feeDenominator);\\r\\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\\r\\n        emit Transfer(sender, address(this), feeAmount);   \\r\\n\\r\\n        return amount.sub(feeAmount);\\r\\n    }\\r\\n\\r\\n   \\r\\n    function swapBack() internal swapping {\\r\\n        uint256 amountToSwap = 0;\\r\\n        if(!stable){\\r\\n        amountToSwap = numTokensSellToAddToLiquidity;\\r\\n        }\\r\\n        else{\\r\\n        amountToSwap = balanceOf(address(this));\\r\\n        } \\r\\n\\r\\n        swapTokensForEth(amountToSwap.div(2));\\r\\n        swapTokensForTOKEN(amountToSwap.div(2));\\r\\n\\r\\n        uint256 dividends = IERC20(MEME).balanceOf(address(this));\\r\\n\\r\\n        bool success = IERC20(MEME).transfer(address(distributor), dividends);\\r\\n\\r\\n        if (success) {\\r\\n            distributor.deposit(dividends);            \\r\\n        }\\r\\n             \\r\\n        payable(marketingWallet).transfer(address(this).balance);        \\r\\n    }\\r\\n\\r\\n    \\r\\n\\r\\n    function swapTokensForTOKEN(uint256 tokenAmount) private {\\r\\n\\r\\n        address[] memory path = new address[](3);\\r\\n        path[0] = address(this);\\r\\n        path[1] = WETH;\\r\\n        path[2] = MEME;\\r\\n\\r\\n        // make the swap\\r\\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function swapTokensForEth(uint256 tokenAmount) private {\\r\\n\\r\\n        // generate the uniswap pair path of token -> weth\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = WETH;\\r\\n\\r\\n        // make the swap\\r\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0, // accept any amount of ETH\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\r\\n        \\r\\n        // add the liquidity\\r\\n        router.addLiquidityETH{value: ethAmount}(\\r\\n            address(this),\\r\\n            tokenAmount,\\r\\n            0, // slippage is unavoidable\\r\\n            0, // slippage is unavoidable\\r\\n            owner,\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    \\r\\n    function openTrading() external onlyOwner {\\r\\n        launchedAt = block.number;\\r\\n        tradingOpen = true;\\r\\n    }    \\r\\n  \\r\\n    \\r\\n    function setBot(address _address, bool toggle) external onlyOwner {\\r\\n        isBot[_address] = toggle;\\r\\n        _setIsDividendExempt(_address, toggle);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function _setIsDividendExempt(address holder, bool exempt) internal {\\r\\n        require(holder != address(this) && holder != pair);\\r\\n        isDividendExempt[holder] = exempt;\\r\\n        if(exempt){\\r\\n            distributor.setShare(holder, 0);\\r\\n        }else{\\r\\n            distributor.setShare(holder, _balances[holder]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setIsDividendExempt(address holder, bool exempt) external onlyOwner {\\r\\n        _setIsDividendExempt(holder, exempt);\\r\\n    }\\r\\n\\r\\n    function setIsFeeExempt(address holder, bool exempt) external onlyOwner {\\r\\n        isFeeExempt[holder] = exempt;\\r\\n    }\\r\\n\\r\\n    function setFee (uint256 _fee) external onlyOwner {\\r\\n        require (_fee <= 14, \\\"Fee can't exceed 14%\\\");\\r\\n        totalFee = _fee;\\r\\n    }\\r\\n  \\r\\n    function manualSend() external onlyOwner {\\r\\n        uint256 contractETHBalance = address(this).balance;\\r\\n        payable(marketingWallet).transfer(contractETHBalance);\\r\\n    }\\r\\n    function setStable(bool _stable) external onlyOwner {\\r\\n        stable = _stable;\\r\\n    }\\r\\n\\r\\n    function claimDividend() external {\\r\\n        distributor.claimDividend(msg.sender);\\r\\n    }\\r\\n    \\r\\n    function claimDividend(address holder) external onlyOwner {\\r\\n        distributor.claimDividend(holder);\\r\\n    }\\r\\n    \\r\\n    function getClaimableDividendOf(address shareholder) public view returns (uint256) {\\r\\n        return distributor.getClaimableDividendOf(shareholder);\\r\\n    }\\r\\n    \\r\\n    function manualBurn(uint256 amount) external onlyOwner returns (bool) {\\r\\n        return _basicTransfer(address(this), DEAD, amount);\\r\\n    }\\r\\n    \\r\\n    function getCirculatingSupply() public view returns (uint256) {\\r\\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\\r\\n    }\\r\\n\\r\\n    function setMarketingWallet(address _marketingWallet) external onlyOwner {\\r\\n        marketingWallet = payable(_marketingWallet);\\r\\n    } \\r\\n\\r\\n    function getTotalDividends() external view returns (uint256) {\\r\\n        return distributor.totalDividends();\\r\\n    }    \\r\\n\\r\\n    function getTotalClaimed() external view returns (uint256) {\\r\\n        return distributor.totalClaimed();\\r\\n    }\\r\\n\\r\\n     function getDividendsClaimedOf (address shareholder) external view returns (uint256) {\\r\\n        return distributor.getDividendsClaimedOf(shareholder);\\r\\n    }\\r\\n\\r\\n    function removeBuyLimit() external onlyOwner {\\r\\n        buyLimit = false;\\r\\n    }\\r\\n\\r\\n    function checkBot(address account) public view returns (bool) {\\r\\n        return isBot[account];\\r\\n    }\\r\\n\\r\\n    function checkPair() public view returns (address) {\\r\\n        return pair;\\r\\n    }\\r\\n\\r\\n    function setBlacklistEnabled() external onlyOwner {\\r\\n        require (blacklistEnabled == false, \\\"can only be called once\\\");\\r\\n        blacklistEnabled = true;\\r\\n    }\\r\\n\\r\\n    function setSwapThresholdAmount (uint256 amount) external onlyOwner {\\r\\n        require (amount <= _totalSupply.div(100), \\\"can't exceed 1%\\\");\\r\\n        numTokensSellToAddToLiquidity = amount * 10 ** 9;\\r\\n    }\\r\\n    function getPrice() public view returns (uint256) {\\r\\n        uint256 memepBalance = this.balanceOf(pair);\\r\\n        uint256 ethBalance = IERC20(WETH).balanceOf(pair);\\r\\n        require(memepBalance > 0, \\\"divison by zero error\\\");\\r\\n        uint256 price = ethBalance.mul(1e9).div(memepBalance);\\r\\n        return price;\\r\\n    } \\r\\n   \\r\\n}\"\r\n    },\r\n    \"contracts/MemePAirdrop.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\n//https://twitter.com/meme_printer69\\r\\n// https://t.me/thememeprinter\\r\\n// https://www.memeprinter.xyz/\\r\\npragma solidity 0.8.19;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\r\\nimport \\\"./MemeP.sol\\\";\\r\\n\\r\\ncontract MEMEPAirdrop is Context, Ownable {\\r\\n    \\r\\n    IERC20 private _memep;\\r\\n    bool isOpen = false;\\r\\n\\r\\n    //Mapping of the addresses that already claimed the airdrop\\r\\n\\r\\n    mapping(address => bool) public hasClaimed;\\r\\n    \\r\\n    constructor(address memep) {\\r\\n        _memep = IERC20(memep);        \\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add to whitelist\\r\\n     */\\r\\n     /**\\r\\n     * @notice Merkle root hash for whitelist addresses\\r\\n     */\\r\\n    bytes32 public merkleRoot = 0x77d63ab50c1528e1397e66bfa8b8c8928ecb4e9a49d4534735ad41dd6757a190;\\r\\n\\r\\n    /**\\r\\n     * @notice Change merkle root hash\\r\\n     */\\r\\n    function setMerkleRoot(bytes32 merkleRootHash) external onlyOwner\\r\\n    {\\r\\n        merkleRoot = merkleRootHash;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Verify merkle proof of the address\\r\\n     */\\r\\n    function verifyAddress(bytes32[] calldata _merkleProof) private \\r\\n    view returns (bool) {\\r\\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\\r\\n        return MerkleProof.verify(_merkleProof, merkleRoot, leaf);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Function with whitelist\\r\\n     */\\r\\n  function claimAirdrop(bytes32[] calldata _merkleProof) public\\r\\n    {\\r\\n        require (isOpen == true, \\\"Not opened yet\\\");\\r\\n        uint256 amount = 2500000000000;\\r\\n        require(verifyAddress(_merkleProof), \\\"Address is not eligible\\\");\\r\\n        require(!hasClaimed[msg.sender], \\\"Address has already claimed the airdrop\\\");\\r\\n        _memep.transfer(msg.sender,amount);\\r\\n        hasClaimed[msg.sender] = true;\\r\\n    }\\r\\n\\r\\n  function setOpen(bool _isOpen) public onlyOwner {\\r\\n    isOpen = _isOpen;\\r\\n  }   \\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"memep\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claimAirdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRootHash\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isOpen\",\"type\":\"bool\"}],\"name\":\"setOpen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MEMEPAirdrop", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ea158bbe90a4acb7b8f3cc53312c932c4b8b282c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}