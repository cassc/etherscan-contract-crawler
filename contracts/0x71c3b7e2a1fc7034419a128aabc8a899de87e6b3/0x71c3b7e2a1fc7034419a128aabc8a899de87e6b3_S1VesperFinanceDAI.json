{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/S1VesperFinanceDAI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IWETH.sol\\\";\\nimport \\\"./interfaces/IUniswapConnector.sol\\\";\\nimport \\\"./interfaces/IS1Proxy.sol\\\";\\nimport \\\"./proxies/S1VesperFinanceDAIProxy.sol\\\";\\n\\n\\ninterface IFees {\\n    function feeCollector(uint256 _index) external view returns (address);\\n    function depositStatus(uint256 _index) external view returns (bool);\\n    function calcFee(\\n        uint256 _strategyId,\\n        address _user,\\n        address _feeToken\\n    ) external view returns (uint256);\\n    function whitelistedDepositCurrencies(uint256 _index, address _token) external view returns(bool);\\n}\\n\\n\\ncontract S1VesperFinanceDAI {\\n    uint8 constant public strategyIndex = 5;\\n    address public feesAddress;\\n    address public uniswapConnector;\\n    address public wethAddress;\\n    address public daiAddress;\\n\\n    // protocols\\n    address public vPoolDAI;\\n    address public vPoolRewardsDAI;\\n    address public vspToken;\\n\\n    mapping(address => address) public depositors; \\n\\n    constructor(\\n        address _feesAddress,\\n        address _uniswapConnector,\\n        address _wethAddress,\\n        address _daiAddress,\\n        address _vPoolDAI,\\n        address _vPoolRewardsDAI,\\n        address _vspToken\\n    ) {\\n        feesAddress = _feesAddress;\\n        uniswapConnector = _uniswapConnector;\\n        wethAddress = _wethAddress;\\n        daiAddress = _daiAddress;\\n        vPoolDAI = _vPoolDAI;\\n        vPoolRewardsDAI = _vPoolRewardsDAI;\\n        vspToken = _vspToken;\\n    }\\n\\n    event Deposit(address indexed _depositor, address indexed _token, uint256 _amountIn, uint256 _amountOut);\\n\\n    event Withdraw(address indexed _depositor, address indexed _token, uint256 _amount, uint256 _fee);\\n\\n    event ClaimAdditionalTokens(address indexed _depositor, uint256 _amount0, uint256 _amount1, address indexed _swappedTo);\\n\\n    // Get current unclaimed additional tokens amount\\n    function getPendingAdditionalTokenClaims(address _address) external view returns(address[] memory _rewardTokens, uint256[] memory _claimableAmounts) {\\n        return IVPoolRewards(vPoolRewardsDAI).claimable(depositors[_address]);\\n    }\\n\\n    // Get current stake\\n    function getCurrentDeposit(address _address) external view returns(uint256, uint256) {\\n        uint256 vaDAIShare = IERC20(vPoolDAI).balanceOf(depositors[_address]);\\n        uint256 daiEquivalent;\\n        if (vaDAIShare > 0) {\\n            uint256 pricePerShare = IVPoolDAI(vPoolDAI).pricePerShare();\\n            daiEquivalent = (pricePerShare * vaDAIShare) / 10 ** 18;\\n        }\\n        return (vaDAIShare, daiEquivalent);\\n    }\\n\\n    function depositETH(uint256 _amountOutMin) external payable {\\n        require(IFees(feesAddress).depositStatus(strategyIndex), \\\"ERR: DEPOSITS_STOPPED\\\");\\n\\n        uint256 depositAmount = IUniswapConnector(uniswapConnector).swapETHForToken{value: msg.value}(\\n            daiAddress, \\n            0, \\n            _amountOutMin, \\n            address(this)\\n        );\\n        _yieldDeposit(depositAmount);\\n\\n        emit Deposit(msg.sender, wethAddress, msg.value, depositAmount);          \\n    }\\n\\n    function depositToken(address _token, uint256 _amount, uint256 _amountOutMin) external {\\n        require(IFees(feesAddress).depositStatus(strategyIndex), \\\"ERR: DEPOSITS_STOPPED\\\");\\n        require(IFees(feesAddress).whitelistedDepositCurrencies(strategyIndex, _token), \\\"ERR: INVALID_DEPOSIT_TOKEN\\\");\\n        IERC20(_token).transferFrom(msg.sender, address(this), _amount);\\n\\n        uint256 depositAmount;\\n        if (_token != daiAddress) {\\n            if (IERC20(_token).allowance(address(this), uniswapConnector) == 0) {\\n                IERC20(_token).approve(uniswapConnector, 2**256 - 1);\\n            }\\n\\n            depositAmount = IUniswapConnector(uniswapConnector).swapTokenForToken(\\n                _token,\\n                daiAddress, \\n                _amount, \\n                _amountOutMin, \\n                address(this)\\n            );\\n        } else {\\n            depositAmount = _amount;\\n        }\\n        _yieldDeposit(depositAmount);\\n \\n        emit Deposit(msg.sender, _token, _amount, depositAmount);\\n    }\\n\\n    function _yieldDeposit(uint256 _amount) private {\\n        if (depositors[msg.sender] == address(0)) {\\n            // deploy new proxy contract\\n            S1VesperFinanceDAIProxy s1proxy = new S1VesperFinanceDAIProxy(\\n                address(this),\\n                daiAddress,\\n                vPoolDAI,\\n                vPoolRewardsDAI,\\n                vspToken\\n            );\\n            depositors[msg.sender] = address(s1proxy);\\n            IERC20(daiAddress).approve(depositors[msg.sender], 2**256 - 1);\\n            s1proxy.deposit(_amount); \\n        } else {\\n            // send the deposit to the existing proxy contract\\n            if (IERC20(daiAddress).allowance(address(this), depositors[msg.sender]) == 0) {\\n                IERC20(daiAddress).approve(depositors[msg.sender], 2**256 - 1); \\n            }\\n\\n            IS1Proxy(depositors[msg.sender]).deposit(_amount);  \\n        }\\n    }\\n\\n    // claim VSP tokens and withdraw them\\n    function claimRaw() external {\\n        require(depositors[msg.sender] != address(0), \\\"ERR: INVALID_DEPOSITOR\\\");\\n        uint256 vspTokens = IS1Proxy(depositors[msg.sender]).claimToDepositor(msg.sender); \\n\\n        emit ClaimAdditionalTokens(msg.sender, vspTokens, 0, address(0));\\n    }\\n\\n    // claim VSP tokens, swap them for ETH and withdraw\\n    function claimInETH(uint256 _amountOutMin) external {\\n        claimInToken(wethAddress, _amountOutMin);        \\n    }\\n\\n    // claim VSP tokens, swap them for _token and withdraw\\n    function claimInToken(address _token, uint256 _amountOutMin) public {\\n        require(depositors[msg.sender] != address(0), \\\"ERR: INVALID_DEPOSITOR\\\");\\n        uint256 vspTokens = IS1Proxy(depositors[msg.sender]).claimToDeployer();\\n\\n        address receiver;\\n        if (_token == wethAddress) {\\n            receiver = address(this);\\n        } else {\\n            receiver = msg.sender;\\n        }\\n        \\n        uint256 tokenAmount;\\n        if (vspTokens > 0) {\\n            if (IERC20(vspToken).allowance(address(this), uniswapConnector) == 0) {\\n                IERC20(vspToken).approve(uniswapConnector, 2**256 - 1);\\n            }\\n\\n            tokenAmount = IUniswapConnector(uniswapConnector).swapTokenForToken(\\n                vspToken,\\n                _token,\\n                vspTokens,\\n                _amountOutMin,\\n                receiver\\n            );\\n\\n            if (_token == wethAddress) {\\n                IWETH(wethAddress).withdraw(tokenAmount);\\n                (bool success, ) = payable(msg.sender).call{value: tokenAmount}(\\\"\\\");\\n                require(success, \\\"ERR: FAIL_SENDING_ETH\\\");\\n            }\\n        }\\n\\n        emit ClaimAdditionalTokens(msg.sender, vspTokens, tokenAmount, _token);\\n    }\\n\\n    function withdrawETH(uint256 _vaDAIAmount, uint256 _amountOutMin, address _feeToken) external {\\n        withdrawToken(wethAddress, _vaDAIAmount, _amountOutMin, _feeToken);\\n    }\\n\\n    function withdrawToken(address _token, uint256 _vaDAIAmount, uint256 _amountOutMin, address _feeToken) public {\\n        require(depositors[msg.sender] != address(0), \\\"ERR: INVALID_DEPOSITOR\\\");\\n        (uint256 yieldDeposit, uint256 fee) = _withdrawYieldDeposit(_vaDAIAmount, _feeToken);\\n\\n        if (_token == daiAddress) { \\n            // withdraw DAI\\n            IERC20(daiAddress).transfer(\\n                msg.sender,\\n                yieldDeposit - fee\\n            );\\n\\n            emit Withdraw(msg.sender, daiAddress, yieldDeposit - fee, fee);\\n        } else {\\n            if (IERC20(daiAddress).allowance(address(this), uniswapConnector) == 0) {\\n                IERC20(daiAddress).approve(uniswapConnector, 2**256 - 1);\\n            }\\n\\n            address receiver;\\n            if (_token == wethAddress) {\\n                receiver = address(this);\\n            } else {\\n                receiver = msg.sender;\\n            }\\n\\n            uint256 tokenAmount = IUniswapConnector(uniswapConnector).swapTokenForToken(\\n                daiAddress,\\n                _token, \\n                yieldDeposit - fee, \\n                _amountOutMin, \\n                receiver\\n            );\\n\\n            if (_token == wethAddress) {\\n                IWETH(wethAddress).withdraw(tokenAmount);\\n                (bool success, ) = payable(msg.sender).call{value: tokenAmount}(\\\"\\\");\\n                require(success, \\\"ERR: FAIL_SENDING_ETH\\\");\\n            }\\n\\n            emit Withdraw(msg.sender, _token, tokenAmount, fee);\\n        }\\n    }\\n\\n    function _withdrawYieldDeposit(uint256 _vaDAIAmount, address _feeToken) private returns(uint256, uint256) {\\n        uint256 daiAmountToBeWithdrawn = IS1Proxy(depositors[msg.sender]).withdraw(_vaDAIAmount); \\n        IERC20(daiAddress).transferFrom(depositors[msg.sender], address(this), daiAmountToBeWithdrawn);\\n        \\n        // if fee then send it to the feeCollector \\n        uint256 fee = (daiAmountToBeWithdrawn * IFees(feesAddress).calcFee(strategyIndex, msg.sender, _feeToken)) / 1000;\\n        if (fee > 0) {\\n            IERC20(daiAddress).transfer(\\n                IFees(feesAddress).feeCollector(strategyIndex),\\n                fee\\n            );\\n        }\\n        return (daiAmountToBeWithdrawn, fee);\\n    }\\n\\n    receive() external payable {}\\n}\\n\\n// MN bby \u00af\\\\_(\u30c4)_/\u00af\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\ninterface IERC20 {\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external;\\n\\n    function transfer(address recipient, uint256 amount) external;\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    function decimals() external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\ninterface IWETH {\\n    function withdraw(uint wad) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IUniswapConnector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\ninterface IUniswapConnector {\\n    function swapTokenForToken(address _tokenIn, address _tokenOut, uint256 _amount, uint256 _amountOutMin, address _to) external returns(uint256);\\n\\n    function swapTokenForETH(address _tokenIn, uint256 _amount, uint256 _amountOutMin, address _to) external returns(uint256);\\n\\n    function swapETHForToken(address _tokenOut, uint256 _amount, uint256 _amountOutMin, address _to) external payable returns(uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IS1Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\ninterface IS1Proxy {\\n    function deposit(uint256 _deposit) external;\\n    function depositETH() external payable;\\n    function withdraw(uint256 _amount) external returns(uint256);\\n    function claimToDepositor(address _depositor) external returns(uint256);\\n    function claimToDeployer() external returns(uint256);\\n}\"\r\n    },\r\n    \"contracts/proxies/S1VesperFinanceDAIProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IVesperFinance.sol\\\";\\n\\n\\ncontract S1VesperFinanceDAIProxy {\\n    address private deployer;\\n    address private daiAddress;\\n    address private vPoolDAI;\\n    address private vPoolRewardsDAI;\\n    address private vspToken;\\n\\n    constructor(\\n        address _deployer,\\n        address _daiAddress,\\n        address _vPoolDAI,\\n        address _vPoolRewardsDAI,\\n        address _vspToken\\n    ) {\\n        deployer = _deployer;\\n        daiAddress = _daiAddress;\\n        vPoolDAI = _vPoolDAI;\\n        vPoolRewardsDAI = _vPoolRewardsDAI;\\n        vspToken = _vspToken;\\n\\n        IERC20(daiAddress).approve(_deployer, 2**256 - 1);\\n        IERC20(daiAddress).approve(vPoolDAI, 2**256 - 1);\\n    }\\n\\n    modifier onlyDeployer() {\\n        require(msg.sender == deployer, \\\"ERR: WRONG_DEPLOYER\\\");\\n        _;\\n    } \\n\\n    function deposit(uint256 _amount) external onlyDeployer {\\n        IERC20(daiAddress).transferFrom(deployer, address(this), _amount);\\n\\n        IVPoolDAI(vPoolDAI).deposit(_amount);\\n    }\\n\\n    function withdraw(uint256 _amount) external onlyDeployer returns(uint256) {\\n        IVPoolDAI(vPoolDAI).withdraw(_amount);\\n\\n        return IERC20(daiAddress).balanceOf(address(this));\\n    }\\n\\n    function claimToDepositor(address _depositor) external onlyDeployer returns(uint256) {\\n        return _claim(_depositor);\\n    }\\n\\n    function claimToDeployer() external onlyDeployer returns(uint256) {\\n        return _claim(deployer);\\n    }\\n\\n    function _claim(address _address) private returns(uint256) {\\n        // VSP tokens\\n        IVPoolRewards(vPoolRewardsDAI).claimReward(address(this));\\n\\n        uint256 vspBalance = IERC20(vspToken).balanceOf(address(this));\\n        if (vspBalance > 0) {\\n            IERC20(vspToken).transfer(\\n                _address,\\n                vspBalance\\n            );\\n        }\\n\\n        return vspBalance;\\n    }\\n}\\n\\n// MN bby \u00af\\\\_(\u30c4)_/\u00af\"\r\n    },\r\n    \"contracts/interfaces/IVesperFinance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\ninterface IVPoolDAI {\\n    function deposit(uint256 _amount) external;\\n\\n    function withdraw(uint256 _shares) external;\\n\\n    function pricePerShare() external view returns (uint256);\\n}\\n\\n\\ninterface IVPoolETH {\\n    function deposit() external payable;\\n\\n    function withdrawETH(uint256 _shares) external;\\n\\n    function pricePerShare() external view returns (uint256);\\n}\\n\\n\\ninterface IVPoolRewards {\\n    function claimable(address _account) external view returns (\\n        address[] memory _rewardTokens,\\n        uint256[] memory _claimableAmounts\\n    );\\n\\n    function claimReward(address _account) external;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feesAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapConnector\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wethAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_daiAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vPoolDAI\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vPoolRewardsDAI\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vspToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount1\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_swappedTo\",\"type\":\"address\"}],\"name\":\"ClaimAdditionalTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"}],\"name\":\"claimInETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"}],\"name\":\"claimInToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRaw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daiAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"}],\"name\":\"depositETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getCurrentDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getPendingAdditionalTokenClaims\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_rewardTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_claimableAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategyIndex\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapConnector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vPoolDAI\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vPoolRewardsDAI\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vspToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wethAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vaDAIAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeToken\",\"type\":\"address\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_vaDAIAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeToken\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "S1VesperFinanceDAI", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000006bfe813169eeb685935952ec461792b57e5ecc7000000000000000000000000f46a58c9cf612bb9d37512e9495688b40d41a8e7000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000538c8bac84e95a9df8ac10aad17dbe81b9e36ee00000000000000000000000035864296944119f72aa1b468e13449222f3f0e670000000000000000000000001b40183efb4dd766f11bda7a7c3ad8982e998421", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}