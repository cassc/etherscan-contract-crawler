{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/PoolManagerTertiaryProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nimport \\\"./Interfaces.sol\\\";\\r\\nimport \\\"./interfaces/IGaugeController.sol\\\";\\r\\nimport \\\"./interfaces/IBooster.sol\\\";\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\r\\n\\r\\n\\r\\ninterface ISecondaryProxy{\\r\\n    function setUsedAddress(address[] memory usedList) external;\\r\\n    function shutdownSystem() external;\\r\\n    function setOperator(address _operator) external;\\r\\n}\\r\\n\\r\\n/*\\r\\nImmutable pool manager proxy 3\\r\\n\\r\\n- seal add force pool\\r\\n- get lptoken from gauge\\r\\n- check protected pool list when shutting down\\r\\n- allow booster owner to shutdown protected pools\\r\\n\\r\\nnote: this should become the owner of secondary proxy\\r\\n\\r\\n*/\\r\\ncontract PoolManagerTertiaryProxy{\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    address public constant gaugeController = address(0x2F50D538606Fa9EDD2B11E2446BEb18C9D5846bB);\\r\\n    address public constant pools = address(0xD20904e5916113D11414F083229e9C8C6F91D1e1);\\r\\n    address public constant booster = address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);\\r\\n    address public constant secondaryProxy = address(0xD20904e5916113D11414F083229e9C8C6F91D1e1);\\r\\n    address public immutable protectedPoolManager;\\r\\n\\r\\n    address public owner;\\r\\n    address public operator;\\r\\n\\r\\n    constructor(address _protectedPoolManager) public {\\r\\n        //default to multisig\\r\\n        owner = address(0xa3C5A1e09150B75ff251c1a7815A07182c3de2FB);\\r\\n        operator = msg.sender;\\r\\n\\r\\n        protectedPoolManager = _protectedPoolManager;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(owner == msg.sender, \\\"!owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyOperator() {\\r\\n        require(operator == msg.sender, \\\"!op\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier isOperatorOrPoolManager() {\\r\\n        require(operator == msg.sender || protectedPoolManager == msg.sender, \\\"!pm\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    //set owner - only OWNER\\r\\n    function setOwner(address _owner) external onlyOwner{\\r\\n        owner = _owner;\\r\\n    }\\r\\n\\r\\n    //set operator - only OWNER\\r\\n    function setOperator(address _operator) external onlyOwner{\\r\\n        operator = _operator;\\r\\n    }\\r\\n\\r\\n    //make sure this contract can declare itself as operator\\r\\n    function setSecondaryOperator() external onlyOwner{\\r\\n        ISecondaryProxy(secondaryProxy).setOperator(address(this));\\r\\n    }\\r\\n\\r\\n    function setUsedAddress(address[] memory usedList) external onlyOwner{\\r\\n        ISecondaryProxy(secondaryProxy).setUsedAddress(usedList);\\r\\n    }\\r\\n\\r\\n    //shutdown pool management and disallow new pools. change is immutable\\r\\n    function shutdownSystem() external onlyOwner{\\r\\n        ISecondaryProxy(secondaryProxy).shutdownSystem();\\r\\n    }\\r\\n\\r\\n    //shutdown a pool - only operator OR protected pool manager\\r\\n    function shutdownPool(uint256 _pid) external isOperatorOrPoolManager returns(bool){\\r\\n        //if not manager, check protected list\\r\\n        if(msg.sender != protectedPoolManager){\\r\\n            //check that the lp token of the pool is not the current fee token\\r\\n            (address lptoken,,,,,) = IPools(booster).poolInfo(_pid);\\r\\n            require(lptoken != IBooster(booster).feeToken(), \\\"!shutdown fee token\\\");\\r\\n        }\\r\\n\\r\\n        //shutdown pool\\r\\n        IPools(pools).shutdownPool(_pid);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    //add a new pool if it has weight on the gauge controller - only OPERATOR\\r\\n    function addPool(address _lptoken, address _gauge, uint256 _stashVersion) external onlyOperator returns(bool){\\r\\n        //get lp token from gauge\\r\\n        address lptoken = ICurveGauge(_gauge).lp_token();\\r\\n        require(_lptoken == lptoken, \\\"!lptoken\\\");\\r\\n\\r\\n        return _addPool(_lptoken, _gauge, _stashVersion);\\r\\n    }\\r\\n\\r\\n    //force add a new pool\\r\\n    function forceAddPool(address _lptoken, address _gauge, uint256 _stashVersion) external onlyOperator returns(bool){\\r\\n        //sealed\\r\\n    }\\r\\n\\r\\n    //internal add pool\\r\\n    function _addPool(address _lptoken, address _gauge, uint256 _stashVersion) internal returns(bool){\\r\\n        return IPools(pools).addPool(_lptoken,_gauge,_stashVersion);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/contracts/interfaces/IGaugeController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ninterface IGaugeController {\\r\\n    function get_gauge_weight(address _gauge) external view returns(uint256);\\r\\n    function vote_user_slopes(address,address) external view returns(uint256,uint256,uint256);//slope,power,end\\r\\n    function vote_for_gauge_weights(address,uint256) external;\\r\\n    function add_gauge(address,int128,uint256) external;\\r\\n}\"\r\n    },\r\n    \"/contracts/interfaces/IBooster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\n\\r\\ninterface IBooster {\\r\\n    function owner() external view returns(address);\\r\\n    function feeToken() external view returns(address);\\r\\n    function feeDistro() external view returns(address);\\r\\n    function lockFees() external view returns(address);\\r\\n    function stakerRewards() external view returns(address);\\r\\n    function lockRewards() external view returns(address);\\r\\n    function setVoteDelegate(address _voteDelegate) external;\\r\\n    function vote(uint256 _voteId, address _votingAddress, bool _support) external returns(bool);\\r\\n    function voteGaugeWeight(address[] calldata _gauge, uint256[] calldata _weight ) external returns(bool);\\r\\n    function poolInfo(uint256 _pid) external view returns(address _lptoken, address _token, address _gauge, address _crvRewards, address _stash, bool _shutdown);\\r\\n    function earmarkRewards(uint256 _pid) external returns(bool);\\r\\n    function earmarkFees() external returns(bool);\\r\\n    function isShutdown() external view returns(bool);\\r\\n    function poolLength() external view returns (uint256);\\r\\n}\"\r\n    },\r\n    \"/contracts/Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\n\\r\\n\\r\\n\\r\\ninterface ICurveGauge {\\r\\n    function deposit(uint256) external;\\r\\n    function balanceOf(address) external view returns (uint256);\\r\\n    function withdraw(uint256) external;\\r\\n    function claim_rewards() external;\\r\\n    function reward_tokens(uint256) external view returns(address);//v2\\r\\n    function rewarded_token() external view returns(address);//v1\\r\\n    function lp_token() external view returns(address);\\r\\n    function is_killed() external view returns(bool);\\r\\n}\\r\\n\\r\\ninterface ICurveVoteEscrow {\\r\\n    function create_lock(uint256, uint256) external;\\r\\n    function increase_amount(uint256) external;\\r\\n    function increase_unlock_time(uint256) external;\\r\\n    function withdraw() external;\\r\\n    function smart_wallet_checker() external view returns (address);\\r\\n}\\r\\n\\r\\ninterface IWalletChecker {\\r\\n    function check(address) external view returns (bool);\\r\\n}\\r\\n\\r\\ninterface IVoting{\\r\\n    function vote(uint256, bool, bool) external; //voteId, support, executeIfDecided\\r\\n    function getVote(uint256) external view returns(bool,bool,uint64,uint64,uint64,uint64,uint256,uint256,uint256,bytes memory); \\r\\n    function vote_for_gauge_weights(address,uint256) external;\\r\\n}\\r\\n\\r\\ninterface IMinter{\\r\\n    function mint(address) external;\\r\\n}\\r\\n\\r\\ninterface IRegistry{\\r\\n    function get_registry() external view returns(address);\\r\\n    function get_address(uint256 _id) external view returns(address);\\r\\n    function gauge_controller() external view returns(address);\\r\\n    function get_lp_token(address) external view returns(address);\\r\\n    function get_gauges(address) external view returns(address[10] memory,uint128[10] memory);\\r\\n}\\r\\n\\r\\ninterface IStaker{\\r\\n    function deposit(address, address) external;\\r\\n    function withdraw(address) external;\\r\\n    function withdraw(address, address, uint256) external;\\r\\n    function withdrawAll(address, address) external;\\r\\n    function createLock(uint256, uint256) external;\\r\\n    function increaseAmount(uint256) external;\\r\\n    function increaseTime(uint256) external;\\r\\n    function release() external;\\r\\n    function claimCrv(address) external returns (uint256);\\r\\n    function claimRewards(address) external;\\r\\n    function claimFees(address,address) external;\\r\\n    function setStashAccess(address, bool) external;\\r\\n    function vote(uint256,address,bool) external;\\r\\n    function voteGaugeWeight(address,uint256) external;\\r\\n    function balanceOfPool(address) external view returns (uint256);\\r\\n    function operator() external view returns (address);\\r\\n    function execute(address _to, uint256 _value, bytes calldata _data) external returns (bool, bytes memory);\\r\\n}\\r\\n\\r\\ninterface IRewards{\\r\\n    function stake(address, uint256) external;\\r\\n    function stakeFor(address, uint256) external;\\r\\n    function withdraw(address, uint256) external;\\r\\n    function exit(address) external;\\r\\n    function getReward(address) external;\\r\\n    function queueNewRewards(uint256) external;\\r\\n    function notifyRewardAmount(uint256) external;\\r\\n    function addExtraReward(address) external;\\r\\n    function stakingToken() external view returns (address);\\r\\n    function rewardToken() external view returns(address);\\r\\n    function earned(address account) external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IStash{\\r\\n    function stashRewards() external returns (bool);\\r\\n    function processStash() external returns (bool);\\r\\n    function claimRewards() external returns (bool);\\r\\n    function initialize(uint256 _pid, address _operator, address _staker, address _gauge, address _rewardFactory) external;\\r\\n    function setExtraReward(address _token) external;\\r\\n    function setRewardHook(address _hook) external;\\r\\n    function tokenCount() external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IFeeDistro{\\r\\n    function claim() external;\\r\\n    function token() external view returns(address);\\r\\n}\\r\\n\\r\\ninterface ITokenMinter{\\r\\n    function mint(address,uint256) external;\\r\\n    function burn(address,uint256) external;\\r\\n}\\r\\n\\r\\ninterface IDeposit{\\r\\n    function isShutdown() external view returns(bool);\\r\\n    function balanceOf(address _account) external view returns(uint256);\\r\\n    function totalSupply() external view returns(uint256);\\r\\n    function poolInfo(uint256) external view returns(address,address,address,address,address, bool);\\r\\n    function rewardClaimed(uint256,address,uint256) external;\\r\\n    function withdrawTo(uint256,uint256,address) external;\\r\\n    function claimRewards(uint256,address) external returns(bool);\\r\\n    function rewardArbitrator() external returns(address);\\r\\n    function setGaugeRedirect(uint256 _pid) external returns(bool);\\r\\n    function owner() external returns(address);\\r\\n}\\r\\n\\r\\ninterface ICrvDeposit{\\r\\n    function deposit(uint256, bool) external;\\r\\n    function lockIncentive() external view returns(uint256);\\r\\n}\\r\\n\\r\\ninterface IRewardFactory{\\r\\n    function setAccess(address,bool) external;\\r\\n    function CreateCrvRewards(uint256,address) external returns(address);\\r\\n    function CreateTokenRewards(address,address,address) external returns(address);\\r\\n    function activeRewardCount(address) external view returns(uint256);\\r\\n    function addActiveReward(address,uint256) external returns(bool);\\r\\n    function removeActiveReward(address,uint256) external returns(bool);\\r\\n}\\r\\n\\r\\ninterface IStashFactory{\\r\\n    function CreateStash(uint256,address,address,uint256) external returns(address);\\r\\n    function setImplementation(address _v1, address _v2, address _v3) external;\\r\\n}\\r\\n\\r\\ninterface ITokenFactory{\\r\\n    function CreateDepositToken(address) external returns(address);\\r\\n}\\r\\n\\r\\ninterface IPools{\\r\\n    function addPool(address _lptoken, address _gauge, uint256 _stashVersion) external returns(bool);\\r\\n    function forceAddPool(address _lptoken, address _gauge, uint256 _stashVersion) external returns(bool);\\r\\n    function shutdownPool(uint256 _pid) external returns(bool);\\r\\n    function poolInfo(uint256) external view returns(address,address,address,address,address,bool);\\r\\n    function poolLength() external view returns (uint256);\\r\\n    function gaugeMap(address) external view returns(bool);\\r\\n    function setPoolManager(address _poolM) external;\\r\\n}\\r\\n\\r\\ninterface IVestedEscrow{\\r\\n    function fund(address[] calldata _recipient, uint256[] calldata _amount) external returns(bool);\\r\\n}\\r\\n\\r\\n\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_protectedPoolManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lptoken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stashVersion\",\"type\":\"uint256\"}],\"name\":\"addPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"booster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lptoken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stashVersion\",\"type\":\"uint256\"}],\"name\":\"forceAddPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gaugeController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protectedPoolManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondaryProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setSecondaryOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"usedList\",\"type\":\"address[]\"}],\"name\":\"setUsedAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"shutdownPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shutdownSystem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PoolManagerTertiaryProxy", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000256e1bba846611c37cf89844a02435e6c098b86d", "EVMVersion": "istanbul", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}