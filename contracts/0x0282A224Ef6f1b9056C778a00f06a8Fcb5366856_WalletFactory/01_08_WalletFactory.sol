pragma solidity 0.8.6;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/proxy/Clones.sol";
import "./Wallet.sol";


/**
 * @dev Implementation of the wallet controller contract.
 * It aims to serve as an orchestration mechanism to generate new wallets. The main idea is that any ethereum
 * address could call the `generate` method in order to have a new address available to receive funds.
 */
contract WalletFactory is Ownable {
    using Clones for address;

    /**
     * @dev Event fired whenever the `oldMaster` address has been replaced by the `newMaster` one.
     */
    event MasterChanged(address oldMaster, address newMaster);

    /**
     * @dev Event fired whenever a new address has been generated via the `generate` method.
     */
    event AddressGenerated(address indexed generatedAddress);

    /**
     * @dev Event fired upon receiving `amount` ether from `sender`.
     */
    event EtherReceived(address indexed sender, address indexed receiver, uint amount);

    /**
     * @dev Address where all funds coming from `Wallet` contracts will be collected in.
     */
    address payable public master;

    /**
     * @dev Address where the `Wallet` implementation lies. Used for cloning so that some gas can be saved
     * in the process.
     */
    address public immutable template;

    /**
     * Stores whether an address has been generated by this contract or not.
     */
    mapping(address => bool) public generatedAddresses;

    constructor(address payable _master, address _template) {
        require(_template != address(0), "WalletFactory: template address cannot be zero");

        template = _template;
        _setMaster(_master);
    }

    /**
     * @dev Internal method to set master address
     */
    function _setMaster(address payable _newMaster) internal {
        require(_newMaster != address(0), "WalletFactory: master address cannot be zero");

        emit MasterChanged(master, _newMaster);
        master = _newMaster;
    }

    /**
     * @dev Changes the current master address for `_newMaster`.
     * This operation can only be performed by the owner.
     */
    function setMaster(address payable _newMaster) public onlyOwner {
        _setMaster(_newMaster);
    }

    /**
     * @dev Generates a new `Wallet` contract using cloning method and returns its address.
     * @return 'address' new wallet contract address
     */
    function generate(bytes32 _salt, address[] calldata _assets) public returns (address) {
        address clone = template.cloneDeterministic(_salt);
        require(!generatedAddresses[clone], "WalletFactory: There is a contract with that address already generated");

        Wallet wallet = Wallet(payable(clone));
        wallet.setup();
        generatedAddresses[clone] = true;
        emit AddressGenerated(clone);
        if (_assets.length > 0) {
            wallet.collectMany(_assets);
        }
        return clone;
    }

    /**
     * @dev Checks whether the provided salt would generate a contract that already exists or not.
     * @return 'bool' Whether it exists or not
     */
    function isWalletGenerated(bytes32 _salt) public view returns (bool) {
        address computedAddress = computeAddress(_salt);
        return generatedAddresses[computedAddress];
    }

    /**
     * @dev Calculates the generated address given the salt.
     * @return 'address' provided by salt
     */
    function computeAddress(bytes32 _salt) public view returns (address) {
        return template.predictDeterministicAddress(_salt, address(this));
    }

    /**
     * @dev Gets called by a generated address whenever ether is received
     */
    function notifyEtherReceived(address _sender, uint _amount) public {
        require(generatedAddresses[msg.sender], "WalletFactory: receiver has not been generated by the factory");
        emit EtherReceived(_sender, msg.sender, _amount);
    }
}