{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/HexRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport {Base64} from \\\"@openzeppelin/contracts/utils/Base64.sol\\\";\\nimport {Strings} from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IRenderer} from \\\"./IRenderer.sol\\\";\\nimport {IHex} from \\\"./IHex.sol\\\";\\n\\ncontract HexRenderer is IRenderer {\\n    /* -------------------------------------------------------------------------- */\\n    /*                                   STORAGE                                  */\\n    /* -------------------------------------------------------------------------- */\\n    IHex private immutable _hexContract;\\n    mapping(uint256 => bool) private _drawMap0;\\n    mapping(uint256 => bool) private _drawMap1;\\n    mapping(uint256 => bool) private _drawMap2;\\n    mapping(uint256 => bool) private _drawMap3;\\n    mapping(uint256 => mapping(uint256 => string)) private _fillColors;\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                               INITIALIZATION                               */\\n    /* -------------------------------------------------------------------------- */\\n    constructor(IHex hexContract) {\\n        _hexContract = hexContract;\\n\\n        uint8[8] memory set0 = [1, 5, 6, 7, 0xb, 0xc, 0xd, 0xf];\\n        uint8[8] memory set1 = [2, 5, 8, 9, 0xb, 0xc, 0xe, 0xf];\\n        uint8[8] memory set2 = [3, 6, 0x8, 0xa, 0xb, 0xd, 0xe, 0xf];\\n        uint8[8] memory set3 = [4, 7, 9, 0xa, 0xc, 0xd, 0xe, 0xf];\\n        for (uint256 i = 0; i < set0.length; i++) {\\n            _drawMap0[set0[i]] = true;\\n        }\\n        for (uint256 i = 0; i < set1.length; i++) {\\n            _drawMap1[set1[i]] = true;\\n        }\\n        for (uint256 i = 0; i < set2.length; i++) {\\n            _drawMap2[set2[i]] = true;\\n        }\\n        for (uint256 i = 0; i < set3.length; i++) {\\n            _drawMap3[set3[i]] = true;\\n        }\\n        _fillColors[1][0] = \\\"B0AAA7\\\";\\n        _fillColors[1][1] = \\\"E83D05\\\";\\n        _fillColors[1][2] = \\\"ED0004\\\";\\n        _fillColors[1][3] = \\\"FAB905\\\";\\n        _fillColors[1][4] = \\\"DCC7BB\\\";\\n        _fillColors[1][5] = \\\"3D3236\\\";\\n        _fillColors[1][6] = \\\"3B657D\\\";\\n        _fillColors[1][7] = \\\"748C58\\\";\\n        _fillColors[2][0] = \\\"333333\\\";\\n        _fillColors[2][1] = \\\"EEEEEE\\\";\\n        _fillColors[2][2] = \\\"FFB6C1\\\";\\n        _fillColors[2][3] = \\\"008080\\\";\\n        _fillColors[2][4] = \\\"FF4500\\\";\\n        _fillColors[2][5] = \\\"FFD700\\\";\\n        _fillColors[2][6] = \\\"9400D3\\\";\\n        _fillColors[2][7] = \\\"00BFFF\\\";\\n        _fillColors[3][0] = \\\"222222\\\";\\n        _fillColors[3][1] = \\\"333333\\\";\\n        _fillColors[3][2] = \\\"555555\\\";\\n        _fillColors[3][3] = \\\"FF0000\\\";\\n        _fillColors[3][4] = \\\"00CDDA\\\";\\n        _fillColors[4][0] = \\\"F29C1B\\\";\\n        _fillColors[4][1] = \\\"5692B0\\\";\\n        _fillColors[4][2] = \\\"F05630\\\";\\n        _fillColors[4][3] = \\\"2B2728\\\";\\n        _fillColors[4][4] = \\\"D1CABC\\\";\\n        _fillColors[5][0] = \\\"202A2D\\\";\\n        _fillColors[5][1] = \\\"2A5371\\\";\\n        _fillColors[5][2] = \\\"3E5977\\\";\\n        _fillColors[5][3] = \\\"891528\\\";\\n        _fillColors[5][4] = \\\"663446\\\";\\n        _fillColors[5][5] = \\\"8A839E\\\";\\n        _fillColors[5][6] = \\\"DED2E0\\\";\\n        _fillColors[5][7] = \\\"F3EAF4\\\";\\n        _fillColors[5][8] = \\\"E59CA1\\\";\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                     SVG                                    */\\n    /* -------------------------------------------------------------------------- */\\n    function renderSVG(uint256 tokenId) external view returns (string memory) {\\n        string memory svgString = string.concat(\\n            '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 2640 3920\\\"><rect x=\\\"0\\\" y=\\\"0\\\" width=\\\"2640\\\" height=\\\"3920\\\" fill=\\\"#',\\n            tokenId == 1\\n                ? \\\"D4D1BB\\\"\\n                : tokenId == 2 ? \\\"DDDDDD\\\" : tokenId == 3 ? \\\"000000\\\" : tokenId == 4 ? \\\"A6BCC3\\\" : \\\"ECDEDF\\\",\\n            '\\\"/>'\\n        );\\n\\n        uint256 hashCount = _hexContract.getTokenDataLength(tokenId);\\n        for (\\n            uint256 globalCharIndex = hashCount > 16 ? (hashCount - 16) * 64 : 0;\\n            globalCharIndex < hashCount * 64;\\n            globalCharIndex++\\n        ) {\\n            uint256 hashIndex = globalCharIndex / 64;\\n            uint256 charIndex = globalCharIndex % 64;\\n            uint256 chunkIndex = charIndex / 4;\\n            bytes32 hash = _hexContract.getTokenDataHash(tokenId, hashIndex);\\n            uint256 chunkValue = _getChunkValue(hash, chunkIndex);\\n            svgString =\\n                string.concat(svgString, _getPathString(tokenId, hashIndex, hash, hashCount, charIndex, chunkValue));\\n        }\\n        return string.concat(svgString, \\\"</svg>\\\");\\n    }\\n\\n    function _getPathString(\\n        uint256 tokenId,\\n        uint256 hashIndex,\\n        bytes32 hash,\\n        uint256 hashCount,\\n        uint256 charIndex,\\n        uint256 chunkValue\\n    ) internal view returns (string memory) {\\n        uint256 charValue = _getUintAtPosition(hash, charIndex);\\n        string memory pathString;\\n        {\\n            uint256 x = (charIndex % 32) * 40 * 2 + 30;\\n            uint256 ySize = 1920 / (hashCount > 16 ? 16 : hashCount);\\n            uint256 y = 40\\n                + (\\n                    (charIndex / 4) < 8\\n                        ? (hashCount > 16 ? hashIndex - (hashCount - 16) : hashIndex) * 2\\n                        : (hashCount > 16 ? hashIndex - (hashCount - 16) : hashIndex) * 2 + 1\\n                ) * ySize;\\n            bool even = chunkValue / 4 < charValue;\\n            pathString = _getPath(x, y, charValue, even, ySize);\\n        }\\n        return string.concat(\\n            '<path d=\\\"',\\n            pathString,\\n            '\\\" fill=\\\"#',\\n            _getFillColor(tokenId, charValue, hash, charIndex, hashIndex),\\n            '\\\" stroke=\\\"#',\\n            tokenId == 1\\n                ? \\\"333333\\\"\\n                : tokenId == 2 ? \\\"111111\\\" : tokenId == 3 ? \\\"444444\\\" : tokenId == 4 ? \\\"111111\\\" : \\\"11111177\\\",\\n            '\\\" stroke-width=\\\"0.',\\n            Strings.toString((uint256(hash) % 90) + 10),\\n            '\\\"/>'\\n        );\\n    }\\n\\n    function _getPath(uint256 x, uint256 y, uint256 charValue, bool even, uint256 ySize)\\n        internal\\n        view\\n        returns (string memory)\\n    {\\n        return string.concat(\\n            _drawBlock(x, y, _drawMap0[charValue], even, ySize),\\n            _drawBlock(x + 20, y, _drawMap1[charValue], even, ySize),\\n            _drawBlock(x + 40, y, _drawMap2[charValue], even, ySize),\\n            _drawBlock(x + 60, y, _drawMap3[charValue], even, ySize)\\n        );\\n    }\\n\\n    function _drawBlock(uint256 x, uint256 y, bool fill, bool pivot, uint256 ySize)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        uint256 ysideA = pivot ? 0 : ySize;\\n        uint256 ysideB = pivot ? ySize : 0;\\n        string memory yA = Strings.toString(y + ysideA);\\n        string memory yB = Strings.toString(y + ysideB);\\n        string memory x0 = Strings.toString(x);\\n        string memory x1 = Strings.toString(x + 20);\\n        string memory x2 = Strings.toString(x + 40);\\n        if (fill) {\\n            string memory fillPath = string.concat(\\\"M\\\", x0, \\\" \\\", yA, \\\"L\\\", x1, \\\" \\\", yB, \\\"L\\\", x2, \\\" \\\", yB, \\\"L\\\", x1, \\\" \\\");\\n            fillPath = string.concat(fillPath, yA, \\\"L\\\", x0, \\\" \\\", yA, \\\"H\\\", x1, \\\"L\\\", x2, \\\" \\\", yB, \\\"H\\\", x1);\\n            fillPath = string.concat(fillPath, \\\"L\\\", x0, \\\" \\\", yA, \\\" Z\\\");\\n            return string.concat(fillPath, _constructAddition(x, y, ysideA, ysideB));\\n        } else {\\n            string memory base = string.concat(\\\"M\\\", x0, \\\" \\\", yA, \\\"L\\\", x1, \\\" \\\", yB, \\\"H\\\", x2, \\\"L\\\", x1, \\\" \\\", yA, \\\"Z\\\");\\n            return string.concat(base, _constructAddition(x, y, ysideA, ysideB));\\n        }\\n    }\\n\\n    function _constructAddition(uint256 x, uint256 y, uint256 ysideA, uint256 ysideB)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        string memory yA = Strings.toString(((y + ysideA) * 100 + _random(x, y, 0) - 500) / 100);\\n        string memory yB = Strings.toString(((y + ysideB) * 100 + _random(x, y, 1) - 500) / 100);\\n        string memory x0 = Strings.toString((x * 100 + _random(x, y, 2) - 500) / 100);\\n        string memory x1 = Strings.toString(((x + 20) * 100 + _random(x, y, 3) - 500) / 100);\\n        string memory x2 = Strings.toString(((x + 40) * 100 + _random(x, y, 4) - 500) / 100);\\n        return string.concat(\\\"M\\\", x0, \\\" \\\", yA, \\\"L\\\", x1, \\\" \\\", yB, \\\"Z M\\\", x2, \\\" \\\", yB, \\\"L\\\", x1, \\\" \\\", yA, \\\"Z\\\");\\n    }\\n\\n    function _random(uint256 x, uint256 y, uint256 offset) internal pure returns (uint256) {\\n        return uint256(keccak256(abi.encodePacked(x, y, offset))) % 1000;\\n    }\\n\\n    function _getChunkValue(bytes32 hash, uint256 index) internal pure returns (uint256) {\\n        return _getUintAtPosition(hash, index * 4) + _getUintAtPosition(hash, index * 4 + 1)\\n            + _getUintAtPosition(hash, index * 4 + 2) + _getUintAtPosition(hash, index * 4 + 3);\\n    }\\n\\n    function _getUintAtPosition(bytes32 hash, uint256 position) internal pure returns (uint256) {\\n        return (position % 2 == 0) ? uint256(uint8(hash[position / 2])) / 16 : uint256(uint8(hash[position / 2])) % 16;\\n    }\\n\\n    function _getFillColor(uint256 tokenId, uint256 value, bytes32 hash, uint256 charIndex, uint256 hashIndex)\\n        internal\\n        view\\n        returns (string memory)\\n    {\\n        return charIndex > 0 && charIndex < 63\\n            && value > _getUintAtPosition(hash, charIndex - 1) + _getUintAtPosition(hash, charIndex + 1)\\n            && (\\n                IERC721(address(_hexContract)).ownerOf(tokenId) == _hexContract.getTokenDataFrom(tokenId, hashIndex)\\n                    || hashIndex < 2\\n            )\\n            ? _fillColors[tokenId][value % ((tokenId == 1 || tokenId == 2) ? 8 : (tokenId == 3 || tokenId == 4) ? 5 : 9)]\\n            : \\\"111111\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"src/IHex.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\ninterface IHex {\\n    struct TokenData {\\n        bytes32 hash;\\n        address from;\\n    }\\n\\n    function getTokenDataLength(uint256 tokenId) external view returns (uint256);\\n\\n    function getTokenDataHash(uint256 tokenId, uint256 index) external view returns (bytes32);\\n\\n    function getTokenDataFrom(uint256 tokenId, uint256 index) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/IRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\ninterface IRenderer {\\n    function renderSVG(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides a set of functions to operate with Base64 strings.\\n *\\n * _Available since v4.5._\\n */\\nlibrary Base64 {\\n    /**\\n     * @dev Base64 Encoding/Decoding Table\\n     */\\n    string internal constant _TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /**\\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\\n     */\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        /**\\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\\n         */\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // Loads the table into memory\\n        string memory table = _TABLE;\\n\\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\\n        // and split into 4 numbers of 6 bits.\\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\\n        // - `data.length + 2`  -> Round up\\n        // - `/ 3`              -> Number of 3-bytes chunks\\n        // - `4 *`              -> 4 characters for each chunk\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Prepare the lookup table (skip the first \\\"length\\\" byte)\\n            let tablePtr := add(table, 1)\\n\\n            // Prepare result pointer, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // Run over the input, 3 bytes at a time\\n            for {\\n                let dataPtr := data\\n                let endPtr := add(data, mload(data))\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                // Advance 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // To write each character, shift the 3 bytes (18 bits) chunk\\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\\n                // and apply logical AND with 0x3F which is the number of\\n                // the previous character in the ASCII table prior to the Base64 Table\\n                // The result is then added to the table to get the character to write,\\n                // and finally write it in the result pointer but with a left shift\\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n            }\\n\\n            // When data `bytes` is not exactly 3 bytes long\\n            // it is padded with `=` characters at the end\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n                mstore8(sub(resultPtr, 2), 0x3d)\\n            }\\n            case 2 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IHex\",\"name\":\"hexContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"renderSVG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "HexRenderer", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000473c8087ce4cc41a6cd4a982622c90aaf993f2b9", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}