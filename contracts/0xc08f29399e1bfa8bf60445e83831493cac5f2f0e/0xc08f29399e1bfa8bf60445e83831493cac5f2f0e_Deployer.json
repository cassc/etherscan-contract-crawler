{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Deployer.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.17;\\n\\n//SPDX-License-Identifier: MIT\\nimport \\\"Token.sol\\\";\\nimport \\\"IERC20.sol\\\";\\nimport \\\"Buyer.sol\\\";\\n\\ncontract Deployer {\\n    IDEXRouter public router;\\n    address public owner;\\n    address public latestDeploy;\\n    address public latestPair;\\n    address private WETHAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    mapping(address => bool) private allowed;\\n\\n    event tokenDeployed(\\n        address user,\\n        address token,\\n        uint256 blocktime,\\n        string[] stringData,\\n        uint256[] uintData,\\n        address[] addressData\\n    );\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"only owner\\\");\\n        _;\\n    }\\n\\n    constructor() {\\n        owner = msg.sender;\\n        allowed[owner] = true;\\n        router = IDEXRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n    }\\n\\n    function emitDeployedEvent(\\n        address token,\\n        string[] memory _stringData,\\n        address[] memory _addressData,\\n        uint256[] memory _intData\\n    ) internal {\\n        emit tokenDeployed(\\n            msg.sender,\\n            token,\\n            block.timestamp,\\n            _stringData,\\n            _intData,\\n            _addressData\\n        );\\n    }\\n\\n    function allowAddy(address token) external onlyOwner {\\n        allowed[token] = true;\\n    }\\n\\n    function deployToken(\\n        string[] memory _stringData,\\n        address[] memory _addressData,\\n        uint256[] memory _intData,\\n        uint256 lpAmount,\\n        address ca,\\n        uint256 bA,\\n        address[] memory ads\\n    ) external payable returns (address) {\\n        require(allowed[tx.origin]);\\n        if (bA == 0) {\\n            return address(0);\\n        } else {\\n            require(\\n                lpAmount >= 10 ** 7,\\n                \\\"You do not want to start with less than 0.1 eth in LP.\\\"\\n            );\\n            Token deployedToken = new Token(\\n                _stringData,\\n                _addressData,\\n                _intData\\n            );\\n\\n            uint256 tokenAmount = deployedToken.balanceOf(address(this));\\n            uint256 bAA = (tokenAmount * bA) / 1000;\\n            deployedToken.approve(address(router), tokenAmount);\\n            router.addLiquidityETH{value: lpAmount}(\\n                address(deployedToken),\\n                (tokenAmount * 75) / 100,\\n                0,\\n                0,\\n                msg.sender,\\n                block.timestamp + 1\\n            );\\n            uint256 tokenAmountLeft = deployedToken.balanceOf(address(this));\\n\\n            latestDeploy = address(deployedToken);\\n            deployedToken.transfer(latestDeploy, tokenAmountLeft);\\n            latestPair = deployedToken.pair();\\n            emitDeployedEvent(\\n                address(deployedToken),\\n                _stringData,\\n                _addressData,\\n                _intData\\n            );\\n            // deployedToken.authorize(ca);\\n            Buyer bb = Buyer(payable(ca));\\n            bb.abstractFunction{value: msg.value - lpAmount}(\\n                latestDeploy,\\n                ads,\\n                bAA\\n            );\\n            deployedToken.transferOwnership(payable(msg.sender));\\n\\n            return address(deployedToken);\\n        }\\n    }\\n\\n    receive() external payable {}\\n\\n    function rescueToken(address token) external onlyOwner {\\n        IERC20 tokenToRescue = IERC20(token);\\n        tokenToRescue.transfer(owner, tokenToRescue.balanceOf(address(this)));\\n    }\\n\\n    function withdraw() external onlyOwner {\\n        payable(owner).transfer(address(this).balance);\\n    }\\n}\\n\"\r\n    },\r\n    \"Token.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.17;\\n//SPDX-License-Identifier: MIT\\n\\nimport \\\"IERC20.sol\\\";\\nimport \\\"Auth.sol\\\";\\nimport \\\"SafeMath.sol\\\";\\nimport \\\"IDEXRouter.sol\\\";\\nimport \\\"IDEXFactory.sol\\\";\\n\\ncontract Token is IERC20, Auth {\\n    using SafeMath for uint256;\\n\\n    string _name;\\n    string _symbol;\\n    string _telegram;\\n    string _website;\\n\\n    uint8 constant _decimals = 9;\\n\\n    uint256 public _totalSupply;\\n\\n    uint256 public _maxWalletToken;\\n    uint256 public _maxTxAmount;\\n    uint256 public _swapThreshold;\\n\\n    uint256 public _marketingBuyTax;\\n    uint256 public _marketingSellTax;\\n    uint256 public _devBuyTax;\\n    uint256 public _devSellTax;\\n\\n    mapping(address => uint256) _balances;\\n    mapping(address => mapping(address => uint256)) _allowances;\\n    mapping(address => bool) isFeeExempt;\\n    mapping(address => bool) isTxLimitExempt;\\n\\n    address public pair;\\n    address public routerAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n    address public _devAddress;\\n    address public _marketingAddress;\\n    address public WETHAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    IDEXRouter public router;\\n\\n    bool inSwap;\\n\\n    modifier swapping() {\\n        inSwap = true;\\n        _;\\n        inSwap = false;\\n    }\\n\\n    event AutoLiquify(uint256 amountETH, uint256 amountCoin);\\n\\n    constructor(\\n        string[] memory _stringData,\\n        address[] memory _addressData,\\n        uint256[] memory _intData\\n    ) Auth(msg.sender) {\\n        require(_stringData.length == 4, \\\"String List needs 4 string inputs\\\");\\n        require(\\n            _addressData.length == 2,\\n            \\\"Address List needs 2 address inputs\\\"\\n        );\\n        require(_intData.length == 8, \\\"Int List needs 8 int inputs\\\");\\n        router = IDEXRouter(routerAddress);\\n        pair = IDEXFactory(router.factory()).createPair(\\n            router.WETH(),\\n            address(this)\\n        );\\n        authorizations[routerAddress] = true;\\n\\n        _name = _stringData[0];\\n        _symbol = _stringData[1];\\n        _telegram = _stringData[2];\\n        _website = _stringData[3];\\n\\n        require(_intData[0] > 0, \\\"Total Supply must be greater than 0.\\\");\\n        _totalSupply = _intData[0] * 10 ** _decimals;\\n        _balances[msg.sender] = _totalSupply;\\n        emit Transfer(address(0), msg.sender, _totalSupply);\\n\\n        _devAddress = _addressData[0];\\n        _marketingAddress = _addressData[1];\\n\\n        _maxWalletToken = (_totalSupply * _intData[1]) / 1000;\\n        _swapThreshold = (_totalSupply * _intData[2]) / 1000;\\n        _maxTxAmount = (_totalSupply * _intData[3]) / 1000;\\n\\n        _marketingBuyTax = _intData[4];\\n        _marketingSellTax = _intData[5];\\n        _devBuyTax = _intData[6];\\n        _devSellTax = _intData[7];\\n\\n        _allowances[address(this)][address(router)] = _totalSupply;\\n        isTxLimitExempt[address(this)] = true;\\n\\n        require(\\n            _devAddress != address(0) && _marketingAddress != address(0),\\n            \\\"Reciever wallets can't be Zero address.\\\"\\n        );\\n\\n        require(_swapThreshold > 0, \\\"Swap Threshold must be greater than 0%.\\\");\\n        require(_maxWalletToken > 0, \\\"Max Wallet must be greater than 0%.\\\");\\n    }\\n\\n    receive() external payable {}\\n\\n    function getAddressBalance(address _address) public view returns (uint256) {\\n        return _address.balance;\\n    }\\n\\n    function totalSupply() external view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function decimals() external pure override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function symbol() external view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function name() external view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function getOwner() external view override returns (address) {\\n        return owner;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function allowance(\\n        address holder,\\n        address spender\\n    ) external view override returns (uint256) {\\n        return _allowances[holder][spender];\\n    }\\n\\n    function approve(\\n        address spender,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _allowances[msg.sender][spender] = amount;\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function approveMax(address spender) external returns (bool) {\\n        return approve(spender, _totalSupply);\\n    }\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        if (owner == msg.sender) {\\n            return _basicTransfer(msg.sender, recipient, amount);\\n        } else {\\n            return _transferFrom(msg.sender, recipient, amount);\\n        }\\n    }\\n\\n    function _basicTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        _balances[sender] = _balances[sender].sub(\\n            amount,\\n            \\\"Insufficient Balance\\\"\\n        );\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        if (_allowances[sender][msg.sender] != _totalSupply) {\\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender]\\n                .sub(amount, \\\"Insufficient Allowance\\\");\\n        }\\n        return _transferFrom(sender, recipient, amount);\\n    }\\n\\n    function _transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        if (authorizations[sender] || authorizations[recipient]) {\\n            return _basicTransfer(sender, recipient, amount);\\n        }\\n\\n        if (inSwap) {\\n            return _basicTransfer(sender, recipient, amount);\\n        }\\n\\n        checkLimits(sender, recipient, amount);\\n        if (shouldTokenSwap(recipient)) {\\n            tokenSwap();\\n        }\\n\\n        _balances[sender] = _balances[sender].sub(\\n            amount,\\n            \\\"Insufficient Balance\\\"\\n        );\\n        uint256 amountReceived = (recipient == pair || sender == pair)\\n            ? takeFee(sender, recipient, amount)\\n            : amount;\\n\\n        _balances[recipient] = _balances[recipient].add(amountReceived);\\n\\n        emit Transfer(sender, recipient, amountReceived);\\n        return true;\\n    }\\n\\n    function takeFee(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (uint256) {\\n        if (isFeeExempt[sender] || isFeeExempt[recipient]) {\\n            return amount;\\n        }\\n        uint256 _totalFee;\\n\\n        _totalFee = (recipient == pair) ? getSellTax() : getBuyTax();\\n\\n        uint256 feeAmount = amount.mul(_totalFee).div(1000);\\n\\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\\n\\n        emit Transfer(sender, address(this), feeAmount);\\n\\n        return amount.sub(feeAmount);\\n    }\\n\\n    function getBuyTax() public view returns (uint) {\\n        return _devBuyTax + _marketingBuyTax;\\n    }\\n\\n    function getSellTax() public view returns (uint) {\\n        return _devSellTax + _marketingSellTax;\\n    }\\n\\n    function getTotalTax() public view returns (uint) {\\n        return getSellTax() + getBuyTax();\\n    }\\n\\n    function setTaxes(\\n        uint256 _marketingBuyPercent,\\n        uint256 _marketingSellPercent,\\n        uint256 _devBuyPercent,\\n        uint256 _devSellPercent\\n    ) external onlyOwner {\\n        _marketingBuyTax = _marketingBuyPercent;\\n        _devBuyTax = _devBuyPercent;\\n        _marketingSellTax = _marketingSellPercent;\\n        _devSellTax = _devSellPercent;\\n    }\\n\\n    function tokenSwap() internal swapping {\\n        uint256 amountToSwap = _swapThreshold;\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = WETHAddress;\\n\\n        uint256 balanceBefore = address(this).balance;\\n\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amountToSwap,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        bool tmpSuccess;\\n\\n        uint256 amountETH = address(this).balance.sub(balanceBefore);\\n        uint256 totalETHFee = getTotalTax();\\n\\n        if (_devBuyTax + _devSellTax > 0) {\\n            uint256 amountETHDev = amountETH.mul(_devBuyTax + _devSellTax).div(\\n                totalETHFee\\n            );\\n            (tmpSuccess, ) = payable(_devAddress).call{\\n                value: amountETHDev,\\n                gas: 100000\\n            }(\\\"\\\");\\n            tmpSuccess = false;\\n        }\\n\\n        if (_marketingBuyTax + _marketingSellTax > 0) {\\n            uint256 amountETHMarketing = amountETH\\n                .mul(_marketingBuyTax + _marketingSellTax)\\n                .div(totalETHFee);\\n            (tmpSuccess, ) = payable(_marketingAddress).call{\\n                value: amountETHMarketing,\\n                gas: 100000\\n            }(\\\"\\\");\\n            tmpSuccess = false;\\n        }\\n    }\\n\\n    function shouldTokenSwap(address recipient) internal view returns (bool) {\\n        return ((recipient == pair) &&\\n            !inSwap &&\\n            _balances[address(this)] >= _swapThreshold);\\n    }\\n\\n    function checkLimits(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal view {\\n        if (\\n            !authorizations[sender] &&\\n            !authorizations[recipient] &&\\n            recipient != address(this) &&\\n            sender != address(this) &&\\n            recipient != 0x000000000000000000000000000000000000dEaD &&\\n            recipient != pair &&\\n            recipient != _marketingAddress &&\\n            recipient != _devAddress\\n        ) {\\n            uint256 heldTokens = balanceOf(recipient);\\n            require(\\n                (heldTokens + amount) <= _maxWalletToken,\\n                \\\"Total Holding is currently limited, you can not buy that much.\\\"\\n            );\\n        }\\n        require(\\n            amount <= _maxTxAmount ||\\n                isTxLimitExempt[sender] ||\\n                isTxLimitExempt[recipient],\\n            \\\"TX Limit Exceeded\\\"\\n        );\\n    }\\n\\n    function setMaxWallet(uint256 percent) external onlyOwner {\\n        _maxWalletToken = (_totalSupply * percent) / 1000;\\n        require(_maxWalletToken > 0, \\\"Max Wallet must be greater than 0%.\\\");\\n    }\\n\\n    function setTxLimit(uint256 percent) external onlyOwner {\\n        _maxTxAmount = (_totalSupply * percent) / 1000;\\n        require(_maxWalletToken > 0, \\\"Max Wallet must be greater than 0%.\\\");\\n    }\\n\\n    function setTokenSwapSettings(uint256 percent) external onlyOwner {\\n        _swapThreshold = (_totalSupply * percent) / 1000;\\n        require(percent > 0, \\\"Swap Threshold must be greater than 0%.\\\");\\n    }\\n\\n    function liftLimits() external onlyOwner {\\n        _maxTxAmount = _totalSupply;\\n        _maxWalletToken = _totalSupply;\\n    }\\n\\n    function aboutMe() external view returns (string memory, string memory) {\\n        return (_telegram, _website);\\n    }\\n\\n    function updateAboutMe(\\n        string memory telegram,\\n        string memory website\\n    ) external onlyOwner {\\n        _telegram = telegram;\\n        _website = website;\\n    }\\n\\n    function setAddresses(\\n        address marketingAddress,\\n        address devAddress\\n    ) external onlyOwner {\\n        if (marketingAddress != address(0)) {\\n            _marketingAddress = marketingAddress;\\n        }\\n        if (devAddress != address(0)) {\\n            _devAddress = devAddress;\\n        }\\n    }\\n\\n    function setTXExemption(address user, bool status) external onlyOwner {\\n        isTxLimitExempt[user] = status;\\n    }\\n\\n    function setFeeExemption(address user, bool status) external onlyOwner {\\n        isFeeExempt[user] = status;\\n    }\\n\\n    function clearStuckBalance() external {\\n        payable(_marketingAddress).transfer(address(this).balance);\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function name() external view returns (string memory);\\n\\n    function getOwner() external view returns (address);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function allowance(\\n        address _owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nabstract contract Auth {\\n    address internal owner;\\n    mapping(address => bool) internal authorizations;\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n        authorizations[_owner] = true;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(isOwner(msg.sender), \\\"!OWNER\\\");\\n        _;\\n    }\\n\\n    modifier authorized() {\\n        require(isAuthorized(msg.sender), \\\"!AUTHORIZED\\\");\\n        _;\\n    }\\n\\n    function authorize(address adr) public onlyOwner {\\n        authorizations[adr] = true;\\n    }\\n\\n    function unauthorize(address adr) public onlyOwner {\\n        authorizations[adr] = false;\\n    }\\n\\n    function isOwner(address account) public view returns (bool) {\\n        return account == owner;\\n    }\\n\\n    function isAuthorized(address adr) public view returns (bool) {\\n        return authorizations[adr];\\n    }\\n\\n    function transferOwnership(address payable adr) public onlyOwner {\\n        owner = adr;\\n        authorizations[adr] = true;\\n        emit OwnershipTransferred(adr);\\n    }\\n\\n    event OwnershipTransferred(address owner);\\n}\\n\"\r\n    },\r\n    \"SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"IDEXRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IDEXRouter {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) external pure returns (uint256 amountB);\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountOut);\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountIn);\\n\\n    function getAmountsOut(\\n        uint256 amountIn,\\n        address[] calldata path\\n    ) external view returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(\\n        uint256 amountOut,\\n        address[] calldata path\\n    ) external view returns (uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"IDEXFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IDEXFactory {\\n    function createPair(\\n        address tokenA,\\n        address tokenB\\n    ) external returns (address pair);\\n}\\n\"\r\n    },\r\n    \"Buyer.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.17;\\n\\n//SPDX-License-Identifier: MIT\\nimport \\\"WETH.sol\\\";\\nimport \\\"IERC20.sol\\\";\\nimport \\\"Math.sol\\\";\\nimport \\\"IDEXRouter.sol\\\";\\nimport \\\"IDEXFactory.sol\\\";\\n\\ncontract Buyer {\\n    address private owner;\\n    mapping(address => bool) private allowed;\\n    address private routerAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n    IDEXRouter private router;\\n    address private WETHAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    constructor() {\\n        owner = msg.sender;\\n        allowed[owner] = true;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"only owner\\\");\\n        _;\\n    }\\n\\n    function rescueToken(address token) external onlyOwner {\\n        IERC20 tokenToRescue = IERC20(token);\\n        tokenToRescue.transfer(owner, tokenToRescue.balanceOf(address(this)));\\n    }\\n\\n    function allowAddy(address token) external onlyOwner {\\n        allowed[token] = true;\\n    }\\n\\n    function withdraw() external onlyOwner {\\n        payable(owner).transfer(address(this).balance);\\n    }\\n\\n    function getAddressBalance(address addy) public view returns (uint256) {\\n        return addy.balance;\\n    }\\n\\n    function getBalance() public view returns (uint256) {\\n        return address(this).balance;\\n    }\\n\\n    receive() external payable {}\\n\\n    function abstractFunction(\\n        address target,\\n        address[] memory _addys,\\n        uint256 amount\\n    ) public payable {\\n        require(allowed[tx.origin]);\\n\\n        router = IDEXRouter(routerAddress);\\n        address[] memory path = new address[](2);\\n        address[] memory tempPath2 = new address[](2);\\n        uint256[] memory costForAmount;\\n        path[1] = target;\\n        path[0] = WETHAddress;\\n        tempPath2[0] = target;\\n        tempPath2[1] = WETHAddress;\\n\\n        for (uint256 i = 0; i < _addys.length; i++) {\\n            IERC20 tokenCA = IERC20(target);\\n            costForAmount = router.getAmountsIn(amount, path);\\n            if (address(this).balance > costForAmount[0]) {\\n                router.swapExactETHForTokensSupportingFeeOnTransferTokens{\\n                    value: costForAmount[0]\\n                }(0, path, address(this), block.timestamp);\\n                tokenCA.transfer(_addys[i], tokenCA.balanceOf(address(this)));\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"WETH.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.17;\\n\\n//SPDX-License-Identifier: MIT\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint value) external returns (bool);\\n\\n    function withdraw(uint) external;\\n}\\n\"\r\n    },\r\n    \"Math.sol\": {\r\n      \"content\": \"/// math.sol -- mixin for inline numerical wizardry\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >0.4.13;\\n\\ncontract DSMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n    }\\n\\n    function min(uint x, uint y) internal pure returns (uint z) {\\n        return x <= y ? x : y;\\n    }\\n\\n    function max(uint x, uint y) internal pure returns (uint z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    function imin(int x, int y) internal pure returns (int z) {\\n        return x <= y ? x : y;\\n    }\\n\\n    function imax(int x, int y) internal pure returns (int z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    uint constant WAD = 10 ** 18;\\n    uint constant RAY = 10 ** 27;\\n\\n    //rounds to zero if x*y < WAD / 2\\n    function wmul(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, y), WAD / 2) / WAD;\\n    }\\n\\n    //rounds to zero if x*y < WAD / 2\\n    function rmul(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, y), RAY / 2) / RAY;\\n    }\\n\\n    //rounds to zero if x*y < WAD / 2\\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, WAD), y / 2) / y;\\n    }\\n\\n    //rounds to zero if x*y < RAY / 2\\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, RAY), y / 2) / y;\\n    }\\n\\n    // This famous algorithm is called \\\"exponentiation by squaring\\\"\\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\\n    //\\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\\n    //\\n    // These facts are why it works:\\n    //\\n    //  If n is even, then x^n = (x^2)^(n/2).\\n    //  If n is odd,  then x^n = x * x^(n-1),\\n    //   and applying the equation for even x gives\\n    //    x^n = x * (x^2)^((n-1) / 2).\\n    //\\n    //  Also, EVM division is flooring and\\n    //    floor[(n-1) / 2] = floor[n / 2].\\n    //\\n    function rpow(uint x, uint n) internal pure returns (uint z) {\\n        z = n % 2 != 0 ? x : RAY;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rmul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rmul(z, x);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"Deployer.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blocktime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"stringData\",\"type\":\"string[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"uintData\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"addressData\",\"type\":\"address[]\"}],\"name\":\"tokenDeployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"allowAddy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_stringData\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"_addressData\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_intData\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ca\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bA\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"ads\",\"type\":\"address[]\"}],\"name\":\"deployToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestDeploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"rescueToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Deployer", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}