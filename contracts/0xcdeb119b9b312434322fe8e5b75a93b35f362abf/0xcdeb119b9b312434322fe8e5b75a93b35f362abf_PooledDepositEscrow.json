{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/PooledDepositEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.19;\\n\\n// Structs\\nimport {UserRequest} from \\\"./core/Structs.sol\\\";\\n\\n/// Utils /////\\nimport {BaseChecker} from \\\"./utils/BaseChecker.sol\\\";\\nimport {Ownable} from \\\"./utils/Ownable.sol\\\";\\n\\n//Interfaces\\nimport {IERC20} from \\\"openzeppelin-contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {IFyde} from \\\"./interfaces/IFyde.sol\\\";\\nimport {IGovernanceModule} from \\\"./interfaces/IGovernanceModule.sol\\\";\\nimport {IOracle} from \\\"./interfaces/IOracle.sol\\\";\\nimport {IRelayer} from \\\"./interfaces/IRelayer.sol\\\";\\n\\n///@title PooledDepositEscrow\\n///@notice The purpose of this contract is to pool assets from different users to be deposited into\\n/// fyde at\\n/// once in order to bootstrap the pool and/or save deposit taxes.\\n///@dev Following flow -> owner deploys Escrow with whitelisted assets/govAssets -> owner whitelists\\n/// users -> user deposit assets with/without governance -> escrow period is over and deposits are\\n/// disabled, start of freeze period -> owner decides how much of the deposited assets they want to\\n/// keep (setConcentrations) -> freeze period ends -> depositToFyde() requestDeposits on the relayer\\n/// to transfer funds into fyde (works in batches of 5 assets, has to be called multiple times due\\n/// to gas limitations) -> wait until fyde has processed transactions -> updateInternalAccounting\\n/// gets the correct TRSY price after calculated by gelato -> user claim assets, gets TRSY sTRSY and\\n/// refunds (can claim whenever they want)\\n/// REVOKE: If owner decides that something is wrong after escrow period, can revoke. Users can then\\n/// get 100% of deposits refunded\\ncontract PooledDepositEscrow is Ownable, BaseChecker {\\n  using SafeERC20 for IERC20;\\n\\n  error CannotClaimForAsset(address);\\n  error EscrowPeriodEnded();\\n  error InvalidTimePeriod();\\n  error InsufficientBalance(address);\\n  error OnlyDuringFreeze();\\n  error FydeDepositCompleted();\\n  error FydeDepositNotCompleted();\\n  error Revoked();\\n  error NotRevoked();\\n  error NotSupportedAsset(address);\\n  error InternalAccountingNotUpdated();\\n  error DepositsMightStillBeProcessed();\\n  error ConcentrationsNotSet();\\n  error TaxFactorNotZero();\\n  error PriceNotAvailable(address asset);\\n\\n  ///@notice Used for precision of division\\n  uint256 constant SCALING_FACTOR = 1e18;\\n\\n  ///@notice Max number assets accepted in one request\\n  uint128 public constant MAX_ASSET_TO_REQUEST = 5;\\n\\n  ///@notice max gas required for deposit, should correspondent to gov deposit of 5 assets + proxy\\n  /// creation\\n  uint128 public constant GAS_TO_FORWARD = 2e6;\\n\\n  ///@notice timestamp until which users can deposit\\n  uint128 public immutable ESCROW_PERIOD;\\n\\n  ///@notice timestamp until owner can set concentrations or revoke\\n  uint128 public immutable FREEZE_PERIOD;\\n\\n  ///@notice fyde interface\\n  IFyde public immutable FYDE;\\n  ///@notice relayer interface\\n  IRelayer public immutable RELAYER;\\n  ///@notice governance module interface\\n  IGovernanceModule public immutable GOVERNANCE_MODULE;\\n  ///@notice oracle module interface\\n  IOracle public immutable ORACLE;\\n\\n  /// -----------------------------\\n  ///         Storage\\n  /// -----------------------------\\n\\n  // bools used to ensure actions are called in correct order\\n\\n  ///@notice owner has set concentration\\n  bool public concentrationsSet;\\n  ///@notice requested deposit on relayer for all assets\\n  bool public fydeDepositCompleted;\\n  ///@notice owner has abborted escrow process\\n  bool public revoked;\\n  ///@notice trsy price updated after deposits are processed\\n  bool public internalAccountingUpdated;\\n  ///@notice amount of assets deposited to fyde (since done in multiple tx)\\n  uint256 public assetsTransferred;\\n  ///@notice measure of expected TRSY when requesting depositing, rescaled to correct value\\n  uint256 public totalExpectedTrsy;\\n  ///notice assets allowed for deposit\\n  address[] public assets;\\n\\n  ///@dev splits slot into uint128 for std and gov deposit values\\n  struct Slot {\\n    uint128 std;\\n    uint128 gov;\\n  }\\n\\n  ///@notice user authorization, can use deposit\\n  mapping(address => bool) public isUser;\\n\\n  ///@notice is asset allowed in escrow\\n  mapping(address => bool) public supportedAssets;\\n  ///@notice is asset allowed in governance\\n  mapping(address => bool) public keepGovAllowed;\\n  ///@notice total token balance in escrow\\n  mapping(address => Slot) public totalBalance;\\n  ///@notice amount of token to be deposited into fyde (chosen by escrow owner)\\n  mapping(address => Slot) public concentrationAmounts;\\n  ///@notice token amount accepted for fyde / amount deposited into escrow\\n  mapping(address => Slot) public finalPercentages;\\n  ///@notice TRSY received for each asset\\n  mapping(address => Slot) public TRSYBalancesPerAsset;\\n  ///@notice escrow deposits per user and asset;\\n  mapping(address => mapping(address => Slot)) public deposits;\\n\\n  /// -----------------------------\\n  ///         Events\\n  /// -----------------------------\\n\\n  event AssetDeposited(address indexed account, address indexed asset, uint256 amount);\\n  event ClaimedAndRefunded(address indexed account);\\n  event ConcentrationAmountsSet(uint128[] amounts, uint128[] govAmounts);\\n  event FydeDeposit();\\n  event Refunded(address indexed account, address indexed asset, uint256 refund);\\n  event EscrowRevoked();\\n  event InternalAccountingUpdated();\\n\\n  ///@notice Deploys escrow and sets the assets for deposit and the timing for the scrow.\\n  ///@param _assets Addresses of whitelisted assets\\n  ///@param _keepGovAllowed is asset whitelisted for gov deposit true/false\\n  ///@param _fyde Address of fyde contract\\n  ///@param _relayer Address of relayer contract\\n  ///@param _governanceModule Address of governance Module contract\\n  ///@param _oracle Address of oracle module contract\\n  ///@param _escrowPeriod ts of escrow period in seconds\\n  ///@param _freezePeriod ts of freeze period in seconds\\n  constructor(\\n    address[] memory _assets,\\n    bool[] memory _keepGovAllowed,\\n    address _fyde,\\n    address _relayer,\\n    address _governanceModule,\\n    address _oracle,\\n    uint128 _escrowPeriod,\\n    uint128 _freezePeriod\\n  ) Ownable(msg.sender) {\\n    if (_assets.length != _keepGovAllowed.length) revert InconsistentLengths();\\n\\n    FYDE = IFyde(_fyde);\\n    RELAYER = IRelayer(_relayer);\\n    GOVERNANCE_MODULE = IGovernanceModule(_governanceModule);\\n    ORACLE = IOracle(_oracle);\\n\\n    ESCROW_PERIOD = uint128(block.timestamp) + _escrowPeriod;\\n    FREEZE_PERIOD = ESCROW_PERIOD + _freezePeriod;\\n\\n    assets = _assets;\\n\\n    // Activate supported assets\\n    for (uint256 i = 0; i < _assets.length; ++i) {\\n      supportedAssets[_assets[i]] = true;\\n      if (_keepGovAllowed[i]) keepGovAllowed[_assets[i]] = true;\\n    }\\n  }\\n\\n  ///@notice Adds users to whitelist of allwoed depositors\\n  ///@param _user addresses to whitelist\\n  function addUser(address[] calldata _user) external onlyOwner {\\n    for (uint256 i; i < _user.length; ++i) {\\n      isUser[_user[i]] = true;\\n    }\\n  }\\n\\n  ///@notice Removes users from whitelist\\n  ///@param _user addresses to remove from\\n  function removeUser(address[] calldata _user) external onlyOwner {\\n    for (uint256 i; i < _user.length; ++i) {\\n      isUser[_user[i]] = false;\\n    }\\n  }\\n\\n  ///@notice Collect ETH from the contract, in case extra eth\\n  function collectEth(address payable _recipient) external onlyOwner {\\n    uint256 ethBalance = address(this).balance;\\n    (bool sent,) = _recipient.call{value: ethBalance}(\\\"\\\");\\n    require(sent);\\n  }\\n\\n  ///@notice Deposits asset into escrow\\n  ///@param asset Asset to deposit\\n  ///@param amount Amount to deposit\\n  ///@param keepGovRights standard or governance deposit\\n  function deposit(address asset, uint128 amount, bool keepGovRights) external onlyUser {\\n    if (amount == 0) revert ZeroParameter();\\n    if (uint128(block.timestamp) > ESCROW_PERIOD) revert EscrowPeriodEnded();\\n    if ((keepGovRights && !keepGovAllowed[asset]) || !supportedAssets[asset]) {\\n      revert NotSupportedAsset(asset);\\n    }\\n    IERC20(asset).safeTransferFrom(msg.sender, address(this), amount);\\n    if (keepGovRights) {\\n      deposits[msg.sender][asset].gov += amount;\\n      totalBalance[asset].gov += amount;\\n    } else {\\n      deposits[msg.sender][asset].std += amount;\\n      totalBalance[asset].std += amount;\\n    }\\n\\n    emit AssetDeposited(msg.sender, asset, amount);\\n  }\\n\\n  ///@notice Sets amount of tokens to accept into fyde\\n  ///@param amounts Amount of tokens for standard deposit\\n  ///@param govAmounts Amount of tokens for governance deposit\\n  ///@dev inputs have to be of same length and order as storage variable assets\\n  function setConcentrationAmounts(uint128[] calldata amounts, uint128[] calldata govAmounts)\\n    external\\n    onlyOwner\\n  {\\n    if (amounts.length != assets.length || govAmounts.length != assets.length) {\\n      revert InconsistentLengths();\\n    }\\n    uint128 time = uint128(block.timestamp);\\n    if (time < ESCROW_PERIOD || time > FREEZE_PERIOD) revert InvalidTimePeriod();\\n    for (uint256 i = 0; i < amounts.length; ++i) {\\n      address asset = assets[i];\\n\\n      uint128 assetAmount = amounts[i];\\n      uint128 govAmount = govAmounts[i];\\n\\n      if (assetAmount == 0 && govAmount == 0) continue;\\n\\n      uint128 balance = totalBalance[asset].std;\\n      uint128 govBalance = totalBalance[asset].gov;\\n\\n      if (assetAmount > balance || govAmount > govBalance) revert InsufficientBalance(asset);\\n\\n      if (assetAmount != 0) {\\n        finalPercentages[asset].std =\\n          uint128(uint256(assetAmount) * SCALING_FACTOR / uint256(balance));\\n        concentrationAmounts[asset].std = assetAmount;\\n      }\\n\\n      if (govAmount != 0) {\\n        finalPercentages[asset].gov =\\n          uint128(uint256(govAmount) * SCALING_FACTOR / uint256(govBalance));\\n        concentrationAmounts[asset].gov = govAmount;\\n      }\\n    }\\n    concentrationsSet = true;\\n    emit ConcentrationAmountsSet(amounts, govAmounts);\\n  }\\n\\n  ///@notice Requests deposit of assets into fyde\\n  ///@dev due to gas limitations deposits a maximum of 5 assets with and without governance, has to\\n  /// be called multiple times until all assets are transferred\\n  function depositToFyde() external payable {\\n    if (uint128(block.timestamp) <= FREEZE_PERIOD) revert InvalidTimePeriod();\\n    if (!concentrationsSet) revert ConcentrationsNotSet();\\n    if (fydeDepositCompleted) revert FydeDepositCompleted();\\n    if (revoked) revert Revoked();\\n    (, uint72 taxFactor,,,,) = FYDE.protocolData();\\n    if (taxFactor != 0) revert TaxFactorNotZero();\\n\\n    address[] memory assetsList = assets;\\n\\n    uint256 assetsToTransfer = assetsList.length - assetsTransferred;\\n    assetsToTransfer =\\n      assetsToTransfer < MAX_ASSET_TO_REQUEST ? assetsToTransfer : MAX_ASSET_TO_REQUEST;\\n\\n    uint256 stdRequestLength;\\n    uint256 govRequestLength;\\n    for (uint256 i = assetsTransferred; i < assetsTransferred + assetsToTransfer; ++i) {\\n      if (keepGovAllowed[assetsList[i]] && concentrationAmounts[assetsList[i]].gov != 0) {\\n        govRequestLength += 1;\\n      }\\n      if (concentrationAmounts[assetsList[i]].std != 0) stdRequestLength += 1;\\n    }\\n\\n    UserRequest[] memory stdRequest = new UserRequest[](stdRequestLength);\\n    UserRequest[] memory govRequest = new UserRequest[](govRequestLength);\\n\\n    uint256 sIdx;\\n    uint256 gIdx;\\n    uint256 totalUSDValue;\\n    for (uint256 i = assetsTransferred; i < assetsTransferred + assetsToTransfer; ++i) {\\n      uint256 totalAmount = 0;\\n      if (concentrationAmounts[assetsList[i]].std != 0) {\\n        // populate request array\\n        stdRequest[sIdx].asset = assetsList[i];\\n        stdRequest[sIdx].amount = concentrationAmounts[assetsList[i]].std;\\n        totalAmount += stdRequest[sIdx].amount;\\n        // track deposited value\\n        uint256 usdValue = FYDE.getQuote(stdRequest[sIdx].asset, stdRequest[sIdx].amount);\\n        if (usdValue == 0) revert PriceNotAvailable(assetsList[i]);\\n        totalUSDValue += usdValue;\\n        TRSYBalancesPerAsset[stdRequest[sIdx].asset].std = uint128(usdValue);\\n\\n        sIdx += 1;\\n      }\\n\\n      if (keepGovAllowed[assetsList[i]] && concentrationAmounts[assetsList[i]].gov != 0) {\\n        govRequest[gIdx].asset = assetsList[i];\\n        govRequest[gIdx].amount = concentrationAmounts[assetsList[i]].gov;\\n        totalAmount += govRequest[gIdx].amount;\\n        gIdx += 1;\\n      }\\n\\n      IERC20(assetsList[i]).forceApprove(address(FYDE), totalAmount);\\n    }\\n\\n    totalExpectedTrsy += totalUSDValue;\\n\\n    uint256 ETHToForward = ORACLE.getGweiPrice() * GAS_TO_FORWARD;\\n    if (stdRequestLength != 0) RELAYER.requestDeposit{value: ETHToForward}(stdRequest, false, 0);\\n    if (govRequestLength != 0) RELAYER.requestDeposit{value: ETHToForward}(govRequest, true, 0);\\n\\n    assetsTransferred += assetsToTransfer;\\n    if (assetsTransferred == assetsList.length) {\\n      fydeDepositCompleted = true;\\n      emit FydeDeposit();\\n    }\\n  }\\n\\n  ///@notice Rescale TrsyBalance to be correct. Has to be called after bootstrapLiquidity and before\\n  /// claiming\\n  ///@dev At the time of transferring funds into fyde, we dont know the current AUM/TRSY price to\\n  /// get the amount of trsy we got per asset.\\n  /// We therefore only store the USD values which are proportional to the correct TRSY balance in\\n  /// TRSYBalancesPerAsset. After the deposit has been processed,\\n  /// This function is called to check the actual amount of TRSY minted and rescale the balances\\n  function updateInternalAccounting() external {\\n    if (!fydeDepositCompleted) revert FydeDepositNotCompleted();\\n    // make sure rescale is not called when processing still in progress by checking queue is empty\\n    if (RELAYER.getNumPendingRequest() != 0) revert DepositsMightStillBeProcessed();\\n\\n    uint256 actualTrsyBalance = IERC20(address(FYDE)).balanceOf(address(this));\\n\\n    // SCALING_FACTOR to ensure precision when dividing\\n    uint256 scalingFactor;\\n    if (totalExpectedTrsy != 0) {\\n      scalingFactor = SCALING_FACTOR * actualTrsyBalance / totalExpectedTrsy;\\n    }\\n\\n    for (uint256 i; i < assets.length; ++i) {\\n      address asset = assets[i];\\n      uint128 rescaledTrsy =\\n        uint128(uint256(TRSYBalancesPerAsset[asset].std) * scalingFactor / SCALING_FACTOR);\\n      TRSYBalancesPerAsset[asset].std = rescaledTrsy;\\n      // for governance we exactly know the balance for each asset - the sTRSY.balanceOf\\n      if (keepGovAllowed[asset]) {\\n        TRSYBalancesPerAsset[asset].gov =\\n          uint128(GOVERNANCE_MODULE.strsyBalance(address(this), asset));\\n      }\\n    }\\n\\n    internalAccountingUpdated = true;\\n    emit InternalAccountingUpdated();\\n  }\\n\\n  ///@notice User claim their TRSY, sTRSY and refund\\n  ///@param assetsToClaim Assets for which to claim\\n  function claimAndRefund(address[] calldata assetsToClaim) external {\\n    if (revoked) revert Revoked();\\n    if (!fydeDepositCompleted) revert FydeDepositNotCompleted();\\n    if (!internalAccountingUpdated) revert InternalAccountingNotUpdated();\\n    uint256 totalClaimedTrsy;\\n    for (uint256 i; i < assetsToClaim.length; ++i) {\\n      address asset = assetsToClaim[i];\\n      uint256 standardDeposit = deposits[msg.sender][asset].std;\\n      uint256 govDeposit = deposits[msg.sender][asset].gov;\\n      uint256 totalDeposit = standardDeposit + govDeposit;\\n      if (totalDeposit == 0) revert CannotClaimForAsset(asset);\\n      // Update their orginal deposit balance\\n      uint256 refundAmount = totalDeposit;\\n\\n      if (standardDeposit > 0) {\\n        deposits[msg.sender][asset].std = 0;\\n        uint256 standardFundsUsed =\\n          standardDeposit * uint256(finalPercentages[asset].std) / SCALING_FACTOR;\\n        uint256 claimTRSY;\\n        if (concentrationAmounts[asset].std != 0) {\\n          claimTRSY = standardFundsUsed * uint256(TRSYBalancesPerAsset[asset].std)\\n            / uint256(concentrationAmounts[asset].std);\\n        }\\n        totalClaimedTrsy += claimTRSY;\\n        refundAmount -= standardFundsUsed;\\n      }\\n\\n      if (govDeposit > 0) {\\n        deposits[msg.sender][asset].gov = 0;\\n        uint256 govFundsUsed = govDeposit * uint256(finalPercentages[asset].gov) / SCALING_FACTOR;\\n        uint256 claimStakedTRSY;\\n        if (concentrationAmounts[asset].gov != 0) {\\n          claimStakedTRSY = govFundsUsed * uint256(TRSYBalancesPerAsset[asset].gov)\\n            / uint256(concentrationAmounts[asset].gov);\\n        }\\n        refundAmount -= govFundsUsed;\\n        IERC20(GOVERNANCE_MODULE.assetToStrsy(asset)).transfer(msg.sender, claimStakedTRSY);\\n      }\\n      // Refund user, make sure balance not exceeded in case of rounding error\\n      if (refundAmount > 0) {\\n        uint256 escrowBalance = IERC20(asset).balanceOf(address(this));\\n        refundAmount = escrowBalance > refundAmount ? refundAmount : escrowBalance;\\n        IERC20(asset).safeTransfer(msg.sender, refundAmount);\\n      }\\n    }\\n\\n    // send all standard TRSY\\n    IERC20(address(FYDE)).transfer(msg.sender, totalClaimedTrsy);\\n\\n    emit ClaimedAndRefunded(msg.sender);\\n  }\\n\\n  ///@notice User claim their refund if escrow has been revoked\\n  function refund(address[] calldata assetsToRefund) external {\\n    if (!revoked) revert NotRevoked();\\n    for (uint256 i; i < assetsToRefund.length; ++i) {\\n      address asset = assetsToRefund[i];\\n      uint256 totalDeposit = deposits[msg.sender][asset].std + deposits[msg.sender][asset].gov;\\n      deposits[msg.sender][asset].std = 0;\\n      deposits[msg.sender][asset].gov = 0;\\n      IERC20(asset).safeTransfer(msg.sender, totalDeposit);\\n      emit Refunded(msg.sender, asset, totalDeposit);\\n    }\\n  }\\n\\n  ///@notice Abort escrow period and allows user to claim their refund\\n  function revoke() external onlyOwner {\\n    uint128 time = uint128(block.timestamp);\\n    if (time < ESCROW_PERIOD || time > FREEZE_PERIOD) revert OnlyDuringFreeze();\\n    revoked = true;\\n    emit EscrowRevoked();\\n  }\\n\\n  ///@notice Recovers funds in case something goes wrong\\n  function returnStuckFunds(address _asset, address _to, uint256 _amount) external onlyOwner {\\n    IERC20(_asset).safeTransfer(_to, _amount);\\n  }\\n\\n  function get_assets() external view returns (address[] memory) {\\n    return assets;\\n  }\\n\\n  ///@notice Returns estimated TRSY for user\\n  ///@dev Have to be call for front end purpose after updateInternalAccounting\\n  function getEstimatedTrsy(address _user, address _asset) public view returns (uint256, uint256) {\\n    Slot memory balance = totalBalance[_asset];\\n    Slot memory trsy = TRSYBalancesPerAsset[_asset];\\n    Slot memory dep = deposits[_user][_asset];\\n\\n    uint256 stdExpTrsy =\\n      trsy.std != 0 ? uint256(trsy.std) * uint256(dep.std) / (uint256(balance.std)) : 0;\\n    uint256 govExpTrsy =\\n      trsy.gov != 0 ? uint256(trsy.gov) * uint256(dep.gov) / (uint256(balance.gov)) : 0;\\n\\n    return (stdExpTrsy, govExpTrsy);\\n  }\\n\\n  ///@dev checks whitelist to allow deposits\\n  modifier onlyUser() {\\n    if (!isUser[address(0x0)] && !isUser[msg.sender]) revert Unauthorized();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/core/Structs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.19;\\n\\nstruct AssetInfo {\\n  uint72 targetConcentration;\\n  address uniswapPool;\\n  int72 incentiveFactor;\\n  uint8 assetDecimals;\\n  uint8 quoteTokenDecimals;\\n  address uniswapQuoteToken;\\n  bool isSupported;\\n}\\n\\nstruct ProtocolData {\\n  ///@notice Protocol AUM in USD\\n  uint256 aum;\\n  ///@notice multiplicator for the tax equation, 100% = 100e18\\n  uint72 taxFactor;\\n  ///@notice Max deviation allowed between AUM from keeper and registry\\n  uint16 maxAumDeviationAllowed; // Default val 200 == 2 %\\n  ///@notice block number where AUM was last updated\\n  uint48 lastAUMUpdateBlock;\\n  ///@notice annual fee on AUM, in % per year 100% = 100e18\\n  uint72 managementFee;\\n  ///@notice last block.timestamp when fee was collected\\n  uint48 lastFeeCollectionTime;\\n}\\n\\nstruct UserRequest {\\n  address asset;\\n  uint256 amount;\\n}\\n\\nstruct RequestData {\\n  uint32 id;\\n  address requestor;\\n  address[] assetIn;\\n  uint256[] amountIn;\\n  address[] assetOut;\\n  uint256[] amountOut;\\n  bool keepGovRights;\\n  uint256 slippageChecker;\\n}\\n\\nstruct RequestQ {\\n  uint64 start;\\n  uint64 end;\\n  mapping(uint64 => RequestData) requestData;\\n}\\n\\nstruct ProcessParam {\\n  uint256 targetConc;\\n  uint256 currentConc;\\n  uint256 usdValue;\\n  uint256 taxableAmount;\\n  uint256 taxInUSD;\\n  uint256 sharesBeforeTax;\\n  uint256 sharesAfterTax;\\n}\\n\\nstruct RebalanceParam {\\n  address asset;\\n  uint256 assetTotalAmount;\\n  uint256 assetProxyAmount;\\n  uint256 assetPrice;\\n  uint256 sTrsyTotalSupply;\\n  uint256 trsyPrice;\\n}\\n\"\r\n    },\r\n    \"src/utils/BaseChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.19;\\n\\nabstract contract BaseChecker {\\n  error ZeroParameter();\\n  error InconsistentLengths();\\n\\n  function _checkZeroValue(uint256 val) internal pure {\\n    if (val == 0) revert ZeroParameter();\\n  }\\n\\n  function _checkZeroAddress(address addr) internal pure {\\n    if (addr == address(0x0)) revert ZeroParameter();\\n  }\\n\\n  function _checkForConsistentLength(address[] memory arr1, uint256[] memory arr2) internal pure {\\n    if (arr1.length != arr2.length) revert InconsistentLengths();\\n  }\\n}\\n\"\r\n    },\r\n    \"src/utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\n///@title Ownable contract\\n/// @notice Simple 2step owner authorization combining solmate and OZ implementation\\nabstract contract Ownable {\\n  /*//////////////////////////////////////////////////////////////\\n                             STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n  ///@notice Address of the owner\\n  address public owner;\\n\\n  ///@notice Address of the pending owner\\n  address public pendingOwner;\\n\\n  /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n  event OwnershipTransferred(address indexed user, address indexed newOner);\\n  event OwnershipTransferStarted(address indexed user, address indexed newOwner);\\n  event OwnershipTransferCanceled(address indexed pendingOwner);\\n\\n  /*//////////////////////////////////////////////////////////////\\n                                 ERROR\\n    //////////////////////////////////////////////////////////////*/\\n\\n  error Unauthorized();\\n\\n  /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n  constructor(address _owner) {\\n    owner = _owner;\\n\\n    emit OwnershipTransferred(address(0), _owner);\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n  ///@notice Transfer ownership to a new address\\n  ///@param newOwner address of the new owner\\n  ///@dev newOwner have to acceptOwnership\\n  function transferOwnership(address newOwner) external onlyOwner {\\n    pendingOwner = newOwner;\\n    emit OwnershipTransferStarted(msg.sender, pendingOwner);\\n  }\\n\\n  ///@notice NewOwner accept the ownership, it transfer the ownership to newOwner\\n  function acceptOwnership() external {\\n    if (msg.sender != pendingOwner) revert Unauthorized();\\n    address oldOwner = owner;\\n    owner = pendingOwner;\\n    delete pendingOwner;\\n    emit OwnershipTransferred(oldOwner, owner);\\n  }\\n\\n  ///@notice Cancel the ownership transfer\\n  function cancelTransferOwnership() external onlyOwner {\\n    emit OwnershipTransferCanceled(pendingOwner);\\n    delete pendingOwner;\\n  }\\n\\n  modifier onlyOwner() {\\n    if (msg.sender != owner) revert Unauthorized();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IFyde.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\nimport {RequestData, RebalanceParam, ProcessParam} from \\\"src/core/Structs.sol\\\";\\n\\ninterface IFyde {\\n  function protocolData() external view returns (uint256, uint72, uint16, uint48, uint72, uint48);\\n\\n  function isAnyNotSupported(address[] calldata _assets) external view returns (address);\\n\\n  function isSwapAllowed(address[] calldata _assets) external view returns (address);\\n\\n  function computeProtocolAUM() external view returns (uint256);\\n\\n  function getProtocolAUM() external view returns (uint256);\\n\\n  function updateProtocolAUM(uint256) external;\\n\\n  function processDeposit(uint256, RequestData calldata) external returns (uint256);\\n\\n  function processWithdraw(uint256, RequestData calldata) external returns (uint256);\\n\\n  function totalAssetAccounting(address) external view returns (uint256);\\n\\n  function proxyAssetAccounting(address) external view returns (uint256);\\n\\n  function standardAssetAccounting(address) external view returns (uint256);\\n\\n  function getQuote(address, uint256) external view returns (uint256);\\n\\n  function getAssetDecimals(address) external view returns (uint8);\\n\\n  function collectManagementFee() external;\\n\\n  function processSwap(uint256, RequestData calldata) external returns (int256);\\n\\n  function getProcessParamDeposit(RequestData memory _req, uint256 _protocolAUM)\\n    external\\n    view\\n    returns (\\n      ProcessParam[] memory processParam,\\n      uint256 sharesToMint,\\n      uint256 taxInTRSY,\\n      uint256 totalUsdDeposit\\n    );\\n\\n  // GOVERNANCE ACCESS FUNCTIONS\\n\\n  function transferAsset(address _asset, address _recipient, uint256 _amount) external;\\n\\n  function getRebalanceParams(address _asset) external view returns (RebalanceParam memory);\\n\\n  function updateAssetProxyAmount(address _asset, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IGovernanceModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\ninterface IGovernanceModule {\\n  function fyde() external view returns (address);\\n\\n  function proxyImplementation() external view returns (address);\\n\\n  function proxyBalance(address proxy, address asset) external view returns (uint256);\\n\\n  function strsyBalance(address _user, address _govToken) external view returns (uint256 balance);\\n\\n  function assetToStrsy(address _asset) external view returns (address);\\n\\n  function userToProxy(address _user) external view returns (address);\\n\\n  function proxyToUser(address _proxy) external view returns (address);\\n\\n  function isOnGovernanceWhitelist(address _asset) external view returns (bool);\\n\\n  function getAllGovUsers() external view returns (address[] memory);\\n\\n  function isAnyNotOnGovWhitelist(address[] calldata _assets) external view returns (address);\\n\\n  function getUserGTAllowance(uint256 _TRSYAmount, address _token) external view returns (uint256);\\n\\n  function govDeposit(\\n    address _depositor,\\n    address[] calldata _govToken,\\n    uint256[] calldata _amount,\\n    uint256[] calldata _amountTRSY,\\n    uint256 _totalTRSY\\n  ) external returns (address proxy);\\n\\n  function govWithdraw(\\n    address _user,\\n    address _asset,\\n    uint256 _amountToWithdraw,\\n    uint256 _trsyToBurn\\n  ) external;\\n\\n  function onStrsyTransfer(address sender, address _recipient) external;\\n\\n  function unstakeGov(uint256 _amount, address _asset) external;\\n\\n  function rebalanceProxy(address _proxy, address _asset, address[] memory _usersToRebalance)\\n    external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IOracle.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\nimport {AssetInfo} from \\\"../core/Structs.sol\\\";\\n\\ninterface IOracle {\\n  function getPriceInUSD(address, AssetInfo calldata) external view returns (uint256);\\n\\n  function getGweiPrice() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IRelayer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\nimport {RequestData, UserRequest} from \\\"../core/Structs.sol\\\";\\n\\ninterface IRelayer {\\n  function getNumPendingRequest() external view returns (uint256);\\n\\n  function getRequest(uint64 idx) external view returns (RequestData memory);\\n\\n  function requestGovernanceWithdraw(\\n    UserRequest memory _userRequest,\\n    address _user,\\n    uint256 _maxTRSYToPay\\n  ) external payable;\\n\\n  function requestWithdraw(UserRequest[] memory _userRequest, uint256 _maxTRSYToPay)\\n    external\\n    payable;\\n\\n  function requestDeposit(\\n    UserRequest[] memory _userRequest,\\n    bool _keepGovRights,\\n    uint256 _minTRSYExpected\\n  ) external payable;\\n\\n  function requestSwap(\\n    address _assetIn,\\n    uint256 _amountIn,\\n    address _assetOut,\\n    uint256 _minAmountOut\\n  ) external payable;\\n\\n  function processRequests(uint256 _protocolAUM) external;\\n\\n  function isQuarantined(address _asset) external view returns (bool);\\n\\n  function isIncentiveManager(address _incentiveManager) external view returns (bool);\\n\\n  function MAX_ASSET_TO_REQUEST() external view returns (uint8);\\n\\n  function actionToGasUsage(bytes32 _actionHash) external view returns (uint256);\\n\\n  function isUser(address _asset) external view returns (bool);\\n\\n  function isAnyQuarantined(address[] memory _assets) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@uniswap/v3-core/=lib/v3-core/\",\r\n      \"@uniswap/v3-periphery/=lib/v3-periphery/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"synthetix-v3/=lib/synthetix-v3/\",\r\n      \"v3-core/=lib/v3-core/contracts/\",\r\n      \"v3-periphery/=lib/v3-periphery/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assets\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_keepGovAllowed\",\"type\":\"bool[]\"},{\"internalType\":\"address\",\"name\":\"_fyde\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_governanceModule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_escrowPeriod\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_freezePeriod\",\"type\":\"uint128\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"CannotClaimForAsset\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ConcentrationsNotSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DepositsMightStillBeProcessed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EscrowPeriodEnded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FydeDepositCompleted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FydeDepositNotCompleted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InconsistentLengths\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InternalAccountingNotUpdated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTimePeriod\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotRevoked\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"NotSupportedAsset\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyDuringFreeze\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"PriceNotAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Revoked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TaxFactorNotZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroParameter\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AssetDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ClaimedAndRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128[]\",\"name\":\"amounts\",\"type\":\"uint128[]\"},{\"indexed\":false,\"internalType\":\"uint128[]\",\"name\":\"govAmounts\",\"type\":\"uint128[]\"}],\"name\":\"ConcentrationAmountsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EscrowRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FydeDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"InternalAccountingUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refund\",\"type\":\"uint256\"}],\"name\":\"Refunded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ESCROW_PERIOD\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FREEZE_PERIOD\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FYDE\",\"outputs\":[{\"internalType\":\"contract IFyde\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GAS_TO_FORWARD\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GOVERNANCE_MODULE\",\"outputs\":[{\"internalType\":\"contract IGovernanceModule\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_ASSET_TO_REQUEST\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ORACLE\",\"outputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RELAYER\",\"outputs\":[{\"internalType\":\"contract IRelayer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"TRSYBalancesPerAsset\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"std\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"gov\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_user\",\"type\":\"address[]\"}],\"name\":\"addUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"assets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetsTransferred\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelTransferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assetsToClaim\",\"type\":\"address[]\"}],\"name\":\"claimAndRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"collectEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"concentrationAmounts\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"std\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"gov\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"concentrationsSet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"keepGovRights\",\"type\":\"bool\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositToFyde\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"std\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"gov\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"finalPercentages\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"std\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"gov\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fydeDepositCompleted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getEstimatedTrsy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_assets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"internalAccountingUpdated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"keepGovAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assetsToRefund\",\"type\":\"address[]\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_user\",\"type\":\"address[]\"}],\"name\":\"removeUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"returnStuckFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revoked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128[]\",\"name\":\"amounts\",\"type\":\"uint128[]\"},{\"internalType\":\"uint128[]\",\"name\":\"govAmounts\",\"type\":\"uint128[]\"}],\"name\":\"setConcentrationAmounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supportedAssets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalBalance\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"std\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"gov\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalExpectedTrsy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateInternalAccounting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PooledDepositEscrow", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000044000000000000000000000000087cc45fff5c0933bb6af6bae7fc013b7ec7df2ee00000000000000000000000094194de310b99d3c8a5b8c0768cfce7aef81d9be000000000000000000000000c6f50903a058f3807111619bd4b24ca64b8239e10000000000000000000000009b122361e8708be33b785e44fce4d6ca86ab6c5a0000000000000000000000000000000000000000000000000000000000188089000000000000000000000000000000000000000000000000000000000001fa7c0000000000000000000000000000000000000000000000000000000000000019000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c5990000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000007f39c581f595b53c5cb19bd0b3f8da6c935e2ca0000000000000000000000000ae78736cd615f374d3085123a210448e74fc6393000000000000000000000000d533a949740bb3306d119cc777fa900ba034cd52000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca000000000000000000000000320623b8e4ff03373931769a31fc52a4e78b5d70000000000000000000000000e76c6c83af64e4c60245d8c7de953df673a7a33d000000000000000000000000102c776ddb30c754ded4fdcc77a19230a60d4e4f000000000000000000000000738865301a9b7dd80dc3666dd48cf034ec42bdda00000000000000000000000066761fa41377003622aee3c7675fc7b5c1c2fac5000000000000000000000000ec67005c4e498ec7f55e092bd1d35cbc47c918920000000000000000000000001a7e4e63778b4f12a199c062f3efdd288afcbce8000000000000000000000000853d955acef822db058eb8505911ed77f175b99e0000000000000000000000006b3595068778dd592e39a122f4f5a5cf09c90fe20000000000000000000000003472a5a71965499acd81997a54bba8d852c6e53d0000000000000000000000003c3a81e81dc49a522a592e7622a7e711c06bf35400000000000000000000000062d0a8458ed7719fdaf978fe5929c6d342b0bfce000000000000000000000000c55126051b22ebb829d00368f4b12bde432de5da000000000000000000000000375abb85c329753b1ba849a601438ae77eec98930000000000000000000000008207c1ffc5b6804f6024322ccf34f29c3541ae260000000000000000000000009aab071b4129b083b01cb5a0cb513ce7eca26fa500000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}