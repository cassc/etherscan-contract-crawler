{"SourceCode": "pragma solidity ^0.4.26;\r\n\r\ncontract LuckyCredits\r\n{\r\n     using SafeMath for uint256;\r\n\r\n\r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens\r\n    );\r\n\r\n    event onBuyEvent(\r\n        address from,\r\n        uint256 tokens\r\n    );\r\n\r\n     event onSellEvent(\r\n        address from,\r\n        uint256 tokens\r\n    );\r\n\r\n\r\n    /*==============================\r\n    =            MODIFIERS         =\r\n    ==============================*/\r\n\r\n    bool isActive = false;\r\n\r\n    modifier isActivated {\r\n        require(isActive == true || msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner\r\n    {\r\n        require (msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyFromGameWhiteListed\r\n    {\r\n        require (gameWhiteListed[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    modifier onlyTokenHolders() {\r\n        require(myTokens() > 0);\r\n        _;\r\n    }\r\n\r\n    address public owner;\r\n\r\n    constructor () public\r\n    {\r\n        owner = address(0x72bEe2Cf43f658F3EdF5f4E08bAB03b5F777FA0A);\r\n    }\r\n\r\n    /*==============================\r\n    =       TOKEN VARIABLES        =\r\n    ==============================*/\r\n\r\n    string public name = \"CREDITS token\";\r\n    string public symbol = \"CREDITS\";\r\n    uint8 constant public decimals = 18;\r\n    uint256 constant internal magnitude = 1e18;\r\n\r\n    uint8 constant internal transferFee = 1;\r\n    uint8 internal buyInFee = 7;\r\n    uint8 internal sellOutFee = 7;\r\n    uint8 internal devFee = 3;\r\n\r\n    mapping(address => uint256) public investedETH;\r\n    mapping(address => uint256) private tokenBalanceLedger;\r\n\r\n    uint256 public totalInvestor = 0;\r\n    uint256 public totalDonation = 0;\r\n\r\n    uint256 private tokenSupply = 0;\r\n    uint256 private contractValue = 0;\r\n    uint256 private tokenPrice = 0.001 ether;   //starting price\r\n\r\n\r\n   /*================================\r\n    =       CREDITS VARIABLES         =\r\n    ================================*/\r\n\r\n    mapping(address => bool) private gameWhiteListed;\r\n\r\n    /*================================\r\n    =       PUBLIC FUNCTIONS         =\r\n    ================================*/\r\n\r\n     /**\r\n     * Fallback function to process ethereum\r\n     */\r\n    function()\r\n        payable\r\n        public\r\n    {\r\n        appreciateTokenPrice();\r\n    }\r\n\r\n    function addGame(address _contractAddress) public\r\n    onlyOwner\r\n    {\r\n        gameWhiteListed[_contractAddress] = true;\r\n    }\r\n\r\n    function removeGame(address _contractAddress) public\r\n    onlyOwner\r\n    {\r\n        gameWhiteListed[_contractAddress] = false;\r\n    }\r\n\r\n    function buyTokenSub(uint256 _eth , address _customerAddress) private\r\n    returns(uint256)\r\n    {\r\n\r\n        uint256 _nb_token = (_eth.mul(magnitude)) / tokenPrice;\r\n\r\n        tokenBalanceLedger[_customerAddress] =  tokenBalanceLedger[_customerAddress].add(_nb_token);\r\n        tokenSupply = tokenSupply.add(_nb_token);\r\n\r\n        emit onBuyEvent(_customerAddress , _nb_token);\r\n\r\n        return(_nb_token);\r\n\r\n    }\r\n\r\n    function buyTokenFromGame(address _customerAddress) public payable\r\n    onlyFromGameWhiteListed\r\n    returns(uint256)\r\n    {\r\n        uint256 _eth = msg.value;\r\n\r\n        require(_eth>=0.0001 ether);\r\n\r\n        if (getInvested() == 0)\r\n        {\r\n            totalInvestor = totalInvestor.add(1);\r\n        }\r\n\r\n        investedETH[msg.sender] = investedETH[msg.sender].add(_eth);\r\n\r\n        uint256 _devfee = (_eth.mul(devFee)) / 100;\r\n        uint256 _fee = (_eth.mul(buyInFee)) / 100;\r\n\r\n        buyTokenSub((_devfee.mul(100-buyInFee)) / 100 , owner);\r\n\r\n        //finally buy for the buyer\r\n        uint256 _nb_token = buyTokenSub(_eth - _fee -_devfee, _customerAddress);\r\n\r\n        //add the value to the contract\r\n        contractValue = contractValue.add(_eth);\r\n\r\n        if (tokenSupply>magnitude)\r\n        {\r\n            tokenPrice = (contractValue.mul(magnitude)) / tokenSupply;\r\n        }\r\n\r\n        return(_nb_token);\r\n\r\n    }\r\n\r\n\r\n    function buyToken() public payable\r\n    isActivated\r\n    returns(uint256)\r\n    {\r\n        if (isActive == false){\r\n          isActive = true;\r\n        }\r\n\r\n        uint256 _eth = msg.value;\r\n        address _customerAddress = msg.sender;\r\n\r\n        require(_eth>=0.0001 ether);\r\n\r\n        if (getInvested() == 0)\r\n        {\r\n            totalInvestor = totalInvestor.add(1);\r\n        }\r\n\r\n        investedETH[msg.sender] = investedETH[msg.sender].add(_eth);\r\n\r\n        uint256 _devfee = (_eth.mul(devFee)) / 100;\r\n        uint256 _fee = (_eth.mul(buyInFee)) / 100;\r\n\r\n        buyTokenSub((_devfee.mul(100-buyInFee)) / 100 , owner);\r\n\r\n        //finally buy for the buyer\r\n        uint256 _nb_token = buyTokenSub(_eth - _fee -_devfee, _customerAddress);\r\n\r\n        //add the value to the contract\r\n        contractValue = contractValue.add(_eth);\r\n\r\n        if (tokenSupply>magnitude)\r\n        {\r\n            tokenPrice = (contractValue.mul(magnitude)) / tokenSupply;\r\n        }\r\n\r\n        return(_nb_token);\r\n\r\n    }\r\n\r\n    function sellToken(uint256 _amount) public\r\n    isActivated\r\n    onlyTokenHolders\r\n    {\r\n        address _customerAddress = msg.sender;\r\n\r\n        uint256 balance = tokenBalanceLedger[_customerAddress];\r\n\r\n        require(_amount <= balance);\r\n\r\n        uint256 _eth = (_amount.mul(tokenPrice)) / magnitude;\r\n\r\n        uint256 _fee = (_eth.mul(sellOutFee)) / 100;\r\n        uint256 _devfee = (_eth.mul(devFee)) / 100;\r\n\r\n        tokenSupply = tokenSupply.sub(_amount);\r\n\r\n        balance = balance.sub(_amount);\r\n\r\n        tokenBalanceLedger[_customerAddress] = balance;\r\n\r\n        buyTokenSub((_devfee.mul(100-sellOutFee)) / 100 , owner);\r\n\r\n        //calculate what is really leaving the contract, basically eth-fee-devfee\r\n        _eth = _eth - _fee - _devfee;\r\n\r\n        contractValue = contractValue.sub(_eth);\r\n\r\n        if (tokenSupply>magnitude)\r\n        {\r\n            tokenPrice = (contractValue.mul(magnitude)) / tokenSupply;\r\n        }\r\n\r\n         emit onSellEvent(_customerAddress , _amount);\r\n\r\n         //finally transfer the money\r\n        _customerAddress.transfer(_eth);\r\n\r\n    }\r\n\r\n    //there is no fee using token to play CREDITS powered games\r\n\r\n    function payWithToken(uint256 _eth ,address _player_address) public\r\n    onlyFromGameWhiteListed\r\n    returns(uint256)\r\n    {\r\n        require(_eth>0 && _eth <= ethBalanceOfNoFee(_player_address));\r\n\r\n        address _game_contract = msg.sender;\r\n\r\n        uint256 balance = tokenBalanceLedger[_player_address];\r\n\r\n        uint256 _nb_token = (_eth.mul(magnitude)) / tokenPrice;\r\n\r\n        require(_nb_token <= balance);\r\n\r\n        //confirm the ETH value\r\n        _eth = (_nb_token.mul(tokenPrice)) / magnitude;\r\n\r\n        balance = balance.sub(_nb_token);\r\n\r\n        tokenSupply = tokenSupply.sub(_nb_token);\r\n\r\n        tokenBalanceLedger[_player_address] = balance;\r\n\r\n        contractValue = contractValue.sub(_eth);\r\n\r\n        if (tokenSupply>magnitude)\r\n        {\r\n            tokenPrice = (contractValue.mul(magnitude)) / tokenSupply;\r\n        }\r\n\r\n        //send the money to the game contract\r\n        _game_contract.transfer(_eth);\r\n\r\n        return(_eth);\r\n    }\r\n\r\n    function appreciateTokenPrice() public payable\r\n    onlyFromGameWhiteListed\r\n    {\r\n        uint256 _eth =  msg.value;\r\n\r\n        contractValue = contractValue.add(_eth);\r\n        totalDonation = totalDonation.add(_eth);\r\n\r\n        //we need a minimum of 1 CREDITS before appreciation is activated\r\n        if (tokenSupply>magnitude)\r\n        {\r\n            tokenPrice = (contractValue.mul(magnitude)) / tokenSupply;\r\n        }\r\n    }\r\n\r\n    function transferSub(address _customerAddress, address _toAddress, uint256 _amountOfTokens)\r\n    private\r\n    returns(bool)\r\n    {\r\n\r\n        require(_amountOfTokens <= tokenBalanceLedger[_customerAddress]);\r\n\r\n        //actually a transfer of 0 token is valid in ERC20\r\n        if (_amountOfTokens>0)\r\n        {\r\n            {\r\n                uint256 _token_fee = (_amountOfTokens.mul(transferFee)) / 100;\r\n\r\n                //now proceed the transfer\r\n                tokenBalanceLedger[_customerAddress] = tokenBalanceLedger[_customerAddress].sub(_amountOfTokens);\r\n                tokenBalanceLedger[_toAddress] = tokenBalanceLedger[_toAddress].add(_amountOfTokens - _token_fee);\r\n\r\n                //burning the other half of token to drive the price up\r\n                tokenSupply = tokenSupply.sub(_token_fee);\r\n\r\n                if (tokenSupply>magnitude)\r\n                {\r\n                    tokenPrice = (contractValue.mul(magnitude)) / tokenSupply;\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        // fire event\r\n        emit Transfer(_customerAddress, _toAddress, _amountOfTokens);\r\n\r\n        // ERC20\r\n        return true;\r\n\r\n    }\r\n\r\n    function transfer(address _toAddress, uint256 _amountOfTokens) public\r\n    isActivated\r\n    returns(bool)\r\n    {\r\n        return(transferSub( msg.sender ,  _toAddress, _amountOfTokens));\r\n    }\r\n\r\n\r\n    /*================================\r\n    =  VIEW AND HELPERS FUNCTIONS    =\r\n    ================================*/\r\n\r\n\r\n    function totalEthereumBalance()\r\n        public\r\n        view\r\n        returns(uint)\r\n    {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function totalContractBalance()\r\n        public\r\n        view\r\n        returns(uint)\r\n    {\r\n        return contractValue;\r\n    }\r\n\r\n    function totalInvestor()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return totalInvestor;\r\n    }\r\n\r\n    function totalDonation()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return totalDonation;\r\n    }\r\n\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return tokenSupply;\r\n    }\r\n\r\n    function myTokens()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        return balanceOf(_customerAddress);\r\n    }\r\n\r\n    function balanceOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        return tokenBalanceLedger[_customerAddress];\r\n    }\r\n\r\n    function sellingPrice( bool includeFees)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        uint256 _fee = 0;\r\n        uint256 _devfee=0;\r\n\r\n        if (includeFees)\r\n        {\r\n            _fee = (tokenPrice.mul(sellOutFee)) / 100;\r\n            _devfee = (tokenPrice.mul(devFee)) / 100;\r\n        }\r\n\r\n        return(tokenPrice - _fee - _devfee);\r\n\r\n    }\r\n\r\n    function buyingPrice( bool includeFees)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        uint256 _fee = 0;\r\n        uint256 _devfee=0;\r\n\r\n        if (includeFees)\r\n        {\r\n            _fee = (tokenPrice.mul(buyInFee)) / 100;\r\n            _devfee = (tokenPrice.mul(devFee)) / 100;\r\n        }\r\n\r\n        return(tokenPrice + _fee + _devfee);\r\n\r\n    }\r\n\r\n    function calculateTokensReceived(uint256 _eth) public view returns (uint256) {\r\n        uint256 _devfee = (_eth.mul(devFee)) / 100;\r\n        uint256 _fee = (_eth.mul(buyInFee)) / 100;\r\n\r\n        uint256 _taxed_eth = _eth - _fee -_devfee;\r\n\r\n        uint256 _nb_token = (_taxed_eth.mul(magnitude)) / tokenPrice;\r\n\r\n        return(_nb_token);\r\n    }\r\n\r\n    function ethBalanceOf(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        uint256 _price = sellingPrice(true);\r\n\r\n        uint256 _balance = tokenBalanceLedger[_customerAddress];\r\n\r\n        uint256 _value = (_balance.mul(_price)) / magnitude;\r\n\r\n        return( _value );\r\n    }\r\n\r\n    function myEthBalanceOf()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        return ethBalanceOf(_customerAddress);\r\n    }\r\n\r\n    function ethBalanceOfNoFee(address _customerAddress)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        uint256 _price = sellingPrice(false);\r\n\r\n        uint256 _balance = tokenBalanceLedger[_customerAddress];\r\n\r\n        uint256 _value = (_balance.mul(_price)) / magnitude;\r\n\r\n        return( _value );\r\n    }\r\n\r\n    function myEthBalanceOfNoFee()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        return ethBalanceOfNoFee(_customerAddress);\r\n    }\r\n\r\n    function checkGameListed(address _contract)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n\r\n        return(gameWhiteListed[ _contract]);\r\n    }\r\n\r\n    function getInvested()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return investedETH[msg.sender];\r\n    }\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"includeFees\",\"type\":\"bool\"}],\"name\":\"sellingPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"appreciateTokenPrice\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sellToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_eth\",\"type\":\"uint256\"},{\"name\":\"_player_address\",\"type\":\"address\"}],\"name\":\"payWithToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthereumBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"ethBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInvestor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"ethBalanceOfNoFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toAddress\",\"type\":\"address\"},{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalContractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"removeGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"buyTokenFromGame\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInvested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myEthBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"includeFees\",\"type\":\"bool\"}],\"name\":\"buyingPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"addGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myEthBalanceOfNoFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investedETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"checkGameListed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDonation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"onBuyEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"onSellEvent\",\"type\":\"event\"}]", "ContractName": "LuckyCredits", "CompilerVersion": "v0.4.26+commit.4563c3fc", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://25da302815564cee68b5bc93192cc1e06c63755f98094dc3cfd3334f8b08a923"}