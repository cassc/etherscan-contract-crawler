{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"test.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\r\\n\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\\r\\n\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(\\r\\n            newOwner != address(0),\\r\\n            \\\"Ownable: new owner is the zero address\\\"\\r\\n        );\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\nlibrary Address {\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        uint256 size;\\r\\n        assembly {\\r\\n            size := extcodesize(account)\\r\\n        }\\r\\n        return size > 0;\\r\\n    }\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return\\r\\n            functionCallWithValue(\\r\\n                target,\\r\\n                data,\\r\\n                value,\\r\\n                \\\"Address: low-level call with value failed\\\"\\r\\n            );\\r\\n    }\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(\\r\\n            address(this).balance >= value,\\r\\n            \\\"Address: insufficient balance for call\\\"\\r\\n        );\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(\\r\\n            data\\r\\n        );\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data\\r\\n    ) internal view returns (bytes memory) {\\r\\n        return\\r\\n            functionStaticCall(\\r\\n                target,\\r\\n                data,\\r\\n                \\\"Address: low-level static call failed\\\"\\r\\n            );\\r\\n    }\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data\\r\\n    ) internal returns (bytes memory) {\\r\\n        return\\r\\n            functionDelegateCall(\\r\\n                target,\\r\\n                data,\\r\\n                \\\"Address: low-level delegate call failed\\\"\\r\\n            );\\r\\n    }\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            if (returndata.length > 0) {\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\nlibrary SafeERC20 {\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(\\r\\n            token,\\r\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        IERC20 token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        _callOptionalReturn(\\r\\n            token,\\r\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\r\\n        );\\r\\n    }\\r\\n    function safeApprove(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        require(\\r\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(\\r\\n            token,\\r\\n            abi.encodeWithSelector(token.approve.selector, spender, value)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\r\\n        _callOptionalReturn(\\r\\n            token,\\r\\n            abi.encodeWithSelector(\\r\\n                token.approve.selector,\\r\\n                spender,\\r\\n                newAllowance\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        unchecked {\\r\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\r\\n            require(\\r\\n                oldAllowance >= value,\\r\\n                \\\"SafeERC20: decreased allowance below zero\\\"\\r\\n            );\\r\\n            uint256 newAllowance = oldAllowance - value;\\r\\n            _callOptionalReturn(\\r\\n                token,\\r\\n                abi.encodeWithSelector(\\r\\n                    token.approve.selector,\\r\\n                    spender,\\r\\n                    newAllowance\\r\\n                )\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        bytes memory returndata = address(token).functionCall(\\r\\n            data,\\r\\n            \\\"SafeERC20: low-level call failed\\\"\\r\\n        );\\r\\n        if (returndata.length > 0) {\\r\\n            // Return data is optional\\r\\n            require(\\r\\n                abi.decode(returndata, (bool)),\\r\\n                \\\"SafeERC20: ERC20 operation did not succeed\\\"\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n}\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\n\\r\\ncontract Presale is Ownable , Pausable{\\r\\n    using SafeERC20 for IERC20;\\r\\n    using SafeERC20 for IERC20Metadata;\\r\\n    uint256[4] public rate;\\r\\n    address public saleToken;\\r\\n    uint public saleTokenDec;\\r\\n    uint256 public totalTokensforSale;\\r\\n    uint256 public maxBuyLimit;\\r\\n    uint256 public minBuyLimit;\\r\\n    mapping(address => bool) public tokenWL;\\r\\n    mapping(address => uint256[4]) public tokenPrices;\\r\\n    uint256 public presaleStartTime;\\r\\n    uint256 public presaleEndTime;\\r\\n    bool public isUnlockingStarted;\\r\\n    mapping(address => BuyerTokenDetails) public buyersAmount;\\r\\n    uint256 public totalTokensSold;\\r\\n\\r\\n    struct BuyerTokenDetails {\\r\\n        uint amount;\\r\\n        bool isClaimed;\\r\\n    }\\r\\n\\r\\n    constructor() {}\\r\\n    modifier isPresaleHasNotStarted() {\\r\\n        if (presaleStartTime != 0) {\\r\\n            require(\\r\\n                block.timestamp < presaleStartTime,\\r\\n                \\\"Presale: Presale has already started\\\"\\r\\n            );\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n    modifier isPresaleStarted() {\\r\\n        require(\\r\\n            block.timestamp >= presaleStartTime,\\r\\n            \\\"Presale: Presale has not started yet\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n    modifier isPresaleNotEnded() {\\r\\n        require(block.timestamp < presaleEndTime, \\\"Presale: Presale has ended\\\");\\r\\n        _;\\r\\n    }\\r\\n    modifier isPresaleEnded() {\\r\\n        require(\\r\\n            block.timestamp >= presaleEndTime,\\r\\n            \\\"Presale: Presale has not ended yet\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n    event TokenAdded(address token, uint256[4] price);\\r\\n    event TokenUpdated(address token, uint256[4] price);\\r\\n    event TokensBought(\\r\\n        address indexed buyer,\\r\\n        address indexed token,\\r\\n        uint256 amount,\\r\\n        uint256 tokensBought\\r\\n    );\\r\\n    event TokensUnlocked(address indexed buyer, uint256 amount);\\r\\n    event SaleTokenAdded(address token, uint256 amount);\\r\\n\\r\\n    function setSaleTokenParams(\\r\\n        address _saleToken,\\r\\n        uint256 _totalTokensforSale\\r\\n    ) external onlyOwner{\\r\\n        require(\\r\\n            _saleToken != address(0),\\r\\n            \\\"Presale: Sale token cannot be zero address\\\"\\r\\n        );\\r\\n        require(\\r\\n            _totalTokensforSale > 0,\\r\\n            \\\"Presale: Total tokens for sale cannot be zero\\\"\\r\\n        );\\r\\n        saleToken = _saleToken;\\r\\n        saleTokenDec = IERC20Metadata(saleToken).decimals();\\r\\n\\r\\n        IERC20(saleToken).safeTransferFrom(\\r\\n            msg.sender,\\r\\n            address(this),\\r\\n            _totalTokensforSale\\r\\n        );\\r\\n        totalTokensforSale = IERC20(saleToken).balanceOf(address(this));\\r\\n        emit SaleTokenAdded(_saleToken, _totalTokensforSale);\\r\\n    }\\r\\n\\r\\n    function startAndSetPresaleEndTime(\\r\\n        uint256 _presaleEndTime\\r\\n    ) external onlyOwner {\\r\\n        presaleStartTime = block.timestamp;\\r\\n        presaleEndTime = _presaleEndTime;\\r\\n    }\\r\\n\\r\\n    function updateTime(\\r\\n        uint256 _presaleEndTime\\r\\n    ) external onlyOwner {\\r\\n        presaleEndTime =  _presaleEndTime;\\r\\n    }\\r\\n\\r\\n    function addWhiteListedToken(\\r\\n        address _token,\\r\\n        uint256[4] memory _price\\r\\n    ) external onlyOwner {\\r\\n        tokenWL[_token] = true;\\r\\n        tokenPrices[_token] = _price;\\r\\n        emit TokenAdded(_token, _price);\\r\\n    }\\r\\n    function updateEthRate(uint256[4] memory _rate) external onlyOwner {\\r\\n        rate = _rate;\\r\\n    }\\r\\n    function updateTokenRate(\\r\\n        address _token,\\r\\n        uint256[4] memory _price\\r\\n    ) external onlyOwner {\\r\\n        require(tokenWL[_token], \\\"Presale: Token not whitelisted\\\");\\r\\n        tokenPrices[_token] = _price;\\r\\n        emit TokenUpdated(_token, _price);\\r\\n    }\\r\\n\\r\\n    function startUnlocking() external onlyOwner isPresaleEnded {\\r\\n        require(!isUnlockingStarted, \\\"Presale: Unlocking has already started\\\");\\r\\n        isUnlockingStarted = true;\\r\\n    }\\r\\n    function stopUnlocking() external onlyOwner isPresaleEnded {\\r\\n        require(isUnlockingStarted, \\\"Presale: Unlocking hasn't started yet!\\\");\\r\\n        isUnlockingStarted = false;\\r\\n    }\\r\\n\\r\\n\\r\\n \\r\\n    function getCurrentTier() public pure returns (uint) {\\r\\n        return 0;\\r\\n    }\\r\\n    \\r\\n    function getTokenAmount(\\r\\n        address token,\\r\\n        uint256 amount\\r\\n    ) public view returns (uint256) {\\r\\n        uint256 amtOut;\\r\\n        uint tier = getCurrentTier();\\r\\n        if (token != address(0)) {\\r\\n            require(tokenWL[token], \\\"Presale: Token not whitelisted\\\");\\r\\n\\r\\n            amtOut = tokenPrices[token][tier] != 0\\r\\n                ? (amount * (10 ** saleTokenDec)) / (tokenPrices[token][tier])\\r\\n                : 0;\\r\\n        } else {\\r\\n            amtOut = rate[tier] != 0\\r\\n                ? (amount * (10 ** saleTokenDec)) / (rate[tier])\\r\\n                : 0;\\r\\n        }\\r\\n        return amtOut;\\r\\n    }\\r\\n\\r\\n\\r\\n    function buyToken(\\r\\n        address _token,\\r\\n        uint256 _amount\\r\\n    ) external payable isPresaleStarted isPresaleNotEnded whenNotPaused{\\r\\n        uint256 saleTokenAmt = _token != address(0)\\r\\n            ? getTokenAmount(_token, _amount)\\r\\n            : getTokenAmount(address(0), msg.value);\\r\\n        require(\\r\\n            saleTokenAmt >= minBuyLimit,\\r\\n            \\\"Presale: Min buy limit not reached\\\"\\r\\n        );\\r\\n        require(\\r\\n            buyersAmount[msg.sender].amount + saleTokenAmt <= maxBuyLimit,\\r\\n            \\\"Presale: Max buy limit reached for this phase\\\"\\r\\n        );\\r\\n        require(\\r\\n            (totalTokensSold + saleTokenAmt) <= totalTokensforSale,\\r\\n            \\\"Presale: Total Token Sale Reached!\\\"\\r\\n        );\\r\\n\\r\\n        if (_token != address(0)) {\\r\\n            require(_amount > 0, \\\"Presale: Cannot buy with zero amount\\\");\\r\\n            require(tokenWL[_token], \\\"Presale: Token not whitelisted\\\");\\r\\n\\r\\n            IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\\r\\n        }\\r\\n\\r\\n        saleTokenAmt = saleTokenAmt ;\\r\\n\\r\\n        totalTokensSold += saleTokenAmt;\\r\\n        buyersAmount[msg.sender].amount += saleTokenAmt;\\r\\n\\r\\n        emit TokensBought(msg.sender, _token, _amount, saleTokenAmt);\\r\\n    }\\r\\n\\r\\n\\r\\n    function withdrawToken() external whenNotPaused {\\r\\n        require(isUnlockingStarted, \\\"Presale: Locking period not over yet\\\");\\r\\n\\r\\n        require(\\r\\n            !buyersAmount[msg.sender].isClaimed,\\r\\n            \\\"Presale: Already claimed\\\"\\r\\n        );\\r\\n\\r\\n        uint256 tokensforWithdraw = buyersAmount[msg.sender].amount;\\r\\n        buyersAmount[msg.sender].isClaimed = true;\\r\\n        IERC20(saleToken).safeTransfer(msg.sender, tokensforWithdraw);\\r\\n\\r\\n        emit TokensUnlocked(msg.sender, tokensforWithdraw);\\r\\n    }\\r\\n\\r\\n    function setMinBuyLimit(uint _minBuyLimit) external onlyOwner {\\r\\n        minBuyLimit = _minBuyLimit;\\r\\n    }\\r\\n\\r\\n    function setMaxBuyLimit(uint _maxBuyLimit) external onlyOwner {\\r\\n        maxBuyLimit = _maxBuyLimit;\\r\\n    }\\r\\n\\r\\n    function withdrawSaleToken(\\r\\n        uint256 _amount\\r\\n    ) external onlyOwner isPresaleEnded {\\r\\n        IERC20(saleToken).safeTransfer(msg.sender, _amount);\\r\\n    }\\r\\n\\r\\n    function withdrawAllSaleToken() external onlyOwner isPresaleEnded {\\r\\n        uint256 amt = IERC20(saleToken).balanceOf(address(this));\\r\\n        IERC20(saleToken).safeTransfer(msg.sender, amt);\\r\\n    }\\r\\n\\r\\n    function withdraw(address token, uint256 amt) public onlyOwner {\\r\\n        require(\\r\\n            token != saleToken,\\r\\n            \\\"Presale: Cannot withdraw sale token with this method, use withdrawSaleToken() instead\\\"\\r\\n        );\\r\\n        IERC20(token).safeTransfer(msg.sender, amt);\\r\\n    }\\r\\n\\r\\n    function withdrawAll(address token) public onlyOwner {\\r\\n        require(\\r\\n            token != saleToken,\\r\\n            \\\"Presale: Cannot withdraw sale token with this method, use withdrawAllSaleToken() instead\\\"\\r\\n        );\\r\\n        uint256 amt = IERC20(token).balanceOf(address(this));\\r\\n        withdraw(token, amt);\\r\\n    }\\r\\n\\r\\n    function withdrawCurrency(uint256 amt) public onlyOwner {\\r\\n        payable(msg.sender).transfer(amt);\\r\\n    }\\r\\n\\r\\n    // Function to pause the contract (only callable by the owner)\\r\\n    function pauseContract() external onlyOwner {\\r\\n        _pause();\\r\\n    }\\r\\n\\r\\n    // Function to unpause the contract (only callable by the owner)\\r\\n    function unpauseContract() external onlyOwner {\\r\\n       _unpause();\\r\\n    }\\r\\n\\r\\n    \\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SaleTokenAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[4]\",\"name\":\"price\",\"type\":\"uint256[4]\"}],\"name\":\"TokenAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[4]\",\"name\":\"price\",\"type\":\"uint256[4]\"}],\"name\":\"TokenUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensBought\",\"type\":\"uint256\"}],\"name\":\"TokensBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256[4]\",\"name\":\"_price\",\"type\":\"uint256[4]\"}],\"name\":\"addWhiteListedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buyToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"buyersAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isClaimed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isUnlockingStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBuyLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBuyLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presaleEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presaleStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleTokenDec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxBuyLimit\",\"type\":\"uint256\"}],\"name\":\"setMaxBuyLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minBuyLimit\",\"type\":\"uint256\"}],\"name\":\"setMinBuyLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_saleToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_totalTokensforSale\",\"type\":\"uint256\"}],\"name\":\"setSaleTokenParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_presaleEndTime\",\"type\":\"uint256\"}],\"name\":\"startAndSetPresaleEndTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startUnlocking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopUnlocking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenWL\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokensSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokensforSale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"_rate\",\"type\":\"uint256[4]\"}],\"name\":\"updateEthRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_presaleEndTime\",\"type\":\"uint256\"}],\"name\":\"updateTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256[4]\",\"name\":\"_price\",\"type\":\"uint256[4]\"}],\"name\":\"updateTokenRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAllSaleToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"withdrawCurrency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawSaleToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Presale", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}