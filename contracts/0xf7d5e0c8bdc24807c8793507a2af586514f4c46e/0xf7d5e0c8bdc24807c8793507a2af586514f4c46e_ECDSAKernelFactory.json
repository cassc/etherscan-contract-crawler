{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/factory/ECDSAKernelFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport \\\"./KernelFactory.sol\\\";\\nimport \\\"src/validator/ECDSAValidator.sol\\\";\\n\\ncontract ECDSAKernelFactory {\\n    KernelFactory public immutable singletonFactory;\\n    ECDSAValidator public immutable validator;\\n    IEntryPoint public immutable entryPoint;\\n\\n    constructor(KernelFactory _singletonFactory, ECDSAValidator _validator, IEntryPoint _entryPoint) {\\n        singletonFactory = _singletonFactory;\\n        validator = _validator;\\n        entryPoint = _entryPoint;\\n    }\\n\\n    function createAccount(address _owner, uint256 _index) external returns (EIP1967Proxy proxy) {\\n        bytes memory data = abi.encodePacked(_owner);\\n        proxy = singletonFactory.createAccount(validator, data, _index);\\n    }\\n\\n    function getAccountAddress(address _owner, uint256 _index) public view returns (address) {\\n        bytes memory data = abi.encodePacked(_owner);\\n        return singletonFactory.getAccountAddress(validator, data, _index);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/factory/KernelFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"openzeppelin-contracts/contracts/utils/Create2.sol\\\";\\nimport \\\"./EIP1967Proxy.sol\\\";\\nimport {Kernel} from \\\"src/Kernel.sol\\\";\\nimport \\\"src/validator/ECDSAValidator.sol\\\";\\n\\nimport \\\"./TempKernel.sol\\\";\\n\\ncontract KernelFactory {\\n    TempKernel public immutable kernelTemplate;\\n    Kernel public immutable nextTemplate;\\n    IEntryPoint public immutable entryPoint;\\n\\n    event AccountCreated(address indexed account, address indexed validator, bytes data, uint256 index);\\n\\n    constructor(IEntryPoint _entryPoint) {\\n        kernelTemplate = new TempKernel(_entryPoint);\\n        nextTemplate = new Kernel(_entryPoint);\\n        entryPoint = _entryPoint;\\n    }\\n\\n    function createAccount(IKernelValidator _validator, bytes calldata _data, uint256 _index)\\n        external\\n        returns (EIP1967Proxy proxy)\\n    {\\n        bytes32 salt = keccak256(abi.encodePacked(_validator, _data, _index));\\n        address addr = Create2.computeAddress(\\n            salt,\\n            keccak256(\\n                abi.encodePacked(\\n                    type(EIP1967Proxy).creationCode,\\n                    abi.encode(address(nextTemplate), abi.encodeCall(nextTemplate.initialize, (_validator, _data)))\\n                )\\n            )\\n        );\\n        if (addr.code.length > 0) {\\n            return EIP1967Proxy(payable(addr));\\n        }\\n        proxy =\\n        new EIP1967Proxy{salt: salt}(address(nextTemplate), abi.encodeCall(nextTemplate.initialize, (_validator, _data)));\\n        emit AccountCreated(address(proxy), address(_validator), _data, _index);\\n    }\\n\\n    function getAccountAddress(IKernelValidator _validator, bytes calldata _data, uint256 _index)\\n        public\\n        view\\n        returns (address)\\n    {\\n        bytes32 salt = keccak256(abi.encodePacked(_validator, _data, _index));\\n        return Create2.computeAddress(\\n            salt,\\n            keccak256(\\n                abi.encodePacked(\\n                    type(EIP1967Proxy).creationCode,\\n                    abi.encode(address(nextTemplate), abi.encodeCall(nextTemplate.initialize, (_validator, _data)))\\n                )\\n            )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/validator/ECDSAValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IValidator.sol\\\";\\nimport \\\"openzeppelin-contracts/contracts/utils/cryptography/EIP712.sol\\\";\\nimport \\\"src/utils/KernelHelper.sol\\\";\\n\\nstruct ECDSAValidatorStorage {\\n    address owner;\\n}\\n\\ncontract ECDSAValidator is IKernelValidator {\\n    event OwnerChanged(address indexed kernel, address indexed oldOwner, address indexed newOwner);\\n\\n    mapping(address => ECDSAValidatorStorage) public ecdsaValidatorStorage;\\n\\n    function disable(bytes calldata) external override {\\n        delete ecdsaValidatorStorage[msg.sender];\\n    }\\n\\n    function enable(bytes calldata _data) external override {\\n        address owner = address(bytes20(_data[0:20]));\\n        address oldOwner = ecdsaValidatorStorage[msg.sender].owner;\\n        ecdsaValidatorStorage[msg.sender].owner = owner;\\n        emit OwnerChanged(msg.sender, oldOwner, owner);\\n    }\\n\\n    function validateUserOp(UserOperation calldata _userOp, bytes32 _userOpHash, uint256)\\n        external\\n        view\\n        override\\n        returns (uint256 validationData)\\n    {\\n        address owner = ecdsaValidatorStorage[_userOp.sender].owner;\\n        if (owner == ECDSA.recover(_userOpHash, _userOp.signature)) {\\n            return 0;\\n        }\\n\\n        bytes32 hash = ECDSA.toEthSignedMessageHash(_userOpHash);\\n        address recovered = ECDSA.recover(hash, _userOp.signature);\\n        if (owner != recovered) {\\n            return SIG_VALIDATION_FAILED;\\n        }\\n    }\\n\\n    function validateSignature(bytes32 hash, bytes calldata signature) public view override returns (uint256) {\\n        address owner = ecdsaValidatorStorage[msg.sender].owner;\\n        if( owner == ECDSA.recover(hash, signature) ) {\\n            return 0;\\n        }\\n        bytes32 ethHash = ECDSA.toEthSignedMessageHash(hash);\\n        address recovered = ECDSA.recover(ethHash, signature);\\n        if (owner != recovered) {\\n            return SIG_VALIDATION_FAILED;\\n        }\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Create2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Create2.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(\\n        uint256 amount,\\n        bytes32 salt,\\n        bytes memory bytecode\\n    ) internal returns (address addr) {\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(\\n        bytes32 salt,\\n        bytes32 bytecodeHash,\\n        address deployer\\n    ) internal pure returns (address addr) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40) // Get free memory pointer\\n\\n            // |                   | \u2193 ptr ...  \u2193 ptr + 0x0B (start) ...  \u2193 ptr + 0x20 ...  \u2193 ptr + 0x40 ...   |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\\n            // | 0xFF              |            FF                                                             |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\\n            // | keccak(start, 85) |            \u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191 |\\n\\n            mstore(add(ptr, 0x40), bytecodeHash)\\n            mstore(add(ptr, 0x20), salt)\\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\\n            mstore8(start, 0xff)\\n            addr := keccak256(start, 85)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/factory/EIP1967Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract EIP1967Proxy {\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    constructor(address _logic, bytes memory _data) payable {\\n        require(_logic != address(0), \\\"EIP1967Proxy: implementation is the zero address\\\");\\n        bytes32 slot = _IMPLEMENTATION_SLOT;\\n        assembly {\\n            sstore(slot, _logic)\\n        }\\n        if (_data.length > 0) {\\n            (bool success,) = _logic.delegatecall(_data);\\n            require(success, \\\"EIP1967Proxy: constructor call failed\\\");\\n        }\\n    }\\n\\n    fallback() external payable {\\n        address implementation = _implementation();\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 { revert(0, returndatasize()) }\\n            default { return(0, returndatasize()) }\\n        }\\n    }\\n\\n    function _implementation() internal view returns (address impl) {\\n        bytes32 slot = _IMPLEMENTATION_SLOT;\\n        assembly {\\n            impl := sload(slot)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Kernel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Importing external libraries and contracts\\nimport \\\"openzeppelin-contracts/contracts/utils/cryptography/EIP712.sol\\\";\\nimport \\\"account-abstraction/core/Helpers.sol\\\";\\nimport \\\"account-abstraction/interfaces/IAccount.sol\\\";\\nimport \\\"account-abstraction/interfaces/IEntryPoint.sol\\\";\\nimport {EntryPoint} from \\\"account-abstraction/core/EntryPoint.sol\\\";\\nimport \\\"./utils/Exec.sol\\\";\\nimport \\\"./abstract/Compatibility.sol\\\";\\nimport \\\"./abstract/KernelStorage.sol\\\";\\nimport \\\"./utils/KernelHelper.sol\\\";\\n\\n/// @title Kernel\\n/// @author taek<leekt216@gmail.com>\\n/// @notice wallet kernel for minimal wallet functionality\\ncontract Kernel is IAccount, EIP712, Compatibility, KernelStorage {\\n    string public constant name = \\\"Kernel\\\";\\n    string public constant version = \\\"0.0.2\\\";\\n\\n    /// @dev Sets up the EIP712 and KernelStorage with the provided entry point\\n    constructor(IEntryPoint _entryPoint) EIP712(name, version) KernelStorage(_entryPoint) {}\\n\\n    /// @notice Accepts incoming Ether transactions and calls from the EntryPoint contract\\n    /// @dev This function will delegate any call to the appropriate executor based on the function signature.\\n    fallback() external payable {\\n        require(msg.sender == address(entryPoint), \\\"account: not from entrypoint\\\");\\n        bytes4 sig = msg.sig;\\n        address executor = getKernelStorage().execution[sig].executor;\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n            let result := delegatecall(gas(), executor, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            switch result\\n            case 0 { revert(0, returndatasize()) }\\n            default { return(0, returndatasize()) }\\n        }\\n    }\\n\\n    /// @notice Executes a function call to an external contract\\n    /// @dev The type of operation (call or delegatecall) is specified as an argument.\\n    /// @param to The address of the target contract\\n    /// @param value The amount of Ether to send\\n    /// @param data The call data to be sent\\n    /// @param operation The type of operation (call or delegatecall)\\n    function execute(address to, uint256 value, bytes calldata data, Operation operation) external {\\n        require(msg.sender == address(entryPoint), \\\"account: not from entrypoint\\\");\\n        bool success;\\n        bytes memory ret;\\n        if (operation == Operation.DelegateCall) {\\n            (success, ret) = Exec.delegateCall(to, data);\\n        } else {\\n            (success, ret) = Exec.call(to, value, data);\\n        }\\n        if (!success) {\\n            assembly {\\n                revert(add(ret, 32), mload(ret))\\n            }\\n        }\\n    }\\n\\n    /// @notice Validates a user operation based on its mode\\n    /// @dev This function will validate user operation and be called by EntryPoint\\n    /// @param userOp The user operation to be validated\\n    /// @param userOpHash The hash of the user operation\\n    /// @param missingAccountFunds The funds needed to be reimbursed\\n    /// @return validationData The data used for validation\\n    function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds)\\n        external\\n        returns (uint256 validationData)\\n    {\\n        require(msg.sender == address(entryPoint), \\\"account: not from entryPoint\\\");\\n        // mode based signature\\n        bytes4 mode = bytes4(userOp.signature[0:4]); // mode == 00..00 use validators\\n        require(mode & getKernelStorage().disabledMode == 0x00000000, \\\"kernel: mode disabled\\\");\\n        // mode == 0x00000000 use sudo validator\\n        // mode == 0x00000001 use given validator\\n        // mode == 0x00000002 enable validator\\n        UserOperation memory op = userOp;\\n        IKernelValidator validator;\\n        bytes4 sig = bytes4(userOp.callData[0:4]);\\n        if (mode == 0x00000000) {\\n            // sudo mode (use default validator)\\n            op = userOp;\\n            op.signature = userOp.signature[4:];\\n            validator = getKernelStorage().defaultValidator;\\n        } else if (mode == 0x00000001) {\\n            ExecutionDetail storage detail = getKernelStorage().execution[sig];\\n            validator = detail.validator;\\n            if (address(validator) == address(0)) {\\n                validator = getKernelStorage().defaultValidator;\\n            }\\n            op.signature = userOp.signature[4:];\\n            validationData = (uint256(detail.validAfter) << 160) | (uint256(detail.validUntil) << (48 + 160));\\n        } else if (mode == 0x00000002) {\\n            // use given validator\\n            // userOp.signature[4:10] = validUntil,\\n            // userOp.signature[10:16] = validAfter,\\n            // userOp.signature[16:36] = validator address,\\n            validator = IKernelValidator(address(bytes20(userOp.signature[16:36])));\\n            bytes calldata enableData;\\n            bytes calldata remainSig;\\n            (validationData, enableData, remainSig) = _approveValidator(sig, userOp.signature);\\n            validator.enable(enableData);\\n            op.signature = remainSig;\\n        } else {\\n            return SIG_VALIDATION_FAILED;\\n        }\\n        if (missingAccountFunds > 0) {\\n            // we are going to assume signature is valid at this point\\n            (bool success,) = msg.sender.call{value: missingAccountFunds}(\\\"\\\");\\n            (success);\\n        }\\n        validationData =\\n            _intersectValidationData(validationData, validator.validateUserOp(op, userOpHash, missingAccountFunds));\\n        return validationData;\\n    }\\n\\n    function _approveValidator(bytes4 sig, bytes calldata signature)\\n        internal\\n        returns (uint256 validationData, bytes calldata enableData, bytes calldata validationSig)\\n    {\\n        uint256 enableDataLength = uint256(bytes32(signature[56:88]));\\n        enableData = signature[88:88 + enableDataLength];\\n        uint256 enableSignatureLength = uint256(bytes32(signature[88 + enableDataLength:120 + enableDataLength]));\\n        bytes32 enableDigest = _hashTypedDataV4(\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"ValidatorApproved(bytes4 sig,uint256 validatorData,address executor,bytes enableData)\\\"),\\n                    bytes4(sig),\\n                    uint256(bytes32(signature[4:36])),\\n                    address(bytes20(signature[36:56])),\\n                    keccak256(enableData)\\n                )\\n            )\\n        );\\n        validationData = _intersectValidationData(\\n            getKernelStorage().defaultValidator.validateSignature(\\n                enableDigest, signature[120 + enableDataLength:120 + enableDataLength + enableSignatureLength]\\n            ),\\n            uint256(bytes32(signature[4:36])) & (uint256(type(uint96).max) << 160)\\n        );\\n        validationSig = signature[120 + enableDataLength + enableSignatureLength:];\\n        getKernelStorage().execution[sig] = ExecutionDetail({\\n            executor: address(bytes20(signature[36:56])),\\n            validator: IKernelValidator(address(bytes20(signature[16:36]))),\\n            validUntil: uint48(bytes6(signature[4:10])),\\n            validAfter: uint48(bytes6(signature[10:16]))\\n        });\\n        return (validationData, signature[88:88 + enableDataLength], validationSig);\\n    }\\n\\n    /// @notice Checks if a signature is valid\\n    /// @dev This function checks if a signature is valid based on the hash of the data signed.\\n    /// @param hash The hash of the data that was signed\\n    /// @param signature The signature to be validated\\n    /// @return The magic value 0x1626ba7e if the signature is valid, otherwise returns 0xffffffff.\\n    function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4) {\\n        uint256 validationData = getKernelStorage().defaultValidator.validateSignature(hash, signature);\\n        ValidationData memory data = _parseValidationData(validationData);\\n        if (data.validAfter > block.timestamp) {\\n            return 0xffffffff;\\n        }\\n        if (data.validUntil < block.timestamp) {\\n            return 0xffffffff;\\n        }\\n        if (data.aggregator != address(0)) {\\n            return 0xffffffff;\\n        }\\n\\n        return 0x1626ba7e;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/factory/TempKernel.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\nimport \\\"account-abstraction/interfaces/IEntryPoint.sol\\\";\\nimport \\\"account-abstraction/interfaces/IAccount.sol\\\";\\nimport \\\"src/Kernel.sol\\\";\\nimport \\\"src/abstract/KernelStorage.sol\\\";\\n\\nbytes32 constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\nstruct TempStorage {\\n    address newTemplate;\\n    address validator;\\n    bytes data;\\n    bytes validatorData;\\n}\\n\\nusing ECDSA for bytes32;\\n\\ncontract TempKernel is EIP712, IAccount {\\n    string public constant name = \\\"Kernel\\\";\\n\\n    string public constant version = \\\"0.0.2\\\";\\n\\n    IEntryPoint public immutable entryPoint;\\n\\n    /// @dev Sets up the EIP712 and KernelStorage with the provided entry point\\n    constructor(IEntryPoint _entryPoint) EIP712(name, version) {\\n        entryPoint = _entryPoint;\\n    }\\n\\n    // Function to initialize the wallet kernel\\n    function initialize(IKernelValidator _defaultValidator, address _newTemplate, bytes calldata _data) external {\\n        WalletKernelStorage storage ws = getKernelStorage();\\n        require(address(ws.defaultValidator) == address(0), \\\"account: already initialized\\\");\\n        ws.defaultValidator = _defaultValidator;\\n        ws.owner = abi.decode(_data, (address));\\n        // _defaultValidator.enable(_data); removed to avoid accessing external storage\\n        getStorage().newTemplate = _newTemplate;\\n        getStorage().data = _data;\\n\\n        (bool success,) =\\n            _callCode(address(_defaultValidator), abi.encodeWithSelector(IKernelValidator.enable.selector, _data)); // to NOT preserve msg.sender\\n        require(success, \\\"account: enable failed with defaultvalidator\\\");\\n    }\\n\\n    function getKernelStorage() internal pure returns (WalletKernelStorage storage ws) {\\n        bytes32 storagePosition = bytes32(uint256(keccak256(\\\"zerodev.kernel\\\")) - 1);\\n        assembly {\\n            ws.slot := storagePosition\\n        }\\n    }\\n\\n    function getTempStorage() external view returns (address newTemplate, bytes memory data) {\\n        TempStorage storage strg = getStorage();\\n        newTemplate = strg.newTemplate;\\n        data = strg.data;\\n    }\\n\\n    function getStorage() internal view returns (TempStorage storage strg) {\\n        assembly {\\n            strg.slot := address()\\n        }\\n    }\\n\\n    /// @notice Validates a user operation based on its mode\\n    /// @dev This function will validate user operation and be called by EntryPoint\\n    /// @param userOp The user operation to be validated\\n    /// @param userOpHash The hash of the user operation\\n    /// @param missingAccountFunds The funds needed to be reimbursed\\n    /// @return validationData The data used for validation\\n    function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds)\\n        external\\n        returns (uint256 validationData)\\n    {\\n        require(msg.sender == address(entryPoint), \\\"account: not from entryPoint\\\");\\n        // mode based signature\\n        bytes4 mode = bytes4(userOp.signature[0:4]); // mode == 00..00 use validators\\n        // mode == 0x00000000 use sudo validator\\n        // mode == 0x00000001 use given validator\\n        // mode == 0x00000002 enable validator\\n        UserOperation memory op = userOp;\\n        IKernelValidator validator;\\n        bytes4 sig = bytes4(userOp.callData[0:4]);\\n        if (mode == 0x00000000) {\\n            // sudo mode (use default validator)\\n            op = userOp;\\n            op.signature = userOp.signature[4:];\\n            validator = getKernelStorage().defaultValidator;\\n        } else if (mode == 0x00000002) {\\n            // no plugin mode\\n            // use given validator\\n            // userOp.signature[4:10] = validUntil,\\n            // userOp.signature[10:16] = validAfter,\\n            // userOp.signature[16:36] = validator address,\\n            validator = IKernelValidator(address(bytes20(userOp.signature[16:36])));\\n            bytes calldata enableData;\\n            bytes calldata remainSig;\\n            (validationData, enableData, remainSig) = _approveValidator(sig, userOp.signature);\\n            (bool s,) =\\n                _callCode(address(validator), abi.encodeWithSelector(IKernelValidator.enable.selector, enableData)); // callcode for NOT preserving msg.sender\\n            require(s, \\\"account: enable mode enable failed\\\");\\n            op.signature = remainSig;\\n        } else {\\n            return SIG_VALIDATION_FAILED;\\n        }\\n        if (missingAccountFunds > 0) {\\n            // we are going to assume signature is valid at this point\\n            (bool s,) = msg.sender.call{value: missingAccountFunds}(\\\"\\\");\\n            (s);\\n        }\\n        (, bytes memory ret) = _callCode(\\n            address(validator),\\n            abi.encodeWithSelector(IKernelValidator.validateUserOp.selector, op, userOpHash, missingAccountFunds)\\n        );\\n        validationData = _intersectValidationData(validationData, abi.decode(ret, (uint256)));\\n\\n        return validationData;\\n    }\\n\\n    function _approveValidator(bytes4 sig, bytes calldata signature)\\n        internal\\n        returns (uint256 validationData, bytes calldata enableData, bytes calldata validationSig)\\n    {\\n        uint256 enableDataLength = uint256(bytes32(signature[56:88]));\\n        enableData = signature[88:88 + enableDataLength];\\n        uint256 enableSignatureLength = uint256(bytes32(signature[88 + enableDataLength:120 + enableDataLength]));\\n        bytes32 enableDigest = _hashTypedDataV4(\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"ValidatorApproved(bytes4 sig,uint256 validatorData,address executor,bytes enableData)\\\"),\\n                    bytes4(sig),\\n                    uint256(bytes32(signature[4:36])),\\n                    address(bytes20(signature[36:56])),\\n                    keccak256(enableData)\\n                )\\n            )\\n        );\\n        (, bytes memory ret) = _callCode(\\n            address(getKernelStorage().defaultValidator),\\n            (\\n                abi.encodeWithSelector(\\n                    IKernelValidator.validateSignature.selector,\\n                    enableDigest,\\n                    signature[120 + enableDataLength:120 + enableDataLength + enableSignatureLength]\\n                )\\n            )\\n        );\\n        validationData = _intersectValidationData(\\n            abi.decode(ret, (uint256)), uint256(bytes32(signature[4:36])) & (uint256(type(uint96).max) << 160)\\n        );\\n        validationSig = signature[120 + enableDataLength + enableSignatureLength:];\\n        getKernelStorage().execution[sig] = ExecutionDetail({\\n            executor: address(bytes20(signature[36:56])),\\n            validator: IKernelValidator(address(bytes20(signature[16:36]))),\\n            validUntil: uint48(bytes6(signature[4:10])),\\n            validAfter: uint48(bytes6(signature[10:16]))\\n        });\\n        getStorage().validator = address(bytes20(signature[16:36]));\\n        getStorage().validatorData = enableData;\\n        return (validationData, signature[88:88 + enableDataLength], validationSig);\\n    }\\n\\n    receive() external payable {}\\n\\n    fallback() external payable {\\n        TempStorage storage strg = getStorage();\\n        address _newImplementation = strg.newTemplate;\\n        bytes32 slot = _IMPLEMENTATION_SLOT;\\n        assembly {\\n            sstore(slot, _newImplementation)\\n        } // update implementation address for used on execution phase\\n\\n        IKernelValidator defaultValidator = IKernelValidator(getKernelStorage().defaultValidator);\\n        defaultValidator.enable(strg.data);\\n\\n        IKernelValidator validator = IKernelValidator(getStorage().validator);\\n        if (address(validator) != address(0)) {\\n            validator.enable(getStorage().validatorData);\\n        }\\n        \\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), _newImplementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    // WARTNING: this function is NOT VIEW\\n    /// @notice Checks if a signature is valid\\n    /// @dev This function checks if a signature is valid based on the hash of the data signed.\\n    /// @param hash The hash of the data that was signed\\n    /// @param signature The signature to be validated\\n    /// @return The magic value 0x1626ba7e if the signature is valid, otherwise returns 0xffffffff.\\n    function isValidSignature(bytes32 hash, bytes calldata signature) external returns (bytes4) {\\n        (, bytes memory ret) = _callCode(\\n            address(getKernelStorage().defaultValidator),\\n            abi.encodeWithSelector(IKernelValidator.validateSignature.selector, hash, signature)\\n        );\\n        uint256 validationData = abi.decode(ret, (uint256));\\n        ValidationData memory data = _parseValidationData(validationData);\\n        if (data.validAfter > block.timestamp) {\\n            return 0xffffffff;\\n        }\\n        if (data.validUntil < block.timestamp) {\\n            return 0xffffffff;\\n        }\\n        if (data.aggregator != address(0)) {\\n            return 0xffffffff;\\n        }\\n\\n        return 0x1626ba7e;\\n    }\\n\\n    function _callCode(address _target, bytes memory data) internal returns (bool success, bytes memory ret) {\\n        assembly {\\n            let result := callcode(gas(), _target, 0, add(data, 0x20), mload(data), 0, 0)\\n            // Load free memory location\\n            let ptr := mload(0x40)\\n            // We allocate memory for the return data by setting the free memory location to\\n            // current free memory location + data size + 32 bytes for data size value\\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\\n            // Store the size\\n            mstore(ptr, returndatasize())\\n            // Store the data\\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\\n            // Point the return data to the correct memory location\\n            ret := ptr\\n            success := result\\n        }\\n        if(!success) {\\n            revert(string(ret));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/validator/IValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"account-abstraction/interfaces/UserOperation.sol\\\";\\n\\ninterface IKernelValidator {\\n    function enable(bytes calldata _data) external;\\n\\n    function disable(bytes calldata _data) external;\\n\\n    function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingFunds)\\n        external\\n        returns (uint256);\\n\\n    function validateSignature(bytes32 hash, bytes calldata signature) external view returns (uint256);\\n}\\n\\n// 3 modes\\n// 1. default mode, use preset validator for the kernel\\n// 2. enable mode, enable a new validator for given action and use it for current userOp\\n// 3. sudo mode, use default plugin for current userOp\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/EIP712.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n    address private immutable _CACHED_THIS;\\n\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        bytes32 typeHash = keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n        _CACHED_CHAIN_ID = block.chainid;\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\\n        _CACHED_THIS = address(this);\\n        _TYPE_HASH = typeHash;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\\n            return _CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\\n        }\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/utils/KernelHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nuint256 constant SIG_VALIDATION_FAILED = 1;\\n\\nfunction _intersectValidationData(uint256 a, uint256 b) pure returns (uint256 validationData) {\\n    if (uint160(a) != uint160(b)) {\\n        return SIG_VALIDATION_FAILED;\\n    }\\n    uint48 validAfterA = uint48(a >> (160 + 48));\\n    uint48 validUntilA = uint48(a >> 160);\\n    if(validUntilA == 0) {\\n        validUntilA = type(uint48).max;\\n    }\\n    uint48 validAfterB = uint48(b >> (160 + 48));\\n    uint48 validUntilB = uint48(b >> 160);\\n    if(validUntilB == 0) {\\n        validUntilB = type(uint48).max;\\n    }\\n\\n    if (validAfterA < validAfterB) validAfterA = validAfterB;\\n    if (validUntilA > validUntilB) validUntilA = validUntilB;\\n    validationData = uint256(uint160(a)) | (uint256(validUntilA) << 160) | (uint256(validAfterA) << (48 + 160));\\n}\\n\"\r\n    },\r\n    \"lib/account-abstraction/contracts/core/Helpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable no-inline-assembly */\\n\\n/**\\n * returned data from validateUserOp.\\n * validateUserOp returns a uint256, with is created by `_packedValidationData` and parsed by `_parseValidationData`\\n * @param aggregator - address(0) - the account validated the signature by itself.\\n *              address(1) - the account failed to validate the signature.\\n *              otherwise - this is an address of a signature aggregator that must be used to validate the signature.\\n * @param validAfter - this UserOp is valid only after this timestamp.\\n * @param validaUntil - this UserOp is valid only up to this timestamp.\\n */\\n    struct ValidationData {\\n        address aggregator;\\n        uint48 validAfter;\\n        uint48 validUntil;\\n    }\\n\\n//extract sigFailed, validAfter, validUntil.\\n// also convert zero validUntil to type(uint48).max\\n    function _parseValidationData(uint validationData) pure returns (ValidationData memory data) {\\n        address aggregator = address(uint160(validationData));\\n        uint48 validUntil = uint48(validationData >> 160);\\n        if (validUntil == 0) {\\n            validUntil = type(uint48).max;\\n        }\\n        uint48 validAfter = uint48(validationData >> (48 + 160));\\n        return ValidationData(aggregator, validAfter, validUntil);\\n    }\\n\\n// intersect account and paymaster ranges.\\n    function _intersectTimeRange(uint256 validationData, uint256 paymasterValidationData) pure returns (ValidationData memory) {\\n        ValidationData memory accountValidationData = _parseValidationData(validationData);\\n        ValidationData memory pmValidationData = _parseValidationData(paymasterValidationData);\\n        address aggregator = accountValidationData.aggregator;\\n        if (aggregator == address(0)) {\\n            aggregator = pmValidationData.aggregator;\\n        }\\n        uint48 validAfter = accountValidationData.validAfter;\\n        uint48 validUntil = accountValidationData.validUntil;\\n        uint48 pmValidAfter = pmValidationData.validAfter;\\n        uint48 pmValidUntil = pmValidationData.validUntil;\\n\\n        if (validAfter < pmValidAfter) validAfter = pmValidAfter;\\n        if (validUntil > pmValidUntil) validUntil = pmValidUntil;\\n        return ValidationData(aggregator, validAfter, validUntil);\\n    }\\n\\n/**\\n * helper to pack the return value for validateUserOp\\n * @param data - the ValidationData to pack\\n */\\n    function _packValidationData(ValidationData memory data) pure returns (uint256) {\\n        return uint160(data.aggregator) | (uint256(data.validUntil) << 160) | (uint256(data.validAfter) << (160 + 48));\\n    }\\n\\n/**\\n * helper to pack the return value for validateUserOp, when not using an aggregator\\n * @param sigFailed - true for signature failure, false for success\\n * @param validUntil last timestamp this UserOperation is valid (or zero for infinite)\\n * @param validAfter first timestamp this UserOperation is valid\\n */\\n    function _packValidationData(bool sigFailed, uint48 validUntil, uint48 validAfter) pure returns (uint256) {\\n        return (sigFailed ? 1 : 0) | (uint256(validUntil) << 160) | (uint256(validAfter) << (160 + 48));\\n    }\\n\\n/**\\n * keccak function over calldata.\\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\\n */\\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\\n        assembly {\\n            let mem := mload(0x40)\\n            let len := data.length\\n            calldatacopy(mem, data.offset, len)\\n            ret := keccak256(mem, len)\\n        }\\n    }\\n\\n\"\r\n    },\r\n    \"lib/account-abstraction/contracts/interfaces/IAccount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"./UserOperation.sol\\\";\\n\\ninterface IAccount {\\n\\n    /**\\n     * Validate user's signature and nonce\\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\\n     * This allows making a \\\"simulation call\\\" without a valid signature\\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\\n     *\\n     * @dev Must validate caller is the entryPoint.\\n     *      Must validate the signature and nonce\\n     * @param userOp the operation that is about to be executed.\\n     * @param userOpHash hash of the user's request data. can be used as the basis for signature.\\n     * @param missingAccountFunds missing funds on the account's deposit in the entrypoint.\\n     *      This is the minimum amount to transfer to the sender(entryPoint) to be able to make the call.\\n     *      The excess is left as a deposit in the entrypoint, for future calls.\\n     *      can be withdrawn anytime using \\\"entryPoint.withdrawTo()\\\"\\n     *      In case there is a paymaster in the request (or the current deposit is high enough), this value will be zero.\\n     * @return validationData packaged ValidationData structure. use `_packValidationData` and `_unpackValidationData` to encode and decode\\n     *      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\\n     *         otherwise, an address of an \\\"authorizer\\\" contract.\\n     *      <6-byte> validUntil - last timestamp this operation is valid. 0 for \\\"indefinite\\\"\\n     *      <6-byte> validAfter - first timestamp this operation is valid\\n     *      If an account doesn't use time-range, it is enough to return SIG_VALIDATION_FAILED value (1) for signature failure.\\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\\n     */\\n    function validateUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 missingAccountFunds)\\n    external returns (uint256 validationData);\\n}\\n\"\r\n    },\r\n    \"lib/account-abstraction/contracts/interfaces/IEntryPoint.sol\": {\r\n      \"content\": \"/**\\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\\n ** Only one instance required on each chain.\\n **/\\n// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable no-inline-assembly */\\n/* solhint-disable reason-string */\\n\\nimport \\\"./UserOperation.sol\\\";\\nimport \\\"./IStakeManager.sol\\\";\\nimport \\\"./IAggregator.sol\\\";\\nimport \\\"./INonceManager.sol\\\";\\n\\ninterface IEntryPoint is IStakeManager, INonceManager {\\n\\n    /***\\n     * An event emitted after each successful request\\n     * @param userOpHash - unique identifier for the request (hash its entire content, except signature).\\n     * @param sender - the account that generates this request.\\n     * @param paymaster - if non-null, the paymaster that pays for this request.\\n     * @param nonce - the nonce value from the request.\\n     * @param success - true if the sender transaction succeeded, false if reverted.\\n     * @param actualGasCost - actual amount paid (by account or paymaster) for this UserOperation.\\n     * @param actualGasUsed - total gas used by this UserOperation (including preVerification, creation, validation and execution).\\n     */\\n    event UserOperationEvent(bytes32 indexed userOpHash, address indexed sender, address indexed paymaster, uint256 nonce, bool success, uint256 actualGasCost, uint256 actualGasUsed);\\n\\n    /**\\n     * account \\\"sender\\\" was deployed.\\n     * @param userOpHash the userOp that deployed this account. UserOperationEvent will follow.\\n     * @param sender the account that is deployed\\n     * @param factory the factory used to deploy this account (in the initCode)\\n     * @param paymaster the paymaster used by this UserOp\\n     */\\n    event AccountDeployed(bytes32 indexed userOpHash, address indexed sender, address factory, address paymaster);\\n\\n    /**\\n     * An event emitted if the UserOperation \\\"callData\\\" reverted with non-zero length\\n     * @param userOpHash the request unique identifier.\\n     * @param sender the sender of this request\\n     * @param nonce the nonce used in the request\\n     * @param revertReason - the return bytes from the (reverted) call to \\\"callData\\\".\\n     */\\n    event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason);\\n\\n    /**\\n     * an event emitted by handleOps(), before starting the execution loop.\\n     * any event emitted before this event, is part of the validation.\\n     */\\n    event BeforeExecution();\\n\\n    /**\\n     * signature aggregator used by the following UserOperationEvents within this bundle.\\n     */\\n    event SignatureAggregatorChanged(address indexed aggregator);\\n\\n    /**\\n     * a custom revert error of handleOps, to identify the offending op.\\n     *  NOTE: if simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\\n     *  @param opIndex - index into the array of ops to the failed one (in simulateValidation, this is always zero)\\n     *  @param reason - revert reason\\n     *      The string starts with a unique code \\\"AAmn\\\", where \\\"m\\\" is \\\"1\\\" for factory, \\\"2\\\" for account and \\\"3\\\" for paymaster issues,\\n     *      so a failure can be attributed to the correct entity.\\n     *   Should be caught in off-chain handleOps simulation and not happen on-chain.\\n     *   Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\\n     */\\n    error FailedOp(uint256 opIndex, string reason);\\n\\n    /**\\n     * error case when a signature aggregator fails to verify the aggregated signature it had created.\\n     */\\n    error SignatureValidationFailed(address aggregator);\\n\\n    /**\\n     * Successful result from simulateValidation.\\n     * @param returnInfo gas and time-range returned values\\n     * @param senderInfo stake information about the sender\\n     * @param factoryInfo stake information about the factory (if any)\\n     * @param paymasterInfo stake information about the paymaster (if any)\\n     */\\n    error ValidationResult(ReturnInfo returnInfo,\\n        StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo);\\n\\n    /**\\n     * Successful result from simulateValidation, if the account returns a signature aggregator\\n     * @param returnInfo gas and time-range returned values\\n     * @param senderInfo stake information about the sender\\n     * @param factoryInfo stake information about the factory (if any)\\n     * @param paymasterInfo stake information about the paymaster (if any)\\n     * @param aggregatorInfo signature aggregation info (if the account requires signature aggregator)\\n     *      bundler MUST use it to verify the signature, or reject the UserOperation\\n     */\\n    error ValidationResultWithAggregation(ReturnInfo returnInfo,\\n        StakeInfo senderInfo, StakeInfo factoryInfo, StakeInfo paymasterInfo,\\n        AggregatorStakeInfo aggregatorInfo);\\n\\n    /**\\n     * return value of getSenderAddress\\n     */\\n    error SenderAddressResult(address sender);\\n\\n    /**\\n     * return value of simulateHandleOp\\n     */\\n    error ExecutionResult(uint256 preOpGas, uint256 paid, uint48 validAfter, uint48 validUntil, bool targetSuccess, bytes targetResult);\\n\\n    //UserOps handled, per aggregator\\n    struct UserOpsPerAggregator {\\n        UserOperation[] userOps;\\n\\n        // aggregator address\\n        IAggregator aggregator;\\n        // aggregated signature\\n        bytes signature;\\n    }\\n\\n    /**\\n     * Execute a batch of UserOperation.\\n     * no signature aggregator is used.\\n     * if any account requires an aggregator (that is, it returned an aggregator when\\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\\n     * @param ops the operations to execute\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleOps(UserOperation[] calldata ops, address payable beneficiary) external;\\n\\n    /**\\n     * Execute a batch of UserOperation with Aggregators\\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleAggregatedOps(\\n        UserOpsPerAggregator[] calldata opsPerAggregator,\\n        address payable beneficiary\\n    ) external;\\n\\n    /**\\n     * generate a request Id - unique identifier for this request.\\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\\n     */\\n    function getUserOpHash(UserOperation calldata userOp) external view returns (bytes32);\\n\\n    /**\\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\\n     * @param userOp the user operation to validate.\\n     */\\n    function simulateValidation(UserOperation calldata userOp) external;\\n\\n    /**\\n     * gas and return values during simulation\\n     * @param preOpGas the gas used for validation (including preValidationGas)\\n     * @param prefund the required prefund for this operation\\n     * @param sigFailed validateUserOp's (or paymaster's) signature check failed\\n     * @param validAfter - first timestamp this UserOp is valid (merging account and paymaster time-range)\\n     * @param validUntil - last timestamp this UserOp is valid (merging account and paymaster time-range)\\n     * @param paymasterContext returned by validatePaymasterUserOp (to be passed into postOp)\\n     */\\n    struct ReturnInfo {\\n        uint256 preOpGas;\\n        uint256 prefund;\\n        bool sigFailed;\\n        uint48 validAfter;\\n        uint48 validUntil;\\n        bytes paymasterContext;\\n    }\\n\\n    /**\\n     * returned aggregated signature info.\\n     * the aggregator returned by the account, and its current stake.\\n     */\\n    struct AggregatorStakeInfo {\\n        address aggregator;\\n        StakeInfo stakeInfo;\\n    }\\n\\n    /**\\n     * Get counterfactual sender address.\\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\\n     * this method always revert, and returns the address in SenderAddressResult error\\n     * @param initCode the constructor code to be passed into the UserOperation.\\n     */\\n    function getSenderAddress(bytes memory initCode) external;\\n\\n\\n    /**\\n     * simulate full execution of a UserOperation (including both validation and target execution)\\n     * this method will always revert with \\\"ExecutionResult\\\".\\n     * it performs full validation of the UserOperation, but ignores signature error.\\n     * an optional target address is called after the userop succeeds, and its value is returned\\n     * (before the entire call is reverted)\\n     * Note that in order to collect the the success/failure of the target call, it must be executed\\n     * with trace enabled to track the emitted events.\\n     * @param op the UserOperation to simulate\\n     * @param target if nonzero, a target address to call after userop simulation. If called, the targetSuccess and targetResult\\n     *        are set to the return from that call.\\n     * @param targetCallData callData to pass to target address\\n     */\\n    function simulateHandleOp(UserOperation calldata op, address target, bytes calldata targetCallData) external;\\n}\\n\\n\"\r\n    },\r\n    \"lib/account-abstraction/contracts/core/EntryPoint.sol\": {\r\n      \"content\": \"/**\\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\\n ** Only one instance required on each chain.\\n **/\\n// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable no-inline-assembly */\\n\\nimport \\\"../interfaces/IAccount.sol\\\";\\nimport \\\"../interfaces/IPaymaster.sol\\\";\\nimport \\\"../interfaces/IEntryPoint.sol\\\";\\n\\nimport \\\"../utils/Exec.sol\\\";\\nimport \\\"./StakeManager.sol\\\";\\nimport \\\"./SenderCreator.sol\\\";\\nimport \\\"./Helpers.sol\\\";\\nimport \\\"./NonceManager.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\ncontract EntryPoint is IEntryPoint, StakeManager, NonceManager, ReentrancyGuard {\\n\\n    using UserOperationLib for UserOperation;\\n\\n    SenderCreator private immutable senderCreator = new SenderCreator();\\n\\n    // internal value used during simulation: need to query aggregator.\\n    address private constant SIMULATE_FIND_AGGREGATOR = address(1);\\n\\n    // marker for inner call revert on out of gas\\n    bytes32 private constant INNER_OUT_OF_GAS = hex'deaddead';\\n\\n    uint256 private constant REVERT_REASON_MAX_LEN = 2048;\\n\\n    /**\\n     * for simulation purposes, validateUserOp (and validatePaymasterUserOp) must return this value\\n     * in case of signature failure, instead of revert.\\n     */\\n    uint256 public constant SIG_VALIDATION_FAILED = 1;\\n\\n    /**\\n     * compensate the caller's beneficiary address with the collected fees of all UserOperations.\\n     * @param beneficiary the address to receive the fees\\n     * @param amount amount to transfer.\\n     */\\n    function _compensate(address payable beneficiary, uint256 amount) internal {\\n        require(beneficiary != address(0), \\\"AA90 invalid beneficiary\\\");\\n        (bool success,) = beneficiary.call{value : amount}(\\\"\\\");\\n        require(success, \\\"AA91 failed send to beneficiary\\\");\\n    }\\n\\n    /**\\n     * execute a user op\\n     * @param opIndex index into the opInfo array\\n     * @param userOp the userOp to execute\\n     * @param opInfo the opInfo filled by validatePrepayment for this userOp.\\n     * @return collected the total amount this userOp paid.\\n     */\\n    function _executeUserOp(uint256 opIndex, UserOperation calldata userOp, UserOpInfo memory opInfo) private returns (uint256 collected) {\\n        uint256 preGas = gasleft();\\n        bytes memory context = getMemoryBytesFromOffset(opInfo.contextOffset);\\n\\n        try this.innerHandleOp(userOp.callData, opInfo, context) returns (uint256 _actualGasCost) {\\n            collected = _actualGasCost;\\n        } catch {\\n            bytes32 innerRevertCode;\\n            assembly {\\n                returndatacopy(0, 0, 32)\\n                innerRevertCode := mload(0)\\n            }\\n            // handleOps was called with gas limit too low. abort entire bundle.\\n            if (innerRevertCode == INNER_OUT_OF_GAS) {\\n                //report paymaster, since if it is not deliberately caused by the bundler,\\n                // it must be a revert caused by paymaster.\\n                revert FailedOp(opIndex, \\\"AA95 out of gas\\\");\\n            }\\n\\n            uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\\n            collected = _handlePostOp(opIndex, IPaymaster.PostOpMode.postOpReverted, opInfo, context, actualGas);\\n        }\\n    }\\n\\n    /**\\n     * Execute a batch of UserOperations.\\n     * no signature aggregator is used.\\n     * if any account requires an aggregator (that is, it returned an aggregator when\\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\\n     * @param ops the operations to execute\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleOps(UserOperation[] calldata ops, address payable beneficiary) public nonReentrant {\\n\\n        uint256 opslen = ops.length;\\n        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\\n\\n    unchecked {\\n        for (uint256 i = 0; i < opslen; i++) {\\n            UserOpInfo memory opInfo = opInfos[i];\\n            (uint256 validationData, uint256 pmValidationData) = _validatePrepayment(i, ops[i], opInfo);\\n            _validateAccountAndPaymasterValidationData(i, validationData, pmValidationData, address(0));\\n        }\\n\\n        uint256 collected = 0;\\n        emit BeforeExecution();\\n\\n        for (uint256 i = 0; i < opslen; i++) {\\n            collected += _executeUserOp(i, ops[i], opInfos[i]);\\n        }\\n\\n        _compensate(beneficiary, collected);\\n    } //unchecked\\n    }\\n\\n    /**\\n     * Execute a batch of UserOperation with Aggregators\\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleAggregatedOps(\\n        UserOpsPerAggregator[] calldata opsPerAggregator,\\n        address payable beneficiary\\n    ) public nonReentrant {\\n\\n        uint256 opasLen = opsPerAggregator.length;\\n        uint256 totalOps = 0;\\n        for (uint256 i = 0; i < opasLen; i++) {\\n            UserOpsPerAggregator calldata opa = opsPerAggregator[i];\\n            UserOperation[] calldata ops = opa.userOps;\\n            IAggregator aggregator = opa.aggregator;\\n\\n            //address(1) is special marker of \\\"signature error\\\"\\n            require(address(aggregator) != address(1), \\\"AA96 invalid aggregator\\\");\\n\\n            if (address(aggregator) != address(0)) {\\n                // solhint-disable-next-line no-empty-blocks\\n                try aggregator.validateSignatures(ops, opa.signature) {}\\n                catch {\\n                    revert SignatureValidationFailed(address(aggregator));\\n                }\\n            }\\n\\n            totalOps += ops.length;\\n        }\\n\\n        UserOpInfo[] memory opInfos = new UserOpInfo[](totalOps);\\n\\n        emit BeforeExecution();\\n\\n        uint256 opIndex = 0;\\n        for (uint256 a = 0; a < opasLen; a++) {\\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\\n            UserOperation[] calldata ops = opa.userOps;\\n            IAggregator aggregator = opa.aggregator;\\n\\n            uint256 opslen = ops.length;\\n            for (uint256 i = 0; i < opslen; i++) {\\n                UserOpInfo memory opInfo = opInfos[opIndex];\\n                (uint256 validationData, uint256 paymasterValidationData) = _validatePrepayment(opIndex, ops[i], opInfo);\\n                _validateAccountAndPaymasterValidationData(i, validationData, paymasterValidationData, address(aggregator));\\n                opIndex++;\\n            }\\n        }\\n\\n        uint256 collected = 0;\\n        opIndex = 0;\\n        for (uint256 a = 0; a < opasLen; a++) {\\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\\n            emit SignatureAggregatorChanged(address(opa.aggregator));\\n            UserOperation[] calldata ops = opa.userOps;\\n            uint256 opslen = ops.length;\\n\\n            for (uint256 i = 0; i < opslen; i++) {\\n                collected += _executeUserOp(opIndex, ops[i], opInfos[opIndex]);\\n                opIndex++;\\n            }\\n        }\\n        emit SignatureAggregatorChanged(address(0));\\n\\n        _compensate(beneficiary, collected);\\n    }\\n\\n    /// @inheritdoc IEntryPoint\\n    function simulateHandleOp(UserOperation calldata op, address target, bytes calldata targetCallData) external override {\\n\\n        UserOpInfo memory opInfo;\\n        _simulationOnlyValidations(op);\\n        (uint256 validationData, uint256 paymasterValidationData) = _validatePrepayment(0, op, opInfo);\\n        ValidationData memory data = _intersectTimeRange(validationData, paymasterValidationData);\\n\\n        numberMarker();\\n        uint256 paid = _executeUserOp(0, op, opInfo);\\n        numberMarker();\\n        bool targetSuccess;\\n        bytes memory targetResult;\\n        if (target != address(0)) {\\n            (targetSuccess, targetResult) = target.call(targetCallData);\\n        }\\n        revert ExecutionResult(opInfo.preOpGas, paid, data.validAfter, data.validUntil, targetSuccess, targetResult);\\n    }\\n\\n\\n    // A memory copy of UserOp static fields only.\\n    // Excluding: callData, initCode and signature. Replacing paymasterAndData with paymaster.\\n    struct MemoryUserOp {\\n        address sender;\\n        uint256 nonce;\\n        uint256 callGasLimit;\\n        uint256 verificationGasLimit;\\n        uint256 preVerificationGas;\\n        address paymaster;\\n        uint256 maxFeePerGas;\\n        uint256 maxPriorityFeePerGas;\\n    }\\n\\n    struct UserOpInfo {\\n        MemoryUserOp mUserOp;\\n        bytes32 userOpHash;\\n        uint256 prefund;\\n        uint256 contextOffset;\\n        uint256 preOpGas;\\n    }\\n\\n    /**\\n     * inner function to handle a UserOperation.\\n     * Must be declared \\\"external\\\" to open a call context, but it can only be called by handleOps.\\n     */\\n    function innerHandleOp(bytes memory callData, UserOpInfo memory opInfo, bytes calldata context) external returns (uint256 actualGasCost) {\\n        uint256 preGas = gasleft();\\n        require(msg.sender == address(this), \\\"AA92 internal call only\\\");\\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\\n\\n        uint callGasLimit = mUserOp.callGasLimit;\\n    unchecked {\\n        // handleOps was called with gas limit too low. abort entire bundle.\\n        if (gasleft() < callGasLimit + mUserOp.verificationGasLimit + 5000) {\\n            assembly {\\n                mstore(0, INNER_OUT_OF_GAS)\\n                revert(0, 32)\\n            }\\n        }\\n    }\\n\\n        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\\n        if (callData.length > 0) {\\n            bool success = Exec.call(mUserOp.sender, 0, callData, callGasLimit);\\n            if (!success) {\\n                bytes memory result = Exec.getReturnData(REVERT_REASON_MAX_LEN);\\n                if (result.length > 0) {\\n                    emit UserOperationRevertReason(opInfo.userOpHash, mUserOp.sender, mUserOp.nonce, result);\\n                }\\n                mode = IPaymaster.PostOpMode.opReverted;\\n            }\\n        }\\n\\n    unchecked {\\n        uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\\n        //note: opIndex is ignored (relevant only if mode==postOpReverted, which is only possible outside of innerHandleOp)\\n        return _handlePostOp(0, mode, opInfo, context, actualGas);\\n    }\\n    }\\n\\n    /**\\n     * generate a request Id - unique identifier for this request.\\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\\n     */\\n    function getUserOpHash(UserOperation calldata userOp) public view returns (bytes32) {\\n        return keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\\n    }\\n\\n    /**\\n     * copy general fields from userOp into the memory opInfo structure.\\n     */\\n    function _copyUserOpToMemory(UserOperation calldata userOp, MemoryUserOp memory mUserOp) internal pure {\\n        mUserOp.sender = userOp.sender;\\n        mUserOp.nonce = userOp.nonce;\\n        mUserOp.callGasLimit = userOp.callGasLimit;\\n        mUserOp.verificationGasLimit = userOp.verificationGasLimit;\\n        mUserOp.preVerificationGas = userOp.preVerificationGas;\\n        mUserOp.maxFeePerGas = userOp.maxFeePerGas;\\n        mUserOp.maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n        bytes calldata paymasterAndData = userOp.paymasterAndData;\\n        if (paymasterAndData.length > 0) {\\n            require(paymasterAndData.length >= 20, \\\"AA93 invalid paymasterAndData\\\");\\n            mUserOp.paymaster = address(bytes20(paymasterAndData[: 20]));\\n        } else {\\n            mUserOp.paymaster = address(0);\\n        }\\n    }\\n\\n    /**\\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\\n     * @param userOp the user operation to validate.\\n     */\\n    function simulateValidation(UserOperation calldata userOp) external {\\n        UserOpInfo memory outOpInfo;\\n\\n        _simulationOnlyValidations(userOp);\\n        (uint256 validationData, uint256 paymasterValidationData) = _validatePrepayment(0, userOp, outOpInfo);\\n        StakeInfo memory paymasterInfo = _getStakeInfo(outOpInfo.mUserOp.paymaster);\\n        StakeInfo memory senderInfo = _getStakeInfo(outOpInfo.mUserOp.sender);\\n        StakeInfo memory factoryInfo;\\n        {\\n            bytes calldata initCode = userOp.initCode;\\n            address factory = initCode.length >= 20 ? address(bytes20(initCode[0 : 20])) : address(0);\\n            factoryInfo = _getStakeInfo(factory);\\n        }\\n\\n        ValidationData memory data = _intersectTimeRange(validationData, paymasterValidationData);\\n        address aggregator = data.aggregator;\\n        bool sigFailed = aggregator == address(1);\\n        ReturnInfo memory returnInfo = ReturnInfo(outOpInfo.preOpGas, outOpInfo.prefund,\\n            sigFailed, data.validAfter, data.validUntil, getMemoryBytesFromOffset(outOpInfo.contextOffset));\\n\\n        if (aggregator != address(0) && aggregator != address(1)) {\\n            AggregatorStakeInfo memory aggregatorInfo = AggregatorStakeInfo(aggregator, _getStakeInfo(aggregator));\\n            revert ValidationResultWithAggregation(returnInfo, senderInfo, factoryInfo, paymasterInfo, aggregatorInfo);\\n        }\\n        revert ValidationResult(returnInfo, senderInfo, factoryInfo, paymasterInfo);\\n\\n    }\\n\\n    function _getRequiredPrefund(MemoryUserOp memory mUserOp) internal pure returns (uint256 requiredPrefund) {\\n    unchecked {\\n        //when using a Paymaster, the verificationGasLimit is used also to as a limit for the postOp call.\\n        // our security model might call postOp eventually twice\\n        uint256 mul = mUserOp.paymaster != address(0) ? 3 : 1;\\n        uint256 requiredGas = mUserOp.callGasLimit + mUserOp.verificationGasLimit * mul + mUserOp.preVerificationGas;\\n\\n        requiredPrefund = requiredGas * mUserOp.maxFeePerGas;\\n    }\\n    }\\n\\n    // create the sender's contract if needed.\\n    function _createSenderIfNeeded(uint256 opIndex, UserOpInfo memory opInfo, bytes calldata initCode) internal {\\n        if (initCode.length != 0) {\\n            address sender = opInfo.mUserOp.sender;\\n            if (sender.code.length != 0) revert FailedOp(opIndex, \\\"AA10 sender already constructed\\\");\\n            address sender1 = senderCreator.createSender{gas : opInfo.mUserOp.verificationGasLimit}(initCode);\\n            if (sender1 == address(0)) revert FailedOp(opIndex, \\\"AA13 initCode failed or OOG\\\");\\n            if (sender1 != sender) revert FailedOp(opIndex, \\\"AA14 initCode must return sender\\\");\\n            if (sender1.code.length == 0) revert FailedOp(opIndex, \\\"AA15 initCode must create sender\\\");\\n            address factory = address(bytes20(initCode[0 : 20]));\\n            emit AccountDeployed(opInfo.userOpHash, sender, factory, opInfo.mUserOp.paymaster);\\n        }\\n    }\\n\\n    /**\\n     * Get counterfactual sender address.\\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\\n     * this method always revert, and returns the address in SenderAddressResult error\\n     * @param initCode the constructor code to be passed into the UserOperation.\\n     */\\n    function getSenderAddress(bytes calldata initCode) public {\\n        address sender = senderCreator.createSender(initCode);\\n        revert SenderAddressResult(sender);\\n    }\\n\\n    function _simulationOnlyValidations(UserOperation calldata userOp) internal view {\\n        // solhint-disable-next-line no-empty-blocks\\n        try this._validateSenderAndPaymaster(userOp.initCode, userOp.sender, userOp.paymasterAndData) {}\\n        catch Error(string memory revertReason) {\\n            if (bytes(revertReason).length != 0) {\\n                revert FailedOp(0, revertReason);\\n            }\\n        }\\n    }\\n\\n    /**\\n    * Called only during simulation.\\n    * This function always reverts to prevent warm/cold storage differentiation in simulation vs execution.\\n    */\\n    function _validateSenderAndPaymaster(bytes calldata initCode, address sender, bytes calldata paymasterAndData) external view {\\n        if (initCode.length == 0 && sender.code.length == 0) {\\n            // it would revert anyway. but give a meaningful message\\n            revert(\\\"AA20 account not deployed\\\");\\n        }\\n        if (paymasterAndData.length >= 20) {\\n            address paymaster = address(bytes20(paymasterAndData[0 : 20]));\\n            if (paymaster.code.length == 0) {\\n                // it would revert anyway. but give a meaningful message\\n                revert(\\\"AA30 paymaster not deployed\\\");\\n            }\\n        }\\n        // always revert\\n        revert(\\\"\\\");\\n    }\\n\\n    /**\\n     * call account.validateUserOp.\\n     * revert (with FailedOp) in case validateUserOp reverts, or account didn't send required prefund.\\n     * decrement account's deposit if needed\\n     */\\n    function _validateAccountPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, uint256 requiredPrefund)\\n    internal returns (uint256 gasUsedByValidateAccountPrepayment, uint256 validationData) {\\n    unchecked {\\n        uint256 preGas = gasleft();\\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\\n        address sender = mUserOp.sender;\\n        _createSenderIfNeeded(opIndex, opInfo, op.initCode);\\n        address paymaster = mUserOp.paymaster;\\n        numberMarker();\\n        uint256 missingAccountFunds = 0;\\n        if (paymaster == address(0)) {\\n            uint256 bal = balanceOf(sender);\\n            missingAccountFunds = bal > requiredPrefund ? 0 : requiredPrefund - bal;\\n        }\\n        try IAccount(sender).validateUserOp{gas : mUserOp.verificationGasLimit}(op, opInfo.userOpHash, missingAccountFunds)\\n        returns (uint256 _validationData) {\\n            validationData = _validationData;\\n        } catch Error(string memory revertReason) {\\n            revert FailedOp(opIndex, string.concat(\\\"AA23 reverted: \\\", revertReason));\\n        } catch {\\n            revert FailedOp(opIndex, \\\"AA23 reverted (or OOG)\\\");\\n        }\\n        if (paymaster == address(0)) {\\n            DepositInfo storage senderInfo = deposits[sender];\\n            uint256 deposit = senderInfo.deposit;\\n            if (requiredPrefund > deposit) {\\n                revert FailedOp(opIndex, \\\"AA21 didn't pay prefund\\\");\\n            }\\n            senderInfo.deposit = uint112(deposit - requiredPrefund);\\n        }\\n        gasUsedByValidateAccountPrepayment = preGas - gasleft();\\n    }\\n    }\\n\\n    /**\\n     * In case the request has a paymaster:\\n     * Validate paymaster has enough deposit.\\n     * Call paymaster.validatePaymasterUserOp.\\n     * Revert with proper FailedOp in case paymaster reverts.\\n     * Decrement paymaster's deposit\\n     */\\n    function _validatePaymasterPrepayment(uint256 opIndex, UserOperation calldata op, UserOpInfo memory opInfo, uint256 requiredPreFund, uint256 gasUsedByValidateAccountPrepayment)\\n    internal returns (bytes memory context, uint256 validationData) {\\n    unchecked {\\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\\n        uint256 verificationGasLimit = mUserOp.verificationGasLimit;\\n        require(verificationGasLimit > gasUsedByValidateAccountPrepayment, \\\"AA41 too little verificationGas\\\");\\n        uint256 gas = verificationGasLimit - gasUsedByValidateAccountPrepayment;\\n\\n        address paymaster = mUserOp.paymaster;\\n        DepositInfo storage paymasterInfo = deposits[paymaster];\\n        uint256 deposit = paymasterInfo.deposit;\\n        if (deposit < requiredPreFund) {\\n            revert FailedOp(opIndex, \\\"AA31 paymaster deposit too low\\\");\\n        }\\n        paymasterInfo.deposit = uint112(deposit - requiredPreFund);\\n        try IPaymaster(paymaster).validatePaymasterUserOp{gas : gas}(op, opInfo.userOpHash, requiredPreFund) returns (bytes memory _context, uint256 _validationData){\\n            context = _context;\\n            validationData = _validationData;\\n        } catch Error(string memory revertReason) {\\n            revert FailedOp(opIndex, string.concat(\\\"AA33 reverted: \\\", revertReason));\\n        } catch {\\n            revert FailedOp(opIndex, \\\"AA33 reverted (or OOG)\\\");\\n        }\\n    }\\n    }\\n\\n    /**\\n     * revert if either account validationData or paymaster validationData is expired\\n     */\\n    function _validateAccountAndPaymasterValidationData(uint256 opIndex, uint256 validationData, uint256 paymasterValidationData, address expectedAggregator) internal view {\\n        (address aggregator, bool outOfTimeRange) = _getValidationData(validationData);\\n        if (expectedAggregator != aggregator) {\\n            revert FailedOp(opIndex, \\\"AA24 signature error\\\");\\n        }\\n        if (outOfTimeRange) {\\n            revert FailedOp(opIndex, \\\"AA22 expired or not due\\\");\\n        }\\n        //pmAggregator is not a real signature aggregator: we don't have logic to handle it as address.\\n        // non-zero address means that the paymaster fails due to some signature check (which is ok only during estimation)\\n        address pmAggregator;\\n        (pmAggregator, outOfTimeRange) = _getValidationData(paymasterValidationData);\\n        if (pmAggregator != address(0)) {\\n            revert FailedOp(opIndex, \\\"AA34 signature error\\\");\\n        }\\n        if (outOfTimeRange) {\\n            revert FailedOp(opIndex, \\\"AA32 paymaster expired or not due\\\");\\n        }\\n    }\\n\\n    function _getValidationData(uint256 validationData) internal view returns (address aggregator, bool outOfTimeRange) {\\n        if (validationData == 0) {\\n            return (address(0), false);\\n        }\\n        ValidationData memory data = _parseValidationData(validationData);\\n        // solhint-disable-next-line not-rely-on-time\\n        outOfTimeRange = block.timestamp > data.validUntil || block.timestamp < data.validAfter;\\n        aggregator = data.aggregator;\\n    }\\n\\n    /**\\n     * validate account and paymaster (if defined).\\n     * also make sure total validation doesn't exceed verificationGasLimit\\n     * this method is called off-chain (simulateValidation()) and on-chain (from handleOps)\\n     * @param opIndex the index of this userOp into the \\\"opInfos\\\" array\\n     * @param userOp the userOp to validate\\n     */\\n    function _validatePrepayment(uint256 opIndex, UserOperation calldata userOp, UserOpInfo memory outOpInfo)\\n    private returns (uint256 validationData, uint256 paymasterValidationData) {\\n\\n        uint256 preGas = gasleft();\\n        MemoryUserOp memory mUserOp = outOpInfo.mUserOp;\\n        _copyUserOpToMemory(userOp, mUserOp);\\n        outOpInfo.userOpHash = getUserOpHash(userOp);\\n\\n        // validate all numeric values in userOp are well below 128 bit, so they can safely be added\\n        // and multiplied without causing overflow\\n        uint256 maxGasValues = mUserOp.preVerificationGas | mUserOp.verificationGasLimit | mUserOp.callGasLimit |\\n        userOp.maxFeePerGas | userOp.maxPriorityFeePerGas;\\n        require(maxGasValues <= type(uint120).max, \\\"AA94 gas values overflow\\\");\\n\\n        uint256 gasUsedByValidateAccountPrepayment;\\n        (uint256 requiredPreFund) = _getRequiredPrefund(mUserOp);\\n        (gasUsedByValidateAccountPrepayment, validationData) = _validateAccountPrepayment(opIndex, userOp, outOpInfo, requiredPreFund);\\n\\n        if (!_validateAndUpdateNonce(mUserOp.sender, mUserOp.nonce)) {\\n            revert FailedOp(opIndex, \\\"AA25 invalid account nonce\\\");\\n        }\\n\\n        //a \\\"marker\\\" where account opcode validation is done and paymaster opcode validation is about to start\\n        // (used only by off-chain simulateValidation)\\n        numberMarker();\\n\\n        bytes memory context;\\n        if (mUserOp.paymaster != address(0)) {\\n            (context, paymasterValidationData) = _validatePaymasterPrepayment(opIndex, userOp, outOpInfo, requiredPreFund, gasUsedByValidateAccountPrepayment);\\n        }\\n    unchecked {\\n        uint256 gasUsed = preGas - gasleft();\\n\\n        if (userOp.verificationGasLimit < gasUsed) {\\n            revert FailedOp(opIndex, \\\"AA40 over verificationGasLimit\\\");\\n        }\\n        outOpInfo.prefund = requiredPreFund;\\n        outOpInfo.contextOffset = getOffsetOfMemoryBytes(context);\\n        outOpInfo.preOpGas = preGas - gasleft() + userOp.preVerificationGas;\\n    }\\n    }\\n\\n    /**\\n     * process post-operation.\\n     * called just after the callData is executed.\\n     * if a paymaster is defined and its validation returned a non-empty context, its postOp is called.\\n     * the excess amount is refunded to the account (or paymaster - if it was used in the request)\\n     * @param opIndex index in the batch\\n     * @param mode - whether is called from innerHandleOp, or outside (postOpReverted)\\n     * @param opInfo userOp fields and info collected during validation\\n     * @param context the context returned in validatePaymasterUserOp\\n     * @param actualGas the gas used so far by this user operation\\n     */\\n    function _handlePostOp(uint256 opIndex, IPaymaster.PostOpMode mode, UserOpInfo memory opInfo, bytes memory context, uint256 actualGas) private returns (uint256 actualGasCost) {\\n        uint256 preGas = gasleft();\\n    unchecked {\\n        address refundAddress;\\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\\n        uint256 gasPrice = getUserOpGasPrice(mUserOp);\\n\\n        address paymaster = mUserOp.paymaster;\\n        if (paymaster == address(0)) {\\n            refundAddress = mUserOp.sender;\\n        } else {\\n            refundAddress = paymaster;\\n            if (context.length > 0) {\\n                actualGasCost = actualGas * gasPrice;\\n                if (mode != IPaymaster.PostOpMode.postOpReverted) {\\n                    IPaymaster(paymaster).postOp{gas : mUserOp.verificationGasLimit}(mode, context, actualGasCost);\\n                } else {\\n                    // solhint-disable-next-line no-empty-blocks\\n                    try IPaymaster(paymaster).postOp{gas : mUserOp.verificationGasLimit}(mode, context, actualGasCost) {}\\n                    catch Error(string memory reason) {\\n                        revert FailedOp(opIndex, string.concat(\\\"AA50 postOp reverted: \\\", reason));\\n                    }\\n                    catch {\\n                        revert FailedOp(opIndex, \\\"AA50 postOp revert\\\");\\n                    }\\n                }\\n            }\\n        }\\n        actualGas += preGas - gasleft();\\n        actualGasCost = actualGas * gasPrice;\\n        if (opInfo.prefund < actualGasCost) {\\n            revert FailedOp(opIndex, \\\"AA51 prefund below actualGasCost\\\");\\n        }\\n        uint256 refund = opInfo.prefund - actualGasCost;\\n        _incrementDeposit(refundAddress, refund);\\n        bool success = mode == IPaymaster.PostOpMode.opSucceeded;\\n        emit UserOperationEvent(opInfo.userOpHash, mUserOp.sender, mUserOp.paymaster, mUserOp.nonce, success, actualGasCost, actualGas);\\n    } // unchecked\\n    }\\n\\n    /**\\n     * the gas price this UserOp agrees to pay.\\n     * relayer/block builder might submit the TX with higher priorityFee, but the user should not\\n     */\\n    function getUserOpGasPrice(MemoryUserOp memory mUserOp) internal view returns (uint256) {\\n    unchecked {\\n        uint256 maxFeePerGas = mUserOp.maxFeePerGas;\\n        uint256 maxPriorityFeePerGas = mUserOp.maxPriorityFeePerGas;\\n        if (maxFeePerGas == maxPriorityFeePerGas) {\\n            //legacy mode (for networks that don't support basefee opcode)\\n            return maxFeePerGas;\\n        }\\n        return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\\n    }\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    function getOffsetOfMemoryBytes(bytes memory data) internal pure returns (uint256 offset) {\\n        assembly {offset := data}\\n    }\\n\\n    function getMemoryBytesFromOffset(uint256 offset) internal pure returns (bytes memory data) {\\n        assembly {data := offset}\\n    }\\n\\n    //place the NUMBER opcode in the code.\\n    // this is used as a marker during simulation, as this OP is completely banned from the simulated code of the\\n    // account and paymaster.\\n    function numberMarker() internal view {\\n        assembly {mstore(0, number())}\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"src/utils/Exec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.5 <0.9.0;\\n\\n// solhint-disable no-inline-assembly\\n\\nenum Operation {\\n    Call,\\n    DelegateCall\\n}\\n\\n/**\\n * Utility functions helpful when making different kinds of contract calls in Solidity.\\n */\\nlibrary Exec {\\n    function call(address to, uint256 value, bytes memory data)\\n        internal\\n        returns (bool success, bytes memory returnData)\\n    {\\n        assembly {\\n            success := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)\\n            let len := returndatasize()\\n            let ptr := mload(0x40)\\n            mstore(0x40, add(ptr, add(len, 0x20)))\\n            mstore(ptr, len)\\n            returndatacopy(add(ptr, 0x20), 0, len)\\n            returnData := ptr\\n        }\\n    }\\n\\n    function staticcall(address to, bytes memory data) internal view returns (bool success, bytes memory returnData) {\\n        assembly {\\n            success := staticcall(gas(), to, add(data, 0x20), mload(data), 0, 0)\\n            let len := returndatasize()\\n            let ptr := mload(0x40)\\n            mstore(0x40, add(ptr, add(len, 0x20)))\\n            mstore(ptr, len)\\n            returndatacopy(add(ptr, 0x20), 0, len)\\n            returnData := ptr\\n        }\\n    }\\n\\n    function delegateCall(address to, bytes memory data) internal returns (bool success, bytes memory returnData) {\\n        assembly {\\n            success := delegatecall(gas(), to, add(data, 0x20), mload(data), 0, 0)\\n            let len := returndatasize()\\n            let ptr := mload(0x40)\\n            mstore(0x40, add(ptr, add(len, 0x20)))\\n            mstore(ptr, len)\\n            returndatacopy(add(ptr, 0x20), 0, len)\\n            returnData := ptr\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/abstract/Compatibility.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract Compatibility {\\n    receive() external payable {}\\n\\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n\\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata)\\n        external\\n        pure\\n        returns (bytes4)\\n    {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/abstract/KernelStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Importing necessary interfaces\\nimport \\\"account-abstraction/interfaces/IEntryPoint.sol\\\";\\nimport \\\"src/validator/IValidator.sol\\\";\\n\\n// Defining a struct for execution details\\nstruct ExecutionDetail {\\n    uint48 validUntil; // Until what time is this execution valid\\n    uint48 validAfter; // After what time is this execution valid\\n    address executor; // Who is the executor of this execution\\n    IKernelValidator validator; // The validator for this execution\\n}\\n\\n// Defining a struct for wallet kernel storage\\nstruct WalletKernelStorage {\\n    bytes32 __deprecated; // A deprecated field\\n    bytes4 disabledMode; // Mode which is currently disabled\\n    uint48 lastDisabledTime; // Last time when a mode was disabled\\n    address owner;\\n    IKernelValidator defaultValidator; // Default validator for the wallet\\n    mapping(bytes4 => ExecutionDetail) execution; // Mapping of function selectors to execution details\\n}\\n\\n/// @title Kernel Storage Contract\\n/// @author taek<leekt216@gmail.com>\\n/// @notice This contract serves as the storage module for the Kernel contract.\\n/// @dev This contract should only be used by the main Kernel contract.\\ncontract KernelStorage {\\n    uint256 internal constant SIG_VALIDATION_FAILED = 1; // Signature validation failed error code\\n\\n    IEntryPoint public immutable entryPoint; // The entry point of the contract\\n\\n    // Event declarations\\n    event Upgraded(address indexed newImplementation);\\n    event DefaultValidatorChanged(address indexed oldValidator, address indexed newValidator);\\n    event ExecutionChanged(bytes4 indexed selector, address indexed executor, address indexed validator);\\n    event OwnerUpdated(address indexed newOwner);\\n\\n    // Modifier to check if the function is called by the entry point, the contract itself or the owner\\n    modifier onlyFromEntryPointOrOwnerOrSelf() {\\n        address owner = getKernelStorage().owner;\\n        require(\\n            msg.sender == address(entryPoint) || msg.sender == address(this) || msg.sender == owner,\\n            \\\"account: not from entrypoint or owner or self\\\"\\n        );\\n        _;\\n    }\\n\\n    /// @param _entryPoint The address of the EntryPoint contract\\n    /// @dev Sets up the EntryPoint contract address\\n    constructor(IEntryPoint _entryPoint) {\\n        entryPoint = _entryPoint;\\n        getKernelStorage().defaultValidator = IKernelValidator(address(1));\\n    }\\n\\n    // Function to initialize the wallet kernel\\n    function initialize(IKernelValidator _defaultValidator, bytes calldata _data) external {\\n        WalletKernelStorage storage ws = getKernelStorage();\\n        require(address(ws.defaultValidator) == address(0), \\\"account: already initialized\\\");\\n        ws.defaultValidator = _defaultValidator;\\n        ws.owner = address(bytes20(_data[0:20]));\\n        emit DefaultValidatorChanged(address(0), address(_defaultValidator));\\n        _defaultValidator.enable(_data);\\n    }\\n\\n    // Function to get the wallet kernel storage\\n    function getKernelStorage() internal pure returns (WalletKernelStorage storage ws) {\\n        bytes32 storagePosition = bytes32(uint256(keccak256(\\\"zerodev.kernel\\\")) - 1);\\n        assembly {\\n            ws.slot := storagePosition\\n        }\\n    }\\n\\n    // Function to upgrade the contract to a new implementation\\n    function upgradeTo(address _newImplementation) external onlyFromEntryPointOrOwnerOrSelf {\\n        bytes32 slot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n        assembly {\\n            sstore(slot, _newImplementation)\\n        }\\n        emit Upgraded(_newImplementation);\\n    }\\n\\n    // Functions to get the nonce from the entry point\\n    function getNonce() public view virtual returns (uint256) {\\n        return entryPoint.getNonce(address(this), 0);\\n    }\\n\\n    function getNonce(uint192 key) public view virtual returns (uint256) {\\n        return entryPoint.getNonce(address(this), key);\\n    }\\n\\n    // query storage\\n    function getDefaultValidator() public view returns (IKernelValidator) {\\n        return getKernelStorage().defaultValidator;\\n    }\\n\\n    function getDisabledMode() public view returns (bytes4) {\\n        return getKernelStorage().disabledMode;\\n    }\\n\\n    function getLastDisabledTime() public view returns (uint48) {\\n        return getKernelStorage().lastDisabledTime;\\n    }\\n\\n    /// @notice Returns the execution details for a specific function signature\\n    /// @dev This function can be used to get execution details for a specific function signature\\n    /// @param _selector The function signature\\n    /// @return ExecutionDetail struct containing the execution details\\n    function getExecution(bytes4 _selector) public view returns (ExecutionDetail memory) {\\n        return getKernelStorage().execution[_selector];\\n    }\\n\\n    /// @notice Changes the execution details for a specific function selector\\n    /// @dev This function can only be called from the EntryPoint contract, the contract owner, or itself\\n    /// @param _selector The selector of the function for which execution details are being set\\n    /// @param _executor The executor to be associated with the function selector\\n    /// @param _validator The validator contract that will be responsible for validating operations associated with this function selector\\n    /// @param _validUntil The timestamp until which the execution details are valid\\n    /// @param _validAfter The timestamp after which the execution details are valid\\n    function setExecution(\\n        bytes4 _selector,\\n        address _executor,\\n        IKernelValidator _validator,\\n        uint48 _validUntil,\\n        uint48 _validAfter,\\n        bytes calldata _enableData\\n    ) external onlyFromEntryPointOrOwnerOrSelf {\\n        getKernelStorage().execution[_selector] = ExecutionDetail({\\n            executor: _executor,\\n            validator: _validator,\\n            validUntil: _validUntil,\\n            validAfter: _validAfter\\n        });\\n        _validator.enable(_enableData);\\n        emit ExecutionChanged(_selector, _executor, address(_validator));\\n    }\\n\\n    function setDefaultValidator(IKernelValidator _defaultValidator, bytes calldata _data)\\n        external\\n        onlyFromEntryPointOrOwnerOrSelf\\n    {\\n        IKernelValidator oldValidator = getKernelStorage().defaultValidator;\\n        getKernelStorage().defaultValidator = _defaultValidator;\\n        emit DefaultValidatorChanged(address(oldValidator), address(_defaultValidator));\\n        _defaultValidator.enable(_data);\\n    }\\n\\n    function setOwner(address _newOwner) external onlyFromEntryPointOrOwnerOrSelf {\\n        require(_newOwner != address(0), \\\"Address cannot be 0\\\");\\n        getKernelStorage().owner = _newOwner;\\n    }\\n\\n    function getOwner() external view returns (address) {\\n        return getKernelStorage().owner;\\n    }\\n\\n    /// @notice Updates the disabled mode\\n    /// @dev This function can be used to update the disabled mode\\n    /// @param _disableFlag The new disabled mode\\n    function disableMode(bytes4 _disableFlag) external onlyFromEntryPointOrOwnerOrSelf {\\n        getKernelStorage().disabledMode = _disableFlag;\\n        getKernelStorage().lastDisabledTime = uint48(block.timestamp);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/account-abstraction/contracts/interfaces/UserOperation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable no-inline-assembly */\\n\\nimport {calldataKeccak} from \\\"../core/Helpers.sol\\\";\\n\\n/**\\n * User Operation struct\\n * @param sender the sender account of this request.\\n     * @param nonce unique value the sender uses to verify it is not a replay.\\n     * @param initCode if set, the account contract will be created by this constructor/\\n     * @param callData the method call to execute on this account.\\n     * @param callGasLimit the gas limit passed to the callData method call.\\n     * @param verificationGasLimit gas used for validateUserOp and validatePaymasterUserOp.\\n     * @param preVerificationGas gas not calculated by the handleOps method, but added to the gas paid. Covers batch overhead.\\n     * @param maxFeePerGas same as EIP-1559 gas parameter.\\n     * @param maxPriorityFeePerGas same as EIP-1559 gas parameter.\\n     * @param paymasterAndData if set, this field holds the paymaster address and paymaster-specific data. the paymaster will pay for the transaction instead of the sender.\\n     * @param signature sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n     */\\n    struct UserOperation {\\n\\n        address sender;\\n        uint256 nonce;\\n        bytes initCode;\\n        bytes callData;\\n        uint256 callGasLimit;\\n        uint256 verificationGasLimit;\\n        uint256 preVerificationGas;\\n        uint256 maxFeePerGas;\\n        uint256 maxPriorityFeePerGas;\\n        bytes paymasterAndData;\\n        bytes signature;\\n    }\\n\\n/**\\n * Utility functions helpful when working with UserOperation structs.\\n */\\nlibrary UserOperationLib {\\n\\n    function getSender(UserOperation calldata userOp) internal pure returns (address) {\\n        address data;\\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\\n        assembly {data := calldataload(userOp)}\\n        return address(uint160(data));\\n    }\\n\\n    //relayer/block builder might submit the TX with higher priorityFee, but the user should not\\n    // pay above what he signed for.\\n    function gasPrice(UserOperation calldata userOp) internal view returns (uint256) {\\n    unchecked {\\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n        if (maxFeePerGas == maxPriorityFeePerGas) {\\n            //legacy mode (for networks that don't support basefee opcode)\\n            return maxFeePerGas;\\n        }\\n        return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\\n    }\\n    }\\n\\n    function pack(UserOperation calldata userOp) internal pure returns (bytes memory ret) {\\n        address sender = getSender(userOp);\\n        uint256 nonce = userOp.nonce;\\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\\n        uint256 callGasLimit = userOp.callGasLimit;\\n        uint256 verificationGasLimit = userOp.verificationGasLimit;\\n        uint256 preVerificationGas = userOp.preVerificationGas;\\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\\n\\n        return abi.encode(\\n            sender, nonce,\\n            hashInitCode, hashCallData,\\n            callGasLimit, verificationGasLimit, preVerificationGas,\\n            maxFeePerGas, maxPriorityFeePerGas,\\n            hashPaymasterAndData\\n        );\\n    }\\n\\n    function hash(UserOperation calldata userOp) internal pure returns (bytes32) {\\n        return keccak256(pack(userOp));\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/account-abstraction/contracts/interfaces/IStakeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.12;\\n\\n/**\\n * manage deposits and stakes.\\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or an account)\\n * stake is value locked for at least \\\"unstakeDelay\\\" by the staked entity.\\n */\\ninterface IStakeManager {\\n\\n    event Deposited(\\n        address indexed account,\\n        uint256 totalDeposit\\n    );\\n\\n    event Withdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    /// Emitted when stake or unstake delay are modified\\n    event StakeLocked(\\n        address indexed account,\\n        uint256 totalStaked,\\n        uint256 unstakeDelaySec\\n    );\\n\\n    /// Emitted once a stake is scheduled for withdrawal\\n    event StakeUnlocked(\\n        address indexed account,\\n        uint256 withdrawTime\\n    );\\n\\n    event StakeWithdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @param deposit the entity's deposit\\n     * @param staked true if this entity is staked.\\n     * @param stake actual amount of ether staked for this entity.\\n     * @param unstakeDelaySec minimum delay to withdraw the stake.\\n     * @param withdrawTime - first block timestamp where 'withdrawStake' will be callable, or zero if already locked\\n     * @dev sizes were chosen so that (deposit,staked, stake) fit into one cell (used during handleOps)\\n     *    and the rest fit into a 2nd cell.\\n     *    112 bit allows for 10^15 eth\\n     *    48 bit for full timestamp\\n     *    32 bit allows 150 years for unstake delay\\n     */\\n    struct DepositInfo {\\n        uint112 deposit;\\n        bool staked;\\n        uint112 stake;\\n        uint32 unstakeDelaySec;\\n        uint48 withdrawTime;\\n    }\\n\\n    //API struct used by getStakeInfo and simulateValidation\\n    struct StakeInfo {\\n        uint256 stake;\\n        uint256 unstakeDelaySec;\\n    }\\n\\n    /// @return info - full deposit information of given account\\n    function getDepositInfo(address account) external view returns (DepositInfo memory info);\\n\\n    /// @return the deposit (for gas payment) of the account\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * add to the deposit of the given account\\n     */\\n    function depositTo(address account) external payable;\\n\\n    /**\\n     * add to the account's stake - amount and delay\\n     * any pending unstake is first cancelled.\\n     * @param _unstakeDelaySec the new lock duration before the deposit can be withdrawn.\\n     */\\n    function addStake(uint32 _unstakeDelaySec) external payable;\\n\\n    /**\\n     * attempt to unlock the stake.\\n     * the value can be withdrawn (using withdrawStake) after the unstake delay.\\n     */\\n    function unlockStake() external;\\n\\n    /**\\n     * withdraw from the (unlocked) stake.\\n     * must first call unlockStake and wait for the unstakeDelay to pass\\n     * @param withdrawAddress the address to send withdrawn value.\\n     */\\n    function withdrawStake(address payable withdrawAddress) external;\\n\\n    /**\\n     * withdraw from the deposit.\\n     * @param withdrawAddress the address to send withdrawn value.\\n     * @param withdrawAmount the amount to withdraw.\\n     */\\n    function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external;\\n}\\n\"\r\n    },\r\n    \"lib/account-abstraction/contracts/interfaces/IAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"./UserOperation.sol\\\";\\n\\n/**\\n * Aggregated Signatures validator.\\n */\\ninterface IAggregator {\\n\\n    /**\\n     * validate aggregated signature.\\n     * revert if the aggregated signature does not match the given list of operations.\\n     */\\n    function validateSignatures(UserOperation[] calldata userOps, bytes calldata signature) external view;\\n\\n    /**\\n     * validate signature of a single userOp\\n     * This method is should be called by bundler after EntryPoint.simulateValidation() returns (reverts) with ValidationResultWithAggregation\\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\\n     * @param userOp the userOperation received from the user.\\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\\n     *    (usually empty, unless account and aggregator support some kind of \\\"multisig\\\"\\n     */\\n    function validateUserOpSignature(UserOperation calldata userOp)\\n    external view returns (bytes memory sigForUserOp);\\n\\n    /**\\n     * aggregate multiple signatures into a single value.\\n     * This method is called off-chain to calculate the signature to pass with handleOps()\\n     * bundler MAY use optimized custom code perform this aggregation\\n     * @param userOps array of UserOperations to collect the signatures from.\\n     * @return aggregatedSignature the aggregated signature\\n     */\\n    function aggregateSignatures(UserOperation[] calldata userOps) external view returns (bytes memory aggregatedSignature);\\n}\\n\"\r\n    },\r\n    \"lib/account-abstraction/contracts/interfaces/INonceManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\ninterface INonceManager {\\n\\n    /**\\n     * Return the next nonce for this sender.\\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\\n     * But UserOp with different keys can come with arbitrary order.\\n     *\\n     * @param sender the account address\\n     * @param key the high 192 bit of the nonce\\n     * @return nonce a full nonce to pass for next UserOp with this sender.\\n     */\\n    function getNonce(address sender, uint192 key)\\n    external view returns (uint256 nonce);\\n\\n    /**\\n     * Manually increment the nonce of the sender.\\n     * This method is exposed just for completeness..\\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\\n     * as the EntryPoint will update the nonce regardless.\\n     * Possible use-case is call it with various keys to \\\"initialize\\\" their nonces to one, so that future\\n     * UserOperations will not pay extra for the first transaction with a given key.\\n     */\\n    function incrementNonce(uint192 key) external;\\n}\\n\"\r\n    },\r\n    \"lib/account-abstraction/contracts/interfaces/IPaymaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"./UserOperation.sol\\\";\\n\\n/**\\n * the interface exposed by a paymaster contract, who agrees to pay the gas for user's operations.\\n * a paymaster must hold a stake to cover the required entrypoint stake and also the gas for the transaction.\\n */\\ninterface IPaymaster {\\n\\n    enum PostOpMode {\\n        opSucceeded, // user op succeeded\\n        opReverted, // user op reverted. still has to pay for gas.\\n        postOpReverted //user op succeeded, but caused postOp to revert. Now it's a 2nd call, after user's op was deliberately reverted.\\n    }\\n\\n    /**\\n     * payment validation: check if paymaster agrees to pay.\\n     * Must verify sender is the entryPoint.\\n     * Revert to reject this request.\\n     * Note that bundlers will reject this method if it changes the state, unless the paymaster is trusted (whitelisted)\\n     * The paymaster pre-pays using its deposit, and receive back a refund after the postOp method returns.\\n     * @param userOp the user operation\\n     * @param userOpHash hash of the user's request data.\\n     * @param maxCost the maximum cost of this transaction (based on maximum gas and gas price from userOp)\\n     * @return context value to send to a postOp\\n     *      zero length to signify postOp is not required.\\n     * @return validationData signature and time-range of this operation, encoded the same as the return value of validateUserOperation\\n     *      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\\n     *         otherwise, an address of an \\\"authorizer\\\" contract.\\n     *      <6-byte> validUntil - last timestamp this operation is valid. 0 for \\\"indefinite\\\"\\n     *      <6-byte> validAfter - first timestamp this operation is valid\\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\\n     */\\n    function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 userOpHash, uint256 maxCost)\\n    external returns (bytes memory context, uint256 validationData);\\n\\n    /**\\n     * post-operation handler.\\n     * Must verify sender is the entryPoint\\n     * @param mode enum with the following options:\\n     *      opSucceeded - user operation succeeded.\\n     *      opReverted  - user op reverted. still has to pay for gas.\\n     *      postOpReverted - user op succeeded, but caused postOp (in mode=opSucceeded) to revert.\\n     *                       Now this is the 2nd call, after user's op was deliberately reverted.\\n     * @param context - the context value returned by validatePaymasterUserOp\\n     * @param actualGasCost - actual gas used so far (without this postOp call).\\n     */\\n    function postOp(PostOpMode mode, bytes calldata context, uint256 actualGasCost) external;\\n}\\n\"\r\n    },\r\n    \"lib/account-abstraction/contracts/utils/Exec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.5 <0.9.0;\\n\\n// solhint-disable no-inline-assembly\\n\\n/**\\n * Utility functions helpful when making different kinds of contract calls in Solidity.\\n */\\nlibrary Exec {\\n\\n    function call(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        uint256 txGas\\n    ) internal returns (bool success) {\\n        assembly {\\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\\n        }\\n    }\\n\\n    function staticcall(\\n        address to,\\n        bytes memory data,\\n        uint256 txGas\\n    ) internal view returns (bool success) {\\n        assembly {\\n            success := staticcall(txGas, to, add(data, 0x20), mload(data), 0, 0)\\n        }\\n    }\\n\\n    function delegateCall(\\n        address to,\\n        bytes memory data,\\n        uint256 txGas\\n    ) internal returns (bool success) {\\n        assembly {\\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\\n        }\\n    }\\n\\n    // get returned data from last call or calldelegate\\n    function getReturnData(uint256 maxLen) internal pure returns (bytes memory returnData) {\\n        assembly {\\n            let len := returndatasize()\\n            if gt(len, maxLen) {\\n                len := maxLen\\n            }\\n            let ptr := mload(0x40)\\n            mstore(0x40, add(ptr, add(len, 0x20)))\\n            mstore(ptr, len)\\n            returndatacopy(add(ptr, 0x20), 0, len)\\n            returnData := ptr\\n        }\\n    }\\n\\n    // revert with explicit byte array (probably reverted info from call)\\n    function revertWithData(bytes memory returnData) internal pure {\\n        assembly {\\n            revert(add(returnData, 32), mload(returnData))\\n        }\\n    }\\n\\n    function callAndRevert(address to, bytes memory data, uint256 maxLen) internal {\\n        bool success = call(to,0,data,gasleft());\\n        if (!success) {\\n            revertWithData(getReturnData(maxLen));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/account-abstraction/contracts/core/StakeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.12;\\n\\nimport \\\"../interfaces/IStakeManager.sol\\\";\\n\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable not-rely-on-time */\\n/**\\n * manage deposits and stakes.\\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or an account)\\n * stake is value locked for at least \\\"unstakeDelay\\\" by a paymaster.\\n */\\nabstract contract StakeManager is IStakeManager {\\n\\n    /// maps paymaster to their deposits and stakes\\n    mapping(address => DepositInfo) public deposits;\\n\\n    /// @inheritdoc IStakeManager\\n    function getDepositInfo(address account) public view returns (DepositInfo memory info) {\\n        return deposits[account];\\n    }\\n\\n    // internal method to return just the stake info\\n    function _getStakeInfo(address addr) internal view returns (StakeInfo memory info) {\\n        DepositInfo storage depositInfo = deposits[addr];\\n        info.stake = depositInfo.stake;\\n        info.unstakeDelaySec = depositInfo.unstakeDelaySec;\\n    }\\n\\n    /// return the deposit (for gas payment) of the account\\n    function balanceOf(address account) public view returns (uint256) {\\n        return deposits[account].deposit;\\n    }\\n\\n    receive() external payable {\\n        depositTo(msg.sender);\\n    }\\n\\n    function _incrementDeposit(address account, uint256 amount) internal {\\n        DepositInfo storage info = deposits[account];\\n        uint256 newAmount = info.deposit + amount;\\n        require(newAmount <= type(uint112).max, \\\"deposit overflow\\\");\\n        info.deposit = uint112(newAmount);\\n    }\\n\\n    /**\\n     * add to the deposit of the given account\\n     */\\n    function depositTo(address account) public payable {\\n        _incrementDeposit(account, msg.value);\\n        DepositInfo storage info = deposits[account];\\n        emit Deposited(account, info.deposit);\\n    }\\n\\n    /**\\n     * add to the account's stake - amount and delay\\n     * any pending unstake is first cancelled.\\n     * @param unstakeDelaySec the new lock duration before the deposit can be withdrawn.\\n     */\\n    function addStake(uint32 unstakeDelaySec) public payable {\\n        DepositInfo storage info = deposits[msg.sender];\\n        require(unstakeDelaySec > 0, \\\"must specify unstake delay\\\");\\n        require(unstakeDelaySec >= info.unstakeDelaySec, \\\"cannot decrease unstake time\\\");\\n        uint256 stake = info.stake + msg.value;\\n        require(stake > 0, \\\"no stake specified\\\");\\n        require(stake <= type(uint112).max, \\\"stake overflow\\\");\\n        deposits[msg.sender] = DepositInfo(\\n            info.deposit,\\n            true,\\n            uint112(stake),\\n            unstakeDelaySec,\\n            0\\n        );\\n        emit StakeLocked(msg.sender, stake, unstakeDelaySec);\\n    }\\n\\n    /**\\n     * attempt to unlock the stake.\\n     * the value can be withdrawn (using withdrawStake) after the unstake delay.\\n     */\\n    function unlockStake() external {\\n        DepositInfo storage info = deposits[msg.sender];\\n        require(info.unstakeDelaySec != 0, \\\"not staked\\\");\\n        require(info.staked, \\\"already unstaking\\\");\\n        uint48 withdrawTime = uint48(block.timestamp) + info.unstakeDelaySec;\\n        info.withdrawTime = withdrawTime;\\n        info.staked = false;\\n        emit StakeUnlocked(msg.sender, withdrawTime);\\n    }\\n\\n\\n    /**\\n     * withdraw from the (unlocked) stake.\\n     * must first call unlockStake and wait for the unstakeDelay to pass\\n     * @param withdrawAddress the address to send withdrawn value.\\n     */\\n    function withdrawStake(address payable withdrawAddress) external {\\n        DepositInfo storage info = deposits[msg.sender];\\n        uint256 stake = info.stake;\\n        require(stake > 0, \\\"No stake to withdraw\\\");\\n        require(info.withdrawTime > 0, \\\"must call unlockStake() first\\\");\\n        require(info.withdrawTime <= block.timestamp, \\\"Stake withdrawal is not due\\\");\\n        info.unstakeDelaySec = 0;\\n        info.withdrawTime = 0;\\n        info.stake = 0;\\n        emit StakeWithdrawn(msg.sender, withdrawAddress, stake);\\n        (bool success,) = withdrawAddress.call{value : stake}(\\\"\\\");\\n        require(success, \\\"failed to withdraw stake\\\");\\n    }\\n\\n    /**\\n     * withdraw from the deposit.\\n     * @param withdrawAddress the address to send withdrawn value.\\n     * @param withdrawAmount the amount to withdraw.\\n     */\\n    function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external {\\n        DepositInfo storage info = deposits[msg.sender];\\n        require(withdrawAmount <= info.deposit, \\\"Withdraw amount too large\\\");\\n        info.deposit = uint112(info.deposit - withdrawAmount);\\n        emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\\n        (bool success,) = withdrawAddress.call{value : withdrawAmount}(\\\"\\\");\\n        require(success, \\\"failed to withdraw\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/account-abstraction/contracts/core/SenderCreator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/**\\n * helper contract for EntryPoint, to call userOp.initCode from a \\\"neutral\\\" address,\\n * which is explicitly not the entryPoint itself.\\n */\\ncontract SenderCreator {\\n\\n    /**\\n     * call the \\\"initCode\\\" factory to create and return the sender account address\\n     * @param initCode the initCode value from a UserOp. contains 20 bytes of factory address, followed by calldata\\n     * @return sender the returned address of the created account, or zero address on failure.\\n     */\\n    function createSender(bytes calldata initCode) external returns (address sender) {\\n        address factory = address(bytes20(initCode[0 : 20]));\\n        bytes memory initCallData = initCode[20 :];\\n        bool success;\\n        /* solhint-disable no-inline-assembly */\\n        assembly {\\n            success := call(gas(), factory, 0, add(initCallData, 0x20), mload(initCallData), 0, 32)\\n            sender := mload(0)\\n        }\\n        if (!success) {\\n            sender = address(0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/account-abstraction/contracts/core/NonceManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"../interfaces/IEntryPoint.sol\\\";\\n\\n/**\\n * nonce management functionality\\n */\\ncontract NonceManager is INonceManager {\\n\\n    /**\\n     * The next valid sequence number for a given nonce key.\\n     */\\n    mapping(address => mapping(uint192 => uint256)) public nonceSequenceNumber;\\n\\n    function getNonce(address sender, uint192 key)\\n    public view override returns (uint256 nonce) {\\n        return nonceSequenceNumber[sender][key] | (uint256(key) << 64);\\n    }\\n\\n    // allow an account to manually increment its own nonce.\\n    // (mainly so that during construction nonce can be made non-zero,\\n    // to \\\"absorb\\\" the gas cost of first nonce increment to 1st transaction (construction),\\n    // not to 2nd transaction)\\n    function incrementNonce(uint192 key) public override {\\n        nonceSequenceNumber[msg.sender][key]++;\\n    }\\n\\n    /**\\n     * validate nonce uniqueness for this account.\\n     * called just after validateUserOp()\\n     */\\n    function _validateAndUpdateNonce(address sender, uint256 nonce) internal returns (bool) {\\n\\n        uint192 key = uint192(nonce >> 64);\\n        uint64 seq = uint64(nonce);\\n        return nonceSequenceNumber[sender][key]++ == seq;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"account-abstraction/=lib/account-abstraction/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"solady/=lib/solady/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract KernelFactory\",\"name\":\"_singletonFactory\",\"type\":\"address\"},{\"internalType\":\"contract ECDSAValidator\",\"name\":\"_validator\",\"type\":\"address\"},{\"internalType\":\"contract IEntryPoint\",\"name\":\"_entryPoint\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"createAccount\",\"outputs\":[{\"internalType\":\"contract EIP1967Proxy\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entryPoint\",\"outputs\":[{\"internalType\":\"contract IEntryPoint\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getAccountAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"singletonFactory\",\"outputs\":[{\"internalType\":\"contract KernelFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validator\",\"outputs\":[{\"internalType\":\"contract ECDSAValidator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ECDSAKernelFactory", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000062095e340967c464152c79a1cc26a27e11e57e5c000000000000000000000000180d6465f921c7e0dea0040107d342c87455fff50000000000000000000000005ff137d4b0fdcd49dca30c7cf57e578a026d2789", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}