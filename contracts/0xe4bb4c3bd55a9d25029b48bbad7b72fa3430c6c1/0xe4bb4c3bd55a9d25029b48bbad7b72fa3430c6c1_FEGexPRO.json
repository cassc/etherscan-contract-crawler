{"SourceCode": "pragma solidity 0.8.7;     \r\n// SPDX-License-Identifier: UNLICENSED \r\n\r\ncontract FEGmath {\r\n\r\n    function btoi(uint256 a)\r\n        internal pure\r\n        returns (uint256)\r\n    {\r\n        return a / 1e18;\r\n    }\r\n\r\n    function bfloor(uint256 a)\r\n        internal pure\r\n        returns (uint256)\r\n    {\r\n        return btoi(a) * 1e18;\r\n    }\r\n\r\n    function badd(uint256 a, uint256 b)\r\n        internal pure\r\n        returns (uint256)\r\n    {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsub(uint256 a, uint256 b)\r\n        internal pure\r\n        returns (uint256)\r\n    {\r\n        (uint256 c, bool flag) = bsubSign(a, b);\r\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsubSign(uint256 a, uint256 b)\r\n        internal pure\r\n        returns (uint, bool)\r\n    {\r\n        if (a >= b) {\r\n            return (a - b, false);\r\n        } else {\r\n            return (b - a, true);\r\n        }\r\n    }\r\n\r\n    function bmul(uint256 a, uint256 b)\r\n        internal pure\r\n        returns (uint256)\r\n    {\r\n        uint256 c0 = a * b;\r\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\r\n        uint256 c1 = c0 + (1e18 / 2);\r\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\r\n        uint256 c2 = c1 / 1e18;\r\n        return c2;\r\n    }\r\n\r\n    function bdiv(uint256 a, uint256 b)\r\n        internal pure\r\n        returns (uint256)\r\n    {\r\n        require(b != 0, \"ERR_DIV_ZERO\");\r\n        uint256 c0 = a * 1e18;\r\n        require(a == 0 || c0 / a == 1e18, \"ERR_DIV_INTERNAL\"); // bmul overflow\r\n        uint256 c1 = c0 + (b / 2);\r\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\r\n        uint256 c2 = c1 / b;\r\n        return c2;\r\n    }\r\n\r\n    function bpowi(uint256 a, uint256 n)\r\n        internal pure\r\n        returns (uint256)\r\n    {\r\n        uint256 z = n % 2 != 0 ? a : 1e18;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            a = bmul(a, a);\r\n\r\n            if (n % 2 != 0) {\r\n                z = bmul(z, a);\r\n            }\r\n        }\r\n        return z;\r\n    }\r\n\r\n    function bpow(uint256 base, uint256 exp)\r\n        internal pure\r\n        returns (uint256)\r\n    {\r\n        require(base >= 1 wei, \"ERR_BPOW_BASE_TOO_LOW\");\r\n        require(base <= (2 * 1e18) - 1 wei, \"ERR_BPOW_BASE_TOO_HIGH\");\r\n\r\n        uint256 whole  = bfloor(exp);\r\n        uint256 remain = bsub(exp, whole);\r\n\r\n        uint256 wholePow = bpowi(base, btoi(whole));\r\n\r\n        if (remain == 0) {\r\n            return wholePow;\r\n        }\r\n\r\n        uint256 partialResult = bpowApprox(base, remain, 1e18 / 1e10);\r\n        return bmul(wholePow, partialResult);\r\n    }\r\n\r\n    function bpowApprox(uint256 base, uint256 exp, uint256 precision)\r\n        internal pure\r\n        returns (uint256)\r\n    {\r\n        uint256 a     = exp;\r\n        (uint256 x, bool xneg)  = bsubSign(base, 1e18);\r\n        uint256 term = 1e18;\r\n        uint256 sum   = term;\r\n        bool negative = false;\r\n\r\n\r\n        for (uint256 i = 1; term >= precision; i++) {\r\n            uint256 bigK = i * 1e18;\r\n            (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, 1e18));\r\n            term = bmul(term, bmul(c, x));\r\n            term = bdiv(term, bigK);\r\n            if (term == 0) break;\r\n\r\n            if (xneg) negative = !negative;\r\n            if (cneg) negative = !negative;\r\n            if (negative) {\r\n                sum = bsub(sum, term);\r\n            } else {\r\n                sum = badd(sum, term);\r\n            }\r\n        }\r\n\r\n        return sum;\r\n    }\r\n}\r\n\r\ncontract FMath is FEGmath {\r\n    \r\n        function calcSpotPrice(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 swapFee\r\n    )\r\n        public pure\r\n        returns (uint256 spotPrice)\r\n    {\r\n        uint256 numer = bdiv(tokenBalanceIn, tokenWeightIn);\r\n        uint256 denom = bdiv(tokenBalanceOut, tokenWeightOut);\r\n        uint256 ratio = bdiv(numer, denom);\r\n        uint256 scale = bdiv(10**18, bsub(10**18, swapFee));\r\n        return  (spotPrice = bmul(ratio, scale));\r\n    }\r\n\r\n\r\n    function calcOutGivenIn(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 tokenAmountIn,\r\n        uint256 swapFee\r\n    )\r\n        public pure\r\n        returns (uint256 tokenAmountOut, uint256 tokenInFee)\r\n    {\r\n        uint256 weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\r\n        uint256 adjustedIn = bsub(10**18, swapFee);\r\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\r\n        uint256 y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\r\n        uint256 foo = bpow(y, weightRatio);\r\n        uint256 bar = bsub(1e18, foo);\r\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\r\n        tokenInFee = bsub(tokenAmountIn, adjustedIn);\r\n        return (tokenAmountOut, tokenInFee);\r\n    }\r\n\r\n    function calcOutGivenIn1(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 tokenAmountIn\r\n    )\r\n        public pure\r\n        returns (uint256 tokenAmountOut)\r\n    {\r\n        uint256 weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\r\n        uint256 adjustedIn = bsub(10**18, 0);\r\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\r\n        uint256 y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\r\n        uint256 foo = bpow(y, weightRatio);\r\n        uint256 bar = bsub(1e18, foo);\r\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    function calcInGivenOut(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 swapFee\r\n    )\r\n        public pure\r\n        returns (uint256 tokenAmountIn, uint256 tokenInFee)\r\n    {\r\n        uint256 weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\r\n        uint256 diff = bsub(tokenBalanceOut, tokenAmountOut);\r\n        uint256 y = bdiv(tokenBalanceOut, diff);\r\n        uint256 foo = bpow(y, weightRatio);\r\n        foo = bsub(foo, 1e18);\r\n        foo = bmul(tokenBalanceIn, foo);\r\n        tokenAmountIn = bsub(1e18, swapFee);\r\n        tokenAmountIn = bdiv(foo, tokenAmountIn);\r\n        tokenInFee = bdiv(foo, 1e18);\r\n        tokenInFee = bsub(tokenAmountIn, tokenInFee);\r\n        return (tokenAmountIn, tokenInFee);\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address whom) external view returns (uint256);\r\n    function allowance(address src, address dst) external view returns (uint256);\r\n    function approve(address dst, uint256 amt) external returns (bool);\r\n    function transfer(address dst, uint256 amt) external returns (bool);\r\n    function transferFrom(\r\n        address src, address dst, uint256 amt\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface wrap {\r\n    function deposit() external payable;\r\n    function withdraw(uint256 amt) external;\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface swap {\r\n    function depositInternal(address asset, uint256 amt) external;\r\n    function payMain(address payee, uint256 amount) external;\r\n    function payToken(address payee, uint256 amount) external;\r\n    function BUY(uint256 dot, address to, uint256 minAmountOut) external payable;\r\n}\r\n\r\nlibrary TransferHelper {\r\n    \r\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    \r\n    function isContract(address account) internal view returns (bool) {\r\n         bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n    \r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n   \r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract LPTokenBase is FEGmath {\r\n\r\n    mapping(address => uint256)                   internal _balance;\r\n    mapping(address => mapping(address=>uint256)) internal _allowance;\r\n    uint256 public totalSupply = 0;\r\n    event Approval(address indexed src, address indexed dst, uint256 amt);\r\n    event Transfer(address indexed src, address indexed dst, uint256 amt);\r\n    \r\n    function _mint(uint256 amt) internal {\r\n        _balance[address(this)] = badd(_balance[address(this)], amt);\r\n        totalSupply = badd(totalSupply, amt);\r\n        emit Transfer(address(0), address(this), amt);\r\n    }\r\n\r\n    function _move(address src, address dst, uint256 amt) internal {\r\n        require(_balance[src] >= amt);\r\n        _balance[src] = bsub(_balance[src], amt);\r\n        _balance[dst] = badd(_balance[dst], amt);\r\n        emit Transfer(src, dst, amt);\r\n    }\r\n\r\n    function _push(address to, uint256 amt) internal {\r\n        _move(address(this), to, amt);\r\n    }\r\n}\r\n\r\ncontract LPToken is LPTokenBase {\r\n\r\n    string  public name     = \"FEGex PRO\";\r\n    string  public symbol   = \"LP Token\";\r\n    uint8   public decimals = 18;\r\n\r\n    function allowance(address src, address dst) external view returns (uint256) {\r\n        return _allowance[src][dst];\r\n    }\r\n\r\n    function balanceOf(address whom) external view returns (uint256) {\r\n        return _balance[whom];\r\n    }\r\n\r\n    function approve(address dst, uint256 amt) external returns (bool) {\r\n        _allowance[msg.sender][dst] = amt;\r\n        emit Approval(msg.sender, dst, amt);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address dst, uint256 amt) external returns (bool) {\r\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\r\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address dst, uint256 amt) external returns (bool) {\r\n        uint256 oldValue = _allowance[msg.sender][dst];\r\n        if (amt > oldValue) {\r\n            _allowance[msg.sender][dst] = 0;\r\n        } else {\r\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\r\n        }\r\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\ninterface FEGexPair {\r\n    function initialize(address, address, address, address, uint256) external; \r\n    function deploySwap(address, uint256) external;\r\n    function userBalanceInternal(address _addr) external returns (uint256, uint256);\r\n}\r\n\r\ninterface newDeployer {\r\n    function createPair(address token, uint256 liqmain, uint256 liqtoken, address owner) external;\r\n}\r\n\r\ncontract FEGexPRO is LPToken, FMath {\r\n    using Address for address;\r\n    struct Record {\r\n        uint256 index;\r\n        uint256 balance;\r\n    }\r\n    \r\n    struct userLock {\r\n        bool setLock; // true = lockedLiquidity, false = unlockedLiquidity\r\n        uint256 unlockTime; // time liquidity can be released\r\n    }\r\n    \r\n    function getUserLock(address usr) public view returns(bool lock){\r\n        return (_userlock[usr].setLock);\r\n    }\r\n\r\n    event LOG_SWAP(\r\n        address indexed caller,\r\n        address indexed tokenIn,\r\n        address indexed tokenOut,\r\n        uint256         tokenAmountIn,\r\n        uint256         tokenAmountOut\r\n);\r\n\r\n    event LOG_JOIN(\r\n        address indexed caller,\r\n        address indexed tokenIn,\r\n        uint256         tokenAmountIn,\r\n        uint256         reservesAmount\r\n);\r\n\r\n    event LOG_EXIT(\r\n        address indexed caller,\r\n        address indexed tokenOut,\r\n        uint256         tokenAmountOut,\r\n        uint256         reservesAmount\r\n    );\r\n\r\n    event LOG_SMARTSWAP(\r\n        address indexed caller,\r\n        address indexed tokenIn,\r\n        address indexed tokenOut,\r\n        uint256         AmountIn,\r\n        uint256         AmountOut\r\n);\r\n\r\n    uint256 private spec;\r\n    address private _controller = 0x4c9BC793716e8dC05d1F48D8cA8f84318Ec3043C; \r\n    address private _setter = 0x86882FA66aC57039b10D78e2D3205592A44664c0;\r\n    address private fegp;\r\n    address private FEG = 0x389999216860AB8E0175387A0c90E5c52522C945;\r\n    address private burn = 0x000000000000000000000000000000000000dEaD;\r\n    address public _poolOwner;\r\n    address public Main = 0xf786c34106762Ab4Eeb45a51B42a62470E9D5332;\r\n    address private newDep;\r\n    address public Token;\r\n    address public pairRewardPool;\r\n    address private FEGstake;\r\n    address public Bonus;\r\n    uint256 public MAX_BUY_RATIO = 100e18;\r\n    uint256 public MAX_SELL_RATIO;\r\n    uint256 public PSS = 20; // pairRewardPool Share 0.2% default\r\n    uint256 public RPF = 1000; // Smart Rising Price Floor Setting\r\n    address[] private _tokens;\r\n    uint256 public _totalSupply1;\r\n    uint256 public _totalSupply2;\r\n    uint256 public _totalSupply7;\r\n    uint256 public _totalSupply8;\r\n    uint256 public lockedLiquidity;\r\n    uint256 public totalSentRebates;\r\n    bool private live = false;\r\n    //bool private on = true;\r\n    bool public open = false;\r\n    mapping(address=>Record) private  _records;\r\n    mapping(address=>userLock) private  _userlock;\r\n    mapping(address=>userLock) public  _unlockTime;\r\n    mapping(address=>bool) private whiteListContract;\r\n    mapping(address => uint256) private _balances1;\r\n    mapping(address => uint256) private _balances2;\r\n    uint256 private constant MAX_RATIO  = 50; // Max ratio for all trades based on liquidity amount\r\n    uint256 public tx1;\r\n    uint256 public tx2 = 99;\r\n    uint256 private status = 0;\r\n   \r\n    function initialize( address _token1, address owner, address _made, address _fegp, uint256 ol) external{\r\n        require(live == false, \"Can only use once\");\r\n        Token = _token1;\r\n        _poolOwner = owner;\r\n        pairRewardPool = owner;\r\n        spec = ol;\r\n        fegp = _fegp;\r\n        FEGstake = _made;\r\n        MAX_SELL_RATIO = bmul(IERC20(Token).totalSupply(), bdiv(1, 20));\r\n    }\r\n    \r\n    receive() external payable {\r\n    }\r\n\r\n    function userBalanceInternal(address _addr) public view returns(uint256, uint256) {\r\n        uint256 main  = _balances2[_addr];\r\n        uint256 token = _balances1[_addr];\r\n        return (token, main);\r\n    } \r\n    \r\n    function isContract(address account) internal view returns(bool) {\r\n        \r\n        if(IsWhiteListContract(account)) {  return false; }\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n    \r\n    function addWhiteListContract(address _addy, bool boolean) public {\r\n        require(msg.sender == _setter);\r\n        whiteListContract[_addy] = boolean;\r\n    }\r\n    \r\n    function IsWhiteListContract(address _addy) public view returns(bool){\r\n        return whiteListContract[_addy];\r\n    }\r\n    \r\n    modifier noContract() {\r\n        require(isContract(msg.sender) == false, \"Unapproved contracts are not allowed to interact with the swap\");\r\n        _;\r\n    }\r\n    \r\n    function sync() public {  // updates the liquidity to current state\r\n        _records[Token].balance = IERC20(Token).balanceOf(address(this)) - _totalSupply1;  \r\n        uint256 al = (_totalSupply2 + _totalSupply7 + _totalSupply8);\r\n        _records[Main].balance = IERC20(Main).balanceOf(address(this)) - al;\r\n    }\r\n    \r\n    function setMaxBuySellRatio(uint256 sellmax, uint256 buymax) public {\r\n        require(msg.sender == _poolOwner, \"You do not have permission\");\r\n        uint256 tob = IERC20(Token).totalSupply();\r\n        require (sellmax >= tob/1000 && sellmax <= tob, \"min 0.1% of token supply, max 100% of token supply\"); \r\n        require (buymax >= 1e18, \"1 BNB minimum\");\r\n        MAX_SELL_RATIO = sellmax;\r\n        MAX_BUY_RATIO = buymax;\r\n    }\r\n    \r\n    function openit() public{ // Since only sets to true, trading can never be turned off\r\n        require(msg.sender == _poolOwner);\r\n        open = true;\r\n    }\r\n    \r\n    function setBonus(address _bonus) public{ // For tokens that have a 3rd party token reflection\r\n        require(msg.sender == _poolOwner && _bonus != Main  && _bonus != Token);\r\n        require(isContract(_bonus) == true);\r\n        Bonus = _bonus;\r\n    }\r\n    \r\n    function setStakePool(address _stake, address _fegp, address newd) public {\r\n        require(msg.sender == _setter);\r\n        FEGstake = _stake;\r\n        fegp = _fegp;\r\n        newDep = newd;\r\n    }\r\n    \r\n    function setPRP(address prp) public {\r\n        require(msg.sender == _setter);\r\n        pairRewardPool = prp;\r\n    }\r\n    \r\n    function setTX1(uint256 amt) public {\r\n        require(msg.sender == _setter);\r\n        tx1 = amt;\r\n    }\r\n    \r\n    function getBalance(address token)\r\n        external view\r\n        returns (uint256)\r\n    {\r\n        \r\n        return _records[token].balance;\r\n    }\r\n\r\n    function setCont(address manager, address set, address ad)\r\n        external\r\n    {\r\n        require(msg.sender == _controller);\r\n        _controller = manager;\r\n        _setter = set;\r\n        _poolOwner = ad; // Incase pool owner wallet was compromised and needs new access\r\n    }\r\n    \r\n    function setLockLiquidity() public { //\r\n        address user;\r\n        user = msg.sender;\r\n        require(getUserLock(user) == false, \"Liquidity already locked\");\r\n        uint256 total = IERC20(address(this)).balanceOf(user);\r\n        userLock storage ulock = _userlock[user];\r\n        userLock storage time = _unlockTime[user];\r\n        ulock.setLock = true;\r\n        time.unlockTime = block.timestamp + 90 days; \r\n        lockedLiquidity += total;\r\n    }\r\n    \r\n    function deploySwap (address _from, uint256 liqtoken)\r\n        external\r\n        {\r\n        require(live == false);\r\n        uint256 much = IERC20(Token).balanceOf(address(this));\r\n        uint256 much1 = IERC20(Main).balanceOf(address(this));\r\n        _records[Token] = Record({\r\n            index: _tokens.length,\r\n            balance: much\r\n        });\r\n        \r\n        _records[Main] = Record({\r\n            index: _tokens.length,\r\n            balance: much1\r\n        });\r\n        \r\n        _tokens.push(Token);\r\n        _tokens.push(Main);\r\n        uint256 a = bdiv(_records[Token].balance, 1e9);\r\n        uint256 b = bdiv(_records[Main].balance, 1e18);\r\n        uint256 c = a + b;\r\n        _mint(c);\r\n        _push(_from, c);\r\n        lockedLiquidity = badd(lockedLiquidity, c);\r\n        userLock storage ulock = _userlock[_from];\r\n        userLock storage time = _unlockTime[_from];\r\n        ulock.setLock = true;\r\n        time.unlockTime = block.timestamp + 365 days; \r\n        live = true;\r\n        tx1 = bmul(100, bdiv(much, liqtoken)); \r\n    }\r\n   \r\n    function getSpotPrice(address tokenIn, address tokenOut)\r\n        public view\r\n        returns (uint256 spotPrice)\r\n    {\r\n        \r\n        Record storage inRecord = _records[address(tokenIn)];\r\n        Record storage outRecord = _records[address(tokenOut)];\r\n        return calcSpotPrice(inRecord.balance, bmul(1e18, 25), outRecord.balance, bmul(1e18, 25), 2e15);\r\n    }\r\n        \r\n    function depositInternal(address asset, uint256 amt) external {\r\n        require(asset == Main || asset == Token, \"Not supported\");\r\n        require(status == 0, \"No reentry\");\r\n        status = 1;\r\n        require(open == true);\r\n        \r\n        if(asset == Token){\r\n        uint256 bef = _records[Token].balance;     \r\n        _pullUnderlying(Token, msg.sender, amt);\r\n        uint256 aft = bsub(IERC20(Token).balanceOf(address(this)), _totalSupply1);  \r\n        uint256 finalAmount = bsub(aft, bef);  \r\n        _totalSupply1 += finalAmount;\r\n        _balances1[msg.sender] += finalAmount;\r\n        }\r\n        else{\r\n        uint256 bef = _records[Main].balance;\r\n        _pullUnderlying(Main, msg.sender, amt);\r\n        uint256 aft = bsub(IERC20(Main).balanceOf(address(this)), badd(_totalSupply2, badd(_totalSupply7, _totalSupply8)));\r\n        uint256 finalAmount = bsub(aft, bef);\r\n        _totalSupply2  += finalAmount;\r\n        _balances2[msg.sender] += finalAmount;\r\n        }\r\n        status = 0;\r\n    }\r\n\r\n    function withdrawInternal(address asset, uint256 amt) external {\r\n        require(asset == Main || asset == Token, \"Not supported\");\r\n        require(status == 0, \"No reentry\");\r\n        status = 1;\r\n        \r\n        if(asset == Token){\r\n        require(_balances1[msg.sender] >= amt, \"Not enough Token\");\r\n        _totalSupply1 -= amt;\r\n        _balances1[msg.sender] -= amt;\r\n        _pushUnderlying(Token, msg.sender, amt);\r\n        }\r\n        else{\r\n        require(_balances2[msg.sender] >= amt, \"Not enough Main\");\r\n        _totalSupply2 -= amt;\r\n        _balances2[msg.sender] -= amt;\r\n        _pushUnderlying(Main, msg.sender, amt);\r\n        }\r\n        status = 0;\r\n    }\r\n\r\n    function swapToSwap(address path, address asset, address to, uint256 amt) external {\r\n        require(asset == Main || asset == Token, \"Not supported\");\r\n        require(status == 0, \"No reentry\");\r\n        status = 1;\r\n        if(asset == Main){\r\n        require(_balances2[msg.sender] >= amt, \"Not enough Main\");\r\n        IERC20(address(Main)).approve(address(path), amt);   \r\n        _totalSupply2 -= amt;\r\n        _balances2[msg.sender] -= amt;\r\n        swap(path).depositInternal(Main, amt);\r\n        (uint256 tokens, uint256 mains) = FEGexPair(path).userBalanceInternal(address(this));\r\n        swap(path).payMain(to, mains);\r\n        tokens = 0;\r\n        }\r\n    \r\n        else{\r\n        require(_balances1[msg.sender] >= amt, \"Not enough Token\");\r\n        IERC20(address(Token)).approve(address(path), amt);\r\n        _totalSupply1 -= amt;\r\n        _balances1[msg.sender] -= amt;\r\n        swap(path).depositInternal(Token, amt);\r\n        (uint256 tokens, uint256 mains) = FEGexPair(path).userBalanceInternal(address(this));\r\n        swap(path).payToken(to, tokens);\r\n        mains = 0;\r\n        }\r\n        status = 0;\r\n    }\r\n    \r\n    function transfer(address dst, uint256 amt) external returns(bool) {\r\n        require(getUserLock(msg.sender) == false, \"Liquidity is locked, you cannot remove liquidity until after lock time.\");\r\n        _move(msg.sender, dst, amt);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint256 amt) external returns(bool) {\r\n        require(msg.sender == src || amt <= _allowance[src][msg.sender]);\r\n        require(getUserLock(msg.sender) == false, \"Liquidity is locked, you cannot remove liquidity until after lock time.\");\r\n        _move(src, dst, amt);\r\n        if (msg.sender != src && _allowance[src][msg.sender] != type(uint256).max) {\r\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\r\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    function addBothLiquidity(uint256 poolAmountOut, uint[] calldata maxAmountsIn)\r\n        external \r\n    {\r\n        require(status == 0, \"No reentry\");\r\n        status = 1;\r\n        uint256 poolTotal = totalSupply;\r\n        uint256 ratio = bdiv(poolAmountOut, poolTotal);\r\n        \r\n        if(getUserLock(msg.sender) == true){\r\n        lockedLiquidity += poolAmountOut;    \r\n        }\r\n        \r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            address t = _tokens[i];\r\n            uint256 bal = _records[t].balance;\r\n            \r\n            uint256 tokenAmountIn = bmul(ratio, bal); \r\n            require(tokenAmountIn <= maxAmountsIn[i]);\r\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn, 0);\r\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\r\n            \r\n        }\r\n        _mint(poolAmountOut);\r\n        _push(msg.sender, poolAmountOut);\r\n        sync();\r\n        status = 0;\r\n    }\r\n   \r\n    function removeBothLiquidity(uint256 poolAmountIn, uint[] calldata minAmountsOut)\r\n        external \r\n    {\r\n        \r\n        require(getUserLock(msg.sender) == false, \"Liquidity is locked, you cannot remove liquidity until after lock time.\");\r\n        require(status == 0, \"No reentry\");\r\n        status = 1;\r\n        sync();\r\n        uint256 poolTotal = totalSupply;\r\n        uint256 ratio = bdiv(poolAmountIn, poolTotal);\r\n\r\n        _balance[msg.sender] -= poolAmountIn;\r\n        totalSupply -= poolAmountIn;\r\n        emit Transfer(msg.sender, address(0), poolAmountIn);\r\n        \r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n            address t = _tokens[i];\r\n            uint256 bal = _records[t].balance;\r\n            uint256 tokenAmountOut = bmul(ratio, bal);\r\n            require(tokenAmountOut >= minAmountsOut[i], \"Minimum amount out not met\");\r\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut, 0);\r\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\r\n        }\r\n        \r\n        uint256 tab = bmul(ratio, _balances2[burn]);\r\n        _balances2[burn] -= tab;\r\n        _balances2[msg.sender] += tab;\r\n        sync();\r\n        if(Bonus != address(0)){\r\n        uint256 bal1 = bmul(ratio, IERC20(Bonus).balanceOf(address(this)));\r\n        if(bal1 > 0){\r\n        _pushUnderlying(Bonus, msg.sender, bal1);\r\n        }\r\n        }\r\n        status = 0;\r\n    }\r\n    \r\n    function sendRebate() internal {\r\n        uint256 re = address(this).balance / 8;\r\n        TransferHelper.safeTransferETH(msg.sender, re);\r\n        totalSentRebates += re;\r\n    }\r\n    \r\n    function BUYSmart(\r\n        uint256 tokenAmountIn,\r\n        uint256 minAmountOut\r\n    )   \r\n        external \r\n        returns(uint256 tokenAmountOut)\r\n    {\r\n\r\n        require(_balances2[msg.sender] >= tokenAmountIn, \"Not enough Main, deposit more\");\r\n        require(status == 0, \"No reentry\");\r\n        status = 1;\r\n        Record storage inRecord = _records[address(Main)];\r\n        Record storage outRecord = _records[address(Token)];\r\n        require(tokenAmountIn <= MAX_BUY_RATIO, \"ERR_BUY_IN_RATIO\");\r\n        uint256 tokenInFee;\r\n        (tokenAmountOut, tokenInFee) = calcOutGivenIn(\r\n                                            inRecord.balance,\r\n                                            bmul(1e18, 25),\r\n                                            outRecord.balance,\r\n                                            bmul(1e18, 25),\r\n                                            bmul(tokenAmountIn, bdiv(999, 1000)),\r\n                                            0\r\n                                        );\r\n        \r\n        require(tokenAmountOut <= bmul(outRecord.balance, bdiv(MAX_RATIO, 100)), \"Over MAX_OUT_RATIO\");                                \r\n        require(tokenAmountOut >= minAmountOut, \"Minimum amount out not met\");   \r\n        _balances2[msg.sender] -= tokenAmountIn;\r\n        _totalSupply2 -= tokenAmountIn;\r\n        _balances1[msg.sender] += tokenAmountOut;\r\n        _totalSupply1 += tokenAmountOut;\r\n        _totalSupply8 += bmul(tokenAmountIn, bdiv(1, 1000));\r\n        sync();\r\n        emit LOG_SMARTSWAP(msg.sender, Main, Token, tokenAmountIn, tokenAmountOut);\r\n        uint256 hold = IERC20(FEG).balanceOf(address(msg.sender));\r\n        if(address(this).balance > 0 && tokenAmountIn >= 5e16 && hold >= 2e19){\r\n        uint256 re = bdiv(address(this).balance, 8);\r\n        TransferHelper.safeTransferETH(msg.sender, re);\r\n        totalSentRebates += re;\r\n        }\r\n        status = 0;\r\n        return(tokenAmountOut);\r\n    }\r\n    \r\n    function BUY(\r\n        uint256 dot,\r\n        address to,\r\n        uint256 minAmountOut\r\n    )  \r\n        external payable\r\n        returns(uint256 tokenAmountOut)\r\n    {\r\n        require(status == 0, \"No reentry\");\r\n        status = 1;\r\n        require(open == true, \"Swap not opened\");\r\n        uint256 maker = bmul(msg.value, bdiv(995, 1000));\r\n        wrap(Main).deposit{value: maker}();\r\n        TransferHelper.safeTransferETH(msg.sender, bmul(msg.value, bdiv(5, 1000)));\r\n        \r\n        if(Address.isContract(msg.sender) == true){ \r\n        require(dot == spec, \"Contracts are not allowed to interact with the Swap\");\r\n        }\r\n        \r\n        uint256 hold = IERC20(FEG).balanceOf(address(msg.sender));\r\n        uint256 io = address(this).balance;\r\n        \r\n        if(io > 0 && msg.value >= 5e16 && hold >= 2e19){\r\n        sendRebate();\r\n        }\r\n        \r\n        Record storage inRecord = _records[address(Main)];\r\n        Record storage outRecord = _records[address(Token)];\r\n        \r\n        require(msg.value <= MAX_BUY_RATIO, \"ERR_BUY_IN_RATIO\");\r\n        \r\n        uint256 tokenInFee;\r\n        (tokenAmountOut, tokenInFee) = calcOutGivenIn(\r\n                                            inRecord.balance,\r\n                                            bmul(1e18, 25),\r\n                                            outRecord.balance,\r\n                                            bmul(1e18, 25),\r\n                                            bmul(maker, bdiv(999, 1000)),\r\n                                            0\r\n                                        );\r\n                                        \r\n        require(tokenAmountOut <= bmul(outRecord.balance, bdiv(MAX_RATIO, 100)), \"Over MAX_OUT_RATIO\");\r\n        _totalSupply8 += bmul(msg.value, bdiv(1, 1000));                                \r\n        require(tokenAmountOut >= minAmountOut, \"Minimum amount out not met\");\r\n        _pushUnderlying(Token, to, tokenAmountOut);\r\n        sync();\r\n\r\n        emit LOG_SWAP(msg.sender, Main, Token, msg.value, bmul(tokenAmountOut, bdiv(tx1, 100)));\r\n        status = 0;\r\n        return(tokenAmountOut);\r\n    }\r\n    \r\n    function SELL(\r\n        uint256 dot,\r\n        address to,\r\n        uint256 tokenAmountIn,\r\n        uint256 minAmountOut\r\n    )   \r\n        external\r\n        returns(uint256 tokenAmountOut)\r\n    {   \r\n        if(IsWhiteListContract(msg.sender) == false){\r\n        require(status == 0, \"No reentry\");\r\n        }\r\n        status = 1;\r\n        require(open == true, \"Swap not opened\");\r\n        if(Address.isContract(msg.sender) == true){ \r\n        require(dot == spec, \"Contracts are not allowed to interact with the Swap\");\r\n        }\r\n        \r\n        require(tokenAmountIn <= MAX_SELL_RATIO, \"ERR_SELL_RATIO\");\r\n        uint256 omm = _records[Token].balance;\r\n        _pullUnderlying(Token, msg.sender, tokenAmountIn);\r\n        _records[Token].balance = IERC20(Token).balanceOf(address(this)) - _totalSupply1;\r\n        uint256 trueamount = bmul((_records[Token].balance - omm), bdiv(998, 1000));\r\n        \r\n        tokenAmountOut = calcOutGivenIn1(\r\n                                            _records[Token].balance,\r\n                                            bmul(1e18, 25),\r\n                                            _records[Main].balance,\r\n                                            bmul(1e18, 25),\r\n                                            trueamount\r\n                                        );\r\n        \r\n        require(tokenAmountOut <= bmul(_records[Main].balance, bdiv(MAX_RATIO, 100)), \"Over MAX_OUT_RATIO\");                                \r\n        require(tokenAmountOut >= minAmountOut, \"Minimum amount out not met\");\r\n        uint256 toka = bmul(tokenAmountOut, bdiv(RPF, 1000));\r\n        uint256 tokAmountI  = bmul(toka, bdiv(15, 10000));\r\n        uint256 tok = bmul(toka, bdiv(15, 10000));\r\n        uint256 tokAmountI2 =  bmul(toka, bdiv(PSS, 10000));\r\n        uint256 io = (toka - (tokAmountI + tok + tokAmountI2));\r\n        uint256 tokAmountI1 = bmul(io, bdiv(999, 1000));\r\n        uint256 ox = _balances2[address(this)];\r\n        \r\n        if(ox > 1e16){\r\n        _totalSupply2 -= ox;\r\n        _balances2[address(this)] = 0;\r\n        }\r\n        \r\n        wrap(Main).withdraw(tokAmountI1 + ox + tokAmountI);\r\n        TransferHelper.safeTransferETH(to, bmul(tokAmountI1, bdiv(99, 100)));\r\n        _totalSupply8 += bmul(io, bdiv(1, 1000));\r\n        uint256 oss = bmul(tokAmountI2, bdiv(5, 100));\r\n        uint256 osss = bmul(tokAmountI2, bdiv(15, 100));\r\n        _balances2[pairRewardPool] += bmul(tokAmountI2, bdiv(80, 100));\r\n        _balances2[_setter] += osss;\r\n        _balances2[burn] += oss;\r\n        _totalSupply2 += tokAmountI2;\r\n        _totalSupply7 += tok;\r\n        payStake();\r\n        burnFEG();\r\n        sync();\r\n        emit LOG_SWAP(msg.sender, Token, Main, trueamount, bmul(tokAmountI1, bdiv(99, 100)));\r\n        status = 0;\r\n        return tokAmountI1;\r\n    }\r\n    \r\n     function SELLSmart(\r\n        uint256 tokenAmountIn,\r\n        uint256 minAmountOut\r\n    )   \r\n        external\r\n        returns(uint256 tokenAmountOut)\r\n    {\r\n        require(status == 0, \"No reentry\");\r\n        status = 1;\r\n        uint256 tai = tokenAmountIn;\r\n        require(_balances1[msg.sender] >= tokenAmountIn, \"Not enough Token\");\r\n        Record storage inRecord = _records[address(Token)];\r\n        Record storage outRecord = _records[address(Main)];\r\n        require(tokenAmountIn <= MAX_SELL_RATIO, \"ERR_SELL_RATIO\");\r\n\r\n        tokenAmountOut = calcOutGivenIn1(\r\n                                            inRecord.balance,\r\n                                            bmul(1e18, 25),\r\n                                            outRecord.balance,\r\n                                            bmul(1e18, 25),\r\n                                            bmul(tokenAmountIn, bdiv(998, 1000)) // 0.2% liquidity fee\r\n                                        );\r\n\r\n        require(tokenAmountOut <= bmul(outRecord.balance, bdiv(MAX_RATIO, 100)), \"Over MAX_OUT_RATIO\");\r\n        uint256 toka = bmul(tokenAmountOut, bdiv(RPF, 1000));\r\n        uint256 tokAmountI  = bmul(toka, bdiv(15, 10000));\r\n        uint256 tok = bmul(toka, bdiv(15, 10000));\r\n        uint256 tokAmountI2 =  bmul(toka, bdiv(PSS, 10000));\r\n        uint256 io = (toka - (tokAmountI + tok + tokAmountI2));\r\n        uint256 tokAmountI1 = bmul(io, bdiv(999, 1000));\r\n        _totalSupply8 += bmul(io, bdiv(1, 1000));\r\n        require(tokAmountI1 >= minAmountOut, \"Minimum amount out not met\");\r\n        _balances1[msg.sender] -= tokenAmountIn;\r\n        _totalSupply1 -= tokenAmountIn;\r\n        _balances2[msg.sender] += tokAmountI1;\r\n        _balances2[address(this)] += tokAmountI;\r\n        uint256 os = bmul(tokAmountI2, bdiv(80, 100));\r\n        uint256 oss = bmul(tokAmountI2, bdiv(5, 100));\r\n        uint256 osss = bmul(tokAmountI2, bdiv(15, 100));\r\n        _balances2[pairRewardPool] += os;\r\n        _balances2[_setter] += osss;\r\n        _balances2[burn] += oss;\r\n        _totalSupply2 += (tokAmountI + tokAmountI2 + tokAmountI1);\r\n        _totalSupply7 += tok;\r\n        sync();\r\n        burnFEG();\r\n        emit LOG_SMARTSWAP(msg.sender, Token, Main, tai, tokAmountI1);\r\n        status = 0;\r\n        return(tokAmountI1);\r\n    }\r\n        \r\n    function setPSSRPF(uint256 _PSS, uint256 _RPF) external {\r\n        \r\n        uint256 tot = _records[Main].balance;\r\n        require(msg.sender == _poolOwner && tot >= 5e18, \"You do not have permission\");\r\n        \r\n        if(tot < 20e18) {// Incentive for providing higher liquidity\r\n        require(_RPF >= 990 && _RPF <= 1000 && _PSS <= 100 && _PSS != 0, \"Cannot set over 1%\"); \r\n        }\r\n        \r\n        if(tot >= 20e18) {// Incentive for providing higher liquidity\r\n        require(_RPF >= 900 && _RPF <= 1000 && _PSS <= 500 && _PSS != 0, \"Cannot set PSS over 5% or RPF over 10%\"); \r\n        }\r\n        \r\n        RPF = _RPF;\r\n        PSS = _PSS;\r\n    }\r\n    \r\n    function releaseLiquidity(address user) external { // Allows removal of liquidity after the lock period is over\r\n        require(status == 0, \"No reentry\");\r\n        status = 1;\r\n        require(getUserLock(user) == true, \"Liquidity not locked\");\r\n        userLock storage ulock = _userlock[user];\r\n        userLock storage time = _unlockTime[user];\r\n        if(msg.sender == _controller){\r\n        time.unlockTime = block.timestamp + 1 days; // 24 hour notice for users\r\n        }\r\n        else{\r\n        require(block.timestamp >= time.unlockTime && msg.sender == _poolOwner, \"Liquidity is locked, you cannot release liquidity until after lock time.\");\r\n        ulock.setLock = false;\r\n        uint256 total = IERC20(address(this)).balanceOf(user);\r\n        lockedLiquidity -= total;\r\n        }\r\n        status = 0;\r\n    }\r\n\r\n    function Migrate() external { //Incase we upgrade to PROv2 in the future\r\n        require(status == 0, \"No reentry\");\r\n        status = 1;\r\n        require(msg.sender == _poolOwner || msg.sender == _controller && newDep != address(0), \"Not ready\");\r\n        sync();\r\n        userLock storage ulock = _userlock[_poolOwner];\r\n        IERC20(Main).approve(newDep, 1e30);\r\n        IERC20(Token).approve(newDep, 1e50);\r\n        uint256 tot = _balance[_poolOwner];\r\n        _balance[_poolOwner] -= tot;\r\n        uint256 ts = totalSupply;\r\n        uint256 amt = bmul(_records[Main].balance, bdiv(tot, ts));\r\n        uint256 amt1 = bmul(_records[Token].balance, bdiv(tot, ts));\r\n        totalSupply -= tot;\r\n        ulock.setLock = false;\r\n        lockedLiquidity -= tot;\r\n        newDeployer(newDep).createPair(Token, amt, amt1, _poolOwner);\r\n        sync();\r\n        status = 0;\r\n    }\r\n\r\n    function _pullUnderlying(address erc20, address from, uint256 amount)\r\n        internal \r\n    {   \r\n        bool xfer = IERC20(erc20).transferFrom(from, address(this), amount);\r\n        require(xfer);\r\n    }\r\n    \r\n    function _pushUnderlying(address erc20, address to, uint256 amount)\r\n        internal \r\n    {   \r\n        bool xfer = IERC20(erc20).transfer(to, amount);\r\n        require(xfer);\r\n    }\r\n    \r\n    function burnFEG() internal {\r\n        if(_totalSupply8 > 25e14){ \r\n        wrap(Main).withdraw(_totalSupply8);\r\n        swap(fegp).BUY{value:bmul(_totalSupply8, bdiv(99, 100))}(1001, burn, 1);\r\n        _totalSupply8 = 0;\r\n        }\r\n    }\r\n    \r\n    function payStake() internal {   \r\n        if(_totalSupply7 > 2e15) {\r\n        _pushUnderlying(Main, FEGstake, _totalSupply7);\r\n        _totalSupply7 = 0;\r\n        }\r\n    }\r\n    \r\n    function payMain(address payee, uint256 amount)\r\n        external  \r\n        \r\n    {   \r\n        require(_balances2[msg.sender] >= amount, \"Not enough token\");\r\n        uint256 amt = bmul(amount, bdiv(997, 1000));\r\n        _balances2[msg.sender] -= amount;\r\n        _balances2[payee] += amt;\r\n        _balances2[burn] += bsub(amount, amt);\r\n        status = 0;\r\n    }\r\n    \r\n    function payToken(address payee, uint256 amount)\r\n        external  \r\n        \r\n    {\r\n        require(status == 0, \"No reentry\");\r\n        status = 1;\r\n        require(_balances1[msg.sender] >= amount, \"Not enough token\");\r\n        _balances1[msg.sender] -= amount;\r\n        _balances1[payee] += amount;\r\n        status = 0;\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reservesAmount\",\"type\":\"uint256\"}],\"name\":\"LOG_EXIT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reservesAmount\",\"type\":\"uint256\"}],\"name\":\"LOG_JOIN\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"AmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"AmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_SMARTSWAP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_SWAP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dot\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"name\":\"BUY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"name\":\"BUYSmart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Bonus\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addy\",\"type\":\"address\"}],\"name\":\"IsWhiteListContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BUY_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SELL_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Main\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PSS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RPF\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dot\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"name\":\"SELL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"name\":\"SELLSmart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_poolOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply7\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply8\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_unlockTime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"setLock\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"}],\"name\":\"addBothLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"boolean\",\"type\":\"bool\"}],\"name\":\"addWhiteListContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"whom\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcInGivenOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenInFee\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcOutGivenIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenInFee\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"name\":\"calcOutGivenIn1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liqtoken\",\"type\":\"uint256\"}],\"name\":\"deploySwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"depositInternal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"getUserLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"lock\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_made\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fegp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ol\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"open\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairRewardPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"payMain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"payToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"releaseLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"}],\"name\":\"removeBothLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bonus\",\"type\":\"address\"}],\"name\":\"setBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"set\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ad\",\"type\":\"address\"}],\"name\":\"setCont\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setLockLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sellmax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buymax\",\"type\":\"uint256\"}],\"name\":\"setMaxBuySellRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"prp\",\"type\":\"address\"}],\"name\":\"setPRP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_PSS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_RPF\",\"type\":\"uint256\"}],\"name\":\"setPSSRPF\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stake\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fegp\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newd\",\"type\":\"address\"}],\"name\":\"setStakePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"setTX1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"path\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"swapToSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSentRebates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tx1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tx2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"userBalanceInternal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"withdrawInternal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "FEGexPRO", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "5", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6e975ff83a4186e01467ea640ea3732de6c1a56f22974857b5b47eb9274d0e34"}