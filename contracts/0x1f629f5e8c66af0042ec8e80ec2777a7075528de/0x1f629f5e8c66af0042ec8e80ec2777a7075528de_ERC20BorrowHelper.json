{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/ERC20BorrowHelper.sol\": {\r\n      \"content\": \"pragma solidity =0.8.17;\\nimport {IAstariaRouter} from \\\"core/interfaces/IAstariaRouter.sol\\\";\\nimport {ILienToken} from \\\"core/interfaces/ILienToken.sol\\\";\\nimport {ICollateralToken} from \\\"core/interfaces/ICollateralToken.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {ILocker} from \\\"core/TheLocker.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport \\\"./test/utils/ERC721Recipient.sol\\\";\\n\\ncontract ERC20BorrowHelper is ERC721Recipient {\\n  using SafeTransferLib for ERC20;\\n\\n  address public immutable WETH;\\n  ICollateralToken public CT;\\n  ILocker public immutable LOCKER;\\n  IAstariaRouter public immutable ROUTER;\\n\\n  constructor(\\n    address _WETH9,\\n    ICollateralToken _CT,\\n    ILocker _LOCKER,\\n    IAstariaRouter _ROUTER\\n  ) {\\n    WETH = _WETH9;\\n    CT = _CT;\\n    LOCKER = _LOCKER;\\n    ROUTER = _ROUTER;\\n  }\\n\\n  function borrow(\\n    ERC20 collateral,\\n    uint256 amount,\\n    IAstariaRouter.NewLienRequest calldata newLienRequest\\n  ) external payable {\\n    collateral.safeTransferFrom(msg.sender, address(this), amount);\\n    collateral.safeApprove(address(LOCKER), amount);\\n    uint256 newId = LOCKER.deposit(collateral, amount);\\n    LOCKER.approve(address(ROUTER), newId);\\n    (, ILienToken.Stack memory newStack) = ROUTER.commitToLien(\\n      IAstariaRouter.Commitment({\\n        tokenContract: address(LOCKER),\\n        tokenId: newId,\\n        lienRequest: newLienRequest\\n      })\\n    );\\n    if (newStack.lien.token == WETH) {\\n      msg.sender.call{value: newStack.point.amount}(\\\"\\\");\\n    } else {\\n      ERC20(newStack.lien.token).safeTransfer(\\n        msg.sender,\\n        newStack.point.amount\\n      );\\n    }\\n    CT.safeTransferFrom(address(this), msg.sender, newStack.lien.collateralId);\\n  }\\n\\n  receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IAstariaRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\n/**\\n *  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557\\n * \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\\n * \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\\n * \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\\n * \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\\n * \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\\n *\\n * Astaria Labs, Inc\\n */\\n\\npragma solidity =0.8.17;\\n\\nimport {IERC721} from \\\"core/interfaces/IERC721.sol\\\";\\nimport {ITransferProxy} from \\\"core/interfaces/ITransferProxy.sol\\\";\\nimport {IERC4626} from \\\"core/interfaces/IERC4626.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {ICollateralToken} from \\\"core/interfaces/ICollateralToken.sol\\\";\\nimport {ILienToken} from \\\"core/interfaces/ILienToken.sol\\\";\\n\\nimport {IPausable} from \\\"core/utils/Pausable.sol\\\";\\nimport {IBeacon} from \\\"core/interfaces/IBeacon.sol\\\";\\n// import {IERC4626RouterBase} from \\\"gpl/interfaces/IERC4626RouterBase.sol\\\";\\nimport {OrderParameters} from \\\"seaport-types/src/lib/ConsiderationStructs.sol\\\";\\n\\ninterface IAstariaRouter is IPausable, IBeacon {\\n  enum FileType {\\n    FeeTo,\\n    LiquidationFee,\\n    ProtocolFee,\\n    MaxStrategistFee,\\n    MinEpochLength,\\n    MaxEpochLength,\\n    MinInterestRate,\\n    MaxInterestRate,\\n    MinLoanDuration,\\n    AuctionWindow,\\n    StrategyValidator,\\n    Implementation,\\n    CollateralToken,\\n    LienToken,\\n    TransferProxy\\n  }\\n\\n  struct File {\\n    FileType what;\\n    bytes data;\\n  }\\n\\n  event FileUpdated(FileType what, bytes data);\\n\\n  struct RouterStorage {\\n    //slot 1\\n    uint32 auctionWindow;\\n    uint32 liquidationFeeNumerator;\\n    uint32 liquidationFeeDenominator;\\n    uint32 maxEpochLength;\\n    uint32 minEpochLength;\\n    uint32 protocolFeeNumerator;\\n    uint32 protocolFeeDenominator;\\n    uint32 minLoanDuration;\\n    //slot 2\\n    ICollateralToken COLLATERAL_TOKEN; //20\\n    ILienToken LIEN_TOKEN; //20\\n    ITransferProxy TRANSFER_PROXY; //20\\n    address feeTo; //20\\n    address BEACON_PROXY_IMPLEMENTATION; //20\\n    uint256 maxInterestRate; //6\\n    //slot 3 +\\n    address guardian; //20\\n    address newGuardian; //20\\n    mapping(uint8 => address) strategyValidators;\\n    mapping(uint8 => address) implementations;\\n    //A strategist can have many deployed vaults\\n    mapping(address => bool) vaults;\\n    uint256 maxStrategistFee; //4\\n    address WETH;\\n  }\\n\\n  enum ImplementationType {\\n    PrivateVault,\\n    PublicVault,\\n    WithdrawProxy\\n  }\\n\\n  enum LienRequestType {\\n    DEACTIVATED,\\n    UNIQUE,\\n    COLLECTION,\\n    UNIV3_LIQUIDITY\\n  }\\n\\n  struct StrategyDetailsParam {\\n    uint8 version;\\n    uint256 deadline;\\n    address payable vault;\\n  }\\n\\n  struct MerkleData {\\n    bytes32 root;\\n    bytes32[] proof;\\n  }\\n\\n  struct NewLienRequest {\\n    StrategyDetailsParam strategy;\\n    bytes nlrDetails;\\n    bytes32 root;\\n    bytes32[] proof;\\n    uint256 amount;\\n    uint8 v;\\n    bytes32 r;\\n    bytes32 s;\\n  }\\n\\n  struct Commitment {\\n    address tokenContract;\\n    uint256 tokenId;\\n    NewLienRequest lienRequest;\\n  }\\n\\n  function STRATEGY_TYPEHASH() external view returns (bytes32);\\n\\n  function validateCommitment(\\n    IAstariaRouter.Commitment calldata commitment\\n  ) external returns (ILienToken.Lien memory lien);\\n\\n  function getStrategyValidator(\\n    Commitment calldata\\n  ) external view returns (address);\\n\\n  function newPublicVault(\\n    uint256 epochLength,\\n    address delegate,\\n    address underlying,\\n    uint256 vaultFee,\\n    bool allowListEnabled,\\n    address[] calldata allowList,\\n    uint256 depositCap\\n  ) external returns (address);\\n\\n  function newVault(\\n    address delegate,\\n    address underlying\\n  ) external returns (address);\\n\\n  function feeTo() external view returns (address);\\n\\n  function WETH() external view returns (address);\\n\\n  function commitToLien(\\n    Commitment memory commitments\\n  ) external returns (uint256, ILienToken.Stack memory);\\n\\n  function LIEN_TOKEN() external view returns (ILienToken);\\n\\n  function TRANSFER_PROXY() external view returns (ITransferProxy);\\n\\n  function BEACON_PROXY_IMPLEMENTATION() external view returns (address);\\n\\n  function COLLATERAL_TOKEN() external view returns (ICollateralToken);\\n\\n  function getAuctionWindow() external view returns (uint256);\\n\\n  function getProtocolFee(uint256) external view returns (uint256);\\n\\n  function getLiquidatorFee(uint256) external view returns (uint256);\\n\\n  function liquidate(\\n    ILienToken.Stack calldata stack\\n  ) external returns (OrderParameters memory);\\n\\n  function canLiquidate(ILienToken.Stack calldata) external view returns (bool);\\n\\n  function isValidVault(address vault) external view returns (bool);\\n\\n  function fileBatch(File[] calldata files) external;\\n\\n  function file(File calldata incoming) external;\\n\\n  function setNewGuardian(address _guardian) external;\\n\\n  function fileGuardian(File[] calldata file) external;\\n\\n  function getImpl(uint8 implType) external view returns (address impl);\\n\\n  event Liquidation(uint256 lienId, address liquidator);\\n  event NewVault(\\n    address strategist,\\n    address delegate,\\n    address vault,\\n    uint8 vaultType\\n  );\\n\\n  error InvalidFileData();\\n  error InvalidEpochLength(uint256);\\n  error InvalidRefinanceRate(uint256);\\n  error InvalidRefinanceDuration(uint256);\\n  error InvalidVaultFee();\\n  error InvalidVaultState(VaultState);\\n  error InvalidSenderForCollateral(address, uint256);\\n  error InvalidLienState(LienState);\\n  error InvalidCollateralState(CollateralStates);\\n  error InvalidCommitmentState(CommitmentState);\\n  error InvalidStrategy(uint16);\\n  error InvalidVault(address);\\n  error InvalidUnderlying(address);\\n  error InvalidSender();\\n  error StrategyExpired();\\n  error UnsupportedFile();\\n\\n  enum LienState {\\n    HEALTHY,\\n    AUCTION\\n  }\\n\\n  enum CollateralStates {\\n    AUCTION,\\n    NO_DEPOSIT,\\n    NO_LIENS\\n  }\\n\\n  enum CommitmentState {\\n    INVALID,\\n    INVALID_RATE,\\n    INVALID_AMOUNT,\\n    COLLATERAL_NO_DEPOSIT\\n  }\\n\\n  enum VaultState {\\n    UNINITIALIZED,\\n    SHUTDOWN,\\n    CORRUPTED\\n  }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILienToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\n/**\\n *  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557\\n * \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\\n * \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\\n * \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\\n * \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\\n * \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\\n *\\n * Astaria Labs, Inc\\n */\\n\\npragma solidity =0.8.17;\\n\\nimport {IERC721} from \\\"core/interfaces/IERC721.sol\\\";\\n\\nimport {IAstariaRouter} from \\\"core/interfaces/IAstariaRouter.sol\\\";\\nimport {ICollateralToken} from \\\"core/interfaces/ICollateralToken.sol\\\";\\nimport {ITransferProxy} from \\\"core/interfaces/ITransferProxy.sol\\\";\\n\\ninterface ILienToken is IERC721 {\\n  enum FileType {\\n    NotSupported,\\n    CollateralToken,\\n    AstariaRouter,\\n    BuyoutFee,\\n    BuyoutFeeDurationCap,\\n    MinInterestBPS,\\n    MinDurationIncrease,\\n    MinLoanDuration\\n  }\\n\\n  struct File {\\n    FileType what;\\n    bytes data;\\n  }\\n\\n  event FileUpdated(FileType what, bytes data);\\n\\n  struct LienStorage {\\n    IAstariaRouter ASTARIA_ROUTER;\\n    ICollateralToken COLLATERAL_TOKEN;\\n    mapping(uint256 => bytes32) collateralStateHash;\\n    mapping(uint256 => AuctionData) collateralLiquidator;\\n  }\\n  struct AuctionData {\\n    uint256 amountOwed;\\n    address liquidator;\\n  }\\n\\n  struct Details {\\n    uint256 maxAmount;\\n    uint256 rate; //rate per second\\n    uint256 duration;\\n    uint256 maxPotentialDebt;\\n    uint256 liquidationInitialAsk;\\n  }\\n\\n  struct Lien {\\n    uint8 collateralType;\\n    address token; //20\\n    address payable vault; //20\\n    uint256 collateralId; //32 //contractAddress + tokenId\\n    Details details; //32 * 5\\n  }\\n\\n  struct Point {\\n    uint256 amount; //11\\n    uint40 last; //5\\n    uint40 end; //5\\n  }\\n\\n  struct Stack {\\n    Lien lien;\\n    Point point;\\n  }\\n\\n  struct LienActionEncumber {\\n    uint256 amount;\\n    address receiver;\\n    ILienToken.Lien lien;\\n    address feeTo;\\n    uint256 fee;\\n  }\\n\\n  function calculateSlope(\\n    Stack calldata stack\\n  ) external pure returns (uint256 slope);\\n\\n  function handleLiquidation(\\n    uint256 auctionWindow,\\n    Stack calldata stack,\\n    address liquidator\\n  ) external;\\n\\n  function getOwed(Stack calldata stack) external view returns (uint256);\\n\\n  function getOwed(\\n    Stack calldata stack,\\n    uint256 timestamp\\n  ) external view returns (uint256);\\n\\n  function getInterest(Stack calldata stack) external returns (uint256);\\n\\n  function getCollateralState(\\n    uint256 collateralId\\n  ) external view returns (bytes32);\\n\\n  function createLien(\\n    LienActionEncumber calldata params\\n  ) external returns (uint256 lienId, Stack memory stack, uint256 owingAtEnd);\\n\\n  function makePayment(Stack memory stack) external;\\n\\n  function getAuctionLiquidator(\\n    uint256 collateralId\\n  ) external view returns (address liquidator);\\n\\n  function getAuctionData(\\n    uint256 collateralId\\n  ) external view returns (AuctionData memory);\\n\\n  function file(File calldata file) external;\\n\\n  event NewLien(uint256 indexed collateralId, Stack stack);\\n  event Payment(uint256 indexed lienId, uint256 amount);\\n\\n  error InvalidFileData();\\n  error UnsupportedFile();\\n  error InvalidTokenId(uint256 tokenId);\\n  error InvalidLoanState();\\n  error InvalidSender();\\n  enum InvalidLienStates {\\n    INVALID_LIEN_ID,\\n    INVALID_HASH,\\n    INVALID_LIQUIDATION_INITIAL_ASK,\\n    PUBLIC_VAULT_RECIPIENT,\\n    COLLATERAL_NOT_LIQUIDATED,\\n    COLLATERAL_LIQUIDATED,\\n    AMOUNT_ZERO,\\n    MIN_DURATION_NOT_MET\\n  }\\n\\n  error InvalidLienState(InvalidLienStates);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ICollateralToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\n/**\\n *  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557\\n * \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\\n * \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\\n * \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\\n * \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\\n * \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\\n *\\n * Astaria Labs, Inc\\n */\\n\\npragma solidity =0.8.17;\\n\\nimport {IERC721} from \\\"core/interfaces/IERC721.sol\\\";\\nimport {ITransferProxy} from \\\"core/interfaces/ITransferProxy.sol\\\";\\nimport {IAstariaRouter} from \\\"core/interfaces/IAstariaRouter.sol\\\";\\nimport {ILienToken} from \\\"core/interfaces/ILienToken.sol\\\";\\nimport {\\n  ConsiderationInterface\\n} from \\\"seaport-types/src/interfaces/ConsiderationInterface.sol\\\";\\nimport {\\n  ConduitControllerInterface\\n} from \\\"seaport-types/src/interfaces/ConduitControllerInterface.sol\\\";\\nimport {IERC1155} from \\\"core/interfaces/IERC1155.sol\\\";\\nimport {\\n  Order,\\n  OrderParameters\\n} from \\\"seaport-types/src/lib/ConsiderationStructs.sol\\\";\\n\\ninterface ICollateralToken is IERC721 {\\n  event AuctionPurchased(address buyer, uint256 lienId, uint256 price);\\n  event LiquidatorNFTClaimed(address liquidator, uint256 lienId);\\n  event ListedOnSeaport(uint256 collateralId, Order listingOrder);\\n  event FileUpdated(FileType what, bytes data);\\n  event Deposit721(\\n    address indexed tokenContract,\\n    uint256 indexed tokenId,\\n    uint256 indexed collateralId,\\n    address depositedFor\\n  );\\n  event ReleaseTo(\\n    address indexed underlyingAsset,\\n    uint256 assetId,\\n    address indexed to\\n  );\\n\\n  struct Asset {\\n    address tokenContract;\\n    uint256 tokenId;\\n    bytes32 auctionHash;\\n  }\\n\\n  struct CollateralStorage {\\n    ILienToken LIEN_TOKEN;\\n    IAstariaRouter ASTARIA_ROUTER;\\n    ConsiderationInterface SEAPORT;\\n    ConduitControllerInterface CONDUIT_CONTROLLER;\\n    address CONDUIT;\\n    bytes32 CONDUIT_KEY;\\n    //mapping of the collateralToken ID and its underlying asset\\n    mapping(uint256 => Asset) idToUnderlying;\\n  }\\n\\n  struct ListUnderlyingForSaleParams {\\n    ILienToken.Stack stack;\\n    uint256 listPrice;\\n    uint56 maxDuration;\\n  }\\n\\n  enum FileType {\\n    NotSupported,\\n    AstariaRouter,\\n    Seaport,\\n    CloseChannel\\n  }\\n\\n  struct File {\\n    FileType what;\\n    bytes data;\\n  }\\n\\n  function fileBatch(File[] calldata files) external;\\n\\n  function file(File calldata incoming) external;\\n\\n  function getConduit() external view returns (address);\\n\\n  function getConduitKey() external view returns (bytes32);\\n\\n  struct AuctionVaultParams {\\n    address settlementToken;\\n    uint256 collateralId;\\n    uint256 maxDuration;\\n    uint256 startingPrice;\\n    uint256 endingPrice;\\n  }\\n\\n  function auctionVault(\\n    AuctionVaultParams calldata params\\n  ) external returns (OrderParameters memory);\\n\\n  function SEAPORT() external view returns (ConsiderationInterface);\\n\\n  function depositERC721(\\n    address tokenContract,\\n    uint256 tokenId,\\n    address from\\n  ) external;\\n\\n  function CONDUIT_CONTROLLER()\\n    external\\n    view\\n    returns (ConduitControllerInterface);\\n\\n  function getUnderlying(\\n    uint256 collateralId\\n  ) external view returns (address, uint256);\\n\\n  function release(uint256 collateralId) external;\\n\\n  function liquidatorNFTClaim(\\n    ILienToken.Stack memory stack,\\n    OrderParameters memory params\\n  ) external;\\n\\n  error UnsupportedFile();\\n  error InvalidCollateral();\\n  error InvalidSender();\\n  error InvalidOrder();\\n  error InvalidCollateralState(InvalidCollateralStates);\\n  error ProtocolPaused();\\n  error ListPriceTooLow();\\n  error InvalidConduitKey();\\n  error InvalidZoneHash();\\n  error InvalidTarget();\\n  error InvalidPaymentToken();\\n  error InvalidPaymentAmount();\\n\\n  enum InvalidCollateralStates {\\n    AUCTION_ACTIVE,\\n    ID_MISMATCH,\\n    INVALID_AUCTION_PARAMS,\\n    ACTIVE_LIENS,\\n    ESCROW_ACTIVE,\\n    NO_AUCTION\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/TheLocker.sol\": {\r\n      \"content\": \"pragma solidity =0.8.17;\\n\\nimport \\\"gpl/ERC721.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport {IERC721} from \\\"core/interfaces/IERC721.sol\\\";\\n\\ninterface ILocker is IERC721 {\\n  error NotOwner();\\n  error AmountMustBeGreaterThanZero();\\n\\n  struct Deposit {\\n    address token;\\n    uint256 amount;\\n  }\\n\\n  function deposit(\\n    ERC20 token,\\n    uint256 amount\\n  ) external returns (uint256 tokenId);\\n\\n  function withdraw(\\n    uint256 tokenId,\\n    address receiver\\n  ) external returns (address, uint256);\\n\\n  function getDeposit(uint256 tokenId) external view returns (Deposit memory);\\n}\\n\\ncontract TheLocker is ERC721, ILocker {\\n  using SafeTransferLib for ERC20;\\n  uint256 internal _counter;\\n\\n  constructor() {\\n    _disableInitializers();\\n  }\\n\\n  function initialize() public initializer {\\n    __initERC721(\\\"TheLocker\\\", \\\"LOCK\\\");\\n    _counter = 1;\\n  }\\n\\n  mapping(uint256 => Deposit) public deposits;\\n\\n  function deposit(\\n    ERC20 token,\\n    uint256 amount\\n  ) external returns (uint256 tokenId) {\\n    if (amount == 0) {\\n      revert AmountMustBeGreaterThanZero();\\n    }\\n    token.safeTransferFrom(msg.sender, address(this), amount);\\n    tokenId = _counter;\\n    deposits[tokenId] = Deposit(address(token), amount);\\n    _safeMint(msg.sender, _counter);\\n    ++_counter;\\n  }\\n\\n  function withdraw(\\n    uint256 tokenId,\\n    address receiver\\n  ) external returns (address, uint256) {\\n    if (msg.sender != ownerOf(tokenId)) {\\n      revert NotOwner();\\n    }\\n    Deposit memory deposit = deposits[tokenId];\\n    delete deposits[tokenId];\\n    _burn(tokenId);\\n    ERC20(deposit.token).safeTransfer(receiver, deposit.amount);\\n    return (deposit.token, deposit.amount);\\n  }\\n\\n  function getDeposit(\\n    uint256 tokenId\\n  ) external view override returns (Deposit memory) {\\n    return deposits[tokenId];\\n  }\\n\\n  function tokenURI(\\n    uint256 id\\n  ) public view override(ERC721, IERC721) returns (string memory) {\\n    Deposit memory deposit = deposits[id];\\n    //return a base64 encoded json string of the deposit data\\n\\n    return\\n      string(\\n        abi.encodePacked(\\n          \\\"data:application/json,\\\",\\n          \\\"{\\\",\\n          \\\"'asset': \\\",\\n          deposit.token,\\n          \\\",\\\",\\n          \\\"'amount': \\\",\\n          deposit.amount,\\n          \\\"}\\\"\\n        )\\n      );\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/test/utils/ERC721Recipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.17;\\n\\nimport {ERC721TokenReceiver} from \\\"solmate/tokens/ERC721.sol\\\";\\n\\ncontract ERC721Recipient is ERC721TokenReceiver {\\n  function onERC721Received(\\n    address,\\n    address,\\n    uint256,\\n    bytes calldata\\n  ) public virtual override returns (bytes4) {\\n    return ERC721TokenReceiver.onERC721Received.selector;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC721.sol\": {\r\n      \"content\": \"pragma solidity =0.8.17;\\n\\nimport {IERC165} from \\\"core/interfaces/IERC165.sol\\\";\\n\\ninterface IERC721 is IERC165 {\\n  event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 indexed id\\n  );\\n\\n  event ApprovalForAll(\\n    address indexed owner,\\n    address indexed operator,\\n    bool approved\\n  );\\n\\n  function tokenURI(uint256 id) external view returns (string memory);\\n\\n  function ownerOf(uint256 id) external view returns (address owner);\\n\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  function approve(address spender, uint256 id) external;\\n\\n  function setApprovalForAll(address operator, bool approved) external;\\n\\n  function transferFrom(address from, address to, uint256 id) external;\\n\\n  function safeTransferFrom(address from, address to, uint256 id) external;\\n\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 id,\\n    bytes calldata data\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ITransferProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\n/**\\n *  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557\\n * \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\\n * \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\\n * \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\\n * \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\\n * \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\\n *\\n * Astaria Labs, Inc\\n */\\n\\npragma solidity =0.8.17;\\n\\ninterface ITransferProxy {\\n  function tokenTransferFrom(\\n    address token,\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) external;\\n\\n  function tokenTransferFromWithErrorReceiver(\\n    address token,\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC4626.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (interfaces/IERC4626.sol)\\n\\npragma solidity =0.8.17;\\nimport {IERC20} from \\\"core/interfaces/IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"core/interfaces/IERC20Metadata.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC4626 \\\"Tokenized Vault Standard\\\", as defined in\\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\\n *\\n * _Available since v4.7._\\n */\\ninterface IERC4626 is IERC20, IERC20Metadata {\\n  event Deposit(\\n    address indexed sender,\\n    address indexed owner,\\n    uint256 assets,\\n    uint256 shares\\n  );\\n\\n  event Withdraw(\\n    address indexed sender,\\n    address indexed receiver,\\n    address indexed owner,\\n    uint256 assets,\\n    uint256 shares\\n  );\\n\\n  /**\\n   * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\\n   *\\n   * - MUST be an ERC-20 token contract.\\n   * - MUST NOT revert.\\n   */\\n  function asset() external view returns (address assetTokenAddress);\\n\\n  /**\\n   * @dev Returns the total amount of the underlying asset that is \u201cmanaged\u201d by Vault.\\n   *\\n   * - SHOULD include any compounding that occurs from yield.\\n   * - MUST be inclusive of any fees that are charged against assets in the Vault.\\n   * - MUST NOT revert.\\n   */\\n  function totalAssets() external view returns (uint256 totalManagedAssets);\\n\\n  /**\\n   * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\\n   * scenario where all the conditions are met.\\n   *\\n   * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n   * - MUST NOT show any variations depending on the caller.\\n   * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n   * - MUST NOT revert.\\n   *\\n   * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\\n   * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n   * from.\\n   */\\n  function convertToShares(\\n    uint256 assets\\n  ) external view returns (uint256 shares);\\n\\n  /**\\n   * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\\n   * scenario where all the conditions are met.\\n   *\\n   * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n   * - MUST NOT show any variations depending on the caller.\\n   * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n   * - MUST NOT revert.\\n   *\\n   * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\\n   * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n   * from.\\n   */\\n  function convertToAssets(\\n    uint256 shares\\n  ) external view returns (uint256 assets);\\n\\n  /**\\n   * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\\n   * through a deposit call.\\n   *\\n   * - MUST return a limited value if receiver is subject to some deposit limit.\\n   * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\\n   * - MUST NOT revert.\\n   */\\n  function maxDeposit(\\n    address receiver\\n  ) external view returns (uint256 maxAssets);\\n\\n  /**\\n   * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\\n   * current on-chain conditions.\\n   *\\n   * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\\n   *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\\n   *   in the same transaction.\\n   * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\\n   *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\\n   * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n   * - MUST NOT revert.\\n   *\\n   * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\\n   * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n   */\\n  function previewDeposit(\\n    uint256 assets\\n  ) external view returns (uint256 shares);\\n\\n  /**\\n   * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\\n   *\\n   * - MUST emit the Deposit event.\\n   * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n   *   deposit execution, and are accounted for during deposit.\\n   * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\\n   *   approving enough underlying tokens to the Vault contract, etc).\\n   *\\n   * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n   */\\n  function deposit(\\n    uint256 assets,\\n    address receiver\\n  ) external returns (uint256 shares);\\n\\n  /**\\n   * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\\n   * - MUST return a limited value if receiver is subject to some mint limit.\\n   * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\\n   * - MUST NOT revert.\\n   */\\n  function maxMint(address receiver) external view returns (uint256 maxShares);\\n\\n  /**\\n   * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\\n   * current on-chain conditions.\\n   *\\n   * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\\n   *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\\n   *   same transaction.\\n   * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\\n   *   would be accepted, regardless if the user has enough tokens approved, etc.\\n   * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n   * - MUST NOT revert.\\n   *\\n   * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\\n   * share price or some other type of condition, meaning the depositor will lose assets by minting.\\n   */\\n  function previewMint(uint256 shares) external view returns (uint256 assets);\\n\\n  /**\\n   * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\\n   *\\n   * - MUST emit the Deposit event.\\n   * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\\n   *   execution, and are accounted for during mint.\\n   * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\\n   *   approving enough underlying tokens to the Vault contract, etc).\\n   *\\n   * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n   */\\n  function mint(\\n    uint256 shares,\\n    address receiver\\n  ) external returns (uint256 assets);\\n\\n  /**\\n   * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\\n   * Vault, through a withdraw call.\\n   *\\n   * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n   * - MUST NOT revert.\\n   */\\n  function maxWithdraw(address owner) external view returns (uint256 maxAssets);\\n\\n  /**\\n   * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\\n   * given current on-chain conditions.\\n   *\\n   * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\\n   *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\\n   *   called\\n   *   in the same transaction.\\n   * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\\n   *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\\n   * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n   * - MUST NOT revert.\\n   *\\n   * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\\n   * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n   */\\n  function previewWithdraw(\\n    uint256 assets\\n  ) external view returns (uint256 shares);\\n\\n  /**\\n   * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\\n   *\\n   * - MUST emit the Withdraw event.\\n   * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n   *   withdraw execution, and are accounted for during withdraw.\\n   * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\\n   *   not having enough shares, etc).\\n   *\\n   * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n   * Those methods should be performed separately.\\n   */\\n  function withdraw(\\n    uint256 assets,\\n    address receiver,\\n    address owner\\n  ) external returns (uint256 shares);\\n\\n  /**\\n   * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\\n   * through a redeem call.\\n   *\\n   * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n   * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\\n   * - MUST NOT revert.\\n   */\\n  function maxRedeem(address owner) external view returns (uint256 maxShares);\\n\\n  /**\\n   * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\\n   * given current on-chain conditions.\\n   *\\n   * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\\n   *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\\n   *   same transaction.\\n   * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\\n   *   redemption would be accepted, regardless if the user has enough shares, etc.\\n   * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n   * - MUST NOT revert.\\n   *\\n   * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\\n   * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\\n   */\\n  function previewRedeem(uint256 shares) external view returns (uint256 assets);\\n\\n  /**\\n   * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\\n   *\\n   * - MUST emit the Withdraw event.\\n   * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n   *   redeem execution, and are accounted for during redeem.\\n   * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\\n   *   not having enough shares, etc).\\n   *\\n   * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n   * Those methods should be performed separately.\\n   */\\n  function redeem(\\n    uint256 shares,\\n    address receiver,\\n    address owner\\n  ) external returns (uint256 assets);\\n}\\n\"\r\n    },\r\n    \"src/utils/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity =0.8.17;\\n\\ninterface IPausable {\\n  function paused() external view returns (bool);\\n}\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is IPausable {\\n  uint256 private constant PAUSE_SLOT =\\n    uint256(keccak256(\\\"xyz.astaria.AstariaRouter.Pausable.storage.location\\\")) -\\n      1;\\n  /**\\n   * @dev Emitted when the pause is triggered by `account`.\\n   */\\n  event Paused(address account);\\n\\n  /**\\n   * @dev Emitted when the pause is lifted by `account`.\\n   */\\n  event Unpaused(address account);\\n\\n  struct PauseStorage {\\n    bool _paused;\\n  }\\n\\n  function _loadPauseSlot() internal pure returns (PauseStorage storage s) {\\n    uint256 slot = PAUSE_SLOT;\\n\\n    assembly {\\n      s.slot := slot\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns true if the contract is paused, and false otherwise.\\n   */\\n  function paused() public view virtual returns (bool) {\\n    return _loadPauseSlot()._paused;\\n  }\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is not paused.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must not be paused.\\n   */\\n  modifier whenNotPaused() {\\n    require(!paused(), \\\"Pausable: paused\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is paused.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must be paused.\\n   */\\n  modifier whenPaused() {\\n    require(paused(), \\\"Pausable: not paused\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Triggers stopped state.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must not be paused.\\n   */\\n  function _pause() internal virtual whenNotPaused {\\n    _loadPauseSlot()._paused = true;\\n    emit Paused(msg.sender);\\n  }\\n\\n  /**\\n   * @dev Returns to normal state.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must be paused.\\n   */\\n  function _unpause() internal virtual whenPaused {\\n    _loadPauseSlot()._paused = false;\\n    emit Unpaused(msg.sender);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\n/**\\n *  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557\\n * \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\\n * \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\\n * \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\\n * \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\\n * \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\\n *\\n * Astaria Labs, Inc\\n */\\n\\npragma solidity =0.8.17;\\n\\ninterface IBeacon {\\n  /**\\n   * @dev Must return an address that can be used as a delegate call target.\\n   *\\n   * {BeaconProxy} will check that this address is a contract.\\n   */\\n  function getImpl(uint8) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/seaport-types/src/lib/ConsiderationStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {\\n    BasicOrderType,\\n    ItemType,\\n    OrderType,\\n    Side\\n} from \\\"./ConsiderationEnums.sol\\\";\\n\\nimport {\\n    CalldataPointer,\\n    MemoryPointer\\n} from \\\"../helpers/PointerLibraries.sol\\\";\\n\\n/**\\n * @dev An order contains eleven components: an offerer, a zone (or account that\\n *      can cancel the order or restrict who can fulfill the order depending on\\n *      the type), the order type (specifying partial fill support as well as\\n *      restricted order status), the start and end time, a hash that will be\\n *      provided to the zone when validating restricted orders, a salt, a key\\n *      corresponding to a given conduit, a counter, and an arbitrary number of\\n *      offer items that can be spent along with consideration items that must\\n *      be received by their respective recipient.\\n */\\nstruct OrderComponents {\\n    address offerer;\\n    address zone;\\n    OfferItem[] offer;\\n    ConsiderationItem[] consideration;\\n    OrderType orderType;\\n    uint256 startTime;\\n    uint256 endTime;\\n    bytes32 zoneHash;\\n    uint256 salt;\\n    bytes32 conduitKey;\\n    uint256 counter;\\n}\\n\\n/**\\n * @dev An offer item has five components: an item type (ETH or other native\\n *      tokens, ERC20, ERC721, and ERC1155, as well as criteria-based ERC721 and\\n *      ERC1155), a token address, a dual-purpose \\\"identifierOrCriteria\\\"\\n *      component that will either represent a tokenId or a merkle root\\n *      depending on the item type, and a start and end amount that support\\n *      increasing or decreasing amounts over the duration of the respective\\n *      order.\\n */\\nstruct OfferItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifierOrCriteria;\\n    uint256 startAmount;\\n    uint256 endAmount;\\n}\\n\\n/**\\n * @dev A consideration item has the same five components as an offer item and\\n *      an additional sixth component designating the required recipient of the\\n *      item.\\n */\\nstruct ConsiderationItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifierOrCriteria;\\n    uint256 startAmount;\\n    uint256 endAmount;\\n    address payable recipient;\\n}\\n\\n/**\\n * @dev A spent item is translated from a utilized offer item and has four\\n *      components: an item type (ETH or other native tokens, ERC20, ERC721, and\\n *      ERC1155), a token address, a tokenId, and an amount.\\n */\\nstruct SpentItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifier;\\n    uint256 amount;\\n}\\n\\n/**\\n * @dev A received item is translated from a utilized consideration item and has\\n *      the same four components as a spent item, as well as an additional fifth\\n *      component designating the required recipient of the item.\\n */\\nstruct ReceivedItem {\\n    ItemType itemType;\\n    address token;\\n    uint256 identifier;\\n    uint256 amount;\\n    address payable recipient;\\n}\\n\\n/**\\n * @dev For basic orders involving ETH / native / ERC20 <=> ERC721 / ERC1155\\n *      matching, a group of six functions may be called that only requires a\\n *      subset of the usual order arguments. Note the use of a \\\"basicOrderType\\\"\\n *      enum; this represents both the usual order type as well as the \\\"route\\\"\\n *      of the basic order (a simple derivation function for the basic order\\n *      type is `basicOrderType = orderType + (4 * basicOrderRoute)`.)\\n */\\nstruct BasicOrderParameters {\\n    // calldata offset\\n    address considerationToken; // 0x24\\n    uint256 considerationIdentifier; // 0x44\\n    uint256 considerationAmount; // 0x64\\n    address payable offerer; // 0x84\\n    address zone; // 0xa4\\n    address offerToken; // 0xc4\\n    uint256 offerIdentifier; // 0xe4\\n    uint256 offerAmount; // 0x104\\n    BasicOrderType basicOrderType; // 0x124\\n    uint256 startTime; // 0x144\\n    uint256 endTime; // 0x164\\n    bytes32 zoneHash; // 0x184\\n    uint256 salt; // 0x1a4\\n    bytes32 offererConduitKey; // 0x1c4\\n    bytes32 fulfillerConduitKey; // 0x1e4\\n    uint256 totalOriginalAdditionalRecipients; // 0x204\\n    AdditionalRecipient[] additionalRecipients; // 0x224\\n    bytes signature; // 0x244\\n    // Total length, excluding dynamic array data: 0x264 (580)\\n}\\n\\n/**\\n * @dev Basic orders can supply any number of additional recipients, with the\\n *      implied assumption that they are supplied from the offered ETH (or other\\n *      native token) or ERC20 token for the order.\\n */\\nstruct AdditionalRecipient {\\n    uint256 amount;\\n    address payable recipient;\\n}\\n\\n/**\\n * @dev The full set of order components, with the exception of the counter,\\n *      must be supplied when fulfilling more sophisticated orders or groups of\\n *      orders. The total number of original consideration items must also be\\n *      supplied, as the caller may specify additional consideration items.\\n */\\nstruct OrderParameters {\\n    address offerer; // 0x00\\n    address zone; // 0x20\\n    OfferItem[] offer; // 0x40\\n    ConsiderationItem[] consideration; // 0x60\\n    OrderType orderType; // 0x80\\n    uint256 startTime; // 0xa0\\n    uint256 endTime; // 0xc0\\n    bytes32 zoneHash; // 0xe0\\n    uint256 salt; // 0x100\\n    bytes32 conduitKey; // 0x120\\n    uint256 totalOriginalConsiderationItems; // 0x140\\n    // offer.length                          // 0x160\\n}\\n\\n/**\\n * @dev Orders require a signature in addition to the other order parameters.\\n */\\nstruct Order {\\n    OrderParameters parameters;\\n    bytes signature;\\n}\\n\\n/**\\n * @dev Advanced orders include a numerator (i.e. a fraction to attempt to fill)\\n *      and a denominator (the total size of the order) in addition to the\\n *      signature and other order parameters. It also supports an optional field\\n *      for supplying extra data; this data will be provided to the zone if the\\n *      order type is restricted and the zone is not the caller, or will be\\n *      provided to the offerer as context for contract order types.\\n */\\nstruct AdvancedOrder {\\n    OrderParameters parameters;\\n    uint120 numerator;\\n    uint120 denominator;\\n    bytes signature;\\n    bytes extraData;\\n}\\n\\n/**\\n * @dev Orders can be validated (either explicitly via `validate`, or as a\\n *      consequence of a full or partial fill), specifically cancelled (they can\\n *      also be cancelled in bulk via incrementing a per-zone counter), and\\n *      partially or fully filled (with the fraction filled represented by a\\n *      numerator and denominator).\\n */\\nstruct OrderStatus {\\n    bool isValidated;\\n    bool isCancelled;\\n    uint120 numerator;\\n    uint120 denominator;\\n}\\n\\n/**\\n * @dev A criteria resolver specifies an order, side (offer vs. consideration),\\n *      and item index. It then provides a chosen identifier (i.e. tokenId)\\n *      alongside a merkle proof demonstrating the identifier meets the required\\n *      criteria.\\n */\\nstruct CriteriaResolver {\\n    uint256 orderIndex;\\n    Side side;\\n    uint256 index;\\n    uint256 identifier;\\n    bytes32[] criteriaProof;\\n}\\n\\n/**\\n * @dev A fulfillment is applied to a group of orders. It decrements a series of\\n *      offer and consideration items, then generates a single execution\\n *      element. A given fulfillment can be applied to as many offer and\\n *      consideration items as desired, but must contain at least one offer and\\n *      at least one consideration that match. The fulfillment must also remain\\n *      consistent on all key parameters across all offer items (same offerer,\\n *      token, type, tokenId, and conduit preference) as well as across all\\n *      consideration items (token, type, tokenId, and recipient).\\n */\\nstruct Fulfillment {\\n    FulfillmentComponent[] offerComponents;\\n    FulfillmentComponent[] considerationComponents;\\n}\\n\\n/**\\n * @dev Each fulfillment component contains one index referencing a specific\\n *      order and another referencing a specific offer or consideration item.\\n */\\nstruct FulfillmentComponent {\\n    uint256 orderIndex;\\n    uint256 itemIndex;\\n}\\n\\n/**\\n * @dev An execution is triggered once all consideration items have been zeroed\\n *      out. It sends the item in question from the offerer to the item's\\n *      recipient, optionally sourcing approvals from either this contract\\n *      directly or from the offerer's chosen conduit if one is specified. An\\n *      execution is not provided as an argument, but rather is derived via\\n *      orders, criteria resolvers, and fulfillments (where the total number of\\n *      executions will be less than or equal to the total number of indicated\\n *      fulfillments) and returned as part of `matchOrders`.\\n */\\nstruct Execution {\\n    ReceivedItem item;\\n    address offerer;\\n    bytes32 conduitKey;\\n}\\n\\n/**\\n * @dev Restricted orders are validated post-execution by calling validateOrder\\n *      on the zone. This struct provides context about the order fulfillment\\n *      and any supplied extraData, as well as all order hashes fulfilled in a\\n *      call to a match or fulfillAvailable method.\\n */\\nstruct ZoneParameters {\\n    bytes32 orderHash;\\n    address fulfiller;\\n    address offerer;\\n    SpentItem[] offer;\\n    ReceivedItem[] consideration;\\n    bytes extraData;\\n    bytes32[] orderHashes;\\n    uint256 startTime;\\n    uint256 endTime;\\n    bytes32 zoneHash;\\n}\\n\\n/**\\n * @dev Zones and contract offerers can communicate which schemas they implement\\n *      along with any associated metadata related to each schema.\\n */\\nstruct Schema {\\n    uint256 id;\\n    bytes metadata;\\n}\\n\\nusing StructPointers for OrderComponents global;\\nusing StructPointers for OfferItem global;\\nusing StructPointers for ConsiderationItem global;\\nusing StructPointers for SpentItem global;\\nusing StructPointers for ReceivedItem global;\\nusing StructPointers for BasicOrderParameters global;\\nusing StructPointers for AdditionalRecipient global;\\nusing StructPointers for OrderParameters global;\\nusing StructPointers for Order global;\\nusing StructPointers for AdvancedOrder global;\\nusing StructPointers for OrderStatus global;\\nusing StructPointers for CriteriaResolver global;\\nusing StructPointers for Fulfillment global;\\nusing StructPointers for FulfillmentComponent global;\\nusing StructPointers for Execution global;\\nusing StructPointers for ZoneParameters global;\\n\\n/**\\n * @dev This library provides a set of functions for converting structs to\\n *      pointers.\\n */\\nlibrary StructPointers {\\n    /**\\n     * @dev Get a MemoryPointer from OrderComponents.\\n     *\\n     * @param obj The OrderComponents object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        OrderComponents memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from OrderComponents.\\n     *\\n     * @param obj The OrderComponents object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        OrderComponents calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from OfferItem.\\n     *\\n     * @param obj The OfferItem object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        OfferItem memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from OfferItem.\\n     *\\n     * @param obj The OfferItem object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        OfferItem calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from ConsiderationItem.\\n     *\\n     * @param obj The ConsiderationItem object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        ConsiderationItem memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from ConsiderationItem.\\n     *\\n     * @param obj The ConsiderationItem object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        ConsiderationItem calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from SpentItem.\\n     *\\n     * @param obj The SpentItem object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        SpentItem memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from SpentItem.\\n     *\\n     * @param obj The SpentItem object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        SpentItem calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from ReceivedItem.\\n     *\\n     * @param obj The ReceivedItem object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        ReceivedItem memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from ReceivedItem.\\n     *\\n     * @param obj The ReceivedItem object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        ReceivedItem calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from BasicOrderParameters.\\n     *\\n     * @param obj The BasicOrderParameters object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        BasicOrderParameters memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from BasicOrderParameters.\\n     *\\n     * @param obj The BasicOrderParameters object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        BasicOrderParameters calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from AdditionalRecipient.\\n     *\\n     * @param obj The AdditionalRecipient object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        AdditionalRecipient memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from AdditionalRecipient.\\n     *\\n     * @param obj The AdditionalRecipient object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        AdditionalRecipient calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from OrderParameters.\\n     *\\n     * @param obj The OrderParameters object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        OrderParameters memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from OrderParameters.\\n     *\\n     * @param obj The OrderParameters object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        OrderParameters calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from Order.\\n     *\\n     * @param obj The Order object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        Order memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from Order.\\n     *\\n     * @param obj The Order object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        Order calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from AdvancedOrder.\\n     *\\n     * @param obj The AdvancedOrder object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        AdvancedOrder memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from AdvancedOrder.\\n     *\\n     * @param obj The AdvancedOrder object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        AdvancedOrder calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from OrderStatus.\\n     *\\n     * @param obj The OrderStatus object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        OrderStatus memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from OrderStatus.\\n     *\\n     * @param obj The OrderStatus object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        OrderStatus calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from CriteriaResolver.\\n     *\\n     * @param obj The CriteriaResolver object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        CriteriaResolver memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from CriteriaResolver.\\n     *\\n     * @param obj The CriteriaResolver object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        CriteriaResolver calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from Fulfillment.\\n     *\\n     * @param obj The Fulfillment object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        Fulfillment memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from Fulfillment.\\n     *\\n     * @param obj The Fulfillment object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        Fulfillment calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from FulfillmentComponent.\\n     *\\n     * @param obj The FulfillmentComponent object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        FulfillmentComponent memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from FulfillmentComponent.\\n     *\\n     * @param obj The FulfillmentComponent object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        FulfillmentComponent calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from Execution.\\n     *\\n     * @param obj The Execution object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        Execution memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from Execution.\\n     *\\n     * @param obj The Execution object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        Execution calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a MemoryPointer from ZoneParameters.\\n     *\\n     * @param obj The ZoneParameters object.\\n     *\\n     * @return ptr The MemoryPointer.\\n     */\\n    function toMemoryPointer(\\n        ZoneParameters memory obj\\n    ) internal pure returns (MemoryPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n\\n    /**\\n     * @dev Get a CalldataPointer from ZoneParameters.\\n     *\\n     * @param obj The ZoneParameters object.\\n     *\\n     * @return ptr The CalldataPointer.\\n     */\\n    function toCalldataPointer(\\n        ZoneParameters calldata obj\\n    ) internal pure returns (CalldataPointer ptr) {\\n        assembly {\\n            ptr := obj\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/seaport-types/src/interfaces/ConsiderationInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport {\\n    AdvancedOrder,\\n    BasicOrderParameters,\\n    CriteriaResolver,\\n    Execution,\\n    Fulfillment,\\n    FulfillmentComponent,\\n    Order,\\n    OrderComponents\\n} from \\\"../lib/ConsiderationStructs.sol\\\";\\n\\n/**\\n * @title ConsiderationInterface\\n * @author 0age\\n * @custom:version 1.5\\n * @notice Consideration is a generalized native token/ERC20/ERC721/ERC1155\\n *         marketplace. It minimizes external calls to the greatest extent\\n *         possible and provides lightweight methods for common routes as well\\n *         as more flexible methods for composing advanced orders.\\n *\\n * @dev ConsiderationInterface contains all external function interfaces for\\n *      Consideration.\\n */\\ninterface ConsiderationInterface {\\n    /**\\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\\n     *         the native token for the given chain) as consideration for the\\n     *         order. An arbitrary number of \\\"additional recipients\\\" may also be\\n     *         supplied which will each receive native tokens from the fulfiller\\n     *         as consideration.\\n     *\\n     * @param parameters Additional information on the fulfilled order. Note\\n     *                   that the offerer must first approve this contract (or\\n     *                   their preferred conduit if indicated by the order) for\\n     *                   their offered ERC721 token to be transferred.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillBasicOrder(\\n        BasicOrderParameters calldata parameters\\n    ) external payable returns (bool fulfilled);\\n\\n    /**\\n     * @notice Fulfill an order with an arbitrary number of items for offer and\\n     *         consideration. Note that this function does not support\\n     *         criteria-based orders or partial filling of orders (though\\n     *         filling the remainder of a partially-filled order is supported).\\n     *\\n     * @param order               The order to fulfill. Note that both the\\n     *                            offerer and the fulfiller must first approve\\n     *                            this contract (or the corresponding conduit if\\n     *                            indicated) to transfer any relevant tokens on\\n     *                            their behalf and that contracts must implement\\n     *                            `onERC1155Received` to receive ERC1155 tokens\\n     *                            as consideration.\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\n     *                            any, to source the fulfiller's token approvals\\n     *                            from. The zero hash signifies that no conduit\\n     *                            should be used, with direct approvals set on\\n     *                            Consideration.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillOrder(\\n        Order calldata order,\\n        bytes32 fulfillerConduitKey\\n    ) external payable returns (bool fulfilled);\\n\\n    /**\\n     * @notice Fill an order, fully or partially, with an arbitrary number of\\n     *         items for offer and consideration alongside criteria resolvers\\n     *         containing specific token identifiers and associated proofs.\\n     *\\n     * @param advancedOrder       The order to fulfill along with the fraction\\n     *                            of the order to attempt to fill. Note that\\n     *                            both the offerer and the fulfiller must first\\n     *                            approve this contract (or their preferred\\n     *                            conduit if indicated by the order) to transfer\\n     *                            any relevant tokens on their behalf and that\\n     *                            contracts must implement `onERC1155Received`\\n     *                            to receive ERC1155 tokens as consideration.\\n     *                            Also note that all offer and consideration\\n     *                            components must have no remainder after\\n     *                            multiplication of the respective amount with\\n     *                            the supplied fraction for the partial fill to\\n     *                            be considered valid.\\n     * @param criteriaResolvers   An array where each element contains a\\n     *                            reference to a specific offer or\\n     *                            consideration, a token identifier, and a proof\\n     *                            that the supplied token identifier is\\n     *                            contained in the merkle root held by the item\\n     *                            in question's criteria element. Note that an\\n     *                            empty criteria indicates that any\\n     *                            (transferable) token identifier on the token\\n     *                            in question is valid and that no associated\\n     *                            proof needs to be supplied.\\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\\n     *                            any, to source the fulfiller's token approvals\\n     *                            from. The zero hash signifies that no conduit\\n     *                            should be used, with direct approvals set on\\n     *                            Consideration.\\n     * @param recipient           The intended recipient for all received items,\\n     *                            with `address(0)` indicating that the caller\\n     *                            should receive the items.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillAdvancedOrder(\\n        AdvancedOrder calldata advancedOrder,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        bytes32 fulfillerConduitKey,\\n        address recipient\\n    ) external payable returns (bool fulfilled);\\n\\n    /**\\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\\n     *         of items for offer and consideration. Any order that is not\\n     *         currently active, has already been fully filled, or has been\\n     *         cancelled will be omitted. Remaining offer and consideration\\n     *         items will then be aggregated where possible as indicated by the\\n     *         supplied offer and consideration component arrays and aggregated\\n     *         items will be transferred to the fulfiller or to each intended\\n     *         recipient, respectively. Note that a failing item transfer or an\\n     *         issue with order formatting will cause the entire batch to fail.\\n     *         Note that this function does not support criteria-based orders or\\n     *         partial filling of orders (though filling the remainder of a\\n     *         partially-filled order is supported).\\n     *\\n     * @param orders                    The orders to fulfill. Note that both\\n     *                                  the offerer and the fulfiller must first\\n     *                                  approve this contract (or the\\n     *                                  corresponding conduit if indicated) to\\n     *                                  transfer any relevant tokens on their\\n     *                                  behalf and that contracts must implement\\n     *                                  `onERC1155Received` to receive ERC1155\\n     *                                  tokens as consideration.\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\n     *                                  indicating which offer items to attempt\\n     *                                  to aggregate when preparing executions.\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\n     *                                  indicating which consideration items to\\n     *                                  attempt to aggregate when preparing\\n     *                                  executions.\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\n     *                                  if any, to source the fulfiller's token\\n     *                                  approvals from. The zero hash signifies\\n     *                                  that no conduit should be used, with\\n     *                                  direct approvals set on this contract.\\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\\n     *\\n     * @return availableOrders An array of booleans indicating if each order\\n     *                         with an index corresponding to the index of the\\n     *                         returned boolean was fulfillable or not.\\n     * @return executions      An array of elements indicating the sequence of\\n     *                         transfers performed as part of matching the given\\n     *                         orders. Note that unspent offer item amounts or\\n     *                         native tokens will not be reflected as part of\\n     *                         this array.\\n     */\\n    function fulfillAvailableOrders(\\n        Order[] calldata orders,\\n        FulfillmentComponent[][] calldata offerFulfillments,\\n        FulfillmentComponent[][] calldata considerationFulfillments,\\n        bytes32 fulfillerConduitKey,\\n        uint256 maximumFulfilled\\n    )\\n        external\\n        payable\\n        returns (bool[] memory availableOrders, Execution[] memory executions);\\n\\n    /**\\n     * @notice Attempt to fill a group of orders, fully or partially, with an\\n     *         arbitrary number of items for offer and consideration per order\\n     *         alongside criteria resolvers containing specific token\\n     *         identifiers and associated proofs. Any order that is not\\n     *         currently active, has already been fully filled, or has been\\n     *         cancelled will be omitted. Remaining offer and consideration\\n     *         items will then be aggregated where possible as indicated by the\\n     *         supplied offer and consideration component arrays and aggregated\\n     *         items will be transferred to the fulfiller or to each intended\\n     *         recipient, respectively. Note that a failing item transfer or an\\n     *         issue with order formatting will cause the entire batch to fail.\\n     *\\n     * @param advancedOrders            The orders to fulfill along with the\\n     *                                  fraction of those orders to attempt to\\n     *                                  fill. Note that both the offerer and the\\n     *                                  fulfiller must first approve this\\n     *                                  contract (or their preferred conduit if\\n     *                                  indicated by the order) to transfer any\\n     *                                  relevant tokens on their behalf and that\\n     *                                  contracts must implement\\n     *                                  `onERC1155Received` to enable receipt of\\n     *                                  ERC1155 tokens as consideration. Also\\n     *                                  note that all offer and consideration\\n     *                                  components must have no remainder after\\n     *                                  multiplication of the respective amount\\n     *                                  with the supplied fraction for an\\n     *                                  order's partial fill amount to be\\n     *                                  considered valid.\\n     * @param criteriaResolvers         An array where each element contains a\\n     *                                  reference to a specific offer or\\n     *                                  consideration, a token identifier, and a\\n     *                                  proof that the supplied token identifier\\n     *                                  is contained in the merkle root held by\\n     *                                  the item in question's criteria element.\\n     *                                  Note that an empty criteria indicates\\n     *                                  that any (transferable) token\\n     *                                  identifier on the token in question is\\n     *                                  valid and that no associated proof needs\\n     *                                  to be supplied.\\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\\n     *                                  indicating which offer items to attempt\\n     *                                  to aggregate when preparing executions.\\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\\n     *                                  indicating which consideration items to\\n     *                                  attempt to aggregate when preparing\\n     *                                  executions.\\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\\n     *                                  if any, to source the fulfiller's token\\n     *                                  approvals from. The zero hash signifies\\n     *                                  that no conduit should be used, with\\n     *                                  direct approvals set on this contract.\\n     * @param recipient                 The intended recipient for all received\\n     *                                  items, with `address(0)` indicating that\\n     *                                  the caller should receive the items.\\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\\n     *\\n     * @return availableOrders An array of booleans indicating if each order\\n     *                         with an index corresponding to the index of the\\n     *                         returned boolean was fulfillable or not.\\n     * @return executions      An array of elements indicating the sequence of\\n     *                         transfers performed as part of matching the given\\n     *                         orders. Note that unspent offer item amounts or\\n     *                         native tokens will not be reflected as part of\\n     *                         this array.\\n     */\\n    function fulfillAvailableAdvancedOrders(\\n        AdvancedOrder[] calldata advancedOrders,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        FulfillmentComponent[][] calldata offerFulfillments,\\n        FulfillmentComponent[][] calldata considerationFulfillments,\\n        bytes32 fulfillerConduitKey,\\n        address recipient,\\n        uint256 maximumFulfilled\\n    )\\n        external\\n        payable\\n        returns (bool[] memory availableOrders, Execution[] memory executions);\\n\\n    /**\\n     * @notice Match an arbitrary number of orders, each with an arbitrary\\n     *         number of items for offer and consideration along with a set of\\n     *         fulfillments allocating offer components to consideration\\n     *         components. Note that this function does not support\\n     *         criteria-based or partial filling of orders (though filling the\\n     *         remainder of a partially-filled order is supported). Any unspent\\n     *         offer item amounts or native tokens will be transferred to the\\n     *         caller.\\n     *\\n     * @param orders       The orders to match. Note that both the offerer and\\n     *                     fulfiller on each order must first approve this\\n     *                     contract (or their conduit if indicated by the order)\\n     *                     to transfer any relevant tokens on their behalf and\\n     *                     each consideration recipient must implement\\n     *                     `onERC1155Received` to enable ERC1155 token receipt.\\n     * @param fulfillments An array of elements allocating offer components to\\n     *                     consideration components. Note that each\\n     *                     consideration component must be fully met for the\\n     *                     match operation to be valid.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders. Note that unspent offer item amounts or\\n     *                    native tokens will not be reflected as part of this\\n     *                    array.\\n     */\\n    function matchOrders(\\n        Order[] calldata orders,\\n        Fulfillment[] calldata fulfillments\\n    ) external payable returns (Execution[] memory executions);\\n\\n    /**\\n     * @notice Match an arbitrary number of full or partial orders, each with an\\n     *         arbitrary number of items for offer and consideration, supplying\\n     *         criteria resolvers containing specific token identifiers and\\n     *         associated proofs as well as fulfillments allocating offer\\n     *         components to consideration components. Any unspent offer item\\n     *         amounts will be transferred to the designated recipient (with the\\n     *         null address signifying to use the caller) and any unspent native\\n     *         tokens will be returned to the caller.\\n     *\\n     * @param orders            The advanced orders to match. Note that both the\\n     *                          offerer and fulfiller on each order must first\\n     *                          approve this contract (or a preferred conduit if\\n     *                          indicated by the order) to transfer any relevant\\n     *                          tokens on their behalf and each consideration\\n     *                          recipient must implement `onERC1155Received` in\\n     *                          order to receive ERC1155 tokens. Also note that\\n     *                          the offer and consideration components for each\\n     *                          order must have no remainder after multiplying\\n     *                          the respective amount with the supplied fraction\\n     *                          in order for the group of partial fills to be\\n     *                          considered valid.\\n     * @param criteriaResolvers An array where each element contains a reference\\n     *                          to a specific order as well as that order's\\n     *                          offer or consideration, a token identifier, and\\n     *                          a proof that the supplied token identifier is\\n     *                          contained in the order's merkle root. Note that\\n     *                          an empty root indicates that any (transferable)\\n     *                          token identifier is valid and that no associated\\n     *                          proof needs to be supplied.\\n     * @param fulfillments      An array of elements allocating offer components\\n     *                          to consideration components. Note that each\\n     *                          consideration component must be fully met in\\n     *                          order for the match operation to be valid.\\n     * @param recipient         The intended recipient for all unspent offer\\n     *                          item amounts, or the caller if the null address\\n     *                          is supplied.\\n     *\\n     * @return executions An array of elements indicating the sequence of\\n     *                    transfers performed as part of matching the given\\n     *                    orders. Note that unspent offer item amounts or native\\n     *                    tokens will not be reflected as part of this array.\\n     */\\n    function matchAdvancedOrders(\\n        AdvancedOrder[] calldata orders,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        Fulfillment[] calldata fulfillments,\\n        address recipient\\n    ) external payable returns (Execution[] memory executions);\\n\\n    /**\\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\\n     *         or the zone of a given order may cancel it. Callers should ensure\\n     *         that the intended order was cancelled by calling `getOrderStatus`\\n     *         and confirming that `isCancelled` returns `true`.\\n     *\\n     * @param orders The orders to cancel.\\n     *\\n     * @return cancelled A boolean indicating whether the supplied orders have\\n     *                   been successfully cancelled.\\n     */\\n    function cancel(\\n        OrderComponents[] calldata orders\\n    ) external returns (bool cancelled);\\n\\n    /**\\n     * @notice Validate an arbitrary number of orders, thereby registering their\\n     *         signatures as valid and allowing the fulfiller to skip signature\\n     *         verification on fulfillment. Note that validated orders may still\\n     *         be unfulfillable due to invalid item amounts or other factors;\\n     *         callers should determine whether validated orders are fulfillable\\n     *         by simulating the fulfillment call prior to execution. Also note\\n     *         that anyone can validate a signed order, but only the offerer can\\n     *         validate an order without supplying a signature.\\n     *\\n     * @param orders The orders to validate.\\n     *\\n     * @return validated A boolean indicating whether the supplied orders have\\n     *                   been successfully validated.\\n     */\\n    function validate(\\n        Order[] calldata orders\\n    ) external returns (bool validated);\\n\\n    /**\\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\\n     *         by incrementing a counter. Note that only the offerer may\\n     *         increment the counter.\\n     *\\n     * @return newCounter The new counter.\\n     */\\n    function incrementCounter() external returns (uint256 newCounter);\\n\\n    /**\\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\\n     *         the native token for the given chain) as consideration for the\\n     *         order. An arbitrary number of \\\"additional recipients\\\" may also be\\n     *         supplied which will each receive native tokens from the fulfiller\\n     *         as consideration. Note that this function costs less gas than\\n     *         `fulfillBasicOrder` due to the zero bytes in the function\\n     *         selector (0x00000000) which also results in earlier function\\n     *         dispatch.\\n     *\\n     * @param parameters Additional information on the fulfilled order. Note\\n     *                   that the offerer must first approve this contract (or\\n     *                   their preferred conduit if indicated by the order) for\\n     *                   their offered ERC721 token to be transferred.\\n     *\\n     * @return fulfilled A boolean indicating whether the order has been\\n     *                   successfully fulfilled.\\n     */\\n    function fulfillBasicOrder_efficient_6GL6yc(\\n        BasicOrderParameters calldata parameters\\n    ) external payable returns (bool fulfilled);\\n\\n    /**\\n     * @notice Retrieve the order hash for a given order.\\n     *\\n     * @param order The components of the order.\\n     *\\n     * @return orderHash The order hash.\\n     */\\n    function getOrderHash(\\n        OrderComponents calldata order\\n    ) external view returns (bytes32 orderHash);\\n\\n    /**\\n     * @notice Retrieve the status of a given order by hash, including whether\\n     *         the order has been cancelled or validated and the fraction of the\\n     *         order that has been filled.\\n     *\\n     * @param orderHash The order hash in question.\\n     *\\n     * @return isValidated A boolean indicating whether the order in question\\n     *                     has been validated (i.e. previously approved or\\n     *                     partially filled).\\n     * @return isCancelled A boolean indicating whether the order in question\\n     *                     has been cancelled.\\n     * @return totalFilled The total portion of the order that has been filled\\n     *                     (i.e. the \\\"numerator\\\").\\n     * @return totalSize   The total size of the order that is either filled or\\n     *                     unfilled (i.e. the \\\"denominator\\\").\\n     */\\n    function getOrderStatus(\\n        bytes32 orderHash\\n    )\\n        external\\n        view\\n        returns (\\n            bool isValidated,\\n            bool isCancelled,\\n            uint256 totalFilled,\\n            uint256 totalSize\\n        );\\n\\n    /**\\n     * @notice Retrieve the current counter for a given offerer.\\n     *\\n     * @param offerer The offerer in question.\\n     *\\n     * @return counter The current counter.\\n     */\\n    function getCounter(\\n        address offerer\\n    ) external view returns (uint256 counter);\\n\\n    /**\\n     * @notice Retrieve configuration information for this contract.\\n     *\\n     * @return version           The contract version.\\n     * @return domainSeparator   The domain separator for this contract.\\n     * @return conduitController The conduit Controller set for this contract.\\n     */\\n    function information()\\n        external\\n        view\\n        returns (\\n            string memory version,\\n            bytes32 domainSeparator,\\n            address conduitController\\n        );\\n\\n    function getContractOffererNonce(\\n        address contractOfferer\\n    ) external view returns (uint256 nonce);\\n\\n    /**\\n     * @notice Retrieve the name of this contract.\\n     *\\n     * @return contractName The name of this contract.\\n     */\\n    function name() external view returns (string memory contractName);\\n}\\n\"\r\n    },\r\n    \"lib/seaport-types/src/interfaces/ConduitControllerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title ConduitControllerInterface\\n * @author 0age\\n * @notice ConduitControllerInterface contains all external function interfaces,\\n *         structs, events, and errors for the conduit controller.\\n */\\ninterface ConduitControllerInterface {\\n    /**\\n     * @dev Track the conduit key, current owner, new potential owner, and open\\n     *      channels for each deployed conduit.\\n     */\\n    struct ConduitProperties {\\n        bytes32 key;\\n        address owner;\\n        address potentialOwner;\\n        address[] channels;\\n        mapping(address => uint256) channelIndexesPlusOne;\\n    }\\n\\n    /**\\n     * @dev Emit an event whenever a new conduit is created.\\n     *\\n     * @param conduit    The newly created conduit.\\n     * @param conduitKey The conduit key used to create the new conduit.\\n     */\\n    event NewConduit(address conduit, bytes32 conduitKey);\\n\\n    /**\\n     * @dev Emit an event whenever conduit ownership is transferred.\\n     *\\n     * @param conduit       The conduit for which ownership has been\\n     *                      transferred.\\n     * @param previousOwner The previous owner of the conduit.\\n     * @param newOwner      The new owner of the conduit.\\n     */\\n    event OwnershipTransferred(\\n        address indexed conduit,\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Emit an event whenever a conduit owner registers a new potential\\n     *      owner for that conduit.\\n     *\\n     * @param newPotentialOwner The new potential owner of the conduit.\\n     */\\n    event PotentialOwnerUpdated(address indexed newPotentialOwner);\\n\\n    /**\\n     * @dev Revert with an error when attempting to create a new conduit using a\\n     *      conduit key where the first twenty bytes of the key do not match the\\n     *      address of the caller.\\n     */\\n    error InvalidCreator();\\n\\n    /**\\n     * @dev Revert with an error when attempting to create a new conduit when no\\n     *      initial owner address is supplied.\\n     */\\n    error InvalidInitialOwner();\\n\\n    /**\\n     * @dev Revert with an error when attempting to set a new potential owner\\n     *      that is already set.\\n     */\\n    error NewPotentialOwnerAlreadySet(\\n        address conduit,\\n        address newPotentialOwner\\n    );\\n\\n    /**\\n     * @dev Revert with an error when attempting to cancel ownership transfer\\n     *      when no new potential owner is currently set.\\n     */\\n    error NoPotentialOwnerCurrentlySet(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to interact with a conduit that\\n     *      does not yet exist.\\n     */\\n    error NoConduit();\\n\\n    /**\\n     * @dev Revert with an error when attempting to create a conduit that\\n     *      already exists.\\n     */\\n    error ConduitAlreadyExists(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to update channels or transfer\\n     *      ownership of a conduit when the caller is not the owner of the\\n     *      conduit in question.\\n     */\\n    error CallerIsNotOwner(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to register a new potential\\n     *      owner and supplying the null address.\\n     */\\n    error NewPotentialOwnerIsZeroAddress(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to claim ownership of a conduit\\n     *      with a caller that is not the current potential owner for the\\n     *      conduit in question.\\n     */\\n    error CallerIsNotNewPotentialOwner(address conduit);\\n\\n    /**\\n     * @dev Revert with an error when attempting to retrieve a channel using an\\n     *      index that is out of range.\\n     */\\n    error ChannelOutOfRange(address conduit);\\n\\n    /**\\n     * @notice Deploy a new conduit using a supplied conduit key and assigning\\n     *         an initial owner for the deployed conduit. Note that the first\\n     *         twenty bytes of the supplied conduit key must match the caller\\n     *         and that a new conduit cannot be created if one has already been\\n     *         deployed using the same conduit key.\\n     *\\n     * @param conduitKey   The conduit key used to deploy the conduit. Note that\\n     *                     the first twenty bytes of the conduit key must match\\n     *                     the caller of this contract.\\n     * @param initialOwner The initial owner to set for the new conduit.\\n     *\\n     * @return conduit The address of the newly deployed conduit.\\n     */\\n    function createConduit(\\n        bytes32 conduitKey,\\n        address initialOwner\\n    ) external returns (address conduit);\\n\\n    /**\\n     * @notice Open or close a channel on a given conduit, thereby allowing the\\n     *         specified account to execute transfers against that conduit.\\n     *         Extreme care must be taken when updating channels, as malicious\\n     *         or vulnerable channels can transfer any ERC20, ERC721 and ERC1155\\n     *         tokens where the token holder has granted the conduit approval.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to open or close the channel.\\n     * @param channel The channel to open or close on the conduit.\\n     * @param isOpen  A boolean indicating whether to open or close the channel.\\n     */\\n    function updateChannel(\\n        address conduit,\\n        address channel,\\n        bool isOpen\\n    ) external;\\n\\n    /**\\n     * @notice Initiate conduit ownership transfer by assigning a new potential\\n     *         owner for the given conduit. Once set, the new potential owner\\n     *         may call `acceptOwnership` to claim ownership of the conduit.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to initiate ownership transfer.\\n     * @param newPotentialOwner The new potential owner of the conduit.\\n     */\\n    function transferOwnership(\\n        address conduit,\\n        address newPotentialOwner\\n    ) external;\\n\\n    /**\\n     * @notice Clear the currently set potential owner, if any, from a conduit.\\n     *         Only the owner of the conduit in question may call this function.\\n     *\\n     * @param conduit The conduit for which to cancel ownership transfer.\\n     */\\n    function cancelOwnershipTransfer(address conduit) external;\\n\\n    /**\\n     * @notice Accept ownership of a supplied conduit. Only accounts that the\\n     *         current owner has set as the new potential owner may call this\\n     *         function.\\n     *\\n     * @param conduit The conduit for which to accept ownership.\\n     */\\n    function acceptOwnership(address conduit) external;\\n\\n    /**\\n     * @notice Retrieve the current owner of a deployed conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the associated owner.\\n     *\\n     * @return owner The owner of the supplied conduit.\\n     */\\n    function ownerOf(address conduit) external view returns (address owner);\\n\\n    /**\\n     * @notice Retrieve the conduit key for a deployed conduit via reverse\\n     *         lookup.\\n     *\\n     * @param conduit The conduit for which to retrieve the associated conduit\\n     *                key.\\n     *\\n     * @return conduitKey The conduit key used to deploy the supplied conduit.\\n     */\\n    function getKey(address conduit) external view returns (bytes32 conduitKey);\\n\\n    /**\\n     * @notice Derive the conduit associated with a given conduit key and\\n     *         determine whether that conduit exists (i.e. whether it has been\\n     *         deployed).\\n     *\\n     * @param conduitKey The conduit key used to derive the conduit.\\n     *\\n     * @return conduit The derived address of the conduit.\\n     * @return exists  A boolean indicating whether the derived conduit has been\\n     *                 deployed or not.\\n     */\\n    function getConduit(\\n        bytes32 conduitKey\\n    ) external view returns (address conduit, bool exists);\\n\\n    /**\\n     * @notice Retrieve the potential owner, if any, for a given conduit. The\\n     *         current owner may set a new potential owner via\\n     *         `transferOwnership` and that owner may then accept ownership of\\n     *         the conduit in question via `acceptOwnership`.\\n     *\\n     * @param conduit The conduit for which to retrieve the potential owner.\\n     *\\n     * @return potentialOwner The potential owner, if any, for the conduit.\\n     */\\n    function getPotentialOwner(\\n        address conduit\\n    ) external view returns (address potentialOwner);\\n\\n    /**\\n     * @notice Retrieve the status (either open or closed) of a given channel on\\n     *         a conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the channel status.\\n     * @param channel The channel for which to retrieve the status.\\n     *\\n     * @return isOpen The status of the channel on the given conduit.\\n     */\\n    function getChannelStatus(\\n        address conduit,\\n        address channel\\n    ) external view returns (bool isOpen);\\n\\n    /**\\n     * @notice Retrieve the total number of open channels for a given conduit.\\n     *\\n     * @param conduit The conduit for which to retrieve the total channel count.\\n     *\\n     * @return totalChannels The total number of open channels for the conduit.\\n     */\\n    function getTotalChannels(\\n        address conduit\\n    ) external view returns (uint256 totalChannels);\\n\\n    /**\\n     * @notice Retrieve an open channel at a specific index for a given conduit.\\n     *         Note that the index of a channel can change as a result of other\\n     *         channels being closed on the conduit.\\n     *\\n     * @param conduit      The conduit for which to retrieve the open channel.\\n     * @param channelIndex The index of the channel in question.\\n     *\\n     * @return channel The open channel, if any, at the specified channel index.\\n     */\\n    function getChannel(\\n        address conduit,\\n        uint256 channelIndex\\n    ) external view returns (address channel);\\n\\n    /**\\n     * @notice Retrieve all open channels for a given conduit. Note that calling\\n     *         this function for a conduit with many channels will revert with\\n     *         an out-of-gas error.\\n     *\\n     * @param conduit The conduit for which to retrieve open channels.\\n     *\\n     * @return channels An array of open channels on the given conduit.\\n     */\\n    function getChannels(\\n        address conduit\\n    ) external view returns (address[] memory channels);\\n\\n    /**\\n     * @dev Retrieve the conduit creation code and runtime code hashes.\\n     */\\n    function getConduitCodeHashes()\\n        external\\n        view\\n        returns (bytes32 creationCodeHash, bytes32 runtimeCodeHash);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\\n\\npragma solidity =0.8.17;\\n\\nimport {IERC165} from \\\"core/interfaces/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n  /**\\n   * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n   */\\n  event TransferSingle(\\n    address indexed operator,\\n    address indexed from,\\n    address indexed to,\\n    uint256 id,\\n    uint256 value\\n  );\\n\\n  /**\\n   * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n   * transfers.\\n   */\\n  event TransferBatch(\\n    address indexed operator,\\n    address indexed from,\\n    address indexed to,\\n    uint256[] ids,\\n    uint256[] values\\n  );\\n\\n  /**\\n   * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n   * `approved`.\\n   */\\n  event ApprovalForAll(\\n    address indexed account,\\n    address indexed operator,\\n    bool approved\\n  );\\n\\n  /**\\n   * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n   *\\n   * If an {URI} event was emitted for `id`, the standard\\n   * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n   * returned by {IERC1155MetadataURI-uri}.\\n   */\\n  event URI(string value, uint256 indexed id);\\n\\n  /**\\n   * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n   *\\n   * Requirements:\\n   *\\n   * - `account` cannot be the zero address.\\n   */\\n  function balanceOf(\\n    address account,\\n    uint256 id\\n  ) external view returns (uint256);\\n\\n  /**\\n   * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n   *\\n   * Requirements:\\n   *\\n   * - `accounts` and `ids` must have the same length.\\n   */\\n  function balanceOfBatch(\\n    address[] calldata accounts,\\n    uint256[] calldata ids\\n  ) external view returns (uint256[] memory);\\n\\n  /**\\n   * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n   *\\n   * Emits an {ApprovalForAll} event.\\n   *\\n   * Requirements:\\n   *\\n   * - `operator` cannot be the caller.\\n   */\\n  function setApprovalForAll(address operator, bool approved) external;\\n\\n  /**\\n   * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n   *\\n   * See {setApprovalForAll}.\\n   */\\n  function isApprovedForAll(\\n    address account,\\n    address operator\\n  ) external view returns (bool);\\n\\n  /**\\n   * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n   *\\n   * Emits a {TransferSingle} event.\\n   *\\n   * Requirements:\\n   *\\n   * - `to` cannot be the zero address.\\n   * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n   * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n   * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n   * acceptance magic value.\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 id,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external;\\n\\n  /**\\n   * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n   *\\n   * Emits a {TransferBatch} event.\\n   *\\n   * Requirements:\\n   *\\n   * - `ids` and `amounts` must have the same length.\\n   * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n   * acceptance magic value.\\n   */\\n  function safeBatchTransferFrom(\\n    address from,\\n    address to,\\n    uint256[] calldata ids,\\n    uint256[] calldata amounts,\\n    bytes calldata data\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"lib/gpl/src/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {IERC721} from \\\"core/interfaces/IERC721.sol\\\";\\n\\nimport {Initializable} from \\\"core/utils/Initializable.sol\\\";\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 is Initializable, IERC721 {\\n  /* //////////////////////////////////////////////////////////////\\n    METADATA STORAGE/LOGIC\\n  ////////////////////////////////////////////////////////////// */\\n\\n  uint256 private constant ERC721_SLOT =\\n    uint256(keccak256(\\\"xyz.astaria.ERC721.storage.location\\\")) - 1;\\n  struct ERC721Storage {\\n    string name;\\n    string symbol;\\n    mapping(uint256 => address) _ownerOf;\\n    mapping(address => uint256) _balanceOf;\\n    mapping(uint256 => address) getApproved;\\n    mapping(address => mapping(address => bool)) isApprovedForAll;\\n  }\\n\\n  function getApproved(uint256 tokenId) public view returns (address) {\\n    return _loadERC721Slot().getApproved[tokenId];\\n  }\\n\\n  function isApprovedForAll(address owner, address operator)\\n    public\\n    view\\n    returns (bool)\\n  {\\n    return _loadERC721Slot().isApprovedForAll[owner][operator];\\n  }\\n\\n  function tokenURI(uint256 id) external view virtual returns (string memory);\\n\\n  /* //////////////////////////////////////////////////////////////\\n    ERC721 BALANCE/OWNER STORAGE\\n  ////////////////////////////////////////////////////////////// */\\n\\n  function _loadERC721Slot() internal pure returns (ERC721Storage storage s) {\\n    uint256 slot = ERC721_SLOT;\\n\\n    assembly {\\n      s.slot := slot\\n    }\\n  }\\n\\n  function ownerOf(uint256 id) public view virtual returns (address owner) {\\n    require(\\n      (owner = _loadERC721Slot()._ownerOf[id]) != address(0),\\n      \\\"NOT_MINTED\\\"\\n    );\\n  }\\n\\n  function balanceOf(address owner) public view virtual returns (uint256) {\\n    require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n    return _loadERC721Slot()._balanceOf[owner];\\n  }\\n\\n  /* //////////////////////////////////////////////////////////////\\n  INITIALIZATION LOGIC\\n  ////////////////////////////////////////////////////////////// */\\n\\n  function __initERC721(string memory _name, string memory _symbol) internal {\\n    ERC721Storage storage s = _loadERC721Slot();\\n    s.name = _name;\\n    s.symbol = _symbol;\\n  }\\n\\n  /* //////////////////////////////////////////////////////////////\\n  ERC721 LOGIC\\n  ////////////////////////////////////////////////////////////// */\\n\\n  function name() public view returns (string memory) {\\n    return _loadERC721Slot().name;\\n  }\\n\\n  function symbol() public view returns (string memory) {\\n    return _loadERC721Slot().symbol;\\n  }\\n\\n  function approve(address spender, uint256 id) external virtual {\\n    ERC721Storage storage s = _loadERC721Slot();\\n    address owner = s._ownerOf[id];\\n    require(\\n      msg.sender == owner || s.isApprovedForAll[owner][msg.sender],\\n      \\\"NOT_AUTHORIZED\\\"\\n    );\\n\\n    s.getApproved[id] = spender;\\n\\n    emit Approval(owner, spender, id);\\n  }\\n\\n  function setApprovalForAll(address operator, bool approved) external virtual {\\n    _loadERC721Slot().isApprovedForAll[msg.sender][operator] = approved;\\n\\n    emit ApprovalForAll(msg.sender, operator, approved);\\n  }\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 id\\n  ) public virtual override(IERC721) {\\n    ERC721Storage storage s = _loadERC721Slot();\\n\\n    require(from == s._ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n    require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n    require(\\n      msg.sender == from ||\\n        s.isApprovedForAll[from][msg.sender] ||\\n        msg.sender == s.getApproved[id],\\n      \\\"NOT_AUTHORIZED\\\"\\n    );\\n    _transfer(from, to, id);\\n  }\\n\\n  function _transfer(\\n    address from,\\n    address to,\\n    uint256 id\\n  ) internal {\\n    // Underflow of the sender's balance is impossible because we check for\\n    // ownership above and the recipient's balance can't realistically overflow.\\n    ERC721Storage storage s = _loadERC721Slot();\\n\\n    unchecked {\\n      s._balanceOf[from]--;\\n\\n      s._balanceOf[to]++;\\n    }\\n\\n    s._ownerOf[id] = to;\\n\\n    delete s.getApproved[id];\\n\\n    emit Transfer(from, to, id);\\n  }\\n\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 id\\n  ) external virtual {\\n    transferFrom(from, to, id);\\n\\n    require(\\n      to.code.length == 0 ||\\n        ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n        ERC721TokenReceiver.onERC721Received.selector,\\n      \\\"UNSAFE_RECIPIENT\\\"\\n    );\\n  }\\n\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 id,\\n    bytes calldata data\\n  ) external override(IERC721) {\\n    transferFrom(from, to, id);\\n\\n    require(\\n      to.code.length == 0 ||\\n        ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n        ERC721TokenReceiver.onERC721Received.selector,\\n      \\\"UNSAFE_RECIPIENT\\\"\\n    );\\n  }\\n\\n  /* //////////////////////////////////////////////////////////////\\n  ERC165 LOGIC\\n  ////////////////////////////////////////////////////////////// */\\n\\n  function supportsInterface(bytes4 interfaceId)\\n    public\\n    view\\n    virtual\\n    returns (bool)\\n  {\\n    return\\n      interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n      interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n      interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n  }\\n\\n  /* //////////////////////////////////////////////////////////////\\n  INTERNAL MINT/BURN LOGIC\\n  ////////////////////////////////////////////////////////////// */\\n\\n  function _mint(address to, uint256 id) internal virtual {\\n    require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n    ERC721Storage storage s = _loadERC721Slot();\\n    require(s._ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n    // Counter overflow is incredibly unrealistic.\\n    unchecked {\\n      s._balanceOf[to]++;\\n    }\\n\\n    s._ownerOf[id] = to;\\n\\n    emit Transfer(address(0), to, id);\\n  }\\n\\n  function _burn(uint256 id) internal virtual {\\n    ERC721Storage storage s = _loadERC721Slot();\\n\\n    address owner = s._ownerOf[id];\\n\\n    require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n    // Ownership check above ensures no underflow.\\n    unchecked {\\n      s._balanceOf[owner]--;\\n    }\\n\\n    delete s._ownerOf[id];\\n\\n    delete s.getApproved[id];\\n\\n    emit Transfer(owner, address(0), id);\\n  }\\n\\n  /* //////////////////////////////////////////////////////////////\\n  INTERNAL SAFE MINT LOGIC\\n  ////////////////////////////////////////////////////////////// */\\n\\n  function _safeMint(address to, uint256 id) internal virtual {\\n    _mint(to, id);\\n\\n    require(\\n      to.code.length == 0 ||\\n        ERC721TokenReceiver(to).onERC721Received(\\n          msg.sender,\\n          address(0),\\n          id,\\n          \\\"\\\"\\n        ) ==\\n        ERC721TokenReceiver.onERC721Received.selector,\\n      \\\"UNSAFE_RECIPIENT\\\"\\n    );\\n  }\\n\\n  function _safeMint(\\n    address to,\\n    uint256 id,\\n    bytes memory data\\n  ) internal virtual {\\n    _mint(to, id);\\n\\n    require(\\n      to.code.length == 0 ||\\n        ERC721TokenReceiver(to).onERC721Received(\\n          msg.sender,\\n          address(0),\\n          id,\\n          data\\n        ) ==\\n        ERC721TokenReceiver.onERC721Received.selector,\\n      \\\"UNSAFE_RECIPIENT\\\"\\n    );\\n  }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n  function onERC721Received(\\n    address,\\n    address,\\n    uint256,\\n    bytes calldata\\n  ) external virtual returns (bytes4) {\\n    return ERC721TokenReceiver.onERC721Received.selector;\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity =0.8.17;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n  /**\\n   * @dev Returns true if this contract implements the interface defined by\\n   * `interfaceId`. See the corresponding\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n   * to learn more about how these ids are created.\\n   *\\n   * This function call must use less than 30 000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity =0.8.17;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `to`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address to, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(\\n    address owner,\\n    address spender\\n  ) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `from` to `to` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20Metadata.sol\": {\r\n      \"content\": \"pragma solidity =0.8.17;\\nimport {IERC20} from \\\"core/interfaces/IERC20.sol\\\";\\n\\ninterface IERC20Metadata is IERC20 {\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the decimals places of the token.\\n   */\\n  function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"lib/seaport-types/src/lib/ConsiderationEnums.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nenum OrderType {\\n    // 0: no partial fills, anyone can execute\\n    FULL_OPEN,\\n\\n    // 1: partial fills supported, anyone can execute\\n    PARTIAL_OPEN,\\n\\n    // 2: no partial fills, only offerer or zone can execute\\n    FULL_RESTRICTED,\\n\\n    // 3: partial fills supported, only offerer or zone can execute\\n    PARTIAL_RESTRICTED,\\n\\n    // 4: contract order type\\n    CONTRACT\\n}\\n\\nenum BasicOrderType {\\n    // 0: no partial fills, anyone can execute\\n    ETH_TO_ERC721_FULL_OPEN,\\n\\n    // 1: partial fills supported, anyone can execute\\n    ETH_TO_ERC721_PARTIAL_OPEN,\\n\\n    // 2: no partial fills, only offerer or zone can execute\\n    ETH_TO_ERC721_FULL_RESTRICTED,\\n\\n    // 3: partial fills supported, only offerer or zone can execute\\n    ETH_TO_ERC721_PARTIAL_RESTRICTED,\\n\\n    // 4: no partial fills, anyone can execute\\n    ETH_TO_ERC1155_FULL_OPEN,\\n\\n    // 5: partial fills supported, anyone can execute\\n    ETH_TO_ERC1155_PARTIAL_OPEN,\\n\\n    // 6: no partial fills, only offerer or zone can execute\\n    ETH_TO_ERC1155_FULL_RESTRICTED,\\n\\n    // 7: partial fills supported, only offerer or zone can execute\\n    ETH_TO_ERC1155_PARTIAL_RESTRICTED,\\n\\n    // 8: no partial fills, anyone can execute\\n    ERC20_TO_ERC721_FULL_OPEN,\\n\\n    // 9: partial fills supported, anyone can execute\\n    ERC20_TO_ERC721_PARTIAL_OPEN,\\n\\n    // 10: no partial fills, only offerer or zone can execute\\n    ERC20_TO_ERC721_FULL_RESTRICTED,\\n\\n    // 11: partial fills supported, only offerer or zone can execute\\n    ERC20_TO_ERC721_PARTIAL_RESTRICTED,\\n\\n    // 12: no partial fills, anyone can execute\\n    ERC20_TO_ERC1155_FULL_OPEN,\\n\\n    // 13: partial fills supported, anyone can execute\\n    ERC20_TO_ERC1155_PARTIAL_OPEN,\\n\\n    // 14: no partial fills, only offerer or zone can execute\\n    ERC20_TO_ERC1155_FULL_RESTRICTED,\\n\\n    // 15: partial fills supported, only offerer or zone can execute\\n    ERC20_TO_ERC1155_PARTIAL_RESTRICTED,\\n\\n    // 16: no partial fills, anyone can execute\\n    ERC721_TO_ERC20_FULL_OPEN,\\n\\n    // 17: partial fills supported, anyone can execute\\n    ERC721_TO_ERC20_PARTIAL_OPEN,\\n\\n    // 18: no partial fills, only offerer or zone can execute\\n    ERC721_TO_ERC20_FULL_RESTRICTED,\\n\\n    // 19: partial fills supported, only offerer or zone can execute\\n    ERC721_TO_ERC20_PARTIAL_RESTRICTED,\\n\\n    // 20: no partial fills, anyone can execute\\n    ERC1155_TO_ERC20_FULL_OPEN,\\n\\n    // 21: partial fills supported, anyone can execute\\n    ERC1155_TO_ERC20_PARTIAL_OPEN,\\n\\n    // 22: no partial fills, only offerer or zone can execute\\n    ERC1155_TO_ERC20_FULL_RESTRICTED,\\n\\n    // 23: partial fills supported, only offerer or zone can execute\\n    ERC1155_TO_ERC20_PARTIAL_RESTRICTED\\n}\\n\\nenum BasicOrderRouteType {\\n    // 0: provide Ether (or other native token) to receive offered ERC721 item.\\n    ETH_TO_ERC721,\\n\\n    // 1: provide Ether (or other native token) to receive offered ERC1155 item.\\n    ETH_TO_ERC1155,\\n\\n    // 2: provide ERC20 item to receive offered ERC721 item.\\n    ERC20_TO_ERC721,\\n\\n    // 3: provide ERC20 item to receive offered ERC1155 item.\\n    ERC20_TO_ERC1155,\\n\\n    // 4: provide ERC721 item to receive offered ERC20 item.\\n    ERC721_TO_ERC20,\\n\\n    // 5: provide ERC1155 item to receive offered ERC20 item.\\n    ERC1155_TO_ERC20\\n}\\n\\nenum ItemType {\\n    // 0: ETH on mainnet, MATIC on polygon, etc.\\n    NATIVE,\\n\\n    // 1: ERC20 items (ERC777 and ERC20 analogues could also technically work)\\n    ERC20,\\n\\n    // 2: ERC721 items\\n    ERC721,\\n\\n    // 3: ERC1155 items\\n    ERC1155,\\n\\n    // 4: ERC721 items where a number of tokenIds are supported\\n    ERC721_WITH_CRITERIA,\\n\\n    // 5: ERC1155 items where a number of ids are supported\\n    ERC1155_WITH_CRITERIA\\n}\\n\\nenum Side {\\n    // 0: Items that can be spent\\n    OFFER,\\n\\n    // 1: Items that must be received\\n    CONSIDERATION\\n}\\n\"\r\n    },\r\n    \"lib/seaport-types/src/helpers/PointerLibraries.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ntype CalldataPointer is uint256;\\n\\ntype ReturndataPointer is uint256;\\n\\ntype MemoryPointer is uint256;\\n\\nusing CalldataPointerLib for CalldataPointer global;\\nusing MemoryPointerLib for MemoryPointer global;\\nusing ReturndataPointerLib for ReturndataPointer global;\\n\\nusing CalldataReaders for CalldataPointer global;\\nusing ReturndataReaders for ReturndataPointer global;\\nusing MemoryReaders for MemoryPointer global;\\nusing MemoryWriters for MemoryPointer global;\\n\\nCalldataPointer constant CalldataStart = CalldataPointer.wrap(0x04);\\nMemoryPointer constant FreeMemoryPPtr = MemoryPointer.wrap(0x40);\\nuint256 constant IdentityPrecompileAddress = 0x4;\\nuint256 constant OffsetOrLengthMask = 0xffffffff;\\nuint256 constant _OneWord = 0x20;\\nuint256 constant _FreeMemoryPointerSlot = 0x40;\\n\\n/// @dev Allocates `size` bytes in memory by increasing the free memory pointer\\n///    and returns the memory pointer to the first byte of the allocated region.\\n// (Free functions cannot have visibility.)\\n// solhint-disable-next-line func-visibility\\nfunction malloc(uint256 size) pure returns (MemoryPointer mPtr) {\\n    assembly {\\n        mPtr := mload(_FreeMemoryPointerSlot)\\n        mstore(_FreeMemoryPointerSlot, add(mPtr, size))\\n    }\\n}\\n\\n// (Free functions cannot have visibility.)\\n// solhint-disable-next-line func-visibility\\nfunction getFreeMemoryPointer() pure returns (MemoryPointer mPtr) {\\n    mPtr = FreeMemoryPPtr.readMemoryPointer();\\n}\\n\\n// (Free functions cannot have visibility.)\\n// solhint-disable-next-line func-visibility\\nfunction setFreeMemoryPointer(MemoryPointer mPtr) pure {\\n    FreeMemoryPPtr.write(mPtr);\\n}\\n\\nlibrary CalldataPointerLib {\\n    function lt(\\n        CalldataPointer a,\\n        CalldataPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := lt(a, b)\\n        }\\n    }\\n\\n    function gt(\\n        CalldataPointer a,\\n        CalldataPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := gt(a, b)\\n        }\\n    }\\n\\n    function eq(\\n        CalldataPointer a,\\n        CalldataPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := eq(a, b)\\n        }\\n    }\\n\\n    function isNull(CalldataPointer a) internal pure returns (bool b) {\\n        assembly {\\n            b := iszero(a)\\n        }\\n    }\\n\\n    /// @dev Resolves an offset stored at `cdPtr + headOffset` to a calldata.\\n    ///      pointer `cdPtr` must point to some parent object with a dynamic\\n    ///      type's head stored at `cdPtr + headOffset`.\\n    function pptr(\\n        CalldataPointer cdPtr,\\n        uint256 headOffset\\n    ) internal pure returns (CalldataPointer cdPtrChild) {\\n        cdPtrChild = cdPtr.offset(\\n            cdPtr.offset(headOffset).readUint256() & OffsetOrLengthMask\\n        );\\n    }\\n\\n    /// @dev Resolves an offset stored at `cdPtr` to a calldata pointer.\\n    ///      `cdPtr` must point to some parent object with a dynamic type as its\\n    ///      first member, e.g. `struct { bytes data; }`\\n    function pptr(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (CalldataPointer cdPtrChild) {\\n        cdPtrChild = cdPtr.offset(cdPtr.readUint256() & OffsetOrLengthMask);\\n    }\\n\\n    /// @dev Returns the calldata pointer one word after `cdPtr`.\\n    function next(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (CalldataPointer cdPtrNext) {\\n        assembly {\\n            cdPtrNext := add(cdPtr, _OneWord)\\n        }\\n    }\\n\\n    /// @dev Returns the calldata pointer `_offset` bytes after `cdPtr`.\\n    function offset(\\n        CalldataPointer cdPtr,\\n        uint256 _offset\\n    ) internal pure returns (CalldataPointer cdPtrNext) {\\n        assembly {\\n            cdPtrNext := add(cdPtr, _offset)\\n        }\\n    }\\n\\n    /// @dev Copies `size` bytes from calldata starting at `src` to memory at\\n    ///      `dst`.\\n    function copy(\\n        CalldataPointer src,\\n        MemoryPointer dst,\\n        uint256 size\\n    ) internal pure {\\n        assembly {\\n            calldatacopy(dst, src, size)\\n        }\\n    }\\n}\\n\\nlibrary ReturndataPointerLib {\\n    function lt(\\n        ReturndataPointer a,\\n        ReturndataPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := lt(a, b)\\n        }\\n    }\\n\\n    function gt(\\n        ReturndataPointer a,\\n        ReturndataPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := gt(a, b)\\n        }\\n    }\\n\\n    function eq(\\n        ReturndataPointer a,\\n        ReturndataPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := eq(a, b)\\n        }\\n    }\\n\\n    function isNull(ReturndataPointer a) internal pure returns (bool b) {\\n        assembly {\\n            b := iszero(a)\\n        }\\n    }\\n\\n    /// @dev Resolves an offset stored at `rdPtr + headOffset` to a returndata\\n    ///      pointer. `rdPtr` must point to some parent object with a dynamic\\n    ///      type's head stored at `rdPtr + headOffset`.\\n    function pptr(\\n        ReturndataPointer rdPtr,\\n        uint256 headOffset\\n    ) internal pure returns (ReturndataPointer rdPtrChild) {\\n        rdPtrChild = rdPtr.offset(\\n            rdPtr.offset(headOffset).readUint256() & OffsetOrLengthMask\\n        );\\n    }\\n\\n    /// @dev Resolves an offset stored at `rdPtr` to a returndata pointer.\\n    ///    `rdPtr` must point to some parent object with a dynamic type as its\\n    ///    first member, e.g. `struct { bytes data; }`\\n    function pptr(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (ReturndataPointer rdPtrChild) {\\n        rdPtrChild = rdPtr.offset(rdPtr.readUint256() & OffsetOrLengthMask);\\n    }\\n\\n    /// @dev Returns the returndata pointer one word after `cdPtr`.\\n    function next(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (ReturndataPointer rdPtrNext) {\\n        assembly {\\n            rdPtrNext := add(rdPtr, _OneWord)\\n        }\\n    }\\n\\n    /// @dev Returns the returndata pointer `_offset` bytes after `cdPtr`.\\n    function offset(\\n        ReturndataPointer rdPtr,\\n        uint256 _offset\\n    ) internal pure returns (ReturndataPointer rdPtrNext) {\\n        assembly {\\n            rdPtrNext := add(rdPtr, _offset)\\n        }\\n    }\\n\\n    /// @dev Copies `size` bytes from returndata starting at `src` to memory at\\n    /// `dst`.\\n    function copy(\\n        ReturndataPointer src,\\n        MemoryPointer dst,\\n        uint256 size\\n    ) internal pure {\\n        assembly {\\n            returndatacopy(dst, src, size)\\n        }\\n    }\\n}\\n\\nlibrary MemoryPointerLib {\\n    function copy(\\n        MemoryPointer src,\\n        MemoryPointer dst,\\n        uint256 size\\n    ) internal view {\\n        assembly {\\n            let success := staticcall(\\n                gas(),\\n                IdentityPrecompileAddress,\\n                src,\\n                size,\\n                dst,\\n                size\\n            )\\n            if or(iszero(returndatasize()), iszero(success)) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n\\n    function lt(\\n        MemoryPointer a,\\n        MemoryPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := lt(a, b)\\n        }\\n    }\\n\\n    function gt(\\n        MemoryPointer a,\\n        MemoryPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := gt(a, b)\\n        }\\n    }\\n\\n    function eq(\\n        MemoryPointer a,\\n        MemoryPointer b\\n    ) internal pure returns (bool c) {\\n        assembly {\\n            c := eq(a, b)\\n        }\\n    }\\n\\n    function isNull(MemoryPointer a) internal pure returns (bool b) {\\n        assembly {\\n            b := iszero(a)\\n        }\\n    }\\n\\n    function hash(\\n        MemoryPointer ptr,\\n        uint256 length\\n    ) internal pure returns (bytes32 _hash) {\\n        assembly {\\n            _hash := keccak256(ptr, length)\\n        }\\n    }\\n\\n    /// @dev Returns the memory pointer one word after `mPtr`.\\n    function next(\\n        MemoryPointer mPtr\\n    ) internal pure returns (MemoryPointer mPtrNext) {\\n        assembly {\\n            mPtrNext := add(mPtr, _OneWord)\\n        }\\n    }\\n\\n    /// @dev Returns the memory pointer `_offset` bytes after `mPtr`.\\n    function offset(\\n        MemoryPointer mPtr,\\n        uint256 _offset\\n    ) internal pure returns (MemoryPointer mPtrNext) {\\n        assembly {\\n            mPtrNext := add(mPtr, _offset)\\n        }\\n    }\\n\\n    /// @dev Resolves a pointer at `mPtr + headOffset` to a memory\\n    ///    pointer. `mPtr` must point to some parent object with a dynamic\\n    ///    type's pointer stored at `mPtr + headOffset`.\\n    function pptr(\\n        MemoryPointer mPtr,\\n        uint256 headOffset\\n    ) internal pure returns (MemoryPointer mPtrChild) {\\n        mPtrChild = mPtr.offset(headOffset).readMemoryPointer();\\n    }\\n\\n    /// @dev Resolves a pointer stored at `mPtr` to a memory pointer.\\n    ///    `mPtr` must point to some parent object with a dynamic type as its\\n    ///    first member, e.g. `struct { bytes data; }`\\n    function pptr(\\n        MemoryPointer mPtr\\n    ) internal pure returns (MemoryPointer mPtrChild) {\\n        mPtrChild = mPtr.readMemoryPointer();\\n    }\\n}\\n\\nlibrary CalldataReaders {\\n    /// @dev Reads the value at `cdPtr` and applies a mask to return only the\\n    ///    last 4 bytes.\\n    function readMaskedUint256(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint256 value) {\\n        value = cdPtr.readUint256() & OffsetOrLengthMask;\\n    }\\n\\n    /// @dev Reads the bool at `cdPtr` in calldata.\\n    function readBool(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bool value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the address at `cdPtr` in calldata.\\n    function readAddress(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (address value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes1 at `cdPtr` in calldata.\\n    function readBytes1(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes1 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes2 at `cdPtr` in calldata.\\n    function readBytes2(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes2 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes3 at `cdPtr` in calldata.\\n    function readBytes3(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes3 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes4 at `cdPtr` in calldata.\\n    function readBytes4(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes4 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes5 at `cdPtr` in calldata.\\n    function readBytes5(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes5 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes6 at `cdPtr` in calldata.\\n    function readBytes6(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes6 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes7 at `cdPtr` in calldata.\\n    function readBytes7(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes7 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes8 at `cdPtr` in calldata.\\n    function readBytes8(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes8 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes9 at `cdPtr` in calldata.\\n    function readBytes9(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes9 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes10 at `cdPtr` in calldata.\\n    function readBytes10(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes10 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes11 at `cdPtr` in calldata.\\n    function readBytes11(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes11 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes12 at `cdPtr` in calldata.\\n    function readBytes12(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes12 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes13 at `cdPtr` in calldata.\\n    function readBytes13(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes13 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes14 at `cdPtr` in calldata.\\n    function readBytes14(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes14 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes15 at `cdPtr` in calldata.\\n    function readBytes15(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes15 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes16 at `cdPtr` in calldata.\\n    function readBytes16(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes16 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes17 at `cdPtr` in calldata.\\n    function readBytes17(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes17 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes18 at `cdPtr` in calldata.\\n    function readBytes18(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes18 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes19 at `cdPtr` in calldata.\\n    function readBytes19(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes19 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes20 at `cdPtr` in calldata.\\n    function readBytes20(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes20 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes21 at `cdPtr` in calldata.\\n    function readBytes21(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes21 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes22 at `cdPtr` in calldata.\\n    function readBytes22(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes22 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes23 at `cdPtr` in calldata.\\n    function readBytes23(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes23 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes24 at `cdPtr` in calldata.\\n    function readBytes24(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes24 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes25 at `cdPtr` in calldata.\\n    function readBytes25(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes25 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes26 at `cdPtr` in calldata.\\n    function readBytes26(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes26 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes27 at `cdPtr` in calldata.\\n    function readBytes27(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes27 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes28 at `cdPtr` in calldata.\\n    function readBytes28(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes28 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes29 at `cdPtr` in calldata.\\n    function readBytes29(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes29 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes30 at `cdPtr` in calldata.\\n    function readBytes30(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes30 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes31 at `cdPtr` in calldata.\\n    function readBytes31(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes31 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes32 at `cdPtr` in calldata.\\n    function readBytes32(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (bytes32 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint8 at `cdPtr` in calldata.\\n    function readUint8(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint8 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint16 at `cdPtr` in calldata.\\n    function readUint16(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint16 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint24 at `cdPtr` in calldata.\\n    function readUint24(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint24 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint32 at `cdPtr` in calldata.\\n    function readUint32(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint32 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint40 at `cdPtr` in calldata.\\n    function readUint40(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint40 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint48 at `cdPtr` in calldata.\\n    function readUint48(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint48 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint56 at `cdPtr` in calldata.\\n    function readUint56(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint56 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint64 at `cdPtr` in calldata.\\n    function readUint64(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint64 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint72 at `cdPtr` in calldata.\\n    function readUint72(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint72 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint80 at `cdPtr` in calldata.\\n    function readUint80(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint80 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint88 at `cdPtr` in calldata.\\n    function readUint88(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint88 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint96 at `cdPtr` in calldata.\\n    function readUint96(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint96 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint104 at `cdPtr` in calldata.\\n    function readUint104(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint104 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint112 at `cdPtr` in calldata.\\n    function readUint112(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint112 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint120 at `cdPtr` in calldata.\\n    function readUint120(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint120 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint128 at `cdPtr` in calldata.\\n    function readUint128(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint128 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint136 at `cdPtr` in calldata.\\n    function readUint136(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint136 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint144 at `cdPtr` in calldata.\\n    function readUint144(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint144 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint152 at `cdPtr` in calldata.\\n    function readUint152(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint152 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint160 at `cdPtr` in calldata.\\n    function readUint160(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint160 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint168 at `cdPtr` in calldata.\\n    function readUint168(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint168 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint176 at `cdPtr` in calldata.\\n    function readUint176(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint176 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint184 at `cdPtr` in calldata.\\n    function readUint184(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint184 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint192 at `cdPtr` in calldata.\\n    function readUint192(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint192 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint200 at `cdPtr` in calldata.\\n    function readUint200(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint200 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint208 at `cdPtr` in calldata.\\n    function readUint208(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint208 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint216 at `cdPtr` in calldata.\\n    function readUint216(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint216 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint224 at `cdPtr` in calldata.\\n    function readUint224(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint224 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint232 at `cdPtr` in calldata.\\n    function readUint232(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint232 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint240 at `cdPtr` in calldata.\\n    function readUint240(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint240 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint248 at `cdPtr` in calldata.\\n    function readUint248(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint248 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint256 at `cdPtr` in calldata.\\n    function readUint256(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (uint256 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int8 at `cdPtr` in calldata.\\n    function readInt8(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int8 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int16 at `cdPtr` in calldata.\\n    function readInt16(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int16 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int24 at `cdPtr` in calldata.\\n    function readInt24(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int24 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int32 at `cdPtr` in calldata.\\n    function readInt32(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int32 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int40 at `cdPtr` in calldata.\\n    function readInt40(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int40 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int48 at `cdPtr` in calldata.\\n    function readInt48(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int48 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int56 at `cdPtr` in calldata.\\n    function readInt56(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int56 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int64 at `cdPtr` in calldata.\\n    function readInt64(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int64 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int72 at `cdPtr` in calldata.\\n    function readInt72(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int72 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int80 at `cdPtr` in calldata.\\n    function readInt80(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int80 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int88 at `cdPtr` in calldata.\\n    function readInt88(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int88 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int96 at `cdPtr` in calldata.\\n    function readInt96(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int96 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int104 at `cdPtr` in calldata.\\n    function readInt104(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int104 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int112 at `cdPtr` in calldata.\\n    function readInt112(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int112 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int120 at `cdPtr` in calldata.\\n    function readInt120(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int120 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int128 at `cdPtr` in calldata.\\n    function readInt128(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int128 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int136 at `cdPtr` in calldata.\\n    function readInt136(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int136 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int144 at `cdPtr` in calldata.\\n    function readInt144(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int144 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int152 at `cdPtr` in calldata.\\n    function readInt152(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int152 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int160 at `cdPtr` in calldata.\\n    function readInt160(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int160 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int168 at `cdPtr` in calldata.\\n    function readInt168(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int168 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int176 at `cdPtr` in calldata.\\n    function readInt176(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int176 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int184 at `cdPtr` in calldata.\\n    function readInt184(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int184 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int192 at `cdPtr` in calldata.\\n    function readInt192(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int192 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int200 at `cdPtr` in calldata.\\n    function readInt200(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int200 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int208 at `cdPtr` in calldata.\\n    function readInt208(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int208 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int216 at `cdPtr` in calldata.\\n    function readInt216(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int216 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int224 at `cdPtr` in calldata.\\n    function readInt224(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int224 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int232 at `cdPtr` in calldata.\\n    function readInt232(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int232 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int240 at `cdPtr` in calldata.\\n    function readInt240(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int240 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int248 at `cdPtr` in calldata.\\n    function readInt248(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int248 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int256 at `cdPtr` in calldata.\\n    function readInt256(\\n        CalldataPointer cdPtr\\n    ) internal pure returns (int256 value) {\\n        assembly {\\n            value := calldataload(cdPtr)\\n        }\\n    }\\n}\\n\\nlibrary ReturndataReaders {\\n    /// @dev Reads value at `rdPtr` & applies a mask to return only last 4 bytes\\n    function readMaskedUint256(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint256 value) {\\n        value = rdPtr.readUint256() & OffsetOrLengthMask;\\n    }\\n\\n    /// @dev Reads the bool at `rdPtr` in returndata.\\n    function readBool(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bool value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the address at `rdPtr` in returndata.\\n    function readAddress(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (address value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes1 at `rdPtr` in returndata.\\n    function readBytes1(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes1 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes2 at `rdPtr` in returndata.\\n    function readBytes2(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes2 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes3 at `rdPtr` in returndata.\\n    function readBytes3(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes3 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes4 at `rdPtr` in returndata.\\n    function readBytes4(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes4 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes5 at `rdPtr` in returndata.\\n    function readBytes5(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes5 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes6 at `rdPtr` in returndata.\\n    function readBytes6(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes6 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes7 at `rdPtr` in returndata.\\n    function readBytes7(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes7 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes8 at `rdPtr` in returndata.\\n    function readBytes8(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes8 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes9 at `rdPtr` in returndata.\\n    function readBytes9(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes9 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes10 at `rdPtr` in returndata.\\n    function readBytes10(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes10 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes11 at `rdPtr` in returndata.\\n    function readBytes11(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes11 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes12 at `rdPtr` in returndata.\\n    function readBytes12(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes12 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes13 at `rdPtr` in returndata.\\n    function readBytes13(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes13 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes14 at `rdPtr` in returndata.\\n    function readBytes14(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes14 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes15 at `rdPtr` in returndata.\\n    function readBytes15(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes15 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes16 at `rdPtr` in returndata.\\n    function readBytes16(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes16 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes17 at `rdPtr` in returndata.\\n    function readBytes17(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes17 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes18 at `rdPtr` in returndata.\\n    function readBytes18(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes18 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes19 at `rdPtr` in returndata.\\n    function readBytes19(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes19 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes20 at `rdPtr` in returndata.\\n    function readBytes20(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes20 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes21 at `rdPtr` in returndata.\\n    function readBytes21(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes21 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes22 at `rdPtr` in returndata.\\n    function readBytes22(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes22 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes23 at `rdPtr` in returndata.\\n    function readBytes23(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes23 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes24 at `rdPtr` in returndata.\\n    function readBytes24(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes24 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes25 at `rdPtr` in returndata.\\n    function readBytes25(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes25 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes26 at `rdPtr` in returndata.\\n    function readBytes26(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes26 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes27 at `rdPtr` in returndata.\\n    function readBytes27(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes27 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes28 at `rdPtr` in returndata.\\n    function readBytes28(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes28 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes29 at `rdPtr` in returndata.\\n    function readBytes29(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes29 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes30 at `rdPtr` in returndata.\\n    function readBytes30(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes30 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes31 at `rdPtr` in returndata.\\n    function readBytes31(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes31 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes32 at `rdPtr` in returndata.\\n    function readBytes32(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (bytes32 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint8 at `rdPtr` in returndata.\\n    function readUint8(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint8 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint16 at `rdPtr` in returndata.\\n    function readUint16(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint16 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint24 at `rdPtr` in returndata.\\n    function readUint24(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint24 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint32 at `rdPtr` in returndata.\\n    function readUint32(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint32 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint40 at `rdPtr` in returndata.\\n    function readUint40(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint40 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint48 at `rdPtr` in returndata.\\n    function readUint48(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint48 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint56 at `rdPtr` in returndata.\\n    function readUint56(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint56 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint64 at `rdPtr` in returndata.\\n    function readUint64(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint64 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint72 at `rdPtr` in returndata.\\n    function readUint72(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint72 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint80 at `rdPtr` in returndata.\\n    function readUint80(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint80 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint88 at `rdPtr` in returndata.\\n    function readUint88(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint88 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint96 at `rdPtr` in returndata.\\n    function readUint96(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint96 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint104 at `rdPtr` in returndata.\\n    function readUint104(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint104 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint112 at `rdPtr` in returndata.\\n    function readUint112(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint112 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint120 at `rdPtr` in returndata.\\n    function readUint120(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint120 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint128 at `rdPtr` in returndata.\\n    function readUint128(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint128 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint136 at `rdPtr` in returndata.\\n    function readUint136(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint136 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint144 at `rdPtr` in returndata.\\n    function readUint144(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint144 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint152 at `rdPtr` in returndata.\\n    function readUint152(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint152 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint160 at `rdPtr` in returndata.\\n    function readUint160(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint160 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint168 at `rdPtr` in returndata.\\n    function readUint168(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint168 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint176 at `rdPtr` in returndata.\\n    function readUint176(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint176 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint184 at `rdPtr` in returndata.\\n    function readUint184(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint184 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint192 at `rdPtr` in returndata.\\n    function readUint192(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint192 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint200 at `rdPtr` in returndata.\\n    function readUint200(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint200 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint208 at `rdPtr` in returndata.\\n    function readUint208(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint208 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint216 at `rdPtr` in returndata.\\n    function readUint216(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint216 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint224 at `rdPtr` in returndata.\\n    function readUint224(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint224 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint232 at `rdPtr` in returndata.\\n    function readUint232(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint232 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint240 at `rdPtr` in returndata.\\n    function readUint240(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint240 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint248 at `rdPtr` in returndata.\\n    function readUint248(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint248 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the uint256 at `rdPtr` in returndata.\\n    function readUint256(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (uint256 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int8 at `rdPtr` in returndata.\\n    function readInt8(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int8 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int16 at `rdPtr` in returndata.\\n    function readInt16(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int16 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int24 at `rdPtr` in returndata.\\n    function readInt24(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int24 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int32 at `rdPtr` in returndata.\\n    function readInt32(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int32 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int40 at `rdPtr` in returndata.\\n    function readInt40(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int40 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int48 at `rdPtr` in returndata.\\n    function readInt48(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int48 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int56 at `rdPtr` in returndata.\\n    function readInt56(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int56 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int64 at `rdPtr` in returndata.\\n    function readInt64(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int64 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int72 at `rdPtr` in returndata.\\n    function readInt72(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int72 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int80 at `rdPtr` in returndata.\\n    function readInt80(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int80 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int88 at `rdPtr` in returndata.\\n    function readInt88(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int88 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int96 at `rdPtr` in returndata.\\n    function readInt96(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int96 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int104 at `rdPtr` in returndata.\\n    function readInt104(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int104 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int112 at `rdPtr` in returndata.\\n    function readInt112(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int112 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int120 at `rdPtr` in returndata.\\n    function readInt120(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int120 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int128 at `rdPtr` in returndata.\\n    function readInt128(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int128 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int136 at `rdPtr` in returndata.\\n    function readInt136(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int136 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int144 at `rdPtr` in returndata.\\n    function readInt144(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int144 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int152 at `rdPtr` in returndata.\\n    function readInt152(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int152 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int160 at `rdPtr` in returndata.\\n    function readInt160(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int160 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int168 at `rdPtr` in returndata.\\n    function readInt168(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int168 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int176 at `rdPtr` in returndata.\\n    function readInt176(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int176 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int184 at `rdPtr` in returndata.\\n    function readInt184(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int184 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int192 at `rdPtr` in returndata.\\n    function readInt192(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int192 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int200 at `rdPtr` in returndata.\\n    function readInt200(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int200 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int208 at `rdPtr` in returndata.\\n    function readInt208(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int208 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int216 at `rdPtr` in returndata.\\n    function readInt216(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int216 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int224 at `rdPtr` in returndata.\\n    function readInt224(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int224 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int232 at `rdPtr` in returndata.\\n    function readInt232(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int232 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int240 at `rdPtr` in returndata.\\n    function readInt240(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int240 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int248 at `rdPtr` in returndata.\\n    function readInt248(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int248 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n\\n    /// @dev Reads the int256 at `rdPtr` in returndata.\\n    function readInt256(\\n        ReturndataPointer rdPtr\\n    ) internal pure returns (int256 value) {\\n        assembly {\\n            returndatacopy(0, rdPtr, _OneWord)\\n            value := mload(0)\\n        }\\n    }\\n}\\n\\nlibrary MemoryReaders {\\n    /// @dev Reads the memory pointer at `mPtr` in memory.\\n    function readMemoryPointer(\\n        MemoryPointer mPtr\\n    ) internal pure returns (MemoryPointer value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads value at `mPtr` & applies a mask to return only last 4 bytes\\n    function readMaskedUint256(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint256 value) {\\n        value = mPtr.readUint256() & OffsetOrLengthMask;\\n    }\\n\\n    /// @dev Reads the bool at `mPtr` in memory.\\n    function readBool(MemoryPointer mPtr) internal pure returns (bool value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the address at `mPtr` in memory.\\n    function readAddress(\\n        MemoryPointer mPtr\\n    ) internal pure returns (address value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes1 at `mPtr` in memory.\\n    function readBytes1(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes1 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes2 at `mPtr` in memory.\\n    function readBytes2(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes2 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes3 at `mPtr` in memory.\\n    function readBytes3(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes3 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes4 at `mPtr` in memory.\\n    function readBytes4(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes4 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes5 at `mPtr` in memory.\\n    function readBytes5(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes5 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes6 at `mPtr` in memory.\\n    function readBytes6(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes6 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes7 at `mPtr` in memory.\\n    function readBytes7(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes7 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes8 at `mPtr` in memory.\\n    function readBytes8(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes8 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes9 at `mPtr` in memory.\\n    function readBytes9(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes9 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes10 at `mPtr` in memory.\\n    function readBytes10(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes10 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes11 at `mPtr` in memory.\\n    function readBytes11(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes11 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes12 at `mPtr` in memory.\\n    function readBytes12(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes12 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes13 at `mPtr` in memory.\\n    function readBytes13(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes13 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes14 at `mPtr` in memory.\\n    function readBytes14(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes14 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes15 at `mPtr` in memory.\\n    function readBytes15(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes15 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes16 at `mPtr` in memory.\\n    function readBytes16(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes16 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes17 at `mPtr` in memory.\\n    function readBytes17(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes17 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes18 at `mPtr` in memory.\\n    function readBytes18(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes18 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes19 at `mPtr` in memory.\\n    function readBytes19(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes19 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes20 at `mPtr` in memory.\\n    function readBytes20(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes20 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes21 at `mPtr` in memory.\\n    function readBytes21(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes21 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes22 at `mPtr` in memory.\\n    function readBytes22(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes22 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes23 at `mPtr` in memory.\\n    function readBytes23(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes23 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes24 at `mPtr` in memory.\\n    function readBytes24(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes24 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes25 at `mPtr` in memory.\\n    function readBytes25(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes25 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes26 at `mPtr` in memory.\\n    function readBytes26(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes26 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes27 at `mPtr` in memory.\\n    function readBytes27(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes27 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes28 at `mPtr` in memory.\\n    function readBytes28(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes28 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes29 at `mPtr` in memory.\\n    function readBytes29(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes29 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes30 at `mPtr` in memory.\\n    function readBytes30(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes30 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes31 at `mPtr` in memory.\\n    function readBytes31(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes31 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the bytes32 at `mPtr` in memory.\\n    function readBytes32(\\n        MemoryPointer mPtr\\n    ) internal pure returns (bytes32 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint8 at `mPtr` in memory.\\n    function readUint8(MemoryPointer mPtr) internal pure returns (uint8 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint16 at `mPtr` in memory.\\n    function readUint16(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint16 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint24 at `mPtr` in memory.\\n    function readUint24(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint24 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint32 at `mPtr` in memory.\\n    function readUint32(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint32 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint40 at `mPtr` in memory.\\n    function readUint40(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint40 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint48 at `mPtr` in memory.\\n    function readUint48(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint48 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint56 at `mPtr` in memory.\\n    function readUint56(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint56 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint64 at `mPtr` in memory.\\n    function readUint64(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint64 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint72 at `mPtr` in memory.\\n    function readUint72(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint72 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint80 at `mPtr` in memory.\\n    function readUint80(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint80 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint88 at `mPtr` in memory.\\n    function readUint88(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint88 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint96 at `mPtr` in memory.\\n    function readUint96(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint96 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint104 at `mPtr` in memory.\\n    function readUint104(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint104 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint112 at `mPtr` in memory.\\n    function readUint112(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint112 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint120 at `mPtr` in memory.\\n    function readUint120(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint120 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint128 at `mPtr` in memory.\\n    function readUint128(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint128 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint136 at `mPtr` in memory.\\n    function readUint136(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint136 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint144 at `mPtr` in memory.\\n    function readUint144(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint144 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint152 at `mPtr` in memory.\\n    function readUint152(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint152 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint160 at `mPtr` in memory.\\n    function readUint160(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint160 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint168 at `mPtr` in memory.\\n    function readUint168(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint168 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint176 at `mPtr` in memory.\\n    function readUint176(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint176 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint184 at `mPtr` in memory.\\n    function readUint184(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint184 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint192 at `mPtr` in memory.\\n    function readUint192(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint192 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint200 at `mPtr` in memory.\\n    function readUint200(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint200 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint208 at `mPtr` in memory.\\n    function readUint208(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint208 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint216 at `mPtr` in memory.\\n    function readUint216(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint216 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint224 at `mPtr` in memory.\\n    function readUint224(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint224 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint232 at `mPtr` in memory.\\n    function readUint232(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint232 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint240 at `mPtr` in memory.\\n    function readUint240(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint240 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint248 at `mPtr` in memory.\\n    function readUint248(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint248 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the uint256 at `mPtr` in memory.\\n    function readUint256(\\n        MemoryPointer mPtr\\n    ) internal pure returns (uint256 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int8 at `mPtr` in memory.\\n    function readInt8(MemoryPointer mPtr) internal pure returns (int8 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int16 at `mPtr` in memory.\\n    function readInt16(MemoryPointer mPtr) internal pure returns (int16 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int24 at `mPtr` in memory.\\n    function readInt24(MemoryPointer mPtr) internal pure returns (int24 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int32 at `mPtr` in memory.\\n    function readInt32(MemoryPointer mPtr) internal pure returns (int32 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int40 at `mPtr` in memory.\\n    function readInt40(MemoryPointer mPtr) internal pure returns (int40 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int48 at `mPtr` in memory.\\n    function readInt48(MemoryPointer mPtr) internal pure returns (int48 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int56 at `mPtr` in memory.\\n    function readInt56(MemoryPointer mPtr) internal pure returns (int56 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int64 at `mPtr` in memory.\\n    function readInt64(MemoryPointer mPtr) internal pure returns (int64 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int72 at `mPtr` in memory.\\n    function readInt72(MemoryPointer mPtr) internal pure returns (int72 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int80 at `mPtr` in memory.\\n    function readInt80(MemoryPointer mPtr) internal pure returns (int80 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int88 at `mPtr` in memory.\\n    function readInt88(MemoryPointer mPtr) internal pure returns (int88 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int96 at `mPtr` in memory.\\n    function readInt96(MemoryPointer mPtr) internal pure returns (int96 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int104 at `mPtr` in memory.\\n    function readInt104(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int104 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int112 at `mPtr` in memory.\\n    function readInt112(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int112 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int120 at `mPtr` in memory.\\n    function readInt120(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int120 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int128 at `mPtr` in memory.\\n    function readInt128(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int128 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int136 at `mPtr` in memory.\\n    function readInt136(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int136 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int144 at `mPtr` in memory.\\n    function readInt144(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int144 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int152 at `mPtr` in memory.\\n    function readInt152(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int152 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int160 at `mPtr` in memory.\\n    function readInt160(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int160 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int168 at `mPtr` in memory.\\n    function readInt168(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int168 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int176 at `mPtr` in memory.\\n    function readInt176(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int176 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int184 at `mPtr` in memory.\\n    function readInt184(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int184 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int192 at `mPtr` in memory.\\n    function readInt192(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int192 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int200 at `mPtr` in memory.\\n    function readInt200(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int200 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int208 at `mPtr` in memory.\\n    function readInt208(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int208 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int216 at `mPtr` in memory.\\n    function readInt216(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int216 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int224 at `mPtr` in memory.\\n    function readInt224(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int224 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int232 at `mPtr` in memory.\\n    function readInt232(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int232 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int240 at `mPtr` in memory.\\n    function readInt240(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int240 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int248 at `mPtr` in memory.\\n    function readInt248(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int248 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n\\n    /// @dev Reads the int256 at `mPtr` in memory.\\n    function readInt256(\\n        MemoryPointer mPtr\\n    ) internal pure returns (int256 value) {\\n        assembly {\\n            value := mload(mPtr)\\n        }\\n    }\\n}\\n\\nlibrary MemoryWriters {\\n    /// @dev Writes `valuePtr` to memory at `mPtr`.\\n    function write(MemoryPointer mPtr, MemoryPointer valuePtr) internal pure {\\n        assembly {\\n            mstore(mPtr, valuePtr)\\n        }\\n    }\\n\\n    /// @dev Writes a boolean `value` to `mPtr` in memory.\\n    function write(MemoryPointer mPtr, bool value) internal pure {\\n        assembly {\\n            mstore(mPtr, value)\\n        }\\n    }\\n\\n    /// @dev Writes an address `value` to `mPtr` in memory.\\n    function write(MemoryPointer mPtr, address value) internal pure {\\n        assembly {\\n            mstore(mPtr, value)\\n        }\\n    }\\n\\n    /// @dev Writes a bytes32 `value` to `mPtr` in memory.\\n    /// Separate name to disambiguate literal write parameters.\\n    function writeBytes32(MemoryPointer mPtr, bytes32 value) internal pure {\\n        assembly {\\n            mstore(mPtr, value)\\n        }\\n    }\\n\\n    /// @dev Writes a uint256 `value` to `mPtr` in memory.\\n    function write(MemoryPointer mPtr, uint256 value) internal pure {\\n        assembly {\\n            mstore(mPtr, value)\\n        }\\n    }\\n\\n    /// @dev Writes an int256 `value` to `mPtr` in memory.\\n    /// Separate name to disambiguate literal write parameters.\\n    function writeInt(MemoryPointer mPtr, int256 value) internal pure {\\n        assembly {\\n            mstore(mPtr, value)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n   *\\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n   * constructor.\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies on extcodesize/address.code.length, which returns 0\\n    // for contracts in construction, since the code is only stored at the end\\n    // of the constructor execution.\\n\\n    return account.code.length > 0;\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n    require(\\n      success,\\n      \\\"Address: unable to send value, recipient may have reverted\\\"\\n    );\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`. A\\n   * plain `call` is an unsafe replacement for a function call: use this\\n   * function instead.\\n   *\\n   * If `target` reverts with a revert reason, it is bubbled up by this\\n   * function (like regular Solidity function calls).\\n   *\\n   * Returns the raw returned data. To convert to the expected return value,\\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n   *\\n   * Requirements:\\n   *\\n   * - `target` must be a contract.\\n   * - calling `target` with `data` must not revert.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(\\n    address target,\\n    bytes memory data\\n  ) internal returns (bytes memory) {\\n    return\\n      functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n   * `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but also transferring `value` wei to `target`.\\n   *\\n   * Requirements:\\n   *\\n   * - the calling contract must have an ETH balance of at least `value`.\\n   * - the called Solidity function must be `payable`.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return\\n      functionCallWithValue(\\n        target,\\n        data,\\n        value,\\n        \\\"Address: low-level call with value failed\\\"\\n      );\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(\\n      address(this).balance >= value,\\n      \\\"Address: insufficient balance for call\\\"\\n    );\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return\\n      verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data\\n  ) internal view returns (bytes memory) {\\n    return\\n      functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return\\n      verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(\\n    address target,\\n    bytes memory data\\n  ) internal returns (bytes memory) {\\n    return\\n      functionDelegateCall(\\n        target,\\n        data,\\n        \\\"Address: low-level delegate call failed\\\"\\n      );\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\n    return\\n      verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n   * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n   *\\n   * _Available since v4.8._\\n   */\\n  function verifyCallResultFromTarget(\\n    address target,\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    if (success) {\\n      if (returndata.length == 0) {\\n        // only check isContract if the call was successful and the return data is empty\\n        // otherwise we already know that it was a contract\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n      }\\n      return returndata;\\n    } else {\\n      _revert(returndata, errorMessage);\\n    }\\n  }\\n\\n  /**\\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n   * revert reason or using the provided one.\\n   *\\n   * _Available since v4.3._\\n   */\\n  function verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      _revert(returndata, errorMessage);\\n    }\\n  }\\n\\n  function _revert(\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) private pure {\\n    // Look for revert reason and bubble it up if present\\n    if (returndata.length > 0) {\\n      // The easiest way to bubble the revert reason is using memory via assembly\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        let returndata_size := mload(returndata)\\n        revert(add(32, returndata), returndata_size)\\n      }\\n    } else {\\n      revert(errorMessage);\\n    }\\n  }\\n}\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n  uint256 private constant INITIALIZER_SLOT =\\n    uint256(\\n      uint256(keccak256(\\\"core.astaria.xyz.initializer.storage.location\\\")) - 1\\n    );\\n\\n  struct InitializerState {\\n    uint8 _initialized;\\n    bool _initializing;\\n  }\\n\\n  /**\\n   * @dev Triggered when the contract has been initialized or reinitialized.\\n   */\\n  event Initialized(uint8 version);\\n\\n  function _getInitializerSlot()\\n    private\\n    view\\n    returns (InitializerState storage state)\\n  {\\n    uint256 slot = INITIALIZER_SLOT;\\n    assembly {\\n      state.slot := slot\\n    }\\n  }\\n\\n  /**\\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n   * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n   */\\n  modifier initializer() {\\n    InitializerState storage s = _getInitializerSlot();\\n    bool isTopLevelCall = !s._initializing;\\n    require(\\n      (isTopLevelCall && s._initialized < 1) ||\\n        (!Address.isContract(address(this)) && s._initialized == 1),\\n      \\\"Initializable: contract is already initialized\\\"\\n    );\\n    s._initialized = 1;\\n    if (isTopLevelCall) {\\n      s._initializing = true;\\n    }\\n    _;\\n    if (isTopLevelCall) {\\n      s._initializing = false;\\n      emit Initialized(1);\\n    }\\n  }\\n\\n  /**\\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n   * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n   * used to initialize parent contracts.\\n   *\\n   * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n   * initialization step. This is essential to configure modules that are added through upgrades and that require\\n   * initialization.\\n   *\\n   * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n   * a contract, executing them in the right order is up to the developer or operator.\\n   */\\n  modifier reinitializer(uint8 version) {\\n    InitializerState storage s = _getInitializerSlot();\\n    require(\\n      !s._initializing && s._initialized < version,\\n      \\\"Initializable: contract is already initialized\\\"\\n    );\\n    s._initialized = version;\\n    s._initializing = true;\\n    _;\\n    s._initializing = false;\\n    emit Initialized(version);\\n  }\\n\\n  /**\\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n   * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n   */\\n  modifier onlyInitializing() {\\n    InitializerState storage s = _getInitializerSlot();\\n    require(s._initializing, \\\"Initializable: contract is not initializing\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n   * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n   * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n   * through proxies.\\n   */\\n  function _disableInitializers() internal virtual {\\n    InitializerState storage s = _getInitializerSlot();\\n    require(!s._initializing, \\\"Initializable: contract is initializing\\\");\\n    if (s._initialized < type(uint8).max) {\\n      s._initialized = type(uint8).max;\\n      emit Initialized(type(uint8).max);\\n    }\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"clones-with-immutable-args/=lib/clones-with-immutable-args/src/\",\r\n      \"create2-clones-with-immutable-args/=lib/create2-clones-with-immutable-args/src/\",\r\n      \"create2-helpers/=lib/create2-clones-with-immutable-args/lib/create2-helpers/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"eip4626/=lib/foundry_eip-4626/src/\",\r\n      \"gpl/=lib/gpl/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"seaport/=lib/seaport/contracts/\",\r\n      \"seaport-core/=lib/seaport-core/\",\r\n      \"seaport-types/=lib/seaport-types/\",\r\n      \"seaport-sol/=lib/seaport-sol/\",\r\n      \"murky/=lib/murky/src/\",\r\n      \"core/=src/\",\r\n      \"@openzeppelin/=lib/seaport/lib/openzeppelin-contracts/\",\r\n      \"@rari-capital/solmate/=lib/seaport/lib/solmate/\",\r\n      \"auction/=lib/gpl/lib/auction-house/src/\",\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/seaport/lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"openzeppelin-contracts/=lib/seaport/lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/gpl/lib/openzeppelin-contracts/contracts/\",\r\n      \"solady/=lib/solady/\",\r\n      \"solarray/=lib/seaport/lib/solarray/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_WETH9\",\"type\":\"address\"},{\"internalType\":\"contract ICollateralToken\",\"name\":\"_CT\",\"type\":\"address\"},{\"internalType\":\"contract ILocker\",\"name\":\"_LOCKER\",\"type\":\"address\"},{\"internalType\":\"contract IAstariaRouter\",\"name\":\"_ROUTER\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CT\",\"outputs\":[{\"internalType\":\"contract ICollateralToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LOCKER\",\"outputs\":[{\"internalType\":\"contract ILocker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROUTER\",\"outputs\":[{\"internalType\":\"contract IAstariaRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"vault\",\"type\":\"address\"}],\"internalType\":\"struct IAstariaRouter.StrategyDetailsParam\",\"name\":\"strategy\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"nlrDetails\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct IAstariaRouter.NewLienRequest\",\"name\":\"newLienRequest\",\"type\":\"tuple\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ERC20BorrowHelper", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000006112d87127847202151b9fe48ea0e2704fa428a10000000000000000000000006b4bf007668b784f7a786abbffca62ad283787de00000000000000000000000042cdc5d4b05e8dacc2fcd181cbe0cc86ee14c439", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}