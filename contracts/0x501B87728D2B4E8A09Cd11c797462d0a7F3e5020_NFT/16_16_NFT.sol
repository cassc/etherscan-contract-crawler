// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "./ILocker.sol";

contract NFT is ERC721Enumerable, Ownable {
    using Counters for Counters.Counter;

    string private _baseTokenURI;
    uint256 public constant TOTAL_NUMBER_NFTS = 3200;
    uint256 public constant PRICE_WEI = 3e16; // 0.03 Eth
    uint8 public constant BOOSTER_SIZE = 5;
    uint256 public constant DISCOUNT_ON_BOOSTER = PRICE_WEI;
    bool public saleStarted = false;
    bool public saleNotEnded = true;
    Counters.Counter private _tokenIdTracker;
    ILocker public lockerContract;
    mapping(uint256 => bool) public registered;
    bool public registrationPeriodOngoing = true;

    /**
     * @dev Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    constructor(
        string memory name,
        string memory symbol,
        string memory baseTokenURI
    ) ERC721(name, symbol) {
        _baseTokenURI = baseTokenURI;
    }

    function mint(uint256 amount) external payable {
        uint256 discount = (amount / BOOSTER_SIZE) * DISCOUNT_ON_BOOSTER;
        require(PRICE_WEI * amount - discount <= msg.value, "Pay more");
        require(saleStarted, "!started");
        require(saleNotEnded, "Sale ended");
        require(TOTAL_NUMBER_NFTS - totalSupply() >= amount, "Overminted");

        for (uint256 i = 0; i < amount; i++) {
            _safeMint(msg.sender, _tokenIdTracker.current());
            _tokenIdTracker.increment();
        }

        if (TOTAL_NUMBER_NFTS <= totalSupply()) {
            _endSale();
        }
    }

    /**
     * @dev Hook that is called before any token transfer. This includes minting
     * and burning.
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual override {
        super._beforeTokenTransfer(from, to, tokenId);
        require(
            address(lockerContract) == address(0) ||
                !lockerContract.isLocked(tokenId),
            "NFT locked"
        );
    }

    /**
     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
     * token will be the concatenation of the `baseURI` and the `tokenId`.
     */
    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    function setBaseURI(string memory baseURI) public onlyOwner {
        _baseTokenURI = baseURI;
    }

    function setLockerContract(address lockerContractAddress)
        external
        onlyOwner
    {
        lockerContract = ILocker(lockerContractAddress);
    }

    function startSale() external onlyOwner {
        saleStarted = true;
    }

    function endSale() external onlyOwner {
        _endSale();
    }

    function distributeSaleRevenue() external onlyOwner {
        payable(owner()).transfer(address(this).balance);
    }

    function _endSale() internal {
        saleNotEnded = false;
    }

    function register(uint256 tokenId) external {
        require(registrationPeriodOngoing, "Registration closed");
        require(_exists(tokenId), "reg: nonexistent token");
        registered[tokenId] = true;
    }

    function closeRegistration() external onlyOwner {
        registrationPeriodOngoing = false;
    }
}