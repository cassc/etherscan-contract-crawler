{"SourceCode": "//SPDX-License-Identifier: MIT\r\n// File: contracts/impl/OwnableView.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract OwnableView {\r\n\r\n    bytes32 internal constant OWNER_KEY = 0xdc6edb7e21c7d6802c30a4249460696aa4c6ef3b5aee9c59996f8fedc7fbaefe;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owner(), \"Unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function _owner() internal view returns (address value) {\r\n        assembly {\r\n            value := sload(OWNER_KEY)\r\n        }\r\n    }\r\n}\r\n// File: contracts/model/IOwnable.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IOwnable {\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function renounceOwnership() external;\r\n\r\n    function transferOwnership(address newOwner) external;\r\n}\r\n// File: contracts/impl/Ownable.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\nabstract contract Ownable is IOwnable, OwnableView {\r\n\r\n    constructor(address initialOwner) {\r\n        _transferOwnership(initialOwner);\r\n    }\r\n\r\n    function owner() override external view returns (address) {\r\n        return _owner();\r\n    }\r\n\r\n    function renounceOwnership() override external onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) override external onlyOwner {\r\n        require(newOwner != address(0), \"Invalid\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) private {\r\n        address oldOwner = _owner();\r\n        assembly {\r\n            sstore(OWNER_KEY, newOwner)\r\n        }\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n// File: contracts/model/IERC20Approve.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20Approve {\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n// File: contracts/vert/uniswapV3/IPoolInitializer.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPoolInitializer {\r\n    function createAndInitializePoolIfNecessary(\r\n        address token0,\r\n        address token1,\r\n        uint24 fee,\r\n        uint160 sqrtPriceX96\r\n    ) external payable returns (address pool);\r\n}\r\n// File: contracts/vert/uniswapV3/IUniswapV3Factory.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IUniswapV3Factory {\r\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\r\n\r\n    event PoolCreated(\r\n        address indexed token0,\r\n        address indexed token1,\r\n        uint24 indexed fee,\r\n        int24 tickSpacing,\r\n        address pool\r\n    );\r\n\r\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\r\n\r\n    function getPool(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 fee\r\n    ) external view returns (address pool);\r\n\r\n    function createPool(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 fee\r\n    ) external returns (address pool);\r\n\r\n    function setOwner(address _owner) external;\r\n\r\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\r\n}\r\n// File: contracts/vert/uniswapV3/IPeripheryPayments.sol\r\n\r\n//License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPeripheryPayments {\r\n\r\n    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;\r\n\r\n    function refundETH() external payable;\r\n\r\n    function sweepToken(\r\n        address token,\r\n        uint256 amountMinimum,\r\n        address recipient\r\n    ) external payable;\r\n}\r\n\r\n// File: contracts/vert/uniswapV3/IMulticall.sol\r\n\r\n//License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IMulticall {\r\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\r\n}\r\n\r\n// File: contracts/vert/uniswapV3/IPeripheryImmutableState.sol\r\n\r\n//License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPeripheryImmutableState {\r\n    function factory() external view returns (address);\r\n\r\n    function WETH9() external view returns (address);\r\n}\r\n\r\n// File: contracts/vert/uniswapV3/ISwapRouter.sol\r\n\r\n//License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\ninterface ISwapRouter is IMulticall, IPeripheryImmutableState, IPeripheryPayments {\r\n    struct ExactInputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\r\n\r\n    struct ExactInputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n    }\r\n\r\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\r\n\r\n    struct ExactOutputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\r\n\r\n    struct ExactOutputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n    }\r\n\r\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\r\n}\r\n// File: contracts/vert/uniswapV3/INonfungiblePositionManager.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\ninterface INonfungiblePositionManager is IMulticall, IPeripheryImmutableState, IPeripheryPayments {\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n    function positions(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (\r\n            uint96 nonce,\r\n            address operator,\r\n            address token0,\r\n            address token1,\r\n            uint24 fee,\r\n            int24 tickLower,\r\n            int24 tickUpper,\r\n            uint128 liquidity,\r\n            uint256 feeGrowthInside0LastX128,\r\n            uint256 feeGrowthInside1LastX128,\r\n            uint128 tokensOwed0,\r\n            uint128 tokensOwed1\r\n        );\r\n\r\n    struct MintParams {\r\n        address token0;\r\n        address token1;\r\n        uint24 fee;\r\n        int24 tickLower;\r\n        int24 tickUpper;\r\n        uint256 amount0Desired;\r\n        uint256 amount1Desired;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        address recipient;\r\n        uint256 deadline;\r\n    }\r\n\r\n    function mint(MintParams calldata params)\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 tokenId,\r\n            uint128 liquidity,\r\n            uint256 amount0,\r\n            uint256 amount1\r\n        );\r\n\r\n    struct IncreaseLiquidityParams {\r\n        uint256 tokenId;\r\n        uint256 amount0Desired;\r\n        uint256 amount1Desired;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        uint256 deadline;\r\n    }\r\n\r\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\r\n        external\r\n        payable\r\n        returns (\r\n            uint128 liquidity,\r\n            uint256 amount0,\r\n            uint256 amount1\r\n        );\r\n\r\n    struct DecreaseLiquidityParams {\r\n        uint256 tokenId;\r\n        uint128 liquidity;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        uint256 deadline;\r\n    }\r\n\r\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\r\n        external\r\n        payable\r\n        returns (uint256 amount0, uint256 amount1);\r\n\r\n    struct CollectParams {\r\n        uint256 tokenId;\r\n        address recipient;\r\n        uint128 amount0Max;\r\n        uint128 amount1Max;\r\n    }\r\n\r\n    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);\r\n\r\n    function burn(uint256 tokenId) external payable;\r\n}\r\n// File: contracts/vert/UtilitiesLib.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary UtilitiesLib {\r\n    uint256 internal constant AMOUNT_PERCENTAGE = 2e17;\r\n    uint256 internal constant TREASURY_PERCENTAGE = 5e16;\r\n    uint256 internal constant MARKETING_PERCENTAGE = 12e16;\r\n    uint256 internal constant BOOTSTRAP_PERCENTAGE = 13e16;\r\n    uint256 internal constant REVENUE_SHARE_PERCENTAGE = 1e17;\r\n    uint256 internal constant ANTI_WHALE_MAX_BALANCE = 1500000e18;\r\n    uint256 internal constant ANTI_WHALE_MAX_TRANSFER = 750000e18;\r\n}\r\n// File: @ethereansos/farming-base/contracts/BaseFarming.sol\r\n\r\n///License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20Token {\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function transfer(address to, uint value) external returns (bool);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n}\r\n\r\ninterface IFarmingLiquidityProvider {\r\n    function totalFarmingLiquidity() external view returns(uint256);\r\n    function setNextRebalanceEvent(uint256 nextRebalanceEvent) external;\r\n}\r\n\r\ncontract BaseFarming {\r\n    using SafeMath for uint256;\r\n\r\n    struct FarmingPosition {\r\n        uint256 rewardTokenToRedeem;\r\n        uint256 rewardPerTokenPaid;\r\n        uint256 lastLiquidityBalance;\r\n    }\r\n\r\n    uint256 public constant FULL_PRECISION = 1e18;\r\n    uint256 public constant TIME_SLOT_IN_SECONDS = 15;\r\n\r\n    address public farmingLiquidityProvider;\r\n    address public rewardToken;\r\n    uint256 public rebalanceIntervalInEventSlots;\r\n    uint256 public startEvent;\r\n    uint256 public lastUpdateEvent;\r\n    uint256 public nextRebalanceEvent;\r\n\r\n    uint256 private _rewardPerEvent;\r\n    uint256 private _rewardPerTokenStored;\r\n    uint256 private _reservedBalance;\r\n    uint256 private _previousLiquidityPoolTotalSupply;\r\n\r\n    bool internal _resetOnly;\r\n    bool internal _inhibitCallback;\r\n\r\n    uint256 public totalFarmingLiquidity;\r\n\r\n    mapping(address => FarmingPosition) private _positions;\r\n\r\n    /// @notice Get the reward per event for the current season\r\n    /// divided by the farming additional precision\r\n    function rewardPerEvent() public view returns(uint256) {\r\n        return _rewardPerEvent / FULL_PRECISION;\r\n    }\r\n\r\n    /// @notice Get the reserved balance for the current season\r\n    /// divided by the farming additional precision\r\n    function reservedBalance() public view returns(uint256) {\r\n        return _reservedBalance / FULL_PRECISION;\r\n    }\r\n\r\n    function _increaseReservedBalance(uint256 amount) internal {\r\n        _reservedBalance = _reservedBalance.add(amount * FULL_PRECISION);\r\n    }\r\n\r\n    function _decreaseReservedBalance(uint256 amount) internal {\r\n        _reservedBalance = _reservedBalance.sub(amount * FULL_PRECISION);\r\n    }\r\n\r\n    function calculateIfThereIsMoreReward() external view returns(uint256 seasonReward) {\r\n        return _calculateIfThereIsMoreReward(_resetOnly);\r\n    }\r\n\r\n    function _claimReward(address account, address[] memory rewardReceivers, uint256[] memory rewardReceiversPercentage) internal returns(uint256 claimedReward, uint256 _nextRebalanceEvent, uint256 rewardPerEvent_) {\r\n        uint lastLiquidityBalance = _positions[account].lastLiquidityBalance;\r\n        (_nextRebalanceEvent, rewardPerEvent_) = _tryRebalance(_totalSupply(), lastLiquidityBalance == 0, false);\r\n        claimedReward = _syncPosition(\r\n            account,\r\n            lastLiquidityBalance,\r\n            rewardReceivers,\r\n            rewardReceiversPercentage\r\n        );\r\n    }\r\n\r\n    /// @notice Sync positions and try to rebalance and start farming seasons\r\n    function _sync(\r\n        address from,\r\n        address to,\r\n        uint256 fromLiquidityPoolTokenBalance,\r\n        uint256 toLiquidityPoolTokenBalance,\r\n        uint256 liquidityPoolTotalSupply\r\n    ) internal returns(uint256 _nextRebalanceEvent) {\r\n\r\n        (_nextRebalanceEvent,) = _tryRebalance(liquidityPoolTotalSupply, false, false);\r\n\r\n        address[] memory voidRewardReceivers = new address[](0);\r\n        uint256[] memory voidRewardReceiversPercentage = new uint256[](0);\r\n\r\n        if (from != address(0)) _syncPosition(from, fromLiquidityPoolTokenBalance, voidRewardReceivers, voidRewardReceiversPercentage);\r\n        if (to != address(0)) _syncPosition(to, toLiquidityPoolTokenBalance, voidRewardReceivers, voidRewardReceiversPercentage);\r\n    }\r\n\r\n    /// @notice Start and stop the farming perpetual seasons. If the season is started compute the _rewardPerTokenStored\r\n    /// @param _nextRebalanceEvent is updated after season is started (or stopped)\r\n    /// @param rewardPerEvent_ is returned in his correct precision, so is divided by PRECISION\r\n    function _tryRebalance(uint256 liquidityPoolTotalSupply, bool inhibit, bool reset) internal returns(uint256 _nextRebalanceEvent, uint256 rewardPerEvent_) {\r\n        /// @dev Gas savings for Optimism L1 blocks static call\r\n        /// and variables that are loaded from storage\r\n        uint256 blockEventstamp = block.timestamp;\r\n        uint256 previousLiquidityPoolTotalSupply = _previousLiquidityPoolTotalSupply;\r\n        uint256 _startEvent = startEvent;\r\n        uint256 _lastUpdateEvent = lastUpdateEvent;\r\n\r\n        /// @dev Gas savings reusing output variables\r\n        _nextRebalanceEvent = nextRebalanceEvent;\r\n        rewardPerEvent_ = _rewardPerEvent;\r\n\r\n        /// @notice Compute the rewards for the time interval (if the season is started)\r\n        if(_nextRebalanceEvent != 0) {\r\n            uint256 currentEvent = blockEventstamp < _nextRebalanceEvent ? blockEventstamp : _nextRebalanceEvent;\r\n\r\n            /// @dev Inhibit the _rewardPerTokenStored update when inhibit variable is true.\r\n            /// This is used for bypass incorrect _rewardPerTokenStored updates in the _tryRebalance function.\r\n            if(!inhibit && previousLiquidityPoolTotalSupply != 0) {\r\n                uint256 computedLastUpdateEvent = _lastUpdateEvent < _startEvent ? _startEvent : _lastUpdateEvent;\r\n                _rewardPerTokenStored = _rewardPerTokenStored.add(((((currentEvent.sub(computedLastUpdateEvent)))).mul(rewardPerEvent_)) / previousLiquidityPoolTotalSupply);\r\n                lastUpdateEvent = currentEvent;\r\n            }\r\n        }\r\n\r\n        _previousLiquidityPoolTotalSupply = liquidityPoolTotalSupply;\r\n\r\n        /// @notice Start (or stop) the new season\r\n        if(reset || blockEventstamp >= _nextRebalanceEvent || liquidityPoolTotalSupply == 0) {\r\n            uint256 reservedBalance_ = _reservedBalance;\r\n\r\n            if (_nextRebalanceEvent > blockEventstamp) {\r\n                reservedBalance_ = reservedBalance_.sub((((_nextRebalanceEvent.sub(blockEventstamp))).mul(rewardPerEvent_)));\r\n            }\r\n\r\n            /// @dev Using lastUpdateEvent storage variable to store the value\r\n            lastUpdateEvent = 0;\r\n\r\n            /// @dev Gas savings using memory variables\r\n            _startEvent = 0;\r\n            _nextRebalanceEvent = 0;\r\n            rewardPerEvent_ = 0;\r\n\r\n            uint256 seasonReward = _calculateIfThereIsMoreReward(reset);\r\n\r\n            /// @notice Update the _nextRebalanceEvent, _rewardPerEvent, _reservedBalance\r\n            /// for the new starting season\r\n            if(seasonReward > 0 && liquidityPoolTotalSupply != 0) {\r\n                uint256 _rebalanceIntervalInEvents = rebalanceIntervalInEventSlots.mul(TIME_SLOT_IN_SECONDS);\r\n\r\n                _startEvent = blockEventstamp;\r\n                reservedBalance_ = reservedBalance_.add(seasonReward);\r\n                _nextRebalanceEvent = blockEventstamp.add(_rebalanceIntervalInEvents);\r\n                rewardPerEvent_ = seasonReward / _rebalanceIntervalInEvents;\r\n            }\r\n\r\n            /// @dev Update storage output variables after changing values\r\n            startEvent = _startEvent;\r\n            _reservedBalance = reservedBalance_;\r\n            nextRebalanceEvent = _nextRebalanceEvent;\r\n            _rewardPerEvent = rewardPerEvent_;\r\n\r\n            _tryNotifyNewRebalanceEvent(_nextRebalanceEvent);\r\n\r\n        }\r\n\r\n        /// @notice Output variables\r\n        /// _rewardPerEvent is returned in his correct precision, so is divided by PRECISION\r\n        /// nextRebalanceEvent is updated after season is started (or stopped)\r\n        rewardPerEvent_ = rewardPerEvent_ / FULL_PRECISION;\r\n\r\n    }\r\n\r\n    /// @notice Calculate the reward for the `account` position\r\n    function _calculateRewardUntilNow(address account) private view returns(uint256 reward) {\r\n        reward = (_rewardPerTokenStored.sub(_positions[account].rewardPerTokenPaid)).mul(_positions[account].lastLiquidityBalance);\r\n    }\r\n\r\n    /// @notice Sync `account` position and eventually claim the accrued reward\r\n    function _syncPosition(address account, uint256 liquidityPoolTokenBalance, address[] memory rewardReceivers, uint256[] memory rewardReceiversPercentage) private returns (uint256 claimedReward) {\r\n        FarmingPosition memory position = _positions[account];\r\n\r\n        /// @dev Inline definitions for gas savings\r\n        position.rewardTokenToRedeem = position.rewardTokenToRedeem.add(_calculateRewardUntilNow(account));\r\n        position.lastLiquidityBalance = liquidityPoolTokenBalance;\r\n        position.rewardPerTokenPaid = _rewardPerTokenStored;\r\n\r\n        /// @dev Claim the accrued reward\r\n        if (_checkRewardParameters(rewardReceivers, rewardReceiversPercentage)) {\r\n            /// @dev claimedReward is divided by PRECISION to transfer the correct amount\r\n            claimedReward = position.rewardTokenToRedeem / FULL_PRECISION;\r\n\r\n            if (claimedReward > 0) {\r\n                uint256 rebuiltReward;\r\n                /// @dev Decrement accrued reward (rebuiltReward) from _reservedBalance and position.rewardTokenToRedeem in 10**18 precision\r\n                _reservedBalance = _reservedBalance.sub(rebuiltReward = claimedReward.mul(FULL_PRECISION));\r\n                position.rewardTokenToRedeem = position.rewardTokenToRedeem.sub(rebuiltReward);\r\n\r\n                /// @dev Send reward tokens to the reward receivers\r\n                _transferReward(claimedReward, rewardReceivers, rewardReceiversPercentage);\r\n            }\r\n        }\r\n\r\n        /// @dev Reassign memory position to storage _positions\r\n        _positions[account] = position;\r\n    }\r\n\r\n    function _transferReward(uint256 claimedReward, address[] memory rewardReceivers, uint256[] memory rewardReceiversPercentage) private {\r\n        address _rewardToken = rewardToken;\r\n        uint256 remainingAmount = claimedReward;\r\n        for(uint256 i = 0; i < rewardReceiversPercentage.length; i++) {\r\n            uint256 value = _calculatePercentage(claimedReward, rewardReceiversPercentage[i]);\r\n            _safeTransfer(_rewardToken, rewardReceivers[i], value);\r\n            remainingAmount -= value;\r\n        }\r\n        _safeTransfer(_rewardToken, rewardReceivers[rewardReceivers.length - 1], remainingAmount);\r\n    }\r\n\r\n    function _checkRewardParameters(address[] memory rewardReceivers, uint256[] memory rewardReceiversPercentage) private pure returns(bool) {\r\n        if(rewardReceivers.length == 0) {\r\n            return false;\r\n        }\r\n        require(rewardReceiversPercentage.length == (rewardReceivers.length - 1), \"percentage\");\r\n        uint256 availableAmount = FULL_PRECISION;\r\n        for(uint256 i = 0; i < rewardReceiversPercentage.length; i++) {\r\n            uint256 percentage = rewardReceiversPercentage[i];\r\n            require(percentage != 0 && percentage < availableAmount, \"percentage\");\r\n            availableAmount -= percentage;\r\n        }\r\n        require(availableAmount != 0, \"percentage\");\r\n        return true;\r\n    }\r\n\r\n    function _calculatePercentage(uint256 total, uint256 percentage) internal pure returns (uint256) {\r\n        return (total * ((percentage * 1e18) / FULL_PRECISION)) / 1e18;\r\n    }\r\n\r\n    function _safeTransfer(address tokenAddress, address to, uint256 value) internal {\r\n        if(value == 0) {\r\n            return;\r\n        }\r\n        if(to == address(this)) {\r\n            return;\r\n        }\r\n        if(tokenAddress == address(0)) {\r\n            require(_sendETH(to, value), 'FARMING: TRANSFER_FAILED');\r\n            return;\r\n        }\r\n        if(to == address(0)) {\r\n            return _safeBurn(tokenAddress, value);\r\n        }\r\n        (bool success, bytes memory data) = tokenAddress.call(abi.encodeWithSelector(IERC20Token(address(0)).transfer.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'FARMING: TRANSFER_FAILED');\r\n    }\r\n\r\n    function _safeBurn(address erc20TokenAddress, uint256 value) internal {\r\n        (bool result, bytes memory returnData) = erc20TokenAddress.call(abi.encodeWithSelector(0x42966c68, value));//burn(uint256)\r\n        result = result && (returnData.length == 0 || abi.decode(returnData, (bool)));\r\n        if(!result) {\r\n            (result, returnData) = erc20TokenAddress.call(abi.encodeWithSelector(IERC20Token(erc20TokenAddress).transfer.selector, address(0), value));\r\n            result = result && (returnData.length == 0 || abi.decode(returnData, (bool)));\r\n        }\r\n        if(!result) {\r\n            (result, returnData) = erc20TokenAddress.call(abi.encodeWithSelector(IERC20Token(erc20TokenAddress).transfer.selector, 0x000000000000000000000000000000000000dEaD, value));\r\n            result = result && (returnData.length == 0 || abi.decode(returnData, (bool)));\r\n        }\r\n        if(!result) {\r\n            (result, returnData) = erc20TokenAddress.call(abi.encodeWithSelector(IERC20Token(erc20TokenAddress).transfer.selector, 0xdeaDDeADDEaDdeaDdEAddEADDEAdDeadDEADDEaD, value));\r\n            result = result && (returnData.length == 0 || abi.decode(returnData, (bool)));\r\n        }\r\n    }\r\n\r\n    function _sendETH(address to, uint256 value) private returns(bool) {\r\n        assembly {\r\n            let res := call(gas(), to, value, 0, 0, 0, 0)\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _balanceOf(address tokenAddress) private view returns(uint256) {\r\n        return tokenAddress == address(0) ? address(this).balance : IERC20Token(tokenAddress).balanceOf(address(this));\r\n    }\r\n\r\n    function _tryNotifyNewRebalanceEvent(uint256 _nextRebalanceEvent) private {\r\n        if(_inhibitCallback) {\r\n            return;\r\n        }\r\n        /// @dev Gas savings to avoid multiple storage loads\r\n        address _farmingLiquidityProvider = farmingLiquidityProvider;\r\n\r\n        /// @notice Set the new _nextRebalanceEvent to the farmingliquidityprovider if the caller is not the farmingliquidityprovider\r\n        if(msg.sender != _farmingLiquidityProvider) {\r\n            IFarmingLiquidityProvider(_farmingLiquidityProvider).setNextRebalanceEvent(_nextRebalanceEvent);\r\n        }\r\n    }\r\n\r\n    function _totalSupply() internal view returns(uint256) {\r\n        address _farmingLiquidityProvider = farmingLiquidityProvider;\r\n        return _farmingLiquidityProvider == address(this) ? totalFarmingLiquidity : IFarmingLiquidityProvider(_farmingLiquidityProvider).totalFarmingLiquidity();\r\n    }\r\n\r\n    function _calculateIfThereIsMoreReward(bool reset) private view returns(uint256 seasonReward) {\r\n        seasonReward = _resetOnly && !reset ? 0 : (_balanceOf(rewardToken).mul(FULL_PRECISION)).sub(_reservedBalance);\r\n    }\r\n\r\n    function _initialize(address _farmingLiquidityProvider, uint256 _rebalanceIntervalInEvents) internal {\r\n        require(farmingLiquidityProvider == address(0), 'Farming: ALREADY_INITIALIZED');\r\n        require((farmingLiquidityProvider =_farmingLiquidityProvider) != address(0), 'Farming: LIQUIDITY_PROVIDER');\r\n        rebalanceIntervalInEventSlots = _rebalanceIntervalInEvents / TIME_SLOT_IN_SECONDS;\r\n    }\r\n\r\n    function _receive() internal view {\r\n        require(rewardToken == address(0));\r\n        require(msg.sig == bytes4(0));\r\n        require(keccak256(msg.data) == keccak256(\"\"));\r\n    }\r\n}\r\n// File: contracts/vert/IVestingContract.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IVestingContract {\r\n    function completeInitialization() external;\r\n}\r\n// File: contracts/vert/ITreasuryBootstrapRevenueShare.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface ITreasuryBootstrapRevenueShare {\r\n    function completeInitialization(address treasuryAddress) external returns(address operatorAddress);\r\n    function setTreasuryAddress(address newValue) external returns(address oldValue);\r\n    function updatePositionOf(address account, uint256 amount, uint256 vestedAmount) external payable;\r\n    function finalizePosition(uint256 treasuryBalance, uint256 additionalLiquidity, uint256 vestingEnds) external payable;\r\n}\r\n// File: contracts/vert/TreasuryBootstrapRevenueShare.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary TreasuryBootstrapRevenueShareLib {\r\n\r\n    function collectFees(bytes memory conversionInput, address uniswapV3NonfungiblePositionsManager, address token, address WETH, uint256 tokenId, address conversionAddress, uint24 fee, address uniswapV3SwapRouter) external returns(uint256 collectedAmount0, uint256 collectedAmount1, bytes memory conversionOutput) {\r\n        bytes[] memory data = new bytes[](3);\r\n        INonfungiblePositionManager nonfungiblePositionManager = INonfungiblePositionManager(uniswapV3NonfungiblePositionsManager);\r\n        data[0] = abi.encodeWithSelector(nonfungiblePositionManager.collect.selector, INonfungiblePositionManager.CollectParams({\r\n            tokenId: tokenId,\r\n            recipient: address(0),\r\n            amount0Max: 0xffffffffffffffffffffffffffffffff,\r\n            amount1Max: 0xffffffffffffffffffffffffffffffff\r\n        }));\r\n        data[1] = abi.encodeWithSelector(nonfungiblePositionManager.unwrapWETH9.selector, 0, address(this));\r\n        data[2] = abi.encodeWithSelector(nonfungiblePositionManager.sweepToken.selector, token, 0, conversionAddress != address(0) ? conversionAddress : address(this));\r\n        (collectedAmount0, collectedAmount1) = abi.decode(IMulticall(uniswapV3NonfungiblePositionsManager).multicall(data)[0], (uint256, uint256));\r\n\r\n        uint256 amount = token < WETH ? collectedAmount0 : collectedAmount1;\r\n\r\n        if(amount > 0) {\r\n            conversionOutput = _convertAmountInETH(amount, conversionInput, token, WETH, conversionAddress, fee, uniswapV3SwapRouter);\r\n        }\r\n    }\r\n\r\n    function _convertAmountInETH(uint256 amount, bytes memory conversionInput, address token, address WETH, address conversionAddress, uint24 fee, address uniswapV3SwapRouter) private returns(bytes memory conversionOutput) {\r\n\r\n        if(conversionAddress != address(0)) {\r\n            uint256 codeLength;\r\n            assembly {\r\n                codeLength := extcodesize(conversionAddress)\r\n            }\r\n            if(codeLength > 0) {\r\n                return IConvertInETH(conversionAddress).convert(token, amount, conversionInput);\r\n            } else {\r\n                return \"\";\r\n            }\r\n        }\r\n\r\n        (uint24 _fee, uint256 amountOutMinimum) = abi.decode(conversionInput, (uint24, uint256));\r\n\r\n        ISwapRouter swapRouter = ISwapRouter(uniswapV3SwapRouter);\r\n\r\n        IERC20Approve(token).approve(address(swapRouter), amount);\r\n\r\n        bytes[] memory data = new bytes[](2);\r\n        data[0] = abi.encodeWithSelector(swapRouter.exactInput.selector, ISwapRouter.ExactInputParams({\r\n            path : abi.encodePacked(token, _fee == 0 ? fee : _fee, WETH),\r\n            recipient : address(0),\r\n            deadline : block.timestamp + 10000,\r\n            amountIn : amount,\r\n            amountOutMinimum : amountOutMinimum\r\n        }));\r\n        data[1] = abi.encodeWithSelector(swapRouter.unwrapWETH9.selector, 0, address(this));\r\n        conversionOutput = swapRouter.multicall(data)[0];\r\n    }\r\n\r\n    function _safeTransfer(address tokenAddress, address to, uint256 value) internal {\r\n        if(value == 0) {\r\n            return;\r\n        }\r\n        if(to == address(this)) {\r\n            return;\r\n        }\r\n        if(tokenAddress == address(0)) {\r\n            require(_sendETH(to, value), 'FARMING: TRANSFER_FAILED');\r\n            return;\r\n        }\r\n        if(to == address(0)) {\r\n            return _safeBurn(tokenAddress, value);\r\n        }\r\n        (bool success, bytes memory data) = tokenAddress.call(abi.encodeWithSelector(IERC20Token(address(0)).transfer.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'FARMING: TRANSFER_FAILED');\r\n    }\r\n\r\n    function _safeBurn(address erc20TokenAddress, uint256 value) internal {\r\n        (bool result, bytes memory returnData) = erc20TokenAddress.call(abi.encodeWithSelector(0x42966c68, value));//burn(uint256)\r\n        result = result && (returnData.length == 0 || abi.decode(returnData, (bool)));\r\n        if(!result) {\r\n            (result, returnData) = erc20TokenAddress.call(abi.encodeWithSelector(IERC20Token(erc20TokenAddress).transfer.selector, address(0), value));\r\n            result = result && (returnData.length == 0 || abi.decode(returnData, (bool)));\r\n        }\r\n        if(!result) {\r\n            (result, returnData) = erc20TokenAddress.call(abi.encodeWithSelector(IERC20Token(erc20TokenAddress).transfer.selector, 0x000000000000000000000000000000000000dEaD, value));\r\n            result = result && (returnData.length == 0 || abi.decode(returnData, (bool)));\r\n        }\r\n        if(!result) {\r\n            (result, returnData) = erc20TokenAddress.call(abi.encodeWithSelector(IERC20Token(erc20TokenAddress).transfer.selector, 0xdeaDDeADDEaDdeaDdEAddEADDEAdDeadDEADDEaD, value));\r\n            result = result && (returnData.length == 0 || abi.decode(returnData, (bool)));\r\n        }\r\n    }\r\n\r\n    function _sendETH(address to, uint256 value) private returns(bool) {\r\n        assembly {\r\n            let res := call(gas(), to, value, 0, 0, 0, 0)\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract TreasuryBootstrapRevenueShare is ITreasuryBootstrapRevenueShare, Ownable, BaseFarming {\r\n\r\n    uint256 public constant MONTH_IN_SECONDS = 2628000;\r\n\r\n    struct AccountPosition {\r\n        uint256 vestedAmount;\r\n        uint256 ethAmount;\r\n        uint128 positionLiquidity;\r\n        uint256 farmingBalance;\r\n    }\r\n    uint256 public accounts;\r\n\r\n    address public immutable destinationAddress;\r\n    address public immutable uniswapV3NonfungiblePositionsManager;\r\n    address public immutable uniswapV3SwapRouter;\r\n    address public immutable WETH;\r\n\r\n    address public pool;\r\n\r\n    uint24 public immutable fee;\r\n    uint160 public immutable sqrtPriceX96;\r\n    int24 public tickLower;\r\n    int24 public tickUpper;\r\n    uint256 public vestingEnds;\r\n    uint256 public priceSlippagePercentage;\r\n\r\n    mapping(address => AccountPosition) public positionOf;\r\n\r\n    uint256 public farmingDuration;\r\n\r\n    address public token;\r\n\r\n    address public treasuryAddress;\r\n\r\n    uint256 public treasuryFarmingBalance;\r\n\r\n    uint256 public tokenId;\r\n\r\n    address public conversionAddress;\r\n\r\n    uint256 public redeemableETH;\r\n\r\n    constructor(address initialOwner, address _destinationAddress, address _conversionAddress, uint256 _farmingDuration, address _uniswapV3NonfungiblePositionsManager, address _uniswapV3SwapRouter, uint24 _fee, uint160 _sqrtPriceX96, uint256 _priceSlippagePercentage, int24 _tickLower, int24 _tickUpper) Ownable(initialOwner) {\r\n        _inhibitCallback = true;\r\n        _initialize(address(this), MONTH_IN_SECONDS * (farmingDuration = _farmingDuration));\r\n        destinationAddress = _destinationAddress;\r\n        conversionAddress = _conversionAddress;\r\n        WETH = IPeripheryImmutableState(uniswapV3NonfungiblePositionsManager = _uniswapV3NonfungiblePositionsManager).WETH9();\r\n        uniswapV3SwapRouter = _uniswapV3SwapRouter;\r\n        tickLower = _tickLower;\r\n        tickUpper = _tickUpper;\r\n        fee = _fee;\r\n        sqrtPriceX96 = _sqrtPriceX96;\r\n        priceSlippagePercentage = _priceSlippagePercentage;\r\n    }\r\n\r\n    receive() external payable {\r\n        _receive();\r\n    }\r\n\r\n    function onERC721Received(address,address,uint256,bytes calldata) external view returns (bytes4) {\r\n        require(tokenId == 0);\r\n        return this.onERC721Received.selector;\r\n    }\r\n\r\n    function setPriceSlippagePercentage(uint256 newValue) external onlyOwner {\r\n        priceSlippagePercentage = newValue;\r\n    }\r\n\r\n    function setConversionAddress(address newValue) external onlyOwner returns(address oldValue) {\r\n        oldValue = conversionAddress;\r\n        conversionAddress = newValue;\r\n    }\r\n\r\n    function completeInitialization(address _treasuryAddress) override external returns(address operatorAddress) {\r\n        require(token == address(0));\r\n        treasuryAddress = _treasuryAddress;\r\n        uint256 tokenPosition = (token = msg.sender) < WETH ? 0 : 1;\r\n        return pool = IPoolInitializer(uniswapV3NonfungiblePositionsManager).createAndInitializePoolIfNecessary(\r\n            tokenPosition == 0 ? msg.sender : WETH,\r\n            tokenPosition == 1 ? msg.sender : WETH,\r\n            fee,\r\n            sqrtPriceX96\r\n        );\r\n    }\r\n\r\n    function updatePositionOf(address account, uint256 amount, uint256 vestedAmount) override external payable {\r\n\r\n        require(msg.sender == token);\r\n\r\n        _increaseReservedBalance(msg.value);\r\n        redeemableETH += msg.value;\r\n\r\n        AccountPosition storage _accountPosition = positionOf[account];\r\n        if(_accountPosition.ethAmount == 0) {\r\n            accounts++;\r\n        }\r\n\r\n        _accountPosition.ethAmount += msg.value;\r\n\r\n        (uint128 liquidity, uint256 remainingAmount) = _mintOrIncreaseLiquidity(amount);\r\n\r\n        amount += vestedAmount;\r\n\r\n        _accountPosition.vestedAmount += vestedAmount + remainingAmount;\r\n        _accountPosition.positionLiquidity += liquidity;\r\n\r\n        _accountPosition.farmingBalance += amount;\r\n        totalFarmingLiquidity += amount;\r\n        require(_accountPosition.farmingBalance <= UtilitiesLib.ANTI_WHALE_MAX_BALANCE, \"Anti-whale system active\");\r\n\r\n        _sync(address(0), account, 0, _accountPosition.farmingBalance, totalFarmingLiquidity);\r\n    }\r\n\r\n    function finalizePosition(uint256 treasuryBalance, uint256 additionalLiquidity, uint256 _vestingEnds) external payable {\r\n        require(msg.sender == token);\r\n        vestingEnds = _vestingEnds;\r\n        (,uint256 remainingAmount) = _mintOrIncreaseLiquidity(treasuryBalance + additionalLiquidity);\r\n        if(remainingAmount > 0) {\r\n            _safeBurn(token, remainingAmount);\r\n        }\r\n\r\n        treasuryFarmingBalance += treasuryBalance;\r\n        totalFarmingLiquidity += treasuryBalance;\r\n        address[] memory rewardReceivers = new address[](1);\r\n        _sync(address(0), rewardReceivers[0] = treasuryAddress, 0, treasuryFarmingBalance, totalFarmingLiquidity);\r\n        _claimReward(rewardReceivers[0], rewardReceivers, new uint256[](0));\r\n    }\r\n\r\n    function redeemVestingResult() external {\r\n        AccountPosition storage _accountPosition = positionOf[msg.sender];\r\n        uint256 vestedAmount = _accountPosition.vestedAmount;\r\n        uint256 ethAmount = _accountPosition.ethAmount;\r\n        require(vestedAmount != 0 && ethAmount != 0, \"unknown account\");\r\n        _accountPosition.vestedAmount = 0;\r\n        _accountPosition.ethAmount = 0;\r\n        address[] memory rewardReceivers = new address[](1);\r\n        if(vestingEnds == 0 || block.timestamp < vestingEnds) {\r\n            _decreaseReservedBalance(ethAmount);\r\n            redeemableETH -= ethAmount;\r\n            _safeTransfer(address(0), msg.sender, ethAmount);\r\n            _safeBurn(token, vestedAmount);\r\n            totalFarmingLiquidity -= _accountPosition.farmingBalance;\r\n            _sync(msg.sender, address(0), _accountPosition.farmingBalance = 0, 0, totalFarmingLiquidity);\r\n            rewardReceivers[0] = treasuryAddress;\r\n            delete positionOf[msg.sender];\r\n            accounts--;\r\n        } else {\r\n            _safeTransfer(token, rewardReceivers[0] = msg.sender, vestedAmount);\r\n            sendRemainingETH();\r\n        }\r\n        _claimReward(msg.sender, rewardReceivers, new uint256[](0));\r\n    }\r\n\r\n    modifier afterVestingPeriod() {\r\n        _afterVestingPeriod();\r\n        _;\r\n    }\r\n\r\n    function sendRemainingETH() public afterVestingPeriod {\r\n        _sendRemainingETH();\r\n    }\r\n\r\n    function setTreasuryAddress(address newValue) external afterVestingPeriod returns(address oldValue) {\r\n        require((oldValue = treasuryAddress) == msg.sender, \"unauthorized\");\r\n        treasuryAddress = newValue;\r\n        _sync(oldValue, newValue, 0, treasuryFarmingBalance, totalFarmingLiquidity);\r\n        address[] memory rewardReceivers = new address[](1);\r\n        rewardReceivers[0] = newValue;\r\n        _claimReward(oldValue, rewardReceivers, new uint256[](0));\r\n    }\r\n\r\n    function claimReward(address[] memory rewardReceivers, uint256[] memory rewardReceiversPercentage) external afterVestingPeriod  returns(uint256 claimedReward, uint256 _nextRebalanceEvent, uint256 rewardPerEvent_) {\r\n        return _claimReward(msg.sender, rewardReceivers, rewardReceiversPercentage);\r\n    }\r\n\r\n    function claimRewardOf(address account) external afterVestingPeriod returns(uint256 claimedReward, uint256 _nextRebalanceEvent, uint256 rewardPerEvent_) {\r\n        address[] memory rewardReceivers = new address[](1);\r\n        return _claimReward(rewardReceivers[0] = account, rewardReceivers, new uint256[](0));\r\n    }\r\n\r\n    function redeemRevenueSharePositionForever(uint256 amount0Min, uint256 amount1Min) external afterVestingPeriod returns (uint256 amount0, uint256 amount1) {\r\n        AccountPosition storage _accountPosition = positionOf[msg.sender];\r\n        require(_accountPosition.positionLiquidity != 0, \"unknown account\");\r\n        uint256 vestedAmount = _accountPosition.vestedAmount;\r\n        _accountPosition.vestedAmount = 0;\r\n        _accountPosition.ethAmount = 0;\r\n        if(vestedAmount != 0) {\r\n            _safeTransfer(token, msg.sender, vestedAmount);\r\n        }\r\n        address to = address(0);\r\n        uint256 toBalance = 0;\r\n        if(farmingDuration == 1) {\r\n            to = treasuryAddress;\r\n            treasuryFarmingBalance += _accountPosition.farmingBalance;\r\n            toBalance = treasuryFarmingBalance;\r\n        } else {\r\n            totalFarmingLiquidity -= _accountPosition.farmingBalance;\r\n        }\r\n        _sync(msg.sender, to, _accountPosition.farmingBalance = 0, toBalance, totalFarmingLiquidity);\r\n        address[] memory rewardReceivers = new address[](1);\r\n        rewardReceivers[0] = msg.sender;\r\n        _claimReward(msg.sender, rewardReceivers, new uint256[](0));\r\n\r\n        bytes[] memory data = new bytes[](3);\r\n        INonfungiblePositionManager nonfungiblePositionManager = INonfungiblePositionManager(uniswapV3NonfungiblePositionsManager);\r\n\r\n        (amount0, amount1) = nonfungiblePositionManager.decreaseLiquidity(INonfungiblePositionManager.DecreaseLiquidityParams({\r\n            tokenId: tokenId,\r\n            liquidity: _accountPosition.positionLiquidity,\r\n            amount0Min: amount0Min,\r\n            amount1Min: amount1Min,\r\n            deadline : block.timestamp + 1000\r\n        }));\r\n\r\n        delete positionOf[msg.sender];\r\n        accounts--;\r\n\r\n        data[0] = abi.encodeWithSelector(nonfungiblePositionManager.collect.selector, INonfungiblePositionManager.CollectParams({\r\n            tokenId: tokenId,\r\n            recipient: address(0),\r\n            amount0Max: uint128(amount0),\r\n            amount1Max: uint128(amount1)\r\n        }));\r\n        data[1] = abi.encodeWithSelector(nonfungiblePositionManager.unwrapWETH9.selector, 0, msg.sender);\r\n        data[2] = abi.encodeWithSelector(nonfungiblePositionManager.sweepToken.selector, token, 0, msg.sender);\r\n        (amount0, amount1) = abi.decode(IMulticall(uniswapV3NonfungiblePositionsManager).multicall(data)[0], (uint256, uint256));\r\n    }\r\n\r\n    function collectFees(bytes memory conversionInput) external returns(uint256 collectedAmount0, uint256 collectedAmount1, bytes memory conversionOutput) {\r\n        (collectedAmount0, collectedAmount1, conversionOutput) = TreasuryBootstrapRevenueShareLib.collectFees(conversionInput, uniswapV3NonfungiblePositionsManager, token, WETH, tokenId, conversionAddress, fee, uniswapV3SwapRouter);\r\n        _afterVestingPeriod();\r\n    }\r\n\r\n    function _mintOrIncreaseLiquidity(uint256 amount) private returns(uint128 liquidity, uint256 remainingAmount) {\r\n\r\n        uint256 tokenPosition = token < WETH ? 0 : 1;\r\n\r\n        IERC20Approve(token).approve(uniswapV3NonfungiblePositionsManager, amount);\r\n\r\n        (uint256 amount0, uint256 amount1) = tokenPosition == 0 ? (amount, uint256(0)) : (uint256(0), amount);\r\n\r\n        if(tokenId == 0) {\r\n            (tokenId, liquidity, amount0, amount1) = INonfungiblePositionManager(uniswapV3NonfungiblePositionsManager).mint(INonfungiblePositionManager.MintParams({\r\n                token0: tokenPosition == 0 ? token : WETH,\r\n                token1: tokenPosition == 1 ? token : WETH,\r\n                fee: fee,\r\n                tickLower: tickLower,\r\n                tickUpper: tickUpper,\r\n                amount0Desired: amount0,\r\n                amount1Desired: amount1,\r\n                amount0Min: _calculatePercentage(amount0, FULL_PRECISION - priceSlippagePercentage),\r\n                amount1Min: _calculatePercentage(amount1, FULL_PRECISION - priceSlippagePercentage),\r\n                recipient: address(this),\r\n                deadline: block.timestamp + 10000\r\n            }));\r\n        } else {\r\n            (liquidity, amount0, amount1) = INonfungiblePositionManager(uniswapV3NonfungiblePositionsManager).increaseLiquidity(INonfungiblePositionManager.IncreaseLiquidityParams({\r\n                tokenId: tokenId,\r\n                amount0Desired: amount0,\r\n                amount1Desired: amount1,\r\n                amount0Min: _calculatePercentage(amount0, FULL_PRECISION - priceSlippagePercentage),\r\n                amount1Min: _calculatePercentage(amount1, FULL_PRECISION - priceSlippagePercentage),\r\n                deadline: block.timestamp + 10000\r\n            }));\r\n        }\r\n        remainingAmount = (amount - (tokenPosition == 0 ? amount0 : amount1));\r\n    }\r\n\r\n    function _sendRemainingETH() private {\r\n        uint256 _redeemableETH = redeemableETH;\r\n        if(_redeemableETH != 0) {\r\n            redeemableETH = 0;\r\n            _decreaseReservedBalance(_redeemableETH);\r\n            _safeTransfer(address(0), destinationAddress, _redeemableETH);\r\n        }\r\n    }\r\n\r\n    function _afterVestingPeriod() private {\r\n        require(vestingEnds != 0 && block.timestamp >= vestingEnds, \"in vesting period\");\r\n        _sendRemainingETH();\r\n        if(nextRebalanceEvent != 0 && block.timestamp >= nextRebalanceEvent && farmingDuration != 1) {\r\n            rebalanceIntervalInEventSlots = (MONTH_IN_SECONDS * (farmingDuration = (farmingDuration /= 2) == 0 ? 1 : farmingDuration)) / TIME_SLOT_IN_SECONDS;\r\n        }\r\n        address[] memory rewardReceivers = new address[](1);\r\n        _claimReward(rewardReceivers[0] = treasuryAddress, rewardReceivers, new uint256[](0));\r\n    }\r\n}\r\n\r\ninterface IConvertInETH {\r\n    function convert(address tokenAddress, uint256 amount, bytes calldata conversionInput) external returns(bytes memory conversionOutput);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_destinationAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_conversionAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_farmingDuration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_uniswapV3NonfungiblePositionsManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapV3SwapRouter\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"_fee\",\"type\":\"uint24\"},{\"internalType\":\"uint160\",\"name\":\"_sqrtPriceX96\",\"type\":\"uint160\"},{\"internalType\":\"uint256\",\"name\":\"_priceSlippagePercentage\",\"type\":\"uint256\"},{\"internalType\":\"int24\",\"name\":\"_tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"_tickUpper\",\"type\":\"int24\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FULL_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MONTH_IN_SECONDS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_SLOT_IN_SECONDS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateIfThereIsMoreReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"seasonReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"rewardReceivers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rewardReceiversPercentage\",\"type\":\"uint256[]\"}],\"name\":\"claimReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimedReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nextRebalanceEvent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerEvent_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"claimRewardOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimedReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nextRebalanceEvent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerEvent_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"conversionInput\",\"type\":\"bytes\"}],\"name\":\"collectFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collectedAmount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collectedAmount1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"conversionOutput\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasuryAddress\",\"type\":\"address\"}],\"name\":\"completeInitialization\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"operatorAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"conversionAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destinationAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"farmingDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"farmingLiquidityProvider\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"treasuryBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"additionalLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_vestingEnds\",\"type\":\"uint256\"}],\"name\":\"finalizePosition\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdateEvent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextRebalanceEvent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"positionOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vestedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"positionLiquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"farmingBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceSlippagePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebalanceIntervalInEventSlots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Min\",\"type\":\"uint256\"}],\"name\":\"redeemRevenueSharePositionForever\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemVestingResult\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemableETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reservedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerEvent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sendRemainingETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"setConversionAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setPriceSlippagePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"setTreasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sqrtPriceX96\",\"outputs\":[{\"internalType\":\"uint160\",\"name\":\"\",\"type\":\"uint160\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startEvent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tickLower\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tickUpper\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFarmingLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryFarmingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV3NonfungiblePositionsManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV3SwapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestedAmount\",\"type\":\"uint256\"}],\"name\":\"updatePositionOf\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingEnds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TreasuryBootstrapRevenueShare", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000005a46c3a544d160f39a96036a88ad09f95035a892000000000000000000000000bc5052b0aa6149fe86747cb7e99524f56fb6402a000000000000000000000000fad75c63c3817f1931357aec9a7736bb8067a1d90000000000000000000000000000000000000000000000000000000000000003000000000000000000000000c36442b4a4522e871399cd717abdd847ab11fe88000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564000000000000000000000000000000000000000000000000000000000000271000000000000000000000000000000000000000000183d3e95f01af549e542b2e000000000000000000000000000000000000000000000000006a94d74f430000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe6f38ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff4868", "EVMVersion": "Default", "Library": "TreasuryBootstrapRevenueShareLib:ca883a296fa19d0ce326caa8bc6de328bbf47cd8", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://97acec69a57de94181cda30ab7ed6376a1914ac8baa163b7852f28988f3ec7d9"}