{"SourceCode": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n// Sources flattened with hardhat v2.12.2 https://hardhat.org\r\n\r\n// File libraries/ScaledMath.sol\r\n\r\npragma solidity ^0.8.17;\r\n\r\nlibrary ScaledMath {\r\n    uint256 internal constant ONE = 1e18;\r\n\r\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return (a * b) / ONE;\r\n    }\r\n\r\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return (a * ONE) / b;\r\n    }\r\n\r\n    function changeScale(\r\n        uint256 a,\r\n        uint256 from,\r\n        uint256 to\r\n    ) internal pure returns (uint256) {\r\n        if (from == to) return a;\r\n        else if (from < to) return a * 10 ** (to - from);\r\n        else return a / 10 ** (from - to);\r\n    }\r\n}\r\n\r\n\r\n// File libraries/VotingPowerHistory.sol\r\n\r\npragma solidity ^0.8.17;\r\n\r\nlibrary VotingPowerHistory {\r\n    using VotingPowerHistory for History;\r\n    using VotingPowerHistory for Record;\r\n    using ScaledMath for uint256;\r\n\r\n    struct Record {\r\n        uint256 at;\r\n        uint256 baseVotingPower;\r\n        uint256 multiplier;\r\n        int256 netDelegatedVotes;\r\n    }\r\n\r\n    function zeroRecord() internal pure returns (Record memory) {\r\n        return\r\n            Record({\r\n                at: 0,\r\n                baseVotingPower: 0,\r\n                multiplier: ScaledMath.ONE,\r\n                netDelegatedVotes: 0\r\n            });\r\n    }\r\n\r\n    function total(Record memory record) internal pure returns (uint256) {\r\n        return\r\n            uint256(\r\n                int256(record.baseVotingPower.mulDown(record.multiplier)) +\r\n                    record.netDelegatedVotes\r\n            );\r\n    }\r\n\r\n    struct History {\r\n        mapping(address => Record[]) votes;\r\n        mapping(address => mapping(address => uint256)) _delegations;\r\n        mapping(address => uint256) _delegatedToOthers;\r\n        mapping(address => uint256) _delegatedToSelf;\r\n    }\r\n\r\n    event VotesDelegated(address from, address to, uint256 amount);\r\n    event VotesUndelegated(address from, address to, uint256 amount);\r\n\r\n    function updateVotingPower(\r\n        History storage history,\r\n        address for_,\r\n        uint256 baseVotingPower,\r\n        uint256 multiplier,\r\n        int256 netDelegatedVotes\r\n    ) internal returns (Record memory) {\r\n        Record[] storage votesFor = history.votes[for_];\r\n        Record memory updatedRecord = Record({\r\n            at: block.timestamp,\r\n            baseVotingPower: baseVotingPower,\r\n            multiplier: multiplier,\r\n            netDelegatedVotes: netDelegatedVotes\r\n        });\r\n        Record memory lastRecord = history.currentRecord(for_);\r\n        if (lastRecord.at == block.timestamp && votesFor.length > 0) {\r\n            votesFor[votesFor.length - 1] = updatedRecord;\r\n        } else {\r\n            history.votes[for_].push(updatedRecord);\r\n        }\r\n        return updatedRecord;\r\n    }\r\n\r\n    function getVotingPower(\r\n        History storage history,\r\n        address for_,\r\n        uint256 at\r\n    ) internal view returns (uint256) {\r\n        (, Record memory record) = binarySearch(history.votes[for_], at);\r\n        return record.total();\r\n    }\r\n\r\n    function currentRecord(\r\n        History storage history,\r\n        address for_\r\n    ) internal view returns (Record memory) {\r\n        Record[] memory records = history.votes[for_];\r\n        if (records.length == 0) {\r\n            return zeroRecord();\r\n        } else {\r\n            return records[records.length - 1];\r\n        }\r\n    }\r\n\r\n    function binarySearch(\r\n        Record[] memory records,\r\n        uint256 at\r\n    ) internal view returns (bool found, Record memory) {\r\n        return _binarySearch(records, at, 0, records.length);\r\n    }\r\n\r\n    function _binarySearch(\r\n        Record[] memory records,\r\n        uint256 at,\r\n        uint256 startIdx,\r\n        uint256 endIdx\r\n    ) internal view returns (bool found, Record memory) {\r\n        if (startIdx >= endIdx) {\r\n            return (false, zeroRecord());\r\n        }\r\n\r\n        if (endIdx - startIdx == 1) {\r\n            Record memory rec = records[startIdx];\r\n            return rec.at <= at ? (true, rec) : (false, zeroRecord());\r\n        }\r\n\r\n        uint256 midIdx = (endIdx + startIdx) / 2;\r\n        Record memory lowerBound = records[midIdx - 1];\r\n        Record memory upperBound = records[midIdx];\r\n        if (lowerBound.at <= at && at < upperBound.at) {\r\n            return (true, lowerBound);\r\n        } else if (upperBound.at <= at) {\r\n            return _binarySearch(records, at, midIdx, endIdx);\r\n        } else {\r\n            return _binarySearch(records, at, startIdx, midIdx);\r\n        }\r\n    }\r\n\r\n    function delegateVote(\r\n        History storage history,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        Record memory fromCurrent = history.currentRecord(from);\r\n\r\n        uint256 availableToDelegate = fromCurrent.baseVotingPower.mulDown(\r\n            fromCurrent.multiplier\r\n        ) - history._delegatedToOthers[from];\r\n        require(\r\n            availableToDelegate >= amount,\r\n            \"insufficient balance to delegate\"\r\n        );\r\n\r\n        history._delegatedToSelf[to] += amount;\r\n        history._delegatedToOthers[from] += amount;\r\n        history._delegations[from][to] += amount;\r\n\r\n        history.updateVotingPower(\r\n            from,\r\n            fromCurrent.baseVotingPower,\r\n            fromCurrent.multiplier,\r\n            history.netDelegatedVotingPower(from)\r\n        );\r\n        Record memory toCurrent = history.currentRecord(to);\r\n        history.updateVotingPower(\r\n            to,\r\n            toCurrent.baseVotingPower,\r\n            toCurrent.multiplier,\r\n            history.netDelegatedVotingPower(to)\r\n        );\r\n\r\n        emit VotesDelegated(from, to, amount);\r\n    }\r\n\r\n    function undelegateVote(\r\n        History storage history,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        require(\r\n            history._delegations[from][to] >= amount,\r\n            \"user has not delegated enough to delegate\"\r\n        );\r\n\r\n        history._delegatedToSelf[to] -= amount;\r\n        history._delegatedToOthers[from] -= amount;\r\n        history._delegations[from][to] -= amount;\r\n\r\n        Record memory fromCurrent = history.currentRecord(from);\r\n        history.updateVotingPower(\r\n            from,\r\n            fromCurrent.baseVotingPower,\r\n            fromCurrent.multiplier,\r\n            history.netDelegatedVotingPower(from)\r\n        );\r\n        Record memory toCurrent = history.currentRecord(to);\r\n        history.updateVotingPower(\r\n            to,\r\n            toCurrent.baseVotingPower,\r\n            toCurrent.multiplier,\r\n            history.netDelegatedVotingPower(to)\r\n        );\r\n\r\n        emit VotesUndelegated(from, to, amount);\r\n    }\r\n\r\n    function netDelegatedVotingPower(\r\n        History storage history,\r\n        address who\r\n    ) internal view returns (int256) {\r\n        return\r\n            int256(history._delegatedToSelf[who]) -\r\n            int256(history._delegatedToOthers[who]);\r\n    }\r\n\r\n    function delegatedVotingPower(\r\n        History storage history,\r\n        address who\r\n    ) internal view returns (uint256) {\r\n        return history._delegatedToOthers[who];\r\n    }\r\n\r\n    function updateMultiplier(\r\n        History storage history,\r\n        address who,\r\n        uint256 multiplier\r\n    ) internal {\r\n        Record memory current = history.currentRecord(who);\r\n        require(current.multiplier <= multiplier, \"cannot decrease multiplier\");\r\n        history.updateVotingPower(\r\n            who,\r\n            current.baseVotingPower,\r\n            multiplier,\r\n            current.netDelegatedVotes\r\n        );\r\n    }\r\n}\r\n\r\n\r\n// File interfaces/IVault.sol\r\n\r\npragma solidity ^0.8.17;\r\n\r\ninterface IVault {\r\n    function getRawVotingPower(address account) external view returns (uint256);\r\n\r\n    function getCurrentRecord(\r\n        address account\r\n    ) external view returns (VotingPowerHistory.Record memory);\r\n\r\n    function getRawVotingPower(\r\n        address account,\r\n        uint256 timestamp\r\n    ) external view returns (uint256);\r\n\r\n    function getTotalRawVotingPower() external view returns (uint256);\r\n\r\n    function getVaultType() external view returns (string memory);\r\n}\r\n\r\n\r\n// File libraries/Errors.sol\r\n\r\npragma solidity ^0.8.17;\r\n\r\nlibrary Errors {\r\n    error DuplicatedVault(address vault);\r\n    error InvalidTotalWeight(uint256 totalWeight);\r\n    error NotAuthorized(address actual, address expected);\r\n    error InvalidVotingPowerUpdate(\r\n        uint256 actualTotalPower,\r\n        uint256 givenTotalPower\r\n    );\r\n    error MultisigSunset();\r\n\r\n    error ZeroDivision();\r\n}\r\n\r\n\r\n// File contracts/access/ImmutableOwner.sol\r\n\r\npragma solidity ^0.8.17;\r\n\r\ncontract ImmutableOwner {\r\n    address public immutable owner;\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) revert Errors.NotAuthorized(msg.sender, owner);\r\n        _;\r\n    }\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n    }\r\n}\r\n\r\n\r\n// File interfaces/IVaultWithThreshold.sol\r\n\r\npragma solidity ^0.8.17;\r\n\r\ninterface IVaultWithThreshold {\r\n    event ThresholdSet(uint256 threshold);\r\n\r\n    function threshold() external view returns (uint256);\r\n\r\n    function setThreshold(uint256 threshold) external;\r\n}\r\n\r\n\r\n// File contracts/vaults/VaultWithThreshold.sol\r\n\r\npragma solidity ^0.8.17;\r\n\r\ncontract VaultWithThreshold is IVaultWithThreshold {\r\n    uint256 public override threshold;\r\n\r\n    function setThreshold(uint256 _threshold) external {\r\n        threshold = _threshold;\r\n        emit ThresholdSet(_threshold);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/structs/EnumerableSet.sol@v4.8.0\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\r\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n *\r\n * [WARNING]\r\n * ====\r\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\r\n * unusable.\r\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\r\n *\r\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\r\n * array of EnumerableSet.\r\n * ====\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastValue = set._values[lastIndex];\r\n\r\n                // Move the last value to the index where the value to delete is\r\n                set._values[toDeleteIndex] = lastValue;\r\n                // Update the index for the moved value\r\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\r\n            }\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        return set._values[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function _values(Set storage set) private view returns (bytes32[] memory) {\r\n        return set._values;\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        bytes32[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(AddressSet storage set) internal view returns (address[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        address[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        uint256[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/structs/EnumerableMap.sol@v4.8.0\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableMap.sol)\r\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for managing an enumerable variant of Solidity's\r\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\r\n * type.\r\n *\r\n * Maps have the following properties:\r\n *\r\n * - Entries are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableMap.UintToAddressMap private myMap;\r\n * }\r\n * ```\r\n *\r\n * The following map types are supported:\r\n *\r\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\r\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\r\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\r\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\r\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\r\n *\r\n * [WARNING]\r\n * ====\r\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\r\n * unusable.\r\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\r\n *\r\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\r\n * array of EnumerableMap.\r\n * ====\r\n */\r\nlibrary EnumerableMap {\r\n    using EnumerableSet for EnumerableSet.Bytes32Set;\r\n\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Map type with\r\n    // bytes32 keys and values.\r\n    // The Map implementation uses private functions, and user-facing\r\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\r\n    // the underlying Map.\r\n    // This means that we can only create new EnumerableMaps for types that fit\r\n    // in bytes32.\r\n\r\n    struct Bytes32ToBytes32Map {\r\n        // Storage of keys\r\n        EnumerableSet.Bytes32Set _keys;\r\n        mapping(bytes32 => bytes32) _values;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\r\n     * key. O(1).\r\n     *\r\n     * Returns true if the key was added to the map, that is if it was not\r\n     * already present.\r\n     */\r\n    function set(\r\n        Bytes32ToBytes32Map storage map,\r\n        bytes32 key,\r\n        bytes32 value\r\n    ) internal returns (bool) {\r\n        map._values[key] = value;\r\n        return map._keys.add(key);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a key-value pair from a map. O(1).\r\n     *\r\n     * Returns true if the key was removed from the map, that is if it was present.\r\n     */\r\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\r\n        delete map._values[key];\r\n        return map._keys.remove(key);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the key is in the map. O(1).\r\n     */\r\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\r\n        return map._keys.contains(key);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of key-value pairs in the map. O(1).\r\n     */\r\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\r\n        return map._keys.length();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of entries inside the\r\n     * array, and it may change when more entries are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\r\n        bytes32 key = map._keys.at(index);\r\n        return (key, map._values[key]);\r\n    }\r\n\r\n    /**\r\n     * @dev Tries to returns the value associated with `key`. O(1).\r\n     * Does not revert if `key` is not in the map.\r\n     */\r\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\r\n        bytes32 value = map._values[key];\r\n        if (value == bytes32(0)) {\r\n            return (contains(map, key), bytes32(0));\r\n        } else {\r\n            return (true, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value associated with `key`. O(1).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `key` must be in the map.\r\n     */\r\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\r\n        bytes32 value = map._values[key];\r\n        require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryGet}.\r\n     */\r\n    function get(\r\n        Bytes32ToBytes32Map storage map,\r\n        bytes32 key,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes32) {\r\n        bytes32 value = map._values[key];\r\n        require(value != 0 || contains(map, key), errorMessage);\r\n        return value;\r\n    }\r\n\r\n    // UintToUintMap\r\n\r\n    struct UintToUintMap {\r\n        Bytes32ToBytes32Map _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\r\n     * key. O(1).\r\n     *\r\n     * Returns true if the key was added to the map, that is if it was not\r\n     * already present.\r\n     */\r\n    function set(\r\n        UintToUintMap storage map,\r\n        uint256 key,\r\n        uint256 value\r\n    ) internal returns (bool) {\r\n        return set(map._inner, bytes32(key), bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the key was removed from the map, that is if it was present.\r\n     */\r\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\r\n        return remove(map._inner, bytes32(key));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the key is in the map. O(1).\r\n     */\r\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\r\n        return contains(map._inner, bytes32(key));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of elements in the map. O(1).\r\n     */\r\n    function length(UintToUintMap storage map) internal view returns (uint256) {\r\n        return length(map._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the element stored at position `index` in the set. O(1).\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\r\n        (bytes32 key, bytes32 value) = at(map._inner, index);\r\n        return (uint256(key), uint256(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Tries to returns the value associated with `key`. O(1).\r\n     * Does not revert if `key` is not in the map.\r\n     */\r\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\r\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\r\n        return (success, uint256(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value associated with `key`. O(1).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `key` must be in the map.\r\n     */\r\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\r\n        return uint256(get(map._inner, bytes32(key)));\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryGet}.\r\n     */\r\n    function get(\r\n        UintToUintMap storage map,\r\n        uint256 key,\r\n        string memory errorMessage\r\n    ) internal view returns (uint256) {\r\n        return uint256(get(map._inner, bytes32(key), errorMessage));\r\n    }\r\n\r\n    // UintToAddressMap\r\n\r\n    struct UintToAddressMap {\r\n        Bytes32ToBytes32Map _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\r\n     * key. O(1).\r\n     *\r\n     * Returns true if the key was added to the map, that is if it was not\r\n     * already present.\r\n     */\r\n    function set(\r\n        UintToAddressMap storage map,\r\n        uint256 key,\r\n        address value\r\n    ) internal returns (bool) {\r\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the key was removed from the map, that is if it was present.\r\n     */\r\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\r\n        return remove(map._inner, bytes32(key));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the key is in the map. O(1).\r\n     */\r\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\r\n        return contains(map._inner, bytes32(key));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of elements in the map. O(1).\r\n     */\r\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\r\n        return length(map._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the element stored at position `index` in the set. O(1).\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\r\n        (bytes32 key, bytes32 value) = at(map._inner, index);\r\n        return (uint256(key), address(uint160(uint256(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Tries to returns the value associated with `key`. O(1).\r\n     * Does not revert if `key` is not in the map.\r\n     */\r\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\r\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\r\n        return (success, address(uint160(uint256(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value associated with `key`. O(1).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `key` must be in the map.\r\n     */\r\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\r\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryGet}.\r\n     */\r\n    function get(\r\n        UintToAddressMap storage map,\r\n        uint256 key,\r\n        string memory errorMessage\r\n    ) internal view returns (address) {\r\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\r\n    }\r\n\r\n    // AddressToUintMap\r\n\r\n    struct AddressToUintMap {\r\n        Bytes32ToBytes32Map _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\r\n     * key. O(1).\r\n     *\r\n     * Returns true if the key was added to the map, that is if it was not\r\n     * already present.\r\n     */\r\n    function set(\r\n        AddressToUintMap storage map,\r\n        address key,\r\n        uint256 value\r\n    ) internal returns (bool) {\r\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the key was removed from the map, that is if it was present.\r\n     */\r\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\r\n        return remove(map._inner, bytes32(uint256(uint160(key))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the key is in the map. O(1).\r\n     */\r\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\r\n        return contains(map._inner, bytes32(uint256(uint160(key))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of elements in the map. O(1).\r\n     */\r\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\r\n        return length(map._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the element stored at position `index` in the set. O(1).\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\r\n        (bytes32 key, bytes32 value) = at(map._inner, index);\r\n        return (address(uint160(uint256(key))), uint256(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Tries to returns the value associated with `key`. O(1).\r\n     * Does not revert if `key` is not in the map.\r\n     */\r\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\r\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\r\n        return (success, uint256(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value associated with `key`. O(1).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `key` must be in the map.\r\n     */\r\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\r\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryGet}.\r\n     */\r\n    function get(\r\n        AddressToUintMap storage map,\r\n        address key,\r\n        string memory errorMessage\r\n    ) internal view returns (uint256) {\r\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\r\n    }\r\n\r\n    // Bytes32ToUintMap\r\n\r\n    struct Bytes32ToUintMap {\r\n        Bytes32ToBytes32Map _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\r\n     * key. O(1).\r\n     *\r\n     * Returns true if the key was added to the map, that is if it was not\r\n     * already present.\r\n     */\r\n    function set(\r\n        Bytes32ToUintMap storage map,\r\n        bytes32 key,\r\n        uint256 value\r\n    ) internal returns (bool) {\r\n        return set(map._inner, key, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the key was removed from the map, that is if it was present.\r\n     */\r\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\r\n        return remove(map._inner, key);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the key is in the map. O(1).\r\n     */\r\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\r\n        return contains(map._inner, key);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of elements in the map. O(1).\r\n     */\r\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\r\n        return length(map._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the element stored at position `index` in the set. O(1).\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\r\n        (bytes32 key, bytes32 value) = at(map._inner, index);\r\n        return (key, uint256(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Tries to returns the value associated with `key`. O(1).\r\n     * Does not revert if `key` is not in the map.\r\n     */\r\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\r\n        (bool success, bytes32 value) = tryGet(map._inner, key);\r\n        return (success, uint256(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value associated with `key`. O(1).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `key` must be in the map.\r\n     */\r\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\r\n        return uint256(get(map._inner, key));\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryGet}.\r\n     */\r\n    function get(\r\n        Bytes32ToUintMap storage map,\r\n        bytes32 key,\r\n        string memory errorMessage\r\n    ) internal view returns (uint256) {\r\n        return uint256(get(map._inner, key, errorMessage));\r\n    }\r\n}\r\n\r\n\r\n// File libraries/DataTypes.sol\r\n\r\npragma solidity ^0.8.17;\r\n\r\nlibrary DataTypes {\r\n    enum Status {\r\n        Undefined,\r\n        Active,\r\n        Rejected,\r\n        Queued,\r\n        Executed,\r\n        Vetoed\r\n    }\r\n\r\n    struct ProposalAction {\r\n        address target;\r\n        bytes data;\r\n    }\r\n\r\n    struct Proposal {\r\n        uint64 createdAt;\r\n        uint64 executableAt;\r\n        uint64 votingEndsAt;\r\n        uint64 voteThreshold;\r\n        uint64 quorum;\r\n        uint16 id;\r\n        uint8 actionLevel;\r\n        address proposer;\r\n        Status status;\r\n        ProposalAction[] actions;\r\n    }\r\n\r\n    struct PendingWithdrawal {\r\n        uint256 id;\r\n        uint256 withdrawableAt;\r\n        uint256 amount;\r\n        address to;\r\n        address delegate;\r\n    }\r\n\r\n    struct VaultWeightSchedule {\r\n        VaultWeightConfiguration[] vaults;\r\n        uint256 startsAt;\r\n        uint256 endsAt;\r\n    }\r\n\r\n    struct VaultWeightConfiguration {\r\n        address vaultAddress;\r\n        uint256 initialWeight;\r\n        uint256 targetWeight;\r\n    }\r\n\r\n    struct VaultWeight {\r\n        address vaultAddress;\r\n        uint256 currentWeight;\r\n        uint256 initialWeight;\r\n        uint256 targetWeight;\r\n    }\r\n\r\n    struct VaultVotingPower {\r\n        address vaultAddress;\r\n        uint256 votingPower;\r\n    }\r\n\r\n    struct Tier {\r\n        uint64 quorum;\r\n        uint64 proposalThreshold;\r\n        uint64 voteThreshold;\r\n        uint32 timeLockDuration;\r\n        uint32 proposalLength;\r\n        uint8 actionLevel;\r\n    }\r\n\r\n    struct EmergencyRecoveryProposal {\r\n        uint64 createdAt;\r\n        uint64 completesAt;\r\n        Status status;\r\n        bytes payload;\r\n        EnumerableMap.AddressToUintMap vetos;\r\n    }\r\n\r\n    enum Ballot {\r\n        Undefined,\r\n        For,\r\n        Against,\r\n        Abstain\r\n    }\r\n\r\n    struct VoteTotals {\r\n        VaultVotingPower[] _for;\r\n        VaultVotingPower[] against;\r\n        VaultVotingPower[] abstentions;\r\n    }\r\n\r\n    struct VaultSnapshot {\r\n        address vaultAddress;\r\n        uint256 weight;\r\n        uint256 totalVotingPower;\r\n    }\r\n\r\n    enum ProposalOutcome {\r\n        Undefined,\r\n        QuorumNotMet,\r\n        ThresholdNotMet,\r\n        Successful\r\n    }\r\n\r\n    struct LimitUpgradeabilityParameters {\r\n        uint8 actionLevelThreshold;\r\n        uint256 emaThreshold;\r\n        uint256 minBGYDSupply;\r\n        address tierStrategy;\r\n    }\r\n\r\n    struct Delegation {\r\n        address delegate;\r\n        uint256 amount;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/vaults/BaseVault.sol\r\n\r\npragma solidity ^0.8.17;\r\n\r\n\r\n\r\nabstract contract BaseVault is IVault {\r\n    using VotingPowerHistory for VotingPowerHistory.History;\r\n\r\n    VotingPowerHistory.History internal history;\r\n\r\n    function getCurrentRecord(\r\n        address account\r\n    ) external view returns (VotingPowerHistory.Record memory) {\r\n        return history.currentRecord(account);\r\n    }\r\n\r\n    function getRawVotingPower(\r\n        address account\r\n    ) external view returns (uint256) {\r\n        return getRawVotingPower(account, block.timestamp);\r\n    }\r\n\r\n    function getRawVotingPower(\r\n        address account,\r\n        uint256 timestamp\r\n    ) public view virtual returns (uint256);\r\n}\r\n\r\n\r\n// File contracts/vaults/AggregateLPVault.sol\r\n\r\npragma solidity ^0.8.17;\r\n\r\n\r\n\r\n\r\n\r\ncontract AggregateLPVault is BaseVault, VaultWithThreshold, ImmutableOwner {\r\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\r\n    using ScaledMath for uint256;\r\n\r\n    string internal constant _VAULT_TYPE = \"AggregateLP\";\r\n\r\n    struct VaultWeight {\r\n        address vaultAddress;\r\n        uint256 weight;\r\n    }\r\n\r\n    EnumerableMap.AddressToUintMap internal vaultsToWeights;\r\n\r\n    constructor(\r\n        address _owner,\r\n        uint256 _threshold,\r\n        VaultWeight[] memory vaultWeights\r\n    ) ImmutableOwner(_owner) {\r\n        threshold = _threshold;\r\n        _setVaultWeights(vaultWeights);\r\n    }\r\n\r\n    function setVaultWeights(\r\n        VaultWeight[] calldata vaultWeights\r\n    ) external onlyOwner {\r\n        _removeAllVaultWeights();\r\n        _setVaultWeights(vaultWeights);\r\n    }\r\n\r\n    function getVaultWeights() external view returns (VaultWeight[] memory) {\r\n        uint256 length = vaultsToWeights.length();\r\n        VaultWeight[] memory vaultWeights = new VaultWeight[](length);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            (address vault, uint256 weight) = vaultsToWeights.at(i);\r\n            vaultWeights[i] = VaultWeight(vault, weight);\r\n        }\r\n\r\n        return vaultWeights;\r\n    }\r\n\r\n    function _removeAllVaultWeights() internal {\r\n        uint256 length = vaultsToWeights.length();\r\n        for (uint256 i = 0; i < length; i++) {\r\n            (address key, ) = vaultsToWeights.at(0);\r\n            vaultsToWeights.remove(key);\r\n        }\r\n    }\r\n\r\n    function getRawVotingPower(\r\n        address _user,\r\n        uint256 timestamp\r\n    ) public view override returns (uint256) {\r\n        uint256 rawVotingPower = 0;\r\n        for (uint256 i = 0; i < vaultsToWeights.length(); i++) {\r\n            (address vault, uint256 weight) = vaultsToWeights.at(i);\r\n            rawVotingPower += IVault(vault)\r\n                .getRawVotingPower(_user, timestamp)\r\n                .mulDown(weight);\r\n        }\r\n\r\n        return rawVotingPower;\r\n    }\r\n\r\n    function getTotalRawVotingPower() public view override returns (uint256) {\r\n        uint256 totalRawVotingPower = 0;\r\n        for (uint256 i = 0; i < vaultsToWeights.length(); i++) {\r\n            (address vault, uint256 weight) = vaultsToWeights.at(i);\r\n            totalRawVotingPower += IVault(vault)\r\n                .getTotalRawVotingPower()\r\n                .mulDown(weight);\r\n        }\r\n\r\n        if (totalRawVotingPower <= threshold) {\r\n            totalRawVotingPower = threshold;\r\n        }\r\n\r\n        return totalRawVotingPower;\r\n    }\r\n\r\n    function getVaultType() external pure returns (string memory) {\r\n        return _VAULT_TYPE;\r\n    }\r\n\r\n    function _setVaultWeights(VaultWeight[] memory vaultWeights) internal {\r\n        for (uint256 i; i < vaultWeights.length; i++) {\r\n            VaultWeight memory v = vaultWeights[i];\r\n            require(v.weight > 0, \"cannot have a 0 weight\");\r\n            vaultsToWeights.set(v.vaultAddress, v.weight);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"internalType\":\"struct AggregateLPVault.VaultWeight[]\",\"name\":\"vaultWeights\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"actual\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expected\",\"type\":\"address\"}],\"name\":\"NotAuthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"ThresholdSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getCurrentRecord\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"at\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseVotingPower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"netDelegatedVotes\",\"type\":\"int256\"}],\"internalType\":\"struct VotingPowerHistory.Record\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getRawVotingPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getRawVotingPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalRawVotingPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultType\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultWeights\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"internalType\":\"struct AggregateLPVault.VaultWeight[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"setThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"internalType\":\"struct AggregateLPVault.VaultWeight[]\",\"name\":\"vaultWeights\",\"type\":\"tuple[]\"}],\"name\":\"setVaultWeights\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"threshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AggregateLPVault", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000078ecf97572c3890ed02221a611014f30219f6219000000000000000000000000000000000000000000084595161401484a00000000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "london", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6891c56f9f591ef24cef150b9f7ac61e41b2689802e9729df349b774d1264769"}