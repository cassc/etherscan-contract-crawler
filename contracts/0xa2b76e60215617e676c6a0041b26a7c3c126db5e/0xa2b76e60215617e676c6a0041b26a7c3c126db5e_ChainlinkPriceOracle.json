{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"ChainLinkPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"BaseChainLinkOracle.sol\\\";\\n\\nimport \\\"Errors.sol\\\";\\nimport \\\"DecimalScale.sol\\\";\\n\\ncontract ChainlinkPriceOracle is BaseChainlinkPriceOracle {\\n    using DecimalScale for uint256;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    event FeedUpdated(address indexed asset, address indexed previousFeed, address indexed newFeed);\\n\\n    constructor(address _governor) BaseChainlinkPriceOracle(_governor) {}\\n\\n    /// @inheritdoc IUSDPriceOracle\\n    function getPriceUSD(address asset) external view override returns (uint256) {\\n        address feed = feeds[asset];\\n        require(feed != address(0), Errors.ASSET_NOT_SUPPORTED);\\n        (, uint256 price, ) = _getLatestRoundData(feed);\\n        return price.scaleFrom(AggregatorV3Interface(feed).decimals());\\n    }\\n\\n    /// @notice Allows to set Chainlink feeds\\n    /// This can only be called by governance\\n    /// @param feed the Chainlink feed address. If this is 0, the asset is removed (i.e. not supported anymore)\\n    function setFeed(address asset, address feed) external virtual governanceOnly {\\n        address previousFeed = feeds[asset];\\n        require(feed != previousFeed, Errors.INVALID_ARGUMENT);\\n        if (feed == address(0)) {\\n            _supportedAssets.remove(asset);\\n            delete feeds[asset];\\n        } else {\\n            _supportedAssets.add(asset);\\n            feeds[asset] = feed;\\n        }\\n        emit FeedUpdated(asset, previousFeed, feed);\\n    }\\n}\\n\"\r\n    },\r\n    \"BaseChainLinkOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"EnumerableSet.sol\\\";\\nimport \\\"Governable.sol\\\";\\n\\nimport \\\"IUSDPriceOracle.sol\\\";\\nimport \\\"ChainlinkAggregator.sol\\\";\\n\\nimport \\\"Errors.sol\\\";\\nimport \\\"DecimalScale.sol\\\";\\n\\nabstract contract BaseChainlinkPriceOracle is IUSDPriceOracle, Governable {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using DecimalScale for uint256;\\n\\n    uint256 public constant MAX_LAG = 86400;\\n\\n    EnumerableSet.AddressSet internal _supportedAssets;\\n    mapping(address => address) public feeds;\\n\\n    constructor(address _governor) Governable(_governor) {}\\n\\n    function listSupportedAssets() external view returns (address[] memory) {\\n        return _supportedAssets.values();\\n    }\\n\\n    function _getLatestRoundData(address feed)\\n        internal\\n        view\\n        returns (\\n            uint80 roundId,\\n            uint256 price,\\n            uint256 updatedAt\\n        )\\n    {\\n        int256 answer;\\n        (roundId, answer, , updatedAt, ) = AggregatorV3Interface(feed).latestRoundData();\\n        require(block.timestamp <= updatedAt + MAX_LAG, Errors.STALE_PRICE);\\n        require(answer >= 0, Errors.NEGATIVE_PRICE);\\n        price = uint256(answer);\\n    }\\n}\\n\"\r\n    },\r\n    \"EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"Governable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"GovernableBase.sol\\\";\\n\\ncontract Governable is GovernableBase {\\n    constructor(address _governor) {\\n        governor = _governor;\\n        emit GovernorChanged(address(0), _governor);\\n    }\\n}\\n\"\r\n    },\r\n    \"GovernableBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nimport \\\"Errors.sol\\\";\\nimport \\\"IGovernable.sol\\\";\\n\\ncontract GovernableBase is IGovernable {\\n    address public override governor;\\n    address public override pendingGovernor;\\n\\n    modifier governanceOnly() {\\n        require(msg.sender == governor, Errors.NOT_AUTHORIZED);\\n        _;\\n    }\\n\\n    /// @inheritdoc IGovernable\\n    function changeGovernor(address newGovernor) external override governanceOnly {\\n        require(address(newGovernor) != address(0), Errors.INVALID_ARGUMENT);\\n        pendingGovernor = newGovernor;\\n        emit GovernorChangeRequested(newGovernor);\\n    }\\n\\n    /// @inheritdoc IGovernable\\n    function acceptGovernance() external override {\\n        require(msg.sender == pendingGovernor, Errors.NOT_AUTHORIZED);\\n        address currentGovernor = governor;\\n        governor = pendingGovernor;\\n        pendingGovernor = address(0);\\n        emit GovernorChanged(currentGovernor, msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\n/// @notice Defines different errors emitted by Gyroscope contracts\\nlibrary Errors {\\n    string public constant TOKEN_AND_AMOUNTS_LENGTH_DIFFER = \\\"1\\\";\\n    string public constant TOO_MUCH_SLIPPAGE = \\\"2\\\";\\n    string public constant EXCHANGER_NOT_FOUND = \\\"3\\\";\\n    string public constant POOL_IDS_NOT_FOUND = \\\"4\\\";\\n    string public constant WOULD_UNBALANCE_GYROSCOPE = \\\"5\\\";\\n    string public constant VAULT_ALREADY_EXISTS = \\\"6\\\";\\n    string public constant VAULT_NOT_FOUND = \\\"7\\\";\\n\\n    string public constant X_OUT_OF_BOUNDS = \\\"20\\\";\\n    string public constant Y_OUT_OF_BOUNDS = \\\"21\\\";\\n    string public constant PRODUCT_OUT_OF_BOUNDS = \\\"22\\\";\\n    string public constant INVALID_EXPONENT = \\\"23\\\";\\n    string public constant OUT_OF_BOUNDS = \\\"24\\\";\\n    string public constant ZERO_DIVISION = \\\"25\\\";\\n    string public constant ADD_OVERFLOW = \\\"26\\\";\\n    string public constant SUB_OVERFLOW = \\\"27\\\";\\n    string public constant MUL_OVERFLOW = \\\"28\\\";\\n    string public constant DIV_INTERNAL = \\\"29\\\";\\n\\n    // User errors\\n    string public constant NOT_AUTHORIZED = \\\"30\\\";\\n    string public constant INVALID_ARGUMENT = \\\"31\\\";\\n    string public constant KEY_NOT_FOUND = \\\"32\\\";\\n    string public constant KEY_FROZEN = \\\"33\\\";\\n    string public constant INSUFFICIENT_BALANCE = \\\"34\\\";\\n    string public constant INVALID_ASSET = \\\"35\\\";\\n    string public constant FORBIDDEN_EXTERNAL_ACTION = \\\"35\\\";\\n\\n    // Oracle related errors\\n    string public constant ASSET_NOT_SUPPORTED = \\\"40\\\";\\n    string public constant STALE_PRICE = \\\"41\\\";\\n    string public constant NEGATIVE_PRICE = \\\"42\\\";\\n    string public constant INVALID_MESSAGE = \\\"43\\\";\\n    string public constant TOO_MUCH_VOLATILITY = \\\"44\\\";\\n    string public constant WETH_ADDRESS_NOT_FIRST = \\\"44\\\";\\n    string public constant ROOT_PRICE_NOT_GROUNDED = \\\"45\\\";\\n    string public constant NOT_ENOUGH_TWAPS = \\\"46\\\";\\n    string public constant ZERO_PRICE_TWAP = \\\"47\\\";\\n    string public constant INVALID_NUMBER_WEIGHTS = \\\"48\\\";\\n    string public constant NO_WETH_PRICE = \\\"49\\\";\\n\\n    //Vault safety check related errors\\n    string public constant A_VAULT_HAS_ALL_STABLECOINS_OFF_PEG = \\\"51\\\";\\n    string public constant NOT_SAFE_TO_MINT = \\\"52\\\";\\n    string public constant NOT_SAFE_TO_REDEEM = \\\"53\\\";\\n    string public constant AMOUNT_AND_PRICE_LENGTH_DIFFER = \\\"54\\\";\\n    string public constant TOKEN_PRICES_TOO_SMALL = \\\"55\\\";\\n    string public constant TRYING_TO_REDEEM_MORE_THAN_VAULT_CONTAINS = \\\"56\\\";\\n    string public constant CALLER_NOT_MOTHERBOARD = \\\"57\\\";\\n    string public constant CALLER_NOT_RESERVE_MANAGER = \\\"58\\\";\\n    string public constant VAULT_CANNOT_BE_REMOVED = \\\"59\\\";\\n\\n    string public constant VAULT_FLOW_TOO_HIGH = \\\"60\\\";\\n    string public constant OPERATION_SUCCEEDS_BUT_SAFETY_MODE_ACTIVATED = \\\"61\\\";\\n    string public constant ORACLE_GUARDIAN_TIME_LIMIT = \\\"62\\\";\\n    string public constant NOT_ENOUGH_FLOW_DATA = \\\"63\\\";\\n    string public constant SUPPLY_CAP_EXCEEDED = \\\"64\\\";\\n    string public constant SAFETY_MODE_ACTIVATED = \\\"65\\\";\\n\\n    // misc errors\\n    string public constant REDEEM_AMOUNT_BUG = \\\"100\\\";\\n    string public constant EXTERNAL_ACTION_FAILED = \\\"101\\\";\\n    string public constant TOKENS_NOT_SORTED = \\\"102\\\";\\n    string public constant NO_SHARES_MINTED = \\\"103\\\";\\n    string public constant TRYING_TO_REDEEM_MORE_THAN_SUPPLY = \\\"104\\\";\\n}\\n\"\r\n    },\r\n    \"IGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\ninterface IGovernable {\\n    /// @notice Emmited when the governor is changed\\n    event GovernorChanged(address oldGovernor, address newGovernor);\\n\\n    /// @notice Emmited when the governor is change is requested\\n    event GovernorChangeRequested(address newGovernor);\\n\\n    /// @notice Returns the current governor\\n    function governor() external view returns (address);\\n\\n    /// @notice Returns the pending governor\\n    function pendingGovernor() external view returns (address);\\n\\n    /// @notice Changes the governor\\n    /// can only be called by the current governor\\n    function changeGovernor(address newGovernor) external;\\n\\n    /// @notice Called by the pending governor to approve the change\\n    function acceptGovernance() external;\\n}\\n\"\r\n    },\r\n    \"IUSDPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\ninterface IUSDPriceOracle {\\n    /// @notice Quotes the USD price of `tokenAddress`\\n    /// The quoted price is always scaled with 18 decimals regardless of the\\n    /// source used for the oracle.\\n    /// @param tokenAddress the asset of which the price is to be quoted\\n    /// @return the USD price of the asset\\n    function getPriceUSD(address tokenAddress) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"ChainlinkAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface AggregatorInterface {\\n    function latestAnswer() external view returns (int256);\\n\\n    function latestTimestamp() external view returns (uint256);\\n\\n    function latestRound() external view returns (uint256);\\n\\n    function getAnswer(uint256 roundId) external view returns (int256);\\n\\n    function getTimestamp(uint256 roundId) external view returns (uint256);\\n}\\n\\ninterface AggregatorV3Interface {\\n    event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\n    event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function description() external view returns (string memory);\\n\\n    function version() external view returns (uint256);\\n\\n    // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n    // if they do not have data to report, instead of returning unset values\\n    // which could be misinterpreted as actual reported values.\\n    function getRoundData(uint80 _roundId)\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n}\\n\"\r\n    },\r\n    \"DecimalScale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LicenseRef-Gyro-1.0\\n// for information on licensing please see the README in the GitHub repository <https://github.com/gyrostable/core-protocol>.\\npragma solidity ^0.8.4;\\n\\nlibrary DecimalScale {\\n    uint8 internal constant DECIMALS = 18; // 18 decimal places\\n\\n    function scaleFrom(uint256 value, uint8 decimals) internal pure returns (uint256) {\\n        if (decimals == DECIMALS) {\\n            return value;\\n        } else if (decimals > DECIMALS) {\\n            return value / 10**(decimals - DECIMALS);\\n        } else {\\n            return value * 10**(DECIMALS - decimals);\\n        }\\n    }\\n\\n    function scaleTo(uint256 value, uint8 decimals) internal pure returns (uint256) {\\n        if (decimals == DECIMALS) {\\n            return value;\\n        } else if (decimals > DECIMALS) {\\n            return value * 10**(decimals - DECIMALS);\\n        } else {\\n            return value / 10**(DECIMALS - decimals);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"ChainLinkPriceOracle.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governor\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousFeed\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newFeed\",\"type\":\"address\"}],\"name\":\"FeedUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"GovernorChangeRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldGovernor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"GovernorChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_LAG\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"changeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeds\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getPriceUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listSupportedAssets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingGovernor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feed\",\"type\":\"address\"}],\"name\":\"setFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ChainlinkPriceOracle", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004f244fcaff67a2f98eaec20a44caf079a7f7a1d4", "EVMVersion": "london", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}