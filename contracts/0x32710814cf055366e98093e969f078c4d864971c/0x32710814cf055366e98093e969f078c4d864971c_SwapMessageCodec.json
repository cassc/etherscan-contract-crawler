{"SourceCode": "struct SwapMessage {\r\n    uint32 version;\r\n    bytes32 bridgeNonceHash;\r\n    uint256 sellAmount;\r\n    bytes32 buyToken;\r\n    uint256 guaranteedBuyAmount;\r\n    bytes32 recipient;\r\n}\r\n\r\nlibrary SwapMessageCodec {\r\n    using LibBytes for *;\r\n\r\n    uint8 public constant VERSION_END_INDEX = 4;\r\n    uint8 public constant BRIDGENONCEHASH_END_INDEX = 36;\r\n    uint8 public constant SELLAMOUNT_END_INDEX = 68;\r\n    uint8 public constant BUYTOKEN_END_INDEX = 100;\r\n    uint8 public constant BUYAMOUNT_END_INDEX = 132;\r\n    uint8 public constant RECIPIENT_END_INDEX = 164;\r\n\r\n    function encode(\r\n        SwapMessage memory swapMessage\r\n    ) public pure returns (bytes memory) {\r\n        return\r\n            abi.encodePacked(\r\n                swapMessage.version,\r\n                swapMessage.bridgeNonceHash,\r\n                swapMessage.sellAmount,\r\n                swapMessage.buyToken,\r\n                swapMessage.guaranteedBuyAmount,\r\n                swapMessage.recipient\r\n            );\r\n    }\r\n\r\n    function decode(\r\n        bytes memory message\r\n    ) public pure returns (SwapMessage memory) {\r\n        uint32 version;\r\n        bytes32 bridgeNonceHash;\r\n        uint256 sellAmount;\r\n        bytes32 buyToken;\r\n        uint256 guaranteedBuyAmount;\r\n        bytes32 recipient;\r\n        assembly {\r\n            version := mload(add(message, VERSION_END_INDEX))\r\n            bridgeNonceHash := mload(add(message, BRIDGENONCEHASH_END_INDEX))\r\n            sellAmount := mload(add(message, SELLAMOUNT_END_INDEX))\r\n            buyToken := mload(add(message, BUYTOKEN_END_INDEX))\r\n            guaranteedBuyAmount := mload(add(message, BUYAMOUNT_END_INDEX))\r\n            recipient := mload(add(message, RECIPIENT_END_INDEX))\r\n        }\r\n        return\r\n            SwapMessage(\r\n                version,\r\n                bridgeNonceHash,\r\n                sellAmount,\r\n                buyToken,\r\n                guaranteedBuyAmount,\r\n                recipient\r\n            );\r\n    }\r\n}\r\n\r\nlibrary LibBytes {\r\n    function addressToBytes32(address addr) external pure returns (bytes32) {\r\n        return bytes32(uint256(uint160(addr)));\r\n    }\r\n\r\n    function bytes32ToAddress(bytes32 _buf) public pure returns (address) {\r\n        return address(uint160(uint256(_buf)));\r\n    }\r\n\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint256 _start,\r\n        uint256 _length\r\n    ) internal pure returns (bytes memory) {\r\n        require(_length + 31 >= _length, \"slice_overflow\");\r\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                tempBytes := mload(0x40)\r\n\r\n                let lengthmod := and(_length, 31)\r\n\r\n                let mc := add(\r\n                    add(tempBytes, lengthmod),\r\n                    mul(0x20, iszero(lengthmod))\r\n                )\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    let cc := add(\r\n                        add(\r\n                            add(_bytes, lengthmod),\r\n                            mul(0x20, iszero(lengthmod))\r\n                        ),\r\n                        _start\r\n                    )\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            default {\r\n                tempBytes := mload(0x40)\r\n                mstore(tempBytes, 0)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"name\":\"BRIDGENONCEHASH_END_INDEX\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BUYAMOUNT_END_INDEX\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BUYTOKEN_END_INDEX\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RECIPIENT_END_INDEX\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SELLAMOUNT_END_INDEX\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION_END_INDEX\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"decode\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"version\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"bridgeNonceHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"buyToken\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"guaranteedBuyAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"}],\"internalType\":\"struct SwapMessage\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"version\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"bridgeNonceHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"buyToken\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"guaranteedBuyAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"}],\"internalType\":\"struct SwapMessage\",\"name\":\"swapMessage\",\"type\":\"tuple\"}],\"name\":\"encode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "SwapMessageCodec", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1badbaca78166da963400035ead7abd652acb159cd12006befd6c40e45b2527d"}