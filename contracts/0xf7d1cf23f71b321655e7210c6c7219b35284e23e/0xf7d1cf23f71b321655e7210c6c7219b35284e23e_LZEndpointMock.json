{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/test/lz/LZEndpointMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.12;\\n\\nimport \\\"./interfaces/ILayerZeroReceiver.sol\\\";\\nimport \\\"./interfaces/ILayerZeroEndpoint.sol\\\";\\n\\n/*\\nmocking multi endpoint connection.\\n- send() will short circuit to lzReceive() directly\\n- no reentrancy guard. the real LayerZero endpoint on main net has a send and receive guard, respectively.\\nif we run a ping-pong-like application, the recursive call might use all gas limit in the block.\\n- not using any messaging library, hence all messaging library func, e.g. estimateFees, version, will not work\\n*/\\ncontract LZEndpointMock is ILayerZeroEndpoint {\\n\\tmapping(address => address) public lzEndpointLookup;\\n\\n\\tuint16 public mockChainId;\\n\\taddress payable public mockOracle;\\n\\taddress payable public mockRelayer;\\n\\tuint public mockBlockConfirmations;\\n\\tuint16 public mockLibraryVersion;\\n\\tuint public mockStaticNativeFee;\\n\\tuint16 public mockLayerZeroVersion;\\n\\tuint public nativeFee;\\n\\tuint public zroFee;\\n\\tbool nextMsgBLocked;\\n\\n\\tstruct StoredPayload {\\n\\t\\tuint64 payloadLength;\\n\\t\\taddress dstAddress;\\n\\t\\tbytes32 payloadHash;\\n\\t}\\n\\n\\tstruct QueuedPayload {\\n\\t\\taddress dstAddress;\\n\\t\\tuint64 nonce;\\n\\t\\tbytes payload;\\n\\t}\\n\\n\\t// inboundNonce = [srcChainId][srcAddress].\\n\\tmapping(uint16 => mapping(bytes => uint64)) public inboundNonce;\\n\\t// outboundNonce = [dstChainId][srcAddress].\\n\\tmapping(uint16 => mapping(address => uint64)) public outboundNonce;\\n\\t// storedPayload = [srcChainId][srcAddress]\\n\\tmapping(uint16 => mapping(bytes => StoredPayload)) public storedPayload;\\n\\t// msgToDeliver = [srcChainId][srcAddress]\\n\\tmapping(uint16 => mapping(bytes => QueuedPayload[])) public msgsToDeliver;\\n\\n\\tevent UaForceResumeReceive(uint16 chainId, bytes srcAddress);\\n\\tevent PayloadCleared(uint16 srcChainId, bytes srcAddress, uint64 nonce, address dstAddress);\\n\\tevent PayloadStored(\\n\\t\\tuint16 srcChainId,\\n\\t\\tbytes srcAddress,\\n\\t\\taddress dstAddress,\\n\\t\\tuint64 nonce,\\n\\t\\tbytes payload,\\n\\t\\tbytes reason\\n\\t);\\n\\n\\tconstructor(uint16 _chainId) {\\n\\t\\tmockStaticNativeFee = 42;\\n\\t\\tmockLayerZeroVersion = 1;\\n\\t\\tmockChainId = _chainId;\\n\\t}\\n\\n\\t// mock helper to set the value returned by `estimateNativeFees`\\n\\tfunction setEstimatedFees(uint _nativeFee, uint _zroFee) public {\\n\\t\\tnativeFee = _nativeFee;\\n\\t\\tzroFee = _zroFee;\\n\\t}\\n\\n\\tfunction getChainId() external view override returns (uint16) {\\n\\t\\treturn mockChainId;\\n\\t}\\n\\n\\tfunction setDestLzEndpoint(address destAddr, address lzEndpointAddr) external {\\n\\t\\tlzEndpointLookup[destAddr] = lzEndpointAddr;\\n\\t}\\n\\n\\tfunction send(\\n\\t\\tuint16 _chainId,\\n\\t\\tbytes calldata _destination,\\n\\t\\tbytes calldata _payload,\\n\\t\\taddress payable, // _refundAddress\\n\\t\\taddress, // _zroPaymentAddress\\n\\t\\tbytes memory _adapterParams\\n\\t) external payable override {\\n\\t\\taddress destAddr = packedBytesToAddr(_destination);\\n\\t\\taddress lzEndpoint = lzEndpointLookup[destAddr];\\n\\n\\t\\trequire(lzEndpoint != address(0), \\\"LayerZeroMock: destination LayerZero Endpoint not found\\\");\\n\\n\\t\\trequire(msg.value >= nativeFee * _payload.length, \\\"LayerZeroMock: not enough native for fees\\\");\\n\\n\\t\\tuint64 nonce;\\n\\t\\t{\\n\\t\\t\\tnonce = ++outboundNonce[_chainId][msg.sender];\\n\\t\\t}\\n\\n\\t\\t// Mock the relayer paying the dstNativeAddr the amount of extra native token\\n\\t\\t{\\n\\t\\t\\tuint extraGas;\\n\\t\\t\\tuint dstNative;\\n\\t\\t\\taddress dstNativeAddr;\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\textraGas := mload(add(_adapterParams, 34))\\n\\t\\t\\t\\tdstNative := mload(add(_adapterParams, 66))\\n\\t\\t\\t\\tdstNativeAddr := mload(add(_adapterParams, 86))\\n\\t\\t\\t}\\n\\n\\t\\t\\t// to simulate actually sending the ether, add a transfer call and ensure the LZEndpointMock contract has an ether balance\\n\\t\\t}\\n\\n\\t\\tbytes memory bytesSourceUserApplicationAddr = addrToPackedBytes(address(msg.sender)); // cast this address to bytes\\n\\n\\t\\t// not using the extra gas parameter because this is a single tx call, not split between different chains\\n\\t\\t// LZEndpointMock(lzEndpoint).receivePayload(mockChainId, bytesSourceUserApplicationAddr, destAddr, nonce, extraGas, _payload);\\n\\t\\tLZEndpointMock(lzEndpoint).receivePayload(\\n\\t\\t\\tmockChainId,\\n\\t\\t\\tbytesSourceUserApplicationAddr,\\n\\t\\t\\tdestAddr,\\n\\t\\t\\tnonce,\\n\\t\\t\\t0,\\n\\t\\t\\t_payload\\n\\t\\t);\\n\\t}\\n\\n\\tfunction receivePayload(\\n\\t\\tuint16 _srcChainId,\\n\\t\\tbytes calldata _srcAddress,\\n\\t\\taddress _dstAddress,\\n\\t\\tuint64 _nonce,\\n\\t\\tuint /*_gasLimit*/,\\n\\t\\tbytes calldata _payload\\n\\t) external override {\\n\\t\\tStoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\\n\\n\\t\\t// assert and increment the nonce. no message shuffling\\n\\t\\trequire(_nonce == ++inboundNonce[_srcChainId][_srcAddress], \\\"LayerZero: wrong nonce\\\");\\n\\n\\t\\t// queue the following msgs inside of a stack to simulate a successful send on src, but not fully delivered on dst\\n\\t\\tif (sp.payloadHash != bytes32(0)) {\\n\\t\\t\\tQueuedPayload[] storage msgs = msgsToDeliver[_srcChainId][_srcAddress];\\n\\t\\t\\tQueuedPayload memory newMsg = QueuedPayload(_dstAddress, _nonce, _payload);\\n\\n\\t\\t\\t// warning, might run into gas issues trying to forward through a bunch of queued msgs\\n\\t\\t\\t// shift all the msgs over so we can treat this like a fifo via array.pop()\\n\\t\\t\\tif (msgs.length > 0) {\\n\\t\\t\\t\\t// extend the array\\n\\t\\t\\t\\tmsgs.push(newMsg);\\n\\n\\t\\t\\t\\t// shift all the indexes up for pop()\\n\\t\\t\\t\\tfor (uint i = 0; i < msgs.length - 1; i++) {\\n\\t\\t\\t\\t\\tmsgs[i + 1] = msgs[i];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// put the newMsg at the bottom of the stack\\n\\t\\t\\t\\tmsgs[0] = newMsg;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmsgs.push(newMsg);\\n\\t\\t\\t}\\n\\t\\t} else if (nextMsgBLocked) {\\n\\t\\t\\tstoredPayload[_srcChainId][_srcAddress] = StoredPayload(\\n\\t\\t\\t\\tuint64(_payload.length),\\n\\t\\t\\t\\t_dstAddress,\\n\\t\\t\\t\\tkeccak256(_payload)\\n\\t\\t\\t);\\n\\t\\t\\temit PayloadStored(_srcChainId, _srcAddress, _dstAddress, _nonce, _payload, bytes(\\\"\\\"));\\n\\t\\t\\t// ensure the next msgs that go through are no longer blocked\\n\\t\\t\\tnextMsgBLocked = false;\\n\\t\\t} else {\\n\\t\\t\\t// we ignore the gas limit because this call is made in one tx due to being \\\"same chain\\\"\\n\\t\\t\\t// ILayerZeroReceiver(_dstAddress).lzReceive{gas: _gasLimit}(_srcChainId, _srcAddress, _nonce, _payload); // invoke lzReceive\\n\\t\\t\\tILayerZeroReceiver(_dstAddress).lzReceive(_srcChainId, _srcAddress, _nonce, _payload); // invoke lzReceive\\n\\t\\t}\\n\\t}\\n\\n\\t// used to simulate messages received get stored as a payload\\n\\tfunction blockNextMsg() external {\\n\\t\\tnextMsgBLocked = true;\\n\\t}\\n\\n\\tfunction getLengthOfQueue(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint) {\\n\\t\\treturn msgsToDeliver[_srcChainId][_srcAddress].length;\\n\\t}\\n\\n\\t// @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\\n\\t// @param _dstChainId - the destination chain identifier\\n\\t// @param _userApplication - the user app address on this EVM chain\\n\\t// @param _payload - the custom message to send over LayerZero\\n\\t// @param _payInZRO - if false, user app pays the protocol fee in native token\\n\\t// @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\\n\\tfunction estimateFees(\\n\\t\\tuint16,\\n\\t\\taddress,\\n\\t\\tbytes memory _payload,\\n\\t\\tbool,\\n\\t\\tbytes memory\\n\\t) external view override returns (uint _nativeFee, uint _zroFee) {\\n\\t\\t_nativeFee = nativeFee * _payload.length;\\n\\t\\t_zroFee = zroFee;\\n\\t}\\n\\n\\t// give 20 bytes, return the decoded address\\n\\tfunction packedBytesToAddr(bytes calldata _b) public pure returns (address) {\\n\\t\\taddress addr;\\n\\t\\tassembly {\\n\\t\\t\\tlet ptr := mload(0x40)\\n\\t\\t\\tcalldatacopy(ptr, sub(_b.offset, 2), add(_b.length, 2))\\n\\t\\t\\taddr := mload(sub(ptr, 10))\\n\\t\\t}\\n\\t\\treturn addr;\\n\\t}\\n\\n\\t// given an address, return the 20 bytes\\n\\tfunction addrToPackedBytes(address _a) public pure returns (bytes memory) {\\n\\t\\tbytes memory data = abi.encodePacked(_a);\\n\\t\\treturn data;\\n\\t}\\n\\n\\tfunction setConfig(\\n\\t\\tuint16 /*_version*/,\\n\\t\\tuint16 /*_chainId*/,\\n\\t\\tuint /*_configType*/,\\n\\t\\tbytes memory /*_config*/\\n\\t) external override {}\\n\\n\\tfunction getConfig(\\n\\t\\tuint16 /*_version*/,\\n\\t\\tuint16 /*_chainId*/,\\n\\t\\taddress /*_ua*/,\\n\\t\\tuint /*_configType*/\\n\\t) external pure override returns (bytes memory) {\\n\\t\\treturn \\\"\\\";\\n\\t}\\n\\n\\tfunction setSendVersion(uint16 /*version*/) external override {}\\n\\n\\tfunction setReceiveVersion(uint16 /*version*/) external override {}\\n\\n\\tfunction getSendVersion(address /*_userApplication*/) external pure override returns (uint16) {\\n\\t\\treturn 1;\\n\\t}\\n\\n\\tfunction getReceiveVersion(address /*_userApplication*/) external pure override returns (uint16) {\\n\\t\\treturn 1;\\n\\t}\\n\\n\\tfunction getInboundNonce(uint16 _chainID, bytes calldata _srcAddress) external view override returns (uint64) {\\n\\t\\treturn inboundNonce[_chainID][_srcAddress];\\n\\t}\\n\\n\\tfunction getOutboundNonce(uint16 _chainID, address _srcAddress) external view override returns (uint64) {\\n\\t\\treturn outboundNonce[_chainID][_srcAddress];\\n\\t}\\n\\n\\t// simulates the relayer pushing through the rest of the msgs that got delayed due to the stored payload\\n\\tfunction _clearMsgQue(uint16 _srcChainId, bytes calldata _srcAddress) internal {\\n\\t\\tQueuedPayload[] storage msgs = msgsToDeliver[_srcChainId][_srcAddress];\\n\\n\\t\\t// warning, might run into gas issues trying to forward through a bunch of queued msgs\\n\\t\\twhile (msgs.length > 0) {\\n\\t\\t\\tQueuedPayload memory payload = msgs[msgs.length - 1];\\n\\t\\t\\tILayerZeroReceiver(payload.dstAddress).lzReceive(_srcChainId, _srcAddress, payload.nonce, payload.payload);\\n\\t\\t\\tmsgs.pop();\\n\\t\\t}\\n\\t}\\n\\n\\tfunction forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\\n\\t\\tStoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\\n\\t\\t// revert if no messages are cached. safeguard malicious UA behaviour\\n\\t\\trequire(sp.payloadHash != bytes32(0), \\\"LayerZero: no stored payload\\\");\\n\\t\\trequire(sp.dstAddress == msg.sender, \\\"LayerZero: invalid caller\\\");\\n\\n\\t\\t// empty the storedPayload\\n\\t\\tsp.payloadLength = 0;\\n\\t\\tsp.dstAddress = address(0);\\n\\t\\tsp.payloadHash = bytes32(0);\\n\\n\\t\\temit UaForceResumeReceive(_srcChainId, _srcAddress);\\n\\n\\t\\t// resume the receiving of msgs after we force clear the \\\"stuck\\\" msg\\n\\t\\t_clearMsgQue(_srcChainId, _srcAddress);\\n\\t}\\n\\n\\tfunction retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external override {\\n\\t\\tStoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\\n\\t\\trequire(sp.payloadHash != bytes32(0), \\\"LayerZero: no stored payload\\\");\\n\\t\\trequire(\\n\\t\\t\\t_payload.length == sp.payloadLength && keccak256(_payload) == sp.payloadHash,\\n\\t\\t\\t\\\"LayerZero: invalid payload\\\"\\n\\t\\t);\\n\\n\\t\\taddress dstAddress = sp.dstAddress;\\n\\t\\t// empty the storedPayload\\n\\t\\tsp.payloadLength = 0;\\n\\t\\tsp.dstAddress = address(0);\\n\\t\\tsp.payloadHash = bytes32(0);\\n\\n\\t\\tuint64 nonce = inboundNonce[_srcChainId][_srcAddress];\\n\\n\\t\\tILayerZeroReceiver(dstAddress).lzReceive(_srcChainId, _srcAddress, nonce, _payload);\\n\\t\\temit PayloadCleared(_srcChainId, _srcAddress, nonce, dstAddress);\\n\\t}\\n\\n\\tfunction hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view override returns (bool) {\\n\\t\\tStoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\\n\\t\\treturn sp.payloadHash != bytes32(0);\\n\\t}\\n\\n\\tfunction isSendingPayload() external pure override returns (bool) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tfunction isReceivingPayload() external pure override returns (bool) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tfunction getSendLibraryAddress(address) external view override returns (address) {\\n\\t\\treturn address(this);\\n\\t}\\n\\n\\tfunction getReceiveLibraryAddress(address) external view override returns (address) {\\n\\t\\treturn address(this);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/test/lz/interfaces/ILayerZeroEndpoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\nimport \\\"./ILayerZeroUserApplicationConfig.sol\\\";\\n\\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\\n\\t// @notice send a LayerZero message to the specified address at a LayerZero endpoint.\\n\\t// @param _dstChainId - the destination chain identifier\\n\\t// @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\\n\\t// @param _payload - a custom bytes payload to send to the destination contract\\n\\t// @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\\n\\t// @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\\n\\t// @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\\n\\tfunction send(\\n\\t\\tuint16 _dstChainId,\\n\\t\\tbytes calldata _destination,\\n\\t\\tbytes calldata _payload,\\n\\t\\taddress payable _refundAddress,\\n\\t\\taddress _zroPaymentAddress,\\n\\t\\tbytes calldata _adapterParams\\n\\t) external payable;\\n\\n\\t// @notice used by the messaging library to publish verified payload\\n\\t// @param _srcChainId - the source chain identifier\\n\\t// @param _srcAddress - the source contract (as bytes) at the source chain\\n\\t// @param _dstAddress - the address on destination chain\\n\\t// @param _nonce - the unbound message ordering nonce\\n\\t// @param _gasLimit - the gas limit for external contract execution\\n\\t// @param _payload - verified payload to send to the destination contract\\n\\tfunction receivePayload(\\n\\t\\tuint16 _srcChainId,\\n\\t\\tbytes calldata _srcAddress,\\n\\t\\taddress _dstAddress,\\n\\t\\tuint64 _nonce,\\n\\t\\tuint _gasLimit,\\n\\t\\tbytes calldata _payload\\n\\t) external;\\n\\n\\t// @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\\n\\t// @param _srcChainId - the source chain identifier\\n\\t// @param _srcAddress - the source chain contract address\\n\\tfunction getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\\n\\n\\t// @notice get the outboundNonce from this source chain which, consequently, is always an EVM\\n\\t// @param _srcAddress - the source chain contract address\\n\\tfunction getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\\n\\n\\t// @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\\n\\t// @param _dstChainId - the destination chain identifier\\n\\t// @param _userApplication - the user app address on this EVM chain\\n\\t// @param _payload - the custom message to send over LayerZero\\n\\t// @param _payInZRO - if false, user app pays the protocol fee in native token\\n\\t// @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\\n\\tfunction estimateFees(\\n\\t\\tuint16 _dstChainId,\\n\\t\\taddress _userApplication,\\n\\t\\tbytes calldata _payload,\\n\\t\\tbool _payInZRO,\\n\\t\\tbytes calldata _adapterParam\\n\\t) external view returns (uint nativeFee, uint zroFee);\\n\\n\\t// @notice get this Endpoint's immutable source identifier\\n\\tfunction getChainId() external view returns (uint16);\\n\\n\\t// @notice the interface to retry failed message on this Endpoint destination\\n\\t// @param _srcChainId - the source chain identifier\\n\\t// @param _srcAddress - the source chain contract address\\n\\t// @param _payload - the payload to be retried\\n\\tfunction retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\\n\\n\\t// @notice query if any STORED payload (message blocking) at the endpoint.\\n\\t// @param _srcChainId - the source chain identifier\\n\\t// @param _srcAddress - the source chain contract address\\n\\tfunction hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\\n\\n\\t// @notice query if the _libraryAddress is valid for sending msgs.\\n\\t// @param _userApplication - the user app address on this EVM chain\\n\\tfunction getSendLibraryAddress(address _userApplication) external view returns (address);\\n\\n\\t// @notice query if the _libraryAddress is valid for receiving msgs.\\n\\t// @param _userApplication - the user app address on this EVM chain\\n\\tfunction getReceiveLibraryAddress(address _userApplication) external view returns (address);\\n\\n\\t// @notice query if the non-reentrancy guard for send() is on\\n\\t// @return true if the guard is on. false otherwise\\n\\tfunction isSendingPayload() external view returns (bool);\\n\\n\\t// @notice query if the non-reentrancy guard for receive() is on\\n\\t// @return true if the guard is on. false otherwise\\n\\tfunction isReceivingPayload() external view returns (bool);\\n\\n\\t// @notice get the configuration of the LayerZero messaging library of the specified version\\n\\t// @param _version - messaging library version\\n\\t// @param _chainId - the chainId for the pending config change\\n\\t// @param _userApplication - the contract address of the user application\\n\\t// @param _configType - type of configuration. every messaging library has its own convention.\\n\\tfunction getConfig(\\n\\t\\tuint16 _version,\\n\\t\\tuint16 _chainId,\\n\\t\\taddress _userApplication,\\n\\t\\tuint _configType\\n\\t) external view returns (bytes memory);\\n\\n\\t// @notice get the send() LayerZero messaging library version\\n\\t// @param _userApplication - the contract address of the user application\\n\\tfunction getSendVersion(address _userApplication) external view returns (uint16);\\n\\n\\t// @notice get the lzReceive() LayerZero messaging library version\\n\\t// @param _userApplication - the contract address of the user application\\n\\tfunction getReceiveVersion(address _userApplication) external view returns (uint16);\\n}\\n\"\r\n    },\r\n    \"contracts/test/lz/interfaces/ILayerZeroReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\ninterface ILayerZeroReceiver {\\n\\t// @notice LayerZero endpoint will invoke this function to deliver the message on the destination\\n\\t// @param _srcChainId - the source endpoint identifier\\n\\t// @param _srcAddress - the source sending contract address from the source chain\\n\\t// @param _nonce - the ordered message nonce\\n\\t// @param _payload - the signed payload is the UA bytes has encoded to be sent\\n\\tfunction lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\\n}\\n\"\r\n    },\r\n    \"contracts/test/lz/interfaces/ILayerZeroUserApplicationConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.5.0;\\n\\ninterface ILayerZeroUserApplicationConfig {\\n\\t// @notice set the configuration of the LayerZero messaging library of the specified version\\n\\t// @param _version - messaging library version\\n\\t// @param _chainId - the chainId for the pending config change\\n\\t// @param _configType - type of configuration. every messaging library has its own convention.\\n\\t// @param _config - configuration in the bytes. can encode arbitrary content.\\n\\tfunction setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\\n\\n\\t// @notice set the send() LayerZero messaging library version to _version\\n\\t// @param _version - new messaging library version\\n\\tfunction setSendVersion(uint16 _version) external;\\n\\n\\t// @notice set the lzReceive() LayerZero messaging library version to _version\\n\\t// @param _version - new messaging library version\\n\\tfunction setReceiveVersion(uint16 _version) external;\\n\\n\\t// @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\\n\\t// @param _srcChainId - the chainId of the source chain\\n\\t// @param _srcAddress - the contract address of the source contract at the source chain\\n\\tfunction forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_chainId\",\"type\":\"uint16\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"srcAddress\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dstAddress\",\"type\":\"address\"}],\"name\":\"PayloadCleared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"srcAddress\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dstAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"reason\",\"type\":\"bytes\"}],\"name\":\"PayloadStored\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"srcAddress\",\"type\":\"bytes\"}],\"name\":\"UaForceResumeReceive\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"}],\"name\":\"addrToPackedBytes\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockNextMsg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"estimateFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_nativeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_zroFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"}],\"name\":\"forceResumeReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_chainID\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"}],\"name\":\"getInboundNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"}],\"name\":\"getLengthOfQueue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_chainID\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_srcAddress\",\"type\":\"address\"}],\"name\":\"getOutboundNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getReceiveLibraryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getReceiveVersion\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getSendLibraryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getSendVersion\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"}],\"name\":\"hasStoredPayload\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"inboundNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isReceivingPayload\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSendingPayload\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lzEndpointLookup\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mockBlockConfirmations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mockChainId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mockLayerZeroVersion\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mockLibraryVersion\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mockOracle\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mockRelayer\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mockStaticNativeFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"msgsToDeliver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"dstAddress\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"outboundNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_b\",\"type\":\"bytes\"}],\"name\":\"packedBytesToAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_dstAddress\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"receivePayload\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"retryPayload\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_chainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_destination\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"},{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_adapterParams\",\"type\":\"bytes\"}],\"name\":\"send\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"destAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lzEndpointAddr\",\"type\":\"address\"}],\"name\":\"setDestLzEndpoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nativeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_zroFee\",\"type\":\"uint256\"}],\"name\":\"setEstimatedFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"setReceiveVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"setSendVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"storedPayload\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"payloadLength\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"dstAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zroFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LZEndpointMock", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000001", "EVMVersion": "london", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}