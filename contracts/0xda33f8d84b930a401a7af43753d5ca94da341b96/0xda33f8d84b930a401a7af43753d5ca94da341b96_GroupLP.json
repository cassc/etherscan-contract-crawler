{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/GroupLP.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\r\\n\\r\\nimport '@uniswap/v2-periphery/contracts/interfaces/IERC20.sol';\\r\\nimport '@uniswap/v2-periphery/contracts/interfaces/IWETH.sol';\\r\\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\\r\\nimport '@uniswap/lib/contracts/libraries/TransferHelper.sol';\\r\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\r\\n\\r\\ninterface IOptiVault {\\r\\n  function initialize(address _token, uint256 _lockupDate, uint256 _minimumTokenCommitment, uint256 _withdrawalsLockedUntilTimestamp, address _balanceLookup) external;\\r\\n}\\r\\n\\r\\ncontract GroupLP {\\r\\n  receive() external payable {}\\r\\n\\r\\n  address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\r\\n  address private constant operations = 0x133A5437951EE1D312fD36a74481987Ec4Bf8A96;\\r\\n  address private constant optiVaultMaster = 0xC5A00A96E6a7039daD5af5c41584469048B26038; // Address to clone OptiVault from\\r\\n\\r\\n  IERC20 public token;                                   // Token to add LP for\\r\\n  address public tokenSupplier;                          // Supplier of token\\r\\n  uint256 public committedTokenAmount;                   // Amount to match\\r\\n  uint256 public goalDate;                               // Date by which to complete the campaign\\r\\n  uint256 public withdrawalsLockedDuration;              // Proposed duration of OptiVault lock\\r\\n  uint256 public withdrawalsLockedUntilTimestamp;        // End time plus Duration\\r\\n  IUniswapV2Pair private pair;                           // Pair to add to\\r\\n  bool private initialized;                              // Campaign pamaters hav been set\\r\\n  bool public campaignFailed;                            // Allows recovery of ETH under failure conditions\\r\\n\\r\\n  mapping (address => uint256) public ethContributionOf; // Used as numerator for calculating users shares\\r\\n  uint256 public totalFundingRaised;                     // Used as denominator for calculating users shares\\r\\n\\r\\n  uint256 public mintedLP;                               // Amount of LP that has been minted\\r\\n  address public optiVault;                              // cloned OptiVault contract that holds the minted LP\\r\\n\\r\\n  function initialize(address _pair, address _tokenSupplier, uint256 _goalDate, uint256 _withdrawalsLockedDuration,  uint256 _commitment) external payable {\\r\\n    require(!initialized, \\\"GroupLP: Already initialized\\\");\\r\\n    committedTokenAmount = _commitment;\\r\\n    pair = IUniswapV2Pair(_pair);\\r\\n    token = (pair.token0() == WETH) ? IERC20(pair.token1()) : IERC20(pair.token0());\\r\\n    goalDate = _goalDate;\\r\\n    withdrawalsLockedDuration = _withdrawalsLockedDuration;\\r\\n    tokenSupplier = _tokenSupplier;\\r\\n    ethContributionOf[tokenSupplier] = msg.value;\\r\\n    totalFundingRaised = msg.value; \\r\\n    initialized = true;\\r\\n  }\\r\\n\\r\\n  function supplierHasCommitedBalance() public view returns (bool valid) {\\r\\n    // Campaign is valid IFF: (Commited tokens <= Supplier approval <= Supplier balance)\\r\\n    uint256 approval = token.allowance(tokenSupplier, address(this));\\r\\n    uint256 balance = token.balanceOf(tokenSupplier);\\r\\n    valid = committedTokenAmount <= approval && approval <= balance;\\r\\n  }\\r\\n\\r\\n  function getReserves() internal view returns (uint256 ethReserves, uint256 tokenReserves) {\\r\\n    (uint reserveA, uint reserveB, ) = pair.getReserves();\\r\\n    (ethReserves, tokenReserves) = WETH < address(token) ? (reserveA, reserveB) : (reserveB, reserveA);\\r\\n  }\\r\\n\\r\\n  function uniswapQuote(uint amountToken) internal view returns (uint256 amountEth) {\\r\\n    (uint256 ethReserves, uint256 tokenReserves) = getReserves();\\r\\n    amountEth = amountToken * ethReserves / tokenReserves;\\r\\n  }  \\r\\n\\r\\n  function ethMatchEstimate() public view returns (uint256 ethGoal) {\\r\\n    ethGoal = uniswapQuote(committedTokenAmount) * 1005 / 1000;\\r\\n  }\\r\\n\\r\\n  function fund() public payable {\\r\\n    require(supplierHasCommitedBalance(), \\\"GroupLP: Supplier is missing tokens\\\");\\r\\n    require(!campaignFailed, \\\"GroupLP: Campaign failed, use recoverETH\\\");\\r\\n    require((ethMatchEstimate() * 110) / 100 >= address(this).balance, \\\"GroupLP: Over funded!\\\");\\r\\n    ethContributionOf[msg.sender] += msg.value;\\r\\n    totalFundingRaised += msg.value;\\r\\n  }\\r\\n\\r\\n  function endFailedCampaign() public {\\r\\n    // Either the campaign is invalid (token supplier's balance or approval has fallen beneath the committed tokens)\\r\\n    // Or the campaign goalDate is past with no LP created\\r\\n    require(!campaignFailed, \\\"GroupLP: Campaign already failed.\\\");\\r\\n    require(mintedLP == 0, \\\"GroupLP: LP already added!\\\");\\r\\n    bool campaignHasExpired = (block.timestamp > (goalDate + 1 hours));\\r\\n    if (!supplierHasCommitedBalance() || campaignHasExpired) {\\r\\n      campaignFailed = true;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function readyToMint() public view returns (bool ready) {\\r\\n    require(address(this).balance >= ethMatchEstimate(), \\\"GroupLP: Campaign needs more ETH to match supplier's committed tokens\\\");\\r\\n    require(supplierHasCommitedBalance(), \\\"GroupLP: Supplier's token balance or approval has fallen below the required amount.\\\");\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function supplyLP(uint minimumEth) public returns (uint256 amountToken, uint256 amountETH) {\\r\\n    require(msg.sender == operations);\\r\\n    require(readyToMint());\\r\\n    address pairAddress = address(pair);\\r\\n    uint256 tokenBalanceOfPairPreSupply = token.balanceOf(pairAddress);\\r\\n    TransferHelper.safeTransferFrom(address(token), tokenSupplier, pairAddress, committedTokenAmount);\\r\\n    uint256 tokenBalanceOfPairPostSupply = token.balanceOf(pairAddress);\\r\\n    amountToken = tokenBalanceOfPairPostSupply - tokenBalanceOfPairPreSupply; \\r\\n    amountETH = uniswapQuote(amountToken); \\r\\n    require(amountETH >= minimumEth, \\\"GroupLP: Tokens must be valued at least the minimum Eth\\\"); \\r\\n    IWETH(WETH).deposit{value: amountETH}();\\r\\n    assert(IWETH(WETH).transfer(pairAddress, amountETH));\\r\\n\\r\\n    withdrawalsLockedUntilTimestamp = block.timestamp + withdrawalsLockedDuration;\\r\\n    optiVault = Clones.clone(optiVaultMaster);\\r\\n    mintedLP = IUniswapV2Pair(pairAddress).mint(optiVault);\\r\\n    payable(operations).transfer(address(this).balance); //Excess ETH to operations\\r\\n    IOptiVault(optiVault).initialize(pairAddress, 0, 0, withdrawalsLockedUntilTimestamp, address(this));\\r\\n  }\\r\\n\\r\\n  function recoverETH() public {\\r\\n    require(campaignFailed, \\\"GroupLP: Campaign is active. Use withdrawLP.\\\");\\r\\n    require(ethContributionOf[msg.sender] > 0, \\\"GroupLP: You have recovered all your ETH\\\");\\r\\n    payable(msg.sender).transfer(ethContributionOf[msg.sender]);\\r\\n    ethContributionOf[msg.sender] == 0;\\r\\n  }\\r\\n\\r\\n  function contributionOf(address user) external view returns (uint256 _ethBalance) {\\r\\n    _ethBalance = ethContributionOf[user];\\r\\n  }\\r\\n\\r\\n  function sharesOf(address user) external view returns (uint256 _lpTokenShare) {\\r\\n    _lpTokenShare = (mintedLP / 2) * ethContributionOf[user] / totalFundingRaised;\\r\\n    if (user == tokenSupplier) {\\r\\n      _lpTokenShare += mintedLP / 2;\\r\\n    }\\r\\n  }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"campaignFailed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"committedTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"contributionOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_ethBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endFailedCampaign\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ethContributionOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethMatchEstimate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethGoal\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fund\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"goalDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenSupplier\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_goalDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawalsLockedDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_commitment\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintedLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optiVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"readyToMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ready\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"sharesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_lpTokenShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplierHasCommitedBalance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minimumEth\",\"type\":\"uint256\"}],\"name\":\"supplyLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenSupplier\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFundingRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalsLockedDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalsLockedUntilTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GroupLP", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}