{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/interfaces/IERC5267.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\\n\\npragma solidity ^0.8.20;\\n\\ninterface IERC5267 {\\n    /**\\n     * @dev MAY be emitted to signal that the domain could have changed.\\n     */\\n    event EIP712DomainChanged();\\n\\n    /**\\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\\n     * signature.\\n     */\\n    function eip712Domain()\\n        external\\n        view\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainId,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IKeeperOracles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {IERC5267} from '@openzeppelin/contracts/interfaces/IERC5267.sol';\\n\\n/**\\n * @title IKeeperOracles\\n * @author StakeWise\\n * @notice Defines the interface for the KeeperOracles contract\\n */\\ninterface IKeeperOracles is IERC5267 {\\n  /**\\n   * @notice Event emitted on the oracle addition\\n   * @param oracle The address of the added oracle\\n   */\\n  event OracleAdded(address indexed oracle);\\n\\n  /**\\n   * @notice Event emitted on the oracle removal\\n   * @param oracle The address of the removed oracle\\n   */\\n  event OracleRemoved(address indexed oracle);\\n\\n  /**\\n   * @notice Event emitted on oracles config update\\n   * @param configIpfsHash The IPFS hash of the new config\\n   */\\n  event ConfigUpdated(string configIpfsHash);\\n\\n  /**\\n   * @notice Function for verifying whether oracle is registered or not\\n   * @param oracle The address of the oracle to check\\n   * @return `true` for the registered oracle, `false` otherwise\\n   */\\n  function isOracle(address oracle) external view returns (bool);\\n\\n  /**\\n   * @notice Total Oracles\\n   * @return The total number of oracles registered\\n   */\\n  function totalOracles() external view returns (uint256);\\n\\n  /**\\n   * @notice Function for adding oracle to the set\\n   * @param oracle The address of the oracle to add\\n   */\\n  function addOracle(address oracle) external;\\n\\n  /**\\n   * @notice Function for removing oracle from the set\\n   * @param oracle The address of the oracle to remove\\n   */\\n  function removeOracle(address oracle) external;\\n\\n  /**\\n   * @notice Function for updating the config IPFS hash\\n   * @param configIpfsHash The new config IPFS hash\\n   */\\n  function updateConfig(string calldata configIpfsHash) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IKeeperRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {IKeeperOracles} from './IKeeperOracles.sol';\\n\\n/**\\n * @title IKeeperRewards\\n * @author StakeWise\\n * @notice Defines the interface for the Keeper contract rewards\\n */\\ninterface IKeeperRewards is IKeeperOracles {\\n  /**\\n   * @notice Event emitted on rewards update\\n   * @param caller The address of the function caller\\n   * @param rewardsRoot The new rewards merkle tree root\\n   * @param avgRewardPerSecond The new average reward per second\\n   * @param updateTimestamp The update timestamp used for rewards calculation\\n   * @param nonce The nonce used for verifying signatures\\n   * @param rewardsIpfsHash The new rewards IPFS hash\\n   */\\n  event RewardsUpdated(\\n    address indexed caller,\\n    bytes32 indexed rewardsRoot,\\n    uint256 avgRewardPerSecond,\\n    uint64 updateTimestamp,\\n    uint64 nonce,\\n    string rewardsIpfsHash\\n  );\\n\\n  /**\\n   * @notice Event emitted on Vault harvest\\n   * @param vault The address of the Vault\\n   * @param rewardsRoot The rewards merkle tree root\\n   * @param totalAssetsDelta The Vault total assets delta since last sync. Can be negative in case of penalty/slashing.\\n   * @param unlockedMevDelta The Vault execution reward that can be withdrawn from shared MEV escrow. Only used by shared MEV Vaults.\\n   */\\n  event Harvested(\\n    address indexed vault,\\n    bytes32 indexed rewardsRoot,\\n    int256 totalAssetsDelta,\\n    uint256 unlockedMevDelta\\n  );\\n\\n  /**\\n   * @notice Event emitted on rewards min oracles number update\\n   * @param oracles The new minimum number of oracles required to update rewards\\n   */\\n  event RewardsMinOraclesUpdated(uint256 oracles);\\n\\n  /**\\n   * @notice A struct containing the last synced Vault's cumulative reward\\n   * @param assets The Vault cumulative reward earned since the start. Can be negative in case of penalty/slashing.\\n   * @param nonce The nonce of the last sync\\n   */\\n  struct Reward {\\n    int192 assets;\\n    uint64 nonce;\\n  }\\n\\n  /**\\n   * @notice A struct containing the last unlocked Vault's cumulative execution reward that can be withdrawn from shared MEV escrow. Only used by shared MEV Vaults.\\n   * @param assets The shared MEV Vault's cumulative execution reward that can be withdrawn\\n   * @param nonce The nonce of the last sync\\n   */\\n  struct UnlockedMevReward {\\n    uint192 assets;\\n    uint64 nonce;\\n  }\\n\\n  /**\\n   * @notice A struct containing parameters for rewards update\\n   * @param rewardsRoot The new rewards merkle root\\n   * @param avgRewardPerSecond The new average reward per second\\n   * @param updateTimestamp The update timestamp used for rewards calculation\\n   * @param rewardsIpfsHash The new IPFS hash with all the Vaults' rewards for the new root\\n   * @param signatures The concatenation of the Oracles' signatures\\n   */\\n  struct RewardsUpdateParams {\\n    bytes32 rewardsRoot;\\n    uint256 avgRewardPerSecond;\\n    uint64 updateTimestamp;\\n    string rewardsIpfsHash;\\n    bytes signatures;\\n  }\\n\\n  /**\\n   * @notice A struct containing parameters for harvesting rewards. Can only be called by Vault.\\n   * @param rewardsRoot The rewards merkle root\\n   * @param reward The Vault cumulative reward earned since the start. Can be negative in case of penalty/slashing.\\n   * @param unlockedMevReward The Vault cumulative execution reward that can be withdrawn from shared MEV escrow. Only used by shared MEV Vaults.\\n   * @param proof The proof to verify that Vault's reward is correct\\n   */\\n  struct HarvestParams {\\n    bytes32 rewardsRoot;\\n    int160 reward;\\n    uint160 unlockedMevReward;\\n    bytes32[] proof;\\n  }\\n\\n  /**\\n   * @notice Previous Rewards Root\\n   * @return The previous merkle tree root of the rewards accumulated by the Vaults\\n   */\\n  function prevRewardsRoot() external view returns (bytes32);\\n\\n  /**\\n   * @notice Rewards Root\\n   * @return The latest merkle tree root of the rewards accumulated by the Vaults\\n   */\\n  function rewardsRoot() external view returns (bytes32);\\n\\n  /**\\n   * @notice Rewards Nonce\\n   * @return The nonce used for updating rewards merkle tree root\\n   */\\n  function rewardsNonce() external view returns (uint64);\\n\\n  /**\\n   * @notice The last rewards update\\n   * @return The timestamp of the last rewards update\\n   */\\n  function lastRewardsTimestamp() external view returns (uint64);\\n\\n  /**\\n   * @notice The minimum number of oracles required to update rewards\\n   * @return The minimum number of oracles\\n   */\\n  function rewardsMinOracles() external view returns (uint256);\\n\\n  /**\\n   * @notice The rewards delay\\n   * @return The delay in seconds between rewards updates\\n   */\\n  function rewardsDelay() external view returns (uint256);\\n\\n  /**\\n   * @notice Get last synced Vault cumulative reward\\n   * @param vault The address of the Vault\\n   * @return assets The last synced reward assets\\n   * @return nonce The last synced reward nonce\\n   */\\n  function rewards(address vault) external view returns (int192 assets, uint64 nonce);\\n\\n  /**\\n   * @notice Get last unlocked shared MEV Vault cumulative reward\\n   * @param vault The address of the Vault\\n   * @return assets The last synced reward assets\\n   * @return nonce The last synced reward nonce\\n   */\\n  function unlockedMevRewards(address vault) external view returns (uint192 assets, uint64 nonce);\\n\\n  /**\\n   * @notice Checks whether Vault must be harvested\\n   * @param vault The address of the Vault\\n   * @return `true` if the Vault requires harvesting, `false` otherwise\\n   */\\n  function isHarvestRequired(address vault) external view returns (bool);\\n\\n  /**\\n   * @notice Checks whether the Vault can be harvested\\n   * @param vault The address of the Vault\\n   * @return `true` if Vault can be harvested, `false` otherwise\\n   */\\n  function canHarvest(address vault) external view returns (bool);\\n\\n  /**\\n   * @notice Checks whether rewards can be updated\\n   * @return `true` if rewards can be updated, `false` otherwise\\n   */\\n  function canUpdateRewards() external view returns (bool);\\n\\n  /**\\n   * @notice Checks whether the Vault has registered validators\\n   * @param vault The address of the Vault\\n   * @return `true` if Vault is collateralized, `false` otherwise\\n   */\\n  function isCollateralized(address vault) external view returns (bool);\\n\\n  /**\\n   * @notice Update rewards data\\n   * @param params The struct containing rewards update parameters\\n   */\\n  function updateRewards(RewardsUpdateParams calldata params) external;\\n\\n  /**\\n   * @notice Harvest rewards. Can be called only by Vault.\\n   * @param params The struct containing rewards harvesting parameters\\n   * @return totalAssetsDelta The total reward/penalty accumulated by the Vault since the last sync\\n   * @return unlockedMevDelta The Vault execution reward that can be withdrawn from shared MEV escrow. Only used by shared MEV Vaults.\\n   * @return harvested `true` when the rewards were harvested, `false` otherwise\\n   */\\n  function harvest(\\n    HarvestParams calldata params\\n  ) external returns (int256 totalAssetsDelta, uint256 unlockedMevDelta, bool harvested);\\n\\n  /**\\n   * @notice Set min number of oracles for confirming rewards update. Can only be called by the owner.\\n   * @param _rewardsMinOracles The new min number of oracles for confirming rewards update\\n   */\\n  function setRewardsMinOracles(uint256 _rewardsMinOracles) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IKeeperValidators.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {IKeeperRewards} from './IKeeperRewards.sol';\\nimport {IKeeperOracles} from './IKeeperOracles.sol';\\n\\n/**\\n * @title IKeeperValidators\\n * @author StakeWise\\n * @notice Defines the interface for the Keeper validators\\n */\\ninterface IKeeperValidators is IKeeperOracles, IKeeperRewards {\\n  /**\\n   * @notice Event emitted on validators approval\\n   * @param vault The address of the Vault\\n   * @param exitSignaturesIpfsHash The IPFS hash with the validators' exit signatures\\n   */\\n  event ValidatorsApproval(address indexed vault, string exitSignaturesIpfsHash);\\n\\n  /**\\n   * @notice Event emitted on exit signatures update\\n   * @param caller The address of the function caller\\n   * @param vault The address of the Vault\\n   * @param nonce The nonce used for verifying Oracles' signatures\\n   * @param exitSignaturesIpfsHash The IPFS hash with the validators' exit signatures\\n   */\\n  event ExitSignaturesUpdated(\\n    address indexed caller,\\n    address indexed vault,\\n    uint256 nonce,\\n    string exitSignaturesIpfsHash\\n  );\\n\\n  /**\\n   * @notice Event emitted on validators min oracles number update\\n   * @param oracles The new minimum number of oracles required to approve validators\\n   */\\n  event ValidatorsMinOraclesUpdated(uint256 oracles);\\n\\n  /**\\n   * @notice Get nonce for the next vault exit signatures update\\n   * @param vault The address of the Vault to get the nonce for\\n   * @return The nonce of the Vault for updating signatures\\n   */\\n  function exitSignaturesNonces(address vault) external view returns (uint256);\\n\\n  /**\\n   * @notice Struct for approving registration of one or more validators\\n   * @param validatorsRegistryRoot The deposit data root used to verify that oracles approved validators\\n   * @param deadline The deadline for submitting the approval\\n   * @param validators The concatenation of the validators' public key, signature and deposit data root\\n   * @param signatures The concatenation of Oracles' signatures\\n   * @param exitSignaturesIpfsHash The IPFS hash with the validators' exit signatures\\n   */\\n  struct ApprovalParams {\\n    bytes32 validatorsRegistryRoot;\\n    uint256 deadline;\\n    bytes validators;\\n    bytes signatures;\\n    string exitSignaturesIpfsHash;\\n  }\\n\\n  /**\\n   * @notice The minimum number of oracles required to update validators\\n   * @return The minimum number of oracles\\n   */\\n  function validatorsMinOracles() external view returns (uint256);\\n\\n  /**\\n   * @notice Function for approving validators registration\\n   * @param params The parameters for approving validators registration\\n   */\\n  function approveValidators(ApprovalParams calldata params) external;\\n\\n  /**\\n   * @notice Function for updating exit signatures for every hard fork\\n   * @param vault The address of the Vault to update signatures for\\n   * @param deadline The deadline for submitting signatures update\\n   * @param exitSignaturesIpfsHash The IPFS hash with the validators' exit signatures\\n   * @param oraclesSignatures The concatenation of Oracles' signatures\\n   */\\n  function updateExitSignatures(\\n    address vault,\\n    uint256 deadline,\\n    string calldata exitSignaturesIpfsHash,\\n    bytes calldata oraclesSignatures\\n  ) external;\\n\\n  /**\\n   * @notice Function for updating validators min oracles number\\n   * @param _validatorsMinOracles The new minimum number of oracles required to approve validators\\n   */\\n  function setValidatorsMinOracles(uint256 _validatorsMinOracles) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISharedMevEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\n/**\\n * @title ISharedMevEscrow\\n * @author StakeWise\\n * @notice Defines the interface for the SharedMevEscrow contract\\n */\\ninterface ISharedMevEscrow {\\n  /**\\n   * @notice Event emitted on received MEV\\n   * @param assets The amount of MEV assets received\\n   */\\n  event MevReceived(uint256 assets);\\n\\n  /**\\n   * @notice Event emitted on harvest\\n   * @param caller The function caller\\n   * @param assets The amount of assets withdrawn\\n   */\\n  event Harvested(address indexed caller, uint256 assets);\\n\\n  /**\\n   * @notice Withdraws MEV accumulated in the escrow. Can be called only by the Vault.\\n   * @dev IMPORTANT: because control is transferred to the Vault, care must be\\n   *    taken to not create reentrancy vulnerabilities. The Vault must follow the checks-effects-interactions pattern:\\n   *    https://docs.soliditylang.org/en/v0.8.22/security-considerations.html#use-the-checks-effects-interactions-pattern\\n   * @param assets The amount of assets to withdraw\\n   */\\n  function harvest(uint256 assets) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\n/**\\n * @title IVaultState\\n * @author StakeWise\\n * @notice Defines the interface for the VaultAdmin contract\\n */\\ninterface IVaultAdmin {\\n  /**\\n   * @notice Event emitted on metadata ipfs hash update\\n   * @param caller The address of the function caller\\n   * @param metadataIpfsHash The new metadata IPFS hash\\n   */\\n  event MetadataUpdated(address indexed caller, string metadataIpfsHash);\\n\\n  /**\\n   * @notice The Vault admin\\n   * @return The address of the Vault admin\\n   */\\n  function admin() external view returns (address);\\n\\n  /**\\n   * @notice Function for updating the metadata IPFS hash. Can only be called by Vault admin.\\n   * @param metadataIpfsHash The new metadata IPFS hash\\n   */\\n  function setMetadata(string calldata metadataIpfsHash) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultEnterExit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {IVaultState} from './IVaultState.sol';\\n\\n/**\\n * @title IVaultEnterExit\\n * @author StakeWise\\n * @notice Defines the interface for the VaultEnterExit contract\\n */\\ninterface IVaultEnterExit is IVaultState {\\n  /**\\n   * @notice Event emitted on deposit\\n   * @param caller The address that called the deposit function\\n   * @param receiver The address that received the shares\\n   * @param assets The number of assets deposited by the caller\\n   * @param shares The number of shares received\\n   * @param referrer The address of the referrer\\n   */\\n  event Deposited(\\n    address indexed caller,\\n    address indexed receiver,\\n    uint256 assets,\\n    uint256 shares,\\n    address referrer\\n  );\\n\\n  /**\\n   * @notice Event emitted on redeem\\n   * @param owner The address that owns the shares\\n   * @param receiver The address that received withdrawn assets\\n   * @param assets The total number of withdrawn assets\\n   * @param shares The total number of withdrawn shares\\n   */\\n  event Redeemed(address indexed owner, address indexed receiver, uint256 assets, uint256 shares);\\n\\n  /**\\n   * @notice Event emitted on shares added to the exit queue\\n   * @param owner The address that owns the shares\\n   * @param receiver The address that will receive withdrawn assets\\n   * @param positionTicket The exit queue ticket that was assigned to the position\\n   * @param shares The number of shares that queued for the exit\\n   */\\n  event ExitQueueEntered(\\n    address indexed owner,\\n    address indexed receiver,\\n    uint256 positionTicket,\\n    uint256 shares\\n  );\\n\\n  /**\\n   * @notice Event emitted on claim of the exited assets\\n   * @param receiver The address that has received withdrawn assets\\n   * @param prevPositionTicket The exit queue ticket received after the `enterExitQueue` call\\n   * @param newPositionTicket The new exit queue ticket in case not all the shares were withdrawn. Otherwise 0.\\n   * @param withdrawnAssets The total number of assets withdrawn\\n   */\\n  event ExitedAssetsClaimed(\\n    address indexed receiver,\\n    uint256 prevPositionTicket,\\n    uint256 newPositionTicket,\\n    uint256 withdrawnAssets\\n  );\\n\\n  /**\\n   * @notice Locks shares to the exit queue. The shares continue earning rewards until they will be burned by the Vault.\\n   * @param shares The number of shares to lock\\n   * @param receiver The address that will receive assets upon withdrawal\\n   * @return positionTicket The position ticket of the exit queue\\n   */\\n  function enterExitQueue(\\n    uint256 shares,\\n    address receiver\\n  ) external returns (uint256 positionTicket);\\n\\n  /**\\n   * @notice Get the exit queue index to claim exited assets from\\n   * @param positionTicket The exit queue position ticket to get the index for\\n   * @return The exit queue index that should be used to claim exited assets.\\n   *         Returns -1 in case such index does not exist.\\n   */\\n  function getExitQueueIndex(uint256 positionTicket) external view returns (int256);\\n\\n  /**\\n   * @notice Calculates the number of shares and assets that can be claimed from the exit queue.\\n   * @param receiver The address that will receive assets upon withdrawal\\n   * @param positionTicket The exit queue ticket received after the `enterExitQueue` call\\n   * @param timestamp The timestamp when the shares entered the exit queue\\n   * @param exitQueueIndex The exit queue index at which the shares were burned. It can be looked up by calling `getExitQueueIndex`.\\n   * @return leftShares The number of shares that are still in the queue\\n   * @return claimedShares The number of claimed shares\\n   * @return claimedAssets The number of claimed assets\\n   */\\n  function calculateExitedAssets(\\n    address receiver,\\n    uint256 positionTicket,\\n    uint256 timestamp,\\n    uint256 exitQueueIndex\\n  ) external view returns (uint256 leftShares, uint256 claimedShares, uint256 claimedAssets);\\n\\n  /**\\n   * @notice Claims assets that were withdrawn by the Vault. It can be called only after the `enterExitQueue` call by the `receiver`.\\n   * @param positionTicket The exit queue ticket received after the `enterExitQueue` call\\n   * @param timestamp The timestamp when the shares entered the exit queue\\n   * @param exitQueueIndex The exit queue index at which the shares were burned. It can be looked up by calling `getExitQueueIndex`.\\n   * @return newPositionTicket The new exit queue ticket in case not all the shares were burned. Otherwise 0.\\n   * @return claimedShares The number of shares claimed\\n   * @return claimedAssets The number of assets claimed\\n   */\\n  function claimExitedAssets(\\n    uint256 positionTicket,\\n    uint256 timestamp,\\n    uint256 exitQueueIndex\\n  ) external returns (uint256 newPositionTicket, uint256 claimedShares, uint256 claimedAssets);\\n\\n  /**\\n   * @notice Redeems assets from the Vault by utilising what has not been staked yet. Can only be called when vault is not collateralized.\\n   * @param shares The number of shares to burn\\n   * @param receiver The address that will receive assets\\n   * @return assets The number of assets withdrawn\\n   */\\n  function redeem(uint256 shares, address receiver) external returns (uint256 assets);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultEthStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {IVaultState} from './IVaultState.sol';\\nimport {IVaultValidators} from './IVaultValidators.sol';\\nimport {IVaultEnterExit} from './IVaultEnterExit.sol';\\nimport {IKeeperRewards} from './IKeeperRewards.sol';\\nimport {IVaultMev} from './IVaultMev.sol';\\n\\n/**\\n * @title IVaultEthStaking\\n * @author StakeWise\\n * @notice Defines the interface for the VaultEthStaking contract\\n */\\ninterface IVaultEthStaking is IVaultState, IVaultValidators, IVaultEnterExit, IVaultMev {\\n  /**\\n   * @notice Deposit ETH to the Vault\\n   * @param receiver The address that will receive Vault's shares\\n   * @param referrer The address of the referrer. Set to zero address if not used.\\n   * @return shares The number of shares minted\\n   */\\n  function deposit(address receiver, address referrer) external payable returns (uint256 shares);\\n\\n  /**\\n   * @notice Used by MEV escrow to transfer ETH.\\n   */\\n  function receiveFromMevEscrow() external payable;\\n\\n  /**\\n   * @notice Updates Vault state and deposits ETH to the Vault\\n   * @param receiver The address that will receive Vault's shares\\n   * @param referrer The address of the referrer. Set to zero address if not used.\\n   * @param harvestParams The parameters for harvesting Keeper rewards\\n   * @return shares The number of shares minted\\n   */\\n  function updateStateAndDeposit(\\n    address receiver,\\n    address referrer,\\n    IKeeperRewards.HarvestParams calldata harvestParams\\n  ) external payable returns (uint256 shares);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultFee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {IVaultAdmin} from './IVaultAdmin.sol';\\n\\n/**\\n * @title IVaultFee\\n * @author StakeWise\\n * @notice Defines the interface for the VaultFee contract\\n */\\ninterface IVaultFee is IVaultAdmin {\\n  /**\\n   * @notice Event emitted on fee recipient update\\n   * @param caller The address of the function caller\\n   * @param feeRecipient The address of the new fee recipient\\n   */\\n  event FeeRecipientUpdated(address indexed caller, address indexed feeRecipient);\\n\\n  /**\\n   * @notice The Vault's fee recipient\\n   * @return The address of the Vault's fee recipient\\n   */\\n  function feeRecipient() external view returns (address);\\n\\n  /**\\n   * @notice The Vault's fee percent in BPS\\n   * @return The fee percent applied by the Vault on the rewards\\n   */\\n  function feePercent() external view returns (uint16);\\n\\n  /**\\n   * @notice Function for updating the fee recipient address. Can only be called by the admin.\\n   * @param _feeRecipient The address of the new fee recipient\\n   */\\n  function setFeeRecipient(address _feeRecipient) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultMev.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {IVaultState} from './IVaultState.sol';\\n\\n/**\\n * @title IVaultMev\\n * @author StakeWise\\n * @notice Common interface for the VaultMev contracts\\n */\\ninterface IVaultMev is IVaultState {\\n  /**\\n   * @notice The contract that accumulates MEV rewards\\n   * @return The MEV escrow contract address\\n   */\\n  function mevEscrow() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultsRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\n/**\\n * @title IVaultsRegistry\\n * @author StakeWise\\n * @notice Defines the interface for the VaultsRegistry\\n */\\ninterface IVaultsRegistry {\\n  /**\\n   * @notice Event emitted on a Vault addition\\n   * @param caller The address that has added the Vault\\n   * @param vault The address of the added Vault\\n   */\\n  event VaultAdded(address indexed caller, address indexed vault);\\n\\n  /**\\n   * @notice Event emitted on adding Vault implementation contract\\n   * @param impl The address of the new implementation contract\\n   */\\n  event VaultImplAdded(address indexed impl);\\n\\n  /**\\n   * @notice Event emitted on removing Vault implementation contract\\n   * @param impl The address of the removed implementation contract\\n   */\\n  event VaultImplRemoved(address indexed impl);\\n\\n  /**\\n   * @notice Event emitted on whitelisting the factory\\n   * @param factory The address of the whitelisted factory\\n   */\\n  event FactoryAdded(address indexed factory);\\n\\n  /**\\n   * @notice Event emitted on removing the factory from the whitelist\\n   * @param factory The address of the factory removed from the whitelist\\n   */\\n  event FactoryRemoved(address indexed factory);\\n\\n  /**\\n   * @notice Registered Vaults\\n   * @param vault The address of the vault to check whether it is registered\\n   * @return `true` for the registered Vault, `false` otherwise\\n   */\\n  function vaults(address vault) external view returns (bool);\\n\\n  /**\\n   * @notice Registered Vault implementations\\n   * @param impl The address of the vault implementation\\n   * @return `true` for the registered implementation, `false` otherwise\\n   */\\n  function vaultImpls(address impl) external view returns (bool);\\n\\n  /**\\n   * @notice Registered Factories\\n   * @param factory The address of the factory to check whether it is whitelisted\\n   * @return `true` for the whitelisted Factory, `false` otherwise\\n   */\\n  function factories(address factory) external view returns (bool);\\n\\n  /**\\n   * @notice Function for adding Vault to the registry. Can only be called by the whitelisted Factory.\\n   * @param vault The address of the Vault to add\\n   */\\n  function addVault(address vault) external;\\n\\n  /**\\n   * @notice Function for adding Vault implementation contract\\n   * @param newImpl The address of the new implementation contract\\n   */\\n  function addVaultImpl(address newImpl) external;\\n\\n  /**\\n   * @notice Function for removing Vault implementation contract\\n   * @param impl The address of the removed implementation contract\\n   */\\n  function removeVaultImpl(address impl) external;\\n\\n  /**\\n   * @notice Function for adding the factory to the whitelist\\n   * @param factory The address of the factory to add to the whitelist\\n   */\\n  function addFactory(address factory) external;\\n\\n  /**\\n   * @notice Function for removing the factory from the whitelist\\n   * @param factory The address of the factory to remove from the whitelist\\n   */\\n  function removeFactory(address factory) external;\\n\\n  /**\\n   * @notice Function for initializing the registry. Can only be called once during the deployment.\\n   * @param _owner The address of the owner of the contract\\n   */\\n  function initialize(address _owner) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {IKeeperRewards} from './IKeeperRewards.sol';\\nimport {IVaultFee} from './IVaultFee.sol';\\n\\n/**\\n * @title IVaultState\\n * @author StakeWise\\n * @notice Defines the interface for the VaultState contract\\n */\\ninterface IVaultState is IVaultFee {\\n  /**\\n   * @notice Event emitted on checkpoint creation\\n   * @param shares The number of burned shares\\n   * @param assets The amount of exited assets\\n   */\\n  event CheckpointCreated(uint256 shares, uint256 assets);\\n\\n  /**\\n   * @notice Event emitted on minting fee recipient shares\\n   * @param receiver The address of the fee recipient\\n   * @param shares The number of minted shares\\n   * @param assets The amount of minted assets\\n   */\\n  event FeeSharesMinted(address receiver, uint256 shares, uint256 assets);\\n\\n  /**\\n   * @notice Total assets in the Vault\\n   * @return The total amount of the underlying asset that is \\\"managed\\\" by Vault\\n   */\\n  function totalAssets() external view returns (uint256);\\n\\n  /**\\n   * @notice Function for retrieving total shares\\n   * @return The amount of shares in existence\\n   */\\n  function totalShares() external view returns (uint256);\\n\\n  /**\\n   * @notice The Vault's capacity\\n   * @return The amount after which the Vault stops accepting deposits\\n   */\\n  function capacity() external view returns (uint256);\\n\\n  /**\\n   * @notice Total assets available in the Vault. They can be staked or withdrawn.\\n   * @return The total amount of withdrawable assets\\n   */\\n  function withdrawableAssets() external view returns (uint256);\\n\\n  /**\\n   * @notice Queued Shares\\n   * @return The total number of shares queued for exit\\n   */\\n  function queuedShares() external view returns (uint128);\\n\\n  /**\\n   * @notice Returns the number of shares held by an account\\n   * @param account The account for which to look up the number of shares it has, i.e. its balance\\n   * @return The number of shares held by the account\\n   */\\n  function getShares(address account) external view returns (uint256);\\n\\n  /**\\n   * @notice Converts shares to assets\\n   * @param assets The amount of assets to convert to shares\\n   * @return shares The amount of shares that the Vault would exchange for the amount of assets provided\\n   */\\n  function convertToShares(uint256 assets) external view returns (uint256 shares);\\n\\n  /**\\n   * @notice Converts assets to shares\\n   * @param shares The amount of shares to convert to assets\\n   * @return assets The amount of assets that the Vault would exchange for the amount of shares provided\\n   */\\n  function convertToAssets(uint256 shares) external view returns (uint256 assets);\\n\\n  /**\\n   * @notice Check whether state update is required\\n   * @return `true` if state update is required, `false` otherwise\\n   */\\n  function isStateUpdateRequired() external view returns (bool);\\n\\n  /**\\n   * @notice Updates the total amount of assets in the Vault and its exit queue\\n   * @param harvestParams The parameters for harvesting Keeper rewards\\n   */\\n  function updateState(IKeeperRewards.HarvestParams calldata harvestParams) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultValidators.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {IKeeperValidators} from './IKeeperValidators.sol';\\nimport {IVaultAdmin} from './IVaultAdmin.sol';\\nimport {IVaultState} from './IVaultState.sol';\\n\\n/**\\n * @title IVaultValidators\\n * @author StakeWise\\n * @notice Defines the interface for VaultValidators contract\\n */\\ninterface IVaultValidators is IVaultAdmin, IVaultState {\\n  /**\\n   * @notice Event emitted on validator registration\\n   * @param publicKey The public key of the validator that was registered\\n   */\\n  event ValidatorRegistered(bytes publicKey);\\n\\n  /**\\n   * @notice Event emitted on keys manager address update\\n   * @param caller The address of the function caller\\n   * @param keysManager The address of the new keys manager\\n   */\\n  event KeysManagerUpdated(address indexed caller, address indexed keysManager);\\n\\n  /**\\n   * @notice Event emitted on validators merkle tree root update\\n   * @param caller The address of the function caller\\n   * @param validatorsRoot The new validators merkle tree root\\n   */\\n  event ValidatorsRootUpdated(address indexed caller, bytes32 indexed validatorsRoot);\\n\\n  /**\\n   * @notice The Vault keys manager address\\n   * @return The address that can update validators merkle tree root\\n   */\\n  function keysManager() external view returns (address);\\n\\n  /**\\n   * @notice The Vault validators root\\n   * @return The merkle tree root to use for verifying validators deposit data\\n   */\\n  function validatorsRoot() external view returns (bytes32);\\n\\n  /**\\n   * @notice The Vault validator index\\n   * @return The index of the next validator to be registered in the current deposit data file\\n   */\\n  function validatorIndex() external view returns (uint256);\\n\\n  /**\\n   * @notice Function for registering single validator\\n   * @param keeperParams The parameters for getting approval from Keeper oracles\\n   * @param proof The proof used to verify that the validator is part of the validators merkle tree\\n   */\\n  function registerValidator(\\n    IKeeperValidators.ApprovalParams calldata keeperParams,\\n    bytes32[] calldata proof\\n  ) external;\\n\\n  /**\\n   * @notice Function for registering multiple validators\\n   * @param keeperParams The parameters for getting approval from Keeper oracles\\n   * @param indexes The indexes of the leaves for the merkle tree multi proof verification\\n   * @param proofFlags The multi proof flags for the merkle tree verification\\n   * @param proof The proof used for the merkle tree verification\\n   */\\n  function registerValidators(\\n    IKeeperValidators.ApprovalParams calldata keeperParams,\\n    uint256[] calldata indexes,\\n    bool[] calldata proofFlags,\\n    bytes32[] calldata proof\\n  ) external;\\n\\n  /**\\n   * @notice Function for updating the keys manager. Can only be called by the admin.\\n   * @param _keysManager The new keys manager address\\n   */\\n  function setKeysManager(address _keysManager) external;\\n\\n  /**\\n   * @notice Function for updating the validators merkle tree root. Can only be called by the keys manager.\\n   * @param _validatorsRoot The new validators merkle tree root\\n   */\\n  function setValidatorsRoot(bytes32 _validatorsRoot) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\n/**\\n * @title Errors\\n * @author StakeWise\\n * @notice Contains all the custom errors\\n */\\nlibrary Errors {\\n  error AccessDenied();\\n  error InvalidShares();\\n  error InvalidAssets();\\n  error ZeroAddress();\\n  error InsufficientAssets();\\n  error CapacityExceeded();\\n  error InvalidCapacity();\\n  error InvalidSecurityDeposit();\\n  error InvalidFeeRecipient();\\n  error InvalidFeePercent();\\n  error NotHarvested();\\n  error NotCollateralized();\\n  error Collateralized();\\n  error InvalidProof();\\n  error LowLtv();\\n  error RedemptionExceeded();\\n  error InvalidPosition();\\n  error InvalidLtv();\\n  error InvalidHealthFactor();\\n  error InvalidReceivedAssets();\\n  error InvalidTokenMeta();\\n  error UpgradeFailed();\\n  error InvalidValidator();\\n  error InvalidValidators();\\n  error WhitelistAlreadyUpdated();\\n  error DeadlineExpired();\\n  error PermitInvalidSigner();\\n  error InvalidValidatorsRegistryRoot();\\n  error InvalidVault();\\n  error AlreadyAdded();\\n  error AlreadyRemoved();\\n  error InvalidOracles();\\n  error NotEnoughSignatures();\\n  error InvalidOracle();\\n  error TooEarlyUpdate();\\n  error InvalidAvgRewardPerSecond();\\n  error InvalidRewardsRoot();\\n  error HarvestFailed();\\n  error InvalidRedeemFromLtvPercent();\\n  error InvalidLiqThresholdPercent();\\n  error InvalidLiqBonusPercent();\\n  error InvalidLtvPercent();\\n  error InvalidCheckpointIndex();\\n  error InvalidCheckpointValue();\\n  error MaxOraclesExceeded();\\n  error ClaimTooEarly();\\n}\\n\"\r\n    },\r\n    \"contracts/vaults/ethereum/mev/SharedMevEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity =0.8.22;\\n\\nimport {ISharedMevEscrow} from '../../../interfaces/ISharedMevEscrow.sol';\\nimport {IVaultsRegistry} from '../../../interfaces/IVaultsRegistry.sol';\\nimport {IVaultEthStaking} from '../../../interfaces/IVaultEthStaking.sol';\\nimport {Errors} from '../../../libraries/Errors.sol';\\n\\n/**\\n * @title SharedMevEscrow\\n * @author StakeWise\\n * @notice Accumulates received MEV. The rewards are shared by multiple Vaults.\\n */\\ncontract SharedMevEscrow is ISharedMevEscrow {\\n  IVaultsRegistry private immutable _vaultsRegistry;\\n\\n  /// @dev Constructor\\n  constructor(address vaultsRegistry) {\\n    _vaultsRegistry = IVaultsRegistry(vaultsRegistry);\\n  }\\n\\n  /// @inheritdoc ISharedMevEscrow\\n  function harvest(uint256 assets) external override {\\n    if (!_vaultsRegistry.vaults(msg.sender)) revert Errors.HarvestFailed();\\n\\n    emit Harvested(msg.sender, assets);\\n    // slither-disable-next-line arbitrary-send-eth\\n    IVaultEthStaking(msg.sender).receiveFromMevEscrow{value: assets}();\\n  }\\n\\n  /**\\n   * @dev Function for receiving MEV\\n   */\\n  receive() external payable {\\n    emit MevReceived(msg.value);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yul\": true\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultsRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"HarvestFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"Harvested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"MevReceived\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SharedMevEscrow", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003a0008a588772446f6e656133c2d5029cc4fc20e", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}