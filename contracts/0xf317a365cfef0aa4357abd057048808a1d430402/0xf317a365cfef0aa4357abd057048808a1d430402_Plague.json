{"SourceCode": "pragma solidity ^0.4.24;\r\n//================================================================================\r\n//                            Plague Inc. <Grand prize>\r\n// WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\r\n//                     This game is easy for you to get rich.\r\n//                           Please prepare enough ETH.\r\n//                 If you have HEART DISEASE, PLEASE DON'T PLAY.\r\n//       If you are Chinese or American, please don't play. YOU ARE TOO RICH.\r\n// \r\n// Plague Inc. , which is abbreviated as PIC by players.\r\n// is developed by a well-known games company who put a lot of effort into R&D.\r\n// One evening, our producer had a hands-on experience on FOMO3D.\r\n// and he was really annoyed by the \"unreasonable\" numerical settings in FOMO3D.\r\n// He said: \"We can make a better one!\"\r\n// So we made a better one. ^v^\r\n// \r\n// # It takes less time for investors to get back their capital, while making more\r\n//   profit (51% for investor dividends).\r\n// # Introducers can get a high return of 10% (effective in the long term).\r\n// # A lot of investors suffered losses in FOMO3D Quick, which is solved perfectly\r\n//   by Plague Inc.\r\n// # A total of 11 players will share the grand prize, you don\u2019t have to be the\r\n//   last one.\r\n// # Better numerical and time setup, no worries about being in trouble.\r\n// \r\n//                     \u00a92030 Plague Inc. All Rights Reserved.\r\n//                                www.plagueinc.io\r\n//                Memorial Bittorrent, eDonkey, eMule. Embrace IPFS\r\n//                        Blockchain will change the world.\r\n//================================================================================\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n    \r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}\r\n\r\ncontract PlagueEvents {\r\n\t\r\n\t//infective person\r\n    event onInfectiveStage\r\n    (\r\n        address indexed player,\r\n        uint256 indexed rndNo,\r\n        uint256 keys,\r\n        uint256 eth,\r\n        uint256 timeStamp,\r\n\t\taddress indexed inveter\r\n    );\r\n\r\n    // become leader during second stage\r\n    event onDevelopmentStage\r\n    (\r\n        address indexed player,\r\n        uint256 indexed rndNo,\r\n        uint256 eth,\r\n        uint256 timeStamp,\r\n\t\taddress indexed inveter\r\n    );\r\n\r\n    // award\r\n    event onAward\r\n    (\r\n        address indexed player,\r\n        uint256 indexed rndNo,\r\n        uint256 eth,\r\n        uint256 timeStamp\r\n    );\r\n}\r\n\r\ncontract Plague is PlagueEvents{\r\n    using SafeMath for *;\r\n    using KeysCalc for uint256;\r\n\r\n    struct Round {\r\n        uint256 eth;                // total eth\r\n        uint256 keys;               // total keys\r\n        uint256 startTime;          // start time\r\n        uint256 endTime;            // end time\r\n        uint256 infectiveEndTime;   // infective end time\r\n        address leader;             // leader\r\n        address infectLastPlayer;   // the player will award 10% eth\r\n        address [11] lastInfective;  // the lastest 11 infective\r\n        address [4] loseInfective;  // the lose infective\r\n        bool [11] infectiveAward_m; //\r\n        uint256 totalInfective;     // the count of this round\r\n        uint256 inveterAmount;      // remain inveter amount of this round\r\n        uint256 lastRoundReward;    // last round remain eth 10% + eth 4% - inveterAmount + last remain award\r\n        uint256 exAward;            // development award\r\n    }\r\n\r\n    struct PlayerRound {\r\n        uint256 eth;        // eth player has added to round\r\n        uint256 keys;       // keys\r\n        uint256 withdraw;   // how many eth has been withdraw\r\n        uint256 getInveterAmount; // inverter amount\r\n        uint256 hasGetAwardAmount;  // player has get award amount\r\n    }\r\n\r\n    uint256 public rndNo = 1;                                   // current round number\r\n    uint256 public totalEth = 0;                                // total eth in all round\r\n\r\n    uint256 constant private rndInfectiveStage_ = 12 hours;          // round timer at infective stage 12 hours;\r\n    uint256 constant private rndInfectiveReadyTime_ = 30 minutes;      // round timer at infective stage ready time\r\n    uint256 constant private rndDevelopmentStage_ = 15 minutes;       // round timer at development stage 30 minutes; \r\n    uint256 constant private rndDevelopmentReadyTime_ = 12 hours;       // round timer at development stage ready time 1 hours;\r\n    uint256 constant private allKeys_ = 15000000 * (10 ** 18);   // all keys count\r\n    uint256 constant private allEths_ = 18703123828125000000000; // all eths count\r\n    uint256 constant private rndIncreaseTime_ = 3 hours;       // increase time 3 hours\r\n    uint256 constant private developmentAwardPercent = 1;   // 0.1% reduction every 3 hours\r\n\r\n    mapping (uint256 => Round) public round_m;                  // (rndNo => Round)\r\n    mapping (uint256 => mapping (address => PlayerRound)) public playerRound_m;   // (rndNo => addr => PlayerRound)\r\n\r\n    address public owner;               // owner address\r\n    address public receiver = address(0);            // receive eth address\r\n    uint256 public ownerWithdraw = 0;   // how many eth has been withdraw by owner\r\n    bool public isStartGame = false;    // start game flag\r\n\r\n    constructor()\r\n        public\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev prevents contracts from interacting\r\n     */\r\n    modifier onlyHuman() \r\n    {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n        \r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev sets boundaries for incoming tx \r\n     */\r\n    modifier isWithinLimits(uint256 _eth) \r\n    {\r\n        require(_eth >= 1000000000, \"pocket lint: not a valid currency\");\r\n        require(_eth <= 100000000000000000000000, \"no vitalik, no\");\r\n        _;    \r\n    }\r\n\r\n    /**\r\n     * @dev only owner\r\n     */\r\n    modifier onlyOwner() \r\n    {\r\n        require(owner == msg.sender, \"only owner can do it\");\r\n        _;    \r\n    }\r\n    \r\n    /**\r\n     * @dev It must be human beings to call the function.\r\n     */\r\n    function isHuman(address _addr) private view returns (bool)\r\n    {\r\n        uint256 _codeLength;\r\n        \r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        return _codeLength == 0;\r\n    }\r\n   \r\n   /**\r\n\t * @dev player infect a person at current round\r\n\t * \r\n\t */\r\n    function buyKeys(address _inveter) private\r\n    {\r\n        uint256 _eth = msg.value;\r\n        uint256 _now = now;\r\n        uint256 _rndNo = rndNo;\r\n        uint256 _ethUse = msg.value;\r\n\r\n        if (_now > round_m[_rndNo].endTime)\r\n        {\r\n            require(round_m[_rndNo].endTime + rndDevelopmentReadyTime_ < _now, \"we should wait some time\");\r\n            \r\n            uint256 lastAwardEth = (round_m[_rndNo].eth.mul(14) / 100).sub(round_m[_rndNo].inveterAmount);\r\n            \r\n            if(round_m[_rndNo].totalInfective < round_m[_rndNo].lastInfective.length)\r\n            {\r\n                uint256 nextPlayersAward = round_m[_rndNo].lastInfective.length.sub(round_m[_rndNo].totalInfective);\r\n                uint256 _totalAward = round_m[_rndNo].eth.mul(30) / 100;\r\n                _totalAward = _totalAward.add(round_m[_rndNo].lastRoundReward);\r\n                if(round_m[_rndNo].infectLastPlayer != address(0))\r\n                {\r\n                    lastAwardEth = lastAwardEth.add(nextPlayersAward.mul(_totalAward.mul(3)/100));\r\n                }\r\n                else\r\n                {\r\n                    lastAwardEth = lastAwardEth.add(nextPlayersAward.mul(_totalAward.mul(4)/100));\r\n                }\r\n            }\r\n            \r\n            _rndNo = _rndNo.add(1);\r\n            rndNo = _rndNo;\r\n            round_m[_rndNo].startTime = _now;\r\n            round_m[_rndNo].endTime = _now + rndInfectiveStage_;\r\n            round_m[_rndNo].totalInfective = 0;\r\n            round_m[_rndNo].lastRoundReward = lastAwardEth;\r\n        }\r\n\r\n        // infective or second stage\r\n        if (round_m[_rndNo].keys < allKeys_)\r\n        {\r\n            // infection stage\r\n            uint256 _keys = (round_m[_rndNo].eth).keysRec(_eth);\r\n            \r\n            if (_keys.add(round_m[_rndNo].keys) >= allKeys_)\r\n            {\r\n                _keys = allKeys_.sub(round_m[_rndNo].keys);\r\n\r\n                if (round_m[_rndNo].eth >= allEths_)\r\n                {\r\n                    _ethUse = 0;\r\n                } \r\n                else {\r\n                    _ethUse = (allEths_).sub(round_m[_rndNo].eth);\r\n                }\r\n\r\n                if (_eth > _ethUse)\r\n                {\r\n                    // refund\r\n                    msg.sender.transfer(_eth.sub(_ethUse));\r\n                } \r\n                else {\r\n                    // fix\r\n                    _ethUse = _eth;\r\n                }\r\n                // first stage is over, record current time\r\n                round_m[_rndNo].infectiveEndTime = _now.add(rndInfectiveReadyTime_);\r\n                round_m[_rndNo].endTime = _now.add(rndDevelopmentStage_).add(rndInfectiveReadyTime_);\r\n                round_m[_rndNo].infectLastPlayer = msg.sender;\r\n            }\r\n            else\r\n            {\r\n                require (_keys >= 1 * 10 ** 19, \"at least 10 thound people\");\r\n                round_m[_rndNo].endTime = _now + rndInfectiveStage_;\r\n            }\r\n            \r\n            round_m[_rndNo].leader = msg.sender;\r\n\r\n            // update playerRound\r\n            playerRound_m[_rndNo][msg.sender].keys = _keys.add(playerRound_m[_rndNo][msg.sender].keys);\r\n            playerRound_m[_rndNo][msg.sender].eth = _ethUse.add(playerRound_m[_rndNo][msg.sender].eth);\r\n\r\n            // update round\r\n            round_m[_rndNo].keys = _keys.add(round_m[_rndNo].keys);\r\n            round_m[_rndNo].eth = _ethUse.add(round_m[_rndNo].eth);\r\n\r\n            // update global variable\r\n            totalEth = _ethUse.add(totalEth);\r\n\r\n            // event\r\n            emit PlagueEvents.onInfectiveStage\r\n            (\r\n                msg.sender,\r\n                _rndNo,\r\n                _keys,\r\n                _ethUse,\r\n                _now,\r\n\t\t\t\t_inveter\r\n            );\r\n        } else {\r\n            // second stage\r\n            require(round_m[_rndNo].infectiveEndTime < _now, \"The virus is being prepared...\");\r\n            \r\n            // increase 0.05 Ether every 3 hours\r\n            _ethUse = (((_now.sub(round_m[_rndNo].infectiveEndTime)) / rndIncreaseTime_).mul(5 * 10 ** 16)).add((5 * 10 ** 16));\r\n            \r\n            require(_eth >= _ethUse, \"Ether amount is wrong\");\r\n            \r\n            if(_eth > _ethUse)\r\n            {\r\n                msg.sender.transfer(_eth.sub(_ethUse));\r\n            }\r\n\r\n            round_m[_rndNo].endTime = _now + rndDevelopmentStage_;\r\n            round_m[_rndNo].leader = msg.sender;\r\n\r\n            // update playerRound\r\n            playerRound_m[_rndNo][msg.sender].eth = _ethUse.add(playerRound_m[_rndNo][msg.sender].eth);\r\n\r\n            // update round\r\n            round_m[_rndNo].eth = _ethUse.add(round_m[_rndNo].eth);\r\n\r\n            // update global variable\r\n            totalEth = _ethUse.add(totalEth);\r\n            \r\n            // update development award\r\n            uint256 _exAwardPercent = ((_now.sub(round_m[_rndNo].infectiveEndTime)) / rndIncreaseTime_).mul(developmentAwardPercent).add(developmentAwardPercent);\r\n            if(_exAwardPercent >= 410)\r\n            {\r\n                _exAwardPercent = 410;\r\n            }\r\n            round_m[_rndNo].exAward = (_exAwardPercent.mul(_ethUse) / 1000).add(round_m[_rndNo].exAward);\r\n\r\n            // event\r\n            emit PlagueEvents.onDevelopmentStage\r\n            (\r\n                msg.sender,\r\n                _rndNo,\r\n                _ethUse,\r\n                _now,\r\n\t\t\t\t_inveter\r\n            );\r\n        }\r\n        \r\n        // caculate share inveter amount\r\n        if(_inveter != address(0) && isHuman(_inveter)) \r\n        {\r\n            playerRound_m[_rndNo][_inveter].getInveterAmount = playerRound_m[_rndNo][_inveter].getInveterAmount.add(_ethUse.mul(10) / 100);\r\n            round_m[_rndNo].inveterAmount = round_m[_rndNo].inveterAmount.add(_ethUse.mul(10) / 100);\r\n        }\r\n        \r\n        round_m[_rndNo].loseInfective[round_m[_rndNo].totalInfective % 4] = round_m[_rndNo].lastInfective[round_m[_rndNo].totalInfective % 11];\r\n        round_m[_rndNo].lastInfective[round_m[_rndNo].totalInfective % 11] = msg.sender;\r\n        \r\n        round_m[_rndNo].totalInfective = round_m[_rndNo].totalInfective.add(1);\r\n    }\r\n    \r\n\t/**\r\n\t * @dev recommend a player\r\n\t */\r\n    function buyKeyByAddr(address _inveter)\r\n        onlyHuman()\r\n        isWithinLimits(msg.value)\r\n        public\r\n        payable\r\n    {\r\n        require(isStartGame == true, \"The game hasn't started yet.\");\r\n        buyKeys(_inveter);\r\n    }\r\n\r\n    /**\r\n     * @dev play\r\n     */\r\n    function()\r\n        onlyHuman()\r\n        isWithinLimits(msg.value)\r\n        public\r\n        payable\r\n    {\r\n        require(isStartGame == true, \"The game hasn't started yet.\");\r\n        buyKeys(address(0));\r\n    }\r\n    \r\n    /**\r\n     * @dev Award by rndNo.\r\n     * 0x80ec35ff\r\n     * 0x80ec35ff0000000000000000000000000000000000000000000000000000000000000001\r\n     */\r\n    function awardByRndNo(uint256 _rndNo)\r\n        onlyHuman()\r\n        public\r\n    {\r\n        require(isStartGame == true, \"The game hasn't started yet.\");\r\n        require(_rndNo <= rndNo, \"You're running too fast\");\r\n        \r\n        uint256 _ethOut = 0;\r\n        uint256 _totalAward = round_m[_rndNo].eth.mul(30) / 100;\r\n        _totalAward = _totalAward.add(round_m[_rndNo].lastRoundReward);\r\n        _totalAward = _totalAward.add(round_m[_rndNo].exAward);\r\n        uint256 _getAward = 0;\r\n        \r\n        //withdraw award\r\n        uint256 _totalWithdraw = round_m[_rndNo].eth.mul(51) / 100;\r\n        _totalWithdraw = _totalWithdraw.sub(round_m[_rndNo].exAward);\r\n        _totalWithdraw = (_totalWithdraw.mul(playerRound_m[_rndNo][msg.sender].keys));\r\n        _totalWithdraw = _totalWithdraw / round_m[_rndNo].keys;\r\n        \r\n        uint256 _inveterAmount = playerRound_m[_rndNo][msg.sender].getInveterAmount;\r\n        _totalWithdraw = _totalWithdraw.add(_inveterAmount);\r\n        uint256 _withdrawed = playerRound_m[_rndNo][msg.sender].withdraw;\r\n        if(_totalWithdraw > _withdrawed)\r\n        {\r\n            _ethOut = _ethOut.add(_totalWithdraw.sub(_withdrawed));\r\n            playerRound_m[_rndNo][msg.sender].withdraw = _totalWithdraw;\r\n        }\r\n        \r\n         //lastest infect player\r\n        if(msg.sender == round_m[_rndNo].infectLastPlayer && round_m[_rndNo].infectLastPlayer != address(0) && round_m[_rndNo].infectiveEndTime != 0)\r\n        {\r\n            _getAward = _getAward.add(_totalAward.mul(10)/100);\r\n        }\r\n        \r\n        if(now > round_m[_rndNo].endTime)\r\n        {\r\n            // finally award\r\n            if(round_m[_rndNo].leader == msg.sender)\r\n            {\r\n                _getAward = _getAward.add(_totalAward.mul(60)/100);\r\n            }\r\n            \r\n            //finally ten person award\r\n            for(uint256 i = 0;i < round_m[_rndNo].lastInfective.length; i = i.add(1))\r\n            {\r\n                if(round_m[_rndNo].lastInfective[i] == msg.sender && (round_m[_rndNo].totalInfective.sub(1) % 11) != i){\r\n                    if(round_m[_rndNo].infectiveAward_m[i])\r\n                        continue;\r\n                    if(round_m[_rndNo].infectLastPlayer != address(0))\r\n                    {\r\n                        _getAward = _getAward.add(_totalAward.mul(3)/100);\r\n                    }\r\n                    else{\r\n                        _getAward = _getAward.add(_totalAward.mul(4)/100);\r\n                    }\r\n                        \r\n                    round_m[_rndNo].infectiveAward_m[i] = true;\r\n                }\r\n            }\r\n        }\r\n        _ethOut = _ethOut.add(_getAward.sub(playerRound_m[_rndNo][msg.sender].hasGetAwardAmount));\r\n        playerRound_m[_rndNo][msg.sender].hasGetAwardAmount = _getAward;\r\n        \r\n        if(_ethOut != 0)\r\n        {\r\n            msg.sender.transfer(_ethOut); \r\n        }\r\n        \r\n        // event\r\n        emit PlagueEvents.onAward\r\n        (\r\n            msg.sender,\r\n            _rndNo,\r\n            _ethOut,\r\n            now\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @dev Get player bonus data\r\n     * 0xd982466d\r\n     * 0xd982466d0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000028f211f6c07d3b79e0aab886d56333e4027d4f59\r\n     * @return player's award\r\n     * @return player's can withdraw amount\r\n     * @return player's inveter amount\r\n     * @return player's has been withdraw\r\n     */\r\n    function getPlayerAwardByRndNo(uint256 _rndNo, address _playAddr)\r\n        view\r\n        public\r\n        returns (uint256, uint256, uint256, uint256)\r\n    {\r\n        uint256 _ethPlayerAward = 0;\r\n        \r\n        //withdraw award\r\n        uint256 _totalWithdraw = round_m[_rndNo].eth.mul(51) / 100;\r\n        _totalWithdraw = _totalWithdraw.sub(round_m[_rndNo].exAward);\r\n        _totalWithdraw = (_totalWithdraw.mul(playerRound_m[_rndNo][_playAddr].keys));\r\n        _totalWithdraw = _totalWithdraw / round_m[_rndNo].keys;\r\n        \r\n        uint256 _totalAward = round_m[_rndNo].eth.mul(30) / 100;\r\n        _totalAward = _totalAward.add(round_m[_rndNo].lastRoundReward);\r\n        _totalAward = _totalAward.add(round_m[_rndNo].exAward);\r\n        \r\n        //lastest infect player\r\n        if(_playAddr == round_m[_rndNo].infectLastPlayer && round_m[_rndNo].infectLastPlayer != address(0) && round_m[_rndNo].infectiveEndTime != 0)\r\n        {\r\n            _ethPlayerAward = _ethPlayerAward.add(_totalAward.mul(10)/100);\r\n        }\r\n        \r\n        if(now > round_m[_rndNo].endTime)\r\n        {\r\n            // finally award\r\n            if(round_m[_rndNo].leader == _playAddr)\r\n            {\r\n                _ethPlayerAward = _ethPlayerAward.add(_totalAward.mul(60)/100);\r\n            }\r\n            \r\n            //finally ten person award\r\n            for(uint256 i = 0;i < round_m[_rndNo].lastInfective.length; i = i.add(1))\r\n            {\r\n                if(round_m[_rndNo].lastInfective[i] == _playAddr && (round_m[_rndNo].totalInfective.sub(1) % 11) != i)\r\n                {\r\n                    if(round_m[_rndNo].infectLastPlayer != address(0))\r\n                    {\r\n                        _ethPlayerAward = _ethPlayerAward.add(_totalAward.mul(3)/100);\r\n                    }\r\n                    else{\r\n                        _ethPlayerAward = _ethPlayerAward.add(_totalAward.mul(4)/100);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        \r\n        return\r\n        (\r\n            _ethPlayerAward,\r\n            _totalWithdraw,\r\n            playerRound_m[_rndNo][_playAddr].getInveterAmount,\r\n            playerRound_m[_rndNo][_playAddr].hasGetAwardAmount + playerRound_m[_rndNo][_playAddr].withdraw\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @dev fee withdraw to receiver, everyone can do it.\r\n     * 0x6561e6ba\r\n     */\r\n    function feeWithdraw()\r\n        onlyHuman()\r\n        public \r\n    {\r\n        require(isStartGame == true, \"The game hasn't started yet.\");\r\n        require(receiver != address(0), \"The receiver address has not been initialized.\");\r\n        \r\n        uint256 _total = (totalEth.mul(5) / (100));\r\n        uint256 _withdrawed = ownerWithdraw;\r\n        require(_total > _withdrawed, \"No need to withdraw\");\r\n        ownerWithdraw = _total;\r\n        receiver.transfer(_total.sub(_withdrawed));\r\n    }\r\n    \r\n    /**\r\n     * @dev start game\r\n     * 0xd65ab5f2\r\n     */\r\n    function startGame()\r\n        onlyOwner()\r\n        public\r\n    {\r\n        require(isStartGame == false, \"The game has already started!\");\r\n        \r\n        round_m[1].startTime = now;\r\n        round_m[1].endTime = now + rndInfectiveStage_;\r\n        round_m[1].lastRoundReward = 0;\r\n        isStartGame = true;\r\n    }\r\n\r\n    /**\r\n     * @dev change owner.\r\n     * 0x547e3f06000000000000000000000000695c7a3c1a27de4bb32cd812a8c2677e25f0b9d5\r\n     */\r\n    function changeReceiver(address newReceiver)\r\n        onlyOwner()\r\n        public\r\n    {\r\n        receiver = newReceiver;\r\n    }\r\n\r\n    /**\r\n     * @dev returns all current round info needed for front end\r\n     * 0x747dff42\r\n     */\r\n    function getCurrentRoundInfo()\r\n        public \r\n        view \r\n        returns(uint256, uint256[2], uint256[3], address[2], uint256[6], address[11], address[4])\r\n    {\r\n        uint256 _rndNo = rndNo;\r\n        uint256 _totalAwardAtRound = round_m[_rndNo].lastRoundReward.add(round_m[_rndNo].exAward).add(round_m[_rndNo].eth.mul(30) / 100);\r\n        \r\n        return (\r\n            _rndNo,\r\n            [round_m[_rndNo].eth, round_m[_rndNo].keys],\r\n            [round_m[_rndNo].startTime, round_m[_rndNo].endTime, round_m[_rndNo].infectiveEndTime],\r\n            [round_m[_rndNo].leader, round_m[_rndNo].infectLastPlayer],\r\n            [getBuyPrice(), round_m[_rndNo].lastRoundReward, _totalAwardAtRound, round_m[_rndNo].inveterAmount, round_m[_rndNo].totalInfective % 11, round_m[_rndNo].exAward],\r\n            round_m[_rndNo].lastInfective,\r\n            round_m[_rndNo].loseInfective\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev return the price buyer will pay for next 1 individual key during first stage.\r\n     * 0x018a25e8\r\n     * @return price for next key bought (in wei format)\r\n     */\r\n    function getBuyPrice()\r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        uint256 _rndNo = rndNo;\r\n        uint256 _now = now;\r\n        \r\n        // start next round?\r\n        if (_now > round_m[_rndNo].endTime)\r\n        {\r\n            return (750007031250000);\r\n        }\r\n        if (round_m[_rndNo].keys < allKeys_)\r\n        {\r\n            return ((round_m[_rndNo].keys.add(10000000000000000000)).ethRec(10000000000000000000));\r\n        }\r\n        if(round_m[_rndNo].keys >= allKeys_ && \r\n            round_m[_rndNo].infectiveEndTime != 0 && \r\n            round_m[_rndNo].infectLastPlayer != address(0) &&\r\n            _now < round_m[_rndNo].infectiveEndTime)\r\n        {\r\n            return 5 * 10 ** 16;\r\n        }\r\n        if(round_m[_rndNo].keys >= allKeys_ && _now > round_m[_rndNo].infectiveEndTime)\r\n        {\r\n            // increase 0.05 Ether every 3 hours\r\n            uint256 currentPrice = (((_now.sub(round_m[_rndNo].infectiveEndTime)) / rndIncreaseTime_).mul(5 * 10 ** 16)).add((5 * 10 ** 16));\r\n            return currentPrice;\r\n        }\r\n        //second stage\r\n        return (0);\r\n    }\r\n    \r\n}\r\n\r\nlibrary KeysCalc {\r\n    using SafeMath for *;\r\n    /**\r\n     * @dev calculates number of keys received given X eth \r\n     * @param _curEth current amount of eth in contract \r\n     * @param _newEth eth being spent\r\n     * @return amount of ticket purchased\r\n     */\r\n    function keysRec(uint256 _curEth, uint256 _newEth)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\r\n    }\r\n    \r\n    /**\r\n     * @dev calculates amount of eth received if you sold X keys \r\n     * @param _curKeys current amount of keys that exist \r\n     * @param _sellKeys amount of keys you wish to sell\r\n     * @return amount of eth received\r\n     */\r\n    function ethRec(uint256 _curKeys, uint256 _sellKeys)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\r\n    }\r\n\r\n    /**\r\n     * @dev calculates how many keys would exist with given an amount of eth\r\n     * @param _eth eth \"in contract\"\r\n     * @return number of keys that would exist\r\n     */\r\n    function keys(uint256 _eth) \r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\r\n    }\r\n    \r\n    /**\r\n     * @dev calculates how much eth would be in contract given a number of keys\r\n     * @param _keys number of keys \"in contract\" \r\n     * @return eth that would exists\r\n     */\r\n    function eth(uint256 _keys) \r\n        internal\r\n        pure\r\n        returns(uint256)  \r\n    {\r\n        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"getBuyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rndNo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newReceiver\",\"type\":\"address\"}],\"name\":\"changeReceiver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"feeWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256[2]\"},{\"name\":\"\",\"type\":\"uint256[3]\"},{\"name\":\"\",\"type\":\"address[2]\"},{\"name\":\"\",\"type\":\"uint256[6]\"},{\"name\":\"\",\"type\":\"address[11]\"},{\"name\":\"\",\"type\":\"address[4]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"round_m\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"infectiveEndTime\",\"type\":\"uint256\"},{\"name\":\"leader\",\"type\":\"address\"},{\"name\":\"infectLastPlayer\",\"type\":\"address\"},{\"name\":\"totalInfective\",\"type\":\"uint256\"},{\"name\":\"inveterAmount\",\"type\":\"uint256\"},{\"name\":\"lastRoundReward\",\"type\":\"uint256\"},{\"name\":\"exAward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rndNo\",\"type\":\"uint256\"}],\"name\":\"awardByRndNo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerRound_m\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"withdraw\",\"type\":\"uint256\"},{\"name\":\"getInveterAmount\",\"type\":\"uint256\"},{\"name\":\"hasGetAwardAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_inveter\",\"type\":\"address\"}],\"name\":\"buyKeyByAddr\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rndNo\",\"type\":\"uint256\"},{\"name\":\"_playAddr\",\"type\":\"address\"}],\"name\":\"getPlayerAwardByRndNo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStartGame\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"receiver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"rndNo\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"keys\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"inveter\",\"type\":\"address\"}],\"name\":\"onInfectiveStage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"rndNo\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"inveter\",\"type\":\"address\"}],\"name\":\"onDevelopmentStage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"rndNo\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onAward\",\"type\":\"event\"}]", "ContractName": "Plague", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://e05d60b44ce490bd187fac60c4d67dae3a62e78c4ce111a796f41a77c5fd93e7"}