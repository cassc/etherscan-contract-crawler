{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/pools/OperatorStakingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {TypeAndVersionInterface} from\\n  \\\"@chainlink/contracts/src/v0.8/interfaces/TypeAndVersionInterface.sol\\\";\\n\\nimport {AccessControlDefaultAdminRules} from\\n  \\\"@openzeppelin/contracts/access/AccessControlDefaultAdminRules.sol\\\";\\nimport {Checkpoints} from \\\"@openzeppelin/contracts/utils/Checkpoints.sol\\\";\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\nimport {ISlashable} from \\\"../interfaces/ISlashable.sol\\\";\\nimport {IRewardVault} from \\\"../interfaces/IRewardVault.sol\\\";\\nimport {StakingPoolBase} from \\\"./StakingPoolBase.sol\\\";\\n\\n/// @notice This contract manages the staking of LINK tokens for the operator stakers.\\n/// @dev This contract inherits the StakingPoolBase contract and interacts with the MigrationProxy,\\n/// PriceFeedAlertsController, CommunityStakingPool, and RewardVault contracts.\\n/// @dev invariant Only addresses added as operators by the contract manager can stake in this pool.\\n/// @dev invariant contract's LINK token balance should be greater than or equal to the sum of\\n/// totalPrincipal and s_alerterRewardFunds.\\ncontract OperatorStakingPool is ISlashable, StakingPoolBase, TypeAndVersionInterface {\\n  using Checkpoints for Checkpoints.History;\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n\\n  /// @notice This error is raised when adding the zero address as an operator\\n  error InvalidOperator();\\n  /// @notice Error code for when the operator list is invalid\\n  error InvalidOperatorList();\\n  /// @notice Error code for when the staker is not an operator\\n  error StakerNotOperator();\\n  /// @notice This error is raised when an address is duplicated in the supplied list of operators.\\n  /// This can happen in addOperators and setFeedOperators functions.\\n  /// @param operator address of the operator\\n  error OperatorAlreadyExists(address operator);\\n  /// @notice This error is raised when removing an operator that doesn't exist.\\n  /// @param operator Address of the operator\\n  error OperatorDoesNotExist(address operator);\\n  /// @notice This error is raised when an operator to add has been removed previously.\\n  /// @param operator Address of the operator\\n  error OperatorHasBeenRemoved(address operator);\\n  /// @notice This error is raised when an operator to add is already a community staker.\\n  error OperatorCannotBeCommunityStaker(address operator);\\n  /// @notice This error is thrown whenever the max pool size is less than the\\n  /// reserved space for operators\\n  /// @param maxPoolSize The maximum pool size of the operator staking pool\\n  /// @param maxPrincipalPerStaker The maximum amount an operator can stake in the\\n  /// pool\\n  /// @param numOperators The number of operators in the pool\\n  error InsufficientPoolSpace(\\n    uint256 maxPoolSize, uint256 maxPrincipalPerStaker, uint256 numOperators\\n  );\\n  /// @notice This error is raised when attempting to open the staking pool with less\\n  /// than the minimum required node operators\\n  /// @param numOperators The current number of operators in the staking pool\\n  /// @param minInitialOperatorCount The minimum required number of operators\\n  /// in the staking pool before it can be opened\\n  error InadequateInitialOperatorCount(uint256 numOperators, uint256 minInitialOperatorCount);\\n  /// @notice This error is thrown when the contract manager tries to add a zero amount\\n  /// to the alerter reward funds\\n  error InvalidAlerterRewardFundAmount();\\n  /// @notice This error is thrown whenever the contract manager tries to withdraw\\n  /// more than the remaining balance in the alerter reward funds\\n  /// @param amountToWithdraw The amount that the contract manager tried to withdraw\\n  /// @param remainingBalance The remaining balance of the alerter reward funds\\n  error InsufficientAlerterRewardFunds(uint256 amountToWithdraw, uint256 remainingBalance);\\n\\n  /// @notice This event is emitted when an operator is removed\\n  /// @param operator Address of the operator\\n  /// @param principal Operator's staked LINK amount\\n  /// @param newTotalPrincipal Total amount of staked juels remaining in the pool\\n  event OperatorRemoved(address indexed operator, uint256 principal, uint256 newTotalPrincipal);\\n  /// @notice This event is emitted when an operator is added\\n  /// @param operator Address of the operator\\n  event OperatorAdded(address indexed operator);\\n  /// @notice This event is emitted whenever the alerter reward funds is funded\\n  /// @param amountFunded The amount added to the alerter reward funds\\n  /// @param totalBalance  The current balance of the alerter reward funds\\n  event AlerterRewardDeposited(uint256 amountFunded, uint256 totalBalance);\\n  /// @notice This event is emitted whenever the contract manager withdraws from the\\n  /// alerter reward funds\\n  /// @param amountWithdrawn The amount withdrawn from the alerter reward funds\\n  /// @param remainingBalance The remaining balance of the alerter reward funds\\n  event AlerterRewardWithdrawn(uint256 amountWithdrawn, uint256 remainingBalance);\\n  /// @notice This event is emitted whenever the alerter is paid the full\\n  /// alerter reward amount\\n  /// @param alerter The address of the alerter\\n  /// @param alerterRewardActual The amount of rewards sent to the alerter in juels.\\n  /// This can be lower than the expected value, if the reward fund is low or we aren't able to\\n  /// slash enough.\\n  /// @param alerterRewardExpected The amount of expected rewards for the alerter\\n  /// in juels\\n  event AlertingRewardPaid(\\n    address indexed alerter, uint256 alerterRewardActual, uint256 alerterRewardExpected\\n  );\\n  /// @notice This event is emitted when the slasher config is set\\n  /// @param slasher The address of the slasher\\n  /// @param refillRate The refill rate of the slasher\\n  /// @param slashCapacity The slash capacity of the slasher\\n  event SlasherConfigSet(address indexed slasher, uint256 refillRate, uint256 slashCapacity);\\n  /// @notice This event is emitted when an operator is slashed\\n  /// @param operator The address of the operator\\n  /// @param slashedAmount The amount slashed from the operator's staked LINK\\n  /// amount\\n  /// @param updatedStakerPrincipal The operator's updated staked LINK amount\\n  /// @param newTotalPrincipal Total amount of staked juels remaining in the pool\\n  event Slashed(\\n    address indexed operator,\\n    uint256 slashedAmount,\\n    uint256 updatedStakerPrincipal,\\n    uint256 newTotalPrincipal\\n  );\\n\\n  /// @notice This struct defines the params required by the Staking contract's\\n  /// constructor.\\n  struct ConstructorParams {\\n    /// @notice The base staking pool constructor parameters\\n    ConstructorParamsBase baseParams;\\n    /// @notice The minimum number of node operators required to open the\\n    /// staking pool.\\n    uint256 minInitialOperatorCount;\\n  }\\n\\n  /// @notice This struct defines the operator-specific states.\\n  struct Operator {\\n    /// @notice The operator's staked LINK amount when they get removed.\\n    uint256 removedPrincipal;\\n    /// @notice Flag that signals whether the operator is an operator.\\n    bool isOperator;\\n    /// @notice Flag that signals whether the operator has been removed.\\n    bool isRemoved;\\n  }\\n\\n  /// @notice This is the ID for the alert rewarder role, which is given to the\\n  /// addresses that will deposit and withdraw the alerter reward.\\n  /// @dev Hash: 8d2cf17e37ecc80f26d65bcf3868b78960ab38b0762747f6c5e311e75068a88b\\n  bytes32 public constant ALERT_REWARDER_ROLE = keccak256(\\\"ALERT_REWARDER_ROLE\\\");\\n  /// @notice This is the ID for the operator manager role, which is given to the address that will\\n  /// add and remove operators\\n  /// @dev Hash: 001fdceeaab2d33566b504ecfe97e6dc3cf82cc816e696d9fe5cce35954bed17\\n  bytes32 public constant OPERATOR_MANAGER_ROLE = keccak256(\\\"OPERATOR_MANAGER_ROLE\\\");\\n  /// @notice This is the ID for the slasher role, which will be given to the\\n  /// AlertsController contract.\\n  /// @dev Hash: 12b42e8a160f6064dc959c6f251e3af0750ad213dbecf573b4710d67d6c28e39\\n  bytes32 public constant SLASHER_ROLE = keccak256(\\\"SLASHER_ROLE\\\");\\n  /// @notice Mapping of addresses to the Operator struct.\\n  mapping(address operator => Operator) private s_operators;\\n  /// @notice Mapping of the slashers to slasher config and state.\\n  mapping(address slasher => Slasher) private s_slashers;\\n  /// @notice The set of operators that are currently on-feed (slashable).\\n  EnumerableSet.AddressSet private s_operatorSet;\\n  /// @notice The number of node operators that have been set in the pool\\n  uint256 private s_numOperators;\\n  /// @notice Tracks the balance of the alerter reward funds.  This bucket holds all\\n  /// slashed funds and also funds alerter rewards.\\n  uint256 private s_alerterRewardFunds;\\n  /// @notice The minimum number of node operators required to open the\\n  /// staking pool.\\n  uint256 private immutable i_minInitialOperatorCount;\\n\\n  constructor(ConstructorParams memory params) StakingPoolBase(params.baseParams) {\\n    i_minInitialOperatorCount = params.minInitialOperatorCount;\\n  }\\n\\n  /// @notice Adds LINK to the alerter reward funds\\n  /// @param amount The amount of LINK to add to the alerter reward funds\\n  /// @dev precondition The caller must have the alert rewarder role.\\n  /// @dev precondition The caller must have at least `amount` LINK tokens.\\n  /// @dev precondition The caller must have approved this contract for the transfer of at least\\n  /// `amount` LINK tokens.\\n  function depositAlerterReward(uint256 amount)\\n    external\\n    onlyRole(ALERT_REWARDER_ROLE)\\n    whenBeforeClosing\\n  {\\n    if (amount == 0) revert InvalidAlerterRewardFundAmount();\\n    uint256 alerterRewardFunds = s_alerterRewardFunds;\\n    alerterRewardFunds += amount;\\n    s_alerterRewardFunds = alerterRewardFunds;\\n    // The return value is not checked since the call will revert if any balance, allowance or\\n    // receiver conditions fail.\\n    i_LINK.transferFrom({from: msg.sender, to: address(this), value: amount});\\n    emit AlerterRewardDeposited(amount, alerterRewardFunds);\\n  }\\n\\n  /// @notice Withdraws LINK from the alerter reward funds\\n  /// @param amount The amount of LINK withdrawn from the alerter reward funds\\n  /// @dev precondition The caller must have the alert rewarder role.\\n  /// @dev precondition This contract must have at least `amount` LINK tokens as the alerter reward\\n  /// funds.\\n  /// @dev precondition This contract must be closed (before opening or after closing).\\n  function withdrawAlerterReward(uint256 amount) external onlyRole(ALERT_REWARDER_ROLE) {\\n    if (amount == 0) revert InvalidAlerterRewardFundAmount();\\n    if (s_isOpen) revert PoolNotClosed();\\n    uint256 alerterRewardFunds = s_alerterRewardFunds;\\n    if (amount > alerterRewardFunds) {\\n      revert InsufficientAlerterRewardFunds(amount, alerterRewardFunds);\\n    }\\n    alerterRewardFunds -= amount;\\n    s_alerterRewardFunds = alerterRewardFunds;\\n    // The return value is not checked since the call will revert if any balance, allowance or\\n    // receiver conditions fail.\\n    i_LINK.transfer(msg.sender, amount);\\n    emit AlerterRewardWithdrawn(amount, alerterRewardFunds);\\n  }\\n\\n  /// @notice Returns the balance of the pool's alerter reward funds\\n  /// @return uint256 The balance of the pool's alerter reward funds\\n  function getAlerterRewardFunds() external view returns (uint256) {\\n    return s_alerterRewardFunds;\\n  }\\n\\n  // ===============\\n  // StakingPoolBase\\n  // ===============\\n\\n  /// @inheritdoc StakingPoolBase\\n  /// @dev The access control is done in StakingPoolBase.\\n  function setPoolConfig(\\n    uint256 maxPoolSize,\\n    uint256 maxPrincipalPerStaker\\n  )\\n    external\\n    override(StakingPoolBase)\\n    validatePoolSpace(maxPoolSize, maxPrincipalPerStaker, s_numOperators)\\n    whenOpen\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n  {\\n    _setPoolConfig(maxPoolSize, maxPrincipalPerStaker);\\n  }\\n\\n  /// @inheritdoc StakingPoolBase\\n  /// @dev Removed operators need to go through the unbonding period before they can withdraw. This\\n  /// function will check if the operator has removed principal they can unstake.\\n  function unbond() external override {\\n    Staker storage staker = s_stakers[msg.sender];\\n    uint224 history = staker.history.latest();\\n    uint112 stakerPrincipal = uint112(history >> 112);\\n    if (stakerPrincipal == 0 && s_operators[msg.sender].removedPrincipal == 0) {\\n      revert StakeNotFound(msg.sender);\\n    }\\n\\n    _unbond(staker);\\n  }\\n\\n  /// @notice Registers operators from a list of unique, sorted addresses\\n  /// Addresses must be provided in sorted order so that\\n  /// address(0xNext) > address(0xPrev)\\n  /// @dev Previously removed operators cannot be readded to the pool.\\n  /// @dev precondition The caller must have the operator manager role.\\n  /// @dev precondition Cannot be called after the pool is closed.\\n  /// @param operators The sorted list of operator addresses\\n  function addOperators(address[] calldata operators)\\n    external\\n    whenBeforeClosing\\n    validateRewardVaultSet\\n    validatePoolSpace(\\n      s_pool.configs.maxPoolSize,\\n      s_pool.configs.maxPrincipalPerStaker,\\n      s_numOperators + operators.length\\n    )\\n    onlyRole(OPERATOR_MANAGER_ROLE)\\n  {\\n    for (uint256 i; i < operators.length; ++i) {\\n      address operatorAddress = operators[i];\\n      if (operatorAddress == address(0)) revert InvalidOperator();\\n      IRewardVault.StakerReward memory stakerReward = s_rewardVault.getStoredReward(operatorAddress);\\n      if (stakerReward.stakerType == IRewardVault.StakerType.COMMUNITY) {\\n        revert OperatorCannotBeCommunityStaker(operatorAddress);\\n      }\\n      // verify input list is sorted and addresses are unique\\n      if (i < operators.length - 1 && operatorAddress >= operators[i + 1]) {\\n        revert InvalidOperatorList();\\n      }\\n      Operator storage operator = s_operators[operatorAddress];\\n      if (operator.isOperator) revert OperatorAlreadyExists(operatorAddress);\\n      if (operator.isRemoved) revert OperatorHasBeenRemoved(operatorAddress);\\n      operator.isOperator = true;\\n      s_operatorSet.add(operatorAddress);\\n      emit OperatorAdded(operatorAddress);\\n    }\\n\\n    unchecked {\\n      s_numOperators += operators.length;\\n    }\\n  }\\n\\n  /// @notice Removes one or more operators from a list of operators.\\n  /// @dev Should only be callable by the owner when the pool is open.\\n  /// When an operator is removed, we store their staked LINK amount in a separate mapping to\\n  /// stop it from accruing rewards. They can withdraw their removedPrincipal and exit the system\\n  /// after going through the unbonding period.\\n  /// Removed operators are no longer slashable.\\n  /// @param operators A list of operator addresses to remove\\n  /// @dev precondition The caller must have the operator manager role.\\n  /// @dev precondition Cannot be called after the pool is closed.\\n  /// @dev precondition The operators must be currently added operators.\\n  function removeOperators(address[] calldata operators)\\n    external\\n    onlyRole(OPERATOR_MANAGER_ROLE)\\n    whenBeforeClosing\\n  {\\n    Operator storage operator;\\n    Staker storage staker;\\n    uint256 totalPrincipal = s_pool.state.totalPrincipal;\\n    for (uint256 i; i < operators.length; ++i) {\\n      address operatorAddress = operators[i];\\n      operator = s_operators[operatorAddress];\\n      if (!operator.isOperator) revert OperatorDoesNotExist(operatorAddress);\\n\\n      staker = s_stakers[operatorAddress];\\n      uint224 history = staker.history.latest();\\n      uint256 principal = uint256(history >> 112);\\n      uint256 stakedAtTime = uint112(history);\\n      s_rewardVault.concludeRewardPeriod({\\n        staker: operatorAddress,\\n        oldPrincipal: principal,\\n        unstakedAmount: principal,\\n        shouldForfeit: true,\\n        stakedAt: stakedAtTime\\n      });\\n\\n      totalPrincipal -= principal;\\n      s_pool.state.totalPrincipal = totalPrincipal;\\n      delete operator.isOperator;\\n      s_operatorSet.remove(operatorAddress);\\n      operator.isRemoved = true;\\n      // Reset the staker's stakedAtTime to 0 so their multiplier resets to 0.\\n      _updateStakerHistory({staker: staker, latestPrincipal: 0, latestStakedAtTime: 0});\\n      // Move the operator's staked LINK amount to removedPrincipal so that\\n      // the operator stops earning rewards\\n      operator.removedPrincipal = principal;\\n\\n      _resetUnbondingPeriod(staker, operatorAddress);\\n\\n      emit OperatorRemoved(operatorAddress, principal, totalPrincipal);\\n    }\\n\\n    s_numOperators -= operators.length;\\n  }\\n\\n  /// @notice Getter function to check if an address is registered as an operator\\n  /// @param staker The address of the staker\\n  /// @return bool True if the staker is an operator\\n  function isOperator(address staker) external view returns (bool) {\\n    return s_operators[staker].isOperator;\\n  }\\n\\n  /// @notice Getter function to check if an address is a removed operator\\n  /// @param staker The address of the staker\\n  /// @return bool True if the operator has been removed\\n  function isRemoved(address staker) external view returns (bool) {\\n    return s_operators[staker].isRemoved;\\n  }\\n\\n  /// @notice Getter function for a removed operator's total staked LINK amount\\n  /// @param staker The address of the staker\\n  /// @return uint256 The removed operator's staked LINK amount that hasn't been withdrawn\\n  function getRemovedPrincipal(address staker) external view returns (uint256) {\\n    return s_operators[staker].removedPrincipal;\\n  }\\n\\n  /// @notice Called by removed operators to withdraw their removed stake\\n  /// @dev precondition The caller must be in the claim period or the pool must be closed or paused.\\n  /// @dev precondition The caller must be a removed operator with some removed\\n  /// staked LINK amount.\\n  function unstakeRemovedPrincipal() external {\\n    if (!_canUnstake(s_stakers[msg.sender])) {\\n      revert StakerNotInClaimPeriod(msg.sender);\\n    }\\n\\n    uint256 withdrawableAmount = s_operators[msg.sender].removedPrincipal;\\n    if (withdrawableAmount == 0) {\\n      revert UnstakeExceedsPrincipal();\\n    }\\n    delete s_operators[msg.sender].removedPrincipal;\\n\\n    // The return value is not checked since the call will revert if any balance, allowance or\\n    // receiver conditions fail.\\n    i_LINK.transfer(msg.sender, withdrawableAmount);\\n    // Since operator has been removed their total amount staked will be 0\\n    emit Unstaked(msg.sender, withdrawableAmount, 0, s_pool.state.totalPrincipal);\\n  }\\n\\n  /// @notice Returns the number of operators configured in the pool.\\n  /// @return uint256 The number of operators configured in the pool\\n  function getNumOperators() external view returns (uint256) {\\n    return s_numOperators;\\n  }\\n\\n  /// @notice Returns the list of operators configured in the pool.\\n  /// @return address[] The list of operators configured in the pool\\n  function getOperators() external view returns (address[] memory) {\\n    return s_operatorSet.values();\\n  }\\n\\n  // =======================\\n  // ISlashable\\n  // =======================\\n\\n  /// @inheritdoc ISlashable\\n  /// @dev precondition The caller must have the default admin role.\\n  /// @dev precondition Cannot be called after the pool is closed.\\n  function addSlasher(\\n    address slasher,\\n    SlasherConfig calldata config\\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) whenBeforeClosing {\\n    _grantRole(SLASHER_ROLE, slasher);\\n    _setSlasherConfig(slasher, config);\\n  }\\n\\n  /// @inheritdoc ISlashable\\n  /// @dev precondition The caller must have the default admin role.\\n  /// @dev precondition Cannot be called after the pool is closed.\\n  function removeSlasher(address slasher) external onlyRole(DEFAULT_ADMIN_ROLE) whenBeforeClosing {\\n    if (!hasRole(SLASHER_ROLE, slasher)) {\\n      revert InvalidSlasher();\\n    }\\n    delete s_slashers[slasher];\\n    _revokeRole(SLASHER_ROLE, slasher);\\n    emit SlasherConfigSet(slasher, 0, 0);\\n  }\\n\\n  /// @inheritdoc ISlashable\\n  /// @dev precondition The caller must have the default admin role.\\n  /// @dev precondition Cannot be called after the pool is closed.\\n  function setSlasherConfig(\\n    address slasher,\\n    SlasherConfig calldata config\\n  ) external onlyRole(DEFAULT_ADMIN_ROLE) whenBeforeClosing {\\n    if (!hasRole(SLASHER_ROLE, slasher)) {\\n      revert InvalidSlasher();\\n    }\\n    _setSlasherConfig(slasher, config);\\n  }\\n\\n  /// @inheritdoc ISlashable\\n  function getSlasherConfig(address slasher) external view returns (SlasherConfig memory) {\\n    return s_slashers[slasher].config;\\n  }\\n\\n  /// @inheritdoc ISlashable\\n  function getSlashCapacity(address slasher) external view returns (uint256) {\\n    SlasherConfig memory slasherConfig = s_slashers[slasher].config;\\n    return _getRemainingSlashCapacity(slasherConfig, slasher);\\n  }\\n\\n  /// @inheritdoc ISlashable\\n  /// @dev In the current implementation, on-feed operators can raise alerts to rescue a portion of\\n  /// their slashed staked LINK amount. All operators can raise alerts in the priority period. Note\\n  /// that this may change in the future as we add alerting for additional services.\\n  /// @dev We will operationally make sure to remove an operator from the slashable (on-feed)\\n  /// operators list in alerts controllers if they are removed from the operators list in this\\n  /// contract, so there won't be a case where we slash a removed operator.\\n  /// @dev precondition The caller must have the slasher role.\\n  /// @dev precondition This contract must be active (open and stakers are earning rewards).\\n  /// @dev precondition The slasher must have enough capacity to slash.\\n  function slashAndReward(\\n    address[] calldata stakers,\\n    address alerter,\\n    uint256 principalAmount,\\n    uint256 alerterRewardAmount\\n  ) external onlySlasher whenActive whenNotPaused {\\n    SlasherConfig storage slasherConfig = s_slashers[msg.sender].config;\\n    uint256 combinedSlashAmount = stakers.length * principalAmount;\\n\\n    uint256 remainingSlashCapacity = _getRemainingSlashCapacity(slasherConfig, msg.sender);\\n    // check if the total slashed amount exceeds the slasher's capacity\\n    if (combinedSlashAmount > remainingSlashCapacity) {\\n      /// @dev If a slashing occurs with an amount to be slashed that is higher than the remaining\\n      /// slashing capacity, only an amount equal to the remaining capacity is slashed.\\n      principalAmount = remainingSlashCapacity / stakers.length;\\n    }\\n\\n    uint256 totalSlashedAmount = _slashOperators(stakers, principalAmount);\\n\\n    s_slashers[msg.sender].state.remainingSlashCapacityAmount =\\n      remainingSlashCapacity - totalSlashedAmount;\\n    s_slashers[msg.sender].state.lastSlashTimestamp = block.timestamp;\\n\\n    _payAlerter({\\n      alerter: alerter,\\n      totalSlashedAmount: totalSlashedAmount,\\n      alerterRewardAmount: alerterRewardAmount\\n    });\\n  }\\n\\n  // =======================\\n  // TypeAndVersionInterface\\n  // =======================\\n\\n  /// @inheritdoc TypeAndVersionInterface\\n  function typeAndVersion() external pure virtual override returns (string memory) {\\n    return \\\"OperatorStakingPool 1.0.0\\\";\\n  }\\n\\n  // ==============================\\n  // AccessControlDefaultAdminRules\\n  // ==============================\\n\\n  /// @inheritdoc AccessControlDefaultAdminRules\\n  /// @notice Grants `role` to `account`. Reverts if the contract manager tries to grant the default\\n  /// admin or slasher role.\\n  /// @dev The default admin role must be granted through `beginDefaultAdminTransfer` and\\n  /// `acceptDefaultAdminTransfer`.\\n  /// @dev The slasher role must be granted through `addSlasher`.\\n  /// @param role The role to grant\\n  /// @param account The address to grant the role to\\n  function grantRole(\\n    bytes32 role,\\n    address account\\n  ) public virtual override(AccessControlDefaultAdminRules) {\\n    if (role == SLASHER_ROLE) revert InvalidRole();\\n    super.grantRole(role, account);\\n  }\\n\\n  /// @inheritdoc AccessControlDefaultAdminRules\\n  /// @notice Grants `role` to `account`. Reverts if the contract manager tries to grant the default\\n  /// admin or slasher role.\\n  /// @dev The default admin role must be revoked through `beginDefaultAdminTransfer` and\\n  /// `acceptDefaultAdminTransfer` to another address.\\n  /// @dev The slasher role must be revoked through `removeSlasher`.\\n  /// @param role The role to revoke\\n  /// @param account The address to revoke the role from\\n  function revokeRole(\\n    bytes32 role,\\n    address account\\n  ) public virtual override(AccessControlDefaultAdminRules) {\\n    if (role == SLASHER_ROLE) revert InvalidRole();\\n    super.revokeRole(role, account);\\n  }\\n\\n  // ===============\\n  // StakingPoolBase\\n  // ===============\\n\\n  /// @inheritdoc StakingPoolBase\\n  function _validateOnTokenTransfer(\\n    address,\\n    address staker,\\n    bytes calldata\\n  ) internal view override(StakingPoolBase) {\\n    // check if staker is an operator\\n    if (!s_operators[staker].isOperator) revert StakerNotOperator();\\n  }\\n\\n  /// @inheritdoc StakingPoolBase\\n  function _validateBeforeOpen() internal view override(StakingPoolBase) {\\n    if (s_numOperators < i_minInitialOperatorCount) {\\n      revert InadequateInitialOperatorCount(s_numOperators, i_minInitialOperatorCount);\\n    }\\n  }\\n\\n  /// @notice Helper function to set the slasher config\\n  /// @param slasher The slasher\\n  /// @param config The slasher config\\n  function _setSlasherConfig(address slasher, SlasherConfig calldata config) private {\\n    if (config.slashCapacity == 0 || config.refillRate == 0) {\\n      revert ISlashable.InvalidSlasherConfig();\\n    }\\n\\n    s_slashers[slasher].config = config;\\n\\n    // refill capacity\\n    SlasherState storage state = s_slashers[slasher].state;\\n    state.remainingSlashCapacityAmount = config.slashCapacity;\\n    state.lastSlashTimestamp = block.timestamp;\\n\\n    emit SlasherConfigSet(slasher, config.refillRate, config.slashCapacity);\\n  }\\n\\n  /// @notice Helper function to slash operators\\n  /// @param operators The list of operators to slash\\n  /// @param principalAmount The amount to slash from each operator's staked\\n  /// LINK amount\\n  /// @return The total amount slashed from all operators\\n  function _slashOperators(\\n    address[] calldata operators,\\n    uint256 principalAmount\\n  ) private returns (uint256) {\\n    // perform the slash on all operators and add up the total slashed amount\\n    uint256 totalSlashedAmount;\\n    Staker storage staker;\\n    uint256 totalPrincipal = s_pool.state.totalPrincipal;\\n    for (uint256 i; i < operators.length; ++i) {\\n      // verify input list is sorted and addresses are unique\\n      address operatorAddress = operators[i];\\n      if (i < operators.length - 1 && operatorAddress >= operators[i + 1]) {\\n        revert InvalidOperatorList();\\n      }\\n      staker = s_stakers[operatorAddress];\\n      uint224 history = staker.history.latest();\\n      uint256 operatorPrincipal = uint112(history >> 112);\\n      uint256 stakerStakedAtTime = uint112(history);\\n      uint256 slashedAmount =\\n        principalAmount > operatorPrincipal ? operatorPrincipal : principalAmount;\\n      uint256 updatedPrincipal = operatorPrincipal - slashedAmount;\\n\\n      // update the staker's rewards\\n      s_rewardVault.updateReward(operatorAddress, operatorPrincipal);\\n      _updateStakerHistory({\\n        staker: staker,\\n        latestPrincipal: updatedPrincipal,\\n        latestStakedAtTime: stakerStakedAtTime\\n      });\\n\\n      totalSlashedAmount += slashedAmount;\\n      totalPrincipal -= slashedAmount;\\n\\n      emit Slashed(operatorAddress, slashedAmount, updatedPrincipal, totalPrincipal);\\n    }\\n    // update the pool state\\n    s_pool.state.totalPrincipal = totalPrincipal;\\n\\n    return totalSlashedAmount;\\n  }\\n\\n  /// @notice Helper function to reward the alerter\\n  /// @param alerter The alerter\\n  /// @param totalSlashedAmount The total amount slashed from all the operators\\n  /// @param alerterRewardAmount The amount to reward the alerter\\n  function _payAlerter(\\n    address alerter,\\n    uint256 totalSlashedAmount,\\n    uint256 alerterRewardAmount\\n  ) private {\\n    uint256 newAlerterRewardFunds = s_alerterRewardFunds + totalSlashedAmount;\\n    uint256 alerterRewardActual =\\n      newAlerterRewardFunds < alerterRewardAmount ? newAlerterRewardFunds : alerterRewardAmount;\\n    s_alerterRewardFunds = newAlerterRewardFunds - alerterRewardActual;\\n\\n    // We emit an event here instead of reverting so that the alerter can\\n    // immediately receive a portion of their rewards.  This event\\n    // will allow the contract manager to reimburse any remaining rewards to the\\n    // alerter.\\n    emit AlertingRewardPaid(alerter, alerterRewardActual, alerterRewardAmount);\\n\\n    // The return value is not checked since the call will revert if any balance, allowance or\\n    // receiver conditions fail.\\n    i_LINK.transfer(alerter, alerterRewardActual);\\n  }\\n\\n  /// @notice Helper function to return the current remaining slash capacity for a slasher\\n  /// @param slasherConfig The slasher's config\\n  /// @param slasher The slasher\\n  /// @return The remaining slashing capacity\\n  function _getRemainingSlashCapacity(\\n    SlasherConfig memory slasherConfig,\\n    address slasher\\n  ) private view returns (uint256) {\\n    SlasherState memory slasherState = s_slashers[slasher].state;\\n    uint256 refilledAmount =\\n      (block.timestamp - slasherState.lastSlashTimestamp) * slasherConfig.refillRate;\\n\\n    return Math.min(\\n      slasherConfig.slashCapacity, slasherState.remainingSlashCapacityAmount + refilledAmount\\n    );\\n  }\\n\\n  /// @dev Reverts if the msg.sender doesn't have the rewarder role.\\n  modifier onlyRewarder() {\\n    if (!hasRole(ALERT_REWARDER_ROLE, msg.sender)) {\\n      revert AccessForbidden();\\n    }\\n    _;\\n  }\\n\\n  /// @dev Reverts if not sent by an address that has the SLASHER role\\n  modifier onlySlasher() {\\n    if (!hasRole(SLASHER_ROLE, msg.sender)) {\\n      revert AccessForbidden();\\n    }\\n    _;\\n  }\\n\\n  /// @notice Checks that the maximum pool size is greater than or equal to\\n  /// the reserved space for operators.\\n  /// @param maxPoolSize The maximum pool size of the operator staking pool\\n  /// @param maxPrincipalPerStaker The maximum amount an operator can stake in the\\n  /// @param numOperators The number of operators in the pool\\n  /// @dev The reserved space is calculated by multiplying the number of\\n  /// operators and the maximum staked LINK amount per operator\\n  modifier validatePoolSpace(\\n    uint256 maxPoolSize,\\n    uint256 maxPrincipalPerStaker,\\n    uint256 numOperators\\n  ) {\\n    if (maxPoolSize < maxPrincipalPerStaker * numOperators) {\\n      revert InsufficientPoolSpace(maxPoolSize, maxPrincipalPerStaker, numOperators);\\n    }\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/chainlink/contracts/src/v0.8/interfaces/TypeAndVersionInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract TypeAndVersionInterface {\\n  function typeAndVersion() external pure virtual returns (string memory);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/AccessControlDefaultAdminRules.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControlDefaultAdminRules.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AccessControl.sol\\\";\\nimport \\\"./IAccessControlDefaultAdminRules.sol\\\";\\nimport \\\"../utils/math/SafeCast.sol\\\";\\nimport \\\"../interfaces/IERC5313.sol\\\";\\n\\n/**\\n * @dev Extension of {AccessControl} that allows specifying special rules to manage\\n * the `DEFAULT_ADMIN_ROLE` holder, which is a sensitive role with special permissions\\n * over other roles that may potentially have privileged rights in the system.\\n *\\n * If a specific role doesn't have an admin role assigned, the holder of the\\n * `DEFAULT_ADMIN_ROLE` will have the ability to grant it and revoke it.\\n *\\n * This contract implements the following risk mitigations on top of {AccessControl}:\\n *\\n * * Only one account holds the `DEFAULT_ADMIN_ROLE` since deployment until it's potentially renounced.\\n * * Enforces a 2-step process to transfer the `DEFAULT_ADMIN_ROLE` to another account.\\n * * Enforces a configurable delay between the two steps, with the ability to cancel before the transfer is accepted.\\n * * The delay can be changed by scheduling, see {changeDefaultAdminDelay}.\\n * * It is not possible to use another role to manage the `DEFAULT_ADMIN_ROLE`.\\n *\\n * Example usage:\\n *\\n * ```solidity\\n * contract MyToken is AccessControlDefaultAdminRules {\\n *   constructor() AccessControlDefaultAdminRules(\\n *     3 days,\\n *     msg.sender // Explicit initial `DEFAULT_ADMIN_ROLE` holder\\n *    ) {}\\n * }\\n * ```\\n *\\n * _Available since v4.9._\\n */\\nabstract contract AccessControlDefaultAdminRules is IAccessControlDefaultAdminRules, IERC5313, AccessControl {\\n    // pending admin pair read/written together frequently\\n    address private _pendingDefaultAdmin;\\n    uint48 private _pendingDefaultAdminSchedule; // 0 == unset\\n\\n    uint48 private _currentDelay;\\n    address private _currentDefaultAdmin;\\n\\n    // pending delay pair read/written together frequently\\n    uint48 private _pendingDelay;\\n    uint48 private _pendingDelaySchedule; // 0 == unset\\n\\n    /**\\n     * @dev Sets the initial values for {defaultAdminDelay} and {defaultAdmin} address.\\n     */\\n    constructor(uint48 initialDelay, address initialDefaultAdmin) {\\n        require(initialDefaultAdmin != address(0), \\\"AccessControl: 0 default admin\\\");\\n        _currentDelay = initialDelay;\\n        _grantRole(DEFAULT_ADMIN_ROLE, initialDefaultAdmin);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControlDefaultAdminRules).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC5313-owner}.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return defaultAdmin();\\n    }\\n\\n    ///\\n    /// Override AccessControl role management\\n    ///\\n\\n    /**\\n     * @dev See {AccessControl-grantRole}. Reverts for `DEFAULT_ADMIN_ROLE`.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\\n        require(role != DEFAULT_ADMIN_ROLE, \\\"AccessControl: can't directly grant default admin role\\\");\\n        super.grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev See {AccessControl-revokeRole}. Reverts for `DEFAULT_ADMIN_ROLE`.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\\n        require(role != DEFAULT_ADMIN_ROLE, \\\"AccessControl: can't directly revoke default admin role\\\");\\n        super.revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev See {AccessControl-renounceRole}.\\n     *\\n     * For the `DEFAULT_ADMIN_ROLE`, it only allows renouncing in two steps by first calling\\n     * {beginDefaultAdminTransfer} to the `address(0)`, so it's required that the {pendingDefaultAdmin} schedule\\n     * has also passed when calling this function.\\n     *\\n     * After its execution, it will not be possible to call `onlyRole(DEFAULT_ADMIN_ROLE)` functions.\\n     *\\n     * NOTE: Renouncing `DEFAULT_ADMIN_ROLE` will leave the contract without a {defaultAdmin},\\n     * thereby disabling any functionality that is only available for it, and the possibility of reassigning a\\n     * non-administrated role.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\\n        if (role == DEFAULT_ADMIN_ROLE && account == defaultAdmin()) {\\n            (address newDefaultAdmin, uint48 schedule) = pendingDefaultAdmin();\\n            require(\\n                newDefaultAdmin == address(0) && _isScheduleSet(schedule) && _hasSchedulePassed(schedule),\\n                \\\"AccessControl: only can renounce in two delayed steps\\\"\\n            );\\n            delete _pendingDefaultAdminSchedule;\\n        }\\n        super.renounceRole(role, account);\\n    }\\n\\n    /**\\n     * @dev See {AccessControl-_grantRole}.\\n     *\\n     * For `DEFAULT_ADMIN_ROLE`, it only allows granting if there isn't already a {defaultAdmin} or if the\\n     * role has been previously renounced.\\n     *\\n     * NOTE: Exposing this function through another mechanism may make the `DEFAULT_ADMIN_ROLE`\\n     * assignable again. Make sure to guarantee this is the expected behavior in your implementation.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual override {\\n        if (role == DEFAULT_ADMIN_ROLE) {\\n            require(defaultAdmin() == address(0), \\\"AccessControl: default admin already granted\\\");\\n            _currentDefaultAdmin = account;\\n        }\\n        super._grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev See {AccessControl-_revokeRole}.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual override {\\n        if (role == DEFAULT_ADMIN_ROLE && account == defaultAdmin()) {\\n            delete _currentDefaultAdmin;\\n        }\\n        super._revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev See {AccessControl-_setRoleAdmin}. Reverts for `DEFAULT_ADMIN_ROLE`.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual override {\\n        require(role != DEFAULT_ADMIN_ROLE, \\\"AccessControl: can't violate default admin rules\\\");\\n        super._setRoleAdmin(role, adminRole);\\n    }\\n\\n    ///\\n    /// AccessControlDefaultAdminRules accessors\\n    ///\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function defaultAdmin() public view virtual returns (address) {\\n        return _currentDefaultAdmin;\\n    }\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function pendingDefaultAdmin() public view virtual returns (address newAdmin, uint48 schedule) {\\n        return (_pendingDefaultAdmin, _pendingDefaultAdminSchedule);\\n    }\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function defaultAdminDelay() public view virtual returns (uint48) {\\n        uint48 schedule = _pendingDelaySchedule;\\n        return (_isScheduleSet(schedule) && _hasSchedulePassed(schedule)) ? _pendingDelay : _currentDelay;\\n    }\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function pendingDefaultAdminDelay() public view virtual returns (uint48 newDelay, uint48 schedule) {\\n        schedule = _pendingDelaySchedule;\\n        return (_isScheduleSet(schedule) && !_hasSchedulePassed(schedule)) ? (_pendingDelay, schedule) : (0, 0);\\n    }\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function defaultAdminDelayIncreaseWait() public view virtual returns (uint48) {\\n        return 5 days;\\n    }\\n\\n    ///\\n    /// AccessControlDefaultAdminRules public and internal setters for defaultAdmin/pendingDefaultAdmin\\n    ///\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function beginDefaultAdminTransfer(address newAdmin) public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _beginDefaultAdminTransfer(newAdmin);\\n    }\\n\\n    /**\\n     * @dev See {beginDefaultAdminTransfer}.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _beginDefaultAdminTransfer(address newAdmin) internal virtual {\\n        uint48 newSchedule = SafeCast.toUint48(block.timestamp) + defaultAdminDelay();\\n        _setPendingDefaultAdmin(newAdmin, newSchedule);\\n        emit DefaultAdminTransferScheduled(newAdmin, newSchedule);\\n    }\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function cancelDefaultAdminTransfer() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _cancelDefaultAdminTransfer();\\n    }\\n\\n    /**\\n     * @dev See {cancelDefaultAdminTransfer}.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _cancelDefaultAdminTransfer() internal virtual {\\n        _setPendingDefaultAdmin(address(0), 0);\\n    }\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function acceptDefaultAdminTransfer() public virtual {\\n        (address newDefaultAdmin, ) = pendingDefaultAdmin();\\n        require(_msgSender() == newDefaultAdmin, \\\"AccessControl: pending admin must accept\\\");\\n        _acceptDefaultAdminTransfer();\\n    }\\n\\n    /**\\n     * @dev See {acceptDefaultAdminTransfer}.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _acceptDefaultAdminTransfer() internal virtual {\\n        (address newAdmin, uint48 schedule) = pendingDefaultAdmin();\\n        require(_isScheduleSet(schedule) && _hasSchedulePassed(schedule), \\\"AccessControl: transfer delay not passed\\\");\\n        _revokeRole(DEFAULT_ADMIN_ROLE, defaultAdmin());\\n        _grantRole(DEFAULT_ADMIN_ROLE, newAdmin);\\n        delete _pendingDefaultAdmin;\\n        delete _pendingDefaultAdminSchedule;\\n    }\\n\\n    ///\\n    /// AccessControlDefaultAdminRules public and internal setters for defaultAdminDelay/pendingDefaultAdminDelay\\n    ///\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function changeDefaultAdminDelay(uint48 newDelay) public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _changeDefaultAdminDelay(newDelay);\\n    }\\n\\n    /**\\n     * @dev See {changeDefaultAdminDelay}.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _changeDefaultAdminDelay(uint48 newDelay) internal virtual {\\n        uint48 newSchedule = SafeCast.toUint48(block.timestamp) + _delayChangeWait(newDelay);\\n        _setPendingDelay(newDelay, newSchedule);\\n        emit DefaultAdminDelayChangeScheduled(newDelay, newSchedule);\\n    }\\n\\n    /**\\n     * @inheritdoc IAccessControlDefaultAdminRules\\n     */\\n    function rollbackDefaultAdminDelay() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {\\n        _rollbackDefaultAdminDelay();\\n    }\\n\\n    /**\\n     * @dev See {rollbackDefaultAdminDelay}.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _rollbackDefaultAdminDelay() internal virtual {\\n        _setPendingDelay(0, 0);\\n    }\\n\\n    /**\\n     * @dev Returns the amount of seconds to wait after the `newDelay` will\\n     * become the new {defaultAdminDelay}.\\n     *\\n     * The value returned guarantees that if the delay is reduced, it will go into effect\\n     * after a wait that honors the previously set delay.\\n     *\\n     * See {defaultAdminDelayIncreaseWait}.\\n     */\\n    function _delayChangeWait(uint48 newDelay) internal view virtual returns (uint48) {\\n        uint48 currentDelay = defaultAdminDelay();\\n\\n        // When increasing the delay, we schedule the delay change to occur after a period of \\\"new delay\\\" has passed, up\\n        // to a maximum given by defaultAdminDelayIncreaseWait, by default 5 days. For example, if increasing from 1 day\\n        // to 3 days, the new delay will come into effect after 3 days. If increasing from 1 day to 10 days, the new\\n        // delay will come into effect after 5 days. The 5 day wait period is intended to be able to fix an error like\\n        // using milliseconds instead of seconds.\\n        //\\n        // When decreasing the delay, we wait the difference between \\\"current delay\\\" and \\\"new delay\\\". This guarantees\\n        // that an admin transfer cannot be made faster than \\\"current delay\\\" at the time the delay change is scheduled.\\n        // For example, if decreasing from 10 days to 3 days, the new delay will come into effect after 7 days.\\n        return\\n            newDelay > currentDelay\\n                ? uint48(Math.min(newDelay, defaultAdminDelayIncreaseWait())) // no need to safecast, both inputs are uint48\\n                : currentDelay - newDelay;\\n    }\\n\\n    ///\\n    /// Private setters\\n    ///\\n\\n    /**\\n     * @dev Setter of the tuple for pending admin and its schedule.\\n     *\\n     * May emit a DefaultAdminTransferCanceled event.\\n     */\\n    function _setPendingDefaultAdmin(address newAdmin, uint48 newSchedule) private {\\n        (, uint48 oldSchedule) = pendingDefaultAdmin();\\n\\n        _pendingDefaultAdmin = newAdmin;\\n        _pendingDefaultAdminSchedule = newSchedule;\\n\\n        // An `oldSchedule` from `pendingDefaultAdmin()` is only set if it hasn't been accepted.\\n        if (_isScheduleSet(oldSchedule)) {\\n            // Emit for implicit cancellations when another default admin was scheduled.\\n            emit DefaultAdminTransferCanceled();\\n        }\\n    }\\n\\n    /**\\n     * @dev Setter of the tuple for pending delay and its schedule.\\n     *\\n     * May emit a DefaultAdminDelayChangeCanceled event.\\n     */\\n    function _setPendingDelay(uint48 newDelay, uint48 newSchedule) private {\\n        uint48 oldSchedule = _pendingDelaySchedule;\\n\\n        if (_isScheduleSet(oldSchedule)) {\\n            if (_hasSchedulePassed(oldSchedule)) {\\n                // Materialize a virtual delay\\n                _currentDelay = _pendingDelay;\\n            } else {\\n                // Emit for implicit cancellations when another delay was scheduled.\\n                emit DefaultAdminDelayChangeCanceled();\\n            }\\n        }\\n\\n        _pendingDelay = newDelay;\\n        _pendingDelaySchedule = newSchedule;\\n    }\\n\\n    ///\\n    /// Private helpers\\n    ///\\n\\n    /**\\n     * @dev Defines if an `schedule` is considered set. For consistency purposes.\\n     */\\n    function _isScheduleSet(uint48 schedule) private pure returns (bool) {\\n        return schedule != 0;\\n    }\\n\\n    /**\\n     * @dev Defines if an `schedule` is considered passed. For consistency purposes.\\n     */\\n    function _hasSchedulePassed(uint48 schedule) private view returns (bool) {\\n        return schedule < block.timestamp;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Checkpoints.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Checkpoints.sol)\\n// This file was procedurally generated from scripts/generate/templates/Checkpoints.js.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SafeCast.sol\\\";\\n\\n/**\\n * @dev This library defines the `History` struct, for checkpointing values as they change at different points in\\n * time, and later looking up past values by block number. See {Votes} as an example.\\n *\\n * To create a history of checkpoints define a variable type `Checkpoints.History` in your contract, and store a new\\n * checkpoint for the current transaction block using the {push} function.\\n *\\n * _Available since v4.5._\\n */\\nlibrary Checkpoints {\\n    struct History {\\n        Checkpoint[] _checkpoints;\\n    }\\n\\n    struct Checkpoint {\\n        uint32 _blockNumber;\\n        uint224 _value;\\n    }\\n\\n    /**\\n     * @dev Returns the value at a given block number. If a checkpoint is not available at that block, the closest one\\n     * before it is returned, or zero otherwise. Because the number returned corresponds to that at the end of the\\n     * block, the requested block number must be in the past, excluding the current block.\\n     */\\n    function getAtBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {\\n        require(blockNumber < block.number, \\\"Checkpoints: block not yet mined\\\");\\n        uint32 key = SafeCast.toUint32(blockNumber);\\n\\n        uint256 len = self._checkpoints.length;\\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value at a given block number. If a checkpoint is not available at that block, the closest one\\n     * before it is returned, or zero otherwise. Similar to {upperLookup} but optimized for the case when the searched\\n     * checkpoint is probably \\\"recent\\\", defined as being among the last sqrt(N) checkpoints where N is the number of\\n     * checkpoints.\\n     */\\n    function getAtProbablyRecentBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {\\n        require(blockNumber < block.number, \\\"Checkpoints: block not yet mined\\\");\\n        uint32 key = SafeCast.toUint32(blockNumber);\\n\\n        uint256 len = self._checkpoints.length;\\n\\n        uint256 low = 0;\\n        uint256 high = len;\\n\\n        if (len > 5) {\\n            uint256 mid = len - Math.sqrt(len);\\n            if (key < _unsafeAccess(self._checkpoints, mid)._blockNumber) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\\n\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Pushes a value onto a History so that it is stored as the checkpoint for the current block.\\n     *\\n     * Returns previous value and new value.\\n     */\\n    function push(History storage self, uint256 value) internal returns (uint256, uint256) {\\n        return _insert(self._checkpoints, SafeCast.toUint32(block.number), SafeCast.toUint224(value));\\n    }\\n\\n    /**\\n     * @dev Pushes a value onto a History, by updating the latest value using binary operation `op`. The new value will\\n     * be set to `op(latest, delta)`.\\n     *\\n     * Returns previous value and new value.\\n     */\\n    function push(\\n        History storage self,\\n        function(uint256, uint256) view returns (uint256) op,\\n        uint256 delta\\n    ) internal returns (uint256, uint256) {\\n        return push(self, op(latest(self), delta));\\n    }\\n\\n    /**\\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\\n     */\\n    function latest(History storage self) internal view returns (uint224) {\\n        uint256 pos = self._checkpoints.length;\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\\n     * in the most recent checkpoint.\\n     */\\n    function latestCheckpoint(\\n        History storage self\\n    ) internal view returns (bool exists, uint32 _blockNumber, uint224 _value) {\\n        uint256 pos = self._checkpoints.length;\\n        if (pos == 0) {\\n            return (false, 0, 0);\\n        } else {\\n            Checkpoint memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\\n            return (true, ckpt._blockNumber, ckpt._value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the number of checkpoint.\\n     */\\n    function length(History storage self) internal view returns (uint256) {\\n        return self._checkpoints.length;\\n    }\\n\\n    /**\\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\\n     * or by updating the last one.\\n     */\\n    function _insert(Checkpoint[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {\\n        uint256 pos = self.length;\\n\\n        if (pos > 0) {\\n            // Copying to memory is important here.\\n            Checkpoint memory last = _unsafeAccess(self, pos - 1);\\n\\n            // Checkpoint keys must be non-decreasing.\\n            require(last._blockNumber <= key, \\\"Checkpoint: decreasing keys\\\");\\n\\n            // Update or push new checkpoint\\n            if (last._blockNumber == key) {\\n                _unsafeAccess(self, pos - 1)._value = value;\\n            } else {\\n                self.push(Checkpoint({_blockNumber: key, _value: value}));\\n            }\\n            return (last._value, value);\\n        } else {\\n            self.push(Checkpoint({_blockNumber: key, _value: value}));\\n            return (0, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\\n     *\\n     * WARNING: `high` should not be greater than the array's length.\\n     */\\n    function _upperBinaryLookup(\\n        Checkpoint[] storage self,\\n        uint32 key,\\n        uint256 low,\\n        uint256 high\\n    ) private view returns (uint256) {\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n            if (_unsafeAccess(self, mid)._blockNumber > key) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    /**\\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\\n     *\\n     * WARNING: `high` should not be greater than the array's length.\\n     */\\n    function _lowerBinaryLookup(\\n        Checkpoint[] storage self,\\n        uint32 key,\\n        uint256 low,\\n        uint256 high\\n    ) private view returns (uint256) {\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n            if (_unsafeAccess(self, mid)._blockNumber < key) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    /**\\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\\n     */\\n    function _unsafeAccess(Checkpoint[] storage self, uint256 pos) private pure returns (Checkpoint storage result) {\\n        assembly {\\n            mstore(0, self.slot)\\n            result.slot := add(keccak256(0, 0x20), pos)\\n        }\\n    }\\n\\n    struct Trace224 {\\n        Checkpoint224[] _checkpoints;\\n    }\\n\\n    struct Checkpoint224 {\\n        uint32 _key;\\n        uint224 _value;\\n    }\\n\\n    /**\\n     * @dev Pushes a (`key`, `value`) pair into a Trace224 so that it is stored as the checkpoint.\\n     *\\n     * Returns previous value and new value.\\n     */\\n    function push(Trace224 storage self, uint32 key, uint224 value) internal returns (uint224, uint224) {\\n        return _insert(self._checkpoints, key, value);\\n    }\\n\\n    /**\\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if there is none.\\n     */\\n    function lowerLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\\n        uint256 len = self._checkpoints.length;\\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\\n     */\\n    function upperLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\\n        uint256 len = self._checkpoints.length;\\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\\n     *\\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \\\"recent\\\" checkpoint (checkpoints with high keys).\\n     */\\n    function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {\\n        uint256 len = self._checkpoints.length;\\n\\n        uint256 low = 0;\\n        uint256 high = len;\\n\\n        if (len > 5) {\\n            uint256 mid = len - Math.sqrt(len);\\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\\n\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\\n     */\\n    function latest(Trace224 storage self) internal view returns (uint224) {\\n        uint256 pos = self._checkpoints.length;\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\\n     * in the most recent checkpoint.\\n     */\\n    function latestCheckpoint(Trace224 storage self) internal view returns (bool exists, uint32 _key, uint224 _value) {\\n        uint256 pos = self._checkpoints.length;\\n        if (pos == 0) {\\n            return (false, 0, 0);\\n        } else {\\n            Checkpoint224 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\\n            return (true, ckpt._key, ckpt._value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the number of checkpoint.\\n     */\\n    function length(Trace224 storage self) internal view returns (uint256) {\\n        return self._checkpoints.length;\\n    }\\n\\n    /**\\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\\n     * or by updating the last one.\\n     */\\n    function _insert(Checkpoint224[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {\\n        uint256 pos = self.length;\\n\\n        if (pos > 0) {\\n            // Copying to memory is important here.\\n            Checkpoint224 memory last = _unsafeAccess(self, pos - 1);\\n\\n            // Checkpoint keys must be non-decreasing.\\n            require(last._key <= key, \\\"Checkpoint: decreasing keys\\\");\\n\\n            // Update or push new checkpoint\\n            if (last._key == key) {\\n                _unsafeAccess(self, pos - 1)._value = value;\\n            } else {\\n                self.push(Checkpoint224({_key: key, _value: value}));\\n            }\\n            return (last._value, value);\\n        } else {\\n            self.push(Checkpoint224({_key: key, _value: value}));\\n            return (0, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\\n     *\\n     * WARNING: `high` should not be greater than the array's length.\\n     */\\n    function _upperBinaryLookup(\\n        Checkpoint224[] storage self,\\n        uint32 key,\\n        uint256 low,\\n        uint256 high\\n    ) private view returns (uint256) {\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n            if (_unsafeAccess(self, mid)._key > key) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    /**\\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\\n     *\\n     * WARNING: `high` should not be greater than the array's length.\\n     */\\n    function _lowerBinaryLookup(\\n        Checkpoint224[] storage self,\\n        uint32 key,\\n        uint256 low,\\n        uint256 high\\n    ) private view returns (uint256) {\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n            if (_unsafeAccess(self, mid)._key < key) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    /**\\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\\n     */\\n    function _unsafeAccess(\\n        Checkpoint224[] storage self,\\n        uint256 pos\\n    ) private pure returns (Checkpoint224 storage result) {\\n        assembly {\\n            mstore(0, self.slot)\\n            result.slot := add(keccak256(0, 0x20), pos)\\n        }\\n    }\\n\\n    struct Trace160 {\\n        Checkpoint160[] _checkpoints;\\n    }\\n\\n    struct Checkpoint160 {\\n        uint96 _key;\\n        uint160 _value;\\n    }\\n\\n    /**\\n     * @dev Pushes a (`key`, `value`) pair into a Trace160 so that it is stored as the checkpoint.\\n     *\\n     * Returns previous value and new value.\\n     */\\n    function push(Trace160 storage self, uint96 key, uint160 value) internal returns (uint160, uint160) {\\n        return _insert(self._checkpoints, key, value);\\n    }\\n\\n    /**\\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if there is none.\\n     */\\n    function lowerLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\\n        uint256 len = self._checkpoints.length;\\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\\n     */\\n    function upperLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\\n        uint256 len = self._checkpoints.length;\\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.\\n     *\\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \\\"recent\\\" checkpoint (checkpoints with high keys).\\n     */\\n    function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {\\n        uint256 len = self._checkpoints.length;\\n\\n        uint256 low = 0;\\n        uint256 high = len;\\n\\n        if (len > 5) {\\n            uint256 mid = len - Math.sqrt(len);\\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\\n\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\\n     */\\n    function latest(Trace160 storage self) internal view returns (uint160) {\\n        uint256 pos = self._checkpoints.length;\\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\\n    }\\n\\n    /**\\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\\n     * in the most recent checkpoint.\\n     */\\n    function latestCheckpoint(Trace160 storage self) internal view returns (bool exists, uint96 _key, uint160 _value) {\\n        uint256 pos = self._checkpoints.length;\\n        if (pos == 0) {\\n            return (false, 0, 0);\\n        } else {\\n            Checkpoint160 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\\n            return (true, ckpt._key, ckpt._value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the number of checkpoint.\\n     */\\n    function length(Trace160 storage self) internal view returns (uint256) {\\n        return self._checkpoints.length;\\n    }\\n\\n    /**\\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\\n     * or by updating the last one.\\n     */\\n    function _insert(Checkpoint160[] storage self, uint96 key, uint160 value) private returns (uint160, uint160) {\\n        uint256 pos = self.length;\\n\\n        if (pos > 0) {\\n            // Copying to memory is important here.\\n            Checkpoint160 memory last = _unsafeAccess(self, pos - 1);\\n\\n            // Checkpoint keys must be non-decreasing.\\n            require(last._key <= key, \\\"Checkpoint: decreasing keys\\\");\\n\\n            // Update or push new checkpoint\\n            if (last._key == key) {\\n                _unsafeAccess(self, pos - 1)._value = value;\\n            } else {\\n                self.push(Checkpoint160({_key: key, _value: value}));\\n            }\\n            return (last._value, value);\\n        } else {\\n            self.push(Checkpoint160({_key: key, _value: value}));\\n            return (0, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.\\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\\n     *\\n     * WARNING: `high` should not be greater than the array's length.\\n     */\\n    function _upperBinaryLookup(\\n        Checkpoint160[] storage self,\\n        uint96 key,\\n        uint256 low,\\n        uint256 high\\n    ) private view returns (uint256) {\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n            if (_unsafeAccess(self, mid)._key > key) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    /**\\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.\\n     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.\\n     *\\n     * WARNING: `high` should not be greater than the array's length.\\n     */\\n    function _lowerBinaryLookup(\\n        Checkpoint160[] storage self,\\n        uint96 key,\\n        uint256 low,\\n        uint256 high\\n    ) private view returns (uint256) {\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n            if (_unsafeAccess(self, mid)._key < key) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    /**\\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\\n     */\\n    function _unsafeAccess(\\n        Checkpoint160[] storage self,\\n        uint256 pos\\n    ) private pure returns (Checkpoint160 storage result) {\\n        assembly {\\n            mstore(0, self.slot)\\n            result.slot := add(keccak256(0, 0x20), pos)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISlashable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface ISlashable {\\n  /// @notice This error is thrown when the slasher config is invalid\\n  error InvalidSlasherConfig();\\n\\n  /// @notice This error is thrown when the contract manager tries to set the slasher role directly\\n  /// through\\n  /// `grantRole`\\n  error InvalidRole();\\n\\n  /// @notice This error is thrown then the contract manager tries to set the slasher config for an\\n  /// address\\n  /// that doesn't have the slasher role\\n  error InvalidSlasher();\\n\\n  /// @notice This struct defines the parameters of the slasher config\\n  struct SlasherConfig {\\n    /// @notice The pool's refill rate (Juels/sec)\\n    uint256 refillRate;\\n    /// @notice The refillable slash capacity amount\\n    uint256 slashCapacity;\\n  }\\n\\n  /// @notice This struct defines the parameters of the slasher state\\n  struct SlasherState {\\n    /// @notice The last slash timestamp, will be 0 if never slashed\\n    /// The timestamp will be set to the time the slashing configuration was configured\\n    /// instead of 0 if slashing never occurs, refilling slash capacity to full.\\n    uint256 lastSlashTimestamp;\\n    /// @notice The current amount of remaining slash capacity\\n    uint256 remainingSlashCapacityAmount;\\n  }\\n\\n  /// @notice This struct defines the slasher's state and config\\n  struct Slasher {\\n    /// @notice The slasher's config\\n    SlasherConfig config;\\n    /// @notice The slasher's state\\n    SlasherState state;\\n  }\\n\\n  /// @notice Adds a new slasher with the given config\\n  /// @param slasher The address of the slasher\\n  /// @param config The slasher config\\n  function addSlasher(address slasher, SlasherConfig calldata config) external;\\n\\n  /// @notice Removes a slasher by revoking the SLASHER_ROLE and resetting the slasher config\\n  /// @param slasher The address of the slasher\\n  function removeSlasher(address slasher) external;\\n\\n  /// @notice Sets the slasher config\\n  /// @param slasher The address of the slasher\\n  /// @param config The slasher config\\n  function setSlasherConfig(address slasher, SlasherConfig calldata config) external;\\n\\n  /// @notice Returns the slasher config\\n  /// @param slasher The slasher\\n  /// @return The slasher config\\n  function getSlasherConfig(address slasher) external view returns (SlasherConfig memory);\\n\\n  /// @notice Returns the slash capacity for a slasher\\n  /// @param slasher The slasher\\n  /// @return The slash capacity\\n  function getSlashCapacity(address slasher) external view returns (uint256);\\n\\n  /// @notice Slashes stakers and rewards the alerter.  Moves slashed staker\\n  /// funds into the alerter reward funds.  The alerter is then\\n  /// rewarded by the funds in the alerter reward funds.\\n  /// @param stakers The list of stakers to slash\\n  /// @param alerter The alerter that successfully raised the alert\\n  /// @param principalAmount The amount of the staker's staked LINK amount to slash\\n  /// @param alerterRewardAmount The reward amount to be given to the alerter\\n  function slashAndReward(\\n    address[] calldata stakers,\\n    address alerter,\\n    uint256 principalAmount,\\n    uint256 alerterRewardAmount\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IRewardVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IRewardVault {\\n  /// @notice This enum describes the different staker types\\n  enum StakerType {\\n    NOT_STAKED,\\n    COMMUNITY,\\n    OPERATOR\\n  }\\n\\n  /// @notice This struct is used to store the reward information for a staker.\\n  struct StakerReward {\\n    /// @notice The staker's accrued multiplier-applied reward that's accounted for and stored.\\n    /// This is used for storing delegated rewards and preserving the staker's past rewards between\\n    /// unstakes or multiplier resets.\\n    /// To get the full claimable reward amount, this value is added to the stored reward *\\n    /// multiplier.\\n    /// @dev This value is reset when a staker calls claimRewards and rewards\\n    /// are transferred to the staker.\\n    uint112 vestedBaseReward;\\n    /// @notice The staker's accrued delegated reward that's accounted for and stored.\\n    /// Delegated rewards are not subject to the ramp up multiplier and are immediately finalized.\\n    /// @dev This value is reset when a staker calls claimRewards and rewards\\n    /// are transferred to the staker.\\n    uint112 vestedDelegatedReward;\\n    /// @notice The last updated per-token base reward of the staker.  This\\n    /// value only increases over time\\n    uint112 baseRewardPerToken;\\n    /// @notice The last updated per-token delegated reward of the operator\\n    uint112 operatorDelegatedRewardPerToken;\\n    /// @notice The staker type\\n    /// @dev This value is set once the first time a staker stakes. This value is used to enforce\\n    /// that a community staker is not added as an operator.\\n    StakerType stakerType;\\n    /// @notice The amount of base rewards that the staker has claimed between\\n    /// the last time they staked/unstaked until they stake, unstake again or\\n    /// when an operator is removed.\\n    /// @dev This is reset to 0 whenever concludeRewardPeriod is called\\n    /// @dev This is set to vestedBaseReward whenever claimReward is called\\n    /// @dev Invariant: The sum of unvestedBaseReward and claimedBaseRewardsInPeriod\\n    /// is the total amount of base rewards a staker has earned since the last time\\n    /// they stake/unstake.\\n    uint112 claimedBaseRewardsInPeriod;\\n    /// @notice The staker's earned but unvested base rewards. The staker's current multiplier is\\n    /// applied to get the vested base reward amount.\\n    uint112 unvestedBaseReward;\\n  }\\n\\n  /// @notice Claims reward earned by a staker.\\n  /// @return uint256 The amount of rewards claimed in juels\\n  function claimReward() external returns (uint256);\\n\\n  /// @notice Updates the staking pools' reward per token and staker\u2019s reward state\\n  /// in the reward vault. This is called whenever an operator is slashed as we want\\n  /// to update the operator's rewards state without resetting their multiplier.\\n  /// @param staker The staker's address. If this is set to zero address,\\n  /// staker's reward update will be skipped\\n  /// @param stakerPrincipal The staker's current staked LINK amount in juels\\n  function updateReward(address staker, uint256 stakerPrincipal) external;\\n\\n  /// @notice Concludes the staker's current reward period (defined by a multiplier reset).\\n  /// This will apply the staker's current ramp up multiplier to their\\n  /// earned rewards and store the amount of rewards they have earned before\\n  /// their multiplier is reset.\\n  /// @dev This is called whenever 1) A staker stakes 2) A staker unstakes\\n  /// 3) An operator is removed as we want to update the staker's\\n  /// rewards AND reset their multiplier.\\n  /// @dev Staker rewards are not forfeited when they stake before they have\\n  /// reached their maximum ramp up period multiplier.  Instead these\\n  /// rewards are stored as already earned rewards and will be subject to the\\n  /// multiplier the next time the contract calculates the staker's claimable\\n  /// rewards.\\n  /// @dev Staker rewards are forfeited when a staker unstakes before they\\n  /// have reached their maximum ramp up period multiplier.  Additionally an\\n  /// operator will also forfeit any unclaimable rewards if they are removed\\n  /// before they reach the maximum ramp up period multiplier.  The amount of\\n  /// rewards forfeited is proportional to the amount unstaked relative to\\n  /// the staker's total staked LINK amount when unstaking.  A removed operator forfeits\\n  /// 100% of their unclaimable rewards.\\n  /// @param staker The staker addres\\n  /// @param oldPrincipal The staker's staked LINK amount before finalizing\\n  /// @param stakedAt The last time the staker staked at\\n  /// @param unstakedAmount The amount that the staker has unstaked in juels\\n  /// @param shouldForfeit True if rewards should be forfeited\\n  function concludeRewardPeriod(\\n    address staker,\\n    uint256 oldPrincipal,\\n    uint256 stakedAt,\\n    uint256 unstakedAmount,\\n    bool shouldForfeit\\n  ) external;\\n\\n  /// @notice Closes the reward vault, disabling adding rewards and staking\\n  function close() external;\\n\\n  /// @notice Returns a boolean that is true if the reward vault is open\\n  /// @return True if open, false otherwise\\n  function isOpen() external view returns (bool);\\n\\n  /// @notice Returns the rewards that the staker would get if they withdraw now\\n  /// Rewards calculation is based on the staker's multiplier\\n  /// @param staker The staker's address\\n  /// @return The reward amount\\n  function getReward(address staker) external view returns (uint256);\\n\\n  /// @notice Returns the stored reward info of the staker\\n  /// @param staker The staker address\\n  /// @return The staker's stored reward info\\n  function getStoredReward(address staker) external view returns (StakerReward memory);\\n\\n  /// @notice Returns whether or not the vault is paused\\n  /// @return bool True if the vault is paused\\n  function isPaused() external view returns (bool);\\n\\n  /// @notice Returns whether or not the reward duration for the pool has ended\\n  /// @param stakingPool The address of the staking pool rewards are being shared to\\n  /// @return bool True if the reward duration has ended\\n  function hasRewardDurationEnded(address stakingPool) external view returns (bool);\\n\\n  /// @notice Returns whether or not the reward vault has had rewards added to it\\n  /// @return bool True if the reward vault has had rewards added to it\\n  function hasRewardAdded() external view returns (bool);\\n\\n  /// @notice Returns the staking pools that are earning rewards from\\n  /// the reward vault\\n  /// @return address[] The staking pools that are earning rewards from the\\n  /// reward vault\\n  function getStakingPools() external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"src/pools/StakingPoolBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {ERC677ReceiverInterface} from\\n  \\\"@chainlink/contracts/src/v0.8/interfaces/ERC677ReceiverInterface.sol\\\";\\nimport {LinkTokenInterface} from \\\"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\\\";\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\nimport {Checkpoints} from \\\"@openzeppelin/contracts/utils/Checkpoints.sol\\\";\\nimport {SafeCast} from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport {IMigratable} from \\\"../interfaces/IMigratable.sol\\\";\\nimport {IRewardVault} from \\\"../interfaces/IRewardVault.sol\\\";\\nimport {IStakingOwner} from \\\"../interfaces/IStakingOwner.sol\\\";\\nimport {IStakingPool} from \\\"../interfaces/IStakingPool.sol\\\";\\nimport {Migratable} from \\\"../Migratable.sol\\\";\\nimport {PausableWithAccessControl} from \\\"../PausableWithAccessControl.sol\\\";\\n\\n/// @notice This contract is the base contract for staking pools. Each staking pool extends this\\n/// contract.\\n/// @dev This contract is abstract and must be inherited.\\n/// @dev invariant maxPoolSize must be greater than or equal to the totalPrincipal.\\n/// @dev invariant maxPoolSize must be greater than or equal to the maxPrincipalPerStaker.\\n/// @dev invariant contract's LINK token balance should be greater than or equal to the\\n/// totalPrincipal.\\n/// @dev invariant The migrated staked LINK amount must be less than or equal to the staker's staked\\n/// LINK amount +\\n/// rewards from the v0.1 staking pool.\\n/// @dev invariant The migrated staked LINK amount must be less than or equal to the\\n/// maxPrincipalPerStaker.\\n/// @dev We only support LINK token in v0.2 staking. Rebasing tokens, ERC777 tokens, fee-on-transfer\\n/// tokens or tokens that do not have 18 decimal places are not supported.\\nabstract contract StakingPoolBase is\\n  ERC677ReceiverInterface,\\n  IStakingPool,\\n  IStakingOwner,\\n  Migratable,\\n  PausableWithAccessControl\\n{\\n  using Checkpoints for Checkpoints.History;\\n  using SafeCast for uint256;\\n\\n  /// @notice This error is thrown when the staking pool is not active.\\n  error PoolNotActive();\\n\\n  /// @notice This error is thrown when the unbonding period is set to 0\\n  error InvalidUnbondingPeriod();\\n\\n  /// @notice This error is thrown when the claim period is set to 0\\n  error InvalidClaimPeriod();\\n\\n  /// @notice This error is thrown whenever a staker tries to unbond during\\n  /// their unbonding period.\\n  /// @param unbondingPeriodEndsAt The time the unbonding period is finished\\n  error UnbondingOrClaimPeriodActive(uint256 unbondingPeriodEndsAt);\\n\\n  /// @notice This error is thrown whenever a staker tries to unstake outside\\n  /// the claim period\\n  /// @param staker The staker trying to unstake\\n  error StakerNotInClaimPeriod(address staker);\\n\\n  /// @notice This error is thrown when an invalid claim period range is provided\\n  /// @param minClaimPeriod The min claim period\\n  /// @param maxClaimPeriod The max claim period\\n  error InvalidClaimPeriodRange(uint256 minClaimPeriod, uint256 maxClaimPeriod);\\n\\n  /// @notice This error is thrown when an invalid max unbonding period is provided\\n  /// @param maxUnbondingPeriod The max unbonding period\\n  error InvalidMaxUnbondingPeriod(uint256 maxUnbondingPeriod);\\n\\n  /// @notice This error is thrown when a staker tries to stake and the reward vault connected to\\n  /// this pool is not open or is paused\\n  error RewardVaultNotActive();\\n\\n  /// @notice This error is thrown when admin tries to open the pool and the reward vault connected\\n  /// to this pool has not had rewards added to it.\\n  error RewardVaultHasNoRewards();\\n\\n  /// @notice This error is thrown when admin tries to set a new reward vault and the old reward\\n  /// vault is not closed yet.\\n  error RewardVaultNotClosed();\\n\\n  /// @notice This event is emitted whenever a staker initiates the unbonding\\n  /// period.\\n  /// @param staker The staker that has started their unbonding period.\\n  event UnbondingPeriodStarted(address indexed staker);\\n\\n  /// @notice This event is emitted when a staker's unbonding period is reset\\n  /// @param staker The staker that has reset their unbonding period\\n  event UnbondingPeriodReset(address indexed staker);\\n\\n  /// @notice This event is emitted when the unbonding period has been changed\\n  /// @param oldUnbondingPeriod The old unbonding period\\n  /// @param newUnbondingPeriod The new unbonding period\\n  event UnbondingPeriodSet(uint256 oldUnbondingPeriod, uint256 newUnbondingPeriod);\\n\\n  /// @notice This event is emitted when the claim period is set\\n  /// @param oldClaimPeriod The old claim period\\n  /// @param newClaimPeriod The new claim period\\n  event ClaimPeriodSet(uint256 oldClaimPeriod, uint256 newClaimPeriod);\\n\\n  /// @notice This event is emitted when the reward vault is set\\n  /// @param oldRewardVault The old reward vault\\n  /// @param newRewardVault The new reward vault\\n  event RewardVaultSet(address indexed oldRewardVault, address indexed newRewardVault);\\n\\n  /// @notice This event is emitted when the staker is migrated to the migration target\\n  /// @param migrationTarget The migration target\\n  /// @param amount The staker's staked LINK amount that was migrated in juels\\n  /// @param migrationData The migration data\\n  event StakerMigrated(address indexed migrationTarget, uint256 amount, bytes migrationData);\\n\\n  /// @notice This struct defines the params required by the Staking contract's\\n  /// constructor.\\n  struct ConstructorParamsBase {\\n    /// @notice The LINK Token\\n    LinkTokenInterface LINKAddress;\\n    /// @notice The initial maximum total stake amount for all stakers in the\\n    /// pool\\n    uint96 initialMaxPoolSize;\\n    /// @notice The initial maximum stake amount for a staker\\n    uint96 initialMaxPrincipalPerStaker;\\n    /// @notice The minimum stake amount that a staker must stake\\n    uint96 minPrincipalPerStaker;\\n    /// @notice The initial unbonding period\\n    uint32 initialUnbondingPeriod;\\n    /// @notice The max value that the unbonding period can be set to\\n    uint32 maxUnbondingPeriod;\\n    /// @notice The initial claim period\\n    uint32 initialClaimPeriod;\\n    /// @notice The min value that the claim period can be set to\\n    uint32 minClaimPeriod;\\n    /// @notice The max value that the claim period can be set to\\n    uint32 maxClaimPeriod;\\n    /// @notice The time it requires to transfer admin role\\n    uint48 adminRoleTransferDelay;\\n  }\\n\\n  /// @notice This struct defines the params that the pool is configured with\\n  struct PoolConfigs {\\n    /// @notice The max amount of staked LINK allowed in the pool in juels. The max value of this\\n    /// field is expected to be less than 1 billion (10^9 * 10^18), which is less than the max value\\n    /// that can be represented by a uint96 (~7.9*10^28).\\n    uint96 maxPoolSize;\\n    /// @notice The max amount of LINK a staker can stake in juels. The max value of this field is\\n    /// expected to be less than 1 million (10^6 * 10^18), which is less than the max value that can\\n    /// be represented by a uint96 (~7.9*10^28).\\n    uint96 maxPrincipalPerStaker;\\n    /// @notice The length of the unbonding period in seconds. The max value of this field is\\n    /// expected to be less than a year, or 30 million (3.2*10^7), which is less than the max value\\n    /// that can be represented by a uint32 (~4.2*10^9).\\n    uint32 unbondingPeriod;\\n    /// @notice The length of the claim period in seconds. The max value of this field is\\n    /// expected to be less than a year, or 30 million (3.2*10^7), which is less than the max value\\n    /// that can be represented by a uint32 (~4.2*10^9).\\n    uint32 claimPeriod;\\n  }\\n\\n  /// @notice This struct defines the state of the staking pool\\n  struct PoolState {\\n    /// @notice The total staked LINK amount amount in the pool\\n    uint256 totalPrincipal;\\n    /// @notice The time that the pool was closed\\n    uint256 closedAt;\\n  }\\n\\n  /// @notice This struct defines the global state and configuration of the pool\\n  struct Pool {\\n    /// @notice The pool's configuration\\n    PoolConfigs configs;\\n    /// @notice The pool's state\\n    PoolState state;\\n  }\\n\\n  /// @notice This is the ID for the initiator role, which is given to the\\n  /// addresses that will add open the pools, and set the merkle root for the community pool.\\n  /// @dev Hash: 6b8b15f1c11543d8280deaa7c24d12fffba6a357e4428e8c43e4234790186bff\\n  bytes32 public constant INITIATOR_ROLE = keccak256(\\\"INITIATOR_ROLE\\\");\\n  /// @notice The LINK token\\n  LinkTokenInterface internal immutable i_LINK;\\n  /// @notice The staking pool state and configuration\\n  Pool internal s_pool;\\n  /// @notice Mapping of a staker's address to their staker state\\n  mapping(address staker => IStakingPool.Staker) internal s_stakers;\\n  /// @notice Migration proxy address\\n  address internal s_migrationProxy;\\n  /// @notice The latest reward vault address\\n  IRewardVault internal s_rewardVault;\\n  /// @notice The min amount of LINK that a staker can stake\\n  uint96 internal immutable i_minPrincipalPerStaker;\\n  /// @notice The min value that the claim period can be set to\\n  uint32 private immutable i_minClaimPeriod;\\n  /// @notice The max value that the claim period can be set to\\n  uint32 private immutable i_maxClaimPeriod;\\n  /// @notice The max value that the unbonding period can be set to\\n  uint32 private immutable i_maxUnbondingPeriod;\\n  /// @notice Flag that signals if the staking pool is open for staking\\n  bool internal s_isOpen;\\n\\n  constructor(ConstructorParamsBase memory params)\\n    PausableWithAccessControl(params.adminRoleTransferDelay, msg.sender)\\n  {\\n    if (address(params.LINKAddress) == address(0)) revert InvalidZeroAddress();\\n    if (params.minPrincipalPerStaker == 0) revert InvalidMinStakeAmount();\\n    if (params.minPrincipalPerStaker >= params.initialMaxPrincipalPerStaker) {\\n      revert InvalidMinStakeAmount();\\n    }\\n    if (params.maxUnbondingPeriod == 0) {\\n      revert InvalidMaxUnbondingPeriod(params.maxUnbondingPeriod);\\n    }\\n    if (params.minClaimPeriod == 0 || params.minClaimPeriod >= params.maxClaimPeriod) {\\n      revert InvalidClaimPeriodRange(params.minClaimPeriod, params.maxClaimPeriod);\\n    }\\n\\n    i_LINK = params.LINKAddress;\\n    i_minPrincipalPerStaker = params.minPrincipalPerStaker;\\n\\n    i_maxUnbondingPeriod = params.maxUnbondingPeriod;\\n    _setUnbondingPeriod(params.initialUnbondingPeriod);\\n\\n    _setPoolConfig(params.initialMaxPoolSize, params.initialMaxPrincipalPerStaker);\\n\\n    i_minClaimPeriod = params.minClaimPeriod;\\n    i_maxClaimPeriod = params.maxClaimPeriod;\\n    _setClaimPeriod(params.initialClaimPeriod);\\n  }\\n\\n  /// @inheritdoc IMigratable\\n  /// @dev This will migrate the staker's staked LINK\\n  /// @dev precondition This contract must be closed and upgraded to a new pool.\\n  /// @dev precondition The migration target must be set.\\n  /// @dev precondition The caller must be staked in the pool.\\n  function migrate(bytes calldata data) external whenClosed validateMigrationTargetSet {\\n    // must be in storage to get access to latest()\\n    IStakingPool.Staker storage staker = s_stakers[msg.sender];\\n\\n    uint224 history = staker.history.latest();\\n    uint112 stakerPrincipal = uint112(history >> 112);\\n    uint112 stakerStakedAtTime = uint112(history);\\n    if (stakerPrincipal == 0) revert StakeNotFound(msg.sender);\\n\\n    bytes memory migrationData = abi.encode(msg.sender, stakerStakedAtTime, data);\\n\\n    // Finalize staker's rewards to include any rewards they have earned before resetting the\\n    // principal and stakedAtTime.\\n    s_rewardVault.concludeRewardPeriod({\\n      staker: msg.sender,\\n      oldPrincipal: stakerPrincipal,\\n      stakedAt: stakerStakedAtTime,\\n      unstakedAmount: stakerPrincipal,\\n      shouldForfeit: false\\n    });\\n    s_pool.state.totalPrincipal -= stakerPrincipal;\\n\\n    // do not reset staked at time to not reset the multiplier because staker is not forfeiting\\n    // rewards when migrating\\n    _updateStakerHistory({\\n      staker: staker,\\n      latestPrincipal: 0,\\n      latestStakedAtTime: stakerStakedAtTime\\n    });\\n    // The return value is not checked since the call will revert if any balance, allowance or\\n    // receiver conditions fail.\\n    i_LINK.transferAndCall({to: s_migrationTarget, value: stakerPrincipal, data: migrationData});\\n    emit StakerMigrated(s_migrationTarget, stakerPrincipal, migrationData);\\n  }\\n\\n  /// @notice Starts the unbonding period for the staker.  A staker may unstake\\n  /// their staked LINK during the claim period that follows the unbonding period.\\n  /// @dev precondition The caller must be staked in the pool.\\n  /// @dev precondition The caller must not be in an unbonding period.\\n  /// @dev precondition The caller must not be in a claim period.\\n  function unbond() external virtual {\\n    Staker storage staker = s_stakers[msg.sender];\\n    uint224 history = staker.history.latest();\\n    uint112 stakerPrincipal = uint112(history >> 112);\\n    if (stakerPrincipal == 0) revert StakeNotFound(msg.sender);\\n\\n    _unbond(staker);\\n  }\\n\\n  /// @notice Sets the new unbonding period for the pool.  Stakers that are\\n  /// already unbonding will not be affected.\\n  /// @param newUnbondingPeriod The new unbonding period\\n  /// @dev precondition The caller must have the default admin role.\\n  /// @dev precondition Cannot be called after the pool is closed.\\n  function setUnbondingPeriod(uint256 newUnbondingPeriod)\\n    external\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n    whenBeforeClosing\\n  {\\n    _setUnbondingPeriod(newUnbondingPeriod);\\n  }\\n\\n  /// @notice Returns the max unbonding period\\n  /// @return uint256 The max value that the unbonding period can be set to\\n  function getMaxUnbondingPeriod() external view returns (uint256) {\\n    return (i_maxUnbondingPeriod);\\n  }\\n\\n  /// @notice Set the claim period\\n  /// @param claimPeriod The claim period\\n  /// @dev precondition Cannot be called after the pool is closed.\\n  function setClaimPeriod(uint256 claimPeriod)\\n    external\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n    whenBeforeClosing\\n  {\\n    _setClaimPeriod(claimPeriod);\\n  }\\n\\n  /// @notice Sets the new reward vault for the pool\\n  /// @param newRewardVault The new reward vault\\n  /// @dev precondition The caller must have the default admin role.\\n  /// @dev precondition Cannot be called after the pool is closed.\\n  function setRewardVault(IRewardVault newRewardVault)\\n    external\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n    whenBeforeClosing\\n  {\\n    if (address(newRewardVault) == address(0)) revert InvalidZeroAddress();\\n    address oldRewardVault = address(s_rewardVault);\\n    if (oldRewardVault == address(newRewardVault)) return;\\n    if (address(s_rewardVault) != address(0) && s_rewardVault.isOpen()) {\\n      revert RewardVaultNotClosed();\\n    }\\n    if (\\n      address(s_rewardVault) != address(0)\\n        && (!newRewardVault.isOpen() || newRewardVault.isPaused())\\n    ) revert RewardVaultNotActive();\\n    if (address(s_rewardVault) != address(0) && !newRewardVault.hasRewardAdded()) {\\n      revert RewardVaultHasNoRewards();\\n    }\\n\\n    s_rewardVault = newRewardVault;\\n    emit RewardVaultSet(oldRewardVault, address(newRewardVault));\\n  }\\n\\n  /// @notice LINK transfer callback function called when transferAndCall is called with this\\n  /// contract as a target.\\n  /// @param sender staker's address if they stake into the pool by calling transferAndCall on the\\n  /// LINK token, or MigrationProxy contract when a staker migrates from V0.1 to V0.2\\n  /// @param amount Amount of LINK token transferred\\n  /// @param data Bytes data received, represents migration path\\n  /// @inheritdoc ERC677ReceiverInterface\\n  /// @dev precondition The migration proxy must be set.\\n  /// @dev precondition This contract must be open and not paused.\\n  /// @dev precondition The reward vault must be open and not paused.\\n  function onTokenTransfer(\\n    address sender,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external validateFromLINK validateMigrationProxySet whenOpen whenRewardVaultOpen whenNotPaused {\\n    if (amount == 0) return;\\n\\n    // Check if this call was forwarded from the migration proxy.\\n    address staker = sender == s_migrationProxy ? _getStakerAddress(data) : sender;\\n    if (staker == address(0)) revert InvalidZeroAddress();\\n\\n    // includes access check for non migration proxy\\n    _validateOnTokenTransfer(sender, staker, data);\\n\\n    Staker storage stakerState = s_stakers[staker];\\n    uint224 history = stakerState.history.latest();\\n    uint256 stakerPrincipal = uint256(history >> 112);\\n    uint256 stakedAt = uint112(history);\\n\\n    _resetUnbondingPeriod(stakerState, staker);\\n\\n    s_rewardVault.concludeRewardPeriod({\\n      staker: staker,\\n      oldPrincipal: stakerPrincipal,\\n      unstakedAmount: 0,\\n      shouldForfeit: false,\\n      stakedAt: stakedAt\\n    });\\n\\n    _increaseStake(staker, stakerPrincipal + amount, amount);\\n  }\\n\\n  /// @notice Returns the minimum and maximum claim periods that can be set by the owner\\n  /// @return uint256 minimum claim period\\n  /// @return uint256 maximum claim period\\n  function getClaimPeriodLimits() external view returns (uint256, uint256) {\\n    return (i_minClaimPeriod, i_maxClaimPeriod);\\n  }\\n\\n  // =================\\n  // IStakingOwner\\n  // =================\\n\\n  /// @inheritdoc IStakingOwner\\n  /// @dev precondition The caller must have the default admin role.\\n  function setPoolConfig(\\n    uint256 maxPoolSize,\\n    uint256 maxPrincipalPerStaker\\n  ) external virtual onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\\n    _setPoolConfig(maxPoolSize, maxPrincipalPerStaker);\\n  }\\n\\n  /// @inheritdoc IStakingOwner\\n  /// @dev precondition The caller must have the initiator role.\\n  function open()\\n    external\\n    onlyRole(INITIATOR_ROLE)\\n    whenBeforeOpening\\n    validateRewardVaultSet\\n    whenRewardVaultOpen\\n    whenRewardVaultHasRewards\\n  {\\n    _validateBeforeOpen();\\n    s_isOpen = true;\\n    emit PoolOpened();\\n  }\\n\\n  /// @inheritdoc IStakingOwner\\n  /// @dev precondition The caller must have the default admin role.\\n  function close() external onlyRole(DEFAULT_ADMIN_ROLE) whenOpen {\\n    s_isOpen = false;\\n    s_pool.state.closedAt = block.timestamp;\\n    emit PoolClosed();\\n  }\\n\\n  /// @inheritdoc IStakingOwner\\n  /// @dev precondition The caller must have the default admin role.\\n  function setMigrationProxy(address migrationProxy)\\n    external\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n    whenBeforeClosing\\n  {\\n    if (migrationProxy == address(0)) revert InvalidZeroAddress();\\n\\n    if (s_migrationProxy == migrationProxy) return;\\n    address oldMigrationProxy = s_migrationProxy;\\n    s_migrationProxy = migrationProxy;\\n\\n    emit MigrationProxySet(oldMigrationProxy, migrationProxy);\\n  }\\n\\n  // =================\\n  // IStakingPool\\n  // =================\\n\\n  /// @inheritdoc IStakingPool\\n  /// @dev precondition The caller must be staked in the pool.\\n  /// @dev precondition The caller must be in the claim period or the pool must be closed or paused.\\n  /// @dev There is a possible reentrancy attack here where a malicious admin\\n  /// can point this pool to a malicious reward vault that calls unstake on the\\n  /// pool again.  This reentrancy attack is possible as the pool updates the\\n  /// staker's staked LINK amount after it calls concludeRewardPeriod on the configured reward\\n  /// vault.  This scenario is mitigated by forcing the admin to go through\\n  /// a timelock period that is longer than the unbonding period, which will\\n  /// provide stakers sufficient time to withdraw their staked LINK from the\\n  /// pool before a malicious reward vault is set.\\n  function unstake(uint256 amount) external {\\n    // cannot unstake 0\\n    if (amount == 0) revert UnstakeZeroAmount();\\n\\n    Staker storage staker = s_stakers[msg.sender];\\n    if (!_canUnstake(staker)) {\\n      revert StakerNotInClaimPeriod(msg.sender);\\n    }\\n\\n    uint224 history = staker.history.latest();\\n    uint256 stakerPrincipal = uint256(history >> 112);\\n    uint256 stakedAt = uint112(history);\\n    // verify that the staker has enough staked LINK amount to unstake\\n    if (amount > stakerPrincipal) revert UnstakeExceedsPrincipal();\\n\\n    uint256 updatedPrincipal = stakerPrincipal - amount;\\n    // in the case of a partial withdrawal, verify new staked LINK amount is above minimum\\n    if (amount < stakerPrincipal && updatedPrincipal < i_minPrincipalPerStaker) {\\n      revert UnstakePrincipalBelowMinAmount();\\n    }\\n\\n    s_rewardVault.concludeRewardPeriod({\\n      staker: msg.sender,\\n      oldPrincipal: stakerPrincipal,\\n      unstakedAmount: amount,\\n      shouldForfeit: true,\\n      stakedAt: stakedAt\\n    });\\n\\n    s_pool.state.totalPrincipal -= amount;\\n\\n    // Reset the staker's staked at time to 0 to prevent the multiplier\\n    // from growing if the staker has unstaked all their staked LINK\\n    _updateStakerHistory({\\n      staker: staker,\\n      latestPrincipal: updatedPrincipal,\\n      latestStakedAtTime: updatedPrincipal == 0 ? 0 : block.timestamp\\n    });\\n    // The return value is not checked since the call will revert if any balance, allowance or\\n    // receiver conditions fail.\\n    i_LINK.transfer(msg.sender, amount);\\n\\n    emit Unstaked(msg.sender, amount, updatedPrincipal, s_pool.state.totalPrincipal);\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function getTotalPrincipal() external view returns (uint256) {\\n    return s_pool.state.totalPrincipal;\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function getStakerPrincipal(address staker) external view returns (uint256) {\\n    return uint112(s_stakers[staker].history.latest() >> 112);\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function getStakerPrincipalAt(\\n    address staker,\\n    uint256 blockNumber\\n  ) external view returns (uint256) {\\n    // `Checkpoints` requires to exclude the current block when calling `getAtBlock`\\n    return (blockNumber == block.number)\\n      ? uint112(s_stakers[staker].history.latest() >> 112)\\n      : uint112(s_stakers[staker].history.getAtBlock(blockNumber) >> 112);\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function getStakerStakedAtTime(address staker) external view returns (uint256) {\\n    return uint112(s_stakers[staker].history.latest());\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function getStakerStakedAtTimeAt(\\n    address staker,\\n    uint256 blockNumber\\n  ) external view returns (uint256) {\\n    // `Checkpoints` requires to exclude the current block when calling `getAtBlock`\\n    return (blockNumber == block.number)\\n      ? uint112(s_stakers[staker].history.latest())\\n      : uint112(s_stakers[staker].history.getAtBlock(blockNumber));\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function getRewardVault() external view returns (IRewardVault) {\\n    return s_rewardVault;\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function getChainlinkToken() external view returns (address) {\\n    return address(i_LINK);\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function getMigrationProxy() external view returns (address) {\\n    return s_migrationProxy;\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function isOpen() external view returns (bool) {\\n    return s_isOpen;\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function isActive() external view returns (bool) {\\n    return _isActive();\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function getStakerLimits() external view returns (uint256, uint256) {\\n    return (i_minPrincipalPerStaker, s_pool.configs.maxPrincipalPerStaker);\\n  }\\n\\n  /// @inheritdoc IStakingPool\\n  function getMaxPoolSize() external view returns (uint256) {\\n    return s_pool.configs.maxPoolSize;\\n  }\\n\\n  /// @notice Returns the time a staker's unbonding period ends\\n  /// @param staker The address of the staker to query\\n  /// @return uint256 The timestamp of when the staker's unbonding period ends.\\n  /// This value will be 0 if the unbonding period is not active.\\n  function getUnbondingEndsAt(address staker) external view returns (uint256) {\\n    return s_stakers[staker].unbondingPeriodEndsAt;\\n  }\\n\\n  /// @notice Returns the pool's unbonding parameters\\n  /// @return uint256 The pool's unbonding period\\n  /// @return uint256 The pools's claim period\\n  function getUnbondingParams() external view returns (uint256, uint256) {\\n    return (s_pool.configs.unbondingPeriod, s_pool.configs.claimPeriod);\\n  }\\n\\n  /// @notice Returns the time a staker's claim period ends\\n  /// @param staker The staker trying to unstake their staked LINK\\n  /// @return uint256 The timestamp of when the staker's claim period ends.\\n  /// This value will be 0 if the unbonding period has not started.\\n  function getClaimPeriodEndsAt(address staker) external view returns (uint256) {\\n    return s_stakers[staker].claimPeriodEndsAt;\\n  }\\n\\n  // ===============\\n  // ERC165\\n  // ===============\\n\\n  /// @notice This function allows the calling contract to\\n  /// check if the contract deployed at this address is a valid\\n  /// LINKTokenReceiver.  A contract is a valid LINKTokenReceiver\\n  /// if it implements the onTokenTransfer function.\\n  /// @param interfaceID The ID of the interface to check against\\n  /// @return bool True if the contract is a valid LINKTokenReceiver.\\n  function supportsInterface(bytes4 interfaceID) public view override returns (bool) {\\n    return interfaceID == this.onTokenTransfer.selector || super.supportsInterface(interfaceID);\\n  }\\n\\n  // =========\\n  // Helpers\\n  // =========\\n\\n  /// @notice Resets a staker's unbonding period\\n  /// @param stakerState The staker's current state\\n  /// @param staker The address of the staker to reset the unbonding period for\\n  /// @dev This sets the stakerState's unbondingPeriodEndsAt and\\n  /// claimPeriodEndsAt to 0\\n  function _resetUnbondingPeriod(Staker storage stakerState, address staker) internal {\\n    if (stakerState.unbondingPeriodEndsAt != 0) {\\n      delete stakerState.unbondingPeriodEndsAt;\\n      delete stakerState.claimPeriodEndsAt;\\n      emit UnbondingPeriodReset(staker);\\n    }\\n  }\\n\\n  /// @inheritdoc Migratable\\n  /// @dev precondition The migration target must implement the onTokenTransfer function.\\n  /// @dev precondition Cannot be called after the pool is closed.\\n  function _validateMigrationTarget(address newMigrationTarget) internal override whenBeforeClosing {\\n    Migratable._validateMigrationTarget(newMigrationTarget);\\n    if (\\n      !IERC165(newMigrationTarget).supportsInterface(\\n        ERC677ReceiverInterface.onTokenTransfer.selector\\n      )\\n    ) {\\n      revert InvalidMigrationTarget();\\n    }\\n  }\\n\\n  /// @notice Validate for when LINK is staked or migrated into the pool\\n  /// @param sender The address transferring LINK into the pool. Could be the migration proxy\\n  /// contract or the staker.\\n  /// @param staker The address staking or migrating LINK into the pool\\n  /// @param data Arbitrary data passed when staking or migrating\\n  function _validateOnTokenTransfer(\\n    address sender,\\n    address staker,\\n    bytes calldata data\\n  ) internal view virtual;\\n\\n  /// @notice Validates pool state before opening\\n  function _validateBeforeOpen() internal view virtual;\\n\\n  /// @notice Util function for setting the pool config\\n  /// @param maxPoolSize The max amount of staked LINK allowed in the pool\\n  /// @param maxPrincipalPerStaker The max amount of LINK a staker can stake\\n  /// in the pool.\\n  function _setPoolConfig(uint256 maxPoolSize, uint256 maxPrincipalPerStaker) internal {\\n    PoolConfigs storage configs = s_pool.configs;\\n    // only allow increasing the maxPoolSize\\n    if (maxPoolSize == 0 || maxPoolSize < configs.maxPoolSize) {\\n      revert InvalidPoolSize(maxPoolSize);\\n    }\\n    // only allow increasing the maxPrincipalPerStaker\\n    if (\\n      maxPrincipalPerStaker == 0 || maxPrincipalPerStaker > maxPoolSize\\n        || configs.maxPrincipalPerStaker > maxPrincipalPerStaker\\n    ) revert InvalidMaxStakeAmount(maxPrincipalPerStaker);\\n\\n    if (configs.maxPoolSize != maxPoolSize) {\\n      configs.maxPoolSize = maxPoolSize.toUint96();\\n      emit PoolSizeIncreased(maxPoolSize);\\n    }\\n    if (configs.maxPrincipalPerStaker != maxPrincipalPerStaker) {\\n      configs.maxPrincipalPerStaker = maxPrincipalPerStaker.toUint96();\\n      emit MaxPrincipalAmountIncreased(maxPrincipalPerStaker);\\n    }\\n  }\\n\\n  /// @notice Util function for setting the unbonding period\\n  /// @param unbondingPeriod The unbonding period\\n  function _setUnbondingPeriod(uint256 unbondingPeriod) internal {\\n    if (unbondingPeriod == 0 || unbondingPeriod > i_maxUnbondingPeriod) {\\n      revert InvalidUnbondingPeriod();\\n    }\\n\\n    if (s_pool.configs.unbondingPeriod == unbondingPeriod) return;\\n\\n    uint256 oldUnbondingPeriod = s_pool.configs.unbondingPeriod;\\n    s_pool.configs.unbondingPeriod = unbondingPeriod.toUint32();\\n    emit UnbondingPeriodSet(oldUnbondingPeriod, unbondingPeriod);\\n  }\\n\\n  /// @notice Updates the staking pool state and the staker state\\n  /// @param sender The staker address\\n  /// @param newPrincipal The staker's staked LINK amount after staking\\n  /// @param amount The amount to stake\\n  function _increaseStake(address sender, uint256 newPrincipal, uint256 amount) internal {\\n    Staker storage staker = s_stakers[sender];\\n\\n    // validate staking limits\\n    if (newPrincipal < i_minPrincipalPerStaker) {\\n      revert InsufficientStakeAmount();\\n    }\\n    if (newPrincipal > s_pool.configs.maxPrincipalPerStaker) {\\n      revert ExceedsMaxStakeAmount();\\n    }\\n    uint256 newTotalPrincipal = s_pool.state.totalPrincipal + amount;\\n    if (newTotalPrincipal > s_pool.configs.maxPoolSize) {\\n      revert ExceedsMaxPoolSize();\\n    }\\n\\n    // update the pool state\\n    s_pool.state.totalPrincipal = newTotalPrincipal;\\n\\n    // update the staker state\\n    _updateStakerHistory({\\n      staker: staker,\\n      latestPrincipal: newPrincipal,\\n      latestStakedAtTime: block.timestamp\\n    });\\n\\n    emit Staked(sender, amount, newPrincipal, newTotalPrincipal);\\n  }\\n\\n  /// @notice Gets the staker address from the data passed by the MigrationProxy contract\\n  /// @param data The data passed by the MigrationProxy contract\\n  /// @return The staker address\\n  function _getStakerAddress(bytes calldata data) internal pure returns (address) {\\n    if (data.length == 0) revert InvalidData();\\n\\n    // decode the data\\n    (address staker) = abi.decode(data, (address));\\n\\n    return staker;\\n  }\\n\\n  /// @notice Checks to see whether or not a staker is eligible to\\n  /// unstake their staked LINK amount (when the pool is closed or, when the pool is open and they\\n  /// are in the claim period or, when pool is paused)\\n  /// @param staker The staker trying to unstake their staked LINK\\n  /// @return bool True if the staker is eligible to unstake\\n  function _canUnstake(Staker storage staker) internal view returns (bool) {\\n    return s_pool.state.closedAt != 0 || _inClaimPeriod(staker) || paused();\\n  }\\n\\n  /// @notice Updates the staker's staked LINK amount history\\n  /// @param staker The staker to update\\n  /// @param latestPrincipal The staker's latest staked LINK amount\\n  /// @param latestStakedAtTime The staker's latest average staked at time\\n  function _updateStakerHistory(\\n    Staker storage staker,\\n    uint256 latestPrincipal,\\n    uint256 latestStakedAtTime\\n  ) internal {\\n    staker.history.push(\\n      (uint224(uint112(latestPrincipal)) << 112) | uint224(uint112(latestStakedAtTime))\\n    );\\n  }\\n\\n  /// @notice Starts the unbonding period for the staker\\n  /// @param staker The staker trying to unbond\\n  function _unbond(Staker storage staker) internal {\\n    if (staker.unbondingPeriodEndsAt != 0 && block.timestamp <= staker.claimPeriodEndsAt) {\\n      revert UnbondingOrClaimPeriodActive(staker.unbondingPeriodEndsAt);\\n    }\\n    staker.unbondingPeriodEndsAt = (block.timestamp + s_pool.configs.unbondingPeriod).toUint128();\\n    staker.claimPeriodEndsAt = staker.unbondingPeriodEndsAt + s_pool.configs.claimPeriod;\\n    emit UnbondingPeriodStarted(msg.sender);\\n  }\\n\\n  /// @notice Checks to see whether or not a staker is within the claim period\\n  /// to unstake their staked LINK\\n  /// @param staker The staker trying to unstake their staked LINK\\n  /// @return bool True if the staker is inside the claim period\\n  function _inClaimPeriod(Staker storage staker) private view returns (bool) {\\n    if (staker.unbondingPeriodEndsAt == 0 || block.timestamp < staker.unbondingPeriodEndsAt) {\\n      return false;\\n    }\\n\\n    return block.timestamp <= staker.claimPeriodEndsAt;\\n  }\\n\\n  /// @notice Util function for setting the claim period\\n  /// @param claimPeriod The claim period\\n  function _setClaimPeriod(uint256 claimPeriod) private {\\n    if (claimPeriod < i_minClaimPeriod || claimPeriod > i_maxClaimPeriod) {\\n      revert InvalidClaimPeriod();\\n    }\\n\\n    if (s_pool.configs.claimPeriod == claimPeriod) return;\\n\\n    uint256 oldClaimPeriod = s_pool.configs.claimPeriod;\\n    s_pool.configs.claimPeriod = claimPeriod.toUint32();\\n\\n    emit ClaimPeriodSet(oldClaimPeriod, claimPeriod);\\n  }\\n\\n  /// @notice Util function to check if the reward vault connected to this pool has rewards added to\\n  /// it\\n  /// @return bool True if the reward vault has rewards added to it, false otherwise\\n  function _hasRewardVaultRewardAdded() internal view virtual returns (bool) {\\n    return s_rewardVault.hasRewardAdded();\\n  }\\n\\n  /// @notice Util function to check if the pool is active\\n  /// @return bool True if the pool is active, false otherwise\\n  function _isActive() internal view returns (bool) {\\n    return s_isOpen && !s_rewardVault.hasRewardDurationEnded(address(this));\\n  }\\n\\n  // =========\\n  // Modifiers\\n  // =========\\n\\n  /// @dev Reverts if not sent from the LINK token\\n  modifier validateFromLINK() {\\n    if (msg.sender != address(i_LINK)) revert SenderNotLinkToken();\\n    _;\\n  }\\n\\n  /// @dev Reverts if migration proxy is not set\\n  modifier validateMigrationProxySet() {\\n    if (s_migrationProxy == address(0)) revert MigrationProxyNotSet();\\n    _;\\n  }\\n\\n  /// @dev Reverts if reward vault is not set\\n  modifier validateRewardVaultSet() {\\n    if (address(s_rewardVault) == address(0)) revert RewardVaultNotSet();\\n    _;\\n  }\\n\\n  /// @dev Reverts if pool is after an opening\\n  modifier whenBeforeOpening() {\\n    if (s_isOpen) revert PoolHasBeenOpened();\\n    if (s_pool.state.closedAt != 0) revert PoolHasBeenClosed();\\n    _;\\n  }\\n\\n  /// @dev Reverts if the pool is already closed\\n  modifier whenBeforeClosing() {\\n    if (s_pool.state.closedAt != 0) revert PoolHasBeenClosed();\\n    _;\\n  }\\n\\n  /// @dev Reverts if pool is not open\\n  modifier whenOpen() {\\n    if (!s_isOpen) revert PoolNotOpen();\\n    _;\\n  }\\n\\n  /// @dev Reverts if pool is not active (is open and rewards are available for this pool)\\n  modifier whenActive() {\\n    if (!_isActive()) revert PoolNotActive();\\n    _;\\n  }\\n\\n  /// @dev Reverts if pool is not closed\\n  modifier whenClosed() {\\n    if (s_pool.state.closedAt == 0) revert PoolNotClosed();\\n    _;\\n  }\\n\\n  /// @dev Reverts if reward vault is not open or is paused\\n  modifier whenRewardVaultOpen() {\\n    if (!s_rewardVault.isOpen() || s_rewardVault.isPaused()) revert RewardVaultNotActive();\\n    _;\\n  }\\n\\n  /// @dev Reverts if reward vault has not had rewards added to it\\n  modifier whenRewardVaultHasRewards() {\\n    if (!_hasRewardVaultRewardAdded()) revert RewardVaultHasNoRewards();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(account),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/IAccessControlDefaultAdminRules.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/IAccessControlDefaultAdminRules.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControlDefaultAdminRules declared to support ERC165 detection.\\n *\\n * _Available since v4.9._\\n */\\ninterface IAccessControlDefaultAdminRules is IAccessControl {\\n    /**\\n     * @dev Emitted when a {defaultAdmin} transfer is started, setting `newAdmin` as the next\\n     * address to become the {defaultAdmin} by calling {acceptDefaultAdminTransfer} only after `acceptSchedule`\\n     * passes.\\n     */\\n    event DefaultAdminTransferScheduled(address indexed newAdmin, uint48 acceptSchedule);\\n\\n    /**\\n     * @dev Emitted when a {pendingDefaultAdmin} is reset if it was never accepted, regardless of its schedule.\\n     */\\n    event DefaultAdminTransferCanceled();\\n\\n    /**\\n     * @dev Emitted when a {defaultAdminDelay} change is started, setting `newDelay` as the next\\n     * delay to be applied between default admin transfer after `effectSchedule` has passed.\\n     */\\n    event DefaultAdminDelayChangeScheduled(uint48 newDelay, uint48 effectSchedule);\\n\\n    /**\\n     * @dev Emitted when a {pendingDefaultAdminDelay} is reset if its schedule didn't pass.\\n     */\\n    event DefaultAdminDelayChangeCanceled();\\n\\n    /**\\n     * @dev Returns the address of the current `DEFAULT_ADMIN_ROLE` holder.\\n     */\\n    function defaultAdmin() external view returns (address);\\n\\n    /**\\n     * @dev Returns a tuple of a `newAdmin` and an accept schedule.\\n     *\\n     * After the `schedule` passes, the `newAdmin` will be able to accept the {defaultAdmin} role\\n     * by calling {acceptDefaultAdminTransfer}, completing the role transfer.\\n     *\\n     * A zero value only in `acceptSchedule` indicates no pending admin transfer.\\n     *\\n     * NOTE: A zero address `newAdmin` means that {defaultAdmin} is being renounced.\\n     */\\n    function pendingDefaultAdmin() external view returns (address newAdmin, uint48 acceptSchedule);\\n\\n    /**\\n     * @dev Returns the delay required to schedule the acceptance of a {defaultAdmin} transfer started.\\n     *\\n     * This delay will be added to the current timestamp when calling {beginDefaultAdminTransfer} to set\\n     * the acceptance schedule.\\n     *\\n     * NOTE: If a delay change has been scheduled, it will take effect as soon as the schedule passes, making this\\n     * function returns the new delay. See {changeDefaultAdminDelay}.\\n     */\\n    function defaultAdminDelay() external view returns (uint48);\\n\\n    /**\\n     * @dev Returns a tuple of `newDelay` and an effect schedule.\\n     *\\n     * After the `schedule` passes, the `newDelay` will get into effect immediately for every\\n     * new {defaultAdmin} transfer started with {beginDefaultAdminTransfer}.\\n     *\\n     * A zero value only in `effectSchedule` indicates no pending delay change.\\n     *\\n     * NOTE: A zero value only for `newDelay` means that the next {defaultAdminDelay}\\n     * will be zero after the effect schedule.\\n     */\\n    function pendingDefaultAdminDelay() external view returns (uint48 newDelay, uint48 effectSchedule);\\n\\n    /**\\n     * @dev Starts a {defaultAdmin} transfer by setting a {pendingDefaultAdmin} scheduled for acceptance\\n     * after the current timestamp plus a {defaultAdminDelay}.\\n     *\\n     * Requirements:\\n     *\\n     * - Only can be called by the current {defaultAdmin}.\\n     *\\n     * Emits a DefaultAdminRoleChangeStarted event.\\n     */\\n    function beginDefaultAdminTransfer(address newAdmin) external;\\n\\n    /**\\n     * @dev Cancels a {defaultAdmin} transfer previously started with {beginDefaultAdminTransfer}.\\n     *\\n     * A {pendingDefaultAdmin} not yet accepted can also be cancelled with this function.\\n     *\\n     * Requirements:\\n     *\\n     * - Only can be called by the current {defaultAdmin}.\\n     *\\n     * May emit a DefaultAdminTransferCanceled event.\\n     */\\n    function cancelDefaultAdminTransfer() external;\\n\\n    /**\\n     * @dev Completes a {defaultAdmin} transfer previously started with {beginDefaultAdminTransfer}.\\n     *\\n     * After calling the function:\\n     *\\n     * - `DEFAULT_ADMIN_ROLE` should be granted to the caller.\\n     * - `DEFAULT_ADMIN_ROLE` should be revoked from the previous holder.\\n     * - {pendingDefaultAdmin} should be reset to zero values.\\n     *\\n     * Requirements:\\n     *\\n     * - Only can be called by the {pendingDefaultAdmin}'s `newAdmin`.\\n     * - The {pendingDefaultAdmin}'s `acceptSchedule` should've passed.\\n     */\\n    function acceptDefaultAdminTransfer() external;\\n\\n    /**\\n     * @dev Initiates a {defaultAdminDelay} update by setting a {pendingDefaultAdminDelay} scheduled for getting\\n     * into effect after the current timestamp plus a {defaultAdminDelay}.\\n     *\\n     * This function guarantees that any call to {beginDefaultAdminTransfer} done between the timestamp this\\n     * method is called and the {pendingDefaultAdminDelay} effect schedule will use the current {defaultAdminDelay}\\n     * set before calling.\\n     *\\n     * The {pendingDefaultAdminDelay}'s effect schedule is defined in a way that waiting until the schedule and then\\n     * calling {beginDefaultAdminTransfer} with the new delay will take at least the same as another {defaultAdmin}\\n     * complete transfer (including acceptance).\\n     *\\n     * The schedule is designed for two scenarios:\\n     *\\n     * - When the delay is changed for a larger one the schedule is `block.timestamp + newDelay` capped by\\n     * {defaultAdminDelayIncreaseWait}.\\n     * - When the delay is changed for a shorter one, the schedule is `block.timestamp + (current delay - new delay)`.\\n     *\\n     * A {pendingDefaultAdminDelay} that never got into effect will be canceled in favor of a new scheduled change.\\n     *\\n     * Requirements:\\n     *\\n     * - Only can be called by the current {defaultAdmin}.\\n     *\\n     * Emits a DefaultAdminDelayChangeScheduled event and may emit a DefaultAdminDelayChangeCanceled event.\\n     */\\n    function changeDefaultAdminDelay(uint48 newDelay) external;\\n\\n    /**\\n     * @dev Cancels a scheduled {defaultAdminDelay} change.\\n     *\\n     * Requirements:\\n     *\\n     * - Only can be called by the current {defaultAdmin}.\\n     *\\n     * May emit a DefaultAdminDelayChangeCanceled event.\\n     */\\n    function rollbackDefaultAdminDelay() external;\\n\\n    /**\\n     * @dev Maximum time in seconds for an increase to {defaultAdminDelay} (that is scheduled using {changeDefaultAdminDelay})\\n     * to take effect. Default to 5 days.\\n     *\\n     * When the {defaultAdminDelay} is scheduled to be increased, it goes into effect after the new delay has passed with\\n     * the purpose of giving enough time for reverting any accidental change (i.e. using milliseconds instead of seconds)\\n     * that may lock the contract. However, to avoid excessive schedules, the wait is capped by this function and it can\\n     * be overrode for a custom {defaultAdminDelay} increase scheduling.\\n     *\\n     * IMPORTANT: Make sure to add a reasonable amount of time while overriding this value, otherwise,\\n     * there's a risk of setting a high new delay that goes into effect almost immediately without the\\n     * possibility of human intervention in the case of an input error (eg. set milliseconds instead of seconds).\\n     */\\n    function defaultAdminDelayIncreaseWait() external view returns (uint48);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC5313.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5313.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface for the Light Contract Ownership Standard.\\n *\\n * A standardized minimal interface required to identify an account that controls a contract\\n *\\n * _Available since v4.9._\\n */\\ninterface IERC5313 {\\n    /**\\n     * @dev Gets the address of the owner.\\n     */\\n    function owner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/chainlink/contracts/src/v0.8/interfaces/ERC677ReceiverInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\ninterface ERC677ReceiverInterface {\\n  function onTokenTransfer(\\n    address sender,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"lib/chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface LinkTokenInterface {\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n  function approve(address spender, uint256 value) external returns (bool success);\\n\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  function decimals() external view returns (uint8 decimalPlaces);\\n\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\n\\n  function name() external view returns (string memory tokenName);\\n\\n  function symbol() external view returns (string memory tokenSymbol);\\n\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\n\\n  function transfer(address to, uint256 value) external returns (bool success);\\n\\n  function transferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external returns (bool success);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\"\r\n    },\r\n    \"src/interfaces/IMigratable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IMigratable {\\n  /// @notice This error is thrown when the owner tries to set the migration target to the\\n  /// zero address or an invalid address as well as when the migration target is not set and owner\\n  /// tries to migrate the contract.\\n  error InvalidMigrationTarget();\\n\\n  /// @notice This event is emitted when the migration target is set\\n  /// @param oldMigrationTarget The previous migration target\\n  /// @param newMigrationTarget The updated migration target\\n  event MigrationTargetSet(address indexed oldMigrationTarget, address indexed newMigrationTarget);\\n\\n  /// @notice Sets the address this contract will be upgraded to\\n  /// @param newMigrationTarget The address of the migration target\\n  function setMigrationTarget(address newMigrationTarget) external;\\n\\n  /// @notice Returns the current migration target of the contract\\n  /// @return address The current migration target\\n  function getMigrationTarget() external view returns (address);\\n\\n  /// @notice Migrates the contract\\n  /// @param data Optional calldata to call on new contract\\n  function migrate(bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStakingOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IStakingOwner {\\n  /// @notice This event is emitted when the staking pool is opened for staking\\n  event PoolOpened();\\n  /// @notice This event is emitted when the staking pool is closed\\n  event PoolClosed();\\n\\n  /// @notice This error is thrown when an invalid min operator stake amount is\\n  /// supplied\\n  error InvalidMinStakeAmount();\\n  /// @notice This error is raised when attempting to decrease maximum pool size\\n  /// @param maxPoolSize the proposed maximum pool size\\n  error InvalidPoolSize(uint256 maxPoolSize);\\n  /// @notice This error is raised when attempting to decrease maximum stake amount\\n  /// for the pool members\\n  /// @param maxStakeAmount the proposed maximum stake amount\\n  error InvalidMaxStakeAmount(uint256 maxStakeAmount);\\n\\n  /// @notice This error is thrown when the staking pool is closed.\\n  error PoolNotOpen();\\n\\n  /// @notice This error is thrown when the staking pool is open.\\n  error PoolNotClosed();\\n\\n  /// @notice This error is thrown when the staking pool has been opened and contract manager tries\\n  /// to re-open.\\n  error PoolHasBeenOpened();\\n\\n  /// @notice This error is thrown when the pool has been closed and contract manager tries to\\n  /// re-open\\n  error PoolHasBeenClosed();\\n\\n  /// @notice Set the pool config\\n  /// @param maxPoolSize The max amount of staked LINK allowed in the pool\\n  /// @param maxPrincipalPerStaker The max amount of LINK a staker can stake\\n  /// in the pool.\\n  function setPoolConfig(uint256 maxPoolSize, uint256 maxPrincipalPerStaker) external;\\n\\n  /// @notice Opens the pool for staking\\n  function open() external;\\n\\n  /// @notice Closes the pool\\n  function close() external;\\n\\n  /// @notice Sets the migration proxy contract address\\n  /// @param migrationProxy The migration proxy contract address\\n  function setMigrationProxy(address migrationProxy) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStakingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {IRewardVault} from \\\"./IRewardVault.sol\\\";\\nimport {Checkpoints} from \\\"@openzeppelin/contracts/utils/Checkpoints.sol\\\";\\n\\ninterface IStakingPool {\\n  /// @notice This error is thrown when a caller tries to execute a transaction\\n  /// that they do not have permissions for\\n  error AccessForbidden();\\n\\n  /// @notice This event is emitted when the migration proxy address has been set\\n  /// @param oldMigrationProxy The old migration proxy contract address\\n  /// @param newMigrationProxy The new migration proxy contract address\\n  event MigrationProxySet(address indexed oldMigrationProxy, address indexed newMigrationProxy);\\n\\n  /// @notice This event is emitted when the staking pool's maximum size is\\n  /// increased\\n  /// @param maxPoolSize the new maximum pool size\\n  event PoolSizeIncreased(uint256 maxPoolSize);\\n\\n  /// @notice This event is emitted when the maximum stake amount\\n  // for the stakers in the pool is increased\\n  /// @param maxPrincipalPerStaker the new maximum stake amount\\n  event MaxPrincipalAmountIncreased(uint256 maxPrincipalPerStaker);\\n\\n  /// @notice This event is emitted when a staker adds stake to the pool.\\n  /// @param staker Staker address\\n  /// @param amount Amount of stake added\\n  /// @param newStake New LINK amount staked\\n  /// @param newTotalPrincipal Total amount of juels staked in the pool\\n  event Staked(address indexed staker, uint256 amount, uint256 newStake, uint256 newTotalPrincipal);\\n\\n  /// @notice This event is emitted when a staker removes stake from the pool.\\n  /// @param staker Staker address\\n  /// @param amount Amount of stake removed\\n  /// @param newStake New LINK amount staked\\n  /// @param newTotalPrincipal Total amount of staked juels remaining in the pool\\n  event Unstaked(\\n    address indexed staker, uint256 amount, uint256 newStake, uint256 newTotalPrincipal\\n  );\\n\\n  /// @notice This error is thrown whenever a zero-address is supplied when\\n  /// a non-zero address is required\\n  error InvalidZeroAddress();\\n\\n  /// @notice This error is thrown whenever the sender is not the LINK token\\n  error SenderNotLinkToken();\\n\\n  /// @notice This error is thrown whenever the migration proxy address has not been set\\n  error MigrationProxyNotSet();\\n\\n  /// @notice This error is thrown whenever the reward vault address has not been set\\n  error RewardVaultNotSet();\\n\\n  /// @notice This error is thrown when invalid data is passed to the onTokenTransfer function\\n  error InvalidData();\\n\\n  /// @notice This error is thrown when the staker tries to stake less than the min amount\\n  error InsufficientStakeAmount();\\n\\n  /// @notice This error is thrown when the staker tries to stake more than the max amount\\n  error ExceedsMaxStakeAmount();\\n\\n  /// @notice This error is thrown when the staker tries to stake more than the max pool size\\n  error ExceedsMaxPoolSize();\\n\\n  /// @notice This error is raised when stakers attempt to exit the pool\\n  /// @param staker address of the staker\\n  error StakeNotFound(address staker);\\n\\n  /// @notice This error is thrown when the staker tries to unstake a zero amount\\n  error UnstakeZeroAmount();\\n\\n  /// @notice This error is thrown when the staker tries to unstake more than the\\n  /// staked LINK amount\\n  error UnstakeExceedsPrincipal();\\n\\n  /// @notice This error is thrown when the staker tries to unstake an amount that leaves their\\n  /// staked LINK amount below the minimum amount\\n  error UnstakePrincipalBelowMinAmount();\\n\\n  /// @notice This struct defines the state of a staker\\n  struct Staker {\\n    /// @notice The combined staked LINK amount and staked at time history\\n    /// @dev Both the staker staked LINK amount and staked at timestamp are stored in uint112 to\\n    /// save space\\n    /// @dev The max value of uint112 is greater than the total supply of LINK\\n    /// @dev The max value of uint112 can represent a timestamp in the year 3615, long after the\\n    /// staking program has ended\\n    /// @dev The combination is performed as such:\\n    /// uint224 history = (uint224(uint112(principal)) << 112) |\\n    /// uint224(uint112(stakedAtTime))\\n    Checkpoints.History history;\\n    /// @notice The staker's unbonding period end time\\n    uint128 unbondingPeriodEndsAt;\\n    /// @notice The staker's claim period end time\\n    uint128 claimPeriodEndsAt;\\n  }\\n\\n  /// @notice Unstakes amount LINK tokens from the staker\u2019s staked LINK amount\\n  /// @param amount The amount of LINK tokens to unstake\\n  function unstake(uint256 amount) external;\\n\\n  /// @notice Returns the total amount staked in the pool\\n  /// @return The total amount staked in pool\\n  function getTotalPrincipal() external view returns (uint256);\\n\\n  /// @notice Returns the staker's staked LINK amount\\n  /// @param staker The address of the staker to query for\\n  /// @return uint256 The staker's staked LINK amount\\n  function getStakerPrincipal(address staker) external view returns (uint256);\\n\\n  /// @notice Returns the staker's staked LINK amount\\n  /// @param staker The address of the staker to query for\\n  /// @param blockNumber The block number to fetch the staker's balance for.  Pass 0\\n  /// to return the staker's latest staked LINK amount\\n  /// @return uint256 The staker's staked LINK amount\\n  function getStakerPrincipalAt(\\n    address staker,\\n    uint256 blockNumber\\n  ) external view returns (uint256);\\n\\n  /// @notice Returns the staker's average staked at time\\n  /// @param staker The address of the staker to query for\\n  /// @return uint256 The staker's average staked at time\\n  function getStakerStakedAtTime(address staker) external view returns (uint256);\\n\\n  /// @notice Returns the staker's last staked at time for a block number ID\\n  /// @param staker The address of the staker to query for\\n  /// @param blockNumber The block number to query for\\n  /// @return uint256 The staker's staked at time for the block number ID\\n  function getStakerStakedAtTimeAt(\\n    address staker,\\n    uint256 blockNumber\\n  ) external view returns (uint256);\\n\\n  /// @notice Returns the current reward vault address\\n  /// @return The reward vault\\n  function getRewardVault() external view returns (IRewardVault);\\n\\n  /// @notice Returns the address of the LINK token contract\\n  /// @return The LINK token contract's address that is used by the pool\\n  function getChainlinkToken() external view returns (address);\\n\\n  /// @notice Returns the migration proxy contract address\\n  /// @return The migration proxy contract address\\n  function getMigrationProxy() external view returns (address);\\n\\n  /// @notice Returns a boolean that is true if the pool is open\\n  /// @return True if the pool is open, false otherwise\\n  function isOpen() external view returns (bool);\\n\\n  /// @notice Returns a boolean that is true if the pool is active,\\n  /// i.e. is open and there are remaining rewards to vest in the pool.\\n  /// @return True if the pool is active, false otherwise\\n  function isActive() external view returns (bool);\\n\\n  /// @notice Returns the minimum and maximum amounts a staker can stake in the\\n  /// pool\\n  /// @return uint256 minimum amount that can be staked by a staker\\n  /// @return uint256 maximum amount that can be staked by a staker\\n  function getStakerLimits() external view returns (uint256, uint256);\\n\\n  /// @notice uint256 Returns the maximum amount that can be staked in the pool\\n  /// @return uint256 current maximum staking pool size\\n  function getMaxPoolSize() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/Migratable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {AccessControlDefaultAdminRules} from\\n  \\\"@openzeppelin/contracts/access/AccessControlDefaultAdminRules.sol\\\";\\n\\nimport {IMigratable} from \\\"./interfaces/IMigratable.sol\\\";\\n\\n/// @notice Base contract that adds migration functionality.\\nabstract contract Migratable is IMigratable, AccessControlDefaultAdminRules {\\n  /// @notice The address of the new contract that this contract will be upgraded to.\\n  address internal s_migrationTarget;\\n\\n  function setMigrationTarget(address newMigrationTarget)\\n    external\\n    override\\n    onlyRole(DEFAULT_ADMIN_ROLE)\\n  {\\n    _validateMigrationTarget(newMigrationTarget);\\n\\n    address oldMigrationTarget = s_migrationTarget;\\n    s_migrationTarget = newMigrationTarget;\\n\\n    emit MigrationTargetSet(oldMigrationTarget, newMigrationTarget);\\n  }\\n\\n  /// @inheritdoc IMigratable\\n  function getMigrationTarget() external view returns (address) {\\n    return s_migrationTarget;\\n  }\\n\\n  /// @notice Helper function for validating the migration target\\n  /// @param newMigrationTarget The address of the new migration target\\n  function _validateMigrationTarget(address newMigrationTarget) internal virtual {\\n    if (\\n      newMigrationTarget == address(0) || newMigrationTarget == address(this)\\n        || newMigrationTarget == s_migrationTarget || newMigrationTarget.code.length == 0\\n    ) {\\n      revert InvalidMigrationTarget();\\n    }\\n  }\\n\\n  /// @dev Reverts if the migration target is not set\\n  modifier validateMigrationTargetSet() {\\n    if (s_migrationTarget == address(0)) {\\n      revert InvalidMigrationTarget();\\n    }\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/PausableWithAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {AccessControlDefaultAdminRules} from\\n  \\\"@openzeppelin/contracts/access/AccessControlDefaultAdminRules.sol\\\";\\nimport {Pausable} from \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\n\\nimport {IPausable} from \\\"./interfaces/IPausable.sol\\\";\\n\\n/// @notice Base contract that adds pausing and access control functionality.\\nabstract contract PausableWithAccessControl is IPausable, Pausable, AccessControlDefaultAdminRules {\\n  /// @notice This is the ID for the pauser role, which is given to the addresses that can pause and\\n  /// unpause the contract.\\n  /// @dev Hash: 65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a\\n  bytes32 public constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\n\\n  constructor(\\n    uint48 adminRoleTransferDelay,\\n    address defaultAdmin\\n  ) AccessControlDefaultAdminRules(adminRoleTransferDelay, defaultAdmin) {}\\n\\n  /// @inheritdoc IPausable\\n  function emergencyPause() external onlyRole(PAUSER_ROLE) {\\n    _pause();\\n  }\\n\\n  /// @inheritdoc IPausable\\n  function emergencyUnpause() external onlyRole(PAUSER_ROLE) {\\n    _unpause();\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IPausable {\\n  /// @notice This function pauses the contract\\n  /// @dev Sets the pause flag to true\\n  function emergencyPause() external;\\n\\n  /// @notice This function unpauses the contract\\n  /// @dev Sets the pause flag to false\\n  function emergencyUnpause() external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@chainlink/=lib/chainlink/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"@solmate/=lib/solmate/src/\",\r\n      \"chainlink/=lib/chainlink/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"lib/forge-std:ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/openzeppelin-contracts:ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/openzeppelin-contracts:erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"lib/openzeppelin-contracts:forge-std/=lib/openzeppelin-contracts/lib/forge-std/src/\",\r\n      \"lib/openzeppelin-contracts:openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"lib/solmate:ds-test/=lib/solmate/lib/ds-test/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"contract LinkTokenInterface\",\"name\":\"LINKAddress\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"initialMaxPoolSize\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"initialMaxPrincipalPerStaker\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"minPrincipalPerStaker\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"initialUnbondingPeriod\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxUnbondingPeriod\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"initialClaimPeriod\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"minClaimPeriod\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxClaimPeriod\",\"type\":\"uint32\"},{\"internalType\":\"uint48\",\"name\":\"adminRoleTransferDelay\",\"type\":\"uint48\"}],\"internalType\":\"struct StakingPoolBase.ConstructorParamsBase\",\"name\":\"baseParams\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"minInitialOperatorCount\",\"type\":\"uint256\"}],\"internalType\":\"struct OperatorStakingPool.ConstructorParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessForbidden\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExceedsMaxPoolSize\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExceedsMaxStakeAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numOperators\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minInitialOperatorCount\",\"type\":\"uint256\"}],\"name\":\"InadequateInitialOperatorCount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingBalance\",\"type\":\"uint256\"}],\"name\":\"InsufficientAlerterRewardFunds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxPoolSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrincipalPerStaker\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numOperators\",\"type\":\"uint256\"}],\"name\":\"InsufficientPoolSpace\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientStakeAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAlerterRewardFundAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidClaimPeriod\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minClaimPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxClaimPeriod\",\"type\":\"uint256\"}],\"name\":\"InvalidClaimPeriodRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidData\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxStakeAmount\",\"type\":\"uint256\"}],\"name\":\"InvalidMaxStakeAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxUnbondingPeriod\",\"type\":\"uint256\"}],\"name\":\"InvalidMaxUnbondingPeriod\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMigrationTarget\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMinStakeAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOperator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOperatorList\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxPoolSize\",\"type\":\"uint256\"}],\"name\":\"InvalidPoolSize\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRole\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSlasher\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSlasherConfig\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidUnbondingPeriod\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MigrationProxyNotSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorAlreadyExists\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorCannotBeCommunityStaker\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorHasBeenRemoved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolHasBeenClosed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolHasBeenOpened\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolNotActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolNotClosed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolNotOpen\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RewardVaultHasNoRewards\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RewardVaultNotActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RewardVaultNotClosed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RewardVaultNotSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderNotLinkToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"StakeNotFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"StakerNotInClaimPeriod\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StakerNotOperator\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unbondingPeriodEndsAt\",\"type\":\"uint256\"}],\"name\":\"UnbondingOrClaimPeriodActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnstakeExceedsPrincipal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnstakePrincipalBelowMinAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnstakeZeroAmount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountFunded\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBalance\",\"type\":\"uint256\"}],\"name\":\"AlerterRewardDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainingBalance\",\"type\":\"uint256\"}],\"name\":\"AlerterRewardWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"alerter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"alerterRewardActual\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"alerterRewardExpected\",\"type\":\"uint256\"}],\"name\":\"AlertingRewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldClaimPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newClaimPeriod\",\"type\":\"uint256\"}],\"name\":\"ClaimPeriodSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"DefaultAdminDelayChangeCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"newDelay\",\"type\":\"uint48\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"effectSchedule\",\"type\":\"uint48\"}],\"name\":\"DefaultAdminDelayChangeScheduled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"DefaultAdminTransferCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"acceptSchedule\",\"type\":\"uint48\"}],\"name\":\"DefaultAdminTransferScheduled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxPrincipalPerStaker\",\"type\":\"uint256\"}],\"name\":\"MaxPrincipalAmountIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldMigrationProxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newMigrationProxy\",\"type\":\"address\"}],\"name\":\"MigrationProxySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldMigrationTarget\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newMigrationTarget\",\"type\":\"address\"}],\"name\":\"MigrationTargetSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalPrincipal\",\"type\":\"uint256\"}],\"name\":\"OperatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PoolClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PoolOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxPoolSize\",\"type\":\"uint256\"}],\"name\":\"PoolSizeIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldRewardVault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRewardVault\",\"type\":\"address\"}],\"name\":\"RewardVaultSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slashedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updatedStakerPrincipal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalPrincipal\",\"type\":\"uint256\"}],\"name\":\"Slashed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"slasher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refillRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slashCapacity\",\"type\":\"uint256\"}],\"name\":\"SlasherConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newStake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalPrincipal\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"migrationTarget\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"migrationData\",\"type\":\"bytes\"}],\"name\":\"StakerMigrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"UnbondingPeriodReset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldUnbondingPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newUnbondingPeriod\",\"type\":\"uint256\"}],\"name\":\"UnbondingPeriodSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"UnbondingPeriodStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newStake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalPrincipal\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ALERT_REWARDER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INITIATOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OPERATOR_MANAGER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAUSER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SLASHER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptDefaultAdminTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"addOperators\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"slasher\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"refillRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slashCapacity\",\"type\":\"uint256\"}],\"internalType\":\"struct ISlashable.SlasherConfig\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"addSlasher\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"beginDefaultAdminTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelDefaultAdminTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint48\",\"name\":\"newDelay\",\"type\":\"uint48\"}],\"name\":\"changeDefaultAdminDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultAdminDelay\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultAdminDelayIncreaseWait\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositAlerterReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyUnpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAlerterRewardFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainlinkToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getClaimPeriodEndsAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClaimPeriodLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxPoolSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxUnbondingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMigrationProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMigrationTarget\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumOperators\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getRemovedPrincipal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardVault\",\"outputs\":[{\"internalType\":\"contract IRewardVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"slasher\",\"type\":\"address\"}],\"name\":\"getSlashCapacity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"slasher\",\"type\":\"address\"}],\"name\":\"getSlasherConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"refillRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slashCapacity\",\"type\":\"uint256\"}],\"internalType\":\"struct ISlashable.SlasherConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakerLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getStakerPrincipal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getStakerPrincipalAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getStakerStakedAtTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getStakerStakedAtTimeAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalPrincipal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getUnbondingEndsAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnbondingParams\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"isRemoved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"open\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingDefaultAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"schedule\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingDefaultAdminDelay\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"newDelay\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"schedule\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"removeOperators\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"slasher\",\"type\":\"address\"}],\"name\":\"removeSlasher\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollbackDefaultAdminDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimPeriod\",\"type\":\"uint256\"}],\"name\":\"setClaimPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"migrationProxy\",\"type\":\"address\"}],\"name\":\"setMigrationProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMigrationTarget\",\"type\":\"address\"}],\"name\":\"setMigrationTarget\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxPoolSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrincipalPerStaker\",\"type\":\"uint256\"}],\"name\":\"setPoolConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IRewardVault\",\"name\":\"newRewardVault\",\"type\":\"address\"}],\"name\":\"setRewardVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"slasher\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"refillRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slashCapacity\",\"type\":\"uint256\"}],\"internalType\":\"struct ISlashable.SlasherConfig\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"setSlasherConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newUnbondingPeriod\",\"type\":\"uint256\"}],\"name\":\"setUnbondingPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"stakers\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"alerter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"principalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"alerterRewardAmount\",\"type\":\"uint256\"}],\"name\":\"slashAndReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typeAndVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unbond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeRemovedPrincipal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawAlerterReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OperatorStakingPool", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca000000000000000000000000000000000000000000036980b2b50d5438200000000000000000000000000000000000000000000000000fe1c215e8f838e0000000000000000000000000000000000000000000000000003635c9adc5dea00000000000000000000000000000000000000000000000000000000000000024ea0000000000000000000000000000000000000000000000000000000000004f1a000000000000000000000000000000000000000000000000000000000000093a8000000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000000000000278d0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}