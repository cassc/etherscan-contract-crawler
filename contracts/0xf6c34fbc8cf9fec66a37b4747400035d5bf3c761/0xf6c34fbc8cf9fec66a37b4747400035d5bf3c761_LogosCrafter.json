{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/LogosCrafter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.20;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { LogosTypes as L } from \\\"./LogosTypes.sol\\\";\\n\\ninterface ILogosTraits {\\n    function charactersByID(uint8) external view returns (L.CharacterInfo memory);\\n    function shapesPrimaryByID(uint8) external view returns (L.ShapeInfo memory);\\n    function shapesSecondaryByID(uint8) external view returns (L.ShapeInfo memory);\\n    function colorPalettesByID(uint16) external view returns (L.ColorPalette memory);\\n}\\n\\ninterface ERC721 {\\n    function ownerOf(uint256) external view returns (address);\\n}\\n\\ncontract LogosCrafter is Ownable {\\n    bool public locked;\\n    bool public paused;\\n    ERC721 public logosContract;\\n    ILogosTraits public traitsContract;\\n\\n    struct Hash {\\n        bool taken;\\n        uint16 tokenID;\\n    }\\n\\n    mapping (uint256 => L.Logo) public _logosByTokenID;\\n    mapping (bytes32 => Hash) public _characterHashes;\\n    mapping (bytes32 => Hash) public _shapeHashes;\\n\\n    event TokenUpdated(uint256 tokenID, L.Logo logo, bool isFirstUpdate);\\n\\n    constructor(address logosContractAddress, address traitsContactAddress) Ownable() {\\n        logosContract = ERC721(logosContractAddress);\\n        traitsContract = ILogosTraits(traitsContactAddress);\\n    }\\n\\n    function lock(string memory ack) external onlyOwner {\\n        require(keccak256(abi.encodePacked(ack)) == keccak256(abi.encodePacked(\\\"This action is permanent\\\")), \\\"Incorrect ack\\\");\\n        locked = true;\\n    }\\n\\n    function setPaused(bool _paused) external onlyOwner {\\n        paused = _paused;\\n    }\\n\\n    function logosByTokenID(uint256 tokenID) external view returns (L.Logo memory) {\\n        L.Logo memory logo = _logosByTokenID[tokenID];\\n\\n        check(tokenID, logo);\\n    \\n        return _logosByTokenID[tokenID];\\n    }\\n\\n    function update(uint256 tokenID, L.Logo memory logo) public {\\n        _update(tokenID, logo, false);\\n    }\\n\\n    function updateAndSkipChecks(uint256 tokenID, L.Logo memory logo) public {\\n        _update(tokenID, logo, true);\\n    }\\n\\n    function check(uint256 tokenID, L.Logo memory logo) public view {\\n        L.CharacterInfo memory character = traitsContract.charactersByID(logo.characterSelections.characterID);\\n        L.ShapeInfo memory primaryShape = traitsContract.shapesPrimaryByID(logo.shapeSelections.primaryShape);\\n        L.ShapeInfo memory secondaryShape = traitsContract.shapesSecondaryByID(logo.shapeSelections.secondaryShape);\\n        L.ColorPalette memory colorPalette = traitsContract.colorPalettesByID(logo.colorPalette);\\n\\n        require(character.enabled, \\\"Character not enabled\\\");\\n        require(primaryShape.enabled, \\\"Primary shape not enabled\\\");\\n        require(primaryShape.numVariants >= logo.shapeSelections.primaryShapeVariant, \\\"Primary shape variant out of range\\\");\\n        require(secondaryShape.enabled, \\\"Secondary shape not enabled\\\");\\n        require(secondaryShape.numVariants >= logo.shapeSelections.secondaryShapeVariant, \\\"Secondary shape variant out of range\\\");\\n        require(colorPalette.enabled, \\\"Color palette not enabled\\\");\\n        require(logo.characterSelections.slotSelections.length == character.slotOffsets.length, \\\"Wrong number of slot selections\\\");\\n\\n        // check that no bonus traits were selected if not a Blitmap base\\n        if (tokenID >= 1700) {\\n            require(!character.bodies[logo.characterSelections.body].isBonus, \\\"Bonus body selected\\\");\\n            require(!character.heads[logo.characterSelections.head].isBonus, \\\"Bonus head selected\\\");\\n            require(!colorPalette.isBonus, \\\"Bonus color palette selected\\\");\\n        }\\n\\n        uint256 slotSelectionLength = logo.characterSelections.slotSelections.length;\\n        for (uint8 i = 0; i < slotSelectionLength; i++) {\\n            // check that slot selection is in range\\n            uint256 lengthOfSlot;\\n\\n            if (i < slotSelectionLength - 1) {\\n                lengthOfSlot = character.slotOffsets[i + 1] - character.slotOffsets[i];\\n            } else {\\n                lengthOfSlot = character.slotOptions.length - character.slotOffsets[i];\\n            }\\n\\n            if (logo.characterSelections.slotSelections[i] >= lengthOfSlot) {\\n                revert(\\\"Slot selection out of range\\\");\\n            }\\n\\n            uint8 offset = character.slotOffsets[i] + logo.characterSelections.slotSelections[i];\\n\\n            // Check that the selected trait is not empty\\n            require(bytes(character.slotOptions[offset].name).length > 0, \\\"Empty trait selected\\\");\\n\\n            // check that no bonus traits were selected if not a Blitmap base\\n            if (tokenID >= 1700) {\\n                require(!character.slotOptions[offset].isBonus, \\\"Bonus trait selected\\\");\\n            }\\n        }\\n    }\\n\\n    function _update(uint256 tokenID, L.Logo memory logo, bool skipExternalChecks) internal {\\n        require(!locked, \\\"Locked\\\");\\n        require(!paused, \\\"Paused\\\");\\n        require(logosContract.ownerOf(tokenID) == msg.sender, \\\"Not owner of Logo\\\");\\n\\n        // external checks can be skipped to optimize gas usage, but validity checks (except for collisions) are lost\\n        if (!skipExternalChecks) {\\n            check(tokenID, logo);\\n        }\\n\\n        bytes32 characterHash = keccak256(\\n            abi.encode(\\n                logo.characterSelections.characterID,\\n                logo.characterSelections.slotSelections\\n            )\\n        );\\n\\n        bytes32 shapeHash = keccak256(\\n            abi.encode(\\n                logo.shapeSelections.primaryShape,\\n                logo.shapeSelections.primaryShapeVariant,\\n                logo.shapeSelections.secondaryShape,\\n                logo.shapeSelections.secondaryShapeVariant\\n            )\\n        );\\n\\n        // character/shape hash must be unused or already owned by this token\\n        require(!_characterHashes[characterHash].taken || _characterHashes[characterHash].tokenID == tokenID, \\\"Character combination already used\\\");\\n        require(!_shapeHashes[shapeHash].taken || _shapeHashes[shapeHash].tokenID == tokenID, \\\"Shape combination already used\\\");\\n\\n        // delete old hash if logo was enabled once already\\n        if (_logosByTokenID[tokenID].enabled) {\\n            bytes32 oldCharacterHash = keccak256(\\n                abi.encode(\\n                    _logosByTokenID[tokenID].characterSelections.characterID,\\n                    _logosByTokenID[tokenID].characterSelections.slotSelections\\n                )\\n            );\\n\\n            bytes32 oldShapeHash = keccak256(\\n                abi.encode(\\n                    _logosByTokenID[tokenID].shapeSelections.primaryShape,\\n                    _logosByTokenID[tokenID].shapeSelections.primaryShapeVariant,\\n                    _logosByTokenID[tokenID].shapeSelections.secondaryShape,\\n                    _logosByTokenID[tokenID].shapeSelections.secondaryShapeVariant\\n                )\\n            );\\n\\n            delete _characterHashes[oldCharacterHash];\\n            delete _shapeHashes[oldShapeHash];\\n        }\\n\\n        _characterHashes[characterHash].taken = true;\\n        _characterHashes[characterHash].tokenID = uint16(tokenID);\\n        _shapeHashes[shapeHash].taken = true;\\n        _shapeHashes[shapeHash].tokenID = uint16(tokenID);\\n\\n        logo.enabled = true;\\n\\n        bool isFirstUpdate = !_logosByTokenID[tokenID].enabled;\\n        \\n        _logosByTokenID[tokenID] = logo;\\n\\n        emit TokenUpdated(tokenID, logo, isFirstUpdate);\\n    }\\n}\"\r\n    },\r\n    \"contracts/LogosTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.20;\\n\\nlibrary LogosTypes {\\n    struct TraitChoice {\\n        string name;\\n        bool isBonus;\\n    }\\n\\n    struct CharacterInfo {\\n        string name;\\n        TraitChoice[] bodies;\\n        TraitChoice[] heads;\\n        string[] slotNames;\\n        uint8[] slotOffsets;\\n        TraitChoice[] slotOptions;\\n        bool enabled;\\n    }\\n\\n    struct ShapeInfo {\\n        string name;\\n        string companyName;\\n        uint8 numVariants; // number of ADDITIONAL variants, not including the base\\n        bool enabled;\\n    }\\n\\n    struct ColorPalette {\\n        string name;\\n        bool isBonus;\\n        string colorA;\\n        string colorB;\\n        bool enabled;\\n    }\\n\\n    struct CharacterSelections {\\n        uint8 characterID;\\n        uint8 body;\\n        uint8 head;\\n        uint8[] slotSelections;\\n    }\\n\\n    struct ShapeSelections {\\n        uint8 primaryShape;\\n        uint8 primaryShapeVariant;\\n        uint8 secondaryShape;\\n        uint8 secondaryShapeVariant;\\n    }\\n\\n    struct Logo {\\n        bool enabled;\\n        CharacterSelections characterSelections;\\n        ShapeSelections shapeSelections;\\n        uint16 colorPalette;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"logosContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"traitsContactAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"characterID\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"head\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"slotSelections\",\"type\":\"uint8[]\"}],\"internalType\":\"struct LogosTypes.CharacterSelections\",\"name\":\"characterSelections\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"primaryShape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"primaryShapeVariant\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"secondaryShape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"secondaryShapeVariant\",\"type\":\"uint8\"}],\"internalType\":\"struct LogosTypes.ShapeSelections\",\"name\":\"shapeSelections\",\"type\":\"tuple\"},{\"internalType\":\"uint16\",\"name\":\"colorPalette\",\"type\":\"uint16\"}],\"indexed\":false,\"internalType\":\"struct LogosTypes.Logo\",\"name\":\"logo\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isFirstUpdate\",\"type\":\"bool\"}],\"name\":\"TokenUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"_characterHashes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"taken\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"tokenID\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_logosByTokenID\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"characterID\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"head\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"slotSelections\",\"type\":\"uint8[]\"}],\"internalType\":\"struct LogosTypes.CharacterSelections\",\"name\":\"characterSelections\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"primaryShape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"primaryShapeVariant\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"secondaryShape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"secondaryShapeVariant\",\"type\":\"uint8\"}],\"internalType\":\"struct LogosTypes.ShapeSelections\",\"name\":\"shapeSelections\",\"type\":\"tuple\"},{\"internalType\":\"uint16\",\"name\":\"colorPalette\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"_shapeHashes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"taken\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"tokenID\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"characterID\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"head\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"slotSelections\",\"type\":\"uint8[]\"}],\"internalType\":\"struct LogosTypes.CharacterSelections\",\"name\":\"characterSelections\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"primaryShape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"primaryShapeVariant\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"secondaryShape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"secondaryShapeVariant\",\"type\":\"uint8\"}],\"internalType\":\"struct LogosTypes.ShapeSelections\",\"name\":\"shapeSelections\",\"type\":\"tuple\"},{\"internalType\":\"uint16\",\"name\":\"colorPalette\",\"type\":\"uint16\"}],\"internalType\":\"struct LogosTypes.Logo\",\"name\":\"logo\",\"type\":\"tuple\"}],\"name\":\"check\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ack\",\"type\":\"string\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"logosByTokenID\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"characterID\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"head\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"slotSelections\",\"type\":\"uint8[]\"}],\"internalType\":\"struct LogosTypes.CharacterSelections\",\"name\":\"characterSelections\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"primaryShape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"primaryShapeVariant\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"secondaryShape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"secondaryShapeVariant\",\"type\":\"uint8\"}],\"internalType\":\"struct LogosTypes.ShapeSelections\",\"name\":\"shapeSelections\",\"type\":\"tuple\"},{\"internalType\":\"uint16\",\"name\":\"colorPalette\",\"type\":\"uint16\"}],\"internalType\":\"struct LogosTypes.Logo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"logosContract\",\"outputs\":[{\"internalType\":\"contract ERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"traitsContract\",\"outputs\":[{\"internalType\":\"contract ILogosTraits\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"characterID\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"head\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"slotSelections\",\"type\":\"uint8[]\"}],\"internalType\":\"struct LogosTypes.CharacterSelections\",\"name\":\"characterSelections\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"primaryShape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"primaryShapeVariant\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"secondaryShape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"secondaryShapeVariant\",\"type\":\"uint8\"}],\"internalType\":\"struct LogosTypes.ShapeSelections\",\"name\":\"shapeSelections\",\"type\":\"tuple\"},{\"internalType\":\"uint16\",\"name\":\"colorPalette\",\"type\":\"uint16\"}],\"internalType\":\"struct LogosTypes.Logo\",\"name\":\"logo\",\"type\":\"tuple\"}],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"characterID\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"head\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"slotSelections\",\"type\":\"uint8[]\"}],\"internalType\":\"struct LogosTypes.CharacterSelections\",\"name\":\"characterSelections\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"primaryShape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"primaryShapeVariant\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"secondaryShape\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"secondaryShapeVariant\",\"type\":\"uint8\"}],\"internalType\":\"struct LogosTypes.ShapeSelections\",\"name\":\"shapeSelections\",\"type\":\"tuple\"},{\"internalType\":\"uint16\",\"name\":\"colorPalette\",\"type\":\"uint16\"}],\"internalType\":\"struct LogosTypes.Logo\",\"name\":\"logo\",\"type\":\"tuple\"}],\"name\":\"updateAndSkipChecks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LogosCrafter", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "20", "ConstructorArguments": "00000000000000000000000089dbbb21922fcfe686d234d751c5507b6b0cdea600000000000000000000000013475a9f853feeffd7634e949622297458e8705a", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}