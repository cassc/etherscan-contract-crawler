{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/plugins/oracle/implementations/BeanOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport {C} from \\\"src/libraries/C.sol\\\";\\nimport {Oracle} from \\\"src/plugins/oracle/Oracle.sol\\\";\\nimport {IWell} from \\\"lib/Beanstalk/IWell.sol\\\";\\nimport {IInstantaneousPump} from \\\"lib/Beanstalk/IInstantaneousPump.sol\\\";\\nimport \\\"@chainlink/AggregatorV2V3Interface.sol\\\";\\n\\ninterface ISilo {\\n    function wellBdv(address token, uint256 amount) external view returns (uint256);\\n\\n    function curveToBDV(uint256 amount) external view returns (uint256);\\n}\\n\\ncontract BeanOracle is Oracle {\\n    address BEANSTALK_PUMP = 0xBA510f10E3095B83a0F33aa9ad2544E22570a87C;\\n    address BEAN_ETH_WELL = 0xBEA0e11282e2bB5893bEcE110cF199501e872bAd;\\n    address BEANSTALK = 0xC1E088fC1323b20BCBee9bd1B9fC9546db5624C5;\\n\\n    struct Parameters {\\n        uint8 input; //1 for Bean, 2 for Bean:ETH and 3 for Bean:3CRV\\n    }\\n\\n    function getOpenPrice(bytes calldata parameters) external view returns (uint256) {\\n        return _value(parameters);\\n    }\\n\\n    function getClosePrice(bytes calldata parameters) external view returns (uint256) {\\n        return _value(parameters);\\n    }\\n\\n    function _value(bytes calldata parameters) internal view returns (uint256) {\\n        uint8 input = abi.decode(parameters, (uint8));\\n\\n        //get ETH:BEAN price from BEANSTALK_PUMP = 0xBA510f10E3095B83a0F33aa9ad2544E22570a87C , BEAN:ETH_WELL = 0xBEA0e11282e2bB5893bEcE110cF199501e872bAd\\n        uint[] memory reserves = IInstantaneousPump(BEANSTALK_PUMP).readInstantaneousReserves(\\n            BEAN_ETH_WELL,\\n            C.BYTES_ZERO\\n        );\\n        uint256 ethBeanvalue;\\n        uint256 beanUsdValue;\\n        ethBeanvalue = ((reserves[0] * (1e30)) / reserves[1]); //price of ETH in Beans 18 dec precision\\n\\n        //Get ETH:USD price from Chainlink DataFeed 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\\n        (, int256 answer, , , ) = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419).latestRoundData();\\n        uint256 ethUsdValue;\\n        ethUsdValue = (uint256(answer) * C.RATIO_FACTOR) / (10 ** (8)); // price of ETH in USD in 18 dec precision\\n        beanUsdValue = (ethUsdValue * C.RATIO_FACTOR) / ethBeanvalue; // price of Bean in USD in 18 dec precision\\n        if (input == 1) {\\n            // return BEAN:USD (number of USD per Bean) price with 18 dec precision\\n            return beanUsdValue;\\n        } else if (input == 2) {\\n            // return BeanEthLP:USD (number of USD per Bean:ETH LP) price with 18 dec precision\\n            uint256 wellBDV = ISilo(BEANSTALK).wellBdv(BEAN_ETH_WELL, 1e18);\\n            return (beanUsdValue * wellBDV/10**(6));\\n        } else if (input == 3) \\n        {   // return 3CRV:USD (number of USD per 3CRV) price with 18 dec precision\\n            uint256 crvBDV = ISilo(BEANSTALK).curveToBDV(1e18);\\n            return (beanUsdValue * crvBDV/10**(6));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/C.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nlibrary C {\\n    uint256 internal constant RATIO_FACTOR = 1e18;\\n\\n    uint256 internal constant ETH_DECIMALS = 18;\\n\\n    // Mainnet, Arbitrum\\n    address internal constant UNI_V3_FACTORY = address(0x1F98431c8aD98523631AE4a59f267346ea31F984);\\n    address internal constant UNI_V3_ROUTER = address(0xE592427A0AEce92De3Edee1F18E0157C05861564);\\n\\n     // MAINNET\\n     address internal constant WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\\n\\n    // //ARBITRUM\\n    // address internal constant WETH = address(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);\\n\\n    // SEPOLIA\\n    //address internal constant WETH = address(0x7b79995e5f793A07Bc00c21412e50Ecae098E7f9);\\n\\n    bytes32 internal constant BOOKKEEPER_ROLE = keccak256(\\\"BOOKKEEPER_ROLE\\\");\\n    bytes32 internal constant ADMIN_ROLE = 0x00;\\n    bytes constant BYTES_ZERO = new bytes(0);\\n\\n}\\n\"\r\n    },\r\n    \"src/plugins/oracle/Oracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\nimport {IOracle} from \\\"src/interfaces/IOracle.sol\\\";\\n\\nabstract contract Oracle is IOracle {}\\n\"\r\n    },\r\n    \"lib/Beanstalk/IWell.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.8.19;\\npragma experimental ABIEncoderV2;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title Call is the struct that contains the target address and extra calldata of a generic call.\\n */\\nstruct Call {\\n    address target; // The address the call is executed on.\\n    bytes data; // Extra calldata to be passed during the call\\n}\\n\\n/**\\n * @title IWell is the interface for the Well contract.\\n */\\ninterface IWell {\\n    /**\\n     * @notice Emitted when a Swap occurs.\\n     * @param fromToken The token swapped from\\n     * @param toToken The token swapped to\\n     * @param amountIn The amount of `fromToken` transferred into the Well\\n     * @param amountOut The amount of `toToken` transferred out of the Well\\n     * @param recipient The address to receive `toToken`\\n     */\\n    event Swap(IERC20 fromToken, IERC20 toToken, uint amountIn, uint amountOut, address recipient);\\n\\n    /**\\n     * @notice Emitted when liquidity is added to the Well.\\n     * @param tokenAmountsIn The amount of each token added to the Well\\n     * @param lpAmountOut The amount of LP tokens minted\\n     * @param recipient The address to receive the LP tokens\\n     */\\n    event AddLiquidity(uint[] tokenAmountsIn, uint lpAmountOut, address recipient);\\n\\n    /**\\n     * @notice Emitted when liquidity is removed from the Well as multiple underlying tokens.\\n     * @param lpAmountIn The amount of LP tokens burned\\n     * @param tokenAmountsOut The amount of each underlying token removed\\n     * @param recipient The address to receive the underlying tokens\\n     * @dev Gas cost scales with `n` tokens.\\n     */\\n    event RemoveLiquidity(uint lpAmountIn, uint[] tokenAmountsOut, address recipient);\\n\\n    /**\\n     * @notice Emitted when liquidity is removed from the Well as a single underlying token.\\n     * @param lpAmountIn The amount of LP tokens burned\\n     * @param tokenOut The underlying token removed\\n     * @param tokenAmountOut The amount of `tokenOut` removed\\n     * @param recipient The address to receive the underlying tokens\\n     * @dev Emitting a separate event when removing liquidity as a single token\\n     * saves gas, since `tokenAmountsOut` in {RemoveLiquidity} must emit a value\\n     * for each token in the Well.\\n     */\\n    event RemoveLiquidityOneToken(uint lpAmountIn, IERC20 tokenOut, uint tokenAmountOut, address recipient);\\n\\n    /**\\n     * @notice Emitted when a Shift occurs.\\n     * @param reserves The ending reserves after a shift\\n     * @param toToken The token swapped to\\n     * @param minAmountOut The minimum amount of `toToken` transferred out of the Well\\n     * @param recipient The address to receive `toToken`\\n     */\\n    event Shift(uint[] reserves, IERC20 toToken, uint minAmountOut, address recipient);\\n\\n    /**\\n     * @notice Emitted when a Sync occurs.\\n     * @param reserves The ending reserves after a sync\\n     */\\n    event Sync(uint[] reserves);\\n\\n    //////////////////// WELL DEFINITION ////////////////////\\n\\n    /**\\n     * @notice Returns a list of ERC20 tokens supported by the Well.\\n     */\\n    function tokens() external view returns (IERC20[] memory);\\n\\n    /**\\n     * @notice Returns the Well function as a Call struct.\\n     * @dev Contains the address of the Well function contract and extra data to\\n     * pass during calls.\\n     *\\n     * **Well functions** define a relationship between the reserves of the\\n     * tokens in the Well and the number of LP tokens.\\n     *\\n     * A Well function MUST implement {IWellFunction}.\\n     */\\n    function wellFunction() external view returns (Call memory);\\n\\n    /**\\n     * @notice Returns the Pumps attached to the Well as Call structs.\\n     * @dev Contains the addresses of the Pumps contract and extra data to pass\\n     * during calls.\\n     *\\n     * **Pumps** are on-chain oracles that are updated every time the Well is\\n     * interacted with.\\n     *\\n     * A Pump is not required for Well operation. For Wells without a Pump:\\n     * `pumps().length = 0`.\\n     *\\n     * An attached Pump MUST implement {IPump}.\\n     */\\n    function pumps() external view returns (Call[] memory);\\n\\n    /**\\n     * @notice Returns the Well data that the Well was bored with.\\n     * @dev The existence and signature of Well data is determined by each individual implementation.\\n     */\\n    function wellData() external view returns (bytes memory);\\n\\n    /**\\n     * @notice Returns the Aquifer that created this Well.\\n     * @dev Wells can be permissionlessly bored in an Aquifer.\\n     *\\n     * Aquifers stores the implementation that was used to bore the Well.\\n     */\\n    function aquifer() external view returns (address);\\n\\n    /**\\n     * @notice Returns the tokens, Well Function, Pumps and Well Data associated\\n     * with the Well as well as the Aquifer that deployed the Well.\\n     */\\n    function well()\\n        external\\n        view\\n        returns (\\n            IERC20[] memory _tokens,\\n            Call memory _wellFunction,\\n            Call[] memory _pumps,\\n            bytes memory _wellData,\\n            address _aquifer\\n        );\\n\\n    //////////////////// SWAP: FROM ////////////////////\\n\\n    /**\\n     * @notice Swaps from an exact amount of `fromToken` to a minimum amount of `toToken`.\\n     * @param fromToken The token to swap from\\n     * @param toToken The token to swap to\\n     * @param amountIn The amount of `fromToken` to spend\\n     * @param minAmountOut The minimum amount of `toToken` to receive\\n     * @param recipient The address to receive `toToken`\\n     * @param deadline The timestamp after which this operation is invalid\\n     * @return amountOut The amount of `toToken` received\\n     */\\n    function swapFrom(\\n        IERC20 fromToken,\\n        IERC20 toToken,\\n        uint amountIn,\\n        uint minAmountOut,\\n        address recipient,\\n        uint deadline\\n    ) external returns (uint amountOut);\\n\\n    /**\\n     * @notice Swaps from an exact amount of `fromToken` to a minimum amount of `toToken` and supports fee on transfer tokens.\\n     * @param fromToken The token to swap from\\n     * @param toToken The token to swap to\\n     * @param amountIn The amount of `fromToken` to spend\\n     * @param minAmountOut The minimum amount of `toToken` to take from the Well. Note that if `toToken` charges a fee on transfer, `recipient` will receive less than this amount.\\n     * @param recipient The address to receive `toToken`\\n     * @param deadline The timestamp after which this operation is invalid\\n     * @return amountOut The amount of `toToken` transferred from the Well. Note that if `toToken` charges a fee on transfer, `recipient` may receive less than this amount.\\n     * @dev Can also be used for tokens without a fee on transfer, but is less gas efficient.\\n     */\\n    function swapFromFeeOnTransfer(\\n        IERC20 fromToken,\\n        IERC20 toToken,\\n        uint amountIn,\\n        uint minAmountOut,\\n        address recipient,\\n        uint deadline\\n    ) external returns (uint amountOut);\\n\\n    /**\\n     * @notice Gets the amount of one token received for swapping an amount of another token.\\n     * @param fromToken The token to swap from\\n     * @param toToken The token to swap to\\n     * @param amountIn The amount of `fromToken` to spend\\n     * @return amountOut The amount of `toToken` to receive\\n     */\\n    function getSwapOut(IERC20 fromToken, IERC20 toToken, uint amountIn) external view returns (uint amountOut);\\n\\n    //////////////////// SWAP: TO ////////////////////\\n\\n    /**\\n     * @notice Swaps from a maximum amount of `fromToken` to an exact amount of `toToken`.\\n     * @param fromToken The token to swap from\\n     * @param toToken The token to swap to\\n     * @param maxAmountIn The maximum amount of `fromToken` to spend\\n     * @param amountOut The amount of `toToken` to receive\\n     * @param recipient The address to receive `toToken`\\n     * @param deadline The timestamp after which this operation is invalid\\n     * @return amountIn The amount of `toToken` received\\n     */\\n    function swapTo(\\n        IERC20 fromToken,\\n        IERC20 toToken,\\n        uint maxAmountIn,\\n        uint amountOut,\\n        address recipient,\\n        uint deadline\\n    ) external returns (uint amountIn);\\n\\n    /**\\n     * @notice Gets the amount of one token that must be spent to receive an amount of another token during a swap.\\n     * @param fromToken The token to swap from\\n     * @param toToken The token to swap to\\n     * @param amountOut The amount of `toToken` desired\\n     * @return amountIn The amount of `fromToken` that must be spent\\n     */\\n    function getSwapIn(IERC20 fromToken, IERC20 toToken, uint amountOut) external view returns (uint amountIn);\\n\\n    //////////////////// SHIFT ////////////////////\\n\\n    /**\\n     * @notice Shifts excess tokens held by the Well into `tokenOut` and delivers to `recipient`.\\n     * @param tokenOut The token to shift into\\n     * @param minAmountOut The minimum amount of `tokenOut` to receive\\n     * @param recipient The address to receive the token\\n     * @return amountOut The amount of `tokenOut` received\\n     * @dev Gas optimization: we leave the responsibility of checking a transaction\\n     * deadline to a wrapper contract like {Pipeline} to prevent repeated deadline\\n     * checks on each hop of a multi-step transaction.\\n     */\\n    function shift(IERC20 tokenOut, uint minAmountOut, address recipient) external returns (uint amountOut);\\n\\n    /**\\n     * @notice Calculates the amount of the token out received from shifting excess tokens held by the Well.\\n     * @param tokenOut The token to shift into\\n     * @return amountOut The amount of `tokenOut` received\\n     */\\n    function getShiftOut(IERC20 tokenOut) external returns (uint amountOut);\\n\\n    //////////////////// ADD LIQUIDITY ////////////////////\\n\\n    /**\\n     * @notice Adds liquidity to the Well as multiple tokens in any ratio.\\n     * @param tokenAmountsIn The amount of each token to add; MUST match the indexing of {Well.tokens}\\n     * @param minLpAmountOut The minimum amount of LP tokens to receive\\n     * @param recipient The address to receive the LP tokens\\n     * @param deadline The timestamp after which this operation is invalid\\n     * @return lpAmountOut The amount of LP tokens received\\n     */\\n    function addLiquidity(\\n        uint[] memory tokenAmountsIn,\\n        uint minLpAmountOut,\\n        address recipient,\\n        uint deadline\\n    ) external returns (uint lpAmountOut);\\n\\n    /**\\n     * @notice Adds liquidity to the Well as multiple tokens in any ratio and supports\\n     * fee on transfer tokens.\\n     * @param tokenAmountsIn The amount of each token to add; MUST match the indexing of {Well.tokens}\\n     * @param minLpAmountOut The minimum amount of LP tokens to receive\\n     * @param recipient The address to receive the LP tokens\\n     * @param deadline The timestamp after which this operation is invalid\\n     * @return lpAmountOut The amount of LP tokens received\\n     * @dev Can also be used for tokens without a fee on transfer, but is less gas efficient.\\n     */\\n    function addLiquidityFeeOnTransfer(\\n        uint[] memory tokenAmountsIn,\\n        uint minLpAmountOut,\\n        address recipient,\\n        uint deadline\\n    ) external returns (uint lpAmountOut);\\n\\n    /**\\n     * @notice Gets the amount of LP tokens received from adding liquidity as multiple tokens in any ratio.\\n     * @param tokenAmountsIn The amount of each token to add; MUST match the indexing of {Well.tokens}\\n     * @return lpAmountOut The amount of LP tokens to receive\\n     */\\n    function getAddLiquidityOut(uint[] memory tokenAmountsIn) external view returns (uint lpAmountOut);\\n\\n    //////////////////// REMOVE LIQUIDITY: BALANCED ////////////////////\\n\\n    /**\\n     * @notice Removes liquidity from the Well as all underlying tokens in a balanced ratio.\\n     * @param lpAmountIn The amount of LP tokens to burn\\n     * @param minTokenAmountsOut The minimum amount of each underlying token to receive; MUST match the indexing of {Well.tokens}\\n     * @param recipient The address to receive the underlying tokens\\n     * @param deadline The timestamp after which this operation is invalid\\n     * @return tokenAmountsOut The amount of each underlying token received\\n     */\\n    function removeLiquidity(\\n        uint lpAmountIn,\\n        uint[] calldata minTokenAmountsOut,\\n        address recipient,\\n        uint deadline\\n    ) external returns (uint[] memory tokenAmountsOut);\\n\\n    /**\\n     * @notice Gets the amount of each underlying token received from removing liquidity in a balanced ratio.\\n     * @param lpAmountIn The amount of LP tokens to burn\\n     * @return tokenAmountsOut The amount of each underlying token to receive\\n     */\\n    function getRemoveLiquidityOut(uint lpAmountIn) external view returns (uint[] memory tokenAmountsOut);\\n\\n    //////////////////// REMOVE LIQUIDITY: ONE TOKEN ////////////////////\\n\\n    /**\\n     * @notice Removes liquidity from the Well as a single underlying token.\\n     * @param lpAmountIn The amount of LP tokens to burn\\n     * @param tokenOut The underlying token to receive\\n     * @param minTokenAmountOut The minimum amount of `tokenOut` to receive\\n     * @param recipient The address to receive the underlying tokens\\n     * @param deadline The timestamp after which this operation is invalid\\n     * @return tokenAmountOut The amount of `tokenOut` received\\n     */\\n    function removeLiquidityOneToken(\\n        uint lpAmountIn,\\n        IERC20 tokenOut,\\n        uint minTokenAmountOut,\\n        address recipient,\\n        uint deadline\\n    ) external returns (uint tokenAmountOut);\\n\\n    /**\\n     * @notice Gets the amount received from removing liquidity from the Well as a single underlying token.\\n     * @param lpAmountIn The amount of LP tokens to burn\\n     * @param tokenOut The underlying token to receive\\n     * @return tokenAmountOut The amount of `tokenOut` to receive\\n     *\\n     */\\n    function getRemoveLiquidityOneTokenOut(\\n        uint lpAmountIn,\\n        IERC20 tokenOut\\n    ) external view returns (uint tokenAmountOut);\\n\\n    //////////////////// REMOVE LIQUIDITY: IMBALANCED ////////////////////\\n\\n    /**\\n     * @notice Removes liquidity from the Well as multiple underlying tokens in any ratio.\\n     * @param maxLpAmountIn The maximum amount of LP tokens to burn\\n     * @param tokenAmountsOut The amount of each underlying token to receive; MUST match the indexing of {Well.tokens}\\n     * @param recipient The address to receive the underlying tokens\\n     * @return lpAmountIn The amount of LP tokens burned\\n     */\\n    function removeLiquidityImbalanced(\\n        uint maxLpAmountIn,\\n        uint[] calldata tokenAmountsOut,\\n        address recipient,\\n        uint deadline\\n    ) external returns (uint lpAmountIn);\\n\\n    /**\\n     * @notice Gets the amount of LP tokens to burn from removing liquidity as multiple underlying tokens in any ratio.\\n     * @param tokenAmountsOut The amount of each underlying token to receive; MUST match the indexing of {Well.tokens}\\n     * @return lpAmountIn The amount of LP tokens to burn\\n     */\\n    function getRemoveLiquidityImbalancedIn(uint[] calldata tokenAmountsOut) external view returns (uint lpAmountIn);\\n\\n    //////////////////// RESERVES ////////////////////\\n\\n    /**\\n     * @notice Syncs the reserves of the Well with the Well's balances of underlying tokens.\\n     */\\n    function sync() external;\\n\\n    /**\\n     * @notice Sends excess tokens held by the Well to the `recipient`.\\n     * @param recipient The address to send the tokens\\n     * @return skimAmounts The amount of each token skimmed\\n     */\\n    function skim(address recipient) external returns (uint[] memory skimAmounts);\\n\\n    /**\\n     * @notice Gets the reserves of each token held by the Well.\\n     */\\n    function getReserves() external view returns (uint[] memory reserves);\\n}\"\r\n    },\r\n    \"lib/Beanstalk/IInstantaneousPump.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity =0.8.19;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title Instantaneous Pumps provide an Oracle for instantaneous reserves.\\n */\\ninterface IInstantaneousPump {\\n    /**\\n     * @notice Reads instantaneous reserves from the Pump\\n     * @param well The address of the Well\\n     * @return reserves The instantaneous balanecs tracked by the Pump\\n     */\\n    function readInstantaneousReserves(\\n        address well,\\n        bytes memory data\\n    ) external view returns (uint[] memory reserves);\\n}\"\r\n    },\r\n    \"lib/chainlink/AggregatorV2V3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(\\n    uint80 _roundId\\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n}\"\r\n    },\r\n    \"src/interfaces/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\n\\ninterface IOracle {\\n    /// @notice price used to open loans, typically a manipulation-resistant price.\\n    function getOpenPrice( bytes calldata parameters) external view returns (uint256 );\\n\\n    /// @notice price used to liquidate loans, typically spot price. \\n    function getClosePrice( bytes calldata parameters) external view returns (uint256 );\\n\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@forge-std/=lib/forge-std/src/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"@tractor/=lib/tractor/\",\r\n      \"@uni-v3-core/=lib/v3-core/contracts/\",\r\n      \"@uni-v3-periphery/=lib/v3-periphery/contracts/\",\r\n      \"@chainlink/=lib/chainlink/\",\r\n      \"@uniswap/=lib/\",\r\n      \"Beanstalk/=lib/Beanstalk/\",\r\n      \"chainlink/=lib/chainlink/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"tractor/=lib/tractor/\",\r\n      \"v2-periphery/=lib/v2-periphery/contracts/\",\r\n      \"v3-core/=lib/v3-core/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"parameters\",\"type\":\"bytes\"}],\"name\":\"getClosePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"parameters\",\"type\":\"bytes\"}],\"name\":\"getOpenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BeanOracle", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}