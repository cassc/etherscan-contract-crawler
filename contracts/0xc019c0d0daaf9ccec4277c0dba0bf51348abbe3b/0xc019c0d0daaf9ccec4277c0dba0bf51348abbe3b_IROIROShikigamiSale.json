{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Shikigami/IROIROShikigamiSale.sol\": {\r\n      \"content\": \"// Sources flattened with hardhat v2.16.1 https://hardhat.org\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n// File @openzeppelin/contracts/access/Ownable.sol@v4.9.2\\r\\n\\r\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the sender is not the owner.\\r\\n     */\\r\\n    function _checkOwner() internal view virtual {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby disabling any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n// File @openzeppelin/contracts/utils/introspection/IERC165.sol@v4.9.2\\r\\n\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC165 standard, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\r\\n *\\r\\n * Implementers can declare support of contract interfaces, which can then be\\r\\n * queried by others ({ERC165Checker}).\\r\\n *\\r\\n * For an implementation, see {ERC165}.\\r\\n */\\r\\ninterface IERC165 {\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30 000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\\r\\n\\r\\n// File @openzeppelin/contracts/interfaces/IERC2981.sol@v4.9.2\\r\\n\\r\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC2981.sol)\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Interface for the NFT Royalty Standard.\\r\\n *\\r\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\r\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\r\\n *\\r\\n * _Available since v4.5._\\r\\n */\\r\\ninterface IERC2981 is IERC165 {\\r\\n    /**\\r\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\r\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\r\\n     */\\r\\n    function royaltyInfo(\\r\\n        uint256 tokenId,\\r\\n        uint256 salePrice\\r\\n    ) external view returns (address receiver, uint256 royaltyAmount);\\r\\n}\\r\\n\\r\\n\\r\\n// File @openzeppelin/contracts/utils/introspection/ERC165.sol@v4.9.2\\r\\n\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC165} interface.\\r\\n *\\r\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\r\\n * for the additional interface id that will be supported. For example:\\r\\n *\\r\\n * ```solidity\\r\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\r\\n */\\r\\nabstract contract ERC165 is IERC165 {\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n        return interfaceId == type(IERC165).interfaceId;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n// File @openzeppelin/contracts/token/common/ERC2981.sol@v4.9.2\\r\\n\\r\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/common/ERC2981.sol)\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the NFT Royalty Standard, a standardized way to retrieve royalty payment information.\\r\\n *\\r\\n * Royalty information can be specified globally for all token ids via {_setDefaultRoyalty}, and/or individually for\\r\\n * specific token ids via {_setTokenRoyalty}. The latter takes precedence over the first.\\r\\n *\\r\\n * Royalty is specified as a fraction of sale price. {_feeDenominator} is overridable but defaults to 10000, meaning the\\r\\n * fee is specified in basis points by default.\\r\\n *\\r\\n * IMPORTANT: ERC-2981 only specifies a way to signal royalty information and does not enforce its payment. See\\r\\n * https://eips.ethereum.org/EIPS/eip-2981#optional-royalty-payments[Rationale] in the EIP. Marketplaces are expected to\\r\\n * voluntarily pay royalties together with sales, but note that this standard is not yet widely supported.\\r\\n *\\r\\n * _Available since v4.5._\\r\\n */\\r\\nabstract contract ERC2981 is IERC2981, ERC165 {\\r\\n    struct RoyaltyInfo {\\r\\n        address receiver;\\r\\n        uint96 royaltyFraction;\\r\\n    }\\r\\n\\r\\n    RoyaltyInfo private _defaultRoyaltyInfo;\\r\\n    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\\r\\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IERC2981\\r\\n     */\\r\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public view virtual override returns (address, uint256) {\\r\\n        RoyaltyInfo memory royalty = _tokenRoyaltyInfo[tokenId];\\r\\n\\r\\n        if (royalty.receiver == address(0)) {\\r\\n            royalty = _defaultRoyaltyInfo;\\r\\n        }\\r\\n\\r\\n        uint256 royaltyAmount = (salePrice * royalty.royaltyFraction) / _feeDenominator();\\r\\n\\r\\n        return (royalty.receiver, royaltyAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev The denominator with which to interpret the fee set in {_setTokenRoyalty} and {_setDefaultRoyalty} as a\\r\\n     * fraction of the sale price. Defaults to 10000 so fees are expressed in basis points, but may be customized by an\\r\\n     * override.\\r\\n     */\\r\\n    function _feeDenominator() internal pure virtual returns (uint96) {\\r\\n        return 10000;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the royalty information that all ids in this contract will default to.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `receiver` cannot be the zero address.\\r\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\r\\n     */\\r\\n    function _setDefaultRoyalty(address receiver, uint96 feeNumerator) internal virtual {\\r\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\r\\n        require(receiver != address(0), \\\"ERC2981: invalid receiver\\\");\\r\\n\\r\\n        _defaultRoyaltyInfo = RoyaltyInfo(receiver, feeNumerator);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes default royalty information.\\r\\n     */\\r\\n    function _deleteDefaultRoyalty() internal virtual {\\r\\n        delete _defaultRoyaltyInfo;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the royalty information for a specific token id, overriding the global default.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `receiver` cannot be the zero address.\\r\\n     * - `feeNumerator` cannot be greater than the fee denominator.\\r\\n     */\\r\\n    function _setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) internal virtual {\\r\\n        require(feeNumerator <= _feeDenominator(), \\\"ERC2981: royalty fee will exceed salePrice\\\");\\r\\n        require(receiver != address(0), \\\"ERC2981: Invalid parameters\\\");\\r\\n\\r\\n        _tokenRoyaltyInfo[tokenId] = RoyaltyInfo(receiver, feeNumerator);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Resets royalty information for the token id back to the global default.\\r\\n     */\\r\\n    function _resetTokenRoyalty(uint256 tokenId) internal virtual {\\r\\n        delete _tokenRoyaltyInfo[tokenId];\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n// File @openzeppelin/contracts/token/ERC1155/IERC1155.sol@v4.9.2\\r\\n\\r\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\r\\n *\\r\\n * _Available since v3.1._\\r\\n */\\r\\ninterface IERC1155 is IERC165 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\r\\n     */\\r\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\r\\n     * transfers.\\r\\n     */\\r\\n    event TransferBatch(\\r\\n        address indexed operator,\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256[] ids,\\r\\n        uint256[] values\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\r\\n     * `approved`.\\r\\n     */\\r\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\r\\n     *\\r\\n     * If an {URI} event was emitted for `id`, the standard\\r\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\r\\n     * returned by {IERC1155MetadataURI-uri}.\\r\\n     */\\r\\n    event URI(string value, uint256 indexed id);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `accounts` and `ids` must have the same length.\\r\\n     */\\r\\n    function balanceOfBatch(\\r\\n        address[] calldata accounts,\\r\\n        uint256[] calldata ids\\r\\n    ) external view returns (uint256[] memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `operator` cannot be the caller.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\r\\n     *\\r\\n     * See {setApprovalForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\r\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\r\\n     *\\r\\n     * Emits a {TransferBatch} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `ids` and `amounts` must have the same length.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata amounts,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n}\\r\\n\\r\\n\\r\\n// File @openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol@v4.9.2\\r\\n\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\r\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\r\\n *\\r\\n * _Available since v3.1._\\r\\n */\\r\\ninterface IERC1155MetadataURI is IERC1155 {\\r\\n    /**\\r\\n     * @dev Returns the URI for token type `id`.\\r\\n     *\\r\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\r\\n     * clients with the actual token type ID.\\r\\n     */\\r\\n    function uri(uint256 id) external view returns (string memory);\\r\\n}\\r\\n\\r\\n\\r\\n// File @openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol@v4.9.2\\r\\n\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev _Available since v3.1._\\r\\n */\\r\\ninterface IERC1155Receiver is IERC165 {\\r\\n    /**\\r\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\r\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\r\\n     *\\r\\n     * NOTE: To accept the transfer, this must return\\r\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\r\\n     * (i.e. 0xf23a6e61, or its own function selector).\\r\\n     *\\r\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\r\\n     * @param from The address which previously owned the token\\r\\n     * @param id The ID of the token being transferred\\r\\n     * @param value The amount of tokens being transferred\\r\\n     * @param data Additional data with no specified format\\r\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\r\\n     */\\r\\n    function onERC1155Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 id,\\r\\n        uint256 value,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n\\r\\n    /**\\r\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\r\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\r\\n     * been updated.\\r\\n     *\\r\\n     * NOTE: To accept the transfer(s), this must return\\r\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\r\\n     * (i.e. 0xbc197c81, or its own function selector).\\r\\n     *\\r\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\r\\n     * @param from The address which previously owned the token\\r\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\r\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\r\\n     * @param data Additional data with no specified format\\r\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\r\\n     */\\r\\n    function onERC1155BatchReceived(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata values,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n}\\r\\n\\r\\n\\r\\n// File @openzeppelin/contracts/utils/Address.sol@v4.9.2\\r\\n\\r\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     *\\r\\n     * Furthermore, `isContract` will also return true if the target contract within\\r\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\r\\n     * which only has an effect at the end of a transaction.\\r\\n     * ====\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\r\\n     *\\r\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\r\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\r\\n     * constructor.\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize/address.code.length, which returns 0\\r\\n        // for contracts in construction, since the code is only stored at the end\\r\\n        // of the constructor execution.\\r\\n\\r\\n        return account.code.length > 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain `call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\r\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\r\\n     *\\r\\n     * _Available since v4.8._\\r\\n     */\\r\\n    function verifyCallResultFromTarget(\\r\\n        address target,\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        if (success) {\\r\\n            if (returndata.length == 0) {\\r\\n                // only check isContract if the call was successful and the return data is empty\\r\\n                // otherwise we already know that it was a contract\\r\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n            }\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\r\\n     * revert reason or using the provided one.\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            _revert(returndata, errorMessage);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\r\\n        // Look for revert reason and bubble it up if present\\r\\n        if (returndata.length > 0) {\\r\\n            // The easiest way to bubble the revert reason is using memory via assembly\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                let returndata_size := mload(returndata)\\r\\n                revert(add(32, returndata), returndata_size)\\r\\n            }\\r\\n        } else {\\r\\n            revert(errorMessage);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n// File @openzeppelin/contracts/token/ERC1155/ERC1155.sol@v4.9.2\\r\\n\\r\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/ERC1155.sol)\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the basic standard multi-token.\\r\\n * See https://eips.ethereum.org/EIPS/eip-1155\\r\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\r\\n *\\r\\n * _Available since v3.1._\\r\\n */\\r\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\r\\n    using Address for address;\\r\\n\\r\\n    // Mapping from token ID to account balances\\r\\n    mapping(uint256 => mapping(address => uint256)) private _balances;\\r\\n\\r\\n    // Mapping from account to operator approvals\\r\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\r\\n\\r\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\r\\n    string private _uri;\\r\\n\\r\\n    /**\\r\\n     * @dev See {_setURI}.\\r\\n     */\\r\\n    constructor(string memory uri_) {\\r\\n        _setURI(uri_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\r\\n        return\\r\\n            interfaceId == type(IERC1155).interfaceId ||\\r\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\r\\n            super.supportsInterface(interfaceId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155MetadataURI-uri}.\\r\\n     *\\r\\n     * This implementation returns the same URI for *all* token types. It relies\\r\\n     * on the token type ID substitution mechanism\\r\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\r\\n     *\\r\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\r\\n     * actual token type ID.\\r\\n     */\\r\\n    function uri(uint256) public view virtual override returns (string memory) {\\r\\n        return _uri;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-balanceOf}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\r\\n        require(account != address(0), \\\"ERC1155: address zero is not a valid owner\\\");\\r\\n        return _balances[id][account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-balanceOfBatch}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `accounts` and `ids` must have the same length.\\r\\n     */\\r\\n    function balanceOfBatch(\\r\\n        address[] memory accounts,\\r\\n        uint256[] memory ids\\r\\n    ) public view virtual override returns (uint256[] memory) {\\r\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\r\\n\\r\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\r\\n\\r\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\r\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\r\\n        }\\r\\n\\r\\n        return batchBalances;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-setApprovalForAll}.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\r\\n        _setApprovalForAll(_msgSender(), operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-isApprovedForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\r\\n        return _operatorApprovals[account][operator];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-safeTransferFrom}.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    ) public virtual override {\\r\\n        require(\\r\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\r\\n            \\\"ERC1155: caller is not token owner or approved\\\"\\r\\n        );\\r\\n        _safeTransferFrom(from, to, id, amount, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\r\\n     */\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) public virtual override {\\r\\n        require(\\r\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\r\\n            \\\"ERC1155: caller is not token owner or approved\\\"\\r\\n        );\\r\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function _safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    ) internal virtual {\\r\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\r\\n\\r\\n        address operator = _msgSender();\\r\\n        uint256[] memory ids = _asSingletonArray(id);\\r\\n        uint256[] memory amounts = _asSingletonArray(amount);\\r\\n\\r\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\r\\n\\r\\n        uint256 fromBalance = _balances[id][from];\\r\\n        require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\r\\n        unchecked {\\r\\n            _balances[id][from] = fromBalance - amount;\\r\\n        }\\r\\n        _balances[id][to] += amount;\\r\\n\\r\\n        emit TransferSingle(operator, from, to, id, amount);\\r\\n\\r\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\r\\n\\r\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\r\\n     *\\r\\n     * Emits a {TransferBatch} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function _safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) internal virtual {\\r\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\r\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\r\\n\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\r\\n\\r\\n        for (uint256 i = 0; i < ids.length; ++i) {\\r\\n            uint256 id = ids[i];\\r\\n            uint256 amount = amounts[i];\\r\\n\\r\\n            uint256 fromBalance = _balances[id][from];\\r\\n            require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\r\\n            unchecked {\\r\\n                _balances[id][from] = fromBalance - amount;\\r\\n            }\\r\\n            _balances[id][to] += amount;\\r\\n        }\\r\\n\\r\\n        emit TransferBatch(operator, from, to, ids, amounts);\\r\\n\\r\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\r\\n\\r\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\r\\n     * substitution mechanism\\r\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\r\\n     *\\r\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\r\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\r\\n     * clients with the token type ID.\\r\\n     *\\r\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\r\\n     * interpreted by clients as\\r\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\r\\n     * for token type ID 0x4cce0.\\r\\n     *\\r\\n     * See {uri}.\\r\\n     *\\r\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\r\\n     * this function emits no events.\\r\\n     */\\r\\n    function _setURI(string memory newuri) internal virtual {\\r\\n        _uri = newuri;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\\r\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\r\\n\\r\\n        address operator = _msgSender();\\r\\n        uint256[] memory ids = _asSingletonArray(id);\\r\\n        uint256[] memory amounts = _asSingletonArray(amount);\\r\\n\\r\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\r\\n\\r\\n        _balances[id][to] += amount;\\r\\n        emit TransferSingle(operator, address(0), to, id, amount);\\r\\n\\r\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\r\\n\\r\\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\r\\n     *\\r\\n     * Emits a {TransferBatch} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `ids` and `amounts` must have the same length.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function _mintBatch(\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) internal virtual {\\r\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\r\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\r\\n\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\r\\n\\r\\n        for (uint256 i = 0; i < ids.length; i++) {\\r\\n            _balances[ids[i]][to] += amounts[i];\\r\\n        }\\r\\n\\r\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\r\\n\\r\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\r\\n\\r\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens of token type `id` from `from`\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `from` must have at least `amount` tokens of token type `id`.\\r\\n     */\\r\\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\\r\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\r\\n\\r\\n        address operator = _msgSender();\\r\\n        uint256[] memory ids = _asSingletonArray(id);\\r\\n        uint256[] memory amounts = _asSingletonArray(amount);\\r\\n\\r\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\r\\n\\r\\n        uint256 fromBalance = _balances[id][from];\\r\\n        require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\r\\n        unchecked {\\r\\n            _balances[id][from] = fromBalance - amount;\\r\\n        }\\r\\n\\r\\n        emit TransferSingle(operator, from, address(0), id, amount);\\r\\n\\r\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\r\\n     *\\r\\n     * Emits a {TransferBatch} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `ids` and `amounts` must have the same length.\\r\\n     */\\r\\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory amounts) internal virtual {\\r\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\r\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\r\\n\\r\\n        address operator = _msgSender();\\r\\n\\r\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\r\\n\\r\\n        for (uint256 i = 0; i < ids.length; i++) {\\r\\n            uint256 id = ids[i];\\r\\n            uint256 amount = amounts[i];\\r\\n\\r\\n            uint256 fromBalance = _balances[id][from];\\r\\n            require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\r\\n            unchecked {\\r\\n                _balances[id][from] = fromBalance - amount;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit TransferBatch(operator, from, address(0), ids, amounts);\\r\\n\\r\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     */\\r\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\r\\n        require(owner != operator, \\\"ERC1155: setting approval status for self\\\");\\r\\n        _operatorApprovals[owner][operator] = approved;\\r\\n        emit ApprovalForAll(owner, operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any token transfer. This includes minting\\r\\n     * and burning, as well as batched variants.\\r\\n     *\\r\\n     * The same hook is called on both single and batched variants. For single\\r\\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\\r\\n     *\\r\\n     * Calling conditions (for each `id` and `amount` pair):\\r\\n     *\\r\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * of token type `id` will be  transferred to `to`.\\r\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\r\\n     * for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\r\\n     * will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     * - `ids` and `amounts` have the same, non-zero length.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) internal virtual {}\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called after any token transfer. This includes minting\\r\\n     * and burning, as well as batched variants.\\r\\n     *\\r\\n     * The same hook is called on both single and batched variants. For single\\r\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\r\\n     *\\r\\n     * Calling conditions (for each `id` and `amount` pair):\\r\\n     *\\r\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\r\\n     * of token type `id` will be  transferred to `to`.\\r\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\r\\n     * for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\r\\n     * will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     * - `ids` and `amounts` have the same, non-zero length.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _afterTokenTransfer(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) internal virtual {}\\r\\n\\r\\n    function _doSafeTransferAcceptanceCheck(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    ) private {\\r\\n        if (to.isContract()) {\\r\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\r\\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\\r\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\r\\n                }\\r\\n            } catch Error(string memory reason) {\\r\\n                revert(reason);\\r\\n            } catch {\\r\\n                revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _doSafeBatchTransferAcceptanceCheck(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) private {\\r\\n        if (to.isContract()) {\\r\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\r\\n                bytes4 response\\r\\n            ) {\\r\\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\\r\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\r\\n                }\\r\\n            } catch Error(string memory reason) {\\r\\n                revert(reason);\\r\\n            } catch {\\r\\n                revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\r\\n        uint256[] memory array = new uint256[](1);\\r\\n        array[0] = element;\\r\\n\\r\\n        return array;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n// File @openzeppelin/contracts/utils/math/Math.sol@v4.9.2\\r\\n\\r\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Standard math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary Math {\\r\\n    enum Rounding {\\r\\n        Down, // Toward negative infinity\\r\\n        Up, // Toward infinity\\r\\n        Zero // Toward zero\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a > b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a < b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow.\\r\\n        return (a & b) + (a ^ b) / 2;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the ceiling of the division of two numbers.\\r\\n     *\\r\\n     * This differs from standard division with `/` in that it rounds up instead\\r\\n     * of rounding down.\\r\\n     */\\r\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\r\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\r\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\r\\n     * with further edits by Uniswap Labs also under MIT license.\\r\\n     */\\r\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\r\\n        unchecked {\\r\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\r\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\r\\n            // variables such that product = prod1 * 2^256 + prod0.\\r\\n            uint256 prod0; // Least significant 256 bits of the product\\r\\n            uint256 prod1; // Most significant 256 bits of the product\\r\\n            assembly {\\r\\n                let mm := mulmod(x, y, not(0))\\r\\n                prod0 := mul(x, y)\\r\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n            }\\r\\n\\r\\n            // Handle non-overflow cases, 256 by 256 division.\\r\\n            if (prod1 == 0) {\\r\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\r\\n                // The surrounding unchecked block does not change this fact.\\r\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\r\\n                return prod0 / denominator;\\r\\n            }\\r\\n\\r\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\r\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\r\\n\\r\\n            ///////////////////////////////////////////////\\r\\n            // 512 by 256 division.\\r\\n            ///////////////////////////////////////////////\\r\\n\\r\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\r\\n            uint256 remainder;\\r\\n            assembly {\\r\\n                // Compute remainder using mulmod.\\r\\n                remainder := mulmod(x, y, denominator)\\r\\n\\r\\n                // Subtract 256 bit number from 512 bit number.\\r\\n                prod1 := sub(prod1, gt(remainder, prod0))\\r\\n                prod0 := sub(prod0, remainder)\\r\\n            }\\r\\n\\r\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\r\\n            // See https://cs.stackexchange.com/q/138556/92363.\\r\\n\\r\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\r\\n            uint256 twos = denominator & (~denominator + 1);\\r\\n            assembly {\\r\\n                // Divide denominator by twos.\\r\\n                denominator := div(denominator, twos)\\r\\n\\r\\n                // Divide [prod1 prod0] by twos.\\r\\n                prod0 := div(prod0, twos)\\r\\n\\r\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\r\\n                twos := add(div(sub(0, twos), twos), 1)\\r\\n            }\\r\\n\\r\\n            // Shift in bits from prod1 into prod0.\\r\\n            prod0 |= prod1 * twos;\\r\\n\\r\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\r\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\r\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\r\\n            uint256 inverse = (3 * denominator) ^ 2;\\r\\n\\r\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\r\\n            // in modular arithmetic, doubling the correct bits in each step.\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\r\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\r\\n\\r\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\r\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\r\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\r\\n            // is no longer required.\\r\\n            result = prod0 * inverse;\\r\\n            return result;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\r\\n     */\\r\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\r\\n        uint256 result = mulDiv(x, y, denominator);\\r\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\r\\n            result += 1;\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\r\\n     *\\r\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\r\\n     */\\r\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\r\\n        //\\r\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\r\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\r\\n        //\\r\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\r\\n        // \u0393\u00e5\u00c6 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\r\\n        // \u0393\u00e5\u00c6 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\r\\n        //\\r\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\r\\n        uint256 result = 1 << (log2(a) >> 1);\\r\\n\\r\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\r\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\r\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\r\\n        // into the expected uint128 result.\\r\\n        unchecked {\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            result = (result + a / result) >> 1;\\r\\n            return min(result, a / result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\r\\n     */\\r\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = sqrt(a);\\r\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log2(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value >> 128 > 0) {\\r\\n                value >>= 128;\\r\\n                result += 128;\\r\\n            }\\r\\n            if (value >> 64 > 0) {\\r\\n                value >>= 64;\\r\\n                result += 64;\\r\\n            }\\r\\n            if (value >> 32 > 0) {\\r\\n                value >>= 32;\\r\\n                result += 32;\\r\\n            }\\r\\n            if (value >> 16 > 0) {\\r\\n                value >>= 16;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value >> 8 > 0) {\\r\\n                value >>= 8;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value >> 4 > 0) {\\r\\n                value >>= 4;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value >> 2 > 0) {\\r\\n                value >>= 2;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value >> 1 > 0) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log2(value);\\r\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log10(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value >= 10 ** 64) {\\r\\n                value /= 10 ** 64;\\r\\n                result += 64;\\r\\n            }\\r\\n            if (value >= 10 ** 32) {\\r\\n                value /= 10 ** 32;\\r\\n                result += 32;\\r\\n            }\\r\\n            if (value >= 10 ** 16) {\\r\\n                value /= 10 ** 16;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value >= 10 ** 8) {\\r\\n                value /= 10 ** 8;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value >= 10 ** 4) {\\r\\n                value /= 10 ** 4;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value >= 10 ** 2) {\\r\\n                value /= 10 ** 2;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value >= 10 ** 1) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log10(value);\\r\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     *\\r\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\r\\n     */\\r\\n    function log256(uint256 value) internal pure returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n        unchecked {\\r\\n            if (value >> 128 > 0) {\\r\\n                value >>= 128;\\r\\n                result += 16;\\r\\n            }\\r\\n            if (value >> 64 > 0) {\\r\\n                value >>= 64;\\r\\n                result += 8;\\r\\n            }\\r\\n            if (value >> 32 > 0) {\\r\\n                value >>= 32;\\r\\n                result += 4;\\r\\n            }\\r\\n            if (value >> 16 > 0) {\\r\\n                value >>= 16;\\r\\n                result += 2;\\r\\n            }\\r\\n            if (value >> 8 > 0) {\\r\\n                result += 1;\\r\\n            }\\r\\n        }\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\r\\n     * Returns 0 if given 0.\\r\\n     */\\r\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            uint256 result = log256(value);\\r\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n// File @openzeppelin/contracts/utils/math/SignedMath.sol@v4.9.2\\r\\n\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Standard signed math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary SignedMath {\\r\\n    /**\\r\\n     * @dev Returns the largest of two signed numbers.\\r\\n     */\\r\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\r\\n        return a > b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two signed numbers.\\r\\n     */\\r\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\r\\n        return a < b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two signed numbers without overflow.\\r\\n     * The result is rounded towards zero.\\r\\n     */\\r\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\r\\n        // Formula from the book \\\"Hacker's Delight\\\"\\r\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\r\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the absolute unsigned value of a signed value.\\r\\n     */\\r\\n    function abs(int256 n) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            // must be unchecked in order to support `n = type(int256).min`\\r\\n            return uint256(n >= 0 ? n : -n);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n// File @openzeppelin/contracts/utils/Strings.sol@v4.9.2\\r\\n\\r\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev String operations.\\r\\n */\\r\\nlibrary Strings {\\r\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\r\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\r\\n     */\\r\\n    function toString(uint256 value) internal pure returns (string memory) {\\r\\n        unchecked {\\r\\n            uint256 length = Math.log10(value) + 1;\\r\\n            string memory buffer = new string(length);\\r\\n            uint256 ptr;\\r\\n            /// @solidity memory-safe-assembly\\r\\n            assembly {\\r\\n                ptr := add(buffer, add(32, length))\\r\\n            }\\r\\n            while (true) {\\r\\n                ptr--;\\r\\n                /// @solidity memory-safe-assembly\\r\\n                assembly {\\r\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\r\\n                }\\r\\n                value /= 10;\\r\\n                if (value == 0) break;\\r\\n            }\\r\\n            return buffer;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\r\\n     */\\r\\n    function toString(int256 value) internal pure returns (string memory) {\\r\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\r\\n     */\\r\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\r\\n        unchecked {\\r\\n            return toHexString(value, Math.log256(value) + 1);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\r\\n     */\\r\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\r\\n        bytes memory buffer = new bytes(2 * length + 2);\\r\\n        buffer[0] = \\\"0\\\";\\r\\n        buffer[1] = \\\"x\\\";\\r\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\r\\n            buffer[i] = _SYMBOLS[value & 0xf];\\r\\n            value >>= 4;\\r\\n        }\\r\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\r\\n        return string(buffer);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\r\\n     */\\r\\n    function toHexString(address addr) internal pure returns (string memory) {\\r\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the two strings are equal.\\r\\n     */\\r\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\r\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n// File operator-filter-registry/src/IOperatorFilterRegistry.sol@v1.4.2\\r\\n\\r\\n\\r\\ninterface IOperatorFilterRegistry {\\r\\n    /**\\r\\n     * @notice Returns true if operator is not filtered for a given token, either by address or codeHash. Also returns\\r\\n     *         true if supplied registrant address is not registered.\\r\\n     */\\r\\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Registers an address with the registry. May be called by address itself or by EIP-173 owner.\\r\\n     */\\r\\n    function register(address registrant) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Registers an address with the registry and \\\"subscribes\\\" to another address's filtered operators and codeHashes.\\r\\n     */\\r\\n    function registerAndSubscribe(address registrant, address subscription) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Registers an address with the registry and copies the filtered operators and codeHashes from another\\r\\n     *         address without subscribing.\\r\\n     */\\r\\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Unregisters an address with the registry and removes its subscription. May be called by address itself or by EIP-173 owner.\\r\\n     *         Note that this does not remove any filtered addresses or codeHashes.\\r\\n     *         Also note that any subscriptions to this registrant will still be active and follow the existing filtered addresses and codehashes.\\r\\n     */\\r\\n    function unregister(address addr) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Update an operator address for a registered address - when filtered is true, the operator is filtered.\\r\\n     */\\r\\n    function updateOperator(address registrant, address operator, bool filtered) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Update multiple operators for a registered address - when filtered is true, the operators will be filtered. Reverts on duplicates.\\r\\n     */\\r\\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Update a codeHash for a registered address - when filtered is true, the codeHash is filtered.\\r\\n     */\\r\\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Update multiple codeHashes for a registered address - when filtered is true, the codeHashes will be filtered. Reverts on duplicates.\\r\\n     */\\r\\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Subscribe an address to another registrant's filtered operators and codeHashes. Will remove previous\\r\\n     *         subscription if present.\\r\\n     *         Note that accounts with subscriptions may go on to subscribe to other accounts - in this case,\\r\\n     *         subscriptions will not be forwarded. Instead the former subscription's existing entries will still be\\r\\n     *         used.\\r\\n     */\\r\\n    function subscribe(address registrant, address registrantToSubscribe) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Unsubscribe an address from its current subscribed registrant, and optionally copy its filtered operators and codeHashes.\\r\\n     */\\r\\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Get the subscription address of a given registrant, if any.\\r\\n     */\\r\\n    function subscriptionOf(address addr) external returns (address registrant);\\r\\n\\r\\n    /**\\r\\n     * @notice Get the set of addresses subscribed to a given registrant.\\r\\n     *         Note that order is not guaranteed as updates are made.\\r\\n     */\\r\\n    function subscribers(address registrant) external returns (address[] memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Get the subscriber at a given index in the set of addresses subscribed to a given registrant.\\r\\n     *         Note that order is not guaranteed as updates are made.\\r\\n     */\\r\\n    function subscriberAt(address registrant, uint256 index) external returns (address);\\r\\n\\r\\n    /**\\r\\n     * @notice Copy filtered operators and codeHashes from a different registrantToCopy to addr.\\r\\n     */\\r\\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if operator is filtered by a given address or its subscription.\\r\\n     */\\r\\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if the hash of an address's code is filtered by a given address or its subscription.\\r\\n     */\\r\\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if a codeHash is filtered by a given address or its subscription.\\r\\n     */\\r\\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns a list of filtered operators for a given address or its subscription.\\r\\n     */\\r\\n    function filteredOperators(address addr) external returns (address[] memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the set of filtered codeHashes for a given address or its subscription.\\r\\n     *         Note that order is not guaranteed as updates are made.\\r\\n     */\\r\\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the filtered operator at the given index of the set of filtered operators for a given address or\\r\\n     *         its subscription.\\r\\n     *         Note that order is not guaranteed as updates are made.\\r\\n     */\\r\\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the filtered codeHash at the given index of the list of filtered codeHashes for a given address or\\r\\n     *         its subscription.\\r\\n     *         Note that order is not guaranteed as updates are made.\\r\\n     */\\r\\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if an address has registered\\r\\n     */\\r\\n    function isRegistered(address addr) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Convenience method to compute the code hash of an arbitrary contract\\r\\n     */\\r\\n    function codeHashOf(address addr) external returns (bytes32);\\r\\n}\\r\\n\\r\\n\\r\\n// File contracts/IROIROShikigami.sol\\r\\n\\r\\n// Sources flattened with hardhat v2.16.1 https://hardhat.org\\r\\n\\r\\n// File @openzeppelin/contracts/utils/Context.sol@v4.9.2\\r\\n\\r\\nabstract contract UpdatableOperatorFilterer {\\r\\n    address private _owner;\\r\\n    /// @dev Emitted when an operator is not allowed.\\r\\n    error OperatorNotAllowed(address operator);\\r\\n    /// @dev Emitted when someone other than the owner is trying to call an only owner function.\\r\\n    error OnlyOwner();\\r\\n\\r\\n    event OperatorFilterRegistryAddressUpdated(address newRegistry);\\r\\n\\r\\n    IOperatorFilterRegistry public operatorFilterRegistry;\\r\\n\\r\\n    /// @dev The constructor that is called when the contract is being deployed.\\r\\n    constructor(address _registry, address subscriptionOrRegistrantToCopy, bool subscribe) {\\r\\n        _owner = msg.sender;\\r\\n        IOperatorFilterRegistry registry = IOperatorFilterRegistry(_registry);\\r\\n        operatorFilterRegistry = registry;\\r\\n        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier\\r\\n        // will not revert, but the contract will need to be registered with the registry once it is deployed in\\r\\n        // order for the modifier to filter addresses.\\r\\n        if (address(registry).code.length > 0) {\\r\\n            if (subscribe) {\\r\\n                registry.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);\\r\\n            } else {\\r\\n                if (subscriptionOrRegistrantToCopy != address(0)) {\\r\\n                    registry.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);\\r\\n                } else {\\r\\n                    registry.register(address(this));\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev A helper function to check if the operator is allowed.\\r\\n     */\\r\\n    modifier onlyAllowedOperator(address from) virtual {\\r\\n        // Allow spending tokens from addresses with balance\\r\\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\\r\\n        // from an EOA.\\r\\n        if (from != msg.sender) {\\r\\n            _checkFilterOperator(msg.sender);\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev A helper function to check if the operator approval is allowed.\\r\\n     */\\r\\n    modifier onlyAllowedOperatorApproval(address operator) virtual {\\r\\n        _checkFilterOperator(operator);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function transferOwnershipRegister(address newOwner) public virtual {\\r\\n        require(msg.sender == _owner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Update the address that the contract will make OperatorFilter checks against. When set to the zero\\r\\n     *         address, checks will be bypassed. OnlyOwner.\\r\\n     */\\r\\n    function updateOperatorFilterRegistryAddress(address newRegistry) public virtual {\\r\\n        if (msg.sender != returnOwnerRegister()) {\\r\\n            revert OnlyOwner();\\r\\n        }\\r\\n        operatorFilterRegistry = IOperatorFilterRegistry(newRegistry);\\r\\n        emit OperatorFilterRegistryAddressUpdated(newRegistry);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Assume the contract has an owner, but leave specific Ownable implementation up to inheriting contract.\\r\\n     */\\r\\n    function returnOwnerRegister() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev A helper function to check if the operator is allowed.\\r\\n     */\\r\\n    function _checkFilterOperator(address operator) internal view virtual {\\r\\n        IOperatorFilterRegistry registry = operatorFilterRegistry;\\r\\n        // Check registry code length to facilitate testing in environments without a deployed registry.\\r\\n        if (address(registry) != address(0) && address(registry).code.length > 0) {\\r\\n            // under normal circumstances, this function will revert rather than return false, but inheriting contracts\\r\\n            // may specify their own OperatorFilterRegistry implementations, which may behave differently\\r\\n            if (!registry.isOperatorAllowed(address(this), operator)) {\\r\\n                revert OperatorNotAllowed(operator);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/extensions/ERC1155Supply.sol)\\r\\n/**\\r\\n * @dev Extension of ERC1155 that adds tracking of total supply per id.\\r\\n *\\r\\n * Useful for scenarios where Fungible and Non-fungible tokens have to be\\r\\n * clearly identified. Note: While a totalSupply of 1 might mean the\\r\\n * corresponding is an NFT, there is no guarantees that no other token with the\\r\\n * same id are not going to be minted.\\r\\n */\\r\\nabstract contract ERC1155Custom is ERC1155 {\\r\\n    using Strings for uint256;\\r\\n\\r\\n    // Optional base URI\\r\\n    string private _baseURI = \\\"\\\";\\r\\n\\r\\n    // Optional mapping for token URIs\\r\\n    mapping(uint256 => string) private _tokenURIs;\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC1155MetadataURI-uri}.\\r\\n     *\\r\\n     * This implementation returns the concatenation of the `_baseURI`\\r\\n     * and the token-specific uri if the latter is set\\r\\n     *\\r\\n     * This enables the following behaviors:\\r\\n     *\\r\\n     * - if `_tokenURIs[tokenId]` is set, then the result is the concatenation\\r\\n     *   of `_baseURI` and `_tokenURIs[tokenId]` (keep in mind that `_baseURI`\\r\\n     *   is empty per default);\\r\\n     *\\r\\n     * - if `_tokenURIs[tokenId]` is NOT set then we fallback to `super.uri()`\\r\\n     *   which in most cases will contain `ERC1155._uri`;\\r\\n     *\\r\\n     * - if `_tokenURIs[tokenId]` is NOT set, and if the parents do not have a\\r\\n     *   uri value set, then the result is empty.\\r\\n     */\\r\\n    function uri(uint256 tokenId) public view virtual override returns (string memory) {\\r\\n        string memory tokenURI = _tokenURIs[tokenId];\\r\\n\\r\\n        // If token URI is set, concatenate base URI and tokenURI (via abi.encodePacked).\\r\\n        return bytes(tokenURI).length > 0 ? string(abi.encodePacked(_baseURI, tokenURI)) : super.uri(tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `tokenURI` as the tokenURI of `tokenId`.\\r\\n     */\\r\\n    function _setURI(uint256 tokenId, string memory tokenURI) internal virtual {\\r\\n        _tokenURIs[tokenId] = tokenURI;\\r\\n        emit URI(uri(tokenId), tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `baseURI` as the `_baseURI` for all tokens\\r\\n     */\\r\\n    function _setBaseURI(string memory baseURI) internal virtual {\\r\\n        _baseURI = baseURI;\\r\\n    }\\r\\n\\r\\n    mapping(uint256 => uint256) private _totalSupply;\\r\\n\\r\\n    /**\\r\\n     * @dev Total amount of tokens in with a given id.\\r\\n     */\\r\\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\\r\\n        return _totalSupply[id];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates whether any token exist with a given id, or not.\\r\\n     */\\r\\n    function exists(uint256 id) public view virtual returns (bool) {\\r\\n        return ERC1155Custom.totalSupply(id) > 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {ERC1155-_beforeTokenTransfer}.\\r\\n     */\\r\\n    function _beforeTokenTransfer(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) internal virtual override {\\r\\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\\r\\n\\r\\n        if (from == address(0)) {\\r\\n            for (uint256 i = 0; i < ids.length; ++i) {\\r\\n                _totalSupply[ids[i]] += amounts[i];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (to == address(0)) {\\r\\n            for (uint256 i = 0; i < ids.length; ++i) {\\r\\n                uint256 id = ids[i];\\r\\n                uint256 amount = amounts[i];\\r\\n                uint256 supply = _totalSupply[id];\\r\\n                require(supply >= amount, \\\"ERC1155: burn amount exceeds totalSupply\\\");\\r\\n                unchecked {\\r\\n                    _totalSupply[id] = supply - amount;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract IROIROShikigami is Ownable, ERC1155Custom, ERC2981, UpdatableOperatorFilterer {\\r\\n\\r\\n    // *Important* \\r\\n    // IROIROShikigami contract should be deployed FIRST, before minter and burner!\\r\\n\\r\\n    //--------------------------------------------------------\\r\\n    // Storage\\r\\n    //--------------------------------------------------------\\r\\n    \\r\\n    using Strings for uint256;\\r\\n\\r\\n    // Royalty\\r\\n    uint96 constant private ROYALTY_FEE_NUMERATOR = 500;    // 500/10000 = 5%\\r\\n\\r\\n    address public minterContract; // Shikigami Sale contract\\r\\n    address public burnerContract; // IROIRORemix contract\\r\\n    address public managerAddress; // Contract manager\\r\\n\\r\\n    address private constant ADDRESS_ZERO = 0x0000000000000000000000000000000000000000; // Check for 0 address\\r\\n    // ShikigamiId => Shikigami struct\\r\\n    mapping (uint256 => uint256) public shikigamiChoices; // Shikigami ID => Choices\\r\\n    mapping (uint256 => uint256) public burnedShikigamiCounter; // Shikigami ID => Burned Shikigamis\\r\\n    uint256 public shikigamiCount; // Count for initialized Shikigamis\\r\\n\\r\\n    //--------------------------------------------------------\\r\\n    // Events\\r\\n    //--------------------------------------------------------\\r\\n\\r\\n    event NewShikigamiInitialized(uint256 indexed shikigamiId);\\r\\n\\r\\n    event ShikigamiBurned(address from, uint256 indexed shikigamiId,  uint256 choice);\\r\\n\\r\\n    event ShikigamiMinted(address to, uint256 indexed shikigamiId, uint256 amount);\\r\\n\\r\\n    //--------------------------------------------------------\\r\\n    // Modifiers\\r\\n    //--------------------------------------------------------\\r\\n\\r\\n    // Adding manager address to manage the contract\\r\\n    modifier onlyOwnerOrManager() {\\r\\n        require(msg.sender == owner() || msg.sender == managerAddress, \\\"Caller is not the owner neither manager!\\\" );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    //--------------------------------------------------------\\r\\n    // Constructor\\r\\n    //--------------------------------------------------------\\r\\n\\r\\n    constructor(address _manager, address ROYALTY_ADDRESS) ERC1155(\\\"\\\") UpdatableOperatorFilterer(address(0x000000000000AAeB6D7670E522A718067333cd4E), address(0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6), true){\\r\\n        _setDefaultRoyalty( ROYALTY_ADDRESS, ROYALTY_FEE_NUMERATOR );\\r\\n        managerAddress = _manager;\\r\\n    }\\r\\n\\r\\n    //--------------------------------------------------------\\r\\n    // [Override] supportsInterface\\r\\n    //--------------------------------------------------------\\r\\n\\r\\n    function supportsInterface(bytes4 interfaceId) public view override( ERC1155, ERC2981 ) returns (bool) {\\r\\n        return super.supportsInterface(interfaceId);\\r\\n    }\\r\\n\\r\\n    //--------------------------------------------------------\\r\\n    // [External][onlyOwnerOrManager] for ERC2981\\r\\n    //--------------------------------------------------------\\r\\n    \\r\\n    function setDefaultRoyalty( address receiver, uint96 feeNumerator ) external onlyOwnerOrManager { _setDefaultRoyalty( receiver, feeNumerator ); }\\r\\n    function deleteDefaultRoyalty() external onlyOwnerOrManager { _deleteDefaultRoyalty(); }\\r\\n    function setTokenRoyalty( uint256 tokenId, address receiver, uint96 feeNumerator ) external onlyOwnerOrManager { _setTokenRoyalty( tokenId, receiver, feeNumerator ); }\\r\\n    function resetTokenRoyalty( uint256 tokenId ) external onlyOwnerOrManager { _resetTokenRoyalty( tokenId ); }\\r\\n\\r\\n    //--------------------------------------------------------\\r\\n    // [Public/Override/onlyAllowedOperatorApproval] for OperatorFilterCustom\\r\\n    //--------------------------------------------------------\\r\\n\\r\\n    function setApprovalForAll(address operator, bool approved) public override onlyAllowedOperatorApproval(operator) { super.setApprovalForAll(operator, approved); }\\r\\n    function safeBatchTransferFrom(address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) public override onlyAllowedOperator(from) { super.safeBatchTransferFrom(from, to, ids, amounts, data); }\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId, uint256 amount, bytes memory data) public override onlyAllowedOperator(from) { super.safeTransferFrom(from, to, tokenId, amount, data); }\\r\\n\\r\\n    //--------------------------------------------------------\\r\\n    // [External][onlyOwner] Setters for Minter/Burner/Manager/Filter Register \\r\\n    //--------------------------------------------------------\\r\\n\\r\\n    function setMinterContract (address _minterContract) external onlyOwner {\\r\\n        require(_minterContract != ADDRESS_ZERO, \\\"Address should be real!\\\");\\r\\n        require(_minterContract != minterContract, \\\"Address already set!\\\");\\r\\n\\r\\n        minterContract = _minterContract;\\r\\n    }\\r\\n\\r\\n    function setBurnerContract (address _burnerContract) external onlyOwner {\\r\\n        require(_burnerContract != ADDRESS_ZERO, \\\"Address should be real!\\\");\\r\\n        require(_burnerContract != burnerContract, \\\"Address already set!\\\");\\r\\n\\r\\n        burnerContract = _burnerContract;\\r\\n    }\\r\\n\\r\\n    function setManager(address to) external onlyOwner {\\r\\n       managerAddress = to;\\r\\n    }\\r\\n\\r\\n    function setOperatorFilterRegistryAddress(address to) external onlyOwner {\\r\\n        updateOperatorFilterRegistryAddress(to);\\r\\n    }\\r\\n\\r\\n    //--------------------------------------------------------\\r\\n    // [External][onlyOwnerOrManager] Functions for managing Shikigami structs\\r\\n    //--------------------------------------------------------\\r\\n\\r\\n    // Creates new Shikigami sale struct and sets URI \\r\\n    function initializeShikigami(uint256 choiceCount, string calldata uri) external onlyOwnerOrManager {\\r\\n        require(choiceCount >= 1 && choiceCount <= 10, \\\"Amount of choices must be between 1 and 10!\\\");\\r\\n        require(keccak256(abi.encode(uri)) != keccak256(abi.encode(\\\"\\\")), \\\"uri can't be empty!\\\");\\r\\n        require(shikigamiChoices[shikigamiCount] == 0, \\\"Shikigami with this ID already exists!\\\");\\r\\n\\r\\n        shikigamiChoices[shikigamiCount] = choiceCount;\\r\\n\\r\\n        _setURI(shikigamiCount, uri); // Sets URI for this ID\\r\\n\\r\\n        emit NewShikigamiInitialized(shikigamiCount);\\r\\n        shikigamiCount++;\\r\\n    }\\r\\n\\r\\n    // Updates URI for a Shikigami sale struct\\r\\n    function updateShikigamiURI(uint256 shikigamiId, string calldata uri) external onlyOwnerOrManager {\\r\\n        require(shikigamiChoices[shikigamiId] != 0, \\\"Shikigami with this ID doesn't exist!\\\");\\r\\n        require(keccak256(abi.encode(uri)) != keccak256(abi.encode(\\\"\\\")), \\\"uri can't be empty!\\\");\\r\\n\\r\\n        _setURI(shikigamiId, uri);\\r\\n    }\\r\\n\\r\\n    //--------------------------------------------------------\\r\\n    // [Internal][onlyMinter/onlyBurner] Internal functions for minting/burning Shikigami NFTs\\r\\n    //--------------------------------------------------------\\r\\n\\r\\n    function mintShikigami(address to, uint256 shikigamiId, uint256 amount) external {\\r\\n        require(msg.sender == minterContract, \\\"Can only be called by the minter contract!\\\"); // Checks for minter address\\r\\n        require(shikigamiChoices[shikigamiId] != 0, \\\"Shikigami with this ID doesn't exist!\\\");\\r\\n\\r\\n        _mint(to, shikigamiId, amount, \\\"\\\");\\r\\n\\r\\n        emit ShikigamiMinted(to, shikigamiId, amount);\\r\\n    }\\r\\n\\r\\n    function burnShikigami(address from, uint256 shikigamiId, uint256 choice) external {\\r\\n         require(msg.sender == burnerContract, \\\"Can only be called by the burner contract!\\\"); // Checks for burner address\\r\\n         require(choice <= shikigamiChoiceCount(shikigamiId), \\\"No such choice available!\\\"); // Checks for input choice\\r\\n\\r\\n         _burn(from, shikigamiId, 1);\\r\\n         burnedShikigamiCounter[shikigamiId] += 1; // Records burned shikigami \\r\\n\\r\\n         emit ShikigamiBurned(from, shikigamiId, choice);\\r\\n    }\\r\\n\\r\\n    //--------------------------------------------------------\\r\\n    // [View] Getters for Shikigami collection\\r\\n    //--------------------------------------------------------\\r\\n\\r\\n    // Returns array of all initialized Shikigami Structs\\r\\n    function getAllShikigamiChoices() external view returns(uint256[] memory) {\\r\\n        uint256[] memory result = new uint256[](shikigamiCount);\\r\\n        for (uint256 i = 0; i < shikigamiCount; i++) {\\r\\n          result[i]= (shikigamiChoices[i]);\\r\\n        }\\r\\n        return result; \\r\\n    }\\r\\n\\r\\n    // Returns balance of every Shikigami ID for address\\r\\n    function shikigamiCountForOwner(address owner) external view returns(uint256[] memory) {\\r\\n        uint256[] memory result = new uint256[](shikigamiCount);\\r\\n        for (uint i = 0; i < shikigamiCount; i++) {\\r\\n           result[i]= (balanceOf(owner, i));\\r\\n        }\\r\\n        return result; \\r\\n    }\\r\\n\\r\\n    // Returns Shikigami ID struct\\r\\n    function shikigamiChoiceCount(uint256 shikigamiId) public view returns (uint) {\\r\\n        return shikigamiChoices[shikigamiId]; \\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n// File @openzeppelin/contracts/utils/cryptography/MerkleProof.sol@v4.9.2\\r\\n\\r\\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev These functions deal with verification of Merkle Tree proofs.\\r\\n *\\r\\n * The tree and the proofs can be generated using our\\r\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\r\\n * You will find a quickstart guide in the readme.\\r\\n *\\r\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\r\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\r\\n * This is because the concatenation of a sorted pair of internal nodes in\\r\\n * the merkle tree could be reinterpreted as a leaf value.\\r\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\r\\n * against this attack out of the box.\\r\\n */\\r\\nlibrary MerkleProof {\\r\\n    /**\\r\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\r\\n     * defined by `root`. For this, a `proof` must be provided, containing\\r\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\r\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\r\\n     */\\r\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\r\\n        return processProof(proof, leaf) == root;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calldata version of {verify}\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\r\\n        return processProofCalldata(proof, leaf) == root;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\r\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\r\\n     * hash matches the root of the tree. When processing the proof, the pairs\\r\\n     * of leafs & pre-images are assumed to be sorted.\\r\\n     *\\r\\n     * _Available since v4.4._\\r\\n     */\\r\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\r\\n        bytes32 computedHash = leaf;\\r\\n        for (uint256 i = 0; i < proof.length; i++) {\\r\\n            computedHash = _hashPair(computedHash, proof[i]);\\r\\n        }\\r\\n        return computedHash;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calldata version of {processProof}\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\r\\n        bytes32 computedHash = leaf;\\r\\n        for (uint256 i = 0; i < proof.length; i++) {\\r\\n            computedHash = _hashPair(computedHash, proof[i]);\\r\\n        }\\r\\n        return computedHash;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\r\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\r\\n     *\\r\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function multiProofVerify(\\r\\n        bytes32[] memory proof,\\r\\n        bool[] memory proofFlags,\\r\\n        bytes32 root,\\r\\n        bytes32[] memory leaves\\r\\n    ) internal pure returns (bool) {\\r\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calldata version of {multiProofVerify}\\r\\n     *\\r\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function multiProofVerifyCalldata(\\r\\n        bytes32[] calldata proof,\\r\\n        bool[] calldata proofFlags,\\r\\n        bytes32 root,\\r\\n        bytes32[] memory leaves\\r\\n    ) internal pure returns (bool) {\\r\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\r\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\r\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\r\\n     * respectively.\\r\\n     *\\r\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\r\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\r\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function processMultiProof(\\r\\n        bytes32[] memory proof,\\r\\n        bool[] memory proofFlags,\\r\\n        bytes32[] memory leaves\\r\\n    ) internal pure returns (bytes32 merkleRoot) {\\r\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\r\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\r\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\r\\n        // the merkle tree.\\r\\n        uint256 leavesLen = leaves.length;\\r\\n        uint256 proofLen = proof.length;\\r\\n        uint256 totalHashes = proofFlags.length;\\r\\n\\r\\n        // Check proof validity.\\r\\n        require(leavesLen + proofLen - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\r\\n\\r\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\r\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\r\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\r\\n        uint256 leafPos = 0;\\r\\n        uint256 hashPos = 0;\\r\\n        uint256 proofPos = 0;\\r\\n        // At each step, we compute the next hash using two values:\\r\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\r\\n        //   get the next hash.\\r\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\r\\n        //   `proof` array.\\r\\n        for (uint256 i = 0; i < totalHashes; i++) {\\r\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\r\\n            bytes32 b = proofFlags[i]\\r\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\r\\n                : proof[proofPos++];\\r\\n            hashes[i] = _hashPair(a, b);\\r\\n        }\\r\\n\\r\\n        if (totalHashes > 0) {\\r\\n            require(proofPos == proofLen, \\\"MerkleProof: invalid multiproof\\\");\\r\\n            unchecked {\\r\\n                return hashes[totalHashes - 1];\\r\\n            }\\r\\n        } else if (leavesLen > 0) {\\r\\n            return leaves[0];\\r\\n        } else {\\r\\n            return proof[0];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calldata version of {processMultiProof}.\\r\\n     *\\r\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\r\\n     *\\r\\n     * _Available since v4.7._\\r\\n     */\\r\\n    function processMultiProofCalldata(\\r\\n        bytes32[] calldata proof,\\r\\n        bool[] calldata proofFlags,\\r\\n        bytes32[] memory leaves\\r\\n    ) internal pure returns (bytes32 merkleRoot) {\\r\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\r\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\r\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\r\\n        // the merkle tree.\\r\\n        uint256 leavesLen = leaves.length;\\r\\n        uint256 proofLen = proof.length;\\r\\n        uint256 totalHashes = proofFlags.length;\\r\\n\\r\\n        // Check proof validity.\\r\\n        require(leavesLen + proofLen - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\r\\n\\r\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\r\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\r\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\r\\n        uint256 leafPos = 0;\\r\\n        uint256 hashPos = 0;\\r\\n        uint256 proofPos = 0;\\r\\n        // At each step, we compute the next hash using two values:\\r\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\r\\n        //   get the next hash.\\r\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\r\\n        //   `proof` array.\\r\\n        for (uint256 i = 0; i < totalHashes; i++) {\\r\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\r\\n            bytes32 b = proofFlags[i]\\r\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\r\\n                : proof[proofPos++];\\r\\n            hashes[i] = _hashPair(a, b);\\r\\n        }\\r\\n\\r\\n        if (totalHashes > 0) {\\r\\n            require(proofPos == proofLen, \\\"MerkleProof: invalid multiproof\\\");\\r\\n            unchecked {\\r\\n                return hashes[totalHashes - 1];\\r\\n            }\\r\\n        } else if (leavesLen > 0) {\\r\\n            return leaves[0];\\r\\n        } else {\\r\\n            return proof[0];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\r\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\r\\n    }\\r\\n\\r\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            mstore(0x00, a)\\r\\n            mstore(0x20, b)\\r\\n            value := keccak256(0x00, 0x40)\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n// File contracts/IDelegationRegistry.sol\\r\\n\\r\\n/**\\r\\n * @title An immutable registry contract to be deployed as a standalone primitive\\r\\n * @dev See EIP-5639, new project launches can read previous cold wallet -> hot wallet delegations\\r\\n * from here and integrate those permissions into their flow\\r\\n */\\r\\n\\r\\ninterface IDelegationRegistry {\\r\\n    /// @notice Delegation type\\r\\n    enum DelegationType {\\r\\n        NONE,\\r\\n        ALL,\\r\\n        CONTRACT,\\r\\n        TOKEN\\r\\n    }\\r\\n\\r\\n    /// @notice Info about a single delegation, used for onchain enumeration\\r\\n    struct DelegationInfo {\\r\\n        DelegationType type_;\\r\\n        address vault;\\r\\n        address delegate;\\r\\n        address contract_;\\r\\n        uint256 tokenId;\\r\\n    }\\r\\n\\r\\n    /// @notice Info about a single contract-level delegation\\r\\n    struct ContractDelegation {\\r\\n        address contract_;\\r\\n        address delegate;\\r\\n    }\\r\\n\\r\\n    /// @notice Info about a single token-level delegation\\r\\n    struct TokenDelegation {\\r\\n        address contract_;\\r\\n        uint256 tokenId;\\r\\n        address delegate;\\r\\n    }\\r\\n\\r\\n    /// @notice Emitted when a user delegates their entire wallet\\r\\n    event DelegateForAll(address vault, address delegate, bool value);\\r\\n\\r\\n    /// @notice Emitted when a user delegates a specific contract\\r\\n    event DelegateForContract(address vault, address delegate, address contract_, bool value);\\r\\n\\r\\n    /// @notice Emitted when a user delegates a specific token\\r\\n    event DelegateForToken(address vault, address delegate, address contract_, uint256 tokenId, bool value);\\r\\n\\r\\n    /// @notice Emitted when a user revokes all delegations\\r\\n    event RevokeAllDelegates(address vault);\\r\\n\\r\\n    /// @notice Emitted when a user revoes all delegations for a given delegate\\r\\n    event RevokeDelegate(address vault, address delegate);\\r\\n\\r\\n    /**\\r\\n     * -----------  WRITE -----------\\r\\n     */\\r\\n\\r\\n    /**\\r\\n     * @notice Allow the delegate to act on your behalf for all contracts\\r\\n     * @param delegate The hotwallet to act on your behalf\\r\\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\\r\\n     */\\r\\n    function delegateForAll(address delegate, bool value) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Allow the delegate to act on your behalf for a specific contract\\r\\n     * @param delegate The hotwallet to act on your behalf\\r\\n     * @param contract_ The address for the contract you're delegating\\r\\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\\r\\n     */\\r\\n    function delegateForContract(address delegate, address contract_, bool value) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Allow the delegate to act on your behalf for a specific token\\r\\n     * @param delegate The hotwallet to act on your behalf\\r\\n     * @param contract_ The address for the contract you're delegating\\r\\n     * @param tokenId The token id for the token you're delegating\\r\\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\\r\\n     */\\r\\n    function delegateForToken(address delegate, address contract_, uint256 tokenId, bool value) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Revoke all delegates\\r\\n     */\\r\\n    function revokeAllDelegates() external;\\r\\n\\r\\n    /**\\r\\n     * @notice Revoke a specific delegate for all their permissions\\r\\n     * @param delegate The hotwallet to revoke\\r\\n     */\\r\\n    function revokeDelegate(address delegate) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Remove yourself as a delegate for a specific vault\\r\\n     * @param vault The vault which delegated to the msg.sender, and should be removed\\r\\n     */\\r\\n    function revokeSelf(address vault) external;\\r\\n\\r\\n    /**\\r\\n     * -----------  READ -----------\\r\\n     */\\r\\n\\r\\n    /**\\r\\n     * @notice Returns all active delegations a given delegate is able to claim on behalf of\\r\\n     * @param delegate The delegate that you would like to retrieve delegations for\\r\\n     * @return info Array of DelegationInfo structs\\r\\n     */\\r\\n    function getDelegationsByDelegate(address delegate) external view returns (DelegationInfo[] memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns an array of wallet-level delegates for a given vault\\r\\n     * @param vault The cold wallet who issued the delegation\\r\\n     * @return addresses Array of wallet-level delegates for a given vault\\r\\n     */\\r\\n    function getDelegatesForAll(address vault) external view returns (address[] memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns an array of contract-level delegates for a given vault and contract\\r\\n     * @param vault The cold wallet who issued the delegation\\r\\n     * @param contract_ The address for the contract you're delegating\\r\\n     * @return addresses Array of contract-level delegates for a given vault and contract\\r\\n     */\\r\\n    function getDelegatesForContract(address vault, address contract_) external view returns (address[] memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns an array of contract-level delegates for a given vault's token\\r\\n     * @param vault The cold wallet who issued the delegation\\r\\n     * @param contract_ The address for the contract holding the token\\r\\n     * @param tokenId The token id for the token you're delegating\\r\\n     * @return addresses Array of contract-level delegates for a given vault's token\\r\\n     */\\r\\n    function getDelegatesForToken(address vault, address contract_, uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (address[] memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns all contract-level delegations for a given vault\\r\\n     * @param vault The cold wallet who issued the delegations\\r\\n     * @return delegations Array of ContractDelegation structs\\r\\n     */\\r\\n    function getContractLevelDelegations(address vault)\\r\\n        external\\r\\n        view\\r\\n        returns (ContractDelegation[] memory delegations);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns all token-level delegations for a given vault\\r\\n     * @param vault The cold wallet who issued the delegations\\r\\n     * @return delegations Array of TokenDelegation structs\\r\\n     */\\r\\n    function getTokenLevelDelegations(address vault) external view returns (TokenDelegation[] memory delegations);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if the address is delegated to act on the entire vault\\r\\n     * @param delegate The hotwallet to act on your behalf\\r\\n     * @param vault The cold wallet who issued the delegation\\r\\n     */\\r\\n    function checkDelegateForAll(address delegate, address vault) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if the address is delegated to act on your behalf for a token contract or an entire vault\\r\\n     * @param delegate The hotwallet to act on your behalf\\r\\n     * @param contract_ The address for the contract you're delegating\\r\\n     * @param vault The cold wallet who issued the delegation\\r\\n     */\\r\\n    function checkDelegateForContract(address delegate, address vault, address contract_)\\r\\n        external\\r\\n        view\\r\\n        returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns true if the address is delegated to act on your behalf for a specific token, the token's contract or an entire vault\\r\\n     * @param delegate The hotwallet to act on your behalf\\r\\n     * @param contract_ The address for the contract you're delegating\\r\\n     * @param tokenId The token id for the token you're delegating\\r\\n     * @param vault The cold wallet who issued the delegation\\r\\n     */\\r\\n    function checkDelegateForToken(address delegate, address vault, address contract_, uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (bool);\\r\\n}\\r\\n\\r\\n// File contracts/IROIROShikigamiSale.sol\\r\\n\\r\\ncontract IROIROShikigamiSale is Ownable{\\r\\n\\r\\n    // Made with love by uwulabs <3\\r\\n\\r\\n    //--------------------------------------------------------\\r\\n    // Storage\\r\\n    //--------------------------------------------------------\\r\\n\\r\\n    address public immutable shikigamiNftAddress; \\r\\n    address private uwuLabsAddress; // Address for sending fee split\\r\\n    address private cyberZAddress; // Address for sending fee split\\r\\n    address public managerAddress; // Manager address\\r\\n    // ShikigamiID => ShikigamiSale struct\\r\\n    mapping(uint256 => ShikigamiSale) private shikigamiSales; // Maps all Shikigami sale structs to Shikigami IDs\\r\\n    mapping(uint256 => uint256) private mintsByTeam; // Shikigami ID => Mints by team\\r\\n    mapping(uint256 => mapping(address => uint256)) mintedPerWalletWl; // ShikigamiID => (address => private minted amount)\\r\\n    mapping(uint256 => mapping(address => uint256)) mintedPerWalletPublic; // ShikigamiID => (address => public minted amount)\\r\\n\\r\\n    IROIROShikigami private immutable shikigami; \\r\\n    IDelegationRegistry public immutable registry;\\r\\n\\r\\n    //--------------------------------------------------------\\r\\n    // Events\\r\\n    //--------------------------------------------------------\\r\\n\\r\\n    event NewShikigamiSaleInitialized(uint256 indexed shikigamiId);\\r\\n\\r\\n    event ShikigamiSaleModified(uint256 indexed shikigamiId);\\r\\n\\r\\n    //--------------------------------------------------------\\r\\n    // Modifiers\\r\\n    //--------------------------------------------------------\\r\\n\\r\\n    modifier onlyOwnerOrManager() {\\r\\n        require( msg.sender == owner() || msg.sender == managerAddress, \\\"Caller is not the owner neither manager!\\\" );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    //--------------------------------------------------------\\r\\n    // Constructor\\r\\n    //--------------------------------------------------------\\r\\n\\r\\n    constructor(address _registry, address payable _shikigamiNftAddress, address _manager, address _uwuLabsAddress, address _cyberZAddress ) {\\r\\n        shikigamiNftAddress = _shikigamiNftAddress;\\r\\n        managerAddress = _manager;\\r\\n        uwuLabsAddress = _uwuLabsAddress;\\r\\n        cyberZAddress = _cyberZAddress;\\r\\n        shikigami = IROIROShikigami(_shikigamiNftAddress);\\r\\n        registry = IDelegationRegistry(_registry);\\r\\n    }\\r\\n\\r\\n    //--------------------------------------------------------\\r\\n    // Structs\\r\\n    //--------------------------------------------------------\\r\\n    \\r\\n    // All metadata regarding Shikigami sale\\r\\n    struct ShikigamiSale {\\r\\n        uint256 wlSalePrice;\\r\\n        uint256 publicSalePrice;\\r\\n        uint64 maxSupply;\\r\\n        uint64 wlSupply;\\r\\n        uint64 teamSupply; \\r\\n        uint64 wlSaleStart;\\r\\n        uint64 publicSaleStart;\\r\\n        uint64 maxPerWalletPublic;\\r\\n        uint64 publicSaleClose;\\r\\n        bytes32 wlSaleRoot;\\r\\n        bytes32 publicSaleRoot;\\r\\n    }\\r\\n\\r\\n    // Struct for parsing to the initialize Shikigami sale function\\r\\n    struct ShikigamiSaleParameters {\\r\\n        uint256 wlSalePrice;\\r\\n        uint256 publicSalePrice;\\r\\n        uint64 maxSupply;\\r\\n        uint64 wlSupply;\\r\\n        uint64 teamSupply; \\r\\n        uint64 wlSaleStart;\\r\\n        uint64 publicSaleStart;\\r\\n        uint64 maxPerWalletPublic;\\r\\n        uint64 publicSaleClose;\\r\\n        bytes32 wlSaleRoot;\\r\\n        bytes32 publicSaleRoot;\\r\\n    }\\r\\n\\r\\n    //--------------------------------------------------------\\r\\n    //  [External][onlyOwnerOrManager] Main functions for initializing/modifiying Shikigami sale structs\\r\\n    //--------------------------------------------------------\\r\\n\\r\\n    function initializeShikigamiSale (uint256 shikigamiId, ShikigamiSaleParameters calldata shikigamiSaleParameters) external onlyOwnerOrManager {\\r\\n        require(shikigamiSales[shikigamiId].maxSupply == 0, \\\"Sale for this ID already initialized!\\\");\\r\\n        require(shikigamiSaleParameters.maxSupply > 0, \\\"Supply can't be 0!\\\");\\r\\n        require(shikigamiSaleParameters.wlSupply + shikigamiSaleParameters.teamSupply <= shikigamiSaleParameters.maxSupply, \\\"Must be less or equal to the total supply!\\\");\\r\\n        require(shikigamiSaleParameters.wlSaleStart < shikigamiSaleParameters.publicSaleStart, \\\"Invalid time!\\\");\\r\\n        require(shikigamiSaleParameters.publicSaleStart < shikigamiSaleParameters.publicSaleClose, \\\"Invalid time!\\\");\\r\\n\\r\\n\\r\\n        shikigamiSales[shikigamiId] = ShikigamiSale({\\r\\n            wlSalePrice: shikigamiSaleParameters.wlSalePrice,\\r\\n            publicSalePrice: shikigamiSaleParameters.publicSalePrice,\\r\\n            maxSupply: shikigamiSaleParameters.maxSupply,\\r\\n            wlSupply: shikigamiSaleParameters.wlSupply,\\r\\n            teamSupply: shikigamiSaleParameters.teamSupply,\\r\\n            wlSaleStart: shikigamiSaleParameters.wlSaleStart, \\r\\n            publicSaleStart: shikigamiSaleParameters.publicSaleStart, \\r\\n            maxPerWalletPublic: shikigamiSaleParameters.maxPerWalletPublic,\\r\\n            publicSaleClose: shikigamiSaleParameters.publicSaleClose,\\r\\n            wlSaleRoot: shikigamiSaleParameters.wlSaleRoot, // Required\\r\\n            publicSaleRoot: shikigamiSaleParameters.publicSaleRoot // If not set free public mint\\r\\n        });\\r\\n\\r\\n        emit NewShikigamiSaleInitialized(shikigamiId);\\r\\n    }\\r\\n\\r\\n    function modifyShikigamiSale(uint256 shikigamiId, ShikigamiSaleParameters calldata shikigamiSaleParameters) external onlyOwnerOrManager {\\r\\n        \\r\\n        ShikigamiSale storage shikigamiSale = shikigamiSales[shikigamiId];\\r\\n        \\r\\n        require(shikigamiSale.maxSupply > 0, \\\"Sale for this ID is not initialized!\\\");\\r\\n        require(shikigamiSaleParameters.wlSupply + shikigamiSaleParameters.teamSupply <= shikigamiSale.maxSupply, \\\"Must be less or equal to the total supply!\\\");\\r\\n        require(shikigamiSaleParameters.wlSaleStart < shikigamiSaleParameters.publicSaleStart, \\\"Invalid time!\\\");\\r\\n        require(shikigamiSaleParameters.publicSaleStart < shikigamiSaleParameters.publicSaleClose, \\\"Invalid time!\\\");\\r\\n\\r\\n        shikigamiSales[shikigamiId] = ShikigamiSale({\\r\\n            wlSalePrice: shikigamiSaleParameters.wlSalePrice,\\r\\n            publicSalePrice: shikigamiSaleParameters.publicSalePrice,\\r\\n            maxSupply: shikigamiSale.maxSupply, // maxSupply isn't changable\\r\\n            wlSupply: shikigamiSaleParameters.wlSupply,\\r\\n            teamSupply: shikigamiSaleParameters.teamSupply,\\r\\n            wlSaleStart: shikigamiSaleParameters.wlSaleStart, \\r\\n            publicSaleStart: shikigamiSaleParameters.publicSaleStart, \\r\\n            maxPerWalletPublic: shikigamiSaleParameters.maxPerWalletPublic,\\r\\n            publicSaleClose: shikigamiSaleParameters.publicSaleClose,\\r\\n            wlSaleRoot: shikigamiSaleParameters.wlSaleRoot, // Required\\r\\n            publicSaleRoot: shikigamiSaleParameters.publicSaleRoot // If not set free public mint\\r\\n        });\\r\\n\\r\\n        emit ShikigamiSaleModified(shikigamiId);\\r\\n    }\\r\\n\\r\\n    //--------------------------------------------------------\\r\\n    //  [External] Mint shikigami function \\r\\n    //--------------------------------------------------------\\r\\n\\r\\n    // Serves both private and public mints, depending on set time limits in Shikigami sale struct. Automatically ends private sale and starts public sale on \\\"publicSaleStart\\\".\\r\\n    function buyShikigami(uint256 shikigamiId, uint256 mintAmount, bytes32[] calldata merkleProof, uint256 merkleMaxAmount, address vault) external payable {\\r\\n        ShikigamiSale memory shikigamiSale = shikigamiSales[shikigamiId];\\r\\n\\r\\n        require(msg.sender == tx.origin, \\\"Contracts can't mint!\\\"); \\r\\n        require(shikigamiSale.maxSupply > 0, \\\"Sale for this ID is not initialized!\\\");\\r\\n        require(block.timestamp > shikigamiSale.wlSaleStart && block.timestamp < shikigamiSale.publicSaleClose, \\\"Sale is not live!\\\");\\r\\n        \\r\\n        // Check for delegation \\r\\n        if (vault == address(0)) {\\r\\n            vault = msg.sender;\\r\\n        } else {\\r\\n            require(registry.checkDelegateForContract(msg.sender, vault, address(this)), \\\"Sender is not delegated!\\\"); // Checks delegation \\r\\n        }\\r\\n\\r\\n        // If else block for Private mint, merkleProof is required. Checks if the timestamp is within set time limits of wlSaleStart and publicSaleStart.\\r\\n        if (block.timestamp > shikigamiSale.wlSaleStart && block.timestamp < shikigamiSale.publicSaleStart) {\\r\\n\\r\\n            // Checks for supply, mint amount, price.\\r\\n            require(shikigami.totalSupply(shikigamiId) + shikigami.burnedShikigamiCounter(shikigamiId) + mintAmount <= shikigamiSale.wlSupply + shikigamiSale.teamSupply, \\\"Mint cap for WL is reached!\\\");\\r\\n            require(msg.value >= shikigamiSale.wlSalePrice * mintAmount, \\\"Invalid value sent!\\\");\\r\\n            require(mintedPerWalletWl[shikigamiId][vault] + mintAmount <= merkleMaxAmount, \\\"Can't mint more than tree allows!\\\");\\r\\n            require(MerkleProof.verify(merkleProof, shikigamiSale.wlSaleRoot, keccak256(abi.encodePacked(vault, merkleMaxAmount))), \\\"Merkle verification failed!\\\");\\r\\n            \\r\\n            // Calls mint function in Shikigami contract.\\r\\n            mintedPerWalletWl[shikigamiId][vault] += mintAmount;\\r\\n            shikigami.mintShikigami(vault, shikigamiId, mintAmount); \\r\\n\\r\\n        // Public mint block. Automatically starts if timestamp within time limits of publicSaleStart and publicSaleClose.\\r\\n        } else if (block.timestamp > shikigamiSale.publicSaleStart && block.timestamp < shikigamiSale.publicSaleClose) {\\r\\n            // Logic for public sale if publicSaleRoot is NOT empty.\\r\\n                require(mintAmount <= shikigamiSale.maxPerWalletPublic, \\\"Mint amount is too high!\\\");\\r\\n                require(shikigami.totalSupply(shikigamiId) + shikigami.burnedShikigamiCounter(shikigamiId) + mintAmount <= shikigamiSale.maxSupply, \\\"Mint cap for public is reached!\\\");\\r\\n                require(msg.value >= shikigamiSale.publicSalePrice * mintAmount, \\\"Invalid value sent!\\\");\\r\\n                require(mintedPerWalletPublic[shikigamiId][vault] + mintAmount <= shikigamiSale.maxPerWalletPublic, \\\"Mint amount exceeds mints per wallet!\\\");\\r\\n\\r\\n            // Checks for supply, mint amount, price.\\r\\n            if(shikigamiSale.publicSaleRoot != \\\"\\\") {\\r\\n                require(mintedPerWalletPublic[shikigamiId][vault] + mintAmount <= merkleMaxAmount, \\\"Can't mint more than tree allows\\\");\\r\\n                require(MerkleProof.verify(merkleProof, shikigamiSale.publicSaleRoot, keccak256(abi.encodePacked(vault, merkleMaxAmount))), \\\"Merkle verification failed!\\\");\\r\\n            } \\r\\n            // Calls mint function in Shikigami contract.\\r\\n            mintedPerWalletPublic[shikigamiId][vault] += mintAmount;\\r\\n            shikigami.mintShikigami(vault, shikigamiId, mintAmount);   \\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    //--------------------------------------------------------\\r\\n    //  [onlyOwnerOrManager] Withdraw and Team Mint \\r\\n    //--------------------------------------------------------\\r\\n\\r\\n    // Needs to be called before private and public mints!\\r\\n    function teamMint(address to, uint64 shikigamiId, uint64 amount) external onlyOwnerOrManager {\\r\\n        ShikigamiSale storage shikigamiSale = shikigamiSales[shikigamiId];\\r\\n\\r\\n        require(shikigamiSale.maxSupply > 0, \\\"Sale for this ID is not initialized!\\\");\\r\\n        require(shikigami.totalSupply(shikigamiId) + shikigami.burnedShikigamiCounter(shikigamiId) + amount <= shikigamiSale.maxSupply, \\\"Mint cap for team is reached!\\\");\\r\\n\\r\\n        if (block.timestamp < shikigamiSale.wlSaleStart) {\\r\\n            require(mintsByTeam[shikigamiId] + amount <= shikigamiSale.teamSupply, \\\"Amount larger than team mint limit!\\\");\\r\\n\\r\\n            mintsByTeam[shikigamiId] += amount;\\r\\n\\r\\n            shikigami.mintShikigami(to, shikigamiId, amount);   \\r\\n        } else if (block.timestamp > shikigamiSale.publicSaleClose) {\\r\\n            shikigami.mintShikigami(to, shikigamiId, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function withdraw() public payable onlyOwnerOrManager {\\r\\n        (bool successRoyalty, ) = payable(uwuLabsAddress).call{value: (address(this).balance) * 5 / 100}(\\\"\\\");\\r\\n        require(successRoyalty, \\\"Transaction failed!\\\");\\r\\n\\r\\n        (bool successOwner, ) = payable(cyberZAddress).call{value: (address(this).balance)}(\\\"\\\");\\r\\n        require(successOwner, \\\"Transaction failed!\\\");\\r\\n    }\\r\\n\\r\\n    //--------------------------------------------------------\\r\\n    //  [onlyOwner] Setters administration functions\\r\\n    //--------------------------------------------------------\\r\\n\\r\\n    function setManager(address to) external onlyOwner {\\r\\n       managerAddress = to;\\r\\n    }\\r\\n\\r\\n    //--------------------------------------------------------\\r\\n    //  [View] Getter for Shikigami sale\\r\\n    //--------------------------------------------------------\\r\\n\\r\\n    function getSaleDetails(uint256 shikigamiId) external view returns(ShikigamiSale memory) {\\r\\n        require(shikigamiSales[shikigamiId].maxSupply > 0, \\\"Sale for this ID is not initialized!\\\");\\r\\n\\r\\n        return shikigamiSales[shikigamiId];\\r\\n    }\\r\\n\\r\\n    function getUnmintedSupply(uint256 shikigamiId) external view returns(uint256 unmintedSupply) {\\r\\n        ShikigamiSale storage shikigamiSale = shikigamiSales[shikigamiId];\\r\\n        require(shikigamiSales[shikigamiId].maxSupply > 0, \\\"Sale for this ID is not initialized!\\\");\\r\\n        \\r\\n        unmintedSupply = shikigamiSale.maxSupply - (shikigami.burnedShikigamiCounter(shikigamiId) + shikigami.totalSupply(shikigamiId));\\r\\n        return unmintedSupply;\\r\\n    }\\r\\n\\r\\n    function getSalePhase(uint256 shikigamiId) external view returns(string memory) {\\r\\n        require(shikigamiSales[shikigamiId].maxSupply > 0, \\\"Sale for this ID is not initialized!\\\");\\r\\n\\r\\n        if (block.timestamp > shikigamiSales[shikigamiId].wlSaleStart && block.timestamp < shikigamiSales[shikigamiId].publicSaleStart) {\\r\\n            return \\\"WL sale\\\";\\r\\n        } else if (block.timestamp > shikigamiSales[shikigamiId].publicSaleStart && block.timestamp < shikigamiSales[shikigamiId].publicSaleClose) {\\r\\n            return \\\"Public sale\\\";\\r\\n        } else {\\r\\n            return \\\"Sale closed\\\";\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_shikigamiNftAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uwuLabsAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cyberZAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"shikigamiId\",\"type\":\"uint256\"}],\"name\":\"NewShikigamiSaleInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"shikigamiId\",\"type\":\"uint256\"}],\"name\":\"ShikigamiSaleModified\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shikigamiId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"merkleMaxAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"buyShikigami\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shikigamiId\",\"type\":\"uint256\"}],\"name\":\"getSaleDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"wlSalePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publicSalePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"maxSupply\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"wlSupply\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"teamSupply\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"wlSaleStart\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"publicSaleStart\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxPerWalletPublic\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"publicSaleClose\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"wlSaleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"publicSaleRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct IROIROShikigamiSale.ShikigamiSale\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shikigamiId\",\"type\":\"uint256\"}],\"name\":\"getSalePhase\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shikigamiId\",\"type\":\"uint256\"}],\"name\":\"getUnmintedSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unmintedSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shikigamiId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"wlSalePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publicSalePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"maxSupply\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"wlSupply\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"teamSupply\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"wlSaleStart\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"publicSaleStart\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxPerWalletPublic\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"publicSaleClose\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"wlSaleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"publicSaleRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct IROIROShikigamiSale.ShikigamiSaleParameters\",\"name\":\"shikigamiSaleParameters\",\"type\":\"tuple\"}],\"name\":\"initializeShikigamiSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shikigamiId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"wlSalePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publicSalePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"maxSupply\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"wlSupply\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"teamSupply\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"wlSaleStart\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"publicSaleStart\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxPerWalletPublic\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"publicSaleClose\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"wlSaleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"publicSaleRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct IROIROShikigamiSale.ShikigamiSaleParameters\",\"name\":\"shikigamiSaleParameters\",\"type\":\"tuple\"}],\"name\":\"modifyShikigamiSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract IDelegationRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shikigamiNftAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"shikigamiId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"amount\",\"type\":\"uint64\"}],\"name\":\"teamMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "IROIROShikigamiSale", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000076a84fef008cdabe6409d2fe638b000000000000000000000000275af81cd01c435898ebf243df609cb923c362ee00000000000000000000000060dd0cf42b571dc2e437cf37a8b2a98ab9551e29000000000000000000000000fe2875dcacd1d92ca755c0a3def4a8debd970643000000000000000000000000c78b8e9f12edbc74a708f9b5a0472b33b3b286ce", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}