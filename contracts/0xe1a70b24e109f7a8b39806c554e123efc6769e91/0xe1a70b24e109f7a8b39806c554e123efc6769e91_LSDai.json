{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDai.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IDai is IERC20 {\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n  function permit(\\n    address holder,\\n    address spender,\\n    uint256 nonce,\\n    uint256 expiry,\\n    bool allowed,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  function nonces(address owner) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IJoin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\ninterface IJoin {\\n  function join(address, uint256) external;\\n\\n  function exit(address, uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILSDai.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title LSDai interface\\n * @dev extention of ERC20 interface, with LSDai-specific events\\n */\\ninterface ILSDai is IERC20 {\\n  /**\\n   * @notice An executed shares transfer from `sender` to `recipient`.\\n   *\\n   * @dev emitted in pair with an ERC20-defined `Transfer` event.\\n   */\\n  event TransferShares(address indexed from, address indexed to, uint256 sharesValue);\\n\\n  /**\\n   * @notice An executed `burnShares` request\\n   *\\n   * @dev Reports simultaneously burnt shares amount\\n   * and corresponding stETH amount.\\n   * The stETH amount is calculated twice: before and after the burning incurred rebase.\\n   *\\n   * @param account holder of the burnt shares\\n   * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\\n   * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\\n   * @param sharesAmount amount of burnt shares\\n   */\\n  event SharesBurnt(\\n    address indexed account, uint256 preRebaseTokenAmount, uint256 postRebaseTokenAmount, uint256 sharesAmount\\n  );\\n\\n  /**\\n   * @dev emitted when the DAI deposit cap is set. set `setDepositCap` for more details.\\n   */\\n  event DepositCapSet(uint256 depositCap);\\n\\n  /**\\n   * @dev emitted when the withdrawal fee is set. set `setWithdrawalFee` for more details.\\n   */\\n  event WithdrawalFeeSet(uint256 withdrawalFee);\\n\\n  /**\\n   * @dev emitted when the interest fee is set. set `setInterestFee` for more details.\\n   */\\n  event InterestFeeSet(uint256 interestFee);\\n\\n  /**\\n   * @dev emitted when the fee recipient is set. set `setFeeRecipient` for more details.\\n   */\\n  event FeeRecipientSet(address indexed recipient);\\n\\n  /**\\n   * @notice The DAI deposit cap.\\n   * @dev can be changed by the owner of the contract.\\n   */\\n  function depositCap() external view returns (uint256);\\n\\n  /**\\n   * @notice the fee recipient.\\n   * @dev can be changed by the owner of the contract.\\n   */\\n  function feeRecipient() external view returns (address);\\n\\n  /**\\n   * @dev Updates the fee recipient. Only callable by the owner.\\n   * @param recipient The new fee recipient.\\n   */\\n  function setFeeRecipient(address recipient) external;\\n\\n  /**\\n   * @notice sets the DAI deposit cap.\\n   * @dev can be changed by the owner of the contract.\\n   * @param cap the new DAI deposit cap.\\n   */\\n  function setDepositCap(uint256 cap) external;\\n\\n  /**\\n   * @notice the interest fee percentage in basis points (1/100 of a percent)\\n   */\\n  function interestFee() external view returns (uint256);\\n\\n  /**\\n   * @notice sets the interest fee percentage in basis points (1/100 of a percent)\\n   * @param fee the new interest fee percentage in basis points (1/100 of a percent)\\n   */\\n  function setInterestFee(uint256 fee) external;\\n\\n  /**\\n   * @notice the withdrawal fee percentage in basis points (1/100 of a percent)\\n   */\\n  function withdrawalFee() external view returns (uint256);\\n\\n  /**\\n   * @notice sets the withdrawal fee percentage in basis points (1/100 of a percent)\\n   * @param fee the new withdrawal fee percentage in basis points (1/100 of a percent)\\n   */\\n  function setWithdrawalFee(uint256 fee) external;\\n\\n  /**\\n   * @dev initializes the contract.\\n   * @param _depositCap the DAI deposit cap.\\n   * @param _interestFee the interest fee percentage in basis points (1/100 of a percent)\\n   * @param _withdrawalFee the withdrawal fee percentage in basis points (1/100 of a percent)\\n   * @param _feeRecipient the address of the fee recipient\\n   */\\n  function initialize(uint256 _depositCap, uint256 _interestFee, uint256 _withdrawalFee, address _feeRecipient)\\n    external\\n    returns (bool);\\n\\n  /**\\n   * @dev rebase the total pooled DAI, user balance and total supply of LSDAI.\\n   * Can only be called by anyone\\n   */\\n  function rebase() external;\\n\\n  /**\\n   * @return the amount of tokens in existence.\\n   *\\n   * @dev Always equals to `_getTotalPooledDai()` since token amount\\n   * is pegged to the total amount of DAI controlled by the protocol.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @return the amount of total LSDAI shares\\n   */\\n  function totalShares() external view returns (uint256);\\n\\n  ////////////////////////////////////////\\n  // User functions //////////////////////\\n  ////////////////////////////////////////\\n\\n  /// getters ///\\n  /**\\n   * @return the amount of shares owned by `_account`.\\n   */\\n  function sharesOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the amount of LSDai tokens owned by the `account`.\\n   * @dev Balances are dynamic and equal the `account`'s share in the amount of the\\n   * total DAI controlled by the protocol. See `sharesOf`.\\n   * @param account The address of the account to check the balance of.\\n   * @return The amount of LSDai tokens owned by the `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Deposit DAI and mint LSDAI.\\n   * @param to The address to mint LSDAI to.\\n   * @param daiAmount The amount of DAI to deposit.\\n   * @return amount of LSDAI minted.\\n   */\\n  function deposit(address to, uint256 daiAmount) external returns (uint256);\\n\\n  /**\\n   * @dev Deposit DAI and mint LSDAI using ERC20 permit.\\n   * @param to The address to mint LSDAI to.\\n   * @param daiAmount The amount of DAI to deposit.\\n   * @param permitNonce The nonce of the permit signature.\\n   * @param permitExpiry The deadline timestamp, type(uint256).max for no deadline.\\n   * @param permitV The recovery byte of the signature.\\n   * @param permitR Half of the ECDSA signature pair.\\n   * @param permitS Half of the ECDSA signature pair.\\n   * @return amount amount of LSDAI minted.\\n   */\\n  function depositWithPermit(\\n    address to,\\n    uint256 daiAmount,\\n    uint256 permitNonce,\\n    uint256 permitExpiry,\\n    uint8 permitV,\\n    bytes32 permitR,\\n    bytes32 permitS\\n  ) external returns (uint256);\\n\\n  /**\\n   * Withdraw DAI from the contract\\n   * @param daiAmount The amount of LSDAI to withdraw. wad is denominated in dai\\n   */\\n  function withdraw(uint256 daiAmount) external returns (bool);\\n\\n  /**\\n   * @notice Returns the amount of LSDai shares that corresponds to `daiAmount` protocol-controlled DAI.\\n   * @param daiAmount The amount of protocol-controlled DAI.\\n   * @return The amount of LSDai shares that corresponds to `daiAmount` protocol-controlled DAI.\\n   */\\n  function getSharesByPooledDai(uint256 daiAmount) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the amount of protocol-controlled DAI that corresponds to `sharesAmount` LSDai shares.\\n   * @param sharesAmount The amount of LSDai shares.\\n   * @return The amount of protocol-controlled DAI that corresponds to `sharesAmount` LSDai shares.\\n   */\\n  function getPooledDaiByShares(uint256 sharesAmount) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\ninterface IPot {\\n  function chi() external view returns (uint256);\\n\\n  function rho() external view returns (uint256);\\n\\n  function dsr() external view returns (uint256);\\n\\n  function drip() external returns (uint256);\\n\\n  function join(uint256) external;\\n\\n  function exit(uint256) external;\\n\\n  /**\\n   * @notice Return the balance of a given address in this contract. Normalised Savings Dai [wad]\\n   */\\n  function pie(address) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\ninterface IVat {\\n  function hope(address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/RMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\n/**\\n * @title RMath - math library\\n * @notice based on MakerDAO's math function in DSRManager\\n */\\nlibrary RMath {\\n  // --- Math ---\\n  uint256 constant RAY = 10 ** 27;\\n\\n  function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n    // always rounds down\\n    z = SafeMath.mul(x, y) / RAY;\\n  }\\n\\n  function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n    // always rounds down\\n    z = SafeMath.mul(x, RAY) / y;\\n  }\\n\\n  function rdivup(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n    // always rounds up\\n    z = SafeMath.add(SafeMath.mul(x, RAY), SafeMath.sub(y, 1)) / y;\\n  }\\n\\n  function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\\n    assembly {\\n      switch x\\n      case 0 {\\n        switch n\\n        case 0 { z := RAY }\\n        default { z := 0 }\\n      }\\n      default {\\n        switch mod(n, 2)\\n        case 0 { z := RAY }\\n        default { z := x }\\n        let half := div(RAY, 2) // for rounding.\\n        for { n := div(n, 2) } n { n := div(n, 2) } {\\n          let xx := mul(x, x)\\n          if iszero(eq(div(xx, x), x)) { revert(0, 0) }\\n          let xxRound := add(xx, half)\\n          if lt(xxRound, xx) { revert(0, 0) }\\n          x := div(xxRound, RAY)\\n          if mod(n, 2) {\\n            let zx := mul(z, x)\\n            if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0, 0) }\\n            let zxRound := add(zx, half)\\n            if lt(zxRound, zx) { revert(0, 0) }\\n            z := div(zxRound, RAY)\\n          }\\n        }\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/LSDai.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport {Strings} from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n// Custom Ownable logic from OZ\\nimport {Ownable} from \\\"./Ownable.sol\\\";\\n\\n// Interfaces\\nimport {ILSDai} from \\\"./interfaces/ILSDai.sol\\\";\\n\\n// DSR helpers\\nimport {RMath} from \\\"./libraries/RMath.sol\\\";\\nimport {IDai} from \\\"./interfaces/IDai.sol\\\";\\nimport {IPot} from \\\"./interfaces/IPot.sol\\\";\\nimport {IJoin} from \\\"./interfaces/IJoin.sol\\\";\\nimport {IVat} from \\\"./interfaces/IVat.sol\\\";\\n\\n/**\\n * @title LSDAI\\n * @dev LSDai is a rebasing token that earns interest on DAI deposited in the MakerDAO DSR.\\n */\\ncontract LSDai is Ownable, ILSDai {\\n  error LSDai__AlreadyInitialized();\\n  error LSDai__DepositCap();\\n  error LSDai__WithdrawalFeeHigh();\\n  error LSDai__InterestFeeHigh();\\n  error LSDai__TransferToZeroAddress();\\n  error LSDai__TransferFromZeroAddress();\\n  error LSDai__TransferToLSDaiContract();\\n  error LSDai__MintToZeroAddress();\\n  error LSDai__BurnFromZeroAddress();\\n  error LSDai__SharesAmountExceedsBalance();\\n  error LSDai__AmountExceedsBalance();\\n  error LSDai__FeeRecipientZeroAddress();\\n  error LSDai__RebaseOverflow(uint256 preRebaseTotalPooledDai, uint256 postRebaseTotalPooledDai);\\n\\n  using SafeMath for uint256;\\n  ///////////////////////////\\n  //     ERC20 storage     //\\n  ///////////////////////////\\n\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  string public name;\\n\\n  /**\\n   * @dev Returns the symbol of the token, usually a shorter version of the\\n   * name.\\n   */\\n  string public symbol;\\n\\n  /**\\n   * @dev Returns the number of decimals used to get its user representation.\\n   */\\n  uint256 public immutable decimals = 18;\\n\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  mapping(address => mapping(address => uint256)) private _allowances;\\n\\n  /*//////////////////////////////////////////////////////////////\\n                                 LSDAI STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n  /**\\n   * @dev LSDAI is initialized.\\n   */\\n  bool private _initialized;\\n\\n  /**\\n   * @dev LSDAI deposit cap. This is the maximum amount of DAI that can be deposited.\\n   */\\n  uint256 public depositCap;\\n\\n  /**\\n   * @dev Address shares\\n   */\\n  mapping(address => uint256) private _shares;\\n\\n  /**\\n   * @dev Total shares of LSDAI\\n   */\\n  uint256 private _totalLsdaiShares;\\n\\n  /**\\n   * @notice Total amount of DAI controlled by LSDAI at MakerDAO DSR.\\n   * @dev This value must be updated before depositing or withdrawing.\\n   */\\n  uint256 private _totalPooledDai;\\n\\n  /**\\n   * @dev the total amount of pot shares\\n   */\\n  uint256 private _totalPotShares;\\n\\n  ///////////////////////////\\n  // LSDAI Fee Information //\\n  ///////////////////////////\\n  /**\\n   * @notice Interest fee taken on interest earned, in basis points.\\n   */\\n  uint256 public interestFee;\\n\\n  /**\\n   * @notice Withdrawal fee taken on exit, in basis points.\\n   */\\n  uint256 public withdrawalFee;\\n\\n  /**\\n   * @notice Fee recipient address.\\n   */\\n  address public feeRecipient;\\n\\n  ///////////////////////////\\n  // MakerDAO DSR Contracts //\\n  ///////////////////////////\\n  IVat public immutable vat = IVat(0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B);\\n  IPot public immutable pot = IPot(0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7);\\n  IJoin public immutable daiJoin = IJoin(0x9759A6Ac90977b93B58547b4A71c78317f391A28);\\n  IDai public immutable dai = IDai(0x6B175474E89094C44Da98b954EedeAC495271d0F);\\n\\n  /**\\n   * @dev initializes the contract.\\n   * @param _depositCap the DAI deposit cap.\\n   * @param _interestFee the interest fee percentage in basis points (1/100 of a percent)\\n   * @param _withdrawalFee the withdrawal fee percentage in basis points (1/100 of a percent)\\n   * @param _feeRecipient the address of the fee recipient\\n   */\\n  function initialize(uint256 _depositCap, uint256 _interestFee, uint256 _withdrawalFee, address _feeRecipient)\\n    external\\n    returns (bool)\\n  {\\n    if (_initialized) {\\n      revert LSDai__AlreadyInitialized();\\n    }\\n\\n    // Transfer ownership to message sender\\n    _transferOwnership(msg.sender);\\n\\n    // Set ERC20 name and symbol\\n    name = \\\"Liquid Savings DAI\\\";\\n    symbol = \\\"LSDAI\\\";\\n\\n    // Set initial deposit cap to 10m DAI\\n    setDepositCap(_depositCap);\\n    // Set fee information\\n    setFeeRecipient(_feeRecipient);\\n    setWithdrawalFee(_withdrawalFee);\\n    setInterestFee(_interestFee);\\n\\n    _initialized = true;\\n\\n    // Setup the LSDAI contract to be able to interact with the MakerDAO contracts and DAI token\\n    vat.hope(address(daiJoin));\\n    vat.hope(address(pot));\\n    dai.approve(address(daiJoin), type(uint256).max);\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @return the amount of shares owned by `_account`.\\n   */\\n  function sharesOf(address account) public view returns (uint256) {\\n    return _shares[account];\\n  }\\n\\n  /**\\n   * @dev returns the amount of pot shares the LSDAI contract has in the DSR pot contract\\n   */\\n  function potShares() external view returns (uint256) {\\n    return pot.pie(address(this));\\n  }\\n\\n  /**\\n   * @dev Deposit DAI and mint LSDAI.\\n   * @param to The address to mint LSDAI to.\\n   * @param daiAmount The amount of DAI to deposit.\\n   * @return amount of LSDAI minted.\\n   */\\n  function deposit(address to, uint256 daiAmount) external returns (uint256) {\\n    dai.transferFrom(msg.sender, address(this), daiAmount);\\n    return _deposit(to, daiAmount);\\n  }\\n\\n  /**\\n   * @dev Deposit DAI and mint LSDAI.\\n   * @param to The address to mint LSDAI to.\\n   * @param daiAmount The amount of DAI to deposit.\\n   * @param permitNonce The nonce of the permit signature.\\n   * @param permitExpiry The deadline timestamp, type(uint256).max for no deadline.\\n   * @param permitV The recovery byte of the signature.\\n   * @param permitR Half of the ECDSA signature pair.\\n   * @param permitS Half of the ECDSA signature pair.\\n   * @return amount of LSDAI minted.\\n   */\\n  function depositWithPermit(\\n    address to,\\n    uint256 daiAmount,\\n    uint256 permitNonce,\\n    uint256 permitExpiry,\\n    uint8 permitV,\\n    bytes32 permitR,\\n    bytes32 permitS\\n  ) external returns (uint256) {\\n    dai.permit(msg.sender, address(this), permitNonce, permitExpiry, true, permitV, permitR, permitS);\\n    dai.transferFrom(msg.sender, address(this), daiAmount);\\n    return _deposit(to, daiAmount);\\n  }\\n\\n  /**\\n   * Withdraw DAI from the contract\\n   * @param daiAmount The amount of LSDAI to withdraw. wad is denominated in dai\\n   */\\n  function withdraw(uint256 daiAmount) external returns (bool) {\\n    return _withdraw(msg.sender, msg.sender, daiAmount, withdrawalFee);\\n  }\\n\\n  /**\\n   * Withdraw DAI from the contract to a specified address instead of the sender\\n   * @param to The address to withdraw LSDAI to.\\n   * @param daiAmount The amount of LSDAI to withdraw. wad is denominated in dai\\n   */\\n  function withdrawTo(address to, uint256 daiAmount) external returns (bool) {\\n    return _withdraw(msg.sender, to, daiAmount, withdrawalFee);\\n  }\\n\\n  /**\\n   * @dev withdraws the pending protocol fees from the DSR pot to the `feeRecipient`. Only callable by the owner.\\n   */\\n  function collectFees() external onlyOwner returns (bool) {\\n    return _withdraw(feeRecipient, feeRecipient, balanceOf(feeRecipient), 0);\\n  }\\n\\n  /**\\n   * @dev Updates the withdrawal fee, possible values between 0 and 0.2%. Only callable by the owner.\\n   * @param fee The new withdrawal fee, in basis points.\\n   */\\n  function setWithdrawalFee(uint256 fee) public onlyOwner {\\n    if (fee > 20) {\\n      revert LSDai__WithdrawalFeeHigh();\\n    }\\n\\n    withdrawalFee = fee;\\n\\n    emit WithdrawalFeeSet(fee);\\n  }\\n\\n  /**\\n   * @dev Updates the interest fee. Only callable by the owner.\\n   * @param fee The new interest fee, in basis points.\\n   */\\n  function setInterestFee(uint256 fee) public onlyOwner {\\n    // Cap at 5% (500 basis points)\\n    if (fee > 500) {\\n      revert LSDai__InterestFeeHigh();\\n    }\\n\\n    interestFee = fee;\\n\\n    emit InterestFeeSet(fee);\\n  }\\n\\n  /**\\n   * @dev Updates the fee recipient. Only callable by the owner.\\n   * @param recipient The new fee recipient.\\n   */\\n  function setFeeRecipient(address recipient) public onlyOwner {\\n    if (recipient == address(0)) {\\n      revert LSDai__FeeRecipientZeroAddress();\\n    }\\n\\n    feeRecipient = recipient;\\n\\n    emit FeeRecipientSet(recipient);\\n  }\\n\\n  /**\\n   * @return the amount of tokens owned by the `account`.\\n   *\\n   * @dev Balances are dynamic and equal the `account`'s share in the amount of the\\n   * total DAI controlled by the protocol. See `sharesOf`.\\n   */\\n  function balanceOf(address account) public view virtual override returns (uint256) {\\n    return getPooledDaiByShares(sharesOf(account));\\n  }\\n\\n  /**\\n   * @return the amount of shares that corresponds to `daiAmount` protocol-controlled DAI.\\n   * @param daiAmount The amount of protocol-controlled DAI.\\n   */\\n  function getSharesByPooledDai(uint256 daiAmount) public view returns (uint256) {\\n    // Prevent division by zero\\n    if (_totalPooledDai == 0) {\\n      return daiAmount;\\n    }\\n\\n    return daiAmount.mul(_totalLsdaiShares).div(_totalPooledDai);\\n  }\\n\\n  /**\\n   * @return the amount of DAI that corresponds to `sharesAmount` token shares.\\n   * @param sharesAmount The amount of LSDAI shares.\\n   */\\n  function getPooledDaiByShares(uint256 sharesAmount) public view returns (uint256) {\\n    return sharesAmount.mul(_totalPooledDai).div(_totalLsdaiShares);\\n  }\\n\\n  /**\\n   * @return the amount of tokens in existence.\\n   *\\n   * @dev Always equals to `_getTotalPooledDai()` since token amount\\n   * is pegged to the total amount of DAI controlled by the protocol.\\n   */\\n  function totalSupply() public view override returns (uint256) {\\n    return _getTotalPooledDai();\\n  }\\n\\n  /**\\n   * @return the amount of total LSDAI shares\\n   */\\n  function totalShares() public view returns (uint256) {\\n    return _totalLsdaiShares;\\n  }\\n\\n  /**\\n   * @dev rebase the total pooled DAI, user balance and total supply of LSDAI.\\n   * Can only be called by anyone\\n   */\\n  function rebase() external {\\n    uint256 chi = _getMostRecentChi();\\n    _rebase(chi, true);\\n  }\\n\\n  /**\\n   * @notice Sets deposit cap. Exclusive for the owner.\\n   */\\n  function setDepositCap(uint256 cap) public onlyOwner {\\n    depositCap = cap;\\n\\n    emit DepositCapSet(cap);\\n  }\\n\\n  /**\\n   * Returns DAI balance at the MakerDAO DSR contract.\\n   */\\n  function getTotalPotSharesValue() external view returns (uint256) {\\n    uint256 chi = (block.timestamp > pot.rho())\\n      ? (RMath.rpow(pot.dsr(), block.timestamp - pot.rho()) * pot.chi()) / RMath.RAY\\n      : pot.chi();\\n\\n    // total pooled DAI is the total shares times the chi\\n    return (_totalPotShares * chi) / RMath.RAY;\\n  }\\n\\n  ///////////////////////////////////////\\n  ///////// Internal functions /////////\\n  /////////////////////////////////////\\n\\n  /**\\n   * @dev Deposit DAI and mint LSDAI.\\n   * @param _to The address to mint LSDAI to.\\n   * @param _daiAmount The amount of DAI to deposit.\\n   * @return shares amount of LSDAI minted.\\n   */\\n  function _deposit(address _to, uint256 _daiAmount) internal returns (uint256 shares) {\\n    // Check if the deposit cap is reached\\n    if (depositCap > 0 && _getTotalPooledDai().add(_daiAmount) > depositCap) {\\n      revert LSDai__DepositCap();\\n    }\\n\\n    uint256 chi = _getMostRecentChi();\\n\\n    // Calculate the amount of pot shares to mint\\n    uint256 potSharesAmount = RMath.rdiv(_daiAmount, chi);\\n\\n    // Mint the shares to the user\\n    shares = getSharesByPooledDai(_daiAmount);\\n    _mintShares(_to, shares);\\n\\n    // Increase the total amount of DAI pooled\\n    _totalPooledDai = _totalPooledDai.add(_daiAmount);\\n    // Keep track of total pot shares controlled by LSDAI\\n    _totalPotShares = _totalPotShares.add(potSharesAmount);\\n\\n    // Mint LSDAI at 1:1 ratio to DAI\\n    emit Transfer(address(0), _to, _daiAmount);\\n\\n    // Join the DSR on behalf of the user\\n    daiJoin.join(address(this), _daiAmount);\\n    pot.join(potSharesAmount);\\n  }\\n\\n  /**\\n   * Withdraw shares back to DAI\\n   * @param _from The address to withdraw LSDAI from.\\n   * @param _to The address to withdraw DAI to.\\n   * @param _daiAmount The amount of LSDAI to withdraw. wad is denominated in (1/chi) * dai\\n   * @param _withdrawFee The fee to be charged on the withdrawal, in basis points.\\n   */\\n  function _withdraw(address _from, address _to, uint256 _daiAmount, uint256 _withdrawFee) internal returns (bool) {\\n    uint256 currentDaiBalance = balanceOf(_from);\\n    // Check if the user has enough LSDAI\\n    if (_daiAmount > currentDaiBalance) {\\n      revert LSDai__AmountExceedsBalance();\\n    }\\n    uint256 chi = _getMostRecentChi();\\n\\n    // Split the amount into the fee and the actual withdrawal\\n    uint256 feeAmount = _daiAmount.mul(_withdrawFee).div(10_000);\\n    // Amount going to the user\\n    uint256 withdrawAmount = _daiAmount.sub(feeAmount);\\n\\n    // Transfer the fee shares to fee recipient\\n    // and burn the withdraw shares from the user\\n    uint256 feeShares = getSharesByPooledDai(feeAmount);\\n    uint256 withdrawShares = getSharesByPooledDai(withdrawAmount);\\n\\n    // Decrease the total amount of DAI pooled\\n    _totalPooledDai = _totalPooledDai.sub(withdrawAmount);\\n\\n    _transferShares(_from, feeRecipient, feeShares);\\n    _burnShares(_from, withdrawShares);\\n\\n    // Withdraw from the DSR, roudning up ensures we get at least the amount of DAI requested\\n    uint256 withdrawPotShares = RMath.rdivup(withdrawAmount, chi);\\n    // Reduce the total pot shares controlled by LSDAI\\n    _totalPotShares = _totalPotShares.sub(withdrawPotShares);\\n\\n    // Burn LSDAI at 1:1 ratio to DAI\\n    emit Transfer(_from, address(0), withdrawAmount);\\n\\n    // Get back the DAI from the DSR to the contract\\n    pot.exit(withdrawPotShares);\\n\\n    daiJoin.exit(address(this), withdrawAmount); // wad is in dai units\\n\\n    // Send it over\\n    return dai.transfer(_to, withdrawAmount);\\n  }\\n\\n  /**\\n   * @notice Destroys `_sharesAmount` shares from `_account`'s holdings, decreasing the total amount of shares.\\n   * @dev This doesn't decrease the token total supply.\\n   *\\n   * Requirements:\\n   *\\n   * - `_account` cannot be the zero address.\\n   * - `_account` must hold at least `_sharesAmount` shares.\\n   * - the contract must not be paused.\\n   */\\n  function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\\n    if (_account == address(0)) {\\n      revert LSDai__BurnFromZeroAddress();\\n    }\\n\\n    uint256 accountShares = _shares[_account];\\n\\n    if (_sharesAmount > accountShares) {\\n      revert LSDai__SharesAmountExceedsBalance();\\n    }\\n\\n    uint256 preRebaseTokenAmount = getPooledDaiByShares(_sharesAmount);\\n\\n    newTotalShares = _totalLsdaiShares.sub(_sharesAmount);\\n\\n    _totalLsdaiShares = newTotalShares;\\n\\n    _shares[_account] = accountShares.sub(_sharesAmount);\\n\\n    uint256 postRebaseTokenAmount = getPooledDaiByShares(_sharesAmount);\\n\\n    emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\\n\\n    // Notice: we're not emitting a Transfer event to the zero address here since shares burn\\n    // works by redistributing the amount of tokens corresponding to the burned shares between\\n    // all other token holders. The total supply of the token doesn't change as the result.\\n    // This is equivalent to performing a send from `address` to each other token holder address,\\n    // but we cannot reflect this as it would require sending an unbounded number of events.\\n\\n    // We're emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\\n  }\\n\\n  /**\\n   * @dev See {IERC20-allowance}.\\n   */\\n  function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n    return _allowances[owner][spender];\\n  }\\n\\n  /**\\n   * @dev See {IERC20-approve}.\\n   *\\n   * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n   * `transferFrom`. This is semantically equivalent to an infinite approval.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   */\\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n    address owner = msg.sender;\\n    _approve(owner, spender, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @notice Moves `_amount` tokens from the caller's account to the `_recipient` account.\\n   *\\n   * @return a boolean value indicating whether the operation succeeded.\\n   * Emits a `Transfer` event.\\n   * Emits a `TransferShares` event.\\n   *\\n   * Requirements:\\n   *\\n   * - `_recipient` cannot be the zero address.\\n   * - the caller must have a balance of at least `_amount`.\\n   * - the contract must not be paused.\\n   *\\n   * @dev The `_amount` argument is the amount of tokens, not shares.\\n   */\\n  function transfer(address _recipient, uint256 _amount) public override returns (bool) {\\n    _transfer(msg.sender, _recipient, _amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\\n   * allowance mechanism. `_amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * @return a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a `Transfer` event.\\n   * Emits a `TransferShares` event.\\n   * Emits an `Approval` event indicating the updated allowance.\\n   *\\n   * Requirements:\\n   *\\n   * - `_sender` and `_recipient` cannot be the zero addresses.\\n   * - `_sender` must have a balance of at least `_amount`.\\n   * - the caller must have allowance for `_sender`'s tokens of at least `_amount`.\\n   * - the contract must not be paused.\\n   *\\n   * @dev The `_amount` argument is the amount of tokens, not shares.\\n   */\\n  function transferFrom(address _sender, address _recipient, uint256 _amount) external override returns (bool) {\\n    _spendAllowance(_sender, msg.sender, _amount);\\n    _transfer(_sender, _recipient, _amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @notice Moves `_sharesAmount` token shares from the caller's account to the `_recipient` account.\\n   *\\n   * @return amount of transferred tokens.\\n   * Emits a `TransferShares` event.\\n   * Emits a `Transfer` event.\\n   *\\n   * Requirements:\\n   *\\n   * - `_recipient` cannot be the zero address.\\n   * - the caller must have at least `_sharesAmount` shares.\\n   * - the contract must not be paused.\\n   *\\n   * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\\n   */\\n  function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\\n    _transferShares(msg.sender, _recipient, _sharesAmount);\\n    uint256 tokensAmount = getPooledDaiByShares(_sharesAmount);\\n    _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\\n    return tokensAmount;\\n  }\\n\\n  /**\\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\\n   *\\n   * This is an alternative to {approve} that can be used as a mitigation for\\n   * problems described in {IERC20-approve}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   */\\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n    address owner = msg.sender;\\n    _approve(owner, spender, allowance(owner, spender) + addedValue);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n   *\\n   * This is an alternative to {approve} that can be used as a mitigation for\\n   * problems described in {IERC20-approve}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   * - `spender` must have allowance for the caller of at least\\n   * `subtractedValue`.\\n   */\\n  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n    address owner = msg.sender;\\n    uint256 currentAllowance = allowance(owner, spender);\\n    require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n    unchecked {\\n      _approve(owner, spender, currentAllowance - subtractedValue);\\n    }\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\\n   *\\n   * @return amount of transferred tokens.\\n   * Emits a `TransferShares` event.\\n   * Emits a `Transfer` event.\\n   *\\n   * Requirements:\\n   *\\n   * - `_sender` and `_recipient` cannot be the zero addresses.\\n   * - `_sender` must have at least `_sharesAmount` shares.\\n   * - the caller must have allowance for `_sender`'s tokens of at least `getPooledDaiByShares(_sharesAmount)`.\\n   * - the contract must not be paused.\\n   *\\n   * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\\n   */\\n  function transferSharesFrom(address _sender, address _recipient, uint256 _sharesAmount) external returns (uint256) {\\n    uint256 tokensAmount = getPooledDaiByShares(_sharesAmount);\\n    _spendAllowance(_sender, msg.sender, tokensAmount);\\n    _transferShares(_sender, _recipient, _sharesAmount);\\n    _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\\n    return tokensAmount;\\n  }\\n\\n  /**\\n   * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\\n   * Emits a `Transfer` event.\\n   * Emits a `TransferShares` event.\\n   */\\n  function _transfer(address _sender, address _recipient, uint256 _amount) internal {\\n    uint256 _sharesToTransfer = getSharesByPooledDai(_amount);\\n    _transferShares(_sender, _recipient, _sharesToTransfer);\\n    _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\\n  }\\n\\n  /**\\n   * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\\n   *\\n   * Requirements:\\n   *\\n   * - `_sender` cannot be the zero address.\\n   * - `_recipient` cannot be the zero address or the `LSDai` token contract itself\\n   * - `_sender` must hold at least `_sharesAmount` shares.\\n   * - the contract must not be paused.\\n   */\\n  function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\\n    if (_sender == address(0)) {\\n      revert LSDai__TransferFromZeroAddress();\\n    }\\n    if (_recipient == address(0)) {\\n      revert LSDai__TransferToZeroAddress();\\n    }\\n\\n    if (_recipient == address(this)) {\\n      revert LSDai__TransferToLSDaiContract();\\n    }\\n\\n    // _whenNotStopped();\\n\\n    uint256 currentSenderShares = _shares[_sender];\\n\\n    if (_sharesAmount > currentSenderShares) {\\n      revert LSDai__SharesAmountExceedsBalance();\\n    }\\n\\n    _shares[_sender] = currentSenderShares.sub(_sharesAmount);\\n    _shares[_recipient] = _shares[_recipient].add(_sharesAmount);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n   *\\n   * This internal function is equivalent to `approve`, and can be used to\\n   * e.g. set automatic allowances for certain subsystems, etc.\\n   *\\n   * Emits an {Approval} event.\\n   *\\n   * Requirements:\\n   *\\n   * - `owner` cannot be the zero address.\\n   * - `spender` cannot be the zero address.\\n   */\\n  function _approve(address owner, address spender, uint256 amount) internal {\\n    require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n    require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n    _allowances[owner][spender] = amount;\\n    emit Approval(owner, spender, amount);\\n  }\\n\\n  /**\\n   * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n   *\\n   * Does not update the allowance amount in case of infinite allowance.\\n   * Revert if not enough allowance is available.\\n   *\\n   * Might emit an {Approval} event.\\n   */\\n  function _spendAllowance(address owner, address spender, uint256 amount) internal {\\n    uint256 currentAllowance = allowance(owner, spender);\\n    if (currentAllowance != type(uint256).max) {\\n      require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n      unchecked {\\n        _approve(owner, spender, currentAllowance - amount);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Emits {Transfer} and {TransferShares} events\\n   */\\n  function _emitTransferEvents(address _from, address _to, uint256 _tokenAmount, uint256 _sharesAmount) internal {\\n    emit Transfer(_from, _to, _tokenAmount);\\n    emit TransferShares(_from, _to, _sharesAmount);\\n  }\\n\\n  /**\\n   * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\\n   * @dev This doesn't increase the token total supply.\\n   *\\n   * NB: The method doesn't check protocol pause relying on the external enforcement.\\n   *\\n   * Requirements:\\n   *\\n   * - `_to` cannot be the zero address.\\n   * - the contract must not be paused.\\n   */\\n  function _mintShares(address _to, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\\n    if (_to == address(0)) {\\n      revert LSDai__TransferToZeroAddress();\\n    }\\n\\n    newTotalShares = _totalLsdaiShares.add(_sharesAmount);\\n\\n    /// @todo research a better place for the storage location for the total shares\\n    _totalLsdaiShares = newTotalShares;\\n\\n    _shares[_to] = _shares[_to].add(_sharesAmount);\\n  }\\n\\n  /**\\n   * @dev updates the total amount of DAI controlled by LSDai.\\n   * @param chi If overrideChi is greater than 0, it will use that chi instead of the most recent chi.\\n   * @param requireSuccess If true, it will revert if the delta pooled DAI underflows or overflows.\\n   * It also calcuates the fees on the accrued interest and appends them to the protocol fee pot.chi();\\n   */\\n  function _rebase(uint256 chi, bool requireSuccess) internal {\\n    uint256 preRebaseTotalPooledDai = _totalPooledDai;\\n    // total pooled DAI is the total shares times the chi\\n    uint256 postRebaseTotalPooledDai = (_totalPotShares * chi) / RMath.RAY;\\n\\n    // Change in total pooled DAI is the total pooled DAI before fees minus the total pooled DAI after fees\\n    (bool isOk, uint256 deltaTotalPooledDai) = postRebaseTotalPooledDai.trySub(_totalPooledDai); // Interest earned since last rebase\\n\\n    // Revert with custom error in event of underflow/overflow\\n    if (isOk == false && requireSuccess == true) {\\n      revert LSDai__RebaseOverflow(preRebaseTotalPooledDai, postRebaseTotalPooledDai);\\n    } else if (isOk == false) {\\n      return;\\n    }\\n\\n    // Update total pooled DAI\\n    _totalPooledDai = postRebaseTotalPooledDai;\\n\\n    // Get the fees on accrued interest\\n    uint256 protocolFeeDaiAmount = _calcInterestFees(deltaTotalPooledDai);\\n\\n    // Mint LSdai shares to the protocol\\n    uint256 protocolFeeLsdaiShares = getSharesByPooledDai(protocolFeeDaiAmount);\\n    _mintShares(feeRecipient, protocolFeeLsdaiShares);\\n  }\\n\\n  /**\\n   * Returns the total supply of LSDAI by converting the DSR shares to DAI\\n   */\\n  function _getTotalPooledDai() internal view returns (uint256) {\\n    return _totalPooledDai;\\n  }\\n\\n  /**\\n   * @dev Calculates the fees on the accrued interest\\n   * @param _daiAmount The change in total pooled DAI since the last rebase\\n   */\\n  function _calcInterestFees(uint256 _daiAmount) internal view returns (uint256 protocolFee) {\\n    if (interestFee == 0) {\\n      return 0;\\n    }\\n\\n    protocolFee = _daiAmount.mul(interestFee).div(10_000);\\n  }\\n\\n  /**\\n   * @dev returns most recent chi (the rate accumulator) by calling drip if necessary\\n   */\\n  function _getMostRecentChi() internal returns (uint256) {\\n    if (block.timestamp > pot.rho()) {\\n      return pot.drip();\\n    }\\n    return pot.chi();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable {\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    _checkOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view virtual returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if the sender is not the owner.\\n   */\\n  function _checkOwner() internal view virtual {\\n    require(owner() == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby disabling any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    _transferOwnership(address(0));\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n    _transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Internal function without access restriction.\\n   */\\n  function _transferOwnership(address newOwner) internal virtual {\\n    address oldOwner = _owner;\\n    _owner = newOwner;\\n    emit OwnershipTransferred(oldOwner, newOwner);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"LSDai__AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LSDai__AmountExceedsBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LSDai__BurnFromZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LSDai__DepositCap\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LSDai__FeeRecipientZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LSDai__InterestFeeHigh\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LSDai__MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"preRebaseTotalPooledDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"postRebaseTotalPooledDai\",\"type\":\"uint256\"}],\"name\":\"LSDai__RebaseOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LSDai__SharesAmountExceedsBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LSDai__TransferFromZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LSDai__TransferToLSDaiContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LSDai__TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LSDai__WithdrawalFeeHigh\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositCap\",\"type\":\"uint256\"}],\"name\":\"DepositCapSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"FeeRecipientSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestFee\",\"type\":\"uint256\"}],\"name\":\"InterestFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"preRebaseTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"postRebaseTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesAmount\",\"type\":\"uint256\"}],\"name\":\"SharesBurnt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesValue\",\"type\":\"uint256\"}],\"name\":\"TransferShares\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawalFee\",\"type\":\"uint256\"}],\"name\":\"WithdrawalFeeSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dai\",\"outputs\":[{\"internalType\":\"contract IDai\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daiJoin\",\"outputs\":[{\"internalType\":\"contract IJoin\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"daiAmount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"daiAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"permitNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"permitExpiry\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"permitV\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"permitR\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"permitS\",\"type\":\"bytes32\"}],\"name\":\"depositWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesAmount\",\"type\":\"uint256\"}],\"name\":\"getPooledDaiByShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"daiAmount\",\"type\":\"uint256\"}],\"name\":\"getSharesByPooledDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalPotSharesValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_interestFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawalFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pot\",\"outputs\":[{\"internalType\":\"contract IPot\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"potShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"setDepositCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"setFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setInterestFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setWithdrawalFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"sharesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sharesAmount\",\"type\":\"uint256\"}],\"name\":\"transferShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sharesAmount\",\"type\":\"uint256\"}],\"name\":\"transferSharesFrom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vat\",\"outputs\":[{\"internalType\":\"contract IVat\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"daiAmount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"daiAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawTo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LSDai", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}