{"SourceCode": "# @version 0.3.9\r\n\r\n\"\"\"\r\n@title CurveTricryptoOptimizedWETH\r\n@author Curve.Fi\r\n@license Copyright (c) Curve.Fi, 2020-2023 - all rights reserved\r\n@notice A Curve AMM pool for 3 unpegged assets (e.g. ETH, BTC, USD).\r\n@dev All prices in the AMM are with respect to the first token in the pool.\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\nimplements: ERC20  # <--------------------- AMM contract is also the LP token.\r\n\r\n# --------------------------------- Interfaces -------------------------------\r\n\r\ninterface Math:\r\n    def geometric_mean(_x: uint256[N_COINS]) -> uint256: view\r\n    def wad_exp(_power: int256) -> uint256: view\r\n    def cbrt(x: uint256) -> uint256: view\r\n    def reduction_coefficient(\r\n        x: uint256[N_COINS], fee_gamma: uint256\r\n    ) -> uint256: view\r\n    def newton_D(\r\n        ANN: uint256,\r\n        gamma: uint256,\r\n        x_unsorted: uint256[N_COINS],\r\n        K0_prev: uint256\r\n    ) -> uint256: view\r\n    def get_y(\r\n        ANN: uint256,\r\n        gamma: uint256,\r\n        x: uint256[N_COINS],\r\n        D: uint256,\r\n        i: uint256,\r\n    ) -> uint256[2]: view\r\n    def get_p(\r\n        _xp: uint256[N_COINS], _D: uint256, _A_gamma: uint256[2],\r\n    ) -> uint256[N_COINS-1]: view\r\n\r\ninterface WETH:\r\n    def deposit(): payable\r\n    def withdraw(_amount: uint256): nonpayable\r\n\r\ninterface Factory:\r\n    def admin() -> address: view\r\n    def fee_receiver() -> address: view\r\n    def views_implementation() -> address: view\r\n\r\ninterface Views:\r\n    def calc_token_amount(\r\n        amounts: uint256[N_COINS], deposit: bool, swap: address\r\n    ) -> uint256: view\r\n    def get_dy(\r\n        i: uint256, j: uint256, dx: uint256, swap: address\r\n    ) -> uint256: view\r\n    def get_dx(\r\n        i: uint256, j: uint256, dy: uint256, swap: address\r\n    ) -> uint256: view\r\n\r\n\r\n# ------------------------------- Events -------------------------------------\r\n\r\nevent Transfer:\r\n    sender: indexed(address)\r\n    receiver: indexed(address)\r\n    value: uint256\r\n\r\nevent Approval:\r\n    owner: indexed(address)\r\n    spender: indexed(address)\r\n    value: uint256\r\n\r\nevent TokenExchange:\r\n    buyer: indexed(address)\r\n    sold_id: uint256\r\n    tokens_sold: uint256\r\n    bought_id: uint256\r\n    tokens_bought: uint256\r\n    fee: uint256\r\n    packed_price_scale: uint256\r\n\r\nevent AddLiquidity:\r\n    provider: indexed(address)\r\n    token_amounts: uint256[N_COINS]\r\n    fee: uint256\r\n    token_supply: uint256\r\n    packed_price_scale: uint256\r\n\r\nevent RemoveLiquidity:\r\n    provider: indexed(address)\r\n    token_amounts: uint256[N_COINS]\r\n    token_supply: uint256\r\n\r\nevent RemoveLiquidityOne:\r\n    provider: indexed(address)\r\n    token_amount: uint256\r\n    coin_index: uint256\r\n    coin_amount: uint256\r\n    approx_fee: uint256\r\n    packed_price_scale: uint256\r\n\r\nevent CommitNewParameters:\r\n    deadline: indexed(uint256)\r\n    mid_fee: uint256\r\n    out_fee: uint256\r\n    fee_gamma: uint256\r\n    allowed_extra_profit: uint256\r\n    adjustment_step: uint256\r\n    ma_time: uint256\r\n\r\nevent NewParameters:\r\n    mid_fee: uint256\r\n    out_fee: uint256\r\n    fee_gamma: uint256\r\n    allowed_extra_profit: uint256\r\n    adjustment_step: uint256\r\n    ma_time: uint256\r\n\r\nevent RampAgamma:\r\n    initial_A: uint256\r\n    future_A: uint256\r\n    initial_gamma: uint256\r\n    future_gamma: uint256\r\n    initial_time: uint256\r\n    future_time: uint256\r\n\r\nevent StopRampA:\r\n    current_A: uint256\r\n    current_gamma: uint256\r\n    time: uint256\r\n\r\nevent ClaimAdminFee:\r\n    admin: indexed(address)\r\n    tokens: uint256\r\n\r\n\r\n# ----------------------- Storage/State Variables ----------------------------\r\n\r\nWETH20: public(immutable(address))\r\n\r\nN_COINS: constant(uint256) = 3\r\nPRECISION: constant(uint256) = 10**18  # <------- The precision to convert to.\r\nA_MULTIPLIER: constant(uint256) = 10000\r\npacked_precisions: uint256\r\n\r\nMATH: public(immutable(Math))\r\ncoins: public(immutable(address[N_COINS]))\r\nfactory: public(address)\r\n\r\nprice_scale_packed: uint256  # <------------------------ Internal price scale.\r\nprice_oracle_packed: uint256  # <------- Price target given by moving average.\r\n\r\nlast_prices_packed: uint256\r\nlast_prices_timestamp: public(uint256)\r\n\r\ninitial_A_gamma: public(uint256)\r\ninitial_A_gamma_time: public(uint256)\r\n\r\nfuture_A_gamma: public(uint256)\r\nfuture_A_gamma_time: public(uint256)  # <------ Time when ramping is finished.\r\n#         This value is 0 (default) when pool is first deployed, and only gets\r\n#        populated by block.timestamp + future_time in `ramp_A_gamma` when the\r\n#                      ramping process is initiated. After ramping is finished\r\n#      (i.e. self.future_A_gamma_time < block.timestamp), the variable is left\r\n#                                                            and not set to 0.\r\n\r\nbalances: public(uint256[N_COINS])\r\nD: public(uint256)\r\nxcp_profit: public(uint256)\r\nxcp_profit_a: public(uint256)  # <--- Full profit at last claim of admin fees.\r\n\r\nvirtual_price: public(uint256)  # <------ Cached (fast to read) virtual price.\r\n#                          The cached `virtual_price` is also used internally.\r\n\r\n# -------------- Params that affect how price_scale get adjusted -------------\r\n\r\npacked_rebalancing_params: public(uint256)  # <---------- Contains rebalancing\r\n#               parameters allowed_extra_profit, adjustment_step, and ma_time.\r\n\r\nfuture_packed_rebalancing_params: uint256\r\n\r\n# ---------------- Fee params that determine dynamic fees --------------------\r\n\r\npacked_fee_params: public(uint256)  # <---- Packs mid_fee, out_fee, fee_gamma.\r\nfuture_packed_fee_params: uint256\r\n\r\nADMIN_FEE: public(constant(uint256)) = 5 * 10**9  # <----- 50% of earned fees.\r\nMIN_FEE: constant(uint256) = 5 * 10**5  # <-------------------------- 0.5 BPS.\r\nMAX_FEE: constant(uint256) = 10 * 10**9\r\nNOISE_FEE: constant(uint256) = 10**5  # <---------------------------- 0.1 BPS.\r\n\r\n# ----------------------- Admin params ---------------------------------------\r\n\r\nadmin_actions_deadline: public(uint256)\r\n\r\nADMIN_ACTIONS_DELAY: constant(uint256) = 3 * 86400\r\nMIN_RAMP_TIME: constant(uint256) = 86400\r\n\r\nMIN_A: constant(uint256) = N_COINS**N_COINS * A_MULTIPLIER / 100\r\nMAX_A: constant(uint256) = 1000 * A_MULTIPLIER * N_COINS**N_COINS\r\nMAX_A_CHANGE: constant(uint256) = 10\r\nMIN_GAMMA: constant(uint256) = 10**10\r\nMAX_GAMMA: constant(uint256) = 5 * 10**16\r\n\r\nPRICE_SIZE: constant(uint128) = 256 / (N_COINS - 1)\r\nPRICE_MASK: constant(uint256) = 2**PRICE_SIZE - 1\r\n\r\n# ----------------------- ERC20 Specific vars --------------------------------\r\n\r\nname: public(immutable(String[64]))\r\nsymbol: public(immutable(String[32]))\r\ndecimals: public(constant(uint8)) = 18\r\nversion: public(constant(String[8])) = \"v2.0.0\"\r\n\r\nbalanceOf: public(HashMap[address, uint256])\r\nallowance: public(HashMap[address, HashMap[address, uint256]])\r\ntotalSupply: public(uint256)\r\nnonces: public(HashMap[address, uint256])\r\n\r\nEIP712_TYPEHASH: constant(bytes32) = keccak256(\r\n    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\"\r\n)\r\nEIP2612_TYPEHASH: constant(bytes32) = keccak256(\r\n    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\r\n)\r\nVERSION_HASH: constant(bytes32) = keccak256(version)\r\nNAME_HASH: immutable(bytes32)\r\nCACHED_CHAIN_ID: immutable(uint256)\r\nsalt: public(immutable(bytes32))\r\nCACHED_DOMAIN_SEPARATOR: immutable(bytes32)\r\n\r\n\r\n# ----------------------- Contract -------------------------------------------\r\n\r\n@external\r\ndef __init__(\r\n    _name: String[64],\r\n    _symbol: String[32],\r\n    _coins: address[N_COINS],\r\n    _math: address,\r\n    _weth: address,\r\n    _salt: bytes32,\r\n    packed_precisions: uint256,\r\n    packed_A_gamma: uint256,\r\n    packed_fee_params: uint256,\r\n    packed_rebalancing_params: uint256,\r\n    packed_prices: uint256,\r\n):\r\n\r\n    WETH20 = _weth\r\n    MATH = Math(_math)\r\n\r\n    self.factory = msg.sender\r\n\r\n    name = _name\r\n    symbol = _symbol\r\n    coins = _coins\r\n\r\n    self.packed_precisions = packed_precisions  # <------- Precisions of coins\r\n    #                            are calculated as 10**(18 - coin.decimals()).\r\n\r\n    self.initial_A_gamma = packed_A_gamma  # <------------------- A and gamma.\r\n    self.future_A_gamma = packed_A_gamma\r\n\r\n    self.packed_rebalancing_params = packed_rebalancing_params  # <-- Contains\r\n    #               rebalancing params: allowed_extra_profit, adjustment_step,\r\n    #                                                         and ma_exp_time.\r\n\r\n    self.packed_fee_params = packed_fee_params  # <-------------- Contains Fee\r\n    #                                  params: mid_fee, out_fee and fee_gamma.\r\n\r\n    self.price_scale_packed = packed_prices\r\n    self.price_oracle_packed = packed_prices\r\n    self.last_prices_packed = packed_prices\r\n    self.last_prices_timestamp = block.timestamp\r\n    self.xcp_profit_a = 10**18\r\n\r\n    #         Cache DOMAIN_SEPARATOR. If chain.id is not CACHED_CHAIN_ID, then\r\n    #     DOMAIN_SEPARATOR will be re-calculated each time `permit` is called.\r\n    #                   Otherwise, it will always use CACHED_DOMAIN_SEPARATOR.\r\n    #                       see: `_domain_separator()` for its implementation.\r\n    NAME_HASH = keccak256(name)\r\n    salt = _salt\r\n    CACHED_CHAIN_ID = chain.id\r\n    CACHED_DOMAIN_SEPARATOR = keccak256(\r\n        _abi_encode(\r\n            EIP712_TYPEHASH,\r\n            NAME_HASH,\r\n            VERSION_HASH,\r\n            chain.id,\r\n            self,\r\n            salt,\r\n        )\r\n    )\r\n\r\n    log Transfer(empty(address), self, 0)  # <------- Fire empty transfer from\r\n    #                                       0x0 to self for indexers to catch.\r\n\r\n\r\n# ------------------- Token transfers in and out of the AMM ------------------\r\n\r\n\r\n@payable\r\n@external\r\ndef __default__():\r\n    if msg.value > 0:\r\n        assert WETH20 in coins\r\n\r\n\r\n@internal\r\ndef _transfer_in(\r\n    _coin: address,\r\n    dx: uint256,\r\n    dy: uint256,\r\n    mvalue: uint256,\r\n    callbacker: address,\r\n    callback_sig: bytes32,\r\n    sender: address,\r\n    receiver: address,\r\n    use_eth: bool\r\n):\r\n    \"\"\"\r\n    @notice Transfers `_coin` from `sender` to `self` and calls `callback_sig`\r\n            if it is not empty.\r\n    @dev The callback sig must have the following args:\r\n         sender: address\r\n         receiver: address\r\n         coin: address\r\n         dx: uint256\r\n         dy: uint256\r\n    @params _coin address of the coin to transfer in.\r\n    @params dx amount of `_coin` to transfer into the pool.\r\n    @params dy amount of `_coin` to transfer out of the pool.\r\n    @params mvalue msg.value if the transfer is ETH, 0 otherwise.\r\n    @params callbacker address to call `callback_sig` on.\r\n    @params callback_sig signature of the callback function.\r\n    @params sender address to transfer `_coin` from.\r\n    @params receiver address to transfer `_coin` to.\r\n    @params use_eth True if the transfer is ETH, False otherwise.\r\n    \"\"\"\r\n\r\n    if use_eth and _coin == WETH20:\r\n        assert mvalue == dx  # dev: incorrect eth amount\r\n    else:\r\n        assert mvalue == 0  # dev: nonzero eth amount\r\n\r\n        if callback_sig == empty(bytes32):\r\n\r\n            assert ERC20(_coin).transferFrom(\r\n                sender, self, dx, default_return_value=True\r\n            )\r\n\r\n        else:\r\n\r\n            # --------- This part of the _transfer_in logic is only accessible\r\n            #                                                    by _exchange.\r\n\r\n            #                 First call callback logic and then check if pool\r\n            #                  gets dx amounts of _coins[i], revert otherwise.\r\n            b: uint256 = ERC20(_coin).balanceOf(self)\r\n            raw_call(\r\n                callbacker,\r\n                concat(\r\n                    slice(callback_sig, 0, 4),\r\n                    _abi_encode(sender, receiver, _coin, dx, dy)\r\n                )\r\n            )\r\n            assert ERC20(_coin).balanceOf(self) - b == dx  # dev: callback didn't give us coins\r\n            #                                          ^------ note: dx cannot\r\n            #                   be 0, so the contract MUST receive some _coin.\r\n\r\n        if _coin == WETH20:\r\n            WETH(WETH20).withdraw(dx)  # <--------- if WETH was transferred in\r\n            #           previous step and `not use_eth`, withdraw WETH to ETH.\r\n\r\n\r\n@internal\r\ndef _transfer_out(\r\n    _coin: address, _amount: uint256, use_eth: bool, receiver: address\r\n):\r\n    \"\"\"\r\n    @notice Transfer a single token from the pool to receiver.\r\n    @dev This function is called by `remove_liquidity` and\r\n         `remove_liquidity_one` and `_exchange` methods.\r\n    @params _coin Address of the token to transfer out\r\n    @params _amount Amount of token to transfer out\r\n    @params use_eth Whether to transfer ETH or not\r\n    @params receiver Address to send the tokens to\r\n    \"\"\"\r\n\r\n    if use_eth and _coin == WETH20:\r\n        raw_call(receiver, b\"\", value=_amount)\r\n    else:\r\n        if _coin == WETH20:\r\n            WETH(WETH20).deposit(value=_amount)\r\n\r\n        assert ERC20(_coin).transfer(\r\n            receiver, _amount, default_return_value=True\r\n        )\r\n\r\n\r\n# -------------------------- AMM Main Functions ------------------------------\r\n\r\n\r\n@payable\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef exchange(\r\n    i: uint256,\r\n    j: uint256,\r\n    dx: uint256,\r\n    min_dy: uint256,\r\n    use_eth: bool = False,\r\n    receiver: address = msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Exchange using wrapped native token by default\r\n    @param i Index value for the input coin\r\n    @param j Index value for the output coin\r\n    @param dx Amount of input coin being swapped in\r\n    @param min_dy Minimum amount of output coin to receive\r\n    @param use_eth True if the input coin is native token, False otherwise\r\n    @param receiver Address to send the output coin to. Default is msg.sender\r\n    @return uint256 Amount of tokens at index j received by the `receiver\r\n    \"\"\"\r\n    return self._exchange(\r\n        msg.sender,\r\n        msg.value,\r\n        i,\r\n        j,\r\n        dx,\r\n        min_dy,\r\n        use_eth,\r\n        receiver,\r\n        empty(address),\r\n        empty(bytes32)\r\n    )\r\n\r\n\r\n@payable\r\n@external\r\n@nonreentrant('lock')\r\ndef exchange_underlying(\r\n    i: uint256,\r\n    j: uint256,\r\n    dx: uint256,\r\n    min_dy: uint256,\r\n    receiver: address = msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Exchange using native token transfers.\r\n    @param i Index value for the input coin\r\n    @param j Index value for the output coin\r\n    @param dx Amount of input coin being swapped in\r\n    @param min_dy Minimum amount of output coin to receive\r\n    @param receiver Address to send the output coin to. Default is msg.sender\r\n    @return uint256 Amount of tokens at index j received by the `receiver\r\n    \"\"\"\r\n    return self._exchange(\r\n        msg.sender,\r\n        msg.value,\r\n        i,\r\n        j,\r\n        dx,\r\n        min_dy,\r\n        True,\r\n        receiver,\r\n        empty(address),\r\n        empty(bytes32)\r\n    )\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef exchange_extended(\r\n    i: uint256,\r\n    j: uint256,\r\n    dx: uint256,\r\n    min_dy: uint256,\r\n    use_eth: bool,\r\n    sender: address,\r\n    receiver: address,\r\n    cb: bytes32\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Exchange with callback method.\r\n    @dev This method does not allow swapping in native token, but does allow\r\n         swaps that transfer out native token from the pool.\r\n    @dev Does not allow flashloans\r\n    @dev One use-case is to reduce the number of redundant ERC20 token\r\n         transfers in zaps.\r\n    @param i Index value for the input coin\r\n    @param j Index value for the output coin\r\n    @param dx Amount of input coin being swapped in\r\n    @param min_dy Minimum amount of output coin to receive\r\n    @param use_eth True if output is native token, False otherwise\r\n    @param sender Address to transfer input coin from\r\n    @param receiver Address to send the output coin to\r\n    @param cb Callback signature\r\n    @return uint256 Amount of tokens at index j received by the `receiver`\r\n    \"\"\"\r\n\r\n    assert cb != empty(bytes32)  # dev: No callback specified\r\n    return self._exchange(\r\n        sender, 0, i, j, dx, min_dy, use_eth, receiver, msg.sender, cb\r\n    )  # callbacker should never be self ------------------^\r\n\r\n\r\n@payable\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef add_liquidity(\r\n    amounts: uint256[N_COINS],\r\n    min_mint_amount: uint256,\r\n    use_eth: bool = False,\r\n    receiver: address = msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Adds liquidity into the pool.\r\n    @param amounts Amounts of each coin to add.\r\n    @param min_mint_amount Minimum amount of LP to mint.\r\n    @param use_eth True if native token is being added to the pool.\r\n    @param receiver Address to send the LP tokens to. Default is msg.sender\r\n    @return uint256 Amount of LP tokens received by the `receiver\r\n    \"\"\"\r\n\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n    xp: uint256[N_COINS] = self.balances\r\n    amountsp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    xx: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    d_token: uint256 = 0\r\n    d_token_fee: uint256 = 0\r\n    old_D: uint256 = 0\r\n\r\n    assert amounts[0] + amounts[1] + amounts[2] > 0  # dev: no coins to add\r\n\r\n    # --------------------- Get prices, balances -----------------------------\r\n\r\n    precisions: uint256[N_COINS] = self._unpack(self.packed_precisions)\r\n    packed_price_scale: uint256 = self.price_scale_packed\r\n    price_scale: uint256[N_COINS-1] = self._unpack_prices(packed_price_scale)\r\n\r\n    # -------------------------------------- Update balances and calculate xp.\r\n    xp_old: uint256[N_COINS] = xp\r\n    for i in range(N_COINS):\r\n        bal: uint256 = xp[i] + amounts[i]\r\n        xp[i] = bal\r\n        self.balances[i] = bal\r\n    xx = xp\r\n\r\n    xp[0] *= precisions[0]\r\n    xp_old[0] *= precisions[0]\r\n    for i in range(1, N_COINS):\r\n        xp[i] = unsafe_div(xp[i] * price_scale[i-1] * precisions[i], PRECISION)\r\n        xp_old[i] = unsafe_div(\r\n            xp_old[i] * unsafe_mul(price_scale[i-1], precisions[i]),\r\n            PRECISION\r\n        )\r\n\r\n    # ---------------- transferFrom token into the pool ----------------------\r\n\r\n    for i in range(N_COINS):\r\n\r\n        if amounts[i] > 0:\r\n\r\n            if coins[i] == WETH20:\r\n\r\n                self._transfer_in(\r\n                    coins[i],\r\n                    amounts[i],\r\n                    0,  # <-----------------------------------\r\n                    msg.value,  #                             | No callbacks\r\n                    empty(address),  # <----------------------| for\r\n                    empty(bytes32),  # <----------------------| add_liquidity.\r\n                    msg.sender,  #                            |\r\n                    empty(address),  # <-----------------------\r\n                    use_eth\r\n                )\r\n\r\n            else:\r\n\r\n                self._transfer_in(\r\n                    coins[i],\r\n                    amounts[i],\r\n                    0,\r\n                    0,  # <----------------- mvalue = 0 if coin is not WETH20.\r\n                    empty(address),\r\n                    empty(bytes32),\r\n                    msg.sender,\r\n                    empty(address),\r\n                    False  # <-------- use_eth is False if coin is not WETH20.\r\n                )\r\n\r\n            amountsp[i] = xp[i] - xp_old[i]\r\n\r\n    # -------------------- Calculate LP tokens to mint -----------------------\r\n\r\n    if self.future_A_gamma_time > block.timestamp:  # <--- A_gamma is ramping.\r\n\r\n        # ----- Recalculate the invariant if A or gamma are undergoing a ramp.\r\n        old_D = MATH.newton_D(A_gamma[0], A_gamma[1], xp_old, 0)\r\n\r\n    else:\r\n\r\n        old_D = self.D\r\n\r\n    D: uint256 = MATH.newton_D(A_gamma[0], A_gamma[1], xp, 0)\r\n\r\n    token_supply: uint256 = self.totalSupply\r\n    if old_D > 0:\r\n        d_token = token_supply * D / old_D - token_supply\r\n    else:\r\n        d_token = self.get_xcp(D)  # <------------------------- Making initial\r\n        #                                            virtual price equal to 1.\r\n\r\n    assert d_token > 0  # dev: nothing minted\r\n\r\n    if old_D > 0:\r\n\r\n        d_token_fee = (\r\n            self._calc_token_fee(amountsp, xp) * d_token / 10**10 + 1\r\n        )\r\n\r\n        d_token -= d_token_fee\r\n        token_supply += d_token\r\n        self.mint(receiver, d_token)\r\n\r\n        packed_price_scale = self.tweak_price(A_gamma, xp, D, 0)\r\n\r\n    else:\r\n\r\n        self.D = D\r\n        self.virtual_price = 10**18\r\n        self.xcp_profit = 10**18\r\n        self.xcp_profit_a = 10**18\r\n        self.mint(receiver, d_token)\r\n\r\n    assert d_token >= min_mint_amount, \"Slippage\"\r\n\r\n    log AddLiquidity(\r\n        receiver, amounts, d_token_fee, token_supply, packed_price_scale\r\n    )\r\n\r\n    self._claim_admin_fees()  # <--------------------------- Claim admin fees.\r\n\r\n    return d_token\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef remove_liquidity(\r\n    _amount: uint256,\r\n    min_amounts: uint256[N_COINS],\r\n    use_eth: bool = False,\r\n    receiver: address = msg.sender,\r\n    claim_admin_fees: bool = True,\r\n) -> uint256[N_COINS]:\r\n    \"\"\"\r\n    @notice This withdrawal method is very safe, does no complex math since\r\n            tokens are withdrawn in balanced proportions. No fees are charged.\r\n    @param _amount Amount of LP tokens to burn\r\n    @param min_amounts Minimum amounts of tokens to withdraw\r\n    @param use_eth Whether to withdraw ETH or not\r\n    @param receiver Address to send the withdrawn tokens to\r\n    @param claim_admin_fees If True, call self._claim_admin_fees(). Default is True.\r\n    @return uint256[3] Amount of pool tokens received by the `receiver`\r\n    \"\"\"\r\n    amount: uint256 = _amount\r\n    balances: uint256[N_COINS] = self.balances\r\n    d_balances: uint256[N_COINS] = empty(uint256[N_COINS])\r\n\r\n    if claim_admin_fees:\r\n        self._claim_admin_fees()  # <------ We claim fees so that the DAO gets\r\n        #         paid before withdrawal. In emergency cases, set it to False.\r\n\r\n    # -------------------------------------------------------- Burn LP tokens.\r\n\r\n    total_supply: uint256 = self.totalSupply  # <------ Get totalSupply before\r\n    self.burnFrom(msg.sender, _amount)  # ---- reducing it with self.burnFrom.\r\n\r\n    # There are two cases for withdrawing tokens from the pool.\r\n    #   Case 1. Withdrawal does not empty the pool.\r\n    #           In this situation, D is adjusted proportional to the amount of\r\n    #           LP tokens burnt. ERC20 tokens transferred is proportional\r\n    #           to : (AMM balance * LP tokens in) / LP token total supply\r\n    #   Case 2. Withdrawal empties the pool.\r\n    #           In this situation, all tokens are withdrawn and the invariant\r\n    #           is reset.\r\n\r\n    if amount == total_supply:  # <----------------------------------- Case 2.\r\n\r\n        for i in range(N_COINS):\r\n\r\n            d_balances[i] = balances[i]\r\n            self.balances[i] = 0  # <------------------------- Empty the pool.\r\n\r\n    else:  # <-------------------------------------------------------- Case 1.\r\n\r\n        amount -= 1  # <---- To prevent rounding errors, favor LPs a tiny bit.\r\n\r\n        for i in range(N_COINS):\r\n            d_balances[i] = balances[i] * amount / total_supply\r\n            assert d_balances[i] >= min_amounts[i]\r\n            self.balances[i] = balances[i] - d_balances[i]\r\n            balances[i] = d_balances[i]  # <-- Now it's the amounts going out.\r\n\r\n    D: uint256 = self.D\r\n    self.D = D - unsafe_div(D * amount, total_supply)  # <----------- Reduce D\r\n    #      proportional to the amount of tokens leaving. Since withdrawals are\r\n    #       balanced, this is a simple subtraction. If amount == total_supply,\r\n    #                                                             D will be 0.\r\n\r\n    # ---------------------------------- Transfers ---------------------------\r\n\r\n    for i in range(N_COINS):\r\n        self._transfer_out(coins[i], d_balances[i], use_eth, receiver)\r\n\r\n    log RemoveLiquidity(msg.sender, balances, total_supply - _amount)\r\n\r\n    return d_balances\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef remove_liquidity_one_coin(\r\n    token_amount: uint256,\r\n    i: uint256,\r\n    min_amount: uint256,\r\n    use_eth: bool = False,\r\n    receiver: address = msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw liquidity in a single token.\r\n            Involves fees (lower than swap fees).\r\n    @dev This operation also involves an admin fee claim.\r\n    @param token_amount Amount of LP tokens to burn\r\n    @param i Index of the token to withdraw\r\n    @param min_amount Minimum amount of token to withdraw.\r\n    @param use_eth Whether to withdraw ETH or not\r\n    @param receiver Address to send the withdrawn tokens to\r\n    @return Amount of tokens at index i received by the `receiver`\r\n    \"\"\"\r\n\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n\r\n    dy: uint256 = 0\r\n    D: uint256 = 0\r\n    p: uint256 = 0\r\n    xp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    approx_fee: uint256 = 0\r\n\r\n    # ---------------------------- Claim admin fees before removing liquidity.\r\n    self._claim_admin_fees()\r\n\r\n    # ------------------------------------------------------------------------\r\n\r\n    dy, D, xp, approx_fee = self._calc_withdraw_one_coin(\r\n        A_gamma,\r\n        token_amount,\r\n        i,\r\n        (self.future_A_gamma_time > block.timestamp),  # <------- During ramps\r\n    )  #                                                  we need to update D.\r\n\r\n    assert dy >= min_amount, \"Slippage\"\r\n\r\n    # ------------------------- Transfers ------------------------------------\r\n\r\n    self.balances[i] -= dy\r\n    self.burnFrom(msg.sender, token_amount)\r\n    self._transfer_out(coins[i], dy, use_eth, receiver)\r\n\r\n    packed_price_scale: uint256 = self.tweak_price(A_gamma, xp, D, 0)\r\n    #        Safe to use D from _calc_withdraw_one_coin here ---^\r\n\r\n    log RemoveLiquidityOne(\r\n        msg.sender, token_amount, i, dy, approx_fee, packed_price_scale\r\n    )\r\n\r\n    return dy\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef claim_admin_fees():\r\n    \"\"\"\r\n    @notice Claim admin fees. Callable by anyone.\r\n    \"\"\"\r\n    self._claim_admin_fees()\r\n\r\n\r\n# -------------------------- Packing functions -------------------------------\r\n\r\n\r\n@internal\r\n@view\r\ndef _pack(x: uint256[3]) -> uint256:\r\n    \"\"\"\r\n    @notice Packs 3 integers with values <= 10**18 into a uint256\r\n    @param x The uint256[3] to pack\r\n    @return uint256 Integer with packed values\r\n    \"\"\"\r\n    return (x[0] << 128) | (x[1] << 64) | x[2]\r\n\r\n\r\n@internal\r\n@view\r\ndef _unpack(_packed: uint256) -> uint256[3]:\r\n    \"\"\"\r\n    @notice Unpacks a uint256 into 3 integers (values must be <= 10**18)\r\n    @param val The uint256 to unpack\r\n    @return uint256[3] A list of length 3 with unpacked integers\r\n    \"\"\"\r\n    return [\r\n        (_packed >> 128) & 18446744073709551615,\r\n        (_packed >> 64) & 18446744073709551615,\r\n        _packed & 18446744073709551615,\r\n    ]\r\n\r\n\r\n@internal\r\n@view\r\ndef _pack_prices(prices_to_pack: uint256[N_COINS-1]) -> uint256:\r\n    \"\"\"\r\n    @notice Packs N_COINS-1 prices into a uint256.\r\n    @param prices_to_pack The prices to pack\r\n    @return uint256 An integer that packs prices\r\n    \"\"\"\r\n    packed_prices: uint256 = 0\r\n    p: uint256 = 0\r\n    for k in range(N_COINS - 1):\r\n        packed_prices = packed_prices << PRICE_SIZE\r\n        p = prices_to_pack[N_COINS - 2 - k]\r\n        assert p < PRICE_MASK\r\n        packed_prices = p | packed_prices\r\n    return packed_prices\r\n\r\n\r\n@internal\r\n@view\r\ndef _unpack_prices(_packed_prices: uint256) -> uint256[2]:\r\n    \"\"\"\r\n    @notice Unpacks N_COINS-1 prices from a uint256.\r\n    @param _packed_prices The packed prices\r\n    @return uint256[2] Unpacked prices\r\n    \"\"\"\r\n    unpacked_prices: uint256[N_COINS-1] = empty(uint256[N_COINS-1])\r\n    packed_prices: uint256 = _packed_prices\r\n    for k in range(N_COINS - 1):\r\n        unpacked_prices[k] = packed_prices & PRICE_MASK\r\n        packed_prices = packed_prices >> PRICE_SIZE\r\n\r\n    return unpacked_prices\r\n\r\n\r\n# ---------------------- AMM Internal Functions -------------------------------\r\n\r\n\r\n@internal\r\ndef _exchange(\r\n    sender: address,\r\n    mvalue: uint256,\r\n    i: uint256,\r\n    j: uint256,\r\n    dx: uint256,\r\n    min_dy: uint256,\r\n    use_eth: bool,\r\n    receiver: address,\r\n    callbacker: address,\r\n    callback_sig: bytes32\r\n) -> uint256:\r\n\r\n    assert i != j  # dev: coin index out of range\r\n    assert dx > 0  # dev: do not exchange 0 coins\r\n\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n    xp: uint256[N_COINS] = self.balances\r\n    precisions: uint256[N_COINS] = self._unpack(self.packed_precisions)\r\n    dy: uint256 = 0\r\n\r\n    y: uint256 = xp[j]  # <----------------- if j > N_COINS, this will revert.\r\n    x0: uint256 = xp[i]  # <--------------- if i > N_COINS, this will  revert.\r\n    xp[i] = x0 + dx\r\n    self.balances[i] = xp[i]\r\n\r\n    packed_price_scale: uint256 = self.price_scale_packed\r\n    price_scale: uint256[N_COINS - 1] = self._unpack_prices(\r\n        packed_price_scale\r\n    )\r\n\r\n    xp[0] *= precisions[0]\r\n    for k in range(1, N_COINS):\r\n        xp[k] = unsafe_div(\r\n            xp[k] * price_scale[k - 1] * precisions[k],\r\n            PRECISION\r\n        )  # <-------- Safu to do unsafe_div here since PRECISION is not zero.\r\n\r\n    prec_i: uint256 = precisions[i]\r\n\r\n    # ----------- Update invariant if A, gamma are undergoing ramps ---------\r\n\r\n    t: uint256 = self.future_A_gamma_time\r\n    if t > block.timestamp:\r\n\r\n        x0 *= prec_i\r\n\r\n        if i > 0:\r\n            x0 = unsafe_div(x0 * price_scale[i - 1], PRECISION)\r\n\r\n        x1: uint256 = xp[i]  # <------------------ Back up old value in xp ...\r\n        xp[i] = x0                                                         # |\r\n        self.D = MATH.newton_D(A_gamma[0], A_gamma[1], xp, 0)              # |\r\n        xp[i] = x1  # <-------------------------------------- ... and restore.\r\n\r\n    # ----------------------- Calculate dy and fees --------------------------\r\n\r\n    D: uint256 = self.D\r\n    prec_j: uint256 = precisions[j]\r\n    y_out: uint256[2] = MATH.get_y(A_gamma[0], A_gamma[1], xp, D, j)\r\n    dy = xp[j] - y_out[0]\r\n    xp[j] -= dy\r\n    dy -= 1\r\n\r\n    if j > 0:\r\n        dy = dy * PRECISION / price_scale[j - 1]\r\n    dy /= prec_j\r\n\r\n    fee: uint256 = unsafe_div(self._fee(xp) * dy, 10**10)\r\n\r\n    dy -= fee  # <--------------------- Subtract fee from the outgoing amount.\r\n    assert dy >= min_dy, \"Slippage\"\r\n\r\n    y -= dy\r\n    self.balances[j] = y  # <----------- Update pool balance of outgoing coin.\r\n\r\n    y *= prec_j\r\n    if j > 0:\r\n        y = unsafe_div(y * price_scale[j - 1], PRECISION)\r\n    xp[j] = y  # <------------------------------------------------- Update xp.\r\n\r\n    # ---------------------- Do Transfers in and out -------------------------\r\n\r\n    ########################## TRANSFER IN <-------\r\n    self._transfer_in(\r\n        coins[i], dx, dy, mvalue,\r\n        callbacker, callback_sig,  # <-------- Callback method is called here.\r\n        sender, receiver, use_eth,\r\n    )\r\n\r\n    ########################## -------> TRANSFER OUT\r\n    self._transfer_out(coins[j], dy, use_eth, receiver)\r\n\r\n    # ------ Tweak price_scale with good initial guess for newton_D ----------\r\n\r\n    packed_price_scale = self.tweak_price(A_gamma, xp, 0, y_out[1])\r\n\r\n    log TokenExchange(sender, i, dx, j, dy, fee, packed_price_scale)\r\n\r\n    return dy\r\n\r\n\r\n@internal\r\ndef tweak_price(\r\n    A_gamma: uint256[2],\r\n    _xp: uint256[N_COINS],\r\n    new_D: uint256,\r\n    K0_prev: uint256 = 0,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Tweaks price_oracle, last_price and conditionally adjusts\r\n            price_scale. This is called whenever there is an unbalanced\r\n            liquidity operation: _exchange, add_liquidity, or\r\n            remove_liquidity_one_coin.\r\n    @dev Contains main liquidity rebalancing logic, by tweaking `price_scale`.\r\n    @param A_gamma Array of A and gamma parameters.\r\n    @param _xp Array of current balances.\r\n    @param new_D New D value.\r\n    @param K0_prev Initial guess for `newton_D`.\r\n    \"\"\"\r\n\r\n    # ---------------------------- Read storage ------------------------------\r\n\r\n    rebalancing_params: uint256[3] = self._unpack(\r\n        self.packed_rebalancing_params\r\n    )  # <---------- Contains: allowed_extra_profit, adjustment_step, ma_time.\r\n    price_oracle: uint256[N_COINS - 1] = self._unpack_prices(\r\n        self.price_oracle_packed\r\n    )\r\n    last_prices: uint256[N_COINS - 1] = self._unpack_prices(\r\n        self.last_prices_packed\r\n    )\r\n    packed_price_scale: uint256 = self.price_scale_packed\r\n    price_scale: uint256[N_COINS - 1] = self._unpack_prices(\r\n        packed_price_scale\r\n    )\r\n\r\n    total_supply: uint256 = self.totalSupply\r\n    old_xcp_profit: uint256 = self.xcp_profit\r\n    old_virtual_price: uint256 = self.virtual_price\r\n    last_prices_timestamp: uint256 = self.last_prices_timestamp\r\n\r\n    # ----------------------- Update MA if needed ----------------------------\r\n\r\n    if last_prices_timestamp < block.timestamp:\r\n\r\n        #   The moving average price oracle is calculated using the last_price\r\n        #      of the trade at the previous block, and the price oracle logged\r\n        #              before that trade. This can happen only once per block.\r\n\r\n        # ------------------ Calculate moving average params -----------------\r\n\r\n        alpha: uint256 = MATH.wad_exp(\r\n            -convert(\r\n                unsafe_div(\r\n                    (block.timestamp - last_prices_timestamp) * 10**18,\r\n                    rebalancing_params[2]  # <----------------------- ma_time.\r\n                ),\r\n                int256,\r\n            )\r\n        )\r\n\r\n        for k in range(N_COINS - 1):\r\n\r\n            # ----------------- We cap state price that goes into the EMA with\r\n            #                                                 2 x price_scale.\r\n            price_oracle[k] = unsafe_div(\r\n                min(last_prices[k], 2 * price_scale[k]) * (10**18 - alpha) +\r\n                price_oracle[k] * alpha,  # ^-------- Cap spot price into EMA.\r\n                10**18\r\n            )\r\n\r\n        self.price_oracle_packed = self._pack_prices(price_oracle)\r\n        self.last_prices_timestamp = block.timestamp  # <---- Store timestamp.\r\n\r\n    #                  price_oracle is used further on to calculate its vector\r\n    #            distance from price_scale. This distance is used to calculate\r\n    #                  the amount of adjustment to be done to the price_scale.\r\n\r\n    # ------------------ If new_D is set to 0, calculate it ------------------\r\n\r\n    D_unadjusted: uint256 = new_D\r\n    if new_D == 0:  #  <--------------------------- _exchange sets new_D to 0.\r\n        D_unadjusted = MATH.newton_D(A_gamma[0], A_gamma[1], _xp, K0_prev)\r\n\r\n    # ----------------------- Calculate last_prices --------------------------\r\n\r\n    last_prices = MATH.get_p(_xp, D_unadjusted, A_gamma)\r\n    for k in range(N_COINS - 1):\r\n        last_prices[k] = unsafe_div(last_prices[k] * price_scale[k], 10**18)\r\n    self.last_prices_packed = self._pack_prices(last_prices)\r\n\r\n    # ---------- Update profit numbers without price adjustment first --------\r\n\r\n    xp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    xp[0] = unsafe_div(D_unadjusted, N_COINS)\r\n    for k in range(N_COINS - 1):\r\n        xp[k + 1] = D_unadjusted * 10**18 / (N_COINS * price_scale[k])\r\n\r\n    # ------------------------- Update xcp_profit ----------------------------\r\n\r\n    xcp_profit: uint256 = 10**18\r\n    virtual_price: uint256 = 10**18\r\n\r\n    if old_virtual_price > 0:\r\n\r\n        xcp: uint256 = MATH.geometric_mean(xp)\r\n        virtual_price = 10**18 * xcp / total_supply\r\n\r\n        xcp_profit = unsafe_div(\r\n            old_xcp_profit * virtual_price,\r\n            old_virtual_price\r\n        )  # <---------------- Safu to do unsafe_div as old_virtual_price > 0.\r\n\r\n        #       If A and gamma are not undergoing ramps (t < block.timestamp),\r\n        #         ensure new virtual_price is not less than old virtual_price,\r\n        #                                        else the pool suffers a loss.\r\n        if self.future_A_gamma_time < block.timestamp:\r\n            assert virtual_price > old_virtual_price, \"Loss\"\r\n\r\n    self.xcp_profit = xcp_profit\r\n\r\n    # ------------ Rebalance liquidity if there's enough profits to adjust it:\r\n    if virtual_price * 2 - 10**18 > xcp_profit + 2 * rebalancing_params[0]:\r\n        #                          allowed_extra_profit --------^\r\n\r\n        # ------------------- Get adjustment step ----------------------------\r\n\r\n        #                Calculate the vector distance between price_scale and\r\n        #                                                        price_oracle.\r\n        norm: uint256 = 0\r\n        ratio: uint256 = 0\r\n        for k in range(N_COINS - 1):\r\n\r\n            ratio = unsafe_div(price_oracle[k] * 10**18, price_scale[k])\r\n            # unsafe_div because we did safediv before ----^\r\n\r\n            if ratio > 10**18:\r\n                ratio = unsafe_sub(ratio, 10**18)\r\n            else:\r\n                ratio = unsafe_sub(10**18, ratio)\r\n            norm = unsafe_add(norm, ratio**2)\r\n\r\n        norm = isqrt(norm)  # <-------------------- isqrt is not in base 1e18.\r\n        adjustment_step: uint256 = max(\r\n            rebalancing_params[1], unsafe_div(norm, 5)\r\n        )  #           ^------------------------------------- adjustment_step.\r\n\r\n        if norm > adjustment_step:  # <---------- We only adjust prices if the\r\n            #          vector distance between price_oracle and price_scale is\r\n            #             large enough. This check ensures that no rebalancing\r\n            #           occurs if the distance is low i.e. the pool prices are\r\n            #                                     pegged to the oracle prices.\r\n\r\n            # ------------------------------------- Calculate new price scale.\r\n\r\n            p_new: uint256[N_COINS - 1] = empty(uint256[N_COINS - 1])\r\n            for k in range(N_COINS - 1):\r\n                p_new[k] = unsafe_div(\r\n                    price_scale[k] * unsafe_sub(norm, adjustment_step)\r\n                    + adjustment_step * price_oracle[k],\r\n                    norm\r\n                )  # <- norm is non-zero and gt adjustment_step; unsafe = safe\r\n\r\n            # ---------------- Update stale xp (using price_scale) with p_new.\r\n            xp = _xp\r\n            for k in range(N_COINS - 1):\r\n                xp[k + 1] = unsafe_div(_xp[k + 1] * p_new[k], price_scale[k])\r\n                # unsafe_div because we did safediv before ----^\r\n\r\n            # ------------------------------------------ Update D with new xp.\r\n            D: uint256 = MATH.newton_D(A_gamma[0], A_gamma[1], xp, 0)\r\n\r\n            for k in range(N_COINS):\r\n                frac: uint256 = xp[k] * 10**18 / D  # <----- Check validity of\r\n                assert (frac > 10**16 - 1) and (frac < 10**20 + 1)  #   p_new.\r\n\r\n            xp[0] = D / N_COINS\r\n            for k in range(N_COINS - 1):\r\n                xp[k + 1] = D * 10**18 / (N_COINS * p_new[k])  # <---- Convert\r\n                #                                           xp to real prices.\r\n\r\n            # ---------- Calculate new virtual_price using new xp and D. Reuse\r\n            #              `old_virtual_price` (but it has new virtual_price).\r\n            old_virtual_price = unsafe_div(\r\n                10**18 * MATH.geometric_mean(xp), total_supply\r\n            )  # <----- unsafe_div because we did safediv before (if vp>1e18)\r\n\r\n            # ---------------------------- Proceed if we've got enough profit.\r\n            if (\r\n                old_virtual_price > 10**18 and\r\n                2 * old_virtual_price - 10**18 > xcp_profit\r\n            ):\r\n\r\n                packed_price_scale = self._pack_prices(p_new)\r\n\r\n                self.D = D\r\n                self.virtual_price = old_virtual_price\r\n                self.price_scale_packed = packed_price_scale\r\n\r\n                return packed_price_scale\r\n\r\n    # --------- price_scale was not adjusted. Update the profit counter and D.\r\n    self.D = D_unadjusted\r\n    self.virtual_price = virtual_price\r\n\r\n    return packed_price_scale\r\n\r\n\r\n@internal\r\ndef _claim_admin_fees():\r\n    \"\"\"\r\n    @notice Claims admin fees and sends it to fee_receiver set in the factory.\r\n    \"\"\"\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n\r\n    xcp_profit: uint256 = self.xcp_profit  # <---------- Current pool profits.\r\n    xcp_profit_a: uint256 = self.xcp_profit_a  # <- Profits at previous claim.\r\n    total_supply: uint256 = self.totalSupply\r\n\r\n    # Do not claim admin fees if:\r\n    # 1. insufficient profits accrued since last claim, and\r\n    # 2. there are less than 10**18 (or 1 unit of) lp tokens, else it can lead\r\n    #    to manipulated virtual prices.\r\n    if xcp_profit <= xcp_profit_a or total_supply < 10**18:\r\n        return\r\n\r\n    #      Claim tokens belonging to the admin here. This is done by 'gulping'\r\n    #       pool tokens that have accrued as fees, but not accounted in pool's\r\n    #         `self.balances` yet: pool balances only account for incoming and\r\n    #                  outgoing tokens excluding fees. Following 'gulps' fees:\r\n\r\n    for i in range(N_COINS):\r\n        if coins[i] == WETH20:\r\n            self.balances[i] = self.balance\r\n        else:\r\n            self.balances[i] = ERC20(coins[i]).balanceOf(self)\r\n\r\n    #            If the pool has made no profits, `xcp_profit == xcp_profit_a`\r\n    #                         and the pool gulps nothing in the previous step.\r\n\r\n    vprice: uint256 = self.virtual_price\r\n\r\n    #  Admin fees are calculated as follows.\r\n    #      1. Calculate accrued profit since last claim. `xcp_profit`\r\n    #         is the current profits. `xcp_profit_a` is the profits\r\n    #         at the previous claim.\r\n    #      2. Take out admin's share, which is hardcoded at 5 * 10**9.\r\n    #         (50% => half of 100% => 10**10 / 2 => 5 * 10**9).\r\n    #      3. Since half of the profits go to rebalancing the pool, we\r\n    #         are left with half; so divide by 2.\r\n\r\n    fees: uint256 = unsafe_div(\r\n        unsafe_sub(xcp_profit, xcp_profit_a) * ADMIN_FEE, 2 * 10**10\r\n    )\r\n\r\n    # ------------------------------ Claim admin fees by minting admin's share\r\n    #                                                of the pool in LP tokens.\r\n    receiver: address = Factory(self.factory).fee_receiver()\r\n    if receiver != empty(address) and fees > 0:\r\n\r\n        frac: uint256 = vprice * 10**18 / (vprice - fees) - 10**18\r\n        claimed: uint256 = self.mint_relative(receiver, frac)\r\n\r\n        xcp_profit -= fees * 2\r\n\r\n        self.xcp_profit = xcp_profit\r\n\r\n        log ClaimAdminFee(receiver, claimed)\r\n\r\n    # ------------------------------------------- Recalculate D b/c we gulped.\r\n    D: uint256 = MATH.newton_D(A_gamma[0], A_gamma[1], self.xp(), 0)\r\n    self.D = D\r\n\r\n    # ------------------- Recalculate virtual_price following admin fee claim.\r\n    #     In this instance we do not check if current virtual price is greater\r\n    #               than old virtual price, since the claim process can result\r\n    #                                     in a small decrease in pool's value.\r\n\r\n    self.virtual_price = 10**18 * self.get_xcp(D) / self.totalSupply\r\n    self.xcp_profit_a = xcp_profit  # <------------ Cache last claimed profit.\r\n\r\n\r\n@internal\r\n@view\r\ndef xp() -> uint256[N_COINS]:\r\n\r\n    result: uint256[N_COINS] = self.balances\r\n    packed_prices: uint256 = self.price_scale_packed\r\n    precisions: uint256[N_COINS] = self._unpack(self.packed_precisions)\r\n\r\n    result[0] *= precisions[0]\r\n    for i in range(1, N_COINS):\r\n        p: uint256 = (packed_prices & PRICE_MASK) * precisions[i]\r\n        result[i] = result[i] * p / PRECISION\r\n        packed_prices = packed_prices >> PRICE_SIZE\r\n\r\n    return result\r\n\r\n\r\n@view\r\n@internal\r\ndef _A_gamma() -> uint256[2]:\r\n    t1: uint256 = self.future_A_gamma_time\r\n\r\n    A_gamma_1: uint256 = self.future_A_gamma\r\n    gamma1: uint256 = A_gamma_1 & 2**128 - 1\r\n    A1: uint256 = A_gamma_1 >> 128\r\n\r\n    if block.timestamp < t1:\r\n\r\n        # --------------- Handle ramping up and down of A --------------------\r\n\r\n        A_gamma_0: uint256 = self.initial_A_gamma\r\n        t0: uint256 = self.initial_A_gamma_time\r\n\r\n        t1 -= t0\r\n        t0 = block.timestamp - t0\r\n        t2: uint256 = t1 - t0\r\n\r\n        A1 = ((A_gamma_0 >> 128) * t2 + A1 * t0) / t1\r\n        gamma1 = ((A_gamma_0 & 2**128 - 1) * t2 + gamma1 * t0) / t1\r\n\r\n    return [A1, gamma1]\r\n\r\n\r\n@internal\r\n@view\r\ndef _fee(xp: uint256[N_COINS]) -> uint256:\r\n    fee_params: uint256[3] = self._unpack(self.packed_fee_params)\r\n    f: uint256 = MATH.reduction_coefficient(xp, fee_params[2])\r\n    return unsafe_div(\r\n        fee_params[0] * f + fee_params[1] * (10**18 - f),\r\n        10**18\r\n    )\r\n\r\n\r\n@internal\r\n@view\r\ndef get_xcp(D: uint256) -> uint256:\r\n\r\n    x: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    x[0] = D / N_COINS\r\n    packed_prices: uint256 = self.price_scale_packed  # <-- No precisions here\r\n    #                                 because we don't switch to \"real\" units.\r\n\r\n    for i in range(1, N_COINS):\r\n        x[i] = D * 10**18 / (N_COINS * (packed_prices & PRICE_MASK))\r\n        packed_prices = packed_prices >> PRICE_SIZE\r\n\r\n    return MATH.geometric_mean(x)\r\n\r\n\r\n@view\r\n@internal\r\ndef _calc_token_fee(amounts: uint256[N_COINS], xp: uint256[N_COINS]) -> uint256:\r\n    # fee = sum(amounts_i - avg(amounts)) * fee' / sum(amounts)\r\n    fee: uint256 = unsafe_div(\r\n        unsafe_mul(self._fee(xp), N_COINS),\r\n        unsafe_mul(4, unsafe_sub(N_COINS, 1))\r\n    )\r\n\r\n    S: uint256 = 0\r\n    for _x in amounts:\r\n        S += _x\r\n\r\n    avg: uint256 = unsafe_div(S, N_COINS)\r\n    Sdiff: uint256 = 0\r\n\r\n    for _x in amounts:\r\n        if _x > avg:\r\n            Sdiff += unsafe_sub(_x, avg)\r\n        else:\r\n            Sdiff += unsafe_sub(avg, _x)\r\n\r\n    return fee * Sdiff / S + NOISE_FEE\r\n\r\n\r\n@internal\r\n@view\r\ndef _calc_withdraw_one_coin(\r\n    A_gamma: uint256[2],\r\n    token_amount: uint256,\r\n    i: uint256,\r\n    update_D: bool,\r\n) -> (uint256, uint256, uint256[N_COINS], uint256):\r\n\r\n    token_supply: uint256 = self.totalSupply\r\n    assert token_amount <= token_supply  # dev: token amount more than supply\r\n    assert i < N_COINS  # dev: coin out of range\r\n\r\n    xx: uint256[N_COINS] = self.balances\r\n    precisions: uint256[N_COINS] = self._unpack(self.packed_precisions)\r\n    xp: uint256[N_COINS] = precisions\r\n    D0: uint256 = 0\r\n\r\n    # -------------------------- Calculate D0 and xp -------------------------\r\n\r\n    price_scale_i: uint256 = PRECISION * precisions[0]\r\n    packed_prices: uint256 = self.price_scale_packed\r\n    xp[0] *= xx[0]\r\n    for k in range(1, N_COINS):\r\n        p: uint256 = (packed_prices & PRICE_MASK)\r\n        if i == k:\r\n            price_scale_i = p * xp[i]\r\n        xp[k] = unsafe_div(xp[k] * xx[k] * p, PRECISION)\r\n        packed_prices = packed_prices >> PRICE_SIZE\r\n\r\n    if update_D:  # <-------------- D is updated if pool is undergoing a ramp.\r\n        D0 = MATH.newton_D(A_gamma[0], A_gamma[1], xp, 0)\r\n    else:\r\n        D0 = self.D\r\n\r\n    D: uint256 = D0\r\n\r\n    # -------------------------------- Fee Calc ------------------------------\r\n\r\n    # Charge fees on D. Roughly calculate xp[i] after withdrawal and use that\r\n    # to calculate fee. Precision is not paramount here: we just want a\r\n    # behavior where the higher the imbalance caused the more fee the AMM\r\n    # charges.\r\n\r\n    # xp is adjusted assuming xp[0] ~= xp[1] ~= x[2], which is usually not the\r\n    #  case. We charge self._fee(xp), where xp is an imprecise adjustment post\r\n    #  withdrawal in one coin. If the withdraw is too large: charge max fee by\r\n    #   default. This is because the fee calculation will otherwise underflow.\r\n\r\n    xp_imprecise: uint256[N_COINS] = xp\r\n    xp_correction: uint256 = xp[i] * N_COINS * token_amount / token_supply\r\n    fee: uint256 = self._unpack(self.packed_fee_params)[1]  # <- self.out_fee.\r\n\r\n    if xp_correction < xp_imprecise[i]:\r\n        xp_imprecise[i] -= xp_correction\r\n        fee = self._fee(xp_imprecise)\r\n\r\n    dD: uint256 = unsafe_div(token_amount * D, token_supply)\r\n    D_fee: uint256 = fee * dD / (2 * 10**10) + 1  # <------- Actual fee on D.\r\n\r\n    # --------- Calculate `approx_fee` (assuming balanced state) in ith token.\r\n    # -------------------------------- We only need this for fee in the event.\r\n    approx_fee: uint256 = N_COINS * D_fee * xx[i] / D\r\n\r\n    # ------------------------------------------------------------------------\r\n    D -= (dD - D_fee)  # <----------------------------------- Charge fee on D.\r\n    # --------------------------------- Calculate `y_out`` with `(D - D_fee)`.\r\n    y: uint256 = MATH.get_y(A_gamma[0], A_gamma[1], xp, D, i)[0]\r\n    dy: uint256 = (xp[i] - y) * PRECISION / price_scale_i\r\n    xp[i] = y\r\n\r\n    return dy, D, xp, approx_fee\r\n\r\n\r\n# ------------------------ ERC20 functions -----------------------------------\r\n\r\n\r\n@internal\r\ndef _approve(_owner: address, _spender: address, _value: uint256):\r\n    self.allowance[_owner][_spender] = _value\r\n\r\n    log Approval(_owner, _spender, _value)\r\n\r\n\r\n@internal\r\ndef _transfer(_from: address, _to: address, _value: uint256):\r\n    assert _to not in [self, empty(address)]\r\n\r\n    self.balanceOf[_from] -= _value\r\n    self.balanceOf[_to] += _value\r\n\r\n    log Transfer(_from, _to, _value)\r\n\r\n\r\n@view\r\n@internal\r\ndef _domain_separator() -> bytes32:\r\n    if chain.id != CACHED_CHAIN_ID:\r\n        return keccak256(\r\n            _abi_encode(\r\n                EIP712_TYPEHASH,\r\n                NAME_HASH,\r\n                VERSION_HASH,\r\n                chain.id,\r\n                self,\r\n                salt,\r\n            )\r\n        )\r\n    return CACHED_DOMAIN_SEPARATOR\r\n\r\n\r\n@external\r\ndef transferFrom(_from: address, _to: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @dev Transfer tokens from one address to another.\r\n    @param _from address The address which you want to send tokens from\r\n    @param _to address The address which you want to transfer to\r\n    @param _value uint256 the amount of tokens to be transferred\r\n    @return bool True on successul transfer. Reverts otherwise.\r\n    \"\"\"\r\n    _allowance: uint256 = self.allowance[_from][msg.sender]\r\n    if _allowance != max_value(uint256):\r\n        self._approve(_from, msg.sender, _allowance - _value)\r\n\r\n    self._transfer(_from, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef transfer(_to: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @dev Transfer token for a specified address\r\n    @param _to The address to transfer to.\r\n    @param _value The amount to be transferred.\r\n    @return bool True on successful transfer. Reverts otherwise.\r\n    \"\"\"\r\n    self._transfer(msg.sender, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef approve(_spender: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Allow `_spender` to transfer up to `_value` amount\r\n            of tokens from the caller's account.\r\n    @dev Non-zero to non-zero approvals are allowed, but should\r\n         be used cautiously. The methods increaseAllowance + decreaseAllowance\r\n         are available to prevent any front-running that may occur.\r\n    @param _spender The account permitted to spend up to `_value` amount of\r\n                    caller's funds.\r\n    @param _value The amount of tokens `_spender` is allowed to spend.\r\n    @return bool Success\r\n    \"\"\"\r\n    self._approve(msg.sender, _spender, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef increaseAllowance(_spender: address, _add_value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Increase the allowance granted to `_spender`.\r\n    @dev This function will never overflow, and instead will bound\r\n         allowance to max_value(uint256). This has the potential to grant an\r\n         infinite approval.\r\n    @param _spender The account to increase the allowance of.\r\n    @param _add_value The amount to increase the allowance by.\r\n    @return bool Success\r\n    \"\"\"\r\n    cached_allowance: uint256 = self.allowance[msg.sender][_spender]\r\n    allowance: uint256 = unsafe_add(cached_allowance, _add_value)\r\n\r\n    if allowance < cached_allowance:  # <-------------- Check for an overflow.\r\n        allowance = max_value(uint256)\r\n\r\n    if allowance != cached_allowance:\r\n        self._approve(msg.sender, _spender, allowance)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef decreaseAllowance(_spender: address, _sub_value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Decrease the allowance granted to `_spender`.\r\n    @dev This function will never underflow, and instead will bound\r\n        allowance to 0.\r\n    @param _spender The account to decrease the allowance of.\r\n    @param _sub_value The amount to decrease the allowance by.\r\n    @return bool Success.\r\n    \"\"\"\r\n    cached_allowance: uint256 = self.allowance[msg.sender][_spender]\r\n    allowance: uint256 = unsafe_sub(cached_allowance, _sub_value)\r\n\r\n    if cached_allowance < allowance:  # <------------- Check for an underflow.\r\n        allowance = 0\r\n\r\n    if allowance != cached_allowance:\r\n        self._approve(msg.sender, _spender, allowance)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef permit(\r\n    _owner: address,\r\n    _spender: address,\r\n    _value: uint256,\r\n    _deadline: uint256,\r\n    _v: uint8,\r\n    _r: bytes32,\r\n    _s: bytes32,\r\n) -> bool:\r\n    \"\"\"\r\n    @notice Permit `_spender` to spend up to `_value` amount of `_owner`'s\r\n            tokens via a signature.\r\n    @dev In the event of a chain fork, replay attacks are prevented as\r\n         domain separator is recalculated. However, this is only if the\r\n         resulting chains update their chainId.\r\n    @param _owner The account which generated the signature and is granting an\r\n                  allowance.\r\n    @param _spender The account which will be granted an allowance.\r\n    @param _value The approval amount.\r\n    @param _deadline The deadline by which the signature must be submitted.\r\n    @param _v The last byte of the ECDSA signature.\r\n    @param _r The first 32 bytes of the ECDSA signature.\r\n    @param _s The second 32 bytes of the ECDSA signature.\r\n    @return bool Success.\r\n    \"\"\"\r\n    assert _owner != empty(address)  # dev: invalid owner\r\n    assert block.timestamp <= _deadline  # dev: permit expired\r\n\r\n    nonce: uint256 = self.nonces[_owner]\r\n    digest: bytes32 = keccak256(\r\n        concat(\r\n            b\"\\x19\\x01\",\r\n            self._domain_separator(),\r\n            keccak256(\r\n                _abi_encode(\r\n                    EIP2612_TYPEHASH, _owner, _spender, _value, nonce, _deadline\r\n                )\r\n            ),\r\n        )\r\n    )\r\n    assert ecrecover(digest, _v, _r, _s) == _owner  # dev: invalid signature\r\n\r\n    self.nonces[_owner] = unsafe_add(nonce, 1)  # <-- Unsafe add is safe here.\r\n    self._approve(_owner, _spender, _value)\r\n    return True\r\n\r\n\r\n@internal\r\ndef mint(_to: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @dev Mint an amount of the token and assigns it to an account.\r\n         This encapsulates the modification of balances such that the\r\n         proper events are emitted.\r\n    @param _to The account that will receive the created tokens.\r\n    @param _value The amount that will be created.\r\n    @return bool Success.\r\n    \"\"\"\r\n    self.totalSupply += _value\r\n    self.balanceOf[_to] += _value\r\n\r\n    log Transfer(empty(address), _to, _value)\r\n    return True\r\n\r\n\r\n@internal\r\ndef mint_relative(_to: address, frac: uint256) -> uint256:\r\n    \"\"\"\r\n    @dev Increases supply by factor of (1 + frac/1e18) and mints it for _to\r\n    @param _to The account that will receive the created tokens.\r\n    @param frac The fraction of the current supply to mint.\r\n    @return uint256 Amount of tokens minted.\r\n    \"\"\"\r\n    supply: uint256 = self.totalSupply\r\n    d_supply: uint256 = supply * frac / 10**18\r\n    if d_supply > 0:\r\n        self.totalSupply = supply + d_supply\r\n        self.balanceOf[_to] += d_supply\r\n        log Transfer(empty(address), _to, d_supply)\r\n\r\n    return d_supply\r\n\r\n\r\n@internal\r\ndef burnFrom(_to: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @dev Burn an amount of the token from a given account.\r\n    @param _to The account whose tokens will be burned.\r\n    @param _value The amount that will be burned.\r\n    @return bool Success.\r\n    \"\"\"\r\n    self.totalSupply -= _value\r\n    self.balanceOf[_to] -= _value\r\n\r\n    log Transfer(_to, empty(address), _value)\r\n    return True\r\n\r\n\r\n# ------------------------- AMM View Functions -------------------------------\r\n\r\n\r\n@external\r\n@view\r\ndef fee_receiver() -> address:\r\n    \"\"\"\r\n    @notice Returns the address of the admin fee receiver.\r\n    @return address Fee receiver.\r\n    \"\"\"\r\n    return Factory(self.factory).fee_receiver()\r\n\r\n\r\n@external\r\n@view\r\ndef calc_token_amount(amounts: uint256[N_COINS], deposit: bool) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate LP tokens minted or to be burned for depositing or\r\n            removing `amounts` of coins\r\n    @dev Includes fee.\r\n    @param amounts Amounts of tokens being deposited or withdrawn\r\n    @param deposit True if it is a deposit action, False if withdrawn.\r\n    @return uint256 Amount of LP tokens deposited or withdrawn.\r\n    \"\"\"\r\n    view_contract: address = Factory(self.factory).views_implementation()\r\n    return Views(view_contract).calc_token_amount(amounts, deposit, self)\r\n\r\n\r\n@external\r\n@view\r\ndef get_dy(i: uint256, j: uint256, dx: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get amount of coin[j] tokens received for swapping in dx amount of coin[i]\r\n    @dev Includes fee.\r\n    @param i index of input token. Check pool.coins(i) to get coin address at ith index\r\n    @param j index of output token\r\n    @param dx amount of input coin[i] tokens\r\n    @return uint256 Exact amount of output j tokens for dx amount of i input tokens.\r\n    \"\"\"\r\n    view_contract: address = Factory(self.factory).views_implementation()\r\n    return Views(view_contract).get_dy(i, j, dx, self)\r\n\r\n\r\n@external\r\n@view\r\ndef get_dx(i: uint256, j: uint256, dy: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get amount of coin[i] tokens to input for swapping out dy amount\r\n            of coin[j]\r\n    @dev This is an approximate method, and returns estimates close to the input\r\n         amount. Expensive to call on-chain.\r\n    @param i index of input token. Check pool.coins(i) to get coin address at\r\n           ith index\r\n    @param j index of output token\r\n    @param dy amount of input coin[j] tokens received\r\n    @return uint256 Approximate amount of input i tokens to get dy amount of j tokens.\r\n    \"\"\"\r\n    view_contract: address = Factory(self.factory).views_implementation()\r\n    return Views(view_contract).get_dx(i, j, dy, self)\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant(\"lock\")\r\ndef lp_price() -> uint256:\r\n    \"\"\"\r\n    @notice Calculates the current price of the LP token w.r.t coin at the\r\n            0th index\r\n    @return uint256 LP price.\r\n    \"\"\"\r\n\r\n    price_oracle: uint256[N_COINS-1] = self._unpack_prices(\r\n        self.price_oracle_packed\r\n    )\r\n    return (\r\n        3 * self.virtual_price * MATH.cbrt(price_oracle[0] * price_oracle[1])\r\n    ) / 10**24\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant(\"lock\")\r\ndef get_virtual_price() -> uint256:\r\n    \"\"\"\r\n    @notice Calculates the current virtual price of the pool LP token.\r\n    @dev Not to be confused with `self.virtual_price` which is a cached\r\n         virtual price.\r\n    @return uint256 Virtual Price.\r\n    \"\"\"\r\n    return 10**18 * self.get_xcp(self.D) / self.totalSupply\r\n\r\n\r\n@external\r\n@view\r\n@nonreentrant(\"lock\")\r\ndef price_oracle(k: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Returns the oracle price of the coin at index `k` w.r.t the coin\r\n            at index 0.\r\n    @dev The oracle is an exponential moving average, with a periodicity\r\n         determined by `self.ma_time`. The aggregated prices are cached state\r\n         prices (dy/dx) calculated AFTER the latest trade.\r\n    @param k The index of the coin.\r\n    @return uint256 Price oracle value of kth coin.\r\n    \"\"\"\r\n    price_oracle: uint256 = self._unpack_prices(self.price_oracle_packed)[k]\r\n    price_scale: uint256 = self._unpack_prices(self.price_scale_packed)[k]\r\n    last_prices_timestamp: uint256 = self.last_prices_timestamp\r\n\r\n    if last_prices_timestamp < block.timestamp:  # <------------ Update moving\r\n        #                                                   average if needed.\r\n\r\n        last_prices: uint256 = self._unpack_prices(self.last_prices_packed)[k]\r\n        ma_time: uint256 = self._unpack(self.packed_rebalancing_params)[2]\r\n        alpha: uint256 = MATH.wad_exp(\r\n            -convert(\r\n                (block.timestamp - last_prices_timestamp) * 10**18 / ma_time,\r\n                int256,\r\n            )\r\n        )\r\n\r\n        # ---- We cap state price that goes into the EMA with 2 x price_scale.\r\n        return (\r\n            min(last_prices, 2 * price_scale) * (10**18 - alpha) +\r\n            price_oracle * alpha\r\n        ) / 10**18\r\n\r\n    return price_oracle\r\n\r\n\r\n@external\r\n@view\r\ndef last_prices(k: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Returns last price of the coin at index `k` w.r.t the coin\r\n            at index 0.\r\n    @dev last_prices returns the quote by the AMM for an infinitesimally small swap\r\n         after the last trade. It is not equivalent to the last traded price, and\r\n         is computed by taking the partial differential of `x` w.r.t `y`. The\r\n         derivative is calculated in `get_p` and then multiplied with price_scale\r\n         to give last_prices.\r\n    @param k The index of the coin.\r\n    @return uint256 Last logged price of coin.\r\n    \"\"\"\r\n    return self._unpack_prices(self.last_prices_packed)[k]\r\n\r\n\r\n@external\r\n@view\r\ndef price_scale(k: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Returns the price scale of the coin at index `k` w.r.t the coin\r\n            at index 0.\r\n    @dev Price scale determines the price band around which liquidity is\r\n         concentrated.\r\n    @param k The index of the coin.\r\n    @return uint256 Price scale of coin.\r\n    \"\"\"\r\n    return self._unpack_prices(self.price_scale_packed)[k]\r\n\r\n\r\n@external\r\n@view\r\ndef fee() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the fee charged by the pool at current state.\r\n    @dev Not to be confused with the fee charged at liquidity action, since\r\n         there the fee is calculated on `xp` AFTER liquidity is added or\r\n         removed.\r\n    @return uint256 fee bps.\r\n    \"\"\"\r\n    return self._fee(self.xp())\r\n\r\n\r\n@view\r\n@external\r\ndef calc_withdraw_one_coin(token_amount: uint256, i: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculates output tokens with fee\r\n    @param token_amount LP Token amount to burn\r\n    @param i token in which liquidity is withdrawn\r\n    @return uint256 Amount of ith tokens received for burning token_amount LP tokens.\r\n    \"\"\"\r\n\r\n    return self._calc_withdraw_one_coin(\r\n        self._A_gamma(),\r\n        token_amount,\r\n        i,\r\n        (self.future_A_gamma_time > block.timestamp)\r\n    )[0]\r\n\r\n\r\n@external\r\n@view\r\ndef calc_token_fee(\r\n    amounts: uint256[N_COINS], xp: uint256[N_COINS]\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Returns the fee charged on the given amounts for add_liquidity.\r\n    @param amounts The amounts of coins being added to the pool.\r\n    @param xp The current balances of the pool multiplied by coin precisions.\r\n    @return uint256 Fee charged.\r\n    \"\"\"\r\n    return self._calc_token_fee(amounts, xp)\r\n\r\n\r\n@view\r\n@external\r\ndef A() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the current pool amplification parameter.\r\n    @return uint256 A param.\r\n    \"\"\"\r\n    return self._A_gamma()[0]\r\n\r\n\r\n@view\r\n@external\r\ndef gamma() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the current pool gamma parameter.\r\n    @return uint256 gamma param.\r\n    \"\"\"\r\n    return self._A_gamma()[1]\r\n\r\n\r\n@view\r\n@external\r\ndef mid_fee() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the current mid fee\r\n    @return uint256 mid_fee value.\r\n    \"\"\"\r\n    return self._unpack(self.packed_fee_params)[0]\r\n\r\n\r\n@view\r\n@external\r\ndef out_fee() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the current out fee\r\n    @return uint256 out_fee value.\r\n    \"\"\"\r\n    return self._unpack(self.packed_fee_params)[1]\r\n\r\n\r\n@view\r\n@external\r\ndef fee_gamma() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the current fee gamma\r\n    @return uint256 fee_gamma value.\r\n    \"\"\"\r\n    return self._unpack(self.packed_fee_params)[2]\r\n\r\n\r\n@view\r\n@external\r\ndef allowed_extra_profit() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the current allowed extra profit\r\n    @return uint256 allowed_extra_profit value.\r\n    \"\"\"\r\n    return self._unpack(self.packed_rebalancing_params)[0]\r\n\r\n\r\n@view\r\n@external\r\ndef adjustment_step() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the current adjustment step\r\n    @return uint256 adjustment_step value.\r\n    \"\"\"\r\n    return self._unpack(self.packed_rebalancing_params)[1]\r\n\r\n\r\n@view\r\n@external\r\ndef ma_time() -> uint256:\r\n    \"\"\"\r\n    @notice Returns the current moving average time in seconds\r\n    @dev To get time in seconds, the parameter is multipled by ln(2)\r\n         One can expect off-by-one errors here.\r\n    @return uint256 ma_time value.\r\n    \"\"\"\r\n    return self._unpack(self.packed_rebalancing_params)[2] * 694 / 1000\r\n\r\n\r\n@view\r\n@external\r\ndef precisions() -> uint256[N_COINS]:  # <-------------- For by view contract.\r\n    \"\"\"\r\n    @notice Returns the precisions of each coin in the pool.\r\n    @return uint256[3] precisions of coins.\r\n    \"\"\"\r\n    return self._unpack(self.packed_precisions)\r\n\r\n\r\n@external\r\n@view\r\ndef fee_calc(xp: uint256[N_COINS]) -> uint256:  # <----- For by view contract.\r\n    \"\"\"\r\n    @notice Returns the fee charged by the pool at current state.\r\n    @param xp The current balances of the pool multiplied by coin precisions.\r\n    @return uint256 Fee value.\r\n    \"\"\"\r\n    return self._fee(xp)\r\n\r\n\r\n@view\r\n@external\r\ndef DOMAIN_SEPARATOR() -> bytes32:\r\n    \"\"\"\r\n    @notice EIP712 domain separator.\r\n    @return bytes32 Domain Separator set for the current chain.\r\n    \"\"\"\r\n    return self._domain_separator()\r\n\r\n\r\n# ------------------------- AMM Admin Functions ------------------------------\r\n\r\n\r\n@external\r\ndef ramp_A_gamma(\r\n    future_A: uint256, future_gamma: uint256, future_time: uint256\r\n):\r\n    \"\"\"\r\n    @notice Initialise Ramping A and gamma parameter values linearly.\r\n    @dev Only accessible by factory admin, and only\r\n    @param future_A The future A value.\r\n    @param future_gamma The future gamma value.\r\n    @param future_time The timestamp at which the ramping will end.\r\n    \"\"\"\r\n    assert msg.sender == Factory(self.factory).admin()  # dev: only owner\r\n    assert block.timestamp > self.initial_A_gamma_time + (MIN_RAMP_TIME - 1)  # dev: ramp undergoing\r\n    assert future_time > block.timestamp + MIN_RAMP_TIME - 1  # dev: insufficient time\r\n\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n    initial_A_gamma: uint256 = A_gamma[0] << 128\r\n    initial_A_gamma = initial_A_gamma | A_gamma[1]\r\n\r\n    assert future_A > MIN_A - 1\r\n    assert future_A < MAX_A + 1\r\n    assert future_gamma > MIN_GAMMA - 1\r\n    assert future_gamma < MAX_GAMMA + 1\r\n\r\n    ratio: uint256 = 10**18 * future_A / A_gamma[0]\r\n    assert ratio < 10**18 * MAX_A_CHANGE + 1\r\n    assert ratio > 10**18 / MAX_A_CHANGE - 1\r\n\r\n    ratio = 10**18 * future_gamma / A_gamma[1]\r\n    assert ratio < 10**18 * MAX_A_CHANGE + 1\r\n    assert ratio > 10**18 / MAX_A_CHANGE - 1\r\n\r\n    self.initial_A_gamma = initial_A_gamma\r\n    self.initial_A_gamma_time = block.timestamp\r\n\r\n    future_A_gamma: uint256 = future_A << 128\r\n    future_A_gamma = future_A_gamma | future_gamma\r\n    self.future_A_gamma_time = future_time\r\n    self.future_A_gamma = future_A_gamma\r\n\r\n    log RampAgamma(\r\n        A_gamma[0],\r\n        future_A,\r\n        A_gamma[1],\r\n        future_gamma,\r\n        block.timestamp,\r\n        future_time,\r\n    )\r\n\r\n\r\n@external\r\ndef stop_ramp_A_gamma():\r\n    \"\"\"\r\n    @notice Stop Ramping A and gamma parameters immediately.\r\n    @dev Only accessible by factory admin.\r\n    \"\"\"\r\n    assert msg.sender == Factory(self.factory).admin()  # dev: only owner\r\n\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n    current_A_gamma: uint256 = A_gamma[0] << 128\r\n    current_A_gamma = current_A_gamma | A_gamma[1]\r\n    self.initial_A_gamma = current_A_gamma\r\n    self.future_A_gamma = current_A_gamma\r\n    self.initial_A_gamma_time = block.timestamp\r\n    self.future_A_gamma_time = block.timestamp\r\n\r\n    # ------ Now (block.timestamp < t1) is always False, so we return saved A.\r\n\r\n    log StopRampA(A_gamma[0], A_gamma[1], block.timestamp)\r\n\r\n\r\n@external\r\ndef commit_new_parameters(\r\n    _new_mid_fee: uint256,\r\n    _new_out_fee: uint256,\r\n    _new_fee_gamma: uint256,\r\n    _new_allowed_extra_profit: uint256,\r\n    _new_adjustment_step: uint256,\r\n    _new_ma_time: uint256,\r\n):\r\n    \"\"\"\r\n    @notice Commit new parameters.\r\n    @dev Only accessible by factory admin.\r\n    @param _new_mid_fee The new mid fee.\r\n    @param _new_out_fee The new out fee.\r\n    @param _new_fee_gamma The new fee gamma.\r\n    @param _new_allowed_extra_profit The new allowed extra profit.\r\n    @param _new_adjustment_step The new adjustment step.\r\n    @param _new_ma_time The new ma time. ma_time is time_in_seconds/ln(2).\r\n    \"\"\"\r\n    assert msg.sender == Factory(self.factory).admin()  # dev: only owner\r\n    assert self.admin_actions_deadline == 0  # dev: active action\r\n\r\n    _deadline: uint256 = block.timestamp + ADMIN_ACTIONS_DELAY\r\n    self.admin_actions_deadline = _deadline\r\n\r\n    # ----------------------------- Set fee params ---------------------------\r\n\r\n    new_mid_fee: uint256 = _new_mid_fee\r\n    new_out_fee: uint256 = _new_out_fee\r\n    new_fee_gamma: uint256 = _new_fee_gamma\r\n\r\n    current_fee_params: uint256[3] = self._unpack(self.packed_fee_params)\r\n\r\n    if new_out_fee < MAX_FEE + 1:\r\n        assert new_out_fee > MIN_FEE - 1  # dev: fee is out of range\r\n    else:\r\n        new_out_fee = current_fee_params[1]\r\n\r\n    if new_mid_fee > MAX_FEE:\r\n        new_mid_fee = current_fee_params[0]\r\n    assert new_mid_fee <= new_out_fee  # dev: mid-fee is too high\r\n\r\n    if new_fee_gamma < 10**18:\r\n        assert new_fee_gamma > 0  # dev: fee_gamma out of range [1 .. 10**18]\r\n    else:\r\n        new_fee_gamma = current_fee_params[2]\r\n\r\n    self.future_packed_fee_params = self._pack(\r\n        [new_mid_fee, new_out_fee, new_fee_gamma]\r\n    )\r\n\r\n    # ----------------- Set liquidity rebalancing parameters -----------------\r\n\r\n    new_allowed_extra_profit: uint256 = _new_allowed_extra_profit\r\n    new_adjustment_step: uint256 = _new_adjustment_step\r\n    new_ma_time: uint256 = _new_ma_time\r\n\r\n    current_rebalancing_params: uint256[3] = self._unpack(self.packed_rebalancing_params)\r\n\r\n    if new_allowed_extra_profit > 10**18:\r\n        new_allowed_extra_profit = current_rebalancing_params[0]\r\n\r\n    if new_adjustment_step > 10**18:\r\n        new_adjustment_step = current_rebalancing_params[1]\r\n\r\n    if new_ma_time < 872542:  # <----- Calculated as: 7 * 24 * 60 * 60 / ln(2)\r\n        assert new_ma_time > 86  # dev: MA time should be longer than 60/ln(2)\r\n    else:\r\n        new_ma_time = current_rebalancing_params[2]\r\n\r\n    self.future_packed_rebalancing_params = self._pack(\r\n        [new_allowed_extra_profit, new_adjustment_step, new_ma_time]\r\n    )\r\n\r\n    # ---------------------------------- LOG ---------------------------------\r\n\r\n    log CommitNewParameters(\r\n        _deadline,\r\n        new_mid_fee,\r\n        new_out_fee,\r\n        new_fee_gamma,\r\n        new_allowed_extra_profit,\r\n        new_adjustment_step,\r\n        new_ma_time,\r\n    )\r\n\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef apply_new_parameters():\r\n    \"\"\"\r\n    @notice Apply committed parameters.\r\n    @dev Only callable after admin_actions_deadline.\r\n    \"\"\"\r\n    assert block.timestamp >= self.admin_actions_deadline  # dev: insufficient time\r\n    assert self.admin_actions_deadline != 0  # dev: no active action\r\n\r\n    self.admin_actions_deadline = 0\r\n\r\n    packed_fee_params: uint256 = self.future_packed_fee_params\r\n    self.packed_fee_params = packed_fee_params\r\n\r\n    packed_rebalancing_params: uint256 = self.future_packed_rebalancing_params\r\n    self.packed_rebalancing_params = packed_rebalancing_params\r\n\r\n    rebalancing_params: uint256[3] = self._unpack(packed_rebalancing_params)\r\n    fee_params: uint256[3] = self._unpack(packed_fee_params)\r\n\r\n    log NewParameters(\r\n        fee_params[0],\r\n        fee_params[1],\r\n        fee_params[2],\r\n        rebalancing_params[0],\r\n        rebalancing_params[1],\r\n        rebalancing_params[2],\r\n    )\r\n\r\n\r\n@external\r\ndef revert_new_parameters():\r\n    \"\"\"\r\n    @notice Revert committed parameters\r\n    @dev Only accessible by factory admin. Setting admin_actions_deadline to 0\r\n         ensures a revert in apply_new_parameters.\r\n    \"\"\"\r\n    assert msg.sender == Factory(self.factory).admin()  # dev: only owner\r\n    self.admin_actions_deadline = 0", "ABI": "[{\"name\":\"Transfer\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"spender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TokenExchange\",\"inputs\":[{\"name\":\"buyer\",\"type\":\"address\",\"indexed\":true},{\"name\":\"sold_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"tokens_sold\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"bought_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"tokens_bought\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"packed_price_scale\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AddLiquidity\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_amounts\",\"type\":\"uint256[3]\",\"indexed\":false},{\"name\":\"fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"token_supply\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"packed_price_scale\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquidity\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_amounts\",\"type\":\"uint256[3]\",\"indexed\":false},{\"name\":\"token_supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquidityOne\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"coin_index\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"coin_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"approx_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"packed_price_scale\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"CommitNewParameters\",\"inputs\":[{\"name\":\"deadline\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"mid_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"out_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"fee_gamma\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"allowed_extra_profit\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"adjustment_step\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"ma_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewParameters\",\"inputs\":[{\"name\":\"mid_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"out_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"fee_gamma\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"allowed_extra_profit\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"adjustment_step\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"ma_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RampAgamma\",\"inputs\":[{\"name\":\"initial_A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"future_A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"initial_gamma\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"future_gamma\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"initial_time\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"future_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"StopRampA\",\"inputs\":[{\"name\":\"current_A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"current_gamma\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ClaimAdminFee\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":true},{\"name\":\"tokens\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_coins\",\"type\":\"address[3]\"},{\"name\":\"_math\",\"type\":\"address\"},{\"name\":\"_weth\",\"type\":\"address\"},{\"name\":\"_salt\",\"type\":\"bytes32\"},{\"name\":\"packed_precisions\",\"type\":\"uint256\"},{\"name\":\"packed_A_gamma\",\"type\":\"uint256\"},{\"name\":\"packed_fee_params\",\"type\":\"uint256\"},{\"name\":\"packed_rebalancing_params\",\"type\":\"uint256\"},{\"name\":\"packed_prices\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"},{\"name\":\"min_dy\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"},{\"name\":\"min_dy\",\"type\":\"uint256\"},{\"name\":\"use_eth\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"},{\"name\":\"min_dy\",\"type\":\"uint256\"},{\"name\":\"use_eth\",\"type\":\"bool\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange_underlying\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"},{\"name\":\"min_dy\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange_underlying\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"},{\"name\":\"min_dy\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"exchange_extended\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"},{\"name\":\"min_dy\",\"type\":\"uint256\"},{\"name\":\"use_eth\",\"type\":\"bool\"},{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"cb\",\"type\":\"bytes32\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"amounts\",\"type\":\"uint256[3]\"},{\"name\":\"min_mint_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"amounts\",\"type\":\"uint256[3]\"},{\"name\":\"min_mint_amount\",\"type\":\"uint256\"},{\"name\":\"use_eth\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"amounts\",\"type\":\"uint256[3]\"},{\"name\":\"min_mint_amount\",\"type\":\"uint256\"},{\"name\":\"use_eth\",\"type\":\"bool\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"min_amounts\",\"type\":\"uint256[3]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[3]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"min_amounts\",\"type\":\"uint256[3]\"},{\"name\":\"use_eth\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[3]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"min_amounts\",\"type\":\"uint256[3]\"},{\"name\":\"use_eth\",\"type\":\"bool\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[3]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"min_amounts\",\"type\":\"uint256[3]\"},{\"name\":\"use_eth\",\"type\":\"bool\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"claim_admin_fees\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[3]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"min_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"min_amount\",\"type\":\"uint256\"},{\"name\":\"use_eth\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"min_amount\",\"type\":\"uint256\"},{\"name\":\"use_eth\",\"type\":\"bool\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_admin_fees\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transferFrom\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transfer\",\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"approve\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"increaseAllowance\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_add_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"decreaseAllowance\",\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_sub_value\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"permit\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_deadline\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee_receiver\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_token_amount\",\"inputs\":[{\"name\":\"amounts\",\"type\":\"uint256[3]\"},{\"name\":\"deposit\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dy\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dx\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dy\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lp_price\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_virtual_price\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"price_oracle\",\"inputs\":[{\"name\":\"k\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_prices\",\"inputs\":[{\"name\":\"k\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"price_scale\",\"inputs\":[{\"name\":\"k\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_withdraw_one_coin\",\"inputs\":[{\"name\":\"token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_token_fee\",\"inputs\":[{\"name\":\"amounts\",\"type\":\"uint256[3]\"},{\"name\":\"xp\",\"type\":\"uint256[3]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"A\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gamma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"mid_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"out_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee_gamma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allowed_extra_profit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"adjustment_step\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"ma_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"precisions\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[3]\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee_calc\",\"inputs\":[{\"name\":\"xp\",\"type\":\"uint256[3]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"DOMAIN_SEPARATOR\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"ramp_A_gamma\",\"inputs\":[{\"name\":\"future_A\",\"type\":\"uint256\"},{\"name\":\"future_gamma\",\"type\":\"uint256\"},{\"name\":\"future_time\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"stop_ramp_A_gamma\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_new_parameters\",\"inputs\":[{\"name\":\"_new_mid_fee\",\"type\":\"uint256\"},{\"name\":\"_new_out_fee\",\"type\":\"uint256\"},{\"name\":\"_new_fee_gamma\",\"type\":\"uint256\"},{\"name\":\"_new_allowed_extra_profit\",\"type\":\"uint256\"},{\"name\":\"_new_adjustment_step\",\"type\":\"uint256\"},{\"name\":\"_new_ma_time\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"apply_new_parameters\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"revert_new_parameters\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"WETH20\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"MATH\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"coins\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"factory\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_prices_timestamp\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"initial_A_gamma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"initial_A_gamma_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_A_gamma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_A_gamma_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balances\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"D\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"xcp_profit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"xcp_profit_a\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"virtual_price\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"packed_rebalancing_params\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"packed_fee_params\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"ADMIN_FEE\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin_actions_deadline\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"decimals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"version\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allowance\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"nonces\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"salt\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]}]", "ContractName": "CurveTricryptoOptimizedWETH", "CompilerVersion": "vyper:0.3.9", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c599000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000cbff3004a20dbfe2731543aa38599a526e0fd6ee000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc29130120a815b305a87f3895e79d3138b1ca24e08fdb1f9665e673d6f464ac2da0000000000000000000000e8d4a5100000000002540be4000000000000000001000000000000000000000000001a0e6d000000000000000000000abd8940e805000000000000000000000000002dc6c00000000001c9c3800001c6bf526340000000000000000000000001d1a94a20000001bda703f0a00000000000000003610000000000000067b435447dda44000000000000000005ed5747de9fcf980000000000000000000000000000000000000000000000000000000000000000000d54726963727970746f5553444300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f6372765553444357425443574554480000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}