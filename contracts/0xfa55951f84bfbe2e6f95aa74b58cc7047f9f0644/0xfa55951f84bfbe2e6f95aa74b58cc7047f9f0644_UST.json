{"SourceCode": "pragma solidity ^0.4.21;\r\n\r\ncontract Owned {\r\n    \r\n    /// 'owner' is the only address that can call a function with \r\n    /// this modifier\r\n    address public owner;\r\n    address internal newOwner;\r\n    \r\n    ///@notice The constructor assigns the message sender to be 'owner'\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    event updateOwner(address _oldOwner, address _newOwner);\r\n    \r\n    ///change the owner\r\n    function changeOwner(address _newOwner) public onlyOwner returns(bool) {\r\n        require(owner != _newOwner);\r\n        newOwner = _newOwner;\r\n        return true;\r\n    }\r\n    \r\n    /// accept the ownership\r\n    function acceptNewOwner() public returns(bool) {\r\n        require(msg.sender == newOwner);\r\n        emit updateOwner(owner, newOwner);\r\n        owner = newOwner;\r\n        return true;\r\n    }\r\n    \r\n}\r\n\r\n// Safe maths, borrowed from OpenZeppelin\r\nlibrary SafeMath {\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint c = a / b;\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    \r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ERC20Token {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n    \r\n    /// user tokens\r\n    mapping (address => uint256) public balances;\r\n    \r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant public returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    \r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract Controlled is Owned, ERC20Token {\r\n    using SafeMath for uint;\r\n    uint256 public releaseStartTime;\r\n    uint256 oneMonth = 3600 * 24 * 30;\r\n    \r\n    // Flag that determines if the token is transferable or not\r\n    bool  public emergencyStop = false;\r\n    \r\n    struct userToken {\r\n        uint256 UST;\r\n        uint256 addrLockType;\r\n    }\r\n    mapping (address => userToken) public userReleaseToken;\r\n    \r\n    modifier canTransfer {\r\n        require(emergencyStop == false);\r\n        _;\r\n    }\r\n    \r\n    modifier releaseTokenValid(address _user, uint256 _time, uint256 _value) {\r\n\t\tuint256 _lockTypeIndex = userReleaseToken[_user].addrLockType;\r\n\t\tif(_lockTypeIndex != 0) {\r\n\t\t\trequire (balances[_user].sub(_value) >= userReleaseToken[_user].UST.sub(calcReleaseToken(_user, _time, _lockTypeIndex)));\r\n        }\r\n        \r\n\t\t_;\r\n    }\r\n    \r\n    \r\n    function canTransferUST(bool _bool) public onlyOwner{\r\n        emergencyStop = _bool;\r\n    }\r\n    \r\n    /// @notice get `_user` transferable token amount \r\n    /// @param _user The user's address\r\n    /// @param _time The present time\r\n    /// @param _lockTypeIndex The user's investment lock type\r\n    /// @return Return the amount of user's transferable token\r\n    function calcReleaseToken(address _user, uint256 _time, uint256 _lockTypeIndex) internal view returns (uint256) {\r\n        uint256 _timeDifference = _time.sub(releaseStartTime);\r\n        uint256 _whichPeriod = getPeriod(_lockTypeIndex, _timeDifference);\r\n        \r\n        if(_lockTypeIndex == 1) {\r\n            \r\n            return (percent(userReleaseToken[_user].UST, 25) + percent(userReleaseToken[_user].UST, _whichPeriod.mul(25)));\r\n        }\r\n        \r\n        if(_lockTypeIndex == 2) {\r\n            return (percent(userReleaseToken[_user].UST, 25) + percent(userReleaseToken[_user].UST, _whichPeriod.mul(25)));\r\n        }\r\n        \r\n        if(_lockTypeIndex == 3) {\r\n            return (percent(userReleaseToken[_user].UST, 10) + percent(userReleaseToken[_user].UST, _whichPeriod.mul(15)));\r\n        }\r\n\t\t\r\n\t\trevert();\r\n    \r\n    }\r\n    \r\n    /// @notice get time period for the given '_lockTypeIndex'\r\n    /// @param _lockTypeIndex The user's investment locktype index\r\n    /// @param _timeDifference The passed time since releaseStartTime to now\r\n    /// @return Return the time period\r\n    function getPeriod(uint256 _lockTypeIndex, uint256 _timeDifference) internal view returns (uint256) {\r\n        if(_lockTypeIndex == 1) {           //The lock for the usechain coreTeamSupply\r\n            uint256 _period1 = (_timeDifference.div(oneMonth)).div(12);\r\n            if(_period1 >= 3){\r\n                _period1 = 3;\r\n            }\r\n            return _period1;\r\n        }\r\n        if(_lockTypeIndex == 2) {           //The lock for medium investment\r\n            uint256 _period2 = _timeDifference.div(oneMonth);\r\n            if(_period2 >= 3){\r\n                _period2 = 3;\r\n            }\r\n            return _period2;\r\n        }\r\n        if(_lockTypeIndex == 3) {           //The lock for massive investment\r\n            uint256 _period3 = _timeDifference.div(oneMonth);\r\n            if(_period3 >= 6){\r\n                _period3 = 6;\r\n            }\r\n            return _period3;\r\n        }\r\n\t\t\r\n\t\trevert();\r\n    }\r\n    \r\n    function percent(uint _token, uint _percentage) internal pure returns (uint) {\r\n        return _percentage.mul(_token).div(100);\r\n    }\r\n    \r\n}\r\n\r\ncontract standardToken is ERC20Token, Controlled {\r\n    \r\n    mapping (address => mapping (address => uint256)) public allowances;\r\n    \r\n    /// @param _owner The address that's balance is being requested\r\n    /// @return The balance of `_owner` at the current block\r\n    function balanceOf(address _owner) constant public returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /// @notice Send `_value` tokens to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of tokens to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    \r\n\tfunction transfer(\r\n        address _to,\r\n        uint256 _value) \r\n        public \r\n        canTransfer\r\n        releaseTokenValid(msg.sender, now, _value)\r\n        returns (bool) \r\n    {\r\n        require (balances[msg.sender] >= _value);           // Throw if sender has insufficient balance\r\n        require (balances[_to] + _value >= balances[_to]);  // Throw if owerflow detected\r\n        balances[msg.sender] -= _value;                     // Deduct senders balance\r\n        balances[_to] += _value;                            // Add recivers balance\r\n        emit Transfer(msg.sender, _to, _value);             // Raise Transfer event\r\n        return true;\r\n    }\r\n    \r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens on\r\n    ///  its behalf. This is a modified version of the ERC20 approve function\r\n    ///  to be a little bit safer\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return True if the approval was successful\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowances[msg.sender][_spender] = _value;          // Set allowance\r\n        emit Approval(msg.sender, _spender, _value);             // Raise Approval event\r\n        return true;\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `_spender` to send `_value` tokens on\r\n    ///  its behalf, and then a function is triggered in the contract that is\r\n    ///  being approved, `_spender`. This allows users to use their tokens to\r\n    ///  interact with contracts in one function call instead of two\r\n    /// @param _spender The address of the contract able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return True if the function call was successful\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        approve(_spender, _value);                          // Set approval to contract for _value\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { \r\n            revert(); \r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @notice Send `_value` tokens to `_to` from `_from` on the condition it\r\n    ///  is approved by `_from`\r\n    /// @param _from The address holding the tokens being transferred\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function transferFrom(address _from, address _to, uint256 _value) public canTransfer releaseTokenValid(msg.sender, now, _value) returns (bool success) {\r\n        require (balances[_from] >= _value);                // Throw if sender does not have enough balance\r\n        require (balances[_to] + _value >= balances[_to]);  // Throw if overflow detected\r\n        require (_value <= allowances[_from][msg.sender]);  // Throw if you do not have allowance\r\n        balances[_from] -= _value;                          // Deduct senders balance\r\n        balances[_to] += _value;                            // Add recipient balance\r\n        allowances[_from][msg.sender] -= _value;            // Deduct allowance for this address\r\n        emit Transfer(_from, _to, _value);                       // Raise Transfer event\r\n        return true;\r\n    }\r\n\r\n    /// @dev This function makes it easy to read the `allowances[]` map\r\n    /// @param _owner The address of the account that owns the token\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens of _owner that _spender is allowed to spend\r\n    function allowance(address _owner, address _spender) constant public returns (uint256) {\r\n        return allowances[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\ncontract UST is Owned, standardToken {\r\n        \r\n    string constant public name   = \"UseChainToken\";\r\n    string constant public symbol = \"UST\";\r\n    uint constant public decimals = 18;\r\n\r\n    uint256 public totalSupply = 0;\r\n    uint256 constant public topTotalSupply = 2 * 10**10 * 10**decimals;\r\n    uint public forSaleSupply        = percent(topTotalSupply, 45);\r\n    uint public marketingPartnerSupply = percent(topTotalSupply, 5);\r\n    uint public coreTeamSupply   = percent(topTotalSupply, 15);\r\n    uint public technicalCommunitySupply       = percent(topTotalSupply, 15);\r\n    uint public communitySupply          = percent(topTotalSupply, 20);\r\n    uint public softCap                = percent(topTotalSupply, 30);\r\n    \r\n    function () public {\r\n        revert();\r\n    }\r\n    \r\n    /// @dev Owner can change the releaseStartTime when needs\r\n    /// @param _time The releaseStartTime, UTC timezone\r\n    function setRealseTime(uint256 _time) public onlyOwner {\r\n        releaseStartTime = _time;\r\n    }\r\n    \r\n    /// @dev This owner allocate token for private sale\r\n    /// @param _owners The address of the account that owns the token\r\n    /// @param _values The amount of tokens\r\n    /// @param _addrLockType The locktype for different investment type\r\n    function allocateToken(address[] _owners, uint256[] _values, uint256[] _addrLockType) public onlyOwner {\r\n        require ((_owners.length == _values.length) && ( _values.length == _addrLockType.length));\r\n        for(uint i = 0; i < _owners.length ; i++){\r\n            uint256 value = _values[i] * 10 ** decimals;\r\n            \r\n            totalSupply = totalSupply.add(value);\r\n            balances[_owners[i]] = balances[_owners[i]].add(value);             // Set minted coins to target\r\n            emit Transfer(0x0, _owners[i], value);    \r\n            \r\n            userReleaseToken[_owners[i]].UST = userReleaseToken[_owners[i]].UST.add(value);\r\n            userReleaseToken[_owners[i]].addrLockType = _addrLockType[i];\r\n        }\r\n    }\r\n    \r\n    /// @dev This owner allocate token for candy airdrop\r\n    /// @param _owners The address of the account that owns the token\r\n    /// @param _values The amount of tokens\r\n\tfunction allocateCandyToken(address[] _owners, uint256[] _values) public onlyOwner {\r\n       for(uint i = 0; i < _owners.length ; i++){\r\n           uint256 value = _values[i] * 10 ** decimals;\r\n           totalSupply = totalSupply.add(value);\r\n\t\t   balances[_owners[i]] = balances[_owners[i]].add(value); \r\n\t\t   emit Transfer(0x0, _owners[i], value);  \t\t  \r\n        }\r\n    }\r\n    \r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"canTransferUST\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"technicalCommunitySupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"emergencyStop\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"coreTeamSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"topTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketingPartnerSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userReleaseToken\",\"outputs\":[{\"name\":\"UST\",\"type\":\"uint256\"},{\"name\":\"addrLockType\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"setRealseTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"forSaleSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"},{\"name\":\"_addrLockType\",\"type\":\"uint256[]\"}],\"name\":\"allocateToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"allocateCandyToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"releaseStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptNewOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"communitySupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"updateOwner\",\"type\":\"event\"}]", "ContractName": "UST", "CompilerVersion": "v0.4.21+commit.dfe3193c", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://78115256c53361a66138c437ed8b5e6fb896bb393c309d9a82c8a5b2ee85be67"}