{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/cctp/SynapseCCTPRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {ISynapseCCTP} from \\\"./interfaces/ISynapseCCTP.sol\\\";\\nimport {ISynapseCCTPFees} from \\\"./interfaces/ISynapseCCTPFees.sol\\\";\\nimport {BridgeToken, DestRequest, SwapQuery, ISynapseCCTPRouter} from \\\"./interfaces/ISynapseCCTPRouter.sol\\\";\\nimport {ITokenMinter} from \\\"./interfaces/ITokenMinter.sol\\\";\\nimport {UnknownRequestAction} from \\\"./libs/RouterErrors.sol\\\";\\nimport {RequestLib} from \\\"./libs/Request.sol\\\";\\nimport {MsgValueIncorrect, DefaultRouter} from \\\"../router/DefaultRouter.sol\\\";\\n\\nimport {IDefaultPool} from \\\"../router/interfaces/IDefaultPool.sol\\\";\\nimport {Action, DefaultParams} from \\\"../router/libs/Structs.sol\\\";\\n\\nimport {SafeERC20, IERC20} from \\\"@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {Pausable} from \\\"@openzeppelin/contracts-4.5.0/security/Pausable.sol\\\";\\n\\ncontract SynapseCCTPRouter is DefaultRouter, ISynapseCCTPRouter {\\n    using SafeERC20 for IERC20;\\n\\n    address public immutable synapseCCTP;\\n\\n    constructor(address _synapseCCTP) {\\n        synapseCCTP = _synapseCCTP;\\n    }\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 BRIDGE INTERACTIONS \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    /// @inheritdoc ISynapseCCTPRouter\\n    function bridge(\\n        address recipient,\\n        uint256 chainId,\\n        address token,\\n        uint256 amount,\\n        SwapQuery memory originQuery,\\n        SwapQuery memory destQuery\\n    ) external payable {\\n        if (originQuery.hasAdapter()) {\\n            // Perform a swap using the swap adapter, set this contract as recipient\\n            (token, amount) = _doSwap(address(this), token, amount, originQuery);\\n        } else {\\n            // If no swap is required, msg.value must be left as zero\\n            if (msg.value != 0) revert MsgValueIncorrect();\\n            // Pull the token from the user to this contract\\n            amount = _pullToken(address(this), token, amount);\\n        }\\n        // Either way, this contract has `amount` worth of `token`\\n        (uint32 requestVersion, bytes memory swapParams) = _deriveCCTPSwapParams(destQuery);\\n        // Approve SynapseCCTP to spend the token\\n        _approveToken(token, synapseCCTP, amount);\\n        ISynapseCCTP(synapseCCTP).sendCircleToken({\\n            recipient: recipient,\\n            chainId: chainId,\\n            burnToken: token,\\n            amount: amount,\\n            requestVersion: requestVersion,\\n            swapParams: swapParams\\n        });\\n    }\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 VIEWS \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    /// @inheritdoc ISynapseCCTPRouter\\n    function calculateFeeAmount(\\n        address token,\\n        uint256 amount,\\n        bool isSwap\\n    ) external view returns (uint256 fee) {\\n        return ISynapseCCTPFees(synapseCCTP).calculateFeeAmount(token, amount, isSwap);\\n    }\\n\\n    /// @inheritdoc ISynapseCCTPRouter\\n    function feeStructures(address token)\\n        external\\n        view\\n        returns (\\n            uint40 relayerFee,\\n            uint72 minBaseFee,\\n            uint72 minSwapFee,\\n            uint72 maxFee\\n        )\\n    {\\n        return ISynapseCCTPFees(synapseCCTP).feeStructures(token);\\n    }\\n\\n    /// @inheritdoc ISynapseCCTPRouter\\n    function getConnectedBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory tokens) {\\n        BridgeToken[] memory cctpTokens = ISynapseCCTPFees(synapseCCTP).getBridgeTokens();\\n        uint256 length = cctpTokens.length;\\n        bool[] memory isConnected = new bool[](length);\\n        uint256 count = 0;\\n        for (uint256 i = 0; i < length; ++i) {\\n            address circleToken = cctpTokens[i].token;\\n            if (circleToken == tokenOut || _isConnected(circleToken, tokenOut)) {\\n                isConnected[i] = true;\\n                ++count;\\n            }\\n        }\\n        // Populate the returned array with connected tokens\\n        tokens = new BridgeToken[](count);\\n        // This will track the index of the next element to be inserted in the returned array\\n        count = 0;\\n        for (uint256 i = 0; i < length; ++i) {\\n            if (isConnected[i]) {\\n                tokens[count++] = cctpTokens[i];\\n            }\\n        }\\n    }\\n\\n    /// @inheritdoc ISynapseCCTPRouter\\n    function getOriginAmountOut(\\n        address tokenIn,\\n        string[] memory tokenSymbols,\\n        uint256 amountIn\\n    ) external view returns (SwapQuery[] memory originQueries) {\\n        uint256 length = tokenSymbols.length;\\n        originQueries = new SwapQuery[](length);\\n        address tokenMinter = ISynapseCCTP(synapseCCTP).tokenMessenger().localMinter();\\n        // Check if it is possible to send Circle tokens (it is always possible to receive them though).\\n        bool isPaused = Pausable(synapseCCTP).paused();\\n        for (uint256 i = 0; i < length; ++i) {\\n            address circleToken = ISynapseCCTPFees(synapseCCTP).symbolToToken(tokenSymbols[i]);\\n            address pool = ISynapseCCTP(synapseCCTP).circleTokenPool(circleToken);\\n            // Get the quote for tokenIn -> circleToken swap\\n            // Note: this only populates `tokenOut`, `minAmountOut` and `rawParams` fields.\\n            originQueries[i] = _getAmountOut(pool, tokenIn, circleToken, amountIn);\\n            // Check if the amount out is higher than the burn limit\\n            uint256 burnLimit = ITokenMinter(tokenMinter).burnLimitsPerMessage(circleToken);\\n            if (originQueries[i].minAmountOut > burnLimit || isPaused) {\\n                // Nullify the query, leaving tokenOut intact (this allows SDK to get the bridge token address)\\n                originQueries[i].minAmountOut = 0;\\n                originQueries[i].rawParams = \\\"\\\";\\n            } else {\\n                // Fill the remaining fields, use this contract as \\\"Router Adapter\\\"\\n                originQueries[i].fillAdapterAndDeadline({routerAdapter: address(this)});\\n            }\\n        }\\n    }\\n\\n    /// @inheritdoc ISynapseCCTPRouter\\n    function getDestinationAmountOut(DestRequest[] memory requests, address tokenOut)\\n        external\\n        view\\n        returns (SwapQuery[] memory destQueries)\\n    {\\n        uint256 length = requests.length;\\n        destQueries = new SwapQuery[](length);\\n        for (uint256 i = 0; i < length; ++i) {\\n            address circleToken = ISynapseCCTPFees(synapseCCTP).symbolToToken(requests[i].symbol);\\n            address pool = ISynapseCCTP(synapseCCTP).circleTokenPool(circleToken);\\n            // Calculate the relayer fee amount\\n            uint256 amountIn = requests[i].amountIn;\\n            uint256 feeAmount = ISynapseCCTPFees(synapseCCTP).calculateFeeAmount({\\n                token: circleToken,\\n                amount: amountIn,\\n                isSwap: circleToken != tokenOut\\n            });\\n            // Only populate the query if the amountIn is higher than the feeAmount\\n            if (amountIn > feeAmount) {\\n                // Get the quote for circleToken -> tokenOut swap after the fee is applied\\n                // Note: this only populates `tokenOut`, `minAmountOut` and `rawParams` fields.\\n                destQueries[i] = _getAmountOut(pool, circleToken, tokenOut, amountIn - feeAmount);\\n                // Fill the remaining fields, use this contract as \\\"Router Adapter\\\"\\n                destQueries[i].fillAdapterAndDeadline({routerAdapter: address(this)});\\n            } else {\\n                // Fill only tokenOut otherwise\\n                destQueries[i].tokenOut = tokenOut;\\n            }\\n        }\\n    }\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 INTERNAL LOGIC \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    /// @dev Approves the token to be spent by the given spender indefinitely by giving infinite allowance.\\n    /// Doesn't modify the allowance if it's already enough for the given amount.\\n    function _approveToken(\\n        address token,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\\n        if (allowance < amount) {\\n            // Reset allowance to 0 before setting it to the new value.\\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\\n            IERC20(token).safeApprove(spender, type(uint256).max);\\n        }\\n    }\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 INTERNAL VIEWS \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    /// @dev Finds the quote for tokenIn -> tokenOut swap using a given pool.\\n    /// Note: only populates `tokenOut`, `minAmountOut` and `rawParams` fields.\\n    function _getAmountOut(\\n        address pool,\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn\\n    ) internal view returns (SwapQuery memory query) {\\n        query.tokenOut = tokenOut;\\n        if (tokenIn == tokenOut) {\\n            query.minAmountOut = amountIn;\\n            // query.rawParams is \\\"\\\", indicating that no further action is required\\n            return query;\\n        }\\n        if (pool == address(0)) {\\n            // query.minAmountOut is 0, indicating that no quote was found\\n            // query.rawParams is \\\"\\\", indicating that no further action is required\\n            return query;\\n        }\\n        address[] memory poolTokens = _getPoolTokens(pool);\\n        uint256 numTokens = poolTokens.length;\\n        // Iterate over all valid (tokenIndexFrom, tokenIndexTo) combinations for tokenIn -> tokenOut swap\\n        for (uint8 tokenIndexFrom = 0; tokenIndexFrom < numTokens; ++tokenIndexFrom) {\\n            // We are only interested in the tokenFrom == tokenIn case\\n            if (poolTokens[tokenIndexFrom] != tokenIn) continue;\\n            for (uint8 tokenIndexTo = 0; tokenIndexTo < numTokens; ++tokenIndexTo) {\\n                // We are only interested in the tokenTo == tokenOut case\\n                if (poolTokens[tokenIndexTo] != tokenOut) continue;\\n                uint256 amountOut = _getPoolSwapQuote(pool, tokenIndexFrom, tokenIndexTo, amountIn);\\n                // Update the query if the new quote is better than the previous one\\n                if (amountOut > query.minAmountOut) {\\n                    query.minAmountOut = amountOut;\\n                    query.rawParams = abi.encode(DefaultParams(Action.Swap, pool, tokenIndexFrom, tokenIndexTo));\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Checks if a token is connected to a Circle token: whether the token is in the whitelisted liquidity pool\\n    /// for the Circle token.\\n    function _isConnected(address circleToken, address token) internal view returns (bool) {\\n        // Get the whitelisted liquidity pool for the  Circle token\\n        address pool = ISynapseCCTP(synapseCCTP).circleTokenPool(circleToken);\\n        if (pool == address(0)) return false;\\n        // Iterate over pool tokens to check if the token is in the pool (meaning it is connected to the Circle token)\\n        for (uint8 index = 0; ; ++index) {\\n            try IDefaultPool(pool).getToken(index) returns (address poolToken) {\\n                if (poolToken == token) return true;\\n            } catch {\\n                // End of pool reached\\n                break;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /// @dev Derives the `swapParams` for following interaction with SynapseCCTP contract.\\n    function _deriveCCTPSwapParams(SwapQuery memory destQuery)\\n        internal\\n        pure\\n        returns (uint32 requestVersion, bytes memory swapParams)\\n    {\\n        // Check if any action was specified in `destQuery`\\n        if (destQuery.routerAdapter == address(0)) {\\n            // No action was specified, so no swap is required\\n            return (RequestLib.REQUEST_BASE, \\\"\\\");\\n        }\\n        DefaultParams memory params = abi.decode(destQuery.rawParams, (DefaultParams));\\n        // Check if the action is a swap\\n        if (params.action != Action.Swap) {\\n            // Actions other than swap are not supported for Circle tokens on the destination chain\\n            revert UnknownRequestAction();\\n        }\\n        requestVersion = RequestLib.REQUEST_SWAP;\\n        swapParams = RequestLib.formatSwapParams({\\n            tokenIndexFrom: params.tokenIndexFrom,\\n            tokenIndexTo: params.tokenIndexTo,\\n            deadline: destQuery.deadline,\\n            minAmountOut: destQuery.minAmountOut\\n        });\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cctp/interfaces/ISynapseCCTP.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {ITokenMessenger} from \\\"./ITokenMessenger.sol\\\";\\nimport {ISynapseCCTPFees} from \\\"./ISynapseCCTPFees.sol\\\";\\n\\ninterface ISynapseCCTP is ISynapseCCTPFees {\\n    /// @notice Send a Circle token supported by CCTP to a given chain\\n    /// with the request for the action to take on the destination chain.\\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\\n    /// as well as an optional swap action to take on the destination chain.\\n    /// `chainId` refers to value from EIP-155 (block.chainid).\\n    /// @param recipient            Recipient of the tokens on destination chain\\n    /// @param chainId              Chain ID of the destination chain\\n    /// @param burnToken            Address of Circle token to burn\\n    /// @param amount               Amount of tokens to burn\\n    /// @param requestVersion       Version of the request format\\n    /// @param swapParams           Swap parameters for the action to take on the destination chain (could be empty)\\n    function sendCircleToken(\\n        address recipient,\\n        uint256 chainId,\\n        address burnToken,\\n        uint256 amount,\\n        uint32 requestVersion,\\n        bytes memory swapParams\\n    ) external;\\n\\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\\n    /// as well as an optional swap action to take on this chain.\\n    /// @dev The relayers need to use SynapseCCTP.chainGasAmount() as `msg.value` when calling this function,\\n    /// or the call will revert.\\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin chain\\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\\n    /// @param requestVersion       Version of the request format\\n    /// @param formattedRequest     Formatted request for the action to take on this chain\\n    function receiveCircleToken(\\n        bytes calldata message,\\n        bytes calldata signature,\\n        uint32 requestVersion,\\n        bytes memory formattedRequest\\n    ) external payable;\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 VIEWS \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    /// @notice Returns the whitelisted liquidity pool for a given Circle token.\\n    /// @dev Returns address(0) if the token bridge+swap is not supported.\\n    function circleTokenPool(address token) external view returns (address pool);\\n\\n    /// @notice Returns the address of Circle's TokenMessenger contract used for bridging Circle tokens.\\n    function tokenMessenger() external view returns (ITokenMessenger);\\n}\\n\"\r\n    },\r\n    \"contracts/cctp/interfaces/ISynapseCCTPFees.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {BridgeToken} from \\\"../../router/libs/Structs.sol\\\";\\n\\ninterface ISynapseCCTPFees {\\n    /// @notice Calculates the fee amount for bridging a token to this chain using CCTP.\\n    /// @dev Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\\n    /// @param token        Address of the Circle token\\n    /// @param amount       Amount of the Circle tokens to be bridged to this chain\\n    /// @param isSwap       Whether the request is a swap request\\n    /// @return fee         Fee amount\\n    function calculateFeeAmount(\\n        address token,\\n        uint256 amount,\\n        bool isSwap\\n    ) external view returns (uint256 fee);\\n\\n    /// @notice Gets the fee structure for bridging a token to this chain.\\n    /// @dev Will return 0 for all fields if the token is not supported.\\n    /// @param token        Address of the Circle token\\n    /// @return relayerFee  Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\\n    /// @return minBaseFee  Minimum fee for bridging a token to this chain using a base request\\n    /// @return minSwapFee  Minimum fee for bridging a token to this chain using a swap request\\n    /// @return maxFee      Maximum fee for bridging a token to this chain\\n    function feeStructures(address token)\\n        external\\n        view\\n        returns (\\n            uint40 relayerFee,\\n            uint72 minBaseFee,\\n            uint72 minSwapFee,\\n            uint72 maxFee\\n        );\\n\\n    /// @notice Returns the list of all supported bridge tokens and their symbols.\\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens);\\n\\n    /// @notice Returns the address of the CCTP token for a given symbol.\\n    /// @dev Will return address(0) if the token is not supported.\\n    function symbolToToken(string memory symbol) external view returns (address token);\\n\\n    /// @notice Returns the symbol of a given CCTP token.\\n    /// @dev Will return empty string if the token is not supported.\\n    function tokenToSymbol(address token) external view returns (string memory symbol);\\n}\\n\"\r\n    },\r\n    \"contracts/cctp/interfaces/ISynapseCCTPRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {BridgeToken, DestRequest, SwapQuery} from \\\"../../router/libs/Structs.sol\\\";\\n\\ninterface ISynapseCCTPRouter {\\n    /// @notice Initiate a bridge transaction with an optional swap on both origin and destination chains.\\n    /// @dev Note that method is payable.\\n    /// If token is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\\n    /// If token is ERC20, the tokens will be pulled from msg.sender (use `msg.value = 0`).\\n    /// Make sure to approve this contract for spending `token` beforehand.\\n    /// originQuery.tokenOut should never be ETH_ADDRESS, bridge only works with ERC20 tokens.\\n    ///\\n    /// `originQuery` is supposed to be fetched using Router.getOriginAmountOut().\\n    /// Alternatively one could use an external adapter for more complex swaps on the origin chain.\\n    ///\\n    /// `destQuery` is supposed to be fetched using Router.getDestinationAmountOut().\\n    /// Complex swaps on destination chain are not supported for the time being.\\n    /// @param recipient    Address to receive tokens on destination chain\\n    /// @param chainId      Destination chain id\\n    /// @param token        Initial token for the bridge transaction to be pulled from the user\\n    /// @param amount       Amount of the initial tokens for the bridge transaction\\n    /// @param originQuery  Origin swap query. Empty struct indicates no swap is required\\n    /// @param destQuery    Destination swap query. Empty struct indicates no swap is required\\n    function bridge(\\n        address recipient,\\n        uint256 chainId,\\n        address token,\\n        uint256 amount,\\n        SwapQuery memory originQuery,\\n        SwapQuery memory destQuery\\n    ) external payable;\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 VIEWS \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    /// @notice Calculates the fee amount for bridging a token to this chain using CCTP.\\n    /// @dev Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\\n    /// @param token        Address of the Circle token\\n    /// @param amount       Amount of the Circle tokens to be bridged to this chain\\n    /// @param isSwap       Whether the request is a swap request\\n    /// @return fee         Fee amount\\n    function calculateFeeAmount(\\n        address token,\\n        uint256 amount,\\n        bool isSwap\\n    ) external view returns (uint256 fee);\\n\\n    /// @notice Gets the fee structure for bridging a token to this chain.\\n    /// @dev Will return 0 for all fields if the token is not supported.\\n    /// @param token        Address of the Circle token\\n    /// @return relayerFee  Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\\n    /// @return minBaseFee  Minimum fee for bridging a token to this chain using a base request\\n    /// @return minSwapFee  Minimum fee for bridging a token to this chain using a swap request\\n    /// @return maxFee      Maximum fee for bridging a token to this chain\\n    function feeStructures(address token)\\n        external\\n        view\\n        returns (\\n            uint40 relayerFee,\\n            uint72 minBaseFee,\\n            uint72 minSwapFee,\\n            uint72 maxFee\\n        );\\n\\n    /// @notice Gets the list of all bridge tokens (and their symbols), such that destination swap\\n    /// from a bridge token to `tokenOut` is possible.\\n    /// @param tokenOut  Token address to swap to on destination chain\\n    /// @return tokens   List of structs with following information:\\n    ///                  - symbol: unique token ID consistent among all chains\\n    ///                  - token: bridge token address\\n    function getConnectedBridgeTokens(address tokenOut) external view returns (BridgeToken[] memory tokens);\\n\\n    /// @notice Finds the best path between `tokenIn` and every supported bridge token from the given list,\\n    /// treating the swap as \\\"origin swap\\\", without putting any restrictions on the swap.\\n    /// @dev Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\\n    /// Check (query.minAmountOut != 0): this is true only if the swap is possible and bridge token is supported.\\n    /// The returned queries with minAmountOut != 0 could be used as `originQuery` with SynapseRouter.\\n    /// Note: it is possible to form a SwapQuery off-chain using alternative SwapAdapter for the origin swap.\\n    /// @param tokenIn       Initial token that user wants to bridge/swap\\n    /// @param tokenSymbols  List of symbols representing bridge tokens\\n    /// @param amountIn      Amount of tokens user wants to bridge/swap\\n    /// @return originQueries    List of structs that could be used as `originQuery` in SynapseRouter.\\n    ///                          minAmountOut and deadline fields will need to be adjusted based on the user settings.\\n    function getOriginAmountOut(\\n        address tokenIn,\\n        string[] memory tokenSymbols,\\n        uint256 amountIn\\n    ) external view returns (SwapQuery[] memory originQueries);\\n\\n    /// @notice Finds the best path between every supported bridge token from the given list and `tokenOut`,\\n    /// treating the swap as \\\"destination swap\\\", limiting possible actions to those available for every bridge token.\\n    /// @dev Will NOT revert if any of the tokens are not supported, instead will return an empty query for that symbol.\\n    /// Note: it is NOT possible to form a SwapQuery off-chain using alternative SwapAdapter for the destination swap.\\n    /// For the time being, only swaps through the Synapse-supported pools are available on destination chain.\\n    /// @param requests  List of structs with following information:\\n    ///                  - symbol: unique token ID consistent among all chains\\n    ///                  - amountIn: amount of bridge token to start with, before the bridge fee is applied\\n    /// @param tokenOut  Token user wants to receive on destination chain\\n    /// @return destQueries  List of structs that could be used as `destQuery` in SynapseRouter.\\n    ///                      minAmountOut and deadline fields will need to be adjusted based on the user settings.\\n    function getDestinationAmountOut(DestRequest[] memory requests, address tokenOut)\\n        external\\n        view\\n        returns (SwapQuery[] memory destQueries);\\n}\\n\"\r\n    },\r\n    \"contracts/cctp/interfaces/ITokenMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface ITokenMinter {\\n    /**\\n     * @notice Mints `amount` of local tokens corresponding to the\\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\\n     * map to a nonzero local token address. This mapping can be queried using\\n     * getLocalToken().\\n     * @param sourceDomain Source domain where `burnToken` was burned.\\n     * @param burnToken Burned token address as bytes32.\\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\\n     * on this domain.\\n     * @param amount Amount of tokens to mint. Must be less than or equal\\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\\n     * @return mintToken token minted.\\n     */\\n    function mint(\\n        uint32 sourceDomain,\\n        bytes32 burnToken,\\n        address to,\\n        uint256 amount\\n    ) external returns (address mintToken);\\n\\n    /**\\n     * @notice Burn tokens owned by this ITokenMinter.\\n     * @param burnToken burnable token.\\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\\n     * account balance of the given `_burnToken`.\\n     */\\n    function burn(address burnToken, uint256 amount) external;\\n\\n    /**\\n     * @notice Get the local token associated with the given remote domain and token.\\n     * @param remoteDomain Remote domain\\n     * @param remoteToken Remote token\\n     * @return local token address\\n     */\\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\\n\\n    // local token (address) => maximum burn amounts per message\\n    function burnLimitsPerMessage(address token) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/cctp/libs/RouterErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nerror UnknownRequestAction();\\n\"\r\n    },\r\n    \"contracts/cctp/libs/Request.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {IncorrectRequestLength, UnknownRequestVersion} from \\\"./Errors.sol\\\";\\n\\n/// # Base Request layout\\n///\\n/// | Field           | Type    | Description                                    |\\n/// | --------------- | ------- | ---------------------------------------------- |\\n/// | originDomain    | uint32  | Domain of the origin chain used by Circle CCTP |\\n/// | nonce           | uint64  | Nonce of the CCTP message on origin chain      |\\n/// | originBurnToken | address | Circle token that was burned on origin chain   |\\n/// | amount          | uint256 | Amount of tokens burned on origin chain        |\\n/// | recipient       | address | Recipient of the tokens on destination chain   |\\n///\\n/// # Swap Params layout\\n///\\n/// | Field          | Type    | Description                                                   |\\n/// | -------------- | ------- | ------------------------------------------------------------- |\\n/// | tokenIndexFrom | uint8   | Index of the minted Circle token in the pool                  |\\n/// | tokenIndexTo   | uint8   | Index of the final token in the pool                          |\\n/// | deadline       | uint256 | Latest timestamp to execute the swap                          |\\n/// | minAmountOut   | uint256 | Minimum amount of tokens to receive from the swap             |\\nlibrary RequestLib {\\n    uint32 internal constant REQUEST_BASE = 0;\\n    uint32 internal constant REQUEST_SWAP = 1;\\n\\n    /// @notice Length of the encoded base request.\\n    uint256 internal constant REQUEST_BASE_LENGTH = 5 * 32;\\n    /// @notice Length of the encoded swap parameters.\\n    uint256 internal constant SWAP_PARAMS_LENGTH = 4 * 32;\\n    /// @notice Length of the encoded swap request.\\n    /// Need 2 extra words for each `bytes` field to store its offset in the full payload, and length.\\n    uint256 internal constant REQUEST_SWAP_LENGTH = 4 * 32 + REQUEST_BASE_LENGTH + SWAP_PARAMS_LENGTH;\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 FORMATTING \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    /// @notice Formats the base request into a bytes array.\\n    /// @param originDomain         Domain of the origin chain\\n    /// @param nonce                Nonce of the CCTP message on origin chain\\n    /// @param originBurnToken      Circle token that was burned on origin chain\\n    /// @param amount               Amount of tokens burned on origin chain\\n    /// @param recipient            Recipient of the tokens on destination chain\\n    /// @return formattedRequest    Properly formatted base request\\n    function formatBaseRequest(\\n        uint32 originDomain,\\n        uint64 nonce,\\n        address originBurnToken,\\n        uint256 amount,\\n        address recipient\\n    ) internal pure returns (bytes memory formattedRequest) {\\n        return abi.encode(originDomain, nonce, originBurnToken, amount, recipient);\\n    }\\n\\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\\n    /// @param tokenIndexFrom       Index of the minted Circle token in the pool\\n    /// @param tokenIndexTo         Index of the final token in the pool\\n    /// @param deadline             Latest timestamp to execute the swap\\n    /// @param minAmountOut         Minimum amount of tokens to receive from the swap\\n    /// @return formattedSwapParams Properly formatted swap parameters\\n    function formatSwapParams(\\n        uint8 tokenIndexFrom,\\n        uint8 tokenIndexTo,\\n        uint256 deadline,\\n        uint256 minAmountOut\\n    ) internal pure returns (bytes memory formattedSwapParams) {\\n        return abi.encode(tokenIndexFrom, tokenIndexTo, deadline, minAmountOut);\\n    }\\n\\n    /// @notice Formats the request into a bytes array.\\n    /// @dev Will revert if the either of these is true:\\n    /// - Request version is unknown.\\n    /// - Base request is not properly formatted.\\n    /// - Swap parameters are specified for a base request.\\n    /// - Swap parameters are not properly formatted.\\n    /// @param requestVersion       Version of the request format\\n    /// @param baseRequest          Formatted base request\\n    /// @param swapParams           Formatted swap parameters\\n    /// @return formattedRequest    Properly formatted request\\n    function formatRequest(\\n        uint32 requestVersion,\\n        bytes memory baseRequest,\\n        bytes memory swapParams\\n    ) internal pure returns (bytes memory formattedRequest) {\\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\\n        if (requestVersion == REQUEST_BASE) {\\n            if (swapParams.length != 0) revert IncorrectRequestLength();\\n            // swapParams is empty, so we can just return the base request\\n            return baseRequest;\\n        } else if (requestVersion == REQUEST_SWAP) {\\n            if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\\n            // Encode both the base request and the swap parameters\\n            return abi.encode(baseRequest, swapParams);\\n        } else {\\n            revert UnknownRequestVersion();\\n        }\\n    }\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 DECODING \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    /// @notice Decodes the base request from a bytes array.\\n    /// @dev Will revert if the request is not properly formatted.\\n    /// @param baseRequest          Formatted base request\\n    /// @return originDomain        Domain of the origin chain\\n    /// @return nonce               Nonce of the CCTP message on origin domain\\n    /// @return originBurnToken     Circle token that was burned on origin domain\\n    /// @return amount              Amount of tokens to burn\\n    /// @return recipient           Recipient of the tokens on destination domain\\n    function decodeBaseRequest(bytes memory baseRequest)\\n        internal\\n        pure\\n        returns (\\n            uint32 originDomain,\\n            uint64 nonce,\\n            address originBurnToken,\\n            uint256 amount,\\n            address recipient\\n        )\\n    {\\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\\n        return abi.decode(baseRequest, (uint32, uint64, address, uint256, address));\\n    }\\n\\n    /// @notice Decodes the swap parameters from a bytes array.\\n    /// @dev Will revert if the swap parameters are not properly formatted.\\n    /// @param swapParams           Formatted swap parameters\\n    /// @return tokenIndexFrom      Index of the minted Circle token in the pool\\n    /// @return tokenIndexTo        Index of the final token in the pool\\n    /// @return deadline            Latest timestamp to execute the swap\\n    /// @return minAmountOut        Minimum amount of tokens to receive from the swap\\n    function decodeSwapParams(bytes memory swapParams)\\n        internal\\n        pure\\n        returns (\\n            uint8 tokenIndexFrom,\\n            uint8 tokenIndexTo,\\n            uint256 deadline,\\n            uint256 minAmountOut\\n        )\\n    {\\n        if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\\n        return abi.decode(swapParams, (uint8, uint8, uint256, uint256));\\n    }\\n\\n    /// @notice Decodes the versioned request from a bytes array.\\n    /// @dev Will revert if the either of these is true:\\n    /// - Request version is unknown.\\n    /// - Request is not properly formatted.\\n    /// @param requestVersion       Version of the request format\\n    /// @param formattedRequest     Formatted request\\n    /// @return baseRequest         Formatted base request\\n    /// @return swapParams          Formatted swap parameters\\n    function decodeRequest(uint32 requestVersion, bytes memory formattedRequest)\\n        internal\\n        pure\\n        returns (bytes memory baseRequest, bytes memory swapParams)\\n    {\\n        if (requestVersion == REQUEST_BASE) {\\n            if (formattedRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\\n            return (formattedRequest, \\\"\\\");\\n        } else if (requestVersion == REQUEST_SWAP) {\\n            if (formattedRequest.length != REQUEST_SWAP_LENGTH) revert IncorrectRequestLength();\\n            return abi.decode(formattedRequest, (bytes, bytes));\\n        } else {\\n            revert UnknownRequestVersion();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/router/DefaultRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {DefaultAdapter} from \\\"./adapters/DefaultAdapter.sol\\\";\\nimport {IRouterAdapter} from \\\"./interfaces/IRouterAdapter.sol\\\";\\nimport {DeadlineExceeded, InsufficientOutputAmount, MsgValueIncorrect, TokenNotETH} from \\\"./libs/Errors.sol\\\";\\nimport {Action, DefaultParams, SwapQuery} from \\\"./libs/Structs.sol\\\";\\nimport {UniversalTokenLib} from \\\"./libs/UniversalToken.sol\\\";\\n\\nimport {SafeERC20, IERC20} from \\\"@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n/// @title DefaultRouter\\n/// @notice Base contract for all Synapse Routers, that is able to natively work with Default Pools\\n/// due to the fact that it inherits from DefaultAdapter.\\nabstract contract DefaultRouter is DefaultAdapter {\\n    using SafeERC20 for IERC20;\\n    using UniversalTokenLib for address;\\n\\n    /// @dev Performs a \\\"swap from tokenIn\\\" following instructions from `query`.\\n    /// `query` will include the router adapter to use, and the exact type of \\\"tokenIn -> tokenOut swap\\\"\\n    /// should be encoded in `query.rawParams`.\\n    function _doSwap(\\n        address recipient,\\n        address tokenIn,\\n        uint256 amountIn,\\n        SwapQuery memory query\\n    ) internal returns (address tokenOut, uint256 amountOut) {\\n        // First, check the deadline for the swap\\n        // solhint-disable-next-line not-rely-on-time\\n        if (block.timestamp > query.deadline) revert DeadlineExceeded();\\n        // Pull initial token from the user to specified router adapter\\n        amountIn = _pullToken(query.routerAdapter, tokenIn, amountIn);\\n        tokenOut = query.tokenOut;\\n        address routerAdapter = query.routerAdapter;\\n        if (routerAdapter == address(this)) {\\n            // If the router adapter is this contract, we can perform the swap directly and trust the result\\n            amountOut = _adapterSwap(recipient, tokenIn, amountIn, tokenOut, query.rawParams);\\n        } else {\\n            // Otherwise, we need to call the router adapter. Adapters are permissionless, so we verify the result\\n            // Record tokenOut balance before swap\\n            amountOut = tokenOut.universalBalanceOf(recipient);\\n            IRouterAdapter(routerAdapter).adapterSwap{value: msg.value}({\\n                recipient: recipient,\\n                tokenIn: tokenIn,\\n                amountIn: amountIn,\\n                tokenOut: tokenOut,\\n                rawParams: query.rawParams\\n            });\\n            // Use the difference between the recorded balance and the current balance as the amountOut\\n            amountOut = tokenOut.universalBalanceOf(recipient) - amountOut;\\n        }\\n        // Finally, check that the recipient received at least as much as they wanted\\n        if (amountOut < query.minAmountOut) revert InsufficientOutputAmount();\\n    }\\n\\n    /// @dev Pulls a requested token from the user to the requested recipient.\\n    /// Or, if msg.value was provided, check that ETH_ADDRESS was used and msg.value is correct.\\n    function _pullToken(\\n        address recipient,\\n        address token,\\n        uint256 amount\\n    ) internal returns (uint256 amountPulled) {\\n        if (msg.value == 0) {\\n            token.assertIsContract();\\n            // Record token balance before transfer\\n            amountPulled = IERC20(token).balanceOf(recipient);\\n            // Token needs to be pulled only if msg.value is zero\\n            // This way user can specify WETH as the origin asset\\n            IERC20(token).safeTransferFrom(msg.sender, recipient, amount);\\n            // Use the difference between the recorded balance and the current balance as the amountPulled\\n            amountPulled = IERC20(token).balanceOf(recipient) - amountPulled;\\n        } else {\\n            // Otherwise, we need to check that ETH was specified\\n            if (token != UniversalTokenLib.ETH_ADDRESS) revert TokenNotETH();\\n            // And that amount matches msg.value\\n            if (amount != msg.value) revert MsgValueIncorrect();\\n            // We will forward msg.value in the external call later, if recipient is not this contract\\n            amountPulled = msg.value;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/router/interfaces/IDefaultPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IDefaultPool {\\n    function swap(\\n        uint8 tokenIndexFrom,\\n        uint8 tokenIndexTo,\\n        uint256 dx,\\n        uint256 minDy,\\n        uint256 deadline\\n    ) external returns (uint256 amountOut);\\n\\n    function calculateSwap(\\n        uint8 tokenIndexFrom,\\n        uint8 tokenIndexTo,\\n        uint256 dx\\n    ) external view returns (uint256 amountOut);\\n\\n    function getToken(uint8 index) external view returns (address token);\\n}\\n\"\r\n    },\r\n    \"contracts/router/libs/Structs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13; // \\\"using A for B global\\\" requires 0.8.13 or higher\\n\\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 TOKEN AND POOL DESCRIPTION \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n/// @notice Struct representing a bridge token. Used as the return value in view functions.\\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\\n/// @param token    Bridge token address\\nstruct BridgeToken {\\n    string symbol;\\n    address token;\\n}\\n\\n/// @notice Struct used by IPoolHandler to represent a token in a pool\\n/// @param index    Token index in the pool\\n/// @param token    Token address\\nstruct IndexedToken {\\n    uint8 index;\\n    address token;\\n}\\n\\n/// @notice Struct representing a token, and the available Actions for performing a swap.\\n/// @param actionMask   Bitmask representing what actions (see ActionLib) are available for swapping a token\\n/// @param token        Token address\\nstruct LimitedToken {\\n    uint256 actionMask;\\n    address token;\\n}\\n\\n/// @notice Struct representing how pool tokens are stored by `SwapQuoter`.\\n/// @param isWeth   Whether the token represents Wrapped ETH.\\n/// @param token    Token address.\\nstruct PoolToken {\\n    bool isWeth;\\n    address token;\\n}\\n\\n/// @notice Struct representing a liquidity pool. Used as the return value in view functions.\\n/// @param pool         Pool address.\\n/// @param lpToken      Address of pool's LP token.\\n/// @param tokens       List of pool's tokens.\\nstruct Pool {\\n    address pool;\\n    address lpToken;\\n    PoolToken[] tokens;\\n}\\n\\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 ROUTER STRUCTS \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n/// @notice Struct representing a quote request for swapping a bridge token.\\n/// Used in destination chain's SynapseRouter, hence the name \\\"Destination Request\\\".\\n/// @dev tokenOut is passed externally.\\n/// @param symbol   Bridge token symbol: unique token ID consistent among all chains\\n/// @param amountIn Amount of bridge token to start with, before the bridge fee is applied\\nstruct DestRequest {\\n    string symbol;\\n    uint256 amountIn;\\n}\\n\\n/// @notice Struct representing a swap request for SynapseRouter.\\n/// @dev tokenIn is supplied separately.\\n/// @param routerAdapter    Contract that will perform the swap for the Router. Address(0) specifies a \\\"no swap\\\" query.\\n/// @param tokenOut         Token address to swap to.\\n/// @param minAmountOut     Minimum amount of tokens to receive after the swap, or tx will be reverted.\\n/// @param deadline         Latest timestamp for when the transaction needs to be executed, or tx will be reverted.\\n/// @param rawParams        ABI-encoded params for the swap that will be passed to `routerAdapter`.\\n///                         Should be DefaultParams for swaps via DefaultAdapter.\\nstruct SwapQuery {\\n    address routerAdapter;\\n    address tokenOut;\\n    uint256 minAmountOut;\\n    uint256 deadline;\\n    bytes rawParams;\\n}\\n\\nusing SwapQueryLib for SwapQuery global;\\n\\nlibrary SwapQueryLib {\\n    /// @notice Checks whether the router adapter was specified in the query.\\n    /// Query without a router adapter specifies that no action needs to be taken.\\n    function hasAdapter(SwapQuery memory query) internal pure returns (bool) {\\n        return query.routerAdapter != address(0);\\n    }\\n\\n    /// @notice Fills `routerAdapter` and `deadline` fields in query, if it specifies one of the supported Actions,\\n    /// and if a path for this action was found.\\n    function fillAdapterAndDeadline(SwapQuery memory query, address routerAdapter) internal pure {\\n        // Fill the fields only if some path was found.\\n        if (query.minAmountOut == 0) return;\\n        // Empty params indicates no action needs to be done, thus no adapter is needed.\\n        query.routerAdapter = query.rawParams.length == 0 ? address(0) : routerAdapter;\\n        // Set default deadline to infinity. Not using the value of 0,\\n        // which would lead to every swap to revert by default.\\n        query.deadline = type(uint256).max;\\n    }\\n}\\n\\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 ADAPTER STRUCTS \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n/// @notice Struct representing parameters for swapping via DefaultAdapter.\\n/// @param action           Action that DefaultAdapter needs to perform.\\n/// @param pool             Liquidity pool that will be used for Swap/AddLiquidity/RemoveLiquidity actions.\\n/// @param tokenIndexFrom   Token index to swap from. Used for swap/addLiquidity actions.\\n/// @param tokenIndexTo     Token index to swap to. Used for swap/removeLiquidity actions.\\nstruct DefaultParams {\\n    Action action;\\n    address pool;\\n    uint8 tokenIndexFrom;\\n    uint8 tokenIndexTo;\\n}\\n\\n/// @notice All possible actions that DefaultAdapter could perform.\\nenum Action {\\n    Swap, // swap between two pools tokens\\n    AddLiquidity, // add liquidity in a form of a single pool token\\n    RemoveLiquidity, // remove liquidity in a form of a single pool token\\n    HandleEth // ETH <> WETH interaction\\n}\\n\\nusing ActionLib for Action global;\\n\\n/// @notice Library for dealing with bit masks which describe what set of Actions is available.\\nlibrary ActionLib {\\n    /// @notice Returns a bitmask with all possible actions set to True.\\n    function allActions() internal pure returns (uint256 actionMask) {\\n        actionMask = type(uint256).max;\\n    }\\n\\n    /// @notice Returns whether the given action is set to True in the bitmask.\\n    function isIncluded(Action action, uint256 actionMask) internal pure returns (bool) {\\n        return actionMask & mask(action) != 0;\\n    }\\n\\n    /// @notice Returns a bitmask with only the given action set to True.\\n    function mask(Action action) internal pure returns (uint256) {\\n        return 1 << uint256(action);\\n    }\\n\\n    /// @notice Returns a bitmask with only two given actions set to True.\\n    function mask(Action a, Action b) internal pure returns (uint256) {\\n        return mask(a) | mask(b);\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-4.5.0/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cctp/interfaces/ITokenMessenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface ITokenMessenger {\\n    /**\\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\\n     * on the destination domain must be called by `destinationCaller`.\\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\\n     * Emits a `DepositForBurn` event.\\n     * @dev reverts if:\\n     * - given destinationCaller is zero address\\n     * - given burnToken is not supported\\n     * - given destinationDomain has no TokenMessenger registered\\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\\n     * to this contract is less than `amount`.\\n     * - burn() reverts. For example, if `amount` is 0.\\n     * - MessageTransmitter returns false or reverts.\\n     * @param amount amount of tokens to burn\\n     * @param destinationDomain destination domain\\n     * @param mintRecipient address of mint recipient on destination domain\\n     * @param burnToken address of contract to burn deposited tokens, on local domain\\n     * @param destinationCaller caller on the destination domain, as bytes32\\n     * @return nonce unique nonce reserved by message\\n     */\\n    function depositForBurnWithCaller(\\n        uint256 amount,\\n        uint32 destinationDomain,\\n        bytes32 mintRecipient,\\n        address burnToken,\\n        bytes32 destinationCaller\\n    ) external returns (uint64 nonce);\\n\\n    /**\\n     * @notice Handles an incoming message received by the local MessageTransmitter,\\n     * and takes the appropriate action. For a burn message, mints the\\n     * associated token to the requested recipient on the local domain.\\n     * @dev Validates the local sender is the local MessageTransmitter, and the\\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\\n     * @param remoteDomain The domain where the message originated from.\\n     * @param sender The sender of the message (remote TokenMessenger).\\n     * @param messageBody The message body bytes.\\n     * @return success Bool, true if successful.\\n     */\\n    function handleReceiveMessage(\\n        uint32 remoteDomain,\\n        bytes32 sender,\\n        bytes calldata messageBody\\n    ) external returns (bool success);\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 VIEWS \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\\n    function localMessageTransmitter() external view returns (address);\\n\\n    // Minter responsible for minting and burning tokens on the local domain\\n    function localMinter() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/cctp/libs/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nerror CastOverflow();\\n\\nerror IncorrectRequestLength();\\nerror UnknownRequestVersion();\\n\\nerror CCTPGasRescueFailed();\\nerror CCTPIncorrectChainId();\\nerror CCTPIncorrectConfig();\\nerror CCTPIncorrectDomain();\\nerror CCTPIncorrectGasAmount();\\nerror CCTPIncorrectProtocolFee();\\nerror CCTPIncorrectTokenAmount();\\nerror CCTPInsufficientAmount();\\nerror CCTPSymbolAlreadyAdded();\\nerror CCTPSymbolIncorrect();\\nerror CCTPTokenAlreadyAdded();\\nerror CCTPTokenNotFound();\\nerror CCTPZeroAddress();\\nerror CCTPZeroAmount();\\n\\nerror CCTPMessageNotReceived();\\nerror RemoteCCTPDeploymentNotSet();\\nerror RemoteCCTPTokenNotSet();\\n\\nerror ForwarderDeploymentFailed();\\n\"\r\n    },\r\n    \"contracts/router/adapters/DefaultAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {IDefaultPool, IDefaultExtendedPool} from \\\"../interfaces/IDefaultExtendedPool.sol\\\";\\nimport {IRouterAdapter} from \\\"../interfaces/IRouterAdapter.sol\\\";\\nimport {IWETH9} from \\\"../interfaces/IWETH9.sol\\\";\\nimport {MsgValueIncorrect, PoolNotFound, TokenAddressMismatch, TokensIdentical} from \\\"../libs/Errors.sol\\\";\\nimport {Action, DefaultParams} from \\\"../libs/Structs.sol\\\";\\nimport {UniversalTokenLib} from \\\"../libs/UniversalToken.sol\\\";\\n\\nimport {SafeERC20, IERC20} from \\\"@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\\\";\\n\\ncontract DefaultAdapter is IRouterAdapter {\\n    using SafeERC20 for IERC20;\\n    using UniversalTokenLib for address;\\n\\n    /// @notice Enable this contract to receive Ether when withdrawing from WETH.\\n    /// @dev Consider implementing rescue functions to withdraw Ether from this contract.\\n    receive() external payable {}\\n\\n    /// @inheritdoc IRouterAdapter\\n    function adapterSwap(\\n        address recipient,\\n        address tokenIn,\\n        uint256 amountIn,\\n        address tokenOut,\\n        bytes memory rawParams\\n    ) external payable returns (uint256 amountOut) {\\n        return _adapterSwap(recipient, tokenIn, amountIn, tokenOut, rawParams);\\n    }\\n\\n    /// @dev Internal logic for doing a tokenIn -> tokenOut swap.\\n    /// Note: `tokenIn` is assumed to have already been transferred to this contract.\\n    function _adapterSwap(\\n        address recipient,\\n        address tokenIn,\\n        uint256 amountIn,\\n        address tokenOut,\\n        bytes memory rawParams\\n    ) internal virtual returns (uint256 amountOut) {\\n        // We define a few phases for the whole Adapter's swap process.\\n        // (?) means the phase is optional.\\n        // (!) means the phase is mandatory.\\n\\n        // PHASE 0(!): CHECK ALL THE PARAMS\\n        DefaultParams memory params = _checkParams(tokenIn, tokenOut, rawParams);\\n\\n        // PHASE 1(?): WRAP RECEIVED ETH INTO WETH\\n        tokenIn = _wrapReceivedETH(tokenIn, amountIn, tokenOut, params);\\n        // After PHASE 1 this contract has `amountIn` worth of `tokenIn`, tokenIn != ETH_ADDRESS\\n\\n        // PHASE 2(?): PREPARE TO UNWRAP SWAPPED WETH\\n        address tokenSwapTo = _deriveTokenSwapTo(tokenIn, tokenOut, params);\\n        // We need to perform tokenIn -> tokenSwapTo action in PHASE 3.\\n        // if tokenOut == ETH_ADDRESS, we need to unwrap WETH in PHASE 4.\\n        // Recipient will receive `tokenOut` in PHASE 5.\\n\\n        // PHASE 3(?): PERFORM A REQUESTED SWAP\\n        amountOut = _performPoolAction(tokenIn, amountIn, tokenSwapTo, params);\\n        // After PHASE 3 this contract has `amountOut` worth of `tokenSwapTo`, tokenSwapTo != ETH_ADDRESS\\n\\n        // PHASE 4(?): UNWRAP SWAPPED WETH\\n        // Check if the final token is native ETH\\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\\n            // PHASE 2: WETH address was stored as `tokenSwapTo`\\n            _unwrapETH(tokenSwapTo, amountOut);\\n        }\\n\\n        // PHASE 5(!): TRANSFER SWAPPED TOKENS TO RECIPIENT\\n        // Note: this will transfer native ETH, if tokenOut == ETH_ADDRESS\\n        // Note: this is a no-op if recipient == address(this)\\n        tokenOut.universalTransfer(recipient, amountOut);\\n    }\\n\\n    /// @dev Checks the params and decodes them into a struct.\\n    function _checkParams(\\n        address tokenIn,\\n        address tokenOut,\\n        bytes memory rawParams\\n    ) internal pure returns (DefaultParams memory params) {\\n        if (tokenIn == tokenOut) revert TokensIdentical();\\n        // Decode params for swapping via a Default pool\\n        params = abi.decode(rawParams, (DefaultParams));\\n        // Swap pool should exist, if action other than HandleEth was requested\\n        if (params.pool == address(0) && params.action != Action.HandleEth) revert PoolNotFound();\\n    }\\n\\n    /// @dev Wraps native ETH into WETH, if requested.\\n    /// Returns the address of the token this contract ends up with.\\n    function _wrapReceivedETH(\\n        address tokenIn,\\n        uint256 amountIn,\\n        address tokenOut,\\n        DefaultParams memory params\\n    ) internal returns (address wrappedTokenIn) {\\n        // tokenIn was already transferred to this contract, check if we start from native ETH\\n        if (tokenIn == UniversalTokenLib.ETH_ADDRESS) {\\n            // Determine WETH address: this is either tokenOut (if no swap is needed),\\n            // or a pool token with index `tokenIndexFrom` (if swap is needed).\\n            wrappedTokenIn = _deriveWethAddress({token: tokenOut, params: params, isTokenFromWeth: true});\\n            // Wrap ETH into WETH and leave it in this contract\\n            _wrapETH(wrappedTokenIn, amountIn);\\n        } else {\\n            wrappedTokenIn = tokenIn;\\n            // For ERC20 tokens msg.value should be zero\\n            if (msg.value != 0) revert MsgValueIncorrect();\\n        }\\n    }\\n\\n    /// @dev Derives the address of token to be received after an action defined in `params`.\\n    function _deriveTokenSwapTo(\\n        address tokenIn,\\n        address tokenOut,\\n        DefaultParams memory params\\n    ) internal view returns (address tokenSwapTo) {\\n        // Check if swap to native ETH was requested\\n        if (tokenOut == UniversalTokenLib.ETH_ADDRESS) {\\n            // Determine WETH address: this is either tokenIn (if no swap is needed),\\n            // or a pool token with index `tokenIndexTo` (if swap is needed).\\n            tokenSwapTo = _deriveWethAddress({token: tokenIn, params: params, isTokenFromWeth: false});\\n        } else {\\n            tokenSwapTo = tokenOut;\\n        }\\n    }\\n\\n    /// @dev Performs an action defined in `params` and returns the amount of `tokenSwapTo` received.\\n    function _performPoolAction(\\n        address tokenIn,\\n        uint256 amountIn,\\n        address tokenSwapTo,\\n        DefaultParams memory params\\n    ) internal returns (uint256 amountOut) {\\n        // Determine if we need to perform a swap\\n        if (params.action == Action.HandleEth) {\\n            // If no swap is required, amountOut doesn't change\\n            amountOut = amountIn;\\n        } else {\\n            // Record balance before the swap\\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this));\\n            // Approve the pool for spending exactly `amountIn` of `tokenIn`\\n            IERC20(tokenIn).safeIncreaseAllowance(params.pool, amountIn);\\n            if (params.action == Action.Swap) {\\n                _swap(params.pool, params, amountIn, tokenSwapTo);\\n            } else if (params.action == Action.AddLiquidity) {\\n                _addLiquidity(params.pool, params, amountIn, tokenSwapTo);\\n            } else {\\n                // The only remaining action is RemoveLiquidity\\n                _removeLiquidity(params.pool, params, amountIn, tokenSwapTo);\\n            }\\n            // Use the difference between the balance after the swap and the recorded balance as `amountOut`\\n            amountOut = IERC20(tokenSwapTo).balanceOf(address(this)) - amountOut;\\n        }\\n    }\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 INTERNAL LOGIC: SWAP ACTIONS \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    /// @dev Performs a swap through the given pool.\\n    /// Note: The pool should be already approved for spending `tokenIn`.\\n    function _swap(\\n        address pool,\\n        DefaultParams memory params,\\n        uint256 amountIn,\\n        address tokenOut\\n    ) internal {\\n        // tokenOut should match the \\\"swap to\\\" token\\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\\n        // amountOut and deadline are not checked in RouterAdapter\\n        IDefaultPool(pool).swap({\\n            tokenIndexFrom: params.tokenIndexFrom,\\n            tokenIndexTo: params.tokenIndexTo,\\n            dx: amountIn,\\n            minDy: 0,\\n            deadline: type(uint256).max\\n        });\\n    }\\n\\n    /// @dev Adds liquidity in a form of a single token to the given pool.\\n    /// Note: The pool should be already approved for spending `tokenIn`.\\n    function _addLiquidity(\\n        address pool,\\n        DefaultParams memory params,\\n        uint256 amountIn,\\n        address tokenOut\\n    ) internal {\\n        uint256 numTokens = _getPoolNumTokens(pool);\\n        address lpToken = _getPoolLPToken(pool);\\n        // tokenOut should match the LP token\\n        if (lpToken != tokenOut) revert TokenAddressMismatch();\\n        uint256[] memory amounts = new uint256[](numTokens);\\n        amounts[params.tokenIndexFrom] = amountIn;\\n        // amountOut and deadline are not checked in RouterAdapter\\n        IDefaultExtendedPool(pool).addLiquidity({amounts: amounts, minToMint: 0, deadline: type(uint256).max});\\n    }\\n\\n    /// @dev Removes liquidity in a form of a single token from the given pool.\\n    /// Note: The pool should be already approved for spending `tokenIn`.\\n    function _removeLiquidity(\\n        address pool,\\n        DefaultParams memory params,\\n        uint256 amountIn,\\n        address tokenOut\\n    ) internal {\\n        // tokenOut should match the \\\"swap to\\\" token\\n        if (IDefaultPool(pool).getToken(params.tokenIndexTo) != tokenOut) revert TokenAddressMismatch();\\n        // amountOut and deadline are not checked in RouterAdapter\\n        IDefaultExtendedPool(pool).removeLiquidityOneToken({\\n            tokenAmount: amountIn,\\n            tokenIndex: params.tokenIndexTo,\\n            minAmount: 0,\\n            deadline: type(uint256).max\\n        });\\n    }\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 INTERNAL LOGIC: POOL LENS \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    /// @dev Returns the LP token address of the given pool.\\n    function _getPoolLPToken(address pool) internal view returns (address lpToken) {\\n        (, , , , , , lpToken) = IDefaultExtendedPool(pool).swapStorage();\\n    }\\n\\n    /// @dev Returns the number of tokens in the given pool.\\n    function _getPoolNumTokens(address pool) internal view returns (uint256 numTokens) {\\n        // Iterate over all tokens in the pool until the end is reached\\n        for (uint8 index = 0; ; ++index) {\\n            try IDefaultPool(pool).getToken(index) returns (address) {} catch {\\n                // End of pool reached\\n                numTokens = index;\\n                break;\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the tokens in the given pool.\\n    function _getPoolTokens(address pool) internal view returns (address[] memory tokens) {\\n        uint256 numTokens = _getPoolNumTokens(pool);\\n        tokens = new address[](numTokens);\\n        for (uint8 i = 0; i < numTokens; ++i) {\\n            // This will not revert because we already know the number of tokens in the pool\\n            tokens[i] = IDefaultPool(pool).getToken(i);\\n        }\\n    }\\n\\n    /// @dev Returns the quote for a swap through the given pool.\\n    /// Note: will return 0 on invalid swaps.\\n    function _getPoolSwapQuote(\\n        address pool,\\n        uint8 tokenIndexFrom,\\n        uint8 tokenIndexTo,\\n        uint256 amountIn\\n    ) internal view returns (uint256 amountOut) {\\n        try IDefaultPool(pool).calculateSwap(tokenIndexFrom, tokenIndexTo, amountIn) returns (uint256 dy) {\\n            amountOut = dy;\\n        } catch {\\n            // Return 0 instead of reverting\\n            amountOut = 0;\\n        }\\n    }\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 INTERNAL LOGIC: ETH <> WETH \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    /// @dev Wraps ETH into WETH.\\n    function _wrapETH(address weth, uint256 amount) internal {\\n        if (amount != msg.value) revert MsgValueIncorrect();\\n        // Deposit in order to have WETH in this contract\\n        IWETH9(weth).deposit{value: amount}();\\n    }\\n\\n    /// @dev Unwraps WETH into ETH.\\n    function _unwrapETH(address weth, uint256 amount) internal {\\n        // Withdraw ETH to this contract\\n        IWETH9(weth).withdraw(amount);\\n    }\\n\\n    /// @dev Derives WETH address from swap parameters.\\n    function _deriveWethAddress(\\n        address token,\\n        DefaultParams memory params,\\n        bool isTokenFromWeth\\n    ) internal view returns (address weth) {\\n        if (params.action == Action.HandleEth) {\\n            // If we only need to wrap/unwrap ETH, WETH address should be specified as the other token\\n            weth = token;\\n        } else {\\n            // Otherwise, we need to get WETH address from the liquidity pool\\n            weth = address(\\n                IDefaultPool(params.pool).getToken(isTokenFromWeth ? params.tokenIndexFrom : params.tokenIndexTo)\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/router/interfaces/IRouterAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IRouterAdapter {\\n    /// @notice Performs a tokenIn -> tokenOut swap, according to the provided params.\\n    /// If tokenIn is ETH_ADDRESS, this method should be invoked with `msg.value = amountIn`.\\n    /// If tokenIn is ERC20, the tokens should be already transferred to this contract (using `msg.value = 0`).\\n    /// If tokenOut is ETH_ADDRESS, native ETH will be sent to the recipient (be aware of potential reentrancy).\\n    /// If tokenOut is ERC20, the tokens will be transferred to the recipient.\\n    /// @dev Contracts implementing {IRouterAdapter} interface are required to enforce the above restrictions.\\n    /// On top of that, they must ensure that exactly `amountOut` worth of `tokenOut` is transferred to the recipient.\\n    /// Swap deadline and slippage is checked outside of this contract.\\n    /// @param recipient    Address to receive the swapped token\\n    /// @param tokenIn      Token to sell (use ETH_ADDRESS to start from native ETH)\\n    /// @param amountIn     Amount of tokens to sell\\n    /// @param tokenOut     Token to buy (use ETH_ADDRESS to end with native ETH)\\n    /// @param rawParams    Additional swap parameters\\n    /// @return amountOut   Amount of bought tokens\\n    function adapterSwap(\\n        address recipient,\\n        address tokenIn,\\n        uint256 amountIn,\\n        address tokenOut,\\n        bytes calldata rawParams\\n    ) external payable returns (uint256 amountOut);\\n}\\n\"\r\n    },\r\n    \"contracts/router/libs/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nerror DeadlineExceeded();\\nerror InsufficientOutputAmount();\\n\\nerror MsgValueIncorrect();\\nerror PoolNotFound();\\nerror TokenAddressMismatch();\\nerror TokenNotContract();\\nerror TokenNotETH();\\nerror TokensIdentical();\\n\"\r\n    },\r\n    \"contracts/router/libs/UniversalToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {TokenNotContract} from \\\"./Errors.sol\\\";\\nimport {SafeERC20, IERC20} from \\\"@openzeppelin/contracts-4.5.0/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nlibrary UniversalTokenLib {\\n    using SafeERC20 for IERC20;\\n\\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    /// @notice Transfers tokens to the given account. Reverts if transfer is not successful.\\n    /// @dev This might trigger fallback, if ETH is transferred to the contract.\\n    /// Make sure this can not lead to reentrancy attacks.\\n    function universalTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // Don't do anything, if need to send tokens to this address\\n        if (to == address(this)) return;\\n        if (token == ETH_ADDRESS) {\\n            /// @dev Note: this can potentially lead to executing code in `to`.\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (bool success, ) = to.call{value: value}(\\\"\\\");\\n            require(success, \\\"ETH transfer failed\\\");\\n        } else {\\n            IERC20(token).safeTransfer(to, value);\\n        }\\n    }\\n\\n    /// @notice Issues an infinite allowance to the spender, if the current allowance is insufficient\\n    /// to spend the given amount.\\n    function universalApproveInfinity(\\n        address token,\\n        address spender,\\n        uint256 amountToSpend\\n    ) internal {\\n        // ETH Chad doesn't require your approval\\n        if (token == ETH_ADDRESS) return;\\n        // No-op if allowance is already sufficient\\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\\n        if (allowance >= amountToSpend) return;\\n        // Otherwise, reset approval to 0 and set to max allowance\\n        if (allowance > 0) IERC20(token).safeApprove(spender, 0);\\n        IERC20(token).safeApprove(spender, type(uint256).max);\\n    }\\n\\n    /// @notice Returns the balance of the given token (or native ETH) for the given account.\\n    function universalBalanceOf(address token, address account) internal view returns (uint256) {\\n        if (token == ETH_ADDRESS) {\\n            return account.balance;\\n        } else {\\n            return IERC20(token).balanceOf(account);\\n        }\\n    }\\n\\n    /// @dev Checks that token is a contract and not ETH_ADDRESS.\\n    function assertIsContract(address token) internal view {\\n        // Check that ETH_ADDRESS was not used (in case this is a predeploy on any of the chains)\\n        if (token == UniversalTokenLib.ETH_ADDRESS) revert TokenNotContract();\\n        // Check that token is not an EOA\\n        if (token.code.length == 0) revert TokenNotContract();\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-4.5.0/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-4.5.0/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts-4.5.0/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/router/interfaces/IDefaultExtendedPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {IDefaultPool} from \\\"./IDefaultPool.sol\\\";\\n\\ninterface IDefaultExtendedPool is IDefaultPool {\\n    function addLiquidity(\\n        uint256[] calldata amounts,\\n        uint256 minToMint,\\n        uint256 deadline\\n    ) external returns (uint256);\\n\\n    function removeLiquidityOneToken(\\n        uint256 tokenAmount,\\n        uint8 tokenIndex,\\n        uint256 minAmount,\\n        uint256 deadline\\n    ) external returns (uint256);\\n\\n    // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 VIEWS \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n\\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\\n\\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\\n        external\\n        view\\n        returns (uint256 availableTokenAmount);\\n\\n    function getAPrecise() external view returns (uint256);\\n\\n    function getTokenBalance(uint8 index) external view returns (uint256);\\n\\n    function swapStorage()\\n        external\\n        view\\n        returns (\\n            uint256 initialA,\\n            uint256 futureA,\\n            uint256 initialATime,\\n            uint256 futureATime,\\n            uint256 swapFee,\\n            uint256 adminFee,\\n            address lpToken\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/router/interfaces/IWETH9.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IWETH9 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 wad) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"@boringcrypto/=node_modules/@boringcrypto/\",\r\n      \"@ensdomains/=node_modules/@ensdomains/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"eth-gas-reporter/=node_modules/eth-gas-reporter/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hardhat-deploy/=node_modules/hardhat-deploy/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"sol-explore/=node_modules/sol-explore/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"synthetix/=node_modules/synthetix/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_synapseCCTP\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DeadlineExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientOutputAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MsgValueIncorrect\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenAddressMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenNotContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenNotETH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokensIdentical\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnknownRequestAction\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"name\":\"adapterSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"routerAdapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapQuery\",\"name\":\"originQuery\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"routerAdapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapQuery\",\"name\":\"destQuery\",\"type\":\"tuple\"}],\"name\":\"bridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSwap\",\"type\":\"bool\"}],\"name\":\"calculateFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"feeStructures\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"relayerFee\",\"type\":\"uint40\"},{\"internalType\":\"uint72\",\"name\":\"minBaseFee\",\"type\":\"uint72\"},{\"internalType\":\"uint72\",\"name\":\"minSwapFee\",\"type\":\"uint72\"},{\"internalType\":\"uint72\",\"name\":\"maxFee\",\"type\":\"uint72\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getConnectedBridgeTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct BridgeToken[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"internalType\":\"struct DestRequest[]\",\"name\":\"requests\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getDestinationAmountOut\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"routerAdapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapQuery[]\",\"name\":\"destQueries\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"tokenSymbols\",\"type\":\"string[]\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"getOriginAmountOut\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"routerAdapter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"rawParams\",\"type\":\"bytes\"}],\"internalType\":\"struct SwapQuery[]\",\"name\":\"originQueries\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"synapseCCTP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SynapseCCTPRouter", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000012715a66773bd9c54534a01abf01d05f6b4bd35e", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}