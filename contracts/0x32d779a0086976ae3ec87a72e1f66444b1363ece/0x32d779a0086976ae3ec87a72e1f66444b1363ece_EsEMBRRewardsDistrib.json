{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/EsEMBRRewardsDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport \\\"./IEsEMBR.sol\\\";\\nimport \\\"solmate/auth/Owned.sol\\\";\\n\\ncontract EsEMBRRewardsDistributor is Owned {\\n    IEsEMBR public esEmbr;\\n\\n    uint256 public emissionPerSecondEth; // Max esEMBR emissions per second for ETH stakers\\n    uint256 public emissionPerSecondEmbr; // Max esEMBR emissions per second for EMBR stakers\\n\\n    uint256 private lastEmissionTimeEth;\\n    uint256 private lastEmissionTimeEmbr;\\n\\n    constructor() Owned(msg.sender) { }\\n\\n    modifier onlyEsEMBR() {\\n        require(msg.sender == address(esEmbr), \\\"EsEMBRRewardsDistributor: Only esEMBR contract can call this function\\\");\\n        _;\\n    }\\n\\n    function setEsEMBR(address payable _esEmbr) external onlyOwner {\\n        esEmbr = IEsEMBR(_esEmbr);\\n    }\\n\\n    function setEmissionPerSecondEth(uint256 amount) external onlyOwner {\\n        esEmbr.updateRewardsEthForAll();\\n\\n        emissionPerSecondEth = amount;\\n        lastEmissionTimeEth = block.timestamp;\\n    }\\n\\n    function setEmissionPerSecondEmbr(uint256 amount) external onlyOwner {\\n        esEmbr.updateRewardsEmbrForAll();\\n\\n        emissionPerSecondEmbr = amount;\\n        lastEmissionTimeEmbr = block.timestamp;\\n    }\\n\\n    function _clamp(uint256 value, uint256 max) internal pure returns(uint256) {\\n        return value > max ? max : value;\\n    }\\n\\n    function distributeForEth() onlyEsEMBR external returns (uint256) {\\n        uint256 tokens_to_emit = pendingForEth();\\n        if (tokens_to_emit == 0) return 0;\\n\\n        lastEmissionTimeEth = block.timestamp;\\n\\n        return _clamp(tokens_to_emit, esEmbr.rewardsLeft());\\n    }\\n\\n    function distributeForEmbr() onlyEsEMBR external returns (uint256) {\\n        uint256 tokens_to_emit = pendingForEmbr();\\n        if (tokens_to_emit == 0) return 0;\\n\\n        lastEmissionTimeEmbr = block.timestamp;\\n\\n        return _clamp(tokens_to_emit, esEmbr.rewardsLeft());\\n    }\\n\\n    function pendingForEth() public view returns (uint256) {\\n        if (lastEmissionTimeEth == block.timestamp) return 0;\\n\\n        return (block.timestamp - lastEmissionTimeEth) * emissionPerSecondEth;\\n    }\\n\\n    function pendingForEmbr() public view returns (uint256) {\\n        if (lastEmissionTimeEmbr == block.timestamp) return 0;\\n\\n        return (block.timestamp - lastEmissionTimeEmbr) * emissionPerSecondEmbr;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/IEsEMBR.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport \\\"./IVester.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IEsEMBR {\\n    function updateRewardsEthForAll() external;\\n    function updateRewardsEmbrForAll() external;\\n    function addVester(uint timeframe, IVester vester) external;\\n    function reward(address recipient, uint amount) external;\\n\\n    function claimable(address _address) external view returns (uint256);\\n    function claim() external returns (uint256);\\n\\n    function claimableRevShare(address _address) external view returns (uint256);\\n    function claimRevShare() external returns (uint256);\\n    function claimableEMBR(address addy, uint256[] calldata timeframes) external view returns (uint256);\\n\\n    function batchCollectVested(uint[] calldata timeframes) external returns (uint);\\n    function collectVested(uint timeframe) external returns (uint);\\n\\n    function rewardsLeft() external returns (uint);\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/IVester.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\ninterface IVester {\\n    function vest(address user, uint256 amount) external; // called by esembr contract only. This is where esembr contract will transfer the vested embr amount to the vester.\\n    function claimable(address user) external view returns (uint256 /* claimable amount */, uint256 /* entry time */);\\n    function claim(address user) external returns (uint256); // called by esembr contract only\\n    function vestingTime() external view returns (uint256);\\n    function vestingAmount(address) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/solmate/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solady/=lib/solady/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"distributeForEmbr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeForEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emissionPerSecondEmbr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emissionPerSecondEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"esEmbr\",\"outputs\":[{\"internalType\":\"contract IEsEMBR\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingForEmbr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingForEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setEmissionPerSecondEmbr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setEmissionPerSecondEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_esEmbr\",\"type\":\"address\"}],\"name\":\"setEsEMBR\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "EsEMBRRewardsDistributor", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1f1ba73018cc591b839a565cb2da6bd27ecddf1adde062645bb1da170856f1c8"}