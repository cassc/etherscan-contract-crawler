{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"node_modules/@openzeppelin/contracts/interfaces/draft-IERC1822.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overridden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/interfaces/IERC1967Upgrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\n/// @title IERC1967Upgrade\\n/// @author Rohan Kulkarni\\n/// @notice The external ERC1967Upgrade events and errors\\ninterface IERC1967Upgrade {\\n    ///                                                          ///\\n    ///                            EVENTS                        ///\\n    ///                                                          ///\\n\\n    /// @notice Emitted when the implementation is upgraded\\n    /// @param impl The address of the implementation\\n    event Upgraded(address impl);\\n\\n    ///                                                          ///\\n    ///                            ERRORS                        ///\\n    ///                                                          ///\\n\\n    /// @dev Reverts if an implementation is an invalid upgrade\\n    /// @param impl The address of the invalid implementation\\n    error INVALID_UPGRADE(address impl);\\n\\n    /// @dev Reverts if an implementation upgrade is not stored at the storage slot of the original\\n    error UNSUPPORTED_UUID();\\n\\n    /// @dev Reverts if an implementation does not support ERC1822 proxiableUUID()\\n    error ONLY_UUPS();\\n}\\n\"\r\n    },\r\n    \"src/lib/proxy/ERC1967Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport { Proxy } from \\\"@openzeppelin/contracts/proxy/Proxy.sol\\\";\\n\\nimport { IERC1967Upgrade } from \\\"../interfaces/IERC1967Upgrade.sol\\\";\\nimport { ERC1967Upgrade } from \\\"./ERC1967Upgrade.sol\\\";\\n\\n/// @title ERC1967Proxy\\n/// @author Rohan Kulkarni\\n/// @notice Modified from OpenZeppelin Contracts v4.7.3 (proxy/ERC1967/ERC1967Proxy.sol)\\n/// - Inherits a modern, minimal ERC1967Upgrade\\ncontract ERC1967Proxy is IERC1967Upgrade, Proxy, ERC1967Upgrade {\\n    ///                                                          ///\\n    ///                         CONSTRUCTOR                      ///\\n    ///                                                          ///\\n\\n    /// @dev Initializes the proxy with an implementation contract and encoded function call\\n    /// @param _logic The implementation address\\n    /// @param _data The encoded function call\\n    constructor(address _logic, bytes memory _data) payable {\\n        _upgradeToAndCall(_logic, _data, false);\\n    }\\n\\n    ///                                                          ///\\n    ///                          FUNCTIONS                       ///\\n    ///                                                          ///\\n\\n    /// @dev The address of the current implementation\\n    function _implementation() internal view virtual override returns (address) {\\n        return ERC1967Upgrade._getImplementation();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/proxy/ERC1967Upgrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport { IERC1822Proxiable } from \\\"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\\\";\\nimport { StorageSlot } from \\\"@openzeppelin/contracts/utils/StorageSlot.sol\\\";\\n\\nimport { IERC1967Upgrade } from \\\"../interfaces/IERC1967Upgrade.sol\\\";\\nimport { Address } from \\\"../utils/Address.sol\\\";\\n\\n/// @title ERC1967Upgrade\\n/// @author Rohan Kulkarni\\n/// @notice Modified from OpenZeppelin Contracts v4.7.3 (proxy/ERC1967/ERC1967Upgrade.sol)\\n/// - Uses custom errors declared in IERC1967Upgrade\\n/// - Removes ERC1967 admin and beacon support\\nabstract contract ERC1967Upgrade is IERC1967Upgrade {\\n    ///                                                          ///\\n    ///                          CONSTANTS                       ///\\n    ///                                                          ///\\n\\n    /// @dev bytes32(uint256(keccak256('eip1967.proxy.rollback')) - 1)\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /// @dev bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    ///                                                          ///\\n    ///                          FUNCTIONS                       ///\\n    ///                                                          ///\\n\\n    /// @dev Upgrades to an implementation with security checks for UUPS proxies and an additional function call\\n    /// @param _newImpl The new implementation address\\n    /// @param _data The encoded function call\\n    function _upgradeToAndCallUUPS(\\n        address _newImpl,\\n        bytes memory _data,\\n        bool _forceCall\\n    ) internal {\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(_newImpl);\\n        } else {\\n            try IERC1822Proxiable(_newImpl).proxiableUUID() returns (bytes32 slot) {\\n                if (slot != _IMPLEMENTATION_SLOT) revert UNSUPPORTED_UUID();\\n            } catch {\\n                revert ONLY_UUPS();\\n            }\\n\\n            _upgradeToAndCall(_newImpl, _data, _forceCall);\\n        }\\n    }\\n\\n    /// @dev Upgrades to an implementation with an additional function call\\n    /// @param _newImpl The new implementation address\\n    /// @param _data The encoded function call\\n    function _upgradeToAndCall(\\n        address _newImpl,\\n        bytes memory _data,\\n        bool _forceCall\\n    ) internal {\\n        _upgradeTo(_newImpl);\\n\\n        if (_data.length > 0 || _forceCall) {\\n            Address.functionDelegateCall(_newImpl, _data);\\n        }\\n    }\\n\\n    /// @dev Performs an implementation upgrade\\n    /// @param _newImpl The new implementation address\\n    function _upgradeTo(address _newImpl) internal {\\n        _setImplementation(_newImpl);\\n\\n        emit Upgraded(_newImpl);\\n    }\\n\\n    /// @dev Stores the address of an implementation\\n    /// @param _impl The implementation address\\n    function _setImplementation(address _impl) private {\\n        if (!Address.isContract(_impl)) revert INVALID_UPGRADE(_impl);\\n\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = _impl;\\n    }\\n\\n    /// @dev The address of the current implementation\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\n/// @title EIP712\\n/// @author Rohan Kulkarni\\n/// @notice Modified from OpenZeppelin Contracts v4.7.3 (utils/Address.sol)\\n/// - Uses custom errors `INVALID_TARGET()` & `DELEGATE_CALL_FAILED()`\\n/// - Adds util converting address to bytes32\\nlibrary Address {\\n    ///                                                          ///\\n    ///                            ERRORS                        ///\\n    ///                                                          ///\\n\\n    /// @dev Reverts if the target of a delegatecall is not a contract\\n    error INVALID_TARGET();\\n\\n    /// @dev Reverts if a delegatecall has failed\\n    error DELEGATE_CALL_FAILED();\\n\\n    ///                                                          ///\\n    ///                           FUNCTIONS                      ///\\n    ///                                                          ///\\n\\n    /// @dev Utility to convert an address to bytes32\\n    function toBytes32(address _account) internal pure returns (bytes32) {\\n        return bytes32(uint256(uint160(_account)) << 96);\\n    }\\n\\n    /// @dev If an address is a contract\\n    function isContract(address _account) internal view returns (bool rv) {\\n        assembly {\\n            rv := gt(extcodesize(_account), 0)\\n        }\\n    }\\n\\n    /// @dev Performs a delegatecall on an address\\n    function functionDelegateCall(address _target, bytes memory _data) internal returns (bytes memory) {\\n        if (!isContract(_target)) revert INVALID_TARGET();\\n\\n        (bool success, bytes memory returndata) = _target.delegatecall(_data);\\n\\n        return verifyCallResult(success, returndata);\\n    }\\n\\n    /// @dev Verifies a delegatecall was successful\\n    function verifyCallResult(bool _success, bytes memory _returndata) internal pure returns (bytes memory) {\\n        if (_success) {\\n            return _returndata;\\n        } else {\\n            if (_returndata.length > 0) {\\n                assembly {\\n                    let returndata_size := mload(_returndata)\\n\\n                    revert(add(32, _returndata), returndata_size)\\n                }\\n            } else {\\n                revert DELEGATE_CALL_FAILED();\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"micro-onchain-metadata-utils/=node_modules/micro-onchain-metadata-utils/src/\",\r\n      \"sol-uriencode/=node_modules/sol-uriencode/\",\r\n      \"sol2string/=node_modules/sol2string/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 500000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_logic\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DELEGATE_CALL_FAILED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_TARGET\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"}],\"name\":\"INVALID_UPGRADE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ONLY_UUPS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UNSUPPORTED_UUID\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ERC1967Proxy", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "500000", "ConstructorArguments": "0000000000000000000000008635e2bab89f9114564b2158cd8ef84b8313d27b00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000024c4d66de8000000000000000000000000c4da93843ca009814325aa5437412c85612d3f1f00000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0xb42d8e37dcba5fe5323c4a6722ba6ded9e8e84da", "SwarmSource": ""}