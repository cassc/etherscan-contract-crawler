{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/antiMev/OnlyOneTransactionPerBlockAntiMevStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.21;\\r\\n\\r\\nimport {Ownable} from \\\"../oz/access/Ownable.sol\\\";\\r\\nimport {IAntiMevStrategy} from \\\"../interfaces/IAntiMevStrategy.sol\\\";\\r\\nimport {IPair} from \\\"../interfaces/IPair.sol\\\";\\r\\nimport {IUniswapV2Factory} from \\\"../interfaces/IUniswapV2Factory.sol\\\";\\r\\nimport {IUniswapV3Factory} from \\\"../interfaces/IUniswapV3Factory.sol\\\";\\r\\nimport {IPoolV3} from \\\"../interfaces/IPoolV3.sol\\\";\\r\\n\\r\\n/// @title\\r\\n/// @author\\r\\n/// @notice This contains the logic necessary for blocking MEV bots from frontrunning transactions.\\r\\ncontract OnlyOneTransactionPerBlockAntiMevStrategy is Ownable, IAntiMevStrategy {\\r\\n  event SetFactoryWhitelist(address whitelist, uint8 version, bool isWhitelisted);\\r\\n\\r\\n  error OnlyOneTransferPerBlockPerAddress(address);\\r\\n  error OnlyBen();\\r\\n\\r\\n  struct FactoryInfo {\\r\\n    bool isWhitelisted;\\r\\n    uint8 version;\\r\\n  }\\r\\n\\r\\n  address private ben;\\r\\n  mapping(bytes32 accountHash => bool[2] directions) private accountTransferredPerBlock;\\r\\n  mapping(address factory => FactoryInfo factoryInfo) private factoryInfos;\\r\\n\\r\\n  modifier onlyBen() {\\r\\n    if (msg.sender != ben) {\\r\\n      revert OnlyBen();\\r\\n    }\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  constructor(address _ben) {\\r\\n    ben = _ben;\\r\\n  }\\r\\n\\r\\n  function onTransfer(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    bool _fromIsWhitelisted,\\r\\n    bool _toIsWhitelisted,\\r\\n    uint256 /*_amount*/,\\r\\n    bool _isTaxingInProgress\\r\\n  ) external override onlyBen {\\r\\n    // If from or to an LP, then whitelist it from MEV\\r\\n    bool fromIsWhitelisted = _fromIsWhitelisted;\\r\\n    if (!fromIsWhitelisted) {\\r\\n      fromIsWhitelisted = _isPair(_from);\\r\\n    }\\r\\n\\r\\n    bool toIsWhitelisted = _toIsWhitelisted;\\r\\n    if (!toIsWhitelisted) {\\r\\n      toIsWhitelisted = _isPair(_to);\\r\\n    }\\r\\n\\r\\n    if (!_isTaxingInProgress) {\\r\\n      if (!_fromIsWhitelisted) {\\r\\n        bytes32 key = keccak256(abi.encodePacked(block.number, _from));\\r\\n        if (accountTransferredPerBlock[key][1]) {\\r\\n          revert OnlyOneTransferPerBlockPerAddress(_from);\\r\\n        }\\r\\n        accountTransferredPerBlock[key][0] = true;\\r\\n      }\\r\\n      if (!_toIsWhitelisted) {\\r\\n        bytes32 key = keccak256(abi.encodePacked(block.number, _to));\\r\\n        if (accountTransferredPerBlock[key][0]) {\\r\\n          revert OnlyOneTransferPerBlockPerAddress(_to);\\r\\n        }\\r\\n        accountTransferredPerBlock[key][1] = true;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _isPair(address _target) private view returns (bool) {\\r\\n    // Not a contract\\r\\n    if (_target.code.length == 0) {\\r\\n      return false;\\r\\n    }\\r\\n\\r\\n    IPair pairContract = IPair(_target);\\r\\n    address factory;\\r\\n    try pairContract.factory() returns (address _factory) {\\r\\n      factory = _factory;\\r\\n    } catch {\\r\\n      return false;\\r\\n    }\\r\\n\\r\\n    // Possible pair, check if factory is whitelisted\\r\\n    FactoryInfo memory factoryInfo = factoryInfos[factory];\\r\\n    if (!factoryInfo.isWhitelisted) {\\r\\n      return false;\\r\\n    }\\r\\n\\r\\n    // Check if this is actually an LP\\r\\n    address token0;\\r\\n    try pairContract.token0() returns (address _token0) {\\r\\n      token0 = _token0;\\r\\n    } catch {\\r\\n      return false;\\r\\n    }\\r\\n\\r\\n    address token1;\\r\\n    try pairContract.token1() returns (address _token1) {\\r\\n      token1 = _token1;\\r\\n    } catch {\\r\\n      return false;\\r\\n    }\\r\\n\\r\\n    if (factoryInfo.version == 2) {\\r\\n      // UniV2 pairs\\r\\n      return IUniswapV2Factory(factory).getPair(token0, token1) == _target;\\r\\n    } else if (factoryInfo.version == 3) {\\r\\n      // UniV3 pairs\\r\\n      uint24 fee;\\r\\n      try IPoolV3(_target).fee() returns (uint24 _fee) {\\r\\n        fee = _fee;\\r\\n      } catch {\\r\\n        return false;\\r\\n      }\\r\\n\\r\\n      return IUniswapV3Factory(factory).getPool(token0, token1, fee) == _target;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setFactoryWhitelist(address _whitelist, uint8 _version, bool _isWhitelisted) external onlyOwner {\\r\\n    factoryInfos[_whitelist].isWhitelisted = _isWhitelisted;\\r\\n    factoryInfos[_whitelist].version = _version;\\r\\n    emit SetFactoryWhitelist(_whitelist, _version, _isWhitelisted);\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IAntiMevStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.21;\\r\\n\\r\\ninterface IAntiMevStrategy {\\r\\n  function onTransfer(\\r\\n    address from,\\r\\n    address to,\\r\\n    bool fromIsWhitelisted,\\r\\n    bool toIsWhitelisted,\\r\\n    uint256 amount,\\r\\n    bool isTaxingInProgress\\r\\n  ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.21;\\r\\n\\r\\ninterface IPair {\\r\\n  function factory() external view returns (address);\\r\\n\\r\\n  function token0() external view returns (address);\\r\\n\\r\\n  function token1() external view returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.21;\\r\\n\\r\\ninterface IPoolV3 {\\r\\n  function fee() external view returns (uint24);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.21;\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n  function getPair(address tokenA, address tokenB) external view returns (address);\\r\\n\\r\\n  function createPair(address tokenA, address tokenB) external returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV3Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.21;\\r\\n\\r\\ninterface IUniswapV3Factory {\\r\\n  function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address pool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/oz/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../utils/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    error OnlyOwner();\\r\\n    error NewOwnerIsZeroAddress();\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the sender is not the owner.\\r\\n     */\\r\\n    function _checkOwner() internal view virtual {\\r\\n        if (owner() != _msgSender()) {\\r\\n            revert OnlyOwner();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby disabling any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        if (newOwner == address(0)) {\\r\\n            revert NewOwnerIsZeroAddress();\\r\\n        }\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/oz/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999999,\r\n      \"details\": {\r\n        \"yul\": true\r\n      }\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ben\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyBen\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"OnlyOneTransferPerBlockPerAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"whitelist\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isWhitelisted\",\"type\":\"bool\"}],\"name\":\"SetFactoryWhitelist\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_fromIsWhitelisted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_toIsWhitelisted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isTaxingInProgress\",\"type\":\"bool\"}],\"name\":\"onTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_whitelist\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_version\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"_isWhitelisted\",\"type\":\"bool\"}],\"name\":\"setFactoryWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OnlyOneTransactionPerBlockAntiMevStrategy", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "9999999", "ConstructorArguments": "00000000000000000000000052c08351298e2aa7f6c20a648142f129e9359cb2", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}