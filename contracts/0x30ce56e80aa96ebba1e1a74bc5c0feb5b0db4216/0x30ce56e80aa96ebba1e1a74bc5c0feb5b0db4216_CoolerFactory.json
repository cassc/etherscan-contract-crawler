{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/Cooler/src/CoolerFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {ClonesWithImmutableArgs} from \\\"clones/ClonesWithImmutableArgs.sol\\\";\\n\\nimport {Cooler} from \\\"./Cooler.sol\\\";\\n\\n/// @title  Cooler Loans Factory.\\n/// @notice The Cooler Factory creates new Cooler escrow contracts.\\n/// @dev    This contract uses Clones (https://github.com/wighawag/clones-with-immutable-args)\\n///         to save gas on deployment.\\ncontract CoolerFactory {\\n    using ClonesWithImmutableArgs for address;\\n\\n    // --- ERRORS ----------------------------------------------------\\n\\n    error NotFromFactory();\\n    error DecimalsNot18();\\n\\n    // --- EVENTS ----------------------------------------------------\\n\\n    /// @notice A global event when a new loan request is created.\\n    event RequestLoan(address indexed cooler, address collateral, address debt, uint256 reqID);\\n    /// @notice A global event when a loan request is rescinded.\\n    event RescindRequest(address indexed cooler, uint256 reqID);\\n    /// @notice A global event when a loan request is fulfilled.\\n    event ClearRequest(address indexed cooler, uint256 reqID, uint256 loanID);\\n    /// @notice A global event when a loan is repaid.\\n    event RepayLoan(address indexed cooler, uint256 loanID, uint256 amount);\\n    /// @notice A global event when a loan is extended.\\n    event ExtendLoan(address indexed cooler, uint256 loanID, uint8 times);\\n    /// @notice A global event when the collateral of defaulted loan is claimed.\\n    event DefaultLoan(address indexed cooler, uint256 loanID, uint256 amount);\\n\\n    // -- STATE VARIABLES --------------------------------------------\\n\\n    /// @notice Cooler reference implementation (deployed on creation to clone from).\\n    Cooler public immutable coolerImplementation;\\n\\n    /// @notice Mapping to validate deployed coolers.\\n    mapping(address => bool) public created;\\n\\n    /// @notice Mapping to prevent duplicate coolers.\\n    mapping(address => mapping(ERC20 => mapping(ERC20 => address))) private coolerFor;\\n\\n    /// @notice Mapping to query Coolers for Collateral-Debt pair.\\n    mapping(ERC20 => mapping(ERC20 => address[])) public coolersFor;\\n\\n    // --- INITIALIZATION --------------------------------------------\\n\\n    constructor() {\\n        coolerImplementation = new Cooler();\\n    }\\n\\n    // --- DEPLOY NEW COOLERS ----------------------------------------\\n\\n    /// @notice creates a new Escrow contract for collateral and debt tokens.\\n    /// @param  collateral_ the token given as collateral.\\n    /// @param  debt_ the token to be lent. Interest is denominated in debt tokens.\\n    /// @return cooler address of the contract.\\nfunction generateCooler(ERC20 collateral_, ERC20 debt_) external returns (address cooler) {\\n    // Return address if cooler exists.\\n    cooler = coolerFor[msg.sender][collateral_][debt_];\\n\\n    // Otherwise generate new cooler.\\n    if (cooler == address(0)) {\\n        if (collateral_.decimals() != 18 || debt_.decimals() != 18) revert DecimalsNot18();\\n        // Clone the cooler implementation.\\n        bytes memory coolerData = abi.encodePacked(\\n            msg.sender,              // owner\\n            address(collateral_),    // collateral\\n            address(debt_),          // debt\\n            address(this)            // factory\\n        );\\n        cooler = address(coolerImplementation).clone(coolerData);\\n\\n        // Update storage accordingly.\\n        coolerFor[msg.sender][collateral_][debt_] = cooler;\\n        coolersFor[collateral_][debt_].push(cooler);\\n        created[cooler] = true;\\n    }\\n}\\n\\n    // --- EMIT EVENTS -----------------------------------------------\\n\\n    /// @notice Ensure that the called is a Cooler.\\n    modifier onlyFromFactory {        \\n        if (!created[msg.sender]) revert NotFromFactory();\\n        _;\\n    }\\n\\n    /// @notice Emit a global event when a new loan request is created.\\n    function logRequestLoan(uint256 reqID_) external onlyFromFactory {\\n        emit RequestLoan(msg.sender, address(Cooler(msg.sender).collateral()), address(Cooler(msg.sender).debt()), reqID_);\\n    }\\n\\n    /// @notice Emit a global event when a loan request is rescinded.\\n    function logRescindRequest(uint256 reqID_) external onlyFromFactory {\\n        emit RescindRequest(msg.sender, reqID_);\\n    }\\n\\n    /// @notice Emit a global event when a loan request is fulfilled.\\n    function logClearRequest(uint256 reqID_, uint256 loanID_) external onlyFromFactory {\\n        emit ClearRequest(msg.sender, reqID_, loanID_);\\n    }\\n\\n    /// @notice Emit a global event when a loan is repaid.\\n    function logRepayLoan(uint256 loanID_, uint256 repayment_) external onlyFromFactory {\\n        emit RepayLoan(msg.sender, loanID_, repayment_);\\n    }\\n\\n    /// @notice Emit a global event when a loan is extended.\\n    function logExtendLoan(uint256 loanID_, uint8 times_) external onlyFromFactory {\\n        emit ExtendLoan(msg.sender, loanID_, times_);\\n    }\\n\\n    /// @notice Emit a global event when the collateral of defaulted loan is claimed.\\n    function logDefaultLoan(uint256 loanID_, uint256 collateral_) external onlyFromFactory {\\n        emit DefaultLoan(msg.sender, loanID_, collateral_);\\n    }\\n\\n    // --- AUX FUNCTIONS ---------------------------------------------\\n\\n    /// @notice Getter function to get an existing cooler for a given user <> collateral <> debt combination.\\n    function getCoolerFor(address user_, address collateral_, address debt_) public view returns (address) {\\n        return coolerFor[user_][ERC20(collateral_)][ERC20(debt_)];\\n    }\\n}\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/clones-with-immutable-args/src/ClonesWithImmutableArgs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD\\n\\npragma solidity ^0.8.4;\\n\\n/// @title ClonesWithImmutableArgs\\n/// @author wighawag, zefram.eth\\n/// @notice Enables creating clone contracts with immutable args\\nlibrary ClonesWithImmutableArgs {\\n    error CreateFail();\\n\\n    /// @notice Creates a clone proxy of the implementation contract, with immutable args\\n    /// @dev data cannot exceed 65535 bytes, since 2 bytes are used to store the data length\\n    /// @param implementation The implementation contract to clone\\n    /// @param data Encoded immutable args\\n    /// @return instance The address of the created clone\\n    function clone(address implementation, bytes memory data)\\n        internal\\n        returns (address instance)\\n    {\\n        // unrealistic for memory ptr or data length to exceed 256 bits\\n        unchecked {\\n            uint256 extraLength = data.length + 2; // +2 bytes for telling how much data there is appended to the call\\n            uint256 creationSize = 0x43 + extraLength;\\n            uint256 runSize = creationSize - 11;\\n            uint256 dataPtr;\\n            uint256 ptr;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                ptr := mload(0x40)\\n\\n                // -------------------------------------------------------------------------------------------------------------\\n                // CREATION (11 bytes)\\n                // -------------------------------------------------------------------------------------------------------------\\n\\n                // 3d          | RETURNDATASIZE        | 0                       | \u2013\\n                // 61 runtime  | PUSH2 runtime (r)     | r 0                     | \u2013\\n                mstore(\\n                    ptr,\\n                    0x3d61000000000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x02), shl(240, runSize)) // size of the contract running bytecode (16 bits)\\n\\n                // creation size = 0b\\n                // 80          | DUP1                  | r r 0                   | \u2013\\n                // 60 creation | PUSH1 creation (c)    | c r r 0                 | \u2013\\n                // 3d          | RETURNDATASIZE        | 0 c r r 0               | \u2013\\n                // 39          | CODECOPY              | r 0                     | [0-2d]: runtime code\\n                // 81          | DUP2                  | 0 c  0                  | [0-2d]: runtime code\\n                // f3          | RETURN                | 0                       | [0-2d]: runtime code\\n                mstore(\\n                    add(ptr, 0x04),\\n                    0x80600b3d3981f300000000000000000000000000000000000000000000000000\\n                )\\n\\n                // -------------------------------------------------------------------------------------------------------------\\n                // RUNTIME\\n                // -------------------------------------------------------------------------------------------------------------\\n\\n                // 36          | CALLDATASIZE          | cds                     | \u2013\\n                // 3d          | RETURNDATASIZE        | 0 cds                   | \u2013\\n                // 3d          | RETURNDATASIZE        | 0 0 cds                 | \u2013\\n                // 37          | CALLDATACOPY          | \u2013                       | [0, cds] = calldata\\n                // 61          | PUSH2 extra           | extra                   | [0, cds] = calldata\\n                mstore(\\n                    add(ptr, 0x0b),\\n                    0x363d3d3761000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x10), shl(240, extraLength))\\n\\n                // 60 0x38     | PUSH1 0x38            | 0x38 extra              | [0, cds] = calldata // 0x38 (56) is runtime size - data\\n                // 36          | CALLDATASIZE          | cds 0x38 extra          | [0, cds] = calldata\\n                // 39          | CODECOPY              | _                       | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | 0                       | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | 0 0                     | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | 0 0 0                   | [0, cds] = calldata\\n                // 36          | CALLDATASIZE          | cds 0 0 0               | [0, cds] = calldata\\n                // 61 extra    | PUSH2 extra           | extra cds 0 0 0         | [0, cds] = calldata\\n                mstore(\\n                    add(ptr, 0x12),\\n                    0x603836393d3d3d36610000000000000000000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x1b), shl(240, extraLength))\\n\\n                // 01          | ADD                   | cds+extra 0 0 0         | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | 0 cds 0 0 0             | [0, cds] = calldata\\n                // 73 addr     | PUSH20 0x123\u2026         | addr 0 cds 0 0 0        | [0, cds] = calldata\\n                mstore(\\n                    add(ptr, 0x1d),\\n                    0x013d730000000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x20), shl(0x60, implementation))\\n\\n                // 5a          | GAS                   | gas addr 0 cds 0 0 0    | [0, cds] = calldata\\n                // f4          | DELEGATECALL          | success 0               | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | rds success 0           | [0, cds] = calldata\\n                // 82          | DUP3                  | 0 rds success 0         | [0, cds] = calldata\\n                // 80          | DUP1                  | 0 0 rds success 0       | [0, cds] = calldata\\n                // 3e          | RETURNDATACOPY        | success 0               | [0, rds] = return data (there might be some irrelevant leftovers in memory [rds, cds] when rds < cds)\\n                // 90          | SWAP1                 | 0 success               | [0, rds] = return data\\n                // 3d          | RETURNDATASIZE        | rds 0 success           | [0, rds] = return data\\n                // 91          | SWAP2                 | success 0 rds           | [0, rds] = return data\\n                // 60 0x36     | PUSH1 0x36            | 0x36 sucess 0 rds       | [0, rds] = return data\\n                // 57          | JUMPI                 | 0 rds                   | [0, rds] = return data\\n                // fd          | REVERT                | \u2013                       | [0, rds] = return data\\n                // 5b          | JUMPDEST              | 0 rds                   | [0, rds] = return data\\n                // f3          | RETURN                | \u2013                       | [0, rds] = return data\\n\\n                mstore(\\n                    add(ptr, 0x34),\\n                    0x5af43d82803e903d91603657fd5bf30000000000000000000000000000000000\\n                )\\n            }\\n\\n            // -------------------------------------------------------------------------------------------------------------\\n            // APPENDED DATA (Accessible from extcodecopy)\\n            // (but also send as appended data to the delegatecall)\\n            // -------------------------------------------------------------------------------------------------------------\\n\\n            extraLength -= 2;\\n            uint256 counter = extraLength;\\n            uint256 copyPtr = ptr + 0x43;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                dataPtr := add(data, 32)\\n            }\\n            for (; counter >= 32; counter -= 32) {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    mstore(copyPtr, mload(dataPtr))\\n                }\\n\\n                copyPtr += 32;\\n                dataPtr += 32;\\n            }\\n            uint256 mask = ~(256**(32 - counter) - 1);\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                mstore(copyPtr, and(mload(dataPtr), mask))\\n            }\\n            copyPtr += counter;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                mstore(copyPtr, shl(240, extraLength))\\n            }\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                instance := create(0, ptr, creationSize)\\n            }\\n            if (instance == address(0)) {\\n                revert CreateFail();\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/Cooler/src/Cooler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {Clone} from \\\"clones/Clone.sol\\\";\\n\\nimport {CoolerFactory} from \\\"./CoolerFactory.sol\\\";\\nimport {CoolerCallback} from \\\"./CoolerCallback.sol\\\";\\n\\n// Function sig taken from gOHM contract\\ninterface IDelegate { function delegate(address to_) external; }\\n\\n\\n/// @title  Cooler Loans.\\n/// @notice A Cooler is a smart contract escrow that facilitates fixed-duration, peer-to-peer\\n///         loans for a user-defined debt-collateral pair.\\n/// @dev    This contract uses Clones (https://github.com/wighawag/clones-with-immutable-args)\\n///         to save gas on deployment.\\ncontract Cooler is Clone {\\n    using SafeTransferLib for ERC20;\\n\\n    // --- ERRORS ----------------------------------------------------\\n\\n    error OnlyApproved();\\n    error Deactivated();\\n    error Default();\\n    error NotExpired();\\n    error NotCoolerCallback();\\n\\n    // --- DATA STRUCTURES -------------------------------------------\\n\\n    /// @notice A loan begins with a borrow request.\\n    struct Request {\\n        uint256 amount;             // Amount to be borrowed.\\n        uint256 interest;           // Annualized percentage to be paid as interest.\\n        uint256 loanToCollateral;   // Requested loan-to-collateral ratio.\\n        uint256 duration;           // Time to repay the loan before it defaults.\\n        bool active;                // Any lender can clear an active loan request.\\n        address requester;          // The address that created the request.\\n    }\\n\\n    /// @notice A request is converted to a loan when a lender clears it.\\n    struct Loan {\\n        Request request;        // Loan terms specified in the request.\\n        uint256 principal;      // Amount of principal debt owed to the lender.\\n        uint256 interestDue;    // Interest owed to the lender.\\n        uint256 collateral;     // Amount of collateral pledged.\\n        uint256 expiry;         // Time when the loan defaults.\\n        address lender;         // Lender's address.\\n        address recipient;      // Recipient of repayments.\\n        bool callback;          // If this is true, the lender must inherit CoolerCallback.\\n    }\\n\\n    // --- IMMUTABLES ------------------------------------------------\\n\\n    // This makes the code look prettier.\\n    uint256 private constant DECIMALS_INTEREST = 1e18;\\n\\n    /// @notice This address owns the collateral in escrow.\\n    function owner() public pure returns (address _owner) {\\n        return _getArgAddress(0x0);\\n    }\\n\\n    /// @notice This token is borrowed against.\\n    function collateral() public pure returns (ERC20 _collateral) {\\n        return ERC20(_getArgAddress(0x14));\\n    }\\n\\n    /// @notice This token is lent.\\n    function debt() public pure returns (ERC20 _debt) {\\n        return ERC20(_getArgAddress(0x28));\\n    }\\n    \\n    /// @notice This contract created the Cooler\\n    function factory() public pure returns (CoolerFactory _factory) {\\n        return CoolerFactory(_getArgAddress(0x3c));\\n    }\\n\\n    // --- STATE VARIABLES -------------------------------------------\\n\\n    /// @notice Arrays stores all the loan requests.\\n    Request[] public requests;\\n\\n    /// @notice Arrays stores all the granted loans.\\n    Loan[] public loans;\\n\\n    /// @notice Facilitates transfer of lender ownership to new addresses\\n    mapping(uint256 => address) public approvals;\\n\\n    // --- BORROWER --------------------------------------------------\\n\\n    /// @notice Request a loan with given parameters.\\n    ///         Collateral is taken at time of request.\\n    /// @param  amount_ of debt tokens to borrow.\\n    /// @param  interest_ to pay (annualized % of 'amount_'). Expressed in DECIMALS_INTEREST.\\n    /// @param  loanToCollateral_ debt tokens per collateral token pledged. Expressed in 10**collateral().decimals().\\n    /// @param  duration_ of loan tenure in seconds.\\n    /// @return reqID of the created request. Equivalent to the index of request in requests[].\\n    function requestLoan(\\n        uint256 amount_,\\n        uint256 interest_,\\n        uint256 loanToCollateral_,\\n        uint256 duration_\\n    ) external returns (uint256 reqID) {\\n        reqID = requests.length;\\n        requests.push(\\n            Request({\\n                amount: amount_,\\n                interest: interest_,\\n                loanToCollateral: loanToCollateral_,\\n                duration: duration_,\\n                active: true,\\n                requester: msg.sender\\n            })\\n        );\\n\\n        // The collateral is taken upfront. Will be escrowed\\n        // until the loan is repaid or defaulted.\\n        collateral().safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            collateralFor(amount_, loanToCollateral_)\\n        );\\n\\n        // Log the event.\\n        factory().logRequestLoan(reqID);\\n    }\\n\\n    /// @notice Cancel a loan request and get the collateral back.\\n    /// @param  reqID_ index of request in requests[].\\n    function rescindRequest(uint256 reqID_) external {\\n        if (msg.sender != owner()) revert OnlyApproved();\\n\\n        Request storage req = requests[reqID_];\\n\\n        if (!req.active) revert Deactivated();\\n\\n        // Update storage and send collateral back to the owner.\\n        req.active = false;\\n        collateral().safeTransfer(owner(), collateralFor(req.amount, req.loanToCollateral));\\n\\n        // Log the event.\\n        factory().logRescindRequest(reqID_);\\n    }\\n\\n    /// @notice Repay a loan to get the collateral back.\\n    /// @dev    Despite a malicious lender could reenter with the callback, the\\n    ///         usage of `msg.sender` prevents any economical benefit to the\\n    ///         attacker, since they would be repaying the loan themselves.\\n    /// @param  loanID_ index of loan in loans[].\\n    /// @param  repayment_ debt tokens to be repaid.\\n    /// @return collateral given back to the borrower.\\n    function repayLoan(uint256 loanID_, uint256 repayment_) external returns (uint256) {\\n        Loan memory loan = loans[loanID_];\\n\\n        if (block.timestamp > loan.expiry) revert Default();\\n\\n        // Cap the repayment to the total debt of the loan\\n        uint256 totalDebt = loan.principal + loan.interestDue;\\n        if (repayment_ > totalDebt) repayment_ = totalDebt;\\n\\n        // Need to repay interest first, then any extra goes to paying down principal.\\n        uint256 interestPaid;\\n        uint256 remainder;\\n        if (repayment_ >= loan.interestDue) {\\n            remainder = repayment_ - loan.interestDue;\\n            interestPaid = loan.interestDue;\\n            loan.interestDue = 0;\\n        } else {\\n            loan.interestDue -= repayment_;\\n            interestPaid = repayment_;\\n        }\\n\\n        // We pay back only if user has paid back principal. This can be 0.\\n        uint256 decollateralized;\\n        if (remainder > 0) {\\n            decollateralized = (loan.collateral * remainder) / loan.principal;\\n            \\n            loan.principal -= remainder;\\n            loan.collateral -= decollateralized;\\n        }\\n\\n        // Save updated loan info in storage.\\n        loans[loanID_] = loan;\\n\\n        // Transfer repaid debt back to the lender and collateral back to the owner if applicable\\n        debt().safeTransferFrom(msg.sender, loan.recipient, repayment_);\\n        if (decollateralized > 0) collateral().safeTransfer(owner(), decollateralized);\\n\\n        // Log the event.\\n        factory().logRepayLoan(loanID_, repayment_);\\n\\n        // If necessary, trigger lender callback.\\n        if (loan.callback) {\\n            CoolerCallback(loan.lender).onRepay(loanID_, remainder, interestPaid);\\n        }\\n\\n        return decollateralized;\\n    }\\n\\n    /// @notice Delegate voting power on collateral.\\n    /// @param  to_ address to delegate.\\n    function delegateVoting(address to_) external {\\n        if (msg.sender != owner()) revert OnlyApproved();\\n        IDelegate(address(collateral())).delegate(to_);\\n    }\\n\\n    // --- LENDER ----------------------------------------------------\\n\\n    /// @notice Fill a requested loan as a lender.\\n    /// @param  reqID_ index of request in requests[].\\n    /// @param  recipient_ address to repay the loan to.\\n    /// @param  isCallback_ true if the lender implements the CoolerCallback abstract. False otherwise.\\n    /// @return loanID of the granted loan. Equivalent to the index of loan in loans[].\\n    function clearRequest(\\n        uint256 reqID_,\\n        address recipient_,\\n        bool isCallback_\\n    ) external returns (uint256 loanID) {\\n        Request memory req = requests[reqID_];\\n\\n        // Loan callbacks are only allowed if:\\n        //  1. The loan request has been created via a trusted lender.\\n        //  2. The lender signals that it implements the CoolerCallback Abstract.\\n        bool callback = (isCallback_ && msg.sender == req.requester);\\n\\n        // If necessary, ensure lender implements the CoolerCallback abstract.\\n        if (callback && !CoolerCallback(msg.sender).isCoolerCallback()) revert NotCoolerCallback();\\n        // Ensure loan request is active. \\n        if (!req.active) revert Deactivated();\\n\\n        // Clear the loan request in memory.\\n        req.active = false;\\n\\n        // Calculate and store loan terms.\\n        uint256 interest = interestFor(req.amount, req.interest, req.duration);\\n        uint256 collat = collateralFor(req.amount, req.loanToCollateral);\\n        loanID = loans.length;\\n\\n        loans.push(\\n            Loan({\\n                request: req,\\n                principal: req.amount,\\n                interestDue: interest,\\n                collateral: collat,\\n                expiry: block.timestamp + req.duration,\\n                lender: msg.sender,\\n                recipient: recipient_,\\n                callback: callback\\n            })\\n        );\\n\\n        // Clear the loan request storage.\\n        requests[reqID_].active = false;\\n\\n        // Transfer debt tokens to the owner of the request.\\n        debt().safeTransferFrom(msg.sender, owner(), req.amount);\\n\\n        // Log the event.\\n        factory().logClearRequest(reqID_, loanID);\\n    }\\n\\n    /// @notice Allow lender to extend a loan for the borrower. Doesn't require\\n    ///         borrower permission because it doesn't have a negative impact for them.\\n    /// @dev    Since this function solely impacts the expiration day, the lender\\n    ///         should ensure that extension interest payments are done beforehand.\\n    /// @param  loanID_ index of loan in loans[].\\n    /// @param  times_ that the fixed-term loan duration is extended.\\n    function extendLoanTerms(uint256 loanID_, uint8 times_) external {\\n        Loan memory loan = loans[loanID_];\\n\\n        if (msg.sender != loan.lender) revert OnlyApproved();\\n        if (block.timestamp > loan.expiry) revert Default();\\n\\n        // Update loan terms to reflect the extension.\\n        loan.expiry += loan.request.duration * times_;\\n\\n        // Save updated loan info in storage.\\n        loans[loanID_] = loan;\\n\\n        // Log the event.\\n        factory().logExtendLoan(loanID_, times_);\\n    }\\n\\n    /// @notice Claim collateral upon loan default.\\n    /// @param  loanID_ index of loan in loans[].\\n    /// @return defaulted debt by the borrower, collateral kept by the lender, elapsed time since expiry.\\n    function claimDefaulted(uint256 loanID_) external returns (uint256, uint256, uint256, uint256) {\\n        Loan memory loan = loans[loanID_];\\n\\n        if (block.timestamp <= loan.expiry) revert NotExpired();\\n\\n        loans[loanID_].principal = 0;\\n        loans[loanID_].interestDue = 0;\\n        loans[loanID_].collateral = 0;\\n\\n        // Transfer defaulted collateral to the lender.\\n        collateral().safeTransfer(loan.lender, loan.collateral);\\n\\n        // Log the event.\\n        factory().logDefaultLoan(loanID_, loan.collateral);\\n\\n        // If necessary, trigger lender callback.\\n        if (loan.callback) {\\n            CoolerCallback(loan.lender).onDefault(loanID_, loan.principal, loan.interestDue, loan.collateral);\\n        }\\n\\n        return (loan.principal, loan.interestDue, loan.collateral, block.timestamp - loan.expiry);\\n    }\\n\\n    /// @notice Approve transfer of loan ownership rights to a new address.\\n    /// @param  to_ address to be approved.\\n    /// @param  loanID_ index of loan in loans[].\\n    function approveTransfer(address to_, uint256 loanID_) external {\\n        if (msg.sender != loans[loanID_].lender) revert OnlyApproved();\\n\\n        // Update transfer approvals.\\n        approvals[loanID_] = to_;\\n    }\\n\\n    /// @notice Execute loan ownership transfer. Must be previously approved by the lender.\\n    /// @param  loanID_ index of loan in loans[].\\n    function transferOwnership(uint256 loanID_) external {\\n        if (msg.sender != approvals[loanID_]) revert OnlyApproved();\\n\\n        // Update the load lender and the recipient.\\n        loans[loanID_].lender = msg.sender;\\n        loans[loanID_].recipient = msg.sender;\\n        // Callbacks are disabled when transferring ownership.\\n        loans[loanID_].callback = false;\\n        // Clear transfer approvals.\\n        approvals[loanID_] = address(0);\\n    }\\n\\n    /// @notice Allow lender to set repayment recipient of a given loan.\\n    /// @param  loanID_ of lender's loan.\\n    /// @param  recipient_ reciever of repayments\\n    function setRepaymentAddress(uint256 loanID_, address recipient_) external {\\n        if (msg.sender != loans[loanID_].lender) revert OnlyApproved();\\n\\n        // Update the repayment method.\\n        loans[loanID_].recipient = recipient_;\\n    }\\n\\n    // --- AUX FUNCTIONS ---------------------------------------------\\n\\n    /// @notice Compute collateral needed for a desired loan amount at given loan to collateral ratio.\\n    /// @param  principal_ amount of debt tokens.\\n    /// @param  loanToCollateral_ ratio for loan. Expressed in 10**collateral().decimals().\\n    function collateralFor(uint256 principal_, uint256 loanToCollateral_) public view returns (uint256) {\\n        return (principal_ * (10 ** collateral().decimals())) / loanToCollateral_;\\n    }\\n\\n    /// @notice Compute interest cost on amount for duration at given annualized rate.\\n    /// @param  principal_ amount of debt tokens.\\n    /// @param  rate_ of interest (annualized).\\n    /// @param  duration_ of the loan in seconds.\\n    /// @return Interest in debt token terms.\\n    function interestFor(uint256 principal_, uint256 rate_, uint256 duration_) public pure returns (uint256) {\\n        uint256 interest = (rate_ * duration_) / 365 days;\\n        return (principal_ * interest) / DECIMALS_INTEREST;\\n    }\\n\\n    /// @notice Check if given loan has expired.\\n    /// @param  loanID_ index of loan in loans[].\\n    /// @return Expiration status.\\n    function hasExpired(uint256 loanID_) external view returns (bool) {\\n        return block.timestamp > loans[loanID_].expiry;\\n    }\\n\\n    /// @notice Check if a given request is active.\\n    /// @param  reqID_ index of request in requests[].\\n    /// @return Active status.\\n    function isActive(uint256 reqID_) external view returns (bool) {\\n        return requests[reqID_].active;\\n    }\\n\\n    /// @notice Getter for Request data as a struct.\\n    /// @param  reqID_ index of request in requests[].\\n    /// @return Request struct.\\n    function getRequest(uint256 reqID_) external view returns (Request memory) {\\n        return requests[reqID_];\\n    }\\n\\n    /// @notice Getter for Loan data as a struct.\\n    /// @param loanID_ index of loan in loans[].\\n    /// @return Loan struct.\\n    function getLoan(uint256 loanID_) external view returns (Loan memory) {\\n        return loans[loanID_];\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/clones-with-immutable-args/src/Clone.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD\\npragma solidity ^0.8.4;\\n\\n/// @title Clone\\n/// @author zefram.eth\\n/// @notice Provides helper functions for reading immutable args from calldata\\ncontract Clone {\\n    /// @notice Reads an immutable arg with type address\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgAddress(uint256 argOffset)\\n        internal\\n        pure\\n        returns (address arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        assembly {\\n            arg := shr(0x60, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @notice Reads an immutable arg with type uint256\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgUint256(uint256 argOffset)\\n        internal\\n        pure\\n        returns (uint256 arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            arg := calldataload(add(offset, argOffset))\\n        }\\n    }\\n\\n    /// @notice Reads an immutable arg with type uint64\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgUint64(uint256 argOffset)\\n        internal\\n        pure\\n        returns (uint64 arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            arg := shr(0xc0, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @notice Reads an immutable arg with type uint8\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            arg := shr(0xf8, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @return offset The offset of the packed immutable args in calldata\\n    function _getImmutableArgsOffset() internal pure returns (uint256 offset) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            offset := sub(\\n                calldatasize(),\\n                add(shr(240, calldataload(sub(calldatasize(), 2))), 2)\\n            )\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/Cooler/src/CoolerCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {CoolerFactory} from \\\"./CoolerFactory.sol\\\";\\n\\n/// @notice Allows for debt issuers to execute logic when a loan is repaid, rolled, or defaulted.\\n/// @dev    The three callback functions must be implemented if `isCoolerCallback()` is set to true.\\nabstract contract CoolerCallback {\\n    // --- ERRORS ----------------------------------------------------\\n\\n    error OnlyFromFactory();\\n\\n    // --- INITIALIZATION --------------------------------------------\\n\\n    CoolerFactory public immutable factory;\\n\\n    constructor(address coolerFactory_) {\\n        factory = CoolerFactory(coolerFactory_);\\n    }\\n\\n    // --- EXTERNAL FUNCTIONS ------------------------------------------------\\n\\n    /// @notice Informs to Cooler that this contract can handle its callbacks.\\n    function isCoolerCallback() external pure returns (bool) {\\n        return true;\\n    }\\n\\n    /// @notice Callback function that handles repayments.\\n    function onRepay(uint256 loanID_, uint256 principlePaid_, uint256 interestPaid_) external {\\n        if (!factory.created(msg.sender)) revert OnlyFromFactory();\\n        _onRepay(loanID_, principlePaid_, interestPaid_);\\n    }\\n\\n    /// @notice Callback function that handles defaults.\\n    function onDefault(\\n        uint256 loanID_,\\n        uint256 principle,\\n        uint256 interest,\\n        uint256 collateral\\n    ) external {\\n        if (!factory.created(msg.sender)) revert OnlyFromFactory();\\n        _onDefault(loanID_, principle, interest, collateral);\\n    }\\n\\n    // --- INTERNAL FUNCTIONS ------------------------------------------------\\n\\n    /// @notice Callback function that handles repayments. Override for custom logic.\\n    function _onRepay(\\n        uint256 loanID_,\\n        uint256 principlePaid_,\\n        uint256 interestPaid_\\n    ) internal virtual;\\n\\n    /// @notice Callback function that handles defaults.\\n    function _onDefault(\\n        uint256 loanID_,\\n        uint256 principle_,\\n        uint256 interestDue_,\\n        uint256 collateral\\n    ) internal virtual;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"interfaces/=src/interfaces/\",\r\n      \"modules/=src/modules/\",\r\n      \"policies/=src/policies/\",\r\n      \"libraries/=src/libraries/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"layer-zero/=lib/solidity-examples/contracts/\",\r\n      \"bonds/=lib/bonds/src/\",\r\n      \"test/=src/test/\",\r\n      \"clones/=lib/clones-with-immutable-args/src/\",\r\n      \"cooler/=lib/Cooler/src/\",\r\n      \"balancer-v2/=lib/balancer-v2/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"Cooler/=lib/Cooler/src/\",\r\n      \"clones-with-immutable-args/=lib/clones-with-immutable-args/src/\",\r\n      \"olympus-v3/=lib/Cooler/lib/olympus-v3/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solidity-examples/=lib/solidity-examples/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CreateFail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DecimalsNot18\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotFromFactory\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cooler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reqID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"}],\"name\":\"ClearRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cooler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DefaultLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cooler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"times\",\"type\":\"uint8\"}],\"name\":\"ExtendLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cooler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RepayLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cooler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"debt\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reqID\",\"type\":\"uint256\"}],\"name\":\"RequestLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"cooler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reqID\",\"type\":\"uint256\"}],\"name\":\"RescindRequest\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"coolerImplementation\",\"outputs\":[{\"internalType\":\"contract Cooler\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"coolersFor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"created\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"collateral_\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"debt_\",\"type\":\"address\"}],\"name\":\"generateCooler\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"cooler\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateral_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"debt_\",\"type\":\"address\"}],\"name\":\"getCoolerFor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reqID_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanID_\",\"type\":\"uint256\"}],\"name\":\"logClearRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanID_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral_\",\"type\":\"uint256\"}],\"name\":\"logDefaultLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanID_\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"times_\",\"type\":\"uint8\"}],\"name\":\"logExtendLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanID_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"repayment_\",\"type\":\"uint256\"}],\"name\":\"logRepayLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reqID_\",\"type\":\"uint256\"}],\"name\":\"logRequestLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reqID_\",\"type\":\"uint256\"}],\"name\":\"logRescindRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CoolerFactory", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "10", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}