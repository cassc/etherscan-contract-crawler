// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⢰⠀⠀⠀⠀⣄⠀⠀⠀⠀⡆⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡀⠀⠀⠀⠘⣆⠀⠀⠀⠸⡄⠀⠀⠀⣿⠀⠀⠀⢠⠇⠀⠀⠀⣰⠃⠀⠀⠀⢀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠳⡄⠀⠀⠀⠹⡄⠀⠀⠠⡇⠀⠀⣰⣿⣧⠀⠀⢸⠀⠀⠀⢠⠏⠀⠀⠀⢠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⢦⠀⠀⠀⠀⠹⡄⠀⠀⠀⢳⠀⠀⠀⢹⠀⣼⣿⣿⣿⣷⡀⡏⠀⠀⠀⡜⠀⠀⠀⣠⠏⠀⠀⠀⠀⡴⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠱⣄⠀⠀⠀⠸⣆⠀⠀⠈⣧⠀⠀⢸⣿⣿⣿⠟⣿⣿⣿⡇⠀⠀⣼⠃⠀⠀⣰⠃⠀⠀⠀⣠⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠈⢳⡀⠀⠀⠘⣧⠀⠀⠸⡆⢀⣾⣿⣿⠏⠀⠈⢿⣿⣿⡄⢰⠏⠀⠀⣼⠃⠀⠀⢀⡼⠁⠀⠀⠀⣀⡴⠂⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠉⠢⣄⠀⠀⠀⠙⢦⡀⠀⠘⣷⡀⠀⢻⣾⣿⣿⠃⠀⠀⠀⠈⢿⣿⣿⣿⠀⢀⣼⠃⠀⢀⡴⠋⠀⠀⠀⣠⠜⠁⠀⠀⠀⠀⠀⠀
// ⠀⠀⠢⣄⡀⠀⠀⠀⠈⠳⣤⡀⠀⠈⠳⣆⠀⠈⢷⣠⣿⣿⡿⠃⠀⠀⠀⠀⠀⠀⢻⣿⣿⣦⣾⠁⠀⣠⠞⠁⠀⢀⣴⠞⠁⠀⠀⠀⢀⣠⠔⠀⠀
// ⠀⠀⠀⠀⠙⠲⢤⡀⠀⠀⠈⠙⢦⣄⠀⠙⢷⣄⣸⣿⣿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠻⣿⣿⣧⣠⡾⠋⠀⣠⡶⠋⠀⠀⠀⢀⡤⠒⠉⠀⠀⠀⠀
// ⢀⣀⠀⠀⠀⠀⠀⠉⠳⢦⣄⡀⠀⠙⢷⣦⡀⣻⣿⣿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⣿⣿⣿⣁⣴⡾⠋⠀⢀⣠⡴⠚⠁⠀⠀⠀⠀⢀⣀⠀
// ⠀⠈⠙⠒⠶⢤⣀⡀⠀⠀⠈⠙⠷⣦⣀⠙⣿⣿⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⡋⣀⣴⠾⠋⠁⠀⠀⣀⣠⠤⠖⠛⠉⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠙⠛⠶⢤⣤⣀⡈⢙⣿⣿⣿⠏⠀⠀⢀⣀⣠⣤⣤⣶⣶⣤⣤⣤⣀⡀⠀⠘⣿⣿⣿⣋⣁⣠⣤⠶⠞⠛⠉⠀⠀⠀⠀⠀⠀⠀
// ⠐⠒⠒⠦⠤⣤⣄⣀⣀⠀⠀⠈⠉⢻⣿⣿⣿⠋⣀⣤⡶⠟⠛⢉⣉⣉⣉⣉⣉⣉⠙⠛⠿⣶⣤⡈⢿⣿⣿⡟⠉⠀⣀⣀⣀⣤⣤⠤⠴⠒⠒⠂⠀
// ⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠙⠛⢻⣾⣿⣿⣣⢶⣫⣷⣶⡿⠛⠛⣿⢿⣿⣿⣿⡟⠛⠻⣷⣦⣭⡻⢮⣿⣿⣿⣟⠛⠉⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠠⠤⠤⠤⠤⠤⠤⠴⠶⣶⣾⣿⣿⣿⠗⠋⠁⠀⣿⡇⠀⢸⣿⣶⣿⣿⣿⣿⠀⠀⢹⡇⠀⠉⠳⠿⣿⣿⣿⣷⠶⠶⠶⠶⠶⠶⠶⠶⠖⠂⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣰⣿⣿⡟⢫⡀⠀⠀⠀⠀⢿⣇⠀⠸⣿⣿⣿⣿⣿⡟⠀⠀⣾⠇⠀⠀⠀⠀⢨⠿⣿⣿⣧⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⣀⣠⠤⠤⠴⠒⠚⠛⣻⣿⣿⡟⠀⠀⠓⢤⣀⠀⠀⠘⢿⣆⠀⠈⠙⠛⠛⠉⠀⢀⣼⠟⠀⠀⢀⣠⡴⠃⠀⠹⣿⣿⣯⡉⠙⠛⠓⠒⠦⠤⠤⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⠏⠀⠀⠀⠀⠀⠙⠻⢶⣤⣤⣛⣿⣦⣤⣤⣤⣤⣾⣟⣡⣤⣴⠶⠛⠁⠀⠀⠀⠀⠘⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⣀⣤⠴⠖⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠙⠛⠻⠿⠿⠿⠿⠟⠛⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢿⣿⣿⡍⠓⠶⢤⣄⡀⠀
// ⠀⠀⠉⠁⠀⢀⣾⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⡄⠀⠀⠀⠈⠁
// ⠀⠀⠀⠀⢠⣾⣿⡿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀INITIALNFT⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣆⠀⠀⠀⠀
// ⠀⠀⠠⢴⣿⣿⣿⣷⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣿⣿⣿⣟⠂⠀⠀
// ⠀⠀⠰⠿⠿⠛⠻⣿⠿⠻⠿⠿⠿⡿⠿⠿⠻⣿⠿⠿⢿⡿⠿⢿⡿⠿⢿⡟⠿⣿⡿⠿⢿⠿⠿⠿⡿⠿⠿⠿⣿⠻⠿⠟⠻⠿⣿⠟⠿⠿⠷⠀⠀
// ⠀⠀⠀⠀⠀⡠⠞⠁⠀⠀⠀⣠⠞⠀⠀⠀⣼⠃⠀⠀⡿⠁⠀⢸⠁⠀⢸⠀⠀⢸⡇⠀⠘⣧⠀⠀⠹⣆⠀⠀⠈⠳⣄⠀⠀⠀⠈⠑⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⠁⠀⠀⠀⡼⠁⠀⠀⣼⠁⠀⠀⡟⠀⠀⢸⠀⠀⠘⣇⠀⠀⠹⡆⠀⠀⠙⢆⠀⠀⠀⠈⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⡴⠋⠀⠀⠀⢀⡜⠁⠀⠀⢰⠃⠀⠀⢸⡇⠀⠀⢸⠀⠀⠀⢹⠀⠀⠀⢹⡀⠀⠀⠈⢧⠀⠀⠀⠀⠙⠄⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⠀⠀⠀⠀⡏⠀⠀⠀⣸⠀⠀⠀⢸⠀⠀⠀⠘⡆⠀⠀⠀⢧⠀⠀⠀⠀⢣⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠊⠀⠀⠀⠀⡾⠀⠀⠀⠀⡏⠀⠀⠀⢸⠀⠀⠀⠀⣇⠀⠀⠀⠈⡇⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠁⠀⠀⠀⠰⠃⠀⠀⠀⠈⠀⠀⠀⠀⢸⠀⠀⠀⠀⠘⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// brought to you by hardcore degens

// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.9;

import "erc721a/contracts/ERC721A.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract INITIALNFT is ERC721A, Ownable {
    uint256 public constant MAX_SUPPLY = 8888;
    uint256 public constant FREE_MINT_SUPPLY = 3333;
    uint256 public constant PRICE_PER_MINT_PUBLIC = 0.025 ether;

    bool public saleActive = false;
    bool public revealed = false;
    bool public ownerHasMinted = false;
    mapping(address => bool) public userHasFreeMinted;
    uint256 public _totalFreeMinted;

    string private baseURI =
        "ipfs://Qmabb2hwK3GekLyE7N6GGTHwfuMhDunjVvj5eAw5pfJLkm";

    constructor() ERC721A("INITIAL NFT", "INITIAL") {}

    function mint(uint256 amount) external payable {
        require(saleActive, "Sale is not active.");
        require(
            _totalMinted() + amount <= MAX_SUPPLY,
            "Trying to mint too many tokens."
        );

        require(
            msg.value >= PRICE_PER_MINT_PUBLIC * amount,
            "Not enough ethers sent to complete purchase."
        );

        _mint(msg.sender, amount);
    }

    function freeMint(uint256 amount) external {
        require(saleActive, "Sale is not active.");
        require(amount <= 2, "Trying to mint too many tokens.");
        require(
            _totalFreeMinted + amount <= FREE_MINT_SUPPLY,
            "Trying to free mint too many tokens."
        );
        require(
            _totalMinted() + amount <= MAX_SUPPLY,
            "Trying to mint too many tokens."
        );

        require(
            !userHasFreeMinted[msg.sender],
            "User has already free minted."
        );

        userHasFreeMinted[msg.sender] = true;
        _totalFreeMinted += amount;

        _mint(msg.sender, amount);
    }

    function _ownerMint(uint256 amount) external onlyOwner {
        require(!ownerHasMinted, "Owner has already minted.");
        require(
            _totalMinted() + amount <= MAX_SUPPLY,
            "Trying to mint too many tokens."
        );

        _mint(msg.sender, amount);

        ownerHasMinted = true;
    }

    function setSaleActive(bool active) external onlyOwner {
        saleActive = active;
    }

    function setBaseURI(string memory _uri) external onlyOwner {
        require(!revealed, "Can only change the metadata if not yet revealed.");
        baseURI = _uri;
    }

    function reveal() external onlyOwner {
        require(!revealed, "Can only reveal once.");
        revealed = true;
    }

    function _baseURI() internal view override returns (string memory) {
        return baseURI;
    }

    function tokenURI(uint256 tokenId)
        public
        view
        override
        returns (string memory)
    {
        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();

        if (!revealed) {
            return baseURI;
        }

        return string(abi.encodePacked(_baseURI(), "/", _toString(tokenId)));
    }

    function withdraw() external onlyOwner {
        payable(msg.sender).transfer(address(this).balance);
    }
}