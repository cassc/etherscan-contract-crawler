{"SourceCode": "//SPDX-License-Identifier: Unlicense\r\n//CAUTION: NOT AUDITED, NO GUARANTEES OF PERFORMANCE\r\n\r\n/*******************************************\r\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n~~~~~~~~~~~~~~~~~ ROULETTE ~~~~~~~~~~~~~~~~~\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\r\n--------------------------------------------\r\n      3 6 9 12 15 18 21 24 27 30 33 36\r\n    0 2 5 8 11 14 17 20 23 26 29 32 35\r\n      1 4 7 10 13 16 19 22 25 28 31 34\r\n--------------------------------------------  \r\n <Even|Odd> ~~ <Black|Red> ~~ <1st|2nd> ~~ <1st|2nd|3rd> \r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\r\n*******************************************/\r\n\r\n/*** @notice on-chain roulette using API3/ANU quantum random numbers.\r\n *** Immutable after deployment except for setRequestParameters().\r\n *** CAUTION: NOT AUDITED, NO GUARANTEES OR WARRANTIES PROVIDED WHATSOEVER.\r\n *** Only supports one bet (single number, black/red, even/odd, 1st/2nd or 1st/2nd/3rd of board) per spin.\r\n *** User places bet by calling applicable payable function, then calls spinRouletteWheel(),\r\n *** then calls checkIf[BetType]Won() after QRNG airnode responds with spinResult for user\r\n *** following the applicable chain's minimum confirmations (25 for Optimism)\r\n *** hardcoded minimum bet of .001 ETH to prevent spam of sponsorWallet, winnings paid from this contract **/\r\n/// @dev https://github.com/api3dao/qrng-example/blob/main/contracts/QrngExample.sol\r\n/// @title Roulette\r\n/// Roulette odds should prevent the casino (this contract) and sponsorWallet from bankruptcy, but anyone can refill by sending ETH directly to address\r\n\r\npragma solidity >=0.8.4;\r\n\r\ninterface IAuthorizationUtilsV0 {\r\n  function checkAuthorizationStatus(\r\n    address[] calldata authorizers,\r\n    address airnode,\r\n    bytes32 requestId,\r\n    bytes32 endpointId,\r\n    address sponsor,\r\n    address requester\r\n  ) external view returns (bool status);\r\n\r\n  function checkAuthorizationStatuses(\r\n    address[] calldata authorizers,\r\n    address airnode,\r\n    bytes32[] calldata requestIds,\r\n    bytes32[] calldata endpointIds,\r\n    address[] calldata sponsors,\r\n    address[] calldata requesters\r\n  ) external view returns (bool[] memory statuses);\r\n}\r\n\r\ninterface ITemplateUtilsV0 {\r\n  event CreatedTemplate(bytes32 indexed templateId, address airnode, bytes32 endpointId, bytes parameters);\r\n\r\n  function createTemplate(\r\n    address airnode,\r\n    bytes32 endpointId,\r\n    bytes calldata parameters\r\n  ) external returns (bytes32 templateId);\r\n\r\n  function getTemplates(\r\n    bytes32[] calldata templateIds\r\n  ) external view returns (address[] memory airnodes, bytes32[] memory endpointIds, bytes[] memory parameters);\r\n\r\n  function templates(\r\n    bytes32 templateId\r\n  ) external view returns (address airnode, bytes32 endpointId, bytes memory parameters);\r\n}\r\n\r\ninterface IWithdrawalUtilsV0 {\r\n  event RequestedWithdrawal(\r\n    address indexed airnode,\r\n    address indexed sponsor,\r\n    bytes32 indexed withdrawalRequestId,\r\n    address sponsorWallet\r\n  );\r\n\r\n  event FulfilledWithdrawal(\r\n    address indexed airnode,\r\n    address indexed sponsor,\r\n    bytes32 indexed withdrawalRequestId,\r\n    address sponsorWallet,\r\n    uint256 amount\r\n  );\r\n\r\n  function requestWithdrawal(address airnode, address sponsorWallet) external;\r\n\r\n  function fulfillWithdrawal(bytes32 withdrawalRequestId, address airnode, address sponsor) external payable;\r\n\r\n  function sponsorToWithdrawalRequestCount(address sponsor) external view returns (uint256 withdrawalRequestCount);\r\n}\r\n\r\ninterface IAirnodeRrpV0 is IAuthorizationUtilsV0, ITemplateUtilsV0, IWithdrawalUtilsV0 {\r\n  event SetSponsorshipStatus(address indexed sponsor, address indexed requester, bool sponsorshipStatus);\r\n\r\n  event MadeTemplateRequest(\r\n    address indexed airnode,\r\n    bytes32 indexed requestId,\r\n    uint256 requesterRequestCount,\r\n    uint256 chainId,\r\n    address requester,\r\n    bytes32 templateId,\r\n    address sponsor,\r\n    address sponsorWallet,\r\n    address fulfillAddress,\r\n    bytes4 fulfillFunctionId,\r\n    bytes parameters\r\n  );\r\n\r\n  event MadeFullRequest(\r\n    address indexed airnode,\r\n    bytes32 indexed requestId,\r\n    uint256 requesterRequestCount,\r\n    uint256 chainId,\r\n    address requester,\r\n    bytes32 endpointId,\r\n    address sponsor,\r\n    address sponsorWallet,\r\n    address fulfillAddress,\r\n    bytes4 fulfillFunctionId,\r\n    bytes parameters\r\n  );\r\n\r\n  event FulfilledRequest(address indexed airnode, bytes32 indexed requestId, bytes data);\r\n\r\n  event FailedRequest(address indexed airnode, bytes32 indexed requestId, string errorMessage);\r\n\r\n  function setSponsorshipStatus(address requester, bool sponsorshipStatus) external;\r\n\r\n  function makeTemplateRequest(\r\n    bytes32 templateId,\r\n    address sponsor,\r\n    address sponsorWallet,\r\n    address fulfillAddress,\r\n    bytes4 fulfillFunctionId,\r\n    bytes calldata parameters\r\n  ) external returns (bytes32 requestId);\r\n\r\n  function makeFullRequest(\r\n    address airnode,\r\n    bytes32 endpointId,\r\n    address sponsor,\r\n    address sponsorWallet,\r\n    address fulfillAddress,\r\n    bytes4 fulfillFunctionId,\r\n    bytes calldata parameters\r\n  ) external returns (bytes32 requestId);\r\n\r\n  function fulfill(\r\n    bytes32 requestId,\r\n    address airnode,\r\n    address fulfillAddress,\r\n    bytes4 fulfillFunctionId,\r\n    bytes calldata data,\r\n    bytes calldata signature\r\n  ) external returns (bool callSuccess, bytes memory callData);\r\n\r\n  function fail(\r\n    bytes32 requestId,\r\n    address airnode,\r\n    address fulfillAddress,\r\n    bytes4 fulfillFunctionId,\r\n    string calldata errorMessage\r\n  ) external;\r\n\r\n  function sponsorToRequesterToSponsorshipStatus(\r\n    address sponsor,\r\n    address requester\r\n  ) external view returns (bool sponsorshipStatus);\r\n\r\n  function requesterToRequestCountPlusOne(address requester) external view returns (uint256 requestCountPlusOne);\r\n\r\n  function requestIsAwaitingFulfillment(bytes32 requestId) external view returns (bool isAwaitingFulfillment);\r\n}\r\n\r\n/// @title The contract to be inherited to make Airnode RRP requests\r\nabstract contract RrpRequesterV0 {\r\n  IAirnodeRrpV0 public immutable airnodeRrp;\r\n\r\n  /// @dev Reverts if the caller is not the Airnode RRP contract.\r\n  /// Use it as a modifier for fulfill and error callback methods, but also\r\n  /// check `requestId`.\r\n  modifier onlyAirnodeRrp() {\r\n    require(msg.sender == address(airnodeRrp), \"Caller not Airnode RRP\");\r\n    _;\r\n  }\r\n\r\n  /// @dev Airnode RRP address is set at deployment and is immutable.\r\n  /// RrpRequester is made its own sponsor by default. RrpRequester can also\r\n  /// be sponsored by others and use these sponsorships while making\r\n  /// requests, i.e., using this default sponsorship is optional.\r\n  /// @param _airnodeRrp Airnode RRP contract address\r\n  constructor(address _airnodeRrp) {\r\n    airnodeRrp = IAirnodeRrpV0(_airnodeRrp);\r\n    IAirnodeRrpV0(_airnodeRrp).setSponsorshipStatus(address(this), true);\r\n  }\r\n}\r\n\r\ncontract Roulette is RrpRequesterV0 {\r\n  uint256 public constant MIN_BET = 10000000000000; // .001 ETH\r\n  uint256 spinCount;\r\n  address airnode;\r\n  address immutable deployer;\r\n  address payable sponsorWallet;\r\n  bytes32 endpointId;\r\n\r\n  // ~~~~~~~ ENUMS ~~~~~~~\r\n\r\n  enum BetType {\r\n    Color,\r\n    Number,\r\n    EvenOdd,\r\n    Third,\r\n\t Half\r\n  }\r\n\r\n  // ~~~~~~~ MAPPINGS ~~~~~~~\r\n\r\n  mapping(address => bool) public userBetAColor;\r\n  mapping(address => bool) public userBetANumber;\r\n  mapping(address => bool) public userBetEvenOdd;\r\n  mapping(address => bool) public userBetThird;\r\n  mapping(address => bool) public userBetHalf;\r\n  mapping(address => bool) public userToColor;\r\n  mapping(address => bool) public userToEven;\r\n\r\n  mapping(address => uint256) public userToCurrentBet;\r\n  mapping(address => uint256) public userToSpinCount;\r\n  mapping(address => uint256) public userToNumber;\r\n  mapping(address => uint256) public userToThird;\r\n  mapping(address => uint256) public userToHalf;\r\n\r\n  mapping(bytes32 => bool) expectingRequestWithIdToBeFulfilled;\r\n\r\n  mapping(bytes32 => uint256) public requestIdToSpinCount;\r\n  mapping(bytes32 => uint256) public requestIdToResult;\r\n\r\n  mapping(uint256 => bool) blackNumber;\r\n  mapping(uint256 => bool) public blackSpin;\r\n  mapping(uint256 => bool) public spinIsComplete;\r\n\r\n  mapping(uint256 => BetType) public spinToBetType;\r\n  mapping(uint256 => address) public spinToUser;\r\n  mapping(uint256 => uint256) public spinResult;\r\n\r\n  // ~~~~~~~ ERRORS ~~~~~~~\r\n\r\n  error HouseBalanceTooLow();\r\n  error NoBet();\r\n  error ReturnFailed();\r\n  error SpinNotComplete();\r\n  error TransferToDeployerWalletFailed();\r\n  error TransferToSponsorWalletFailed();\r\n\r\n  // ~~~~~~~ EVENTS ~~~~~~~\r\n\r\n  event RequestedUint256(bytes32 requestId);\r\n  event ReceivedUint256(bytes32 indexed requestId, uint256 response);\r\n  event SpinComplete(bytes32 indexed requestId, uint256 indexed spinNumber, uint256 qrngResult);\r\n  event WinningNumber(uint256 indexed spinNumber, uint256 winningNumber);\r\n\r\n  /// sponsorWallet must be derived from address(this) after deployment\r\n  /// https://docs.api3.org/airnode/v0.6/grp-developers/requesters-sponsors.html#how-to-derive-a-sponsor-wallet\r\n  /// @param _airnodeRrp Airnode RRP contract address, https://docs.api3.org/airnode/v0.6/reference/airnode-addresses.html\r\n  /// @dev includes init of blackNumber mapping to match roulette board for betColor()\r\n  /// https://docs.api3.org/qrng/chains.html\r\n  /// https://docs.api3.org/airnode/v0.6/reference/airnode-addresses.html\r\n  constructor(address _airnodeRrp) RrpRequesterV0(_airnodeRrp) {\r\n    deployer = msg.sender;\r\n    blackNumber[2] = true;\r\n    blackNumber[4] = true;\r\n    blackNumber[6] = true;\r\n    blackNumber[8] = true;\r\n    blackNumber[10] = true;\r\n    blackNumber[11] = true;\r\n    blackNumber[13] = true;\r\n    blackNumber[15] = true;\r\n    blackNumber[17] = true;\r\n    blackNumber[20] = true;\r\n    blackNumber[22] = true;\r\n    blackNumber[24] = true;\r\n    blackNumber[26] = true;\r\n    blackNumber[28] = true;\r\n    blackNumber[29] = true;\r\n    blackNumber[31] = true;\r\n    blackNumber[33] = true;\r\n    blackNumber[35] = true;\r\n  }\r\n\r\n  /// @notice for user to spin after bet is placed\r\n  /// @dev calls the AirnodeRrp contract with a request\r\n  /// @param _spinCount the msg.sender's spin number assigned when bet placed\r\n  function _spinRouletteWheel(uint256 _spinCount) internal {\r\n    require(!spinIsComplete[_spinCount], \"spin already complete\");\r\n    require(_spinCount == userToSpinCount[msg.sender], \"!= msg.sender spinCount\");\r\n    bytes32 requestId = airnodeRrp.makeFullRequest(\r\n      airnode,\r\n      endpointId,\r\n      address(this),\r\n      sponsorWallet,\r\n      address(this),\r\n      this.fulfillUint256.selector,\r\n      \"\"\r\n    );\r\n    expectingRequestWithIdToBeFulfilled[requestId] = true;\r\n    requestIdToSpinCount[requestId] = _spinCount;\r\n    emit RequestedUint256(requestId);\r\n  }\r\n\r\n  /** @dev AirnodeRrp will call back with a response\r\n   *** if no response returned (0) user will have bet returned (see check functions) */\r\n  function fulfillUint256(bytes32 requestId, bytes calldata data) external onlyAirnodeRrp {\r\n    require(expectingRequestWithIdToBeFulfilled[requestId], \"Unexpected Request ID\");\r\n    expectingRequestWithIdToBeFulfilled[requestId] = false;\r\n    uint256 _qrngUint256 = abi.decode(data, (uint256));\r\n    requestIdToResult[requestId] = _qrngUint256;\r\n    _spinComplete(requestId, _qrngUint256);\r\n    emit ReceivedUint256(requestId, _qrngUint256);\r\n  }\r\n\r\n  /** @dev a failed fulfill (return 0) assigned 37 to avoid modulo problem\r\n   *** in spinResult calculations in above functions,\r\n   *** otherwise assigns the QRNG result to the applicable spin number **/\r\n  function _spinComplete(bytes32 _requestId, uint256 _qrngUint256) internal {\r\n    uint256 _spin = requestIdToSpinCount[_requestId];\r\n    if (_qrngUint256 == 0) {\r\n      spinResult[_spin] = 37;\r\n    } else {\r\n      spinResult[_spin] = _qrngUint256;\r\n    }\r\n    spinIsComplete[_spin] = true;\r\n    if (spinToBetType[_spin] == BetType.Number) {\r\n      checkIfNumberWon(_spin);\r\n    } else if (spinToBetType[_spin] == BetType.Color) {\r\n      checkIfColorWon(_spin);\r\n    } else if (spinToBetType[_spin] == BetType.EvenOdd) {\r\n      checkIfEvenOddWon(_spin);\r\n\t } else if (spinToBetType[_spin] == BetType.Half) {\r\n\t\tcheckIfHalfWon(_spin);\r\n    } else if (spinToBetType[_spin] == BetType.Third) {\r\n      checkIfThirdWon(_spin);\r\n    }\r\n    emit SpinComplete(_requestId, _spin, spinResult[_spin]);\r\n  }\r\n\r\n  /// @dev set parameters for airnodeRrp.makeFullRequest\r\n  /// @param _airnode ANU airnode contract address\r\n  /// @param _sponsorWallet derived sponsor wallet address\r\n  /// @param _endpointId endpointID for the QRNG, see https://docs.api3.org/qrng/providers.html\r\n  /// @notice derive sponsorWallet via https://docs.api3.org/airnode/v0.6/concepts/sponsor.html#derive-a-sponsor-wallet\r\n  /// only non-immutable function, to allow updating request parameters if needed\r\n  function setRequestParameters(address _airnode, bytes32 _endpointId, address payable _sponsorWallet) external {\r\n    require(msg.sender == deployer, \"msg.sender not deployer\");\r\n    airnode = _airnode;\r\n    endpointId = _endpointId;\r\n    sponsorWallet = _sponsorWallet;\r\n  }\r\n\r\n  /// @notice sends msg.value to sponsorWallet to ensure Airnode continues responses\r\n  function topUpSponsorWallet() external payable {\r\n    require(msg.value != 0, \"msg.value == 0\");\r\n    (bool sent, ) = sponsorWallet.call{ value: msg.value }(\"\");\r\n    if (!sent) revert TransferToSponsorWalletFailed();\r\n  }\r\n\r\n  // to refill the \"house\" (address(this)) if bankrupt\r\n  receive() external payable {}\r\n\r\n  /// @notice for user to submit a single-number bet, which pays out 35:1 if correct after spin\r\n  /// @param _numberBet number between 0 and 36\r\n  /// @return userToSpinCount[msg.sender] spin count for this msg.sender, to enter in spinRouletteWheel()\r\n  function betNumber(uint256 _numberBet) external payable returns (uint256) {\r\n    require(_numberBet < 37, \"_numberBet is > 36\");\r\n    require(msg.value >= MIN_BET, \"msg.value < MIN_BET\");\r\n    if (address(this).balance < msg.value * 35) revert HouseBalanceTooLow();\r\n    userToCurrentBet[msg.sender] = msg.value;\r\n    unchecked {\r\n      ++spinCount;\r\n    }\r\n    userToSpinCount[msg.sender] = spinCount;\r\n    spinToUser[spinCount] = msg.sender;\r\n    userToNumber[msg.sender] = _numberBet;\r\n    userBetANumber[msg.sender] = true;\r\n    spinToBetType[spinCount] = BetType.Number;\r\n    _spinRouletteWheel(spinCount);\r\n    return (userToSpinCount[msg.sender]);\r\n  }\r\n\r\n  /// @notice for user to check number bet result when spin complete\r\n  /// @dev unsuccessful bet sends 10% to sponsor wallet to ensure future fulfills, 2% to deployer, rest kept by house\r\n  function checkIfNumberWon(uint256 _spin) internal returns (uint256) {\r\n    address _user = spinToUser[_spin];\r\n    if (userToCurrentBet[_user] == 0) revert NoBet();\r\n    if (!userBetANumber[_user]) revert NoBet();\r\n    if (!spinIsComplete[_spin]) revert SpinNotComplete();\r\n    if (spinResult[_spin] == 37) {\r\n      (bool sent, ) = _user.call{ value: userToCurrentBet[_user] }(\"\");\r\n      if (!sent) revert ReturnFailed();\r\n    } else {}\r\n    if (userToNumber[_user] == spinResult[_spin] % 37) {\r\n      (bool sent, ) = _user.call{ value: userToCurrentBet[_user] * 35 }(\"\");\r\n      if (!sent) revert HouseBalanceTooLow();\r\n    } else {\r\n      (bool sent, ) = sponsorWallet.call{ value: userToCurrentBet[_user] / 10 }(\"\");\r\n      if (!sent) revert TransferToSponsorWalletFailed();\r\n      (bool sent2, ) = deployer.call{ value: userToCurrentBet[_user] / 50 }(\"\");\r\n      if (!sent2) revert TransferToDeployerWalletFailed();\r\n    }\r\n    userToCurrentBet[_user] = 0;\r\n    userBetANumber[_user] = false;\r\n    emit WinningNumber(_spin, spinResult[_spin] % 37);\r\n    return (spinResult[_spin] % 37);\r\n  }\r\n\r\n  /// @notice submit bet and \"1\", \"2\", or \"3\" for a bet on 1st/2nd/3rd of table, which pays out 3:1 if correct after spin\r\n  /// @param _oneThirdBet uint 1, 2, or 3 to represent first, second or third of table\r\n  /// @return userToSpinCount[msg.sender] spin count for this msg.sender, to enter in spinRouletteWheel()\r\n  function betOneThird(uint256 _oneThirdBet) external payable returns (uint256) {\r\n    require(_oneThirdBet == 1 || _oneThirdBet == 2 || _oneThirdBet == 3, \"_oneThirdBet not 1 or 2 or 3\");\r\n    require(msg.value >= MIN_BET, \"msg.value < MIN_BET\");\r\n    if (address(this).balance < msg.value * 3) revert HouseBalanceTooLow();\r\n    userToCurrentBet[msg.sender] = msg.value;\r\n    unchecked {\r\n      ++spinCount;\r\n    }\r\n    spinToUser[spinCount] = msg.sender;\r\n    userToSpinCount[msg.sender] = spinCount;\r\n    userToThird[msg.sender] = _oneThirdBet;\r\n    userBetThird[msg.sender] = true;\r\n    spinToBetType[spinCount] = BetType.Third;\r\n    _spinRouletteWheel(spinCount);\r\n    return (userToSpinCount[msg.sender]);\r\n  }\r\n\r\n  /// @notice for user to check third bet result when spin complete\r\n  /// @dev unsuccessful bet sends 10% to sponsor wallet to ensure future fulfills, 2% to deployer, rest kept by house\r\n  function checkIfThirdWon(uint256 _spin) internal returns (uint256) {\r\n    address _user = spinToUser[_spin];\r\n    if (userToCurrentBet[_user] == 0) revert NoBet();\r\n    if (!userBetThird[_user]) revert NoBet();\r\n    if (!spinIsComplete[_spin]) revert SpinNotComplete();\r\n    uint256 _result = spinResult[_spin] % 37;\r\n    uint256 _thirdResult;\r\n    if (_result > 0 && _result < 13) {\r\n      _thirdResult = 1;\r\n    } else if (_result > 12 && _result < 25) {\r\n      _thirdResult = 2;\r\n    } else if (_result > 24) {\r\n      _thirdResult = 3;\r\n    }\r\n    if (spinResult[_spin] == 37) {\r\n      (bool sent, ) = _user.call{ value: userToCurrentBet[_user] }(\"\");\r\n      if (!sent) revert ReturnFailed();\r\n    } else {}\r\n    if (userToThird[_user] == 1 && _thirdResult == 1) {\r\n      (bool sent, ) = _user.call{ value: userToCurrentBet[_user] * 3 }(\"\");\r\n      if (!sent) revert HouseBalanceTooLow();\r\n    } else if (userToThird[_user] == 2 && _thirdResult == 2) {\r\n      (bool sent, ) = _user.call{ value: userToCurrentBet[_user] * 3 }(\"\");\r\n      if (!sent) revert HouseBalanceTooLow();\r\n    } else if (userToThird[_user] == 3 && _thirdResult == 3) {\r\n      (bool sent, ) = _user.call{ value: userToCurrentBet[_user] * 3 }(\"\");\r\n      if (!sent) revert HouseBalanceTooLow();\r\n    } else {\r\n      (bool sent, ) = sponsorWallet.call{ value: userToCurrentBet[_user] / 10 }(\"\");\r\n      if (!sent) revert TransferToSponsorWalletFailed();\r\n      (bool sent2, ) = deployer.call{ value: userToCurrentBet[_user] / 50 }(\"\");\r\n      if (!sent2) revert TransferToDeployerWalletFailed();\r\n    }\r\n    userToCurrentBet[_user] = 0;\r\n    userBetThird[_user] = false;\r\n    emit WinningNumber(_spin, spinResult[_spin] % 37);\r\n    return (spinResult[_spin] % 37);\r\n  }\r\n\r\n  // make similar function as above for halves\r\n    /// @notice submit bet and \"1\" or \"2\" for a bet on 1st/2nd/3rd of table, which pays out 2:1 if correct after spin\r\n  /// @param _halfBet uint 1 or 2 to represent first or second half of table\r\n  /// @return userToSpinCount[msg.sender] spin count for this msg.sender, to enter in spinRouletteWheel()\r\n  function betHalf(uint256 _halfBet) external payable returns (uint256) {\r\n\t require(_halfBet == 1 || _halfBet == 2, \"_halfBet not 1 or 2\");\r\n\t require(msg.value >= MIN_BET, \"msg.value < MIN_BET\");\r\n\t if (address(this).balance < msg.value * 2) revert HouseBalanceTooLow();\r\n\t userToCurrentBet[msg.sender] = msg.value;\r\n\t unchecked {\r\n\t\t++spinCount;\r\n\t }\r\n\t spinToUser[spinCount] = msg.sender;\r\n\t userToSpinCount[msg.sender] = spinCount;\r\n\t userToHalf[msg.sender] = _halfBet;\r\n\t userBetHalf[msg.sender] = true;\r\n\t spinToBetType[spinCount] = BetType.Half;\r\n\t _spinRouletteWheel(spinCount);\r\n\t return (userToSpinCount[msg.sender]);\r\n  }\r\n\r\n  /// @notice for user to check half bet result when spin complete\r\n  /// @dev unsuccessful bet sends 10% to sponsor wallet to ensure future fulfills, 2% to deployer, rest kept by house\r\n  function checkIfHalfWon(uint256 _spin) internal returns (uint256) {\r\n\t address _user = spinToUser[_spin];\r\n\t if (userToCurrentBet[_user] == 0) revert NoBet();\r\n\t if (!userBetHalf[_user]) revert NoBet();\r\n\t if (!spinIsComplete[_spin]) revert SpinNotComplete();\r\n\t uint256 _result = spinResult[_spin] % 37;\r\n\t uint256 _halfResult;\r\n\t if (_result > 0 && _result < 19) {\r\n\t\t_halfResult = 1;\r\n\t } else if (_result > 18) {\r\n\t\t_halfResult = 2;\r\n\t }\r\n\t if (spinResult[_spin] == 37) {\r\n\t\t(bool sent, ) = _user.call{ value: userToCurrentBet[_user] }(\"\");\r\n\t\tif (!sent) revert ReturnFailed();\r\n\t } else {}\r\n\t if (userToHalf[_user] == 1 && _halfResult == 1) {\r\n\t\t(bool sent, ) = _user.call{ value: userToCurrentBet[_user] * 2 }(\"\");\r\n\t\tif (!sent) revert HouseBalanceTooLow();\r\n\t } else if (userToHalf[_user] == 2 && _halfResult == 2) {\r\n\t\t(bool sent, ) = _user.call{ value: userToCurrentBet[_user] * 2 }(\"\");\r\n\t\tif (!sent) revert HouseBalanceTooLow();\r\n\t } else {\r\n\t\t(bool sent, ) = sponsorWallet.call{ value: userToCurrentBet[_user] / 10 }(\"\");\r\n\t\tif (!sent) revert TransferToSponsorWalletFailed();\r\n\t\t(bool sent2, ) = deployer.call{ value: userToCurrentBet[_user] / 50 }(\"\");\r\n\t\tif (!sent2) revert TransferToDeployerWalletFailed();\r\n\t }\r\n\t userToCurrentBet[_user] = 0;\r\n\t userBetHalf[_user] = false;\r\n\t emit WinningNumber(_spin, spinResult[_spin] % 37);\r\n\t return (spinResult[_spin] % 37);\r\n  }\r\n\r\n\r\n\r\n\r\n  /** @notice for user to submit a boolean even or odd bet, which pays out 2:1 if correct\r\n   *** reminder that a return of 0 is neither even nor odd in roulette **/\r\n  /// @param _isEven boolean bet, true for even\r\n  /// @return userToSpinCount[msg.sender] spin count for this msg.sender, to enter in spinRouletteWheel()\r\n  function betEvenOdd(bool _isEven) external payable returns (uint256) {\r\n    require(msg.value >= MIN_BET, \"msg.value < MIN_BET\");\r\n    if (address(this).balance < msg.value * 2) revert HouseBalanceTooLow();\r\n    unchecked {\r\n      ++spinCount;\r\n    }\r\n    spinToUser[spinCount] = msg.sender;\r\n    userToCurrentBet[msg.sender] = msg.value;\r\n    userToSpinCount[msg.sender] = spinCount;\r\n    userBetEvenOdd[msg.sender] = true;\r\n    if (_isEven) {\r\n      userToEven[msg.sender] = true;\r\n    } else {}\r\n    spinToBetType[spinCount] = BetType.EvenOdd;\r\n    _spinRouletteWheel(spinCount);\r\n    return (userToSpinCount[msg.sender]);\r\n  }\r\n\r\n  /// @notice for user to check even/odd bet result when spin complete\r\n  /// @dev unsuccessful bet sends 10% to sponsor wallet to ensure future fulfills, 2% to deployer, rest kept by house\r\n  function checkIfEvenOddWon(uint256 _spin) internal returns (uint256) {\r\n    address _user = spinToUser[_spin];\r\n    if (userToCurrentBet[_user] == 0) revert NoBet();\r\n    if (!userBetEvenOdd[_user]) revert NoBet();\r\n    if (!spinIsComplete[_spin]) revert SpinNotComplete();\r\n    uint256 _result = spinResult[_spin] % 37;\r\n    if (spinResult[_spin] == 37) {\r\n      (bool sent, ) = _user.call{ value: userToCurrentBet[_user] }(\"\");\r\n      if (!sent) revert ReturnFailed();\r\n    } else {}\r\n    if (_result == 0) {\r\n      (bool sent, ) = sponsorWallet.call{ value: userToCurrentBet[_user] / 10 }(\"\");\r\n      if (!sent) revert TransferToSponsorWalletFailed();\r\n    } else if (userToEven[_user] && (_result % 2 == 0)) {\r\n      (bool sent, ) = _user.call{ value: userToCurrentBet[_user] * 2 }(\"\");\r\n      if (!sent) revert HouseBalanceTooLow();\r\n    } else if (!userToEven[_user] && _result % 2 != 0) {\r\n      (bool sent, ) = _user.call{ value: userToCurrentBet[_user] * 2 }(\"\");\r\n      if (!sent) revert HouseBalanceTooLow();\r\n    } else {\r\n      (bool sent, ) = sponsorWallet.call{ value: userToCurrentBet[_user] / 10 }(\"\");\r\n      if (!sent) revert TransferToSponsorWalletFailed();\r\n      (bool sent2, ) = deployer.call{ value: userToCurrentBet[_user] / 50 }(\"\");\r\n      if (!sent2) revert TransferToDeployerWalletFailed();\r\n    }\r\n    userBetEvenOdd[_user] = false;\r\n    userToCurrentBet[_user] = 0;\r\n    emit WinningNumber(_spin, spinResult[_spin] % 37);\r\n    return (spinResult[_spin] % 37);\r\n  }\r\n\r\n  /** @notice for user to submit a boolean black or red bet, which pays out 2:1 if correct\r\n   *** reminder that 0 is neither red nor black in roulette **/\r\n  /// @param _isBlack boolean bet, true for black, false for red\r\n  /// @return userToSpinCount[msg.sender] spin count for this msg.sender, to enter in spinRouletteWheel()\r\n  function betColor(bool _isBlack) external payable returns (uint256) {\r\n    require(msg.value >= MIN_BET, \"msg.value < MIN_BET\");\r\n    if (address(this).balance < msg.value * 2) revert HouseBalanceTooLow();\r\n    unchecked {\r\n      ++spinCount;\r\n    }\r\n    spinToUser[spinCount] = msg.sender;\r\n    userToCurrentBet[msg.sender] = msg.value;\r\n    userToSpinCount[msg.sender] = spinCount;\r\n    userBetAColor[msg.sender] = true;\r\n    if (_isBlack) {\r\n      userToColor[msg.sender] = true;\r\n    } else {}\r\n    spinToBetType[spinCount] = BetType.Color;\r\n    _spinRouletteWheel(spinCount);\r\n    return (userToSpinCount[msg.sender]);\r\n  }\r\n\r\n  /// @notice for user to check color bet result when spin complete\r\n  /// @dev unsuccessful bet sends 10% to sponsor wallet to ensure future fulfills, 2% to deployer, rest kept by house\r\n  function checkIfColorWon(uint256 _spin) internal returns (uint256) {\r\n    address _user = spinToUser[_spin];\r\n    if (userToCurrentBet[_user] == 0) revert NoBet();\r\n    if (!userBetAColor[_user]) revert NoBet();\r\n    if (!spinIsComplete[_spin]) revert SpinNotComplete();\r\n    uint256 _result = spinResult[_spin] % 37;\r\n    if (spinResult[_spin] == 37) {\r\n      (bool sent, ) = _user.call{ value: userToCurrentBet[_user] }(\"\");\r\n      if (!sent) revert ReturnFailed();\r\n    } else if (_result == 0) {\r\n      (bool sent, ) = sponsorWallet.call{ value: userToCurrentBet[_user] / 10 }(\"\");\r\n      if (!sent) revert TransferToSponsorWalletFailed();\r\n      (bool sent2, ) = deployer.call{ value: userToCurrentBet[_user] / 50 }(\"\");\r\n      if (!sent2) revert TransferToDeployerWalletFailed();\r\n    } else {\r\n      if (blackNumber[_result]) {\r\n        blackSpin[_spin] = true;\r\n      } else {}\r\n      if (userToColor[_user] && blackSpin[_spin]) {\r\n        (bool sent, ) = _user.call{ value: userToCurrentBet[_user] * 2 }(\"\");\r\n        if (!sent) revert HouseBalanceTooLow();\r\n      } else if (!userToColor[_user] && !blackSpin[_spin] && _result != 0) {\r\n        (bool sent, ) = _user.call{ value: userToCurrentBet[_user] * 2 }(\"\");\r\n        if (!sent) revert HouseBalanceTooLow();\r\n      } else {\r\n        (bool sent, ) = sponsorWallet.call{ value: userToCurrentBet[_user] / 10 }(\"\");\r\n        if (!sent) revert TransferToSponsorWalletFailed();\r\n        (bool sent2, ) = deployer.call{ value: userToCurrentBet[_user] / 50 }(\"\");\r\n        if (!sent2) revert TransferToDeployerWalletFailed();\r\n      }\r\n    }\r\n    userBetAColor[_user] = false;\r\n    userToCurrentBet[_user] = 0;\r\n    emit WinningNumber(_spin, spinResult[_spin] % 37);\r\n    return (spinResult[_spin] % 37);\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_airnodeRrp\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"HouseBalanceTooLow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoBet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReturnFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SpinNotComplete\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToDeployerWalletFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToSponsorWalletFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"response\",\"type\":\"uint256\"}],\"name\":\"ReceivedUint256\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"name\":\"RequestedUint256\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"spinNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qrngResult\",\"type\":\"uint256\"}],\"name\":\"SpinComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"spinNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winningNumber\",\"type\":\"uint256\"}],\"name\":\"WinningNumber\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MIN_BET\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airnodeRrp\",\"outputs\":[{\"internalType\":\"contract IAirnodeRrpV0\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isBlack\",\"type\":\"bool\"}],\"name\":\"betColor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isEven\",\"type\":\"bool\"}],\"name\":\"betEvenOdd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_halfBet\",\"type\":\"uint256\"}],\"name\":\"betHalf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numberBet\",\"type\":\"uint256\"}],\"name\":\"betNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_oneThirdBet\",\"type\":\"uint256\"}],\"name\":\"betOneThird\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"blackSpin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"fulfillUint256\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"requestIdToResult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"requestIdToSpinCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_endpointId\",\"type\":\"bytes32\"},{\"internalType\":\"address payable\",\"name\":\"_sponsorWallet\",\"type\":\"address\"}],\"name\":\"setRequestParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"spinIsComplete\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"spinResult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"spinToBetType\",\"outputs\":[{\"internalType\":\"enum Roulette.BetType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"spinToUser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"topUpSponsorWallet\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userBetAColor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userBetANumber\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userBetEvenOdd\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userBetHalf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userBetThird\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userToColor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userToCurrentBet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userToEven\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userToHalf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userToNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userToSpinCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userToThird\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Roulette", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000a0ad79d995ddeeb18a14eaef56a549a04e3aa1bd", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://60f90e90d624cb5c28df3c85cafad9e2df91f4a33da475079e1128eb8db36d35"}