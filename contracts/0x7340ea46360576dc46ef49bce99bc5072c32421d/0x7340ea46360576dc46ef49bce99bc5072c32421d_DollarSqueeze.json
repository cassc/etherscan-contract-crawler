{"SourceCode": "/**\r\nTG: https://t.me/DollarSqueeze\r\nWebsite: https://dollarsqueeze.io\r\nAuthor: @bLock_doctor\r\n */\r\n// SPDX-License-Identifier: Unlicensed\r\npragma solidity ^0.8.12;\r\n \r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\ninterface IUniRouterV1\r\n{\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n \r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\ninterface IUniRouterV2 is IUniRouterV1\r\n{\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\ninterface IDividendDistributor {\r\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external;\r\n    function setShare(address shareholder, uint256 amount) external;\r\n    function deposit() external payable;\r\n    function process(uint256 gas) external;\r\n}\r\ncontract DividendDistributor is IDividendDistributor {\r\n    using SafeMath for uint256;\r\n    address _token;\r\n    struct Share {\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised;\r\n    }\r\n    IUniRouterV2 router;\r\n    address[] shareholders;\r\n    mapping (address => uint256) shareholderIndexes;\r\n    mapping (address => uint256) shareholderClaims;\r\n    mapping (address => Share) public shares;\r\n    uint256 public totalShares;\r\n    uint256 public totalDividends;\r\n    uint256 public totalDistributed;\r\n    uint256 public dividendsPerShare;\r\n    uint256 public dividendsPerShareAccuracyFactor = 10 ** 36;\r\n    uint256 public minPeriod = 1 hours;\r\n    uint256 public minDistribution = 1;\r\n    uint256 currentIndex;\r\n    bool initialized;\r\n    modifier initialization() {\r\n        require(!initialized);\r\n        _;\r\n        initialized = true;\r\n    }\r\n    modifier onlyToken() {\r\n        require(msg.sender == _token); _;\r\n    }\r\n    constructor (IUniRouterV2 _router) {\r\n        router = _router;\r\n        _token = msg.sender;\r\n    }\r\n    function setDistributionCriteria(uint256 newMinPeriod, uint256 newMinDistribution) external override onlyToken {\r\n        minPeriod = newMinPeriod;\r\n        minDistribution = newMinDistribution;\r\n    }\r\n    function setShare(address shareholder, uint256 amount) external override onlyToken {\r\n        if(shares[shareholder].amount > 0){\r\n            distributeDividend(shareholder);\r\n        }\r\n        if(amount > 0 && shares[shareholder].amount == 0){\r\n            addShareholder(shareholder);\r\n        }else if(amount == 0 && shares[shareholder].amount > 0){\r\n            removeShareholder(shareholder);\r\n        }\r\n        totalShares = totalShares.sub(shares[shareholder].amount).add(amount);\r\n        shares[shareholder].amount = amount;\r\n        shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\r\n    }\r\n    function deposit() external payable override onlyToken\r\n    {\r\n        totalDividends = totalDividends.add(msg.value);\r\n        dividendsPerShare = dividendsPerShare.add(dividendsPerShareAccuracyFactor.mul(msg.value).div(totalShares));\r\n    }\r\n    function process(uint256 gas) external override onlyToken {\r\n        uint256 shareholderCount = shareholders.length;\r\n        if(shareholderCount == 0) { return; }\r\n        uint256 iterations = 0;\r\n        uint256 gasUsed = 0;\r\n        uint256 gasLeft = gasleft();\r\n        while(gasUsed < gas && iterations < shareholderCount) {\r\n            if(currentIndex >= shareholderCount){ currentIndex = 0; }\r\n            if(shouldDistribute(shareholders[currentIndex])){\r\n                distributeDividend(shareholders[currentIndex]);\r\n            }\r\n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\r\n            gasLeft = gasleft();\r\n            currentIndex++;\r\n            iterations++;\r\n        }\r\n    }\r\n    function shouldDistribute(address shareholder) internal view returns (bool) {\r\n        return shareholderClaims[shareholder] + minPeriod < block.timestamp\r\n                && getUnpaidEarnings(shareholder) > minDistribution;\r\n    }\r\n    function distributeDividend(address shareholder) internal {\r\n        if(shares[shareholder].amount == 0){ return; }\r\n        uint256 amount = getUnpaidEarnings(shareholder);\r\n        if(amount > 0){\r\n            totalDistributed = totalDistributed.add(amount);\r\n            (bool success, ) = payable(shareholder).call{value: amount, gas: 30000}(\"\");\r\n            success = false;\r\n            shareholderClaims[shareholder] = block.timestamp;\r\n            shares[shareholder].totalRealised = shares[shareholder].totalRealised.add(amount);\r\n            shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\r\n        }\r\n    }\r\n    function claimDividend() external {\r\n        require(shouldDistribute(msg.sender), \"Too soon. Need to wait!\");\r\n        distributeDividend(msg.sender);\r\n    }\r\n    function getUnpaidEarnings(address shareholder) public view returns (uint256) {\r\n        if(shares[shareholder].amount == 0){ return 0; }\r\n        uint256 shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount);\r\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\r\n        if(shareholderTotalDividends <= shareholderTotalExcluded){ return 0; }\r\n        return shareholderTotalDividends.sub(shareholderTotalExcluded);\r\n    }\r\n    function getCumulativeDividends(uint256 share) internal view returns (uint256) {\r\n        return share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\r\n    }\r\n    function addShareholder(address shareholder) internal {\r\n        shareholderIndexes[shareholder] = shareholders.length;\r\n        shareholders.push(shareholder);\r\n    }\r\n    function removeShareholder(address shareholder) internal {\r\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\r\n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\r\n        shareholders.pop();\r\n    }\r\n}\r\ncontract Ownable {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor () {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(msg.sender==owner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _owner = address(0);\r\n        emit OwnershipTransferred(_owner, address(0));\r\n    }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n    }\r\n}\r\ncontract DollarSqueeze is IERC20, Ownable {\r\n    string private _tokenName=\"DollarSqueeze\";\r\n    string private _tokenSymbol=\"DSQ\";\r\n    uint8 private _decimals=18;\r\n    uint256 private _totalSupply=100000000*10**_decimals; // 100m\r\n    // Transaction Tax\r\n    uint8 private _buyTax=6;\r\n    uint8 private _sellTax=20;\r\n    uint8 private _burnTax=1;\r\n    uint8 private _transferTax=0;\r\n    // Trading\r\n    bool private _airdropDone=false;\r\n    bool private _tradingEnabled=false;\r\n    uint256 private _maxTx=1000000*10**_decimals; // 1m\r\n    // Wallets\r\n    address public backupOwner=0xAe7c6C4D33667185db125842d31e3D79d614986d;\r\n    address public marketingWallet=0xa62909d663e79Eaa49c86F429EE1538be50862aD;\r\n    address public burnWallet=address(0xdead);\r\n    address public zeroAddress=address(0);\r\n    IUniRouterV2 private _router;\r\n    address public _pair;\r\n    // Reward Distributor\r\n    DividendDistributor public dividendDistributor;\r\n    address public dividendDistributorAddress;\r\n    uint256 distributorGas=500000;\r\n    // Mappings\r\n    mapping(address=>uint256) private _balances;\r\n    mapping(address=>mapping (address => uint256)) private _allowances;\r\n    mapping(address=>bool) private _excludedFromFee;\r\n    mapping(address=>bool) private _excludedFromRewards;\r\n    mapping(address=>bool) private _automatedMarketMakers;\r\n    //\r\n    // Swap & Liquify Taxes\r\n    SwapTaxes private _swapTaxes;\r\n    struct SwapTaxes {\r\n        uint8 marketingTax;\r\n        uint8 liquidityTax;\r\n        uint8 rewardsTax;\r\n    }\r\n    //Swap & Liquify\r\n    bool private _inSwap;\r\n    bool private _swapEnabled;\r\n    uint256 private _swapThreshold=100000*10**_decimals;\r\n    modifier lockTheSwap {_inSwap = true;_;_inSwap = false;}\r\n    event SwapAndLiquify(\r\n        uint256 amountTokens,\r\n        uint256 amountETH\r\n    );\r\n \r\n    constructor() {\r\n        _router = IUniRouterV2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        _pair = IDEXFactory(_router.factory()).createPair(_router.WETH(), address(this));\r\n        _allowances[address(this)][address(_router)]=type(uint256).max;\r\n        _automatedMarketMakers[_pair] = true;\r\n        _excludedFromFee[msg.sender]=true;\r\n        _excludedFromFee[address(this)]=true;\r\n        _excludedFromFee[burnWallet]=true;\r\n        _excludedFromFee[zeroAddress]=true;\r\n        _excludedFromRewards[_pair]=true;\r\n        _excludedFromRewards[msg.sender]=true;\r\n        _excludedFromRewards[address(this)]=true;\r\n        _excludedFromRewards[burnWallet]=true;\r\n        _excludedFromRewards[zeroAddress]=true;\r\n        _swapTaxes=SwapTaxes(50,20,30);\r\n        dividendDistributor = new DividendDistributor(_router);\r\n        dividendDistributorAddress=address(dividendDistributor);\r\n        _balances[msg.sender]+=_totalSupply;\r\n        emit Transfer(address(0),msg.sender,_totalSupply);\r\n    }\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) private {\r\n        bool isExcluded=_excludedFromFee[from]||_excludedFromFee[to]||_inSwap;\r\n        bool isBuy=_automatedMarketMakers[from];\r\n        bool isSell=_automatedMarketMakers[to];\r\n        if(isExcluded)_tokenTransfer(from,to,amount,0);\r\n        else {\r\n            require(_tradingEnabled);\r\n            if(isBuy)_buyTokens(from,to,amount);\r\n            else if(isSell) {\r\n                if(!_inSwap&&_swapEnabled)_swapAndLiquify(false);\r\n                _sellTokens(from,to,amount);\r\n            } else {\r\n                _tokenTransfer(from,to,amount,_transferTax*amount/100);\r\n            }\r\n        }\r\n    }\r\n    function _swapAndLiquify(\r\n        bool ignoreLimits\r\n    ) private lockTheSwap {\r\n        uint256 contractTokenBalance=_balances[address(this)];\r\n        uint256 toSwap=_swapThreshold;\r\n        if(contractTokenBalance<toSwap) {\r\n            if(ignoreLimits&&contractTokenBalance>0) {\r\n                toSwap=contractTokenBalance;\r\n            } else return;\r\n        }\r\n        uint256 totalLiquidityTokens=toSwap*_swapTaxes.liquidityTax/100;\r\n        uint256 tokensRemaining=toSwap-totalLiquidityTokens;\r\n        uint256 liquidityTokens=totalLiquidityTokens/2;\r\n        uint256 liquidityETHTokens=totalLiquidityTokens-liquidityTokens;\r\n        toSwap=tokensRemaining+liquidityETHTokens;\r\n        uint256 oldETH=address(this).balance;\r\n        _swapTokensForETH(toSwap);\r\n        uint256 newETH=address(this).balance-oldETH;\r\n        uint256 liquidityETH=(newETH*liquidityETHTokens)/toSwap;\r\n        uint256 remainingETH=newETH-liquidityETH;\r\n        uint256 marketingETH=remainingETH*_swapTaxes.marketingTax/100;\r\n        uint256 rewardsETH=remainingETH-marketingETH;\r\n        if (rewardsETH > 0)\r\n            try dividendDistributor.deposit{value: rewardsETH}() {} catch {}\r\n        (bool transferMarketing,) = payable(marketingWallet).call{value: marketingETH, gas: 30000}(\"\");\r\n        transferMarketing=false;\r\n        _addLiquidity(liquidityTokens,liquidityETH);\r\n        emit SwapAndLiquify(liquidityTokens,liquidityETH);\r\n    }\r\n    function _buyTokens(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) private {\r\n        require(amount<=_maxTx,\"Amount exceeds maxTx.\");\r\n        _tokenTransfer(from,to,amount,amount*_buyTax/100);\r\n    }\r\n    function _sellTokens(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) private {\r\n        require(amount<=_maxTx,\"Amount exceeds maxTx.\");\r\n        _tokenTransfer(from,to,amount,amount*_sellTax/100);\r\n    }\r\n    function _tokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 tax\r\n    ) private {\r\n        uint256 tokensToBurn=_burnTax*tax/100;\r\n        _balances[from]-=amount;\r\n        _balances[burnWallet]+=tokensToBurn;\r\n        _balances[address(this)]+=(tax-tokensToBurn);\r\n        _balances[to]+=(amount-tax);\r\n        if(!_excludedFromRewards[from]) try dividendDistributor.setShare(from,_balances[from]) {} catch {}\r\n        if(!_excludedFromRewards[to]) try dividendDistributor.setShare(to,_balances[to]) {} catch {}\r\n        try dividendDistributor.process(distributorGas) {} catch {}\r\n        emit Transfer(from,to,(amount-tax));\r\n    }\r\n    function _swapTokensForETH(\r\n        uint256 tokenAmount\r\n    ) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = _router.WETH();\r\n        _approve(address(this), address(_router), tokenAmount);\r\n        _router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, \r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n    function _addLiquidity(\r\n        uint256 tokenAmount,\r\n        uint256 ETHAmount\r\n    ) private {\r\n        _approve(address(this), address(_router), tokenAmount);\r\n        _router.addLiquidityETH{value: ETHAmount}(\r\n            address(this),\r\n            tokenAmount,\r\n            0,\r\n            0,\r\n            burnWallet,\r\n            block.timestamp\r\n        );\r\n    }\r\n    //\r\n    function enableTrading() public onlyOwner() {\r\n        require(!_tradingEnabled,\"Trading is already enabled.\");\r\n        _tradingEnabled=!_tradingEnabled;\r\n    }\r\n    function recoverOwnershipFromBackup() public {\r\n        require(msg.sender==backupOwner);\r\n        transferOwnership(backupOwner);\r\n    }\r\n    function updateBackupOwnerWallet(\r\n        address _backupOwner\r\n    ) public onlyOwner {\r\n        backupOwner=_backupOwner;\r\n    }\r\n    function updateAutomatedMarketMakers(\r\n        address marketMaker,\r\n        bool enabled\r\n    ) public onlyOwner {\r\n        _automatedMarketMakers[marketMaker]=enabled;\r\n        excludeFromReward(marketMaker,true);\r\n    }\r\n    function updateTax(\r\n        uint8 buyTax,\r\n        uint8 sellTax,\r\n        uint8 burnTax,\r\n        uint8 transferTax\r\n    ) public onlyOwner {\r\n        require(_buyTax+sellTax<=30,\"Taxes cannot exceed 30%.\");\r\n        require(_transferTax<=20,\"Transfer tax cannot exceed 20%.\");\r\n        _buyTax=buyTax;\r\n        _sellTax=sellTax;\r\n        _burnTax=burnTax;\r\n        _transferTax=transferTax;\r\n    }\r\n    function updateSwapTaxes(\r\n        uint8 marketingTax,\r\n        uint8 rewardsTax,\r\n        uint8 liquidityTax\r\n    ) public onlyOwner {\r\n        require((marketingTax+rewardsTax+liquidityTax)==100,\"Swap tax cannot exceed 100.\");\r\n        _swapTaxes.marketingTax=marketingTax;\r\n        _swapTaxes.rewardsTax=rewardsTax;\r\n        _swapTaxes.liquidityTax=liquidityTax;\r\n    }\r\n    function updateSwapThreshold(\r\n        uint256 swapThreshold\r\n    ) public onlyOwner {\r\n        require(_swapThreshold>0&&swapThreshold<=(_totalSupply*1/100));\r\n        _swapThreshold=swapThreshold;\r\n    }\r\n    function switchSwapEnabled(\r\n        bool swapEnabled\r\n    ) public onlyOwner {\r\n        _swapEnabled=swapEnabled;\r\n    }\r\n    function triggerSwapAndLiquify(\r\n        bool ignoreLimits\r\n    ) public onlyOwner {\r\n        _swapAndLiquify(ignoreLimits);\r\n    }\r\n    function excludeFromFee(\r\n        address account,\r\n        bool excluded\r\n    ) public onlyOwner {\r\n        _excludedFromFee[account]=excluded;\r\n    }\r\n    function excludeFromReward(\r\n        address account,\r\n        bool excluded\r\n    ) public onlyOwner {\r\n        _excludedFromRewards[account]=excluded;\r\n        try dividendDistributor.setShare(account,excluded?0:_balances[account]) {} catch {}\r\n    }\r\n    function updateMaxTx(\r\n        uint256 maxTx\r\n    ) public onlyOwner {\r\n        require(maxTx>=(_totalSupply*1/100) / 2);\r\n        _maxTx=maxTx*10**_decimals;\r\n    }\r\n    function updateMarketingWallet(\r\n        address _marketingWallet\r\n    ) public onlyOwner {\r\n        require(_marketingWallet!=address(0),\"Cannot be zero address!\");\r\n        marketingWallet=_marketingWallet;\r\n    }\r\n    function withdrawStrandedToken(\r\n        address strandedToken\r\n    ) public onlyOwner {\r\n        require(strandedToken!=address(this));\r\n        IERC20 token=IERC20(strandedToken);\r\n        token.transfer(owner(),token.balanceOf(address(this)));\r\n    }\r\n    function withdrawStuckETH() public onlyOwner {\r\n        (bool success,)=msg.sender.call{value:(address(this).balance)}(\"\");\r\n        require(success);\r\n    }\r\n    function addRewardsManually() public payable onlyOwner {\r\n        require(msg.value>0);\r\n        try dividendDistributor.deposit{value: msg.value}() {} catch {}\r\n    }\r\n    function updateDistributorSettings(\r\n        uint256 _minPeriod,\r\n        uint256 _minDistribution,\r\n        uint256 gas\r\n    ) public onlyOwner {\r\n        require(gas<=1200000);\r\n        dividendDistributor.setDistributionCriteria(_minPeriod, _minDistribution);\r\n        distributorGas = gas;\r\n    }\r\n    //\r\n    function showMaxTx() public view returns(uint256) {\r\n        return _maxTx;\r\n    }\r\n    function isSwapEnabled() public view returns(bool) {\r\n        return _swapEnabled;\r\n    }\r\n    function showTradeTaxes() public view returns(\r\n        uint8 buyTax, \r\n        uint8 sellTax,\r\n        uint8 burnTax,\r\n        uint8 transferTax\r\n    ) {\r\n        buyTax=_buyTax;\r\n        sellTax=_sellTax;\r\n        burnTax=_burnTax;\r\n        transferTax=_transferTax;\r\n    }\r\n    function showSwapTaxes() public view returns(\r\n        uint8 marketingTax, \r\n        uint8 liquidityTax, \r\n        uint8 rewardsTax\r\n    ) {\r\n        marketingTax=_swapTaxes.marketingTax;\r\n        liquidityTax=_swapTaxes.liquidityTax;\r\n        rewardsTax=_swapTaxes.rewardsTax;\r\n    }\r\n    function showDistributorDetails() public view returns(\r\n        address _distributorAddress, \r\n        uint256 _distributorGas\r\n    ) {\r\n        _distributorAddress=dividendDistributorAddress;\r\n        _distributorGas=distributorGas;\r\n    }\r\n    function isTradingEnabled() public view returns(bool) {\r\n        return _tradingEnabled;\r\n    }\r\n    //\r\n    function transfer(\r\n        address recipient, \r\n        uint256 amount\r\n    ) external override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n    function transferFrom(\r\n        address sender, \r\n        address recipient, \r\n        uint256 amount\r\n    ) external override returns (bool) {\r\n        uint256 allowance_ = _allowances[sender][msg.sender];\r\n        _transfer(sender, recipient, amount);\r\n        require(allowance_ >= amount);\r\n        _approve(sender, msg.sender, allowance_ - amount);\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n    function _approve(\r\n        address owner, \r\n        address spender, \r\n        uint256 amount\r\n    ) private {\r\n        require((owner != address(0) && spender != address(0)), \"Owner/Spender address cannot be 0.\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n    function approve(\r\n        address spender, \r\n        uint256 amount\r\n    ) external override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n    function allowance(\r\n        address owner_,\r\n        address spender\r\n    ) external view override returns (uint256) {\r\n        return _allowances[owner_][spender];\r\n    }\r\n    function balanceOf(\r\n        address account\r\n    ) external view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n    function name() external view returns (string memory) {\r\n        return _tokenName;\r\n    }\r\n    function symbol() external view returns (string memory) {\r\n        return _tokenSymbol;\r\n    }\r\n    function totalSupply() external view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    function decimals() external view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n    function getOwner() external view returns (address) {\r\n        return owner();\r\n    }\r\n    receive() external payable { }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addRewardsManually\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"backupOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendDistributor\",\"outputs\":[{\"internalType\":\"contract DividendDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendDistributorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSwapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverOwnershipFromBackup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"showDistributorDetails\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_distributorAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_distributorGas\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"showMaxTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"showSwapTaxes\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"marketingTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"liquidityTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rewardsTax\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"showTradeTaxes\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"buyTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sellTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"burnTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"transferTax\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"swapEnabled\",\"type\":\"bool\"}],\"name\":\"switchSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"ignoreLimits\",\"type\":\"bool\"}],\"name\":\"triggerSwapAndLiquify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketMaker\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"updateAutomatedMarketMakers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_backupOwner\",\"type\":\"address\"}],\"name\":\"updateBackupOwnerWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minDistribution\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"updateDistributorSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketingWallet\",\"type\":\"address\"}],\"name\":\"updateMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTx\",\"type\":\"uint256\"}],\"name\":\"updateMaxTx\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"marketingTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rewardsTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"liquidityTax\",\"type\":\"uint8\"}],\"name\":\"updateSwapTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"swapThreshold\",\"type\":\"uint256\"}],\"name\":\"updateSwapThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"buyTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sellTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"burnTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"transferTax\",\"type\":\"uint8\"}],\"name\":\"updateTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strandedToken\",\"type\":\"address\"}],\"name\":\"withdrawStrandedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawStuckETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zeroAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DollarSqueeze", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c999a8a079c99f06e84b8b0abb5ae947e4a89e4f841312a0932b141ef5cfa900"}