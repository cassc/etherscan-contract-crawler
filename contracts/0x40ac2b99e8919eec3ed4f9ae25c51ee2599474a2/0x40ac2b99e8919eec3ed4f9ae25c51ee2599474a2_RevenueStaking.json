{"SourceCode": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.20;\r\n\r\ninterface IDexRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, 'SafeMath: addition overflow');\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, 'SafeMath: subtraction overflow');\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, 'SafeMath: multiplication overflow');\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, 'SafeMath: division by zero');\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, 'SafeMath: modulo by zero');\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\r\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint256 x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMathInt {\r\n    int256 private constant MIN_INT256 = int256(1) << 255;\r\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\r\n\r\n    /**\r\n     * @dev Multiplies two int256 variables and fails on overflow.\r\n     */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a * b;\r\n\r\n        // Detect overflow when multiplying MIN_INT256 with -1\r\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\r\n        require((b == 0) || (c / b == a));\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Division of two int256 variables and fails on overflow.\r\n     */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        // Prevent overflow when dividing MIN_INT256 by -1\r\n        require(b != -1 || a != MIN_INT256);\r\n\r\n        // Solidity already throws when dividing by 0.\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two int256 variables and fails on overflow.\r\n     */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two int256 variables and fails on overflow.\r\n     */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Converts to absolute value, and fails on overflow.\r\n     */\r\n    function abs(int256 a) internal pure returns (int256) {\r\n        require(a != MIN_INT256);\r\n        return a < 0 ? -a : a;\r\n    }\r\n\r\n\r\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\r\n        require(a >= 0);\r\n        return uint256(a);\r\n    }\r\n}\r\n\r\nlibrary SafeMathUint {\r\n  function toInt256Safe(uint256 a) internal pure returns (int256) {\r\n    int256 b = int256(a);\r\n    require(b >= 0);\r\n    return b;\r\n  }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface DividendPayingContractOptionalInterface {\r\n  function withdrawableDividendOf(address _owner) external view returns(uint256);\r\n  function withdrawnDividendOf(address _owner) external view returns(uint256);\r\n  function accumulativeDividendOf(address _owner) external view returns(uint256);\r\n}\r\n\r\ninterface DividendPayingContractInterface {\r\n  function dividendOf(address _owner) external view returns(uint256);\r\n  function distributeDividends() external payable;\r\n  function withdrawDividend() external;\r\n  event DividendsDistributed(\r\n    address indexed from,\r\n    uint256 weiAmount\r\n  );\r\n  event DividendWithdrawn(\r\n    address indexed to,\r\n    uint256 weiAmount\r\n  );\r\n}\r\n\r\ncontract DividendPayingContract is DividendPayingContractInterface, DividendPayingContractOptionalInterface {\r\n  using SafeMath for uint256;\r\n  using SafeMathUint for uint256;\r\n  using SafeMathInt for int256;\r\n\r\n  uint256 constant internal magnitude = 2**128;\r\n\r\n  uint256 internal magnifiedDividendPerShare;\r\n                                                                         \r\n  mapping(address => int256) internal magnifiedDividendCorrections;\r\n  mapping(address => uint256) internal withdrawnDividends;\r\n  \r\n  mapping (address => uint256) public holderBalance;\r\n  uint256 public totalBalance;\r\n\r\n  uint256 public totalDividendsDistributed;\r\n\r\n  receive() external payable {\r\n    distributeDividends();\r\n  }\r\n\r\n  function distributeDividends() public override payable {\r\n    if(totalBalance > 0 && msg.value > 0){\r\n        magnifiedDividendPerShare = magnifiedDividendPerShare.add(\r\n            (msg.value).mul(magnitude) / totalBalance\r\n        );\r\n        emit DividendsDistributed(msg.sender, msg.value);\r\n\r\n        totalDividendsDistributed = totalDividendsDistributed.add(msg.value);\r\n    }\r\n  }\r\n\r\n  function withdrawDividend() external virtual override {\r\n    _withdrawDividendOfUser(payable(msg.sender));\r\n  }\r\n\r\n  function _withdrawDividendOfUser(address payable user) internal returns (uint256) {\r\n    uint256 _withdrawableDividend = withdrawableDividendOf(user);\r\n    if (_withdrawableDividend > 0) {\r\n      withdrawnDividends[user] = withdrawnDividends[user].add(_withdrawableDividend);\r\n\r\n      emit DividendWithdrawn(user, _withdrawableDividend);\r\n      (bool success,) = user.call{value: _withdrawableDividend}(\"\");\r\n\r\n      if(!success) {\r\n        withdrawnDividends[user] = withdrawnDividends[user].sub(_withdrawableDividend);\r\n        return 0;\r\n      }\r\n\r\n      return _withdrawableDividend;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  function dividendOf(address _owner) external view override returns(uint256) {\r\n    return withdrawableDividendOf(_owner);\r\n  }\r\n\r\n  function withdrawableDividendOf(address _owner) public view override returns(uint256) {\r\n    return accumulativeDividendOf(_owner).sub(withdrawnDividends[_owner]);\r\n  }\r\n\r\n  function withdrawnDividendOf(address _owner) external view override returns(uint256) {\r\n    return withdrawnDividends[_owner];\r\n  }\r\n\r\n  function accumulativeDividendOf(address _owner) public view override returns(uint256) {\r\n    return magnifiedDividendPerShare.mul(holderBalance[_owner]).toInt256Safe()\r\n      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;\r\n  }\r\n\r\n  function _increase(address account, uint256 value) internal {\r\n    magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\r\n      .sub( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );\r\n  }\r\n\r\n  function _reduce(address account, uint256 value) internal {\r\n    magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\r\n      .add( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );\r\n  }\r\n\r\n  function _setBalance(address account, uint256 newBalance) internal {\r\n    uint256 currentBalance = holderBalance[account];\r\n    holderBalance[account] = newBalance;\r\n    if(newBalance > currentBalance) {\r\n      uint256 increaseAmount = newBalance.sub(currentBalance);\r\n      _increase(account, increaseAmount);\r\n      totalBalance += increaseAmount;\r\n    } else if(newBalance < currentBalance) {\r\n      uint256 reduceAmount = currentBalance.sub(newBalance);\r\n      _reduce(account, reduceAmount);\r\n      totalBalance -= reduceAmount;\r\n    }\r\n  }\r\n}\r\n\r\n\r\ncontract DividendTracker is DividendPayingContract {\r\n\r\n    event Claim(address indexed account, uint256 amount, bool indexed automatic);\r\n\r\n    constructor() {}\r\n\r\n    function getAccount(address _account)\r\n        public view returns (\r\n            address account,\r\n            uint256 withdrawableDividends,\r\n            uint256 totalDividends,\r\n            uint256 balance) {\r\n        account = _account;\r\n\r\n        withdrawableDividends = withdrawableDividendOf(account);\r\n        totalDividends = accumulativeDividendOf(account);\r\n\r\n        balance = holderBalance[account];\r\n    }\r\n    function setBalance(address payable account, uint256 newBalance) internal {\r\n\r\n        _setBalance(account, newBalance);\r\n\r\n    \tprocessAccount(account, true);\r\n    }\r\n    \r\n    function processAccount(address payable account, bool automatic) internal returns (bool) {\r\n        uint256 amount = _withdrawDividendOfUser(account);\r\n\r\n    \tif(amount > 0) {\r\n            emit Claim(account, amount, automatic);\r\n    \t\treturn true;\r\n    \t}\r\n\r\n    \treturn false;\r\n    }\r\n\r\n    function getTotalDividendsDistributed() external view returns (uint256) {\r\n        return totalDividendsDistributed;\r\n    }\r\n\r\n\tfunction dividendTokenBalanceOf(address account) public view returns (uint256) {\r\n\t\treturn holderBalance[account];\r\n\t}\r\n\r\n    function getNumberOfDividends() external view returns(uint256) {\r\n        return totalBalance;\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract RevenueStaking is ReentrancyGuard, DividendTracker {\r\n\r\n    IERC20 public immutable stakingToken;\r\n    IDexRouter public immutable dexRouter;\r\n\r\n    mapping (address => uint256) public holderUnlockTime;\r\n    uint256 public lockDuration;\r\n\r\n    event Deposit(address indexed user, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 amount);\r\n\r\n    constructor(address _stakingToken, uint256 _lockTimeInDays) {\r\n        require(_stakingToken != address(0), \"cannot be 0 address\");\r\n        stakingToken = IERC20(_stakingToken);\r\n        \r\n        lockDuration = _lockTimeInDays * 1 days;\r\n\r\n        address _v2Router;\r\n\r\n        // @dev assumes WETH pair\r\n        if(block.chainid == 1){\r\n            _v2Router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n        } else if(block.chainid == 5){\r\n            _v2Router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n        } else {\r\n            revert(\"Chain not configured\");\r\n        }\r\n\r\n        dexRouter = IDexRouter(_v2Router);\r\n    }\r\n\r\n    // Stake primary tokens\r\n    function deposit(uint256 _amount) external nonReentrant {\r\n        require(_amount > 0, \"Zero Amount\");\r\n\r\n        if(holderUnlockTime[msg.sender] == 0){\r\n            holderUnlockTime[msg.sender] = block.timestamp + lockDuration;\r\n        }\r\n        uint256 userAmount = holderBalance[msg.sender];\r\n\r\n        uint256 amountTransferred = 0;\r\n\r\n        uint256 initialBalance = stakingToken.balanceOf(address(this));\r\n        stakingToken.transferFrom(address(msg.sender), address(this), _amount);\r\n        amountTransferred = stakingToken.balanceOf(address(this)) - initialBalance;\r\n    \r\n        setBalance(payable(msg.sender), userAmount + amountTransferred);\r\n\r\n        emit Deposit(msg.sender, _amount);\r\n    }\r\n\r\n    // Withdraw primary tokens\r\n\r\n    function withdraw(uint256 _amount) external nonReentrant {\r\n        require(_amount > 0, \"Zero Amount\");\r\n        uint256 userAmount = holderBalance[msg.sender];\r\n        require(_amount <= userAmount, \"Not enough tokens\");\r\n        require(holderUnlockTime[msg.sender] <= block.timestamp, \"May not withdraw early\");\r\n\r\n        stakingToken.transfer(address(msg.sender), _amount);\r\n\r\n        setBalance(payable(msg.sender), userAmount - _amount);\r\n\r\n        if(userAmount > 0){\r\n            holderUnlockTime[msg.sender] = block.timestamp + lockDuration;\r\n        } else {\r\n            holderUnlockTime[msg.sender] = 0;\r\n        }\r\n\r\n        emit Withdraw(msg.sender, _amount);\r\n    }\r\n\r\n    function withdrawAll() public nonReentrant {\r\n        uint256 userAmount = holderBalance[msg.sender];\r\n        require(userAmount > 0, \"Not a holder\");\r\n        require(holderUnlockTime[msg.sender] <= block.timestamp, \"May not withdraw early\");\r\n        \r\n        stakingToken.transfer(address(msg.sender), userAmount);\r\n\r\n        setBalance(payable(msg.sender), 0);\r\n        holderUnlockTime[msg.sender] = 0;\r\n\r\n        emit Withdraw(msg.sender, userAmount);\r\n    }\r\n\r\n    function claim() external nonReentrant {\r\n        processAccount(payable(msg.sender), false);\r\n    }\r\n\r\n    function compound(uint256 minOutput) external nonReentrant {\r\n        uint256 userAmount = holderBalance[msg.sender];\r\n        uint256 amountEthForCompound = _withdrawDividendOfUserForCompound(payable(msg.sender));\r\n        if(amountEthForCompound > 0){\r\n            uint256 initialBalance = stakingToken.balanceOf(address(this));\r\n            buyBackTokens(amountEthForCompound, minOutput);\r\n            uint256 amountTransferred = stakingToken.balanceOf(address(this)) - initialBalance;\r\n            setBalance(payable(msg.sender), userAmount + amountTransferred);\r\n        } else {\r\n            revert(\"No rewards\");\r\n        }\r\n    }\r\n\r\n    function _withdrawDividendOfUserForCompound(address payable user) internal returns (uint256 _withdrawableDividend) {\r\n        _withdrawableDividend = withdrawableDividendOf(user);\r\n        if (_withdrawableDividend > 0) {\r\n            withdrawnDividends[user] = withdrawnDividends[user] + _withdrawableDividend;\r\n            emit DividendWithdrawn(user, _withdrawableDividend);\r\n        }\r\n    }\r\n\r\n    function buyBackTokens(uint256 ethAmountInWei, uint256 minOut) internal {\r\n        // generate the uniswap pair path of weth -> eth\r\n        address[] memory path = new address[](2);\r\n        path[0] = dexRouter.WETH();\r\n        path[1] = address(stakingToken);\r\n\r\n        // make the swap\r\n        dexRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: ethAmountInWei}(\r\n            minOut,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    // helper views\r\n\r\n    function getExpectedCompoundOutputByEthAmount(uint256 rewardAmount) external view returns(uint256) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = dexRouter.WETH();\r\n        path[1] = address(stakingToken);\r\n        uint256[] memory amounts = dexRouter.getAmountsOut(rewardAmount, path);\r\n        return amounts[1];\r\n    }\r\n\r\n    function getExpectedCompoundOutputByWallet(address wallet) external view returns(uint256) {\r\n        uint256 rewardAmount = withdrawableDividendOf(wallet);\r\n        address[] memory path = new address[](2);\r\n        path[0] = dexRouter.WETH();\r\n        path[1] = address(stakingToken);\r\n        uint256[] memory amounts = dexRouter.getAmountsOut(rewardAmount, path);\r\n        return amounts[1];\r\n    }\r\n }", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockTimeInDays\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"automatic\",\"type\":\"bool\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"DividendWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"DividendsDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"accumulativeDividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minOutput\",\"type\":\"uint256\"}],\"name\":\"compound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dexRouter\",\"outputs\":[{\"internalType\":\"contract IDexRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeDividends\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"dividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"dividendTokenBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableDividends\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDividends\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"getExpectedCompoundOutputByEthAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getExpectedCompoundOutputByWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDividendsDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"holderBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"holderUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDividendsDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawDividend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"withdrawableDividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"withdrawnDividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RevenueStaking", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000002b7b3ee07bf35bfd99634c8481931b2c1d2ab7fc0000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d312b6601e614a6d51c738ed9f19fb89f0ff9238f0afb3089cbc1359e240f4c6"}