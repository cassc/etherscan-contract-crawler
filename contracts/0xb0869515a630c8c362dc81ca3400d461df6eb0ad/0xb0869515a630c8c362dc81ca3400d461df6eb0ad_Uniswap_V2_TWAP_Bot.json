{"SourceCode": "# @version 0.3.9\r\n\r\n\"\"\"\r\n@title Uniswap V2 TWAP Bot\r\n@license Apache 2.0\r\n@author Volume.finance\r\n\"\"\"\r\n\r\nstruct SwapInfo:\r\n    path: DynArray[address, MAX_SIZE]\r\n    amount: uint256\r\n\r\nstruct Deposit:\r\n    depositor: address\r\n    path: DynArray[address, MAX_SIZE]\r\n    input_amount: uint256\r\n    number_trades: uint256\r\n    interval: uint256\r\n    remaining_counts: uint256\r\n    starting_time: uint256\r\n\r\ninterface UniswapV2Router:\r\n    def WETH() -> address: pure\r\n    def swapExactETHForTokensSupportingFeeOnTransferTokens(amountOutMin: uint256, path: DynArray[address, MAX_SIZE], to: address, deadline: uint256): payable\r\n    def swapExactTokensForTokensSupportingFeeOnTransferTokens(amountIn: uint256, amountOutMin: uint256, path: DynArray[address, MAX_SIZE], to: address, deadline: uint256): nonpayable\r\n    def swapExactTokensForETHSupportingFeeOnTransferTokens(amountIn: uint256, amountOutMin: uint256, path: DynArray[address, MAX_SIZE], to: address, deadline: uint256): nonpayable\r\n\r\ninterface ERC20:\r\n    def balanceOf(_owner: address) -> uint256: view\r\n\r\nVETH: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE # Virtual ETH\r\nWETH: immutable(address)\r\nROUTER: immutable(address)\r\nMAX_SIZE: constant(uint256) = 8\r\nDENOMINATOR: constant(uint256) = 10000\r\ncompass_evm: public(address)\r\ndeposit_list: public(HashMap[uint256, Deposit])\r\nnext_deposit: public(uint256)\r\nrefund_wallet: public(address)\r\nfee: public(uint256)\r\npaloma: public(bytes32)\r\nservice_fee_collector: public(address)\r\nservice_fee: public(uint256)\r\n\r\nevent Deposited:\r\n    deposit_id: uint256\r\n    token0: address\r\n    token1: address\r\n    input_amount: uint256\r\n    number_trades: uint256\r\n    interval: uint256\r\n    starting_time: uint256\r\n    depositor: address\r\n\r\nevent Swapped:\r\n    deposit_id: uint256\r\n    remaining_counts: uint256\r\n    amount: uint256\r\n    out_amount: uint256\r\n\r\nevent Canceled:\r\n    deposit_id: uint256\r\n\r\nevent UpdateCompass:\r\n    old_compass: address\r\n    new_compass: address\r\n\r\nevent UpdateRefundWallet:\r\n    old_refund_wallet: address\r\n    new_refund_wallet: address\r\n\r\nevent UpdateFee:\r\n    old_fee: uint256\r\n    new_fee: uint256\r\n\r\nevent SetPaloma:\r\n    paloma: bytes32\r\n\r\nevent UpdateServiceFeeCollector:\r\n    old_service_fee_collector: address\r\n    new_service_fee_collector: address\r\n\r\nevent UpdateServiceFee:\r\n    old_service_fee: uint256\r\n    new_service_fee: uint256\r\n\r\n@external\r\ndef __init__(_compass_evm: address, router: address, _refund_wallet: address, _fee: uint256, _service_fee_collector: address, _service_fee: uint256):\r\n    self.compass_evm = _compass_evm\r\n    ROUTER = router\r\n    WETH = UniswapV2Router(ROUTER).WETH()\r\n    self.refund_wallet = _refund_wallet\r\n    self.fee = _fee\r\n    self.service_fee_collector = _service_fee_collector\r\n    assert _service_fee < DENOMINATOR\r\n    self.service_fee = _service_fee\r\n    log UpdateCompass(empty(address), _compass_evm)\r\n    log UpdateRefundWallet(empty(address), _refund_wallet)\r\n    log UpdateFee(0, _fee)\r\n    log UpdateServiceFeeCollector(empty(address), _service_fee_collector)\r\n    log UpdateServiceFee(0, _service_fee)\r\n\r\n@internal\r\ndef _safe_transfer_from(_token: address, _from: address, _to: address, _value: uint256):\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        _abi_encode(_from, _to, _value, method_id=method_id(\"transferFrom(address,address,uint256)\")),\r\n        max_outsize=32\r\n    )  # dev: failed transferFrom\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool), \"failed transferFrom\"  # dev: failed transferFrom\r\n\r\n@external\r\n@payable\r\n@nonreentrant('lock')\r\ndef deposit(swap_infos: DynArray[SwapInfo, MAX_SIZE], number_trades: uint256, interval: uint256, starting_time: uint256):\r\n    _value: uint256 = msg.value\r\n    _fee: uint256 = self.fee\r\n    if _fee > 0:\r\n        _fee = _fee * number_trades\r\n        assert _value >= _fee, \"Insufficient fee\"\r\n        send(self.refund_wallet, _fee)\r\n        _value = unsafe_sub(_value, _fee)\r\n    _next_deposit: uint256 = self.next_deposit\r\n    for swap_info in swap_infos:\r\n        last_index: uint256 = unsafe_sub(len(swap_info.path), 1)\r\n        amount: uint256 = 0\r\n        if swap_info.path[0] == VETH:\r\n            amount = swap_info.amount\r\n            assert _value >= amount, \"Insufficient deposit\"\r\n            _value = unsafe_sub(_value, amount)\r\n        else:\r\n            amount = ERC20(swap_info.path[0]).balanceOf(self)\r\n            self._safe_transfer_from(swap_info.path[0], msg.sender, self, swap_info.amount)\r\n            amount = ERC20(swap_info.path[0]).balanceOf(self) - amount\r\n        _starting_time: uint256 = starting_time\r\n        if starting_time <= block.timestamp:\r\n            _starting_time = block.timestamp\r\n        assert number_trades > 0, \"Wrong trade count\"\r\n        self.deposit_list[_next_deposit] = Deposit({\r\n            depositor: msg.sender,\r\n            path: swap_info.path,\r\n            input_amount: swap_info.amount,\r\n            number_trades: number_trades,\r\n            interval: interval,\r\n            remaining_counts: number_trades,\r\n            starting_time: _starting_time\r\n        })\r\n        log Deposited(_next_deposit, swap_info.path[0], swap_info.path[last_index], amount, number_trades, interval, _starting_time, msg.sender)\r\n        _next_deposit = unsafe_add(_next_deposit, 1)\r\n    self.next_deposit = _next_deposit\r\n    if _value > 0:\r\n        send(msg.sender, _value)\r\n\r\n@internal\r\ndef _safe_approve(_token: address, _to: address, _value: uint256):\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        _abi_encode(_to, _value, method_id=method_id(\"approve(address,uint256)\")),\r\n        max_outsize=32\r\n    )  # dev: failed approve\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool), \"failed approve\"  # dev: failed approve\r\n\r\n@internal\r\ndef _safe_transfer(_token: address, _to: address, _value: uint256):\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        _abi_encode(_to, _value, method_id=method_id(\"transfer(address,uint256)\")),\r\n        max_outsize=32\r\n    )  # dev: failed transfer\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool) # dev: failed transfer\r\n\r\n@internal\r\ndef _swap(deposit_id: uint256, remaining_count: uint256, amount_out_min: uint256) -> uint256:\r\n    _deposit: Deposit = self.deposit_list[deposit_id]\r\n    assert _deposit.remaining_counts > 0 and _deposit.remaining_counts == remaining_count, \"wrong count\"\r\n    _amount: uint256 = _deposit.input_amount / _deposit.remaining_counts\r\n    _deposit.input_amount -= _amount\r\n    _deposit.remaining_counts -= 1\r\n    self.deposit_list[deposit_id] = _deposit\r\n    _out_amount: uint256 = 0\r\n    _path: DynArray[address, MAX_SIZE] = _deposit.path\r\n    last_index: uint256 = unsafe_sub(len(_deposit.path), 1)\r\n    if _deposit.path[0] == VETH:\r\n        _path[0] = WETH\r\n        _out_amount = ERC20(_deposit.path[last_index]).balanceOf(self)\r\n        UniswapV2Router(ROUTER).swapExactETHForTokensSupportingFeeOnTransferTokens(amount_out_min, _path, self, block.timestamp, value=_amount)\r\n        _out_amount = ERC20(_deposit.path[last_index]).balanceOf(self) - _out_amount\r\n    else:\r\n        self._safe_approve(_deposit.path[0], ROUTER, _amount)\r\n        if _deposit.path[last_index] == VETH:\r\n            _path[last_index] = WETH\r\n            _out_amount = self.balance\r\n            UniswapV2Router(ROUTER).swapExactTokensForETHSupportingFeeOnTransferTokens(_amount, amount_out_min, _path, self, block.timestamp)\r\n            _out_amount = self.balance - _out_amount\r\n        else:\r\n            _out_amount = ERC20(_deposit.path[last_index]).balanceOf(self)\r\n            UniswapV2Router(ROUTER).swapExactTokensForTokensSupportingFeeOnTransferTokens(_amount, amount_out_min, _path, self, block.timestamp)\r\n            _out_amount = ERC20(_deposit.path[last_index]).balanceOf(self) - _out_amount\r\n    _service_fee: uint256 = self.service_fee\r\n    service_fee_amount: uint256 = 0\r\n    if _service_fee > 0:\r\n        service_fee_amount = unsafe_div(_out_amount * _service_fee, DENOMINATOR)\r\n    if _deposit.path[last_index] == VETH:\r\n        if service_fee_amount > 0:\r\n            send(self.service_fee_collector, service_fee_amount)\r\n            send(_deposit.depositor, unsafe_sub(_out_amount, service_fee_amount))\r\n        else:\r\n            send(_deposit.depositor, _out_amount)\r\n    else:\r\n        if service_fee_amount > 0:\r\n            self._safe_transfer(_deposit.path[last_index], self.service_fee_collector, service_fee_amount)\r\n            self._safe_transfer(_deposit.path[last_index], _deposit.depositor, unsafe_sub(_out_amount, service_fee_amount))\r\n        else:\r\n            self._safe_transfer(_deposit.path[last_index], _deposit.depositor, _out_amount)\r\n    log Swapped(deposit_id, _deposit.remaining_counts, _amount, _out_amount)\r\n    return _out_amount\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef multiple_swap(deposit_id: DynArray[uint256, MAX_SIZE], remaining_counts: DynArray[uint256, MAX_SIZE], amount_out_min: DynArray[uint256, MAX_SIZE]):\r\n    assert msg.sender == self.compass_evm, \"Unauthorized\"\r\n    _len: uint256 = len(deposit_id)\r\n    assert _len == len(amount_out_min) and _len == len(remaining_counts), \"Validation error\"\r\n    _len = unsafe_add(unsafe_mul(unsafe_add(_len, 2), 96), 36)\r\n    assert len(msg.data) == _len, \"invalid payload\"\r\n    assert self.paloma == convert(slice(msg.data, unsafe_sub(_len, 32), 32), bytes32), \"invalid paloma\"\r\n    for i in range(MAX_SIZE):\r\n        if i >= len(deposit_id):\r\n            break\r\n        self._swap(deposit_id[i], remaining_counts[i], amount_out_min[i])\r\n\r\n@external\r\ndef multiple_swap_view(deposit_id: DynArray[uint256, MAX_SIZE], remaining_counts: DynArray[uint256, MAX_SIZE]) -> DynArray[uint256, MAX_SIZE]:\r\n    assert msg.sender == empty(address) # only for view function\r\n    _len: uint256 = len(deposit_id)\r\n    res: DynArray[uint256, MAX_SIZE] = []\r\n    for i in range(MAX_SIZE):\r\n        if i >= len(deposit_id):\r\n            break\r\n        res.append(self._swap(deposit_id[i], remaining_counts[i], 1))\r\n    return res\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef cancel(deposit_id: uint256):\r\n    _deposit: Deposit = self.deposit_list[deposit_id]\r\n    assert _deposit.depositor == msg.sender, \"Unauthorized\"\r\n    assert _deposit.input_amount > 0, \"all traded\"\r\n    if _deposit.path[0] == VETH:\r\n        send(msg.sender, _deposit.input_amount)\r\n    else:\r\n        self._safe_transfer(_deposit.path[0], msg.sender, _deposit.input_amount)\r\n    _deposit.input_amount = 0\r\n    _deposit.remaining_counts = 0\r\n    self.deposit_list[deposit_id] = _deposit\r\n    log Canceled(deposit_id)\r\n\r\n@external\r\ndef update_compass(new_compass: address):\r\n    assert msg.sender == self.compass_evm and len(msg.data) == 68 and convert(slice(msg.data, 36, 32), bytes32) == self.paloma, \"Unauthorized\"\r\n    self.compass_evm = new_compass\r\n    log UpdateCompass(msg.sender, new_compass)\r\n\r\n@external\r\ndef update_refund_wallet(new_refund_wallet: address):\r\n    assert msg.sender == self.compass_evm and len(msg.data) == 68 and convert(slice(msg.data, 36, 32), bytes32) == self.paloma, \"Unauthorized\"\r\n    old_refund_wallet: address = self.refund_wallet\r\n    self.refund_wallet = new_refund_wallet\r\n    log UpdateRefundWallet(old_refund_wallet, new_refund_wallet)\r\n\r\n@external\r\ndef update_fee(new_fee: uint256):\r\n    assert msg.sender == self.compass_evm and len(msg.data) == 68 and convert(slice(msg.data, 36, 32), bytes32) == self.paloma, \"Unauthorized\"\r\n    old_fee: uint256 = self.fee\r\n    self.fee = new_fee\r\n    log UpdateFee(old_fee, new_fee)\r\n\r\n@external\r\ndef set_paloma():\r\n    assert msg.sender == self.compass_evm and self.paloma == empty(bytes32) and len(msg.data) == 36, \"Invalid\"\r\n    _paloma: bytes32 = convert(slice(msg.data, 4, 32), bytes32)\r\n    self.paloma = _paloma\r\n    log SetPaloma(_paloma)\r\n\r\n@external\r\ndef update_service_fee_collector(new_service_fee_collector: address):\r\n    assert msg.sender == self.compass_evm and len(msg.data) == 68 and convert(slice(msg.data, 36, 32), bytes32) == self.paloma, \"Unauthorized\"\r\n    old_service_fee_collector: address = self.service_fee_collector\r\n    self.service_fee_collector = new_service_fee_collector\r\n    log UpdateServiceFeeCollector(old_service_fee_collector, new_service_fee_collector)\r\n\r\n@external\r\ndef update_service_fee(new_service_fee: uint256):\r\n    assert msg.sender == self.compass_evm and len(msg.data) == 68 and convert(slice(msg.data, 36, 32), bytes32) == self.paloma, \"Unauthorized\"\r\n    assert new_service_fee < DENOMINATOR\r\n    old_service_fee: uint256 = self.service_fee\r\n    self.service_fee = new_service_fee\r\n    log UpdateServiceFee(old_service_fee, new_service_fee)\r\n\r\n@external\r\n@payable\r\ndef __default__():\r\n    assert msg.sender == ROUTER", "ABI": "[{\"name\":\"Deposited\",\"inputs\":[{\"name\":\"deposit_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"token0\",\"type\":\"address\",\"indexed\":false},{\"name\":\"token1\",\"type\":\"address\",\"indexed\":false},{\"name\":\"input_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"number_trades\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"interval\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"starting_time\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"depositor\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Swapped\",\"inputs\":[{\"name\":\"deposit_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"remaining_counts\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"out_amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Canceled\",\"inputs\":[{\"name\":\"deposit_id\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateCompass\",\"inputs\":[{\"name\":\"old_compass\",\"type\":\"address\",\"indexed\":false},{\"name\":\"new_compass\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateRefundWallet\",\"inputs\":[{\"name\":\"old_refund_wallet\",\"type\":\"address\",\"indexed\":false},{\"name\":\"new_refund_wallet\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateFee\",\"inputs\":[{\"name\":\"old_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"new_fee\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetPaloma\",\"inputs\":[{\"name\":\"paloma\",\"type\":\"bytes32\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateServiceFeeCollector\",\"inputs\":[{\"name\":\"old_service_fee_collector\",\"type\":\"address\",\"indexed\":false},{\"name\":\"new_service_fee_collector\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateServiceFee\",\"inputs\":[{\"name\":\"old_service_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"new_service_fee\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_compass_evm\",\"type\":\"address\"},{\"name\":\"router\",\"type\":\"address\"},{\"name\":\"_refund_wallet\",\"type\":\"address\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_service_fee_collector\",\"type\":\"address\"},{\"name\":\"_service_fee\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"swap_infos\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"path\",\"type\":\"address[]\"},{\"name\":\"amount\",\"type\":\"uint256\"}]},{\"name\":\"number_trades\",\"type\":\"uint256\"},{\"name\":\"interval\",\"type\":\"uint256\"},{\"name\":\"starting_time\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"multiple_swap\",\"inputs\":[{\"name\":\"deposit_id\",\"type\":\"uint256[]\"},{\"name\":\"remaining_counts\",\"type\":\"uint256[]\"},{\"name\":\"amount_out_min\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"multiple_swap_view\",\"inputs\":[{\"name\":\"deposit_id\",\"type\":\"uint256[]\"},{\"name\":\"remaining_counts\",\"type\":\"uint256[]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"cancel\",\"inputs\":[{\"name\":\"deposit_id\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_compass\",\"inputs\":[{\"name\":\"new_compass\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_refund_wallet\",\"inputs\":[{\"name\":\"new_refund_wallet\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_fee\",\"inputs\":[{\"name\":\"new_fee\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_paloma\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_service_fee_collector\",\"inputs\":[{\"name\":\"new_service_fee_collector\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_service_fee\",\"inputs\":[{\"name\":\"new_service_fee\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"compass_evm\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"deposit_list\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"depositor\",\"type\":\"address\"},{\"name\":\"path\",\"type\":\"address[]\"},{\"name\":\"input_amount\",\"type\":\"uint256\"},{\"name\":\"number_trades\",\"type\":\"uint256\"},{\"name\":\"interval\",\"type\":\"uint256\"},{\"name\":\"remaining_counts\",\"type\":\"uint256\"},{\"name\":\"starting_time\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"next_deposit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"refund_wallet\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"paloma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"service_fee_collector\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"service_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]", "ContractName": "Uniswap V2 TWAP Bot", "CompilerVersion": "vyper:0.3.9", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "000000000000000000000000a00cf3504ffacff301e4973e21b44c052d0871570000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d0000000000000000000000006dc0a87638cd75cc700ccdb226c7ab6c054bc70b00000000000000000000000000000000000000000000000000354a6ba7a180000000000000000000000000007a16ff8270133f063aab6c9977183d9e728354280000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": ""}